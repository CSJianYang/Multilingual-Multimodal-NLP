[
    {
        "title": "Restore IP Addresses",
        "question_content": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\n\tFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n&nbsp;\nExample 1:\n\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\n\nExample 2:\n\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\n\nExample 3:\n\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 20\n\ts consists of digits only.",
        "solutions": [
            {
                "id": 30972,
                "title": "who-can-beat-this-code",
                "content": "\\n        // c++  code\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> ret;\\n            string ans;\\n            \\n            for (int a=1; a<=3; a++)\\n            for (int b=1; b<=3; b++)\\n            for (int c=1; c<=3; c++)\\n            for (int d=1; d<=3; d++)\\n                if (a+b+c+d == s.length()) {\\n                    int A = stoi(s.substr(0, a));\\n                    int B = stoi(s.substr(a, b));\\n                    int C = stoi(s.substr(a+b, c));\\n                    int D = stoi(s.substr(a+b+c, d));\\n                    if (A<=255 && B<=255 && C<=255 && D<=255)\\n                        if ( (ans=to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D)).length() == s.length()+3)\\n                            ret.push_back(ans);\\n                }    \\n            \\n            return ret;\\n        }",
                "solutionTags": [],
                "code": "\\n        // c++  code\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> ret;\\n            string ans;\\n            \\n            for (int a=1; a<=3; a++)\\n            for (int b=1; b<=3; b++)\\n            for (int c=1; c<=3; c++)\\n            for (int d=1; d<=3; d++)\\n                if (a+b+c+d == s.length()) {\\n                    int A = stoi(s.substr(0, a));\\n                    int B = stoi(s.substr(a, b));\\n                    int C = stoi(s.substr(a+b, c));\\n                    int D = stoi(s.substr(a+b+c, d));\\n                    if (A<=255 && B<=255 && C<=255 && D<=255)\\n                        if ( (ans=to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D)).length() == s.length()+3)\\n                            ret.push_back(ans);\\n                }    \\n            \\n            return ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 30949,
                "title": "my-code-in-java",
                "content": "    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<String>();\\n            int len = s.length();\\n            for(int i = 1; i<4 && i<len-2; i++){\\n                for(int j = i+1; j<i+4 && j<len-1; j++){\\n                    for(int k = j+1; k<j+4 && k<len; k++){\\n                        String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);\\n                        if(isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)){\\n                            res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4);\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        public boolean isValid(String s){\\n            if(s.length()>3 || s.length()==0 || (s.charAt(0)=='0' && s.length()>1) || Integer.parseInt(s)>255)\\n                return false;\\n            return true;\\n        }\\n    }\\n\\n3-loop divides the string s into 4 substring: s1, s2, s3, s4. Check if each substring is valid.\\nIn isValid, strings whose length greater than 3 or equals to 0 is not valid; or if the string's length is longer than 1 and the first letter is '0' then it's invalid; or the string whose integer representation greater than 255 is invalid.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<String>();\\n            int len = s.length();\\n            for(int i = 1; i<4 && i<len-2; i++){\\n                for(int j = i+1; j<i+4 && j<len-1; j++){\\n                    for(int k = j+1; k<j+4 && k<len; k++){\\n                        String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);\\n                        if(isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)){\\n                            res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 30944,
                "title": "very-simple-dfs-solution",
                "content": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> solutions = new ArrayList<String>();\\n        restoreIp(s, solutions, 0, \"\", 0);\\n        return solutions;\\n    }\\n    \\n    private void restoreIp(String ip, List<String> solutions, int idx, String restored, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && idx == ip.length()) solutions.add(restored);\\n        \\n        for (int i=1; i<4; i++) {\\n            if (idx+i > ip.length()) break;\\n            String s = ip.substring(idx,idx+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)) continue;\\n            restoreIp(ip, solutions, idx+i, restored+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> solutions = new ArrayList<String>();\\n        restoreIp(s, solutions, 0, \"\", 0);\\n        return solutions;\\n    }\\n    \\n    private void restoreIp(String ip, List<String> solutions, int idx, String restored, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && idx == ip.length()) solutions.add(restored);\\n        \\n        for (int i=1; i<4; i++) {\\n            if (idx+i > ip.length()) break;\\n            String s = ip.substring(idx,idx+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)) continue;\\n            restoreIp(ip, solutions, idx+i, restored+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31140,
                "title": "python-easy-to-understand-solution-backtracking",
                "content": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        res = []\\n        self.dfs(s, 0, \"\", res)\\n        return res\\n    \\n    def dfs(self, s, idx, path, res):\\n        if idx > 4:\\n            return \\n        if idx == 4 and not s:\\n            res.append(path[:-1])\\n            return \\n        for i in range(1, len(s)+1):\\n            if s[:i]==\\'0\\' or (s[0]!=\\'0\\' and 0 < int(s[:i]) < 256):\\n                self.dfs(s[i:], idx+1, path+s[:i]+\".\", res)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        res = []\\n        self.dfs(s, 0, \"\", res)\\n        return res\\n    \\n    def dfs(self, s, idx, path, res):\\n        if idx > 4:\\n            return \\n        if idx == 4 and not s:\\n            res.append(path[:-1])\\n            return \\n        for i in range(1, len(s)+1):\\n            if s[:i]==\\'0\\' or (s[0]!=\\'0\\' and 0 < int(s[:i]) < 256):\\n                self.dfs(s[i:], idx+1, path+s[:i]+\".\", res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079368,
                "title": "c-easy-solution-iterative-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFIterative Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/KfMMaxgF/shared\" frameBorder=\"0\" width=\"800\" height=\"1010\"></iframe>\\n\\n***Time Complexity : `O(1)`\\nSpace Complexity : `O(1)`***\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFIterative Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/KfMMaxgF/shared\" frameBorder=\"0\" width=\"800\" height=\"1010\"></iframe>\\n\\n***Time Complexity : `O(1)`\\nSpace Complexity : `O(1)`***\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3079183,
                "title": "easy-explanation-with-video-and-pics-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Screenshot 2023-01-21 at 6.45.12 AM.png](https://assets.leetcode.com/users/images/a62d9067-6cbb-417d-8f3f-bf9fb150d0d1_1674263738.058996.png)\\n\\nLets take a very simple scenario where we insert just one dot.\\nQuick Observation: The length of the string can be 1, 2 or 3 as the range is 0,255.\\n\\nOnce the function has inserted the dot it will verify if the string is valid or not, in the above example 355 is not valid, so we can discard it.\\n\\nHowever we have one more invalid case i.e 3.555 The approach we can use here is though we are inserting one dot we will make it to insert 2 dots so that the same function will check the validitity of the second part and remove the last dot from ans.\\n\\nThe same approach goes for 3 dots, at each step add a dot --> generate valid answers and pass it down again. \\n\\n![Screenshot 2023-01-21 at 6.51.38 AM.png](https://assets.leetcode.com/users/images/b58bfe69-5df9-4dfb-8d17-ea1cf7e3551b_1674264111.1136658.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse an additional input to the function that is index, which says the function where the string starts from, it is as good as forgetting the already dotted part of the string.\\n\\n\\nAdditional Improvement: Check if the string length is greater than 12, than its completely invalid, Similarly if already 2 dots inserted and the remaining string length is 7 its invalid as well.\\n\\nhttps://youtu.be/h2HmKNdmZ_c\\n\\n![sfw-please-upvote-me-v0-u5cacra0rnca1.webp](https://assets.leetcode.com/users/images/15fbfe1e-a57a-475a-a229-a438ed3f1672_1674264427.05538.webp)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    String str;\\n    public List<String> restoreIpAddresses(String s) {\\n        str = s;\\n        magical(\"\", 0, 0);\\n        return ans;\\n    } \\n\\n    void magical( String path, int index, int dots) {\\n        if (dots > 4) return;\\n        if (dots == 4 && index >= str.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int length = 1; length <= 3 && index + length <= str.length(); length++) {\\n            String num = str.substring(index, index + length);\\n            if (num.charAt(0) == \\'0\\' && length != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                magical( path + str.substring(index, index + length) + \".\", index + length,dots + 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    String str;\\n    public List<String> restoreIpAddresses(String s) {\\n        str = s;\\n        magical(\"\", 0, 0);\\n        return ans;\\n    } \\n\\n    void magical( String path, int index, int dots) {\\n        if (dots > 4) return;\\n        if (dots == 4 && index >= str.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int length = 1; length <= 3 && index + length <= str.length(); length++) {\\n            String num = str.substring(index, index + length);\\n            if (num.charAt(0) == \\'0\\' && length != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                magical( path + str.substring(index, index + length) + \".\", index + length,dots + 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079269,
                "title": "beats-100-0ms-easy-solution-fully-explained-c-python3-java",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful.\\n\\n```\\n# Intuition\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can\\'t be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n# Approach : Backtracking\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        int sz = s.size();\\n        for(int i=ind;i<min(ind+3, sz);i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def valid(self, temp: str) -> bool:\\n        if len(temp) > 3 or len(temp) == 0:\\n            return False\\n        if len(temp) > 1 and temp[0] == \\'0\\':\\n            return False\\n        if len(temp) and int(temp) > 255:\\n            return False\\n        return True\\n\\n    def solve(self, ans, output, ind, s, dots):\\n        if dots == 3:\\n            if self.valid(s[ind:]):\\n                ans.append(output + s[ind:])\\n            return\\n        for i in range(ind, min(ind+3, len(s))):\\n            if self.valid(s[ind:i+1]):\\n                new_output = output + s[ind:i+1] + \\'.\\'\\n                self.solve(ans, new_output, i+1, s, dots+1)\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.solve(ans, \"\", 0, s, 0)\\n        return ans\\n\\n```\\n```Java []\\n private List<String> ipes;\\n   private int l;\\n   public List<String> restoreIpAddresses(String s) {\\n       ipes = new ArrayList<>();\\n       l = s.length();\\n       f(s, 0, \"\", 0);\\n       return ipes;\\n   }\\n   \\n   private boolean isIp(String ip){\\n       if(ip.length() > 3 || ip.length() == 0) return false;\\n       if(ip.length() > 1 && ip.charAt(0) == \\'0\\') return false;\\n       if(ip.length() > 0 && Integer.parseInt(ip) > 255) return false;\\n       return true; \\n   }\\n\\n   private void f(String s, int index, String ip, int dot){\\n       //base case\\n       if(dot == 3){\\n           if(isIp(s.substring(index))) {\\n               ip += s.substring(index);\\n               ipes.add(ip);\\n           }\\n           return;\\n       }\\n\\n       //do all the stuff\\n       for(int i = index; i < l; i++){\\n           if(isIp(s.substring(index, i +1))){\\n               int k = s.substring(index, i+1).length();\\n               ip += s.substring(index, i+1) + \".\";\\n               f(s, i+1, ip, dot+1);\\n               ip = ip.substring(0, ip.length() - k -1);\\n           }\\n       }\\n   }\\n}\\n```\\n```\\n                               Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        int sz = s.size();\\n        for(int i=ind;i<min(ind+3, sz);i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def valid(self, temp: str) -> bool:\\n        if len(temp) > 3 or len(temp) == 0:\\n            return False\\n        if len(temp) > 1 and temp[0] == \\'0\\':\\n            return False\\n        if len(temp) and int(temp) > 255:\\n            return False\\n        return True\\n\\n    def solve(self, ans, output, ind, s, dots):\\n        if dots == 3:\\n            if self.valid(s[ind:]):\\n                ans.append(output + s[ind:])\\n            return\\n        for i in range(ind, min(ind+3, len(s))):\\n            if self.valid(s[ind:i+1]):\\n                new_output = output + s[ind:i+1] + \\'.\\'\\n                self.solve(ans, new_output, i+1, s, dots+1)\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.solve(ans, \"\", 0, s, 0)\\n        return ans\\n\\n```\n```Java []\\n private List<String> ipes;\\n   private int l;\\n   public List<String> restoreIpAddresses(String s) {\\n       ipes = new ArrayList<>();\\n       l = s.length();\\n       f(s, 0, \"\", 0);\\n       return ipes;\\n   }\\n   \\n   private boolean isIp(String ip){\\n       if(ip.length() > 3 || ip.length() == 0) return false;\\n       if(ip.length() > 1 && ip.charAt(0) == \\'0\\') return false;\\n       if(ip.length() > 0 && Integer.parseInt(ip) > 255) return false;\\n       return true; \\n   }\\n\\n   private void f(String s, int index, String ip, int dot){\\n       //base case\\n       if(dot == 3){\\n           if(isIp(s.substring(index))) {\\n               ip += s.substring(index);\\n               ipes.add(ip);\\n           }\\n           return;\\n       }\\n\\n       //do all the stuff\\n       for(int i = index; i < l; i++){\\n           if(isIp(s.substring(index, i +1))){\\n               int k = s.substring(index, i+1).length();\\n               ip += s.substring(index, i+1) + \".\";\\n               f(s, i+1, ip, dot+1);\\n               ip = ip.substring(0, ip.length() - k -1);\\n           }\\n       }\\n   }\\n}\\n```\n```\\n                               Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30998,
                "title": "my-concise-ac-java-code",
                "content": "the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1~3 digits and it must be <255. \\n\\n    static List<String> restoreIpAddresses(String s) {\\n    \\tList<String> ans = new ArrayList<String>();\\n    \\tint len = s.length();\\n    \\tfor (int i = 1; i <=3; ++i){  // first cut\\n    \\t\\tif (len-i > 9) continue;    \\t\\t\\n    \\t\\tfor (int j = i+1; j<=i+3; ++j){  //second cut\\n    \\t\\t\\tif (len-j > 6) continue;    \\t\\t\\t\\n    \\t\\t\\tfor (int k = j+1; k<=j+3 && k<len; ++k){  // third cut\\n    \\t\\t\\t\\tint a,b,c,d;                // the four int's seperated by \".\"\\n    \\t\\t\\t\\ta = Integer.parseInt(s.substring(0,i));  \\n    \\t\\t\\t\\tb = Integer.parseInt(s.substring(i,j)); // notice that \"01\" can be parsed into 1. Need to deal with that later.\\n    \\t\\t\\t\\tc = Integer.parseInt(s.substring(j,k));\\n    \\t\\t\\t\\td = Integer.parseInt(s.substring(k));\\n    \\t\\t\\t\\tif (a>255 || b>255 || c>255 || d>255) continue; \\n    \\t\\t\\t\\tString ip = a+\".\"+b+\".\"+c+\".\"+d;\\n    \\t\\t\\t\\tif (ip.length()<len+3) continue;  // this is to reject those int's parsed from \"01\" or \"00\"-like substrings\\n    \\t\\t\\t\\tans.add(ip);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [],
                "code": "the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1~3 digits and it must be <255. \\n\\n    static List<String> restoreIpAddresses(String s) {\\n    \\tList<String> ans = new ArrayList<String>();\\n    \\tint len = s.length();\\n    \\tfor (int i = 1; i <=3; ++i){  // first cut\\n    \\t\\tif (len-i > 9) continue;    \\t\\t\\n    \\t\\tfor (int j = i+1; j<=i+3; ++j){  //second cut\\n    \\t\\t\\tif (len-j > 6) continue;    \\t\\t\\t\\n    \\t\\t\\tfor (int k = j+1; k<=j+3 && k<len; ++k){  // third cut\\n    \\t\\t\\t\\tint a,b,c,d;                // the four int's seperated by \".\"\\n    \\t\\t\\t\\ta = Integer.parseInt(s.substring(0,i));  \\n    \\t\\t\\t\\tb = Integer.parseInt(s.substring(i,j)); // notice that \"01\" can be parsed into 1. Need to deal with that later.\\n    \\t\\t\\t\\tc = Integer.parseInt(s.substring(j,k));\\n    \\t\\t\\t\\td = Integer.parseInt(s.substring(k));\\n    \\t\\t\\t\\tif (a>255 || b>255 || c>255 || d>255) continue; \\n    \\t\\t\\t\\tString ip = a+\".\"+b+\".\"+c+\".\"+d;\\n    \\t\\t\\t\\tif (ip.length()<len+3) continue;  // this is to reject those int's parsed from \"01\" or \"00\"-like substrings\\n    \\t\\t\\t\\tans.add(ip);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31098,
                "title": "easy-java-code-of-backtracking-within-16-lines",
                "content": "        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<>();\\n            helper(s,\"\",res,0);\\n            return res;\\n        }\\n        public void helper(String s, String tmp, List<String> res,int n){\\n            if(n==4){\\n                if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1));\\n                //substring here to get rid of last '.'\\n                return;\\n            }\\n            for(int k=1;k<=3;k++){\\n                if(s.length()<k) continue;\\n                int val = Integer.parseInt(s.substring(0,k));\\n                if(val>255 || k!=String.valueOf(val).length()) continue;\\n                /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/\\n                helper(s.substring(k),tmp+s.substring(0,k)+\".\",res,n+1);\\n            }\\n        }",
                "solutionTags": [],
                "code": "        public List<String> restoreIpAddresses(String s) {\\n            List<String> res = new ArrayList<>();\\n            helper(s,\"\",res,0);\\n            return res;\\n        }\\n        public void helper(String s, String tmp, List<String> res,int n){\\n            if(n==4){\\n                if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1));\\n                //substring here to get rid of last '.'\\n                return;\\n            }\\n            for(int k=1;k<=3;k++){\\n                if(s.length()<k) continue;\\n                int val = Integer.parseInt(s.substring(0,k));\\n                if(val>255 || k!=String.valueOf(val).length()) continue;\\n                /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/\\n                helper(s.substring(k),tmp+s.substring(0,k)+\".\",res,n+1);\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3079133,
                "title": "python3-backtracking-for-beginners",
                "content": "**Code with no comments at the end, in case you don\\'t want to read the story but just want to compare mine with yours**\\n\\nWe have no other choices but to generate **all** possible valid IP **addresses** as the problem asked, backtracking is a good candidate.\\n\\n**Backtracking** is basically **Brute Force**, where we check **all possibilities** using a **Recursive Function**.\\nThe most important parts of backtracking using recursive function are:\\n(1) **return** when we reach to the end and no more states can be generated.\\n(2) **restore the state** after calling the recursive function.\\ni.e.,\\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n(2) change the current state to its neighboring state\\n(3) backtrack(state)\\n(4) restore the state (backtrack)\\n```\\n\\n**For this problem**, we want to build all valid IP addresses one by one (Brute Force). So we do a recursive call on each state. \\n - State is defined as the position ```i``` in ```s``` we are currently visiting and the address we have previously build.\\n - If ```i == len(s)```, we have reached to the end of ```s```, and no more state can be generated. We check if the current ```address``` we build is of exactly four numbers, and add it to the result if it is.\\n - Now, at each position ```i```, we have at most two choices, and we need to check for each option to see if it will result in a valid address.\\n    (1) Add the current digit to the last number in ```address``` if the last number is not 0 (No leading zero) and the concatenated number is <= 255.\\n    (2) Add the current digit in ```address``` as a new number if ```address``` contains less than 4 numbers.\\n - We start the backtracking process by using the first digit in ```s``` as the first number in ```address```.\\n - I used intgers in the address I\\'m building for easier comparing and concatenation.\\n\\n**Code with comments**\\n\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is not 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n**Code with no comments**\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            if i==len(s):\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i])\\n                BT(i+1, address)\\n                address[-1] = lastItem\\n            \\n            if len(address)<4:\\n                BT(i+1,address + [int(s[i])])\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n\\n05/20/2023, Third time I see this question, here is what I did in 10 min:\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        def BT(i,cur):\\n            nonlocal res\\n            if i==len(s):\\n                if len(cur)==4:\\n                    res.append(\\'.\\'.join([str(x) for x in cur]))\\n                return\\n            if len(cur)>4:\\n                return\\n            \\n            BT(i+1, cur+[int(s[i])])\\n            if cur and cur[-1]!=0 and cur[-1]*10+int(s[i])<=255:\\n                cur[-1] = cur[-1]*10+int(s[i])\\n                BT(i+1, cur)\\n                cur[-1] = cur[-1]//10\\n        BT(0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n(2) change the current state to its neighboring state\\n(3) backtrack(state)\\n(4) restore the state (backtrack)\\n```\n```i```\n```s```\n```i == len(s)```\n```s```\n```address```\n```i```\n```address```\n```address```\n```address```\n```s```\n```address```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is not 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            if i==len(s):\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i])\\n                BT(i+1, address)\\n                address[-1] = lastItem\\n            \\n            if len(address)<4:\\n                BT(i+1,address + [int(s[i])])\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        def BT(i,cur):\\n            nonlocal res\\n            if i==len(s):\\n                if len(cur)==4:\\n                    res.append(\\'.\\'.join([str(x) for x in cur]))\\n                return\\n            if len(cur)>4:\\n                return\\n            \\n            BT(i+1, cur+[int(s[i])])\\n            if cur and cur[-1]!=0 and cur[-1]*10+int(s[i])<=255:\\n                cur[-1] = cur[-1]*10+int(s[i])\\n                BT(i+1, cur)\\n                cur[-1] = cur[-1]//10\\n        BT(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31151,
                "title": "share-0ms-neat-and-clear-c-solution-using-dfs",
                "content": "    class Solution {\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> result;\\n            string ip;\\n            dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n            return result;\\n        }\\n        void dfs(string s,int start,int step,string ip,vector<string>& result){\\n            if(start==s.size()&&step==4){\\n                ip.erase(ip.end()-1); //remove the last '.' from the last decimal number\\n                result.push_back(ip);\\n                return;\\n            }\\n            if(s.size()-start>(4-step)*3) return;\\n            if(s.size()-start<(4-step)) return;\\n            int num=0;\\n            for(int i=start;i<start+3;i++){\\n                num=num*10+(s[i]-'0');\\n                if(num<=255){\\n                    ip+=s[i];\\n                    dfs(s,i+1,step+1,ip+'.',result);\\n                }\\n                if(num==0) break;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> result;\\n            string ip;\\n            dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1272225,
                "title": "easy-to-understand-backtracking-c-with-comments",
                "content": "class Solution {\\npublic:\\n    \\n   bool isValid(string s1)\\n   {\\n      \\n       \\n       if(s1.size()>3||s1.size()==0) return false;\\n       \\n       if(s1.size()>1 && s1[0]==\\'0\\') return false;\\n       \\n\\t   // using stoi to convert string to integer \\n\\t   \\n       if(s1.size() && stoi(s1)>255) return false;\\n       \\n       \\n       \\n       return true;\\n           \\n   }\\n    \\n    void recur(int i, int dots, string temp, vector<string>& ans, string s)\\n    {\\n\\t\\t// we have to place 3 dots in the string to make 4 partitions\\n\\t\\t\\n        if(dots==3)\\n        {\\n           // pushing last partition after checking its validity\\n\\t\\t\\t\\t\\n            if(isValid(s.substr(i)))\\n            {\\n           \\n                ans.push_back(temp+s.substr(i));\\n                \\n            }\\n            return;\\n        }\\n\\t\\t\\n        // placing the dot at every valid position\\n\\t\\t\\n        for(int j=i; j<s.size() ;j++)\\n        {\\n\\n\\t\\tif( isValid(s.substr(i, j-i+1)))\\n\\t\\t{\\n\\t\\t\\ttemp.push_back(s[j]);\\n\\t\\t\\ttemp.push_back(\\'.\\');\\n\\n\\t\\t\\trecur(j+1, dots+1, temp, ans, s);\\n\\n\\t\\t   // removing the dot after calling recur function \\n\\n\\t\\t   // note that we don\\'t remove the last digit that was placed in temp string as we just have to change positions of dots only and not digits in string\\n\\t\\t\\ttemp.pop_back();\\n\\n\\n            }\\n        }\\n        \\n        return;\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        vector<string> ans;\\n        \\n        if(s.size()<4) return ans;\\n        \\n        recur(0, 0, \"\", ans, s);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n   bool isValid(string s1)\\n   {\\n      \\n       \\n       if(s1.size()>3||s1.size()==0) return false;\\n       \\n       if(s1.size()>1 && s1[0]==\\'0\\') return false;\\n       \\n\\t   // using stoi to convert string to integer \\n\\t   \\n       if(s1.size() && stoi(s1)>255) return false;\\n       \\n       \\n       \\n       return true;\\n           \\n   }",
                "codeTag": "Java"
            },
            {
                "id": 3079573,
                "title": "java-solution-with-explanation",
                "content": "\\n\\n# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. This code defines a class called \"Solution\" that contains a single public method called \"`restoreIpAddresses`\". This method takes a single input, a string called \"s\", and returns a list of strings.\\n\\n2. The method first initializes two lists, \"`addresses`\" and \"`address`\". \"addresses\" will ultimately hold all of the valid IP addresses that can be created from the input string \"s\", and \"address\" is a temporary list used to store each individual segment of an IP address (i.e., the four numbers that make up an IP address) as the code generates them.\\n\\n3. The method then calls a private helper function called \"`rec`\". This function takes four inputs: the input string \"s\", an integer \"i\" that keeps track of the current position in the string, the \"address\" list, and the \"addresses\" list.\\n\\n4. The function starts by checking if the \"address\" list has a size of 4. If it does, this means that all four segments of the IP address have been generated and it checks if i is equal to the length of the input string. If both of these conditions are true, it means that all of the characters in the input string have been used to generate a valid IP address, so the function converts the \"address\" list to a string and adds it to the \"addresses\" list.\\n\\n5. If the \"address\" list does not have a size of 4, the function enters a loop. The loop iterates from i+1 to i+3 (or until it reaches the end of the input string) and for each iteration, it creates a new string called \"nextInt\" which is a substring of the input string \"s\" starting from index i and ending at index j. Then it checks if the integer value of nextInt is less than or equal to 255 and either nextInt is equal to \"0\" or it doesn\\'t start with \"0\", then it adds this nextInt to the \"address\" list and recursively calls the function with updated inputs. After this call, it removes the last element of \"address\" list.\\n\\n6. This process continues until the function generates all possible valid IP addresses from the input string. The final list of valid IP addresses is returned by the \"restoreIpAddresses\" method.\\n\\n# Code\\n```\\nclass Solution {\\n    public static List<String> restoreIpAddresses(String s) {\\n        // Initialize the list to hold all valid IP addresses\\n        List<String> addresses = new ArrayList<>();\\n        // Initialize the list to hold the current IP address being built\\n        List<String> address = new ArrayList<>();\\n        // Call the recursive helper function to generate all possible IP addresses\\n        rec(s, 0, address, addresses);\\n        // Return the list of all valid IP addresses\\n        return addresses;\\n    }\\n    private static void rec(String s, int i, List<String> address, List<String> addresses) {\\n        // If the current address has 4 segments, check if we have reached the end of the input string\\n        if (address.size() == 4) {\\n            if (i == s.length()) {\\n                // If we have reached the end of the input string, add the current address to the list of valid addresses\\n                addresses.add(String.join(\".\", address));\\n            }\\n        } else {\\n            // Try all possible next segments for the current address\\n            for (int j = i + 1; j <= i + 3 && j <= s.length(); j++) {\\n                String nextInt = s.substring(i, j);\\n                // Check if the next segment is valid (between 0 and 255, and not starting with 0 unless it is 0)\\n                if (Integer.parseInt(nextInt) <= 255 && (nextInt.equals(\"0\") || !nextInt.startsWith(\"0\"))) {\\n                    // Add the next segment to the current address\\n                    address.add(nextInt);\\n                    // Recursively call the function to generate the next segment\\n                    rec(s, j, address, addresses);\\n                    // Remove the last segment from the current address\\n                    address.remove(address.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static List<String> restoreIpAddresses(String s) {\\n        // Initialize the list to hold all valid IP addresses\\n        List<String> addresses = new ArrayList<>();\\n        // Initialize the list to hold the current IP address being built\\n        List<String> address = new ArrayList<>();\\n        // Call the recursive helper function to generate all possible IP addresses\\n        rec(s, 0, address, addresses);\\n        // Return the list of all valid IP addresses\\n        return addresses;\\n    }\\n    private static void rec(String s, int i, List<String> address, List<String> addresses) {\\n        // If the current address has 4 segments, check if we have reached the end of the input string\\n        if (address.size() == 4) {\\n            if (i == s.length()) {\\n                // If we have reached the end of the input string, add the current address to the list of valid addresses\\n                addresses.add(String.join(\".\", address));\\n            }\\n        } else {\\n            // Try all possible next segments for the current address\\n            for (int j = i + 1; j <= i + 3 && j <= s.length(); j++) {\\n                String nextInt = s.substring(i, j);\\n                // Check if the next segment is valid (between 0 and 255, and not starting with 0 unless it is 0)\\n                if (Integer.parseInt(nextInt) <= 255 && (nextInt.equals(\"0\") || !nextInt.startsWith(\"0\"))) {\\n                    // Add the next segment to the current address\\n                    address.add(nextInt);\\n                    // Recursively call the function to generate the next segment\\n                    rec(s, j, address, addresses);\\n                    // Remove the last segment from the current address\\n                    address.remove(address.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31113,
                "title": "java-recursive-backtracking-easy-to-read",
                "content": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new LinkedList<>();\\n        int[] path = new int[4];\\n        helper(ret, s, 0,  path, 0);\\n        return ret;\\n    }\\n    \\n    void helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n        if(segment == 4 && idx == s.length() ){\\n            acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n            return ;\\n        }else if(segment == 4 || idx == s.length() ){\\n            return ;\\n        }\\n        \\n        for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n            int val = Integer.parseInt(s.substring(idx, idx + len));\\n            // range check, no leading 0.\\n            if(val > 255 || len >= 2  && s.charAt(idx) == '0') \\n                break; \\n                \\n            path[segment] = val;\\n            helper(acc, s, idx + len, path, segment + 1);\\n            path[segment] = -1; // for debug. \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new LinkedList<>();\\n        int[] path = new int[4];\\n        helper(ret, s, 0,  path, 0);\\n        return ret;\\n    }\\n    \\n    void helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n        if(segment == 4 && idx == s.length() ){\\n            acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n            return ;\\n        }else if(segment == 4 || idx == s.length() ){\\n            return ;\\n        }\\n        \\n        for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n            int val = Integer.parseInt(s.substring(idx, idx + len));\\n            // range check, no leading 0.\\n            if(val > 255 || len >= 2  && s.charAt(idx) == '0') \\n                break; \\n                \\n            path[segment] = val;\\n            helper(acc, s, idx + len, path, segment + 1);\\n            path[segment] = -1; // for debug. \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31184,
                "title": "beautiful-c-backtracking-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> result;\\n        string solution;\\n        \\n        vector<string> restoreIpAddresses(string s) {\\n            \\n            backtracking(s, 0, 0);\\n            \\n            return result;\\n        }\\n        \\n    private:\\n        void backtracking(string s, int start, int part)\\n        {\\n            if(start == s.size() && part == 4)\\n            {\\n                result.push_back(solution);\\n                return;\\n            }\\n            \\n            for(int i = start; i < s.size(); i++)\\n            {\\n                if(part < 4 && i-start < 3 && validIP(s, start, i))\\n                {\\n                    solution.append(s.substr(start, i-start+1));\\n                    part++;\\n                    if(part < 4) solution.push_back('.');\\n    \\n                    backtracking(s, i+1, part);\\n                    \\n                    if(part < 4) solution.pop_back();\\n                    part--;\\n                    for(int j = 0; j < i-start+1; j++) solution.pop_back();\\n                }\\n            }\\n        }\\n        \\n        bool validIP(string s, int start, int end)\\n        {\\n            string temp = s.substr(start, end-start+1);\\n            int ip = stoll(temp);\\n            \\n            if(s[start] == '0' && start != end) return false;\\n            else if(ip >= 0 && ip <= 255) return true;\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> result;\\n        string solution;\\n        \\n        vector<string> restoreIpAddresses(string s) {\\n            \\n            backtracking(s, 0, 0);\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3079263,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=Tw4Mfxv0MJM&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=21) if you are interested.\\n\\n---\\n\\n**Iterative Approach**\\n\\n<iframe src=\"https://leetcode.com/playground/MVq87gRz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=Tw4Mfxv0MJM&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=21) if you are interested.\\n\\n---\\n\\n**Iterative Approach**\\n\\n<iframe src=\"https://leetcode.com/playground/MVq87gRz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3079377,
                "title": "clean-codes-full-explanation-recursion-c-java-python3",
                "content": "# Exaplanation to Approach :\\n1. The main idea to solve this problem is to use Recursion.\\n2. Consider every position of the input string and, there exist two possible cases:\\n    - Place a dot over the current position.\\n    - Take this character, i.e don\\u2019t place the dot over this position.\\n3. At every step of the recursion, we have the following data:\\n    - curr stores the string between two dots.\\n    - res stores the possible IP Address.\\n    - index stores the current position in the input string.\\n4. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n5. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n# Request \\uD83D\\uDE0A :\\n- If you find this solution easy to understand and helpful, then Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/336747b3-ffea-40aa-b4e0-bf2146e509ea_1674271394.8886068.gif)\\n\\n# Code [C++] :\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void recurse(string res,string curr,int index,string s){\\n        if(index==s.length()){\\n            if(curr.empty() and count(res.begin(),res.end(),\\'.\\')==3){\\n                ans.push_back(res);\\n            }\\n            return;\\n        }\\n        if(!curr.empty() and stoi(curr)==0){\\n            return;\\n        }\\n        curr.push_back(s[index]);\\n        if(stoi(curr)>255){\\n            return;\\n        }\\n        recurse(res,curr,index+1,s);\\n        if(!res.empty()){\\n            recurse(res+\".\"+curr,\"\",index+1,s);\\n        }\\n        else{\\n            recurse(curr,\"\",index+1,s);\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        recurse(\"\",\"\",0,s);\\n        return ans;\\n    }\\n};\\n```\\n# Code [Java] :\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        recurse(s, ans, 0, \"\", 0);\\n        return ans;\\n    }\\n    private void recurse(String curr, List<String> ans, int index, String temp, int count) {\\n        if (count > 4)\\n            return;\\n        if (count == 4 && index == curr.length())\\n            ans.add(temp);\\n        for (int i=1; i<4; i++) {\\n            if (index+i > curr.length()){\\n                break;\\n            }\\n            String s = curr.substring(index,index+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)){\\n                continue;\\n            }\\n            recurse(curr, ans, index+i, temp+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }\\n}\\n```\\n# Code [Python3] :\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.recurse(s, ans, 0, \"\", 0)\\n        return ans\\n    \\n    def recurse(self, curr, ans, index, temp, count):\\n        if count > 4:\\n            return\\n        if count == 4 and index == len(curr):\\n            ans.append(temp)\\n        for i in range(1, 4):\\n            if index + i > len(curr):\\n                break\\n            s = curr[index:index+i]\\n            if (s.startswith(\"0\") and len(s) > 1) or (i == 3 and int(s) >= 256):\\n                continue\\n            self.recurse(curr, ans, index+i, temp + s + (\".\" if count < 3 else \"\"), count+1)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void recurse(string res,string curr,int index,string s){\\n        if(index==s.length()){\\n            if(curr.empty() and count(res.begin(),res.end(),\\'.\\')==3){\\n                ans.push_back(res);\\n            }\\n            return;\\n        }\\n        if(!curr.empty() and stoi(curr)==0){\\n            return;\\n        }\\n        curr.push_back(s[index]);\\n        if(stoi(curr)>255){\\n            return;\\n        }\\n        recurse(res,curr,index+1,s);\\n        if(!res.empty()){\\n            recurse(res+\".\"+curr,\"\",index+1,s);\\n        }\\n        else{\\n            recurse(curr,\"\",index+1,s);\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        recurse(\"\",\"\",0,s);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        recurse(s, ans, 0, \"\", 0);\\n        return ans;\\n    }\\n    private void recurse(String curr, List<String> ans, int index, String temp, int count) {\\n        if (count > 4)\\n            return;\\n        if (count == 4 && index == curr.length())\\n            ans.add(temp);\\n        for (int i=1; i<4; i++) {\\n            if (index+i > curr.length()){\\n                break;\\n            }\\n            String s = curr.substring(index,index+i);\\n            if ((s.startsWith(\"0\") && s.length()>1) || (i==3 && Integer.parseInt(s) >= 256)){\\n                continue;\\n            }\\n            recurse(curr, ans, index+i, temp+s+(count==3?\"\" : \".\"), count+1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        self.recurse(s, ans, 0, \"\", 0)\\n        return ans\\n    \\n    def recurse(self, curr, ans, index, temp, count):\\n        if count > 4:\\n            return\\n        if count == 4 and index == len(curr):\\n            ans.append(temp)\\n        for i in range(1, 4):\\n            if index + i > len(curr):\\n                break\\n            s = curr[index:index+i]\\n            if (s.startswith(\"0\") and len(s) > 1) or (i == 3 and int(s) >= 256):\\n                continue\\n            self.recurse(curr, ans, index+i, temp + s + (\".\" if count < 3 else \"\"), count+1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164573,
                "title": "c-c-python-super-clean-iterative-approach-and-fast-recursive-without-converting-to-numbers",
                "content": "# TL;DR\\n## Iterative solution. No pruning done.\\n#### Python\\n```python\\n  def restoreIpAddresses(self, s):\\n    ret = []\\n    for a in range(1, 4):\\n      for b in range(1, 4):\\n        for c in range(1, 4):\\n          d = len(s) - a - b - c\\n          \"\"\"\\n          Last number must use all remaining digits. Check;\\n          1. The size of the last number is valid\\n          2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          \"\"\"\\n          if (1 <= d <= 3 and\\n            (1 == a or \\'0\\' != s[0        ]) and (a != 3 or s[         :a        ] <= \"255\") and\\n            (1 == b or \\'0\\' != s[a        ]) and (b != 3 or s[a        :a + b    ] <= \"255\") and\\n            (1 == c or \\'0\\' != s[a + b    ]) and (c != 3 or s[a + b    :a + b + c] <= \"255\") and\\n            (1 == d or \\'0\\' != s[a + b + c]) and (d != 3 or s[a + b + c:         ] <= \"255\")):\\n            ret.append(\\'.\\'.join([s[0:a], s[a:a + b], s[a + b:a + b + c], s[a + b + c:]]))\\n    return ret\\n```\\t\\t\\n#### c++\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n   \\n    for (int a = 1; a <= 3; ++a) {\\n      for (int b = 1; b <= 3; ++b) {\\n        for (int c = 1; c <= 3; ++c) {\\n          int d = s.size() - a - b - c;\\n          // Last number must use all remaining digits. Check;\\n          // 1. The size of the last number is valid\\n          // 2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          if (1 <= d && d <= 3 && \\n            (1 == a || \\'0\\' != s[0        ] && (3 != a || 0 < memcmp(\"256\", &s[0        ], 3))) &&\\n            (1 == b || \\'0\\' != s[a        ] && (3 != b || 0 < memcmp(\"256\", &s[a        ], 3))) &&\\n            (1 == c || \\'0\\' != s[a + b    ] && (3 != c || 0 < memcmp(\"256\", &s[a + b    ], 3))) &&\\n            (1 == d || \\'0\\' != s[a + b + c] && (3 != d || 0 < memcmp(\"256\", &s[a + b + c], 3)))) \\n          {\\n            ret.emplace_back(s.substr(0, a) + \".\" + s.substr(a, b) + \".\" + s.substr(a + b, c) + \".\" + s.substr(a + b + c));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\\t\\n## Iterative solution, with pruning. Super fast with minimal loops.\\n### c\\n```\\nchar ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }\\n          char* dest = (char*) malloc(len + 4);\\n          memcpy(dest        , s    , a    );\\n          dest[a] = \\'.\\';\\n          memcpy(dest + a + 1, s + a, b - a);\\n          dest[b + 1] = \\'.\\';\\n          memcpy(dest + b + 2, s + b, c - b);\\n          dest[c + 2] = \\'.\\';\\n          memcpy(dest + c + 3, s + c, len - c);\\n          dest[len + 3] = \\'\\\\0\\';\\n          ret[(*returnSize)++] = dest;\\n        }\\n      }\\n    }\\n  }\\n  return ret;\\n}\\n```\\n## Recursive solution, with pruning. Not as pretty, but fast\\nI didn\\'t bother doing this in python, because... well you don\\'t care about speed if you\\'re using python.\\n### c++\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    char temp[15 + 1] = {0};\\n    \\n    // Recursive function that progressively cycles through valid numbers lengths \\n    std::function <void (const char* pos, int len, char* buf, int count)> helper;\\n    helper = [&ret, &temp, &helper] (const char* pos, int len, char* buf, int count) -> void {\\n      // Check if there is the right amount of input string left\\n      if (len >= (4 - count) && len <= (4 - count) * 3) {\\n        if (4 == count)\\n        {\\n          ret.push_back(temp);\\n        } else {\\n          // \\'0\\' is a special case. \\'0\\' is valid number, \"00\" is not. Only recurse on a single digit\\n          int sub_len = (\\'0\\' == *pos) ? 1 : std::min(3, len);\\n\\n          // Recurse around, using upto 3 digits for the number, then 2, then 1\\n          buf += sprintf(buf, \"%s%.*s\", ((count) ? \".\" : \"\"), sub_len, pos);\\n          switch (sub_len) {\\n            default: \\n              if (0 < memcmp(\"256\", pos, 3)) {\\n                helper(pos + 3, len - 3, buf, count + 1);\\n              }\\n              --buf;  // Fall-through*/\\n            case 2: helper(pos + 2, len - 2, buf--, count + 1); // Fall-through\\n            case 1: helper(pos + 1, len - 1, buf--, count + 1);\\n          }\\n        }\\n      }\\n    };\\n    \\n    helper(s.c_str(), s.size(), temp, 0);\\n    return ret;\\n  }\\n```\\t\\n# Details\\nA simple solution would be to just try every possible length for the 4 ip numbers. That\\'s 3^4 = 81 possible values, so quite doable if your time constant isn\\'t too bad. In fact, since the total length of all the numbers must equal the string size, if you know your first 3 number lengths, the 4th is known. Therefore there is actually only 3^3 = 27 possible values to check; very doable.\\n\\nThings to be aware of are;\\n1. Numbers, apart from _0_, do not start with \\'0\\'. _0_ itself is only ever a single digit. eg. \"00\" and \"01\" are not valid numbers.\\n2. Numbers must be less than or equal to 255.\\n\\nChecking 1. is relatively simple. `len == 1 || \\'0\\' != digit[0]` will handle that.\\n\\nChecking 2. can be done many ways;\\n* Convert the number string to an actual number using `atoi`, `stoi` or similar. This can be an expensive operation to do a lot, since it often requires terminateing the substring/creating a copy.\\n* An ugly as if. `if (3 != len || (\\'2\\' > digit[0] || (\\'2\\' == digit[0] && (\\'5\\' > digit[1] || (\\'5\\' == digit[1] && \\'5\\' >= digit[2])))))`, which is fast, but makes your eyes bleed.\\n* `memcmp` directly against a string. Fast and efficent.\\n\\nI choose to use the `memcmp` approach because it allows the entire solution to be done without ever converting a string to a number or a number to a string.\\n\\n### Iterative solution\\nWtih that decided and aiming for neat code, I produced the logical iterative approach. This has no pruning, so it will always perform 27 comparisons, even if the input string size means there is no possible solution. For example \"0\" or \"00000\" will not cause a quick bail out. I think the clean code was worth it, particularly since the constant will be low.\\n\\nI originally used some stl to follow the DRY principle, but it\\'s not as clean. This is what I had;\\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    int len[4];\\n    int offs[4] = {0};\\n   \\n    for (len[0] = 1; len[0] <= 3; ++len[0]) {\\n      for (len[1] = 1; len[1] <= 3; ++len[1]) {\\n        for (len[2] = 1; len[2] <= 3; ++len[2]) {\\n          std::partial_sum(std::begin(len), std::end(len) - 1, std::begin(offs) + 1);\\n          if (offs[3] >= s.size() - 3 && 1 <= (len[3] = s.size() - offs[3]) && \\n            all_of(begin(offs), end(offs), [l_it = begin(len), &s] (int off) mutable { \\n              return (1 == *l_it || \\'0\\' != s[off]) && (3 != *l_it++ || 0 < memcmp(\"256\", &s[off], 3)); \\n            }))\\n          {\\n            ret.emplace_back(s.substr(0, len[0]) + \".\" + s.substr(offs[1], len[1]) + \".\" + s.substr(offs[2], len[2]) + \".\" + s.substr(offs[3]));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\\nI decided to unroll it and decided to keep it clean. It is the same reason I didn\\'t use the non concatinating and faster code below to build the final result string.\\n```cpp\\nsprintf(buf, \"%.*s.%.*s.%.*s.%s\", a, &s[0], b, &s[a], c, &s[a + b], &s[a + b + c]);\\nret.emplace_back(buf);\\n```\\n\\nThe fastest solution is in c and basically just builds on the above approaches, but shifts the individual checks for each group into the associated `for`. The reason for this is in the above cases, the outside loop could produce an invalid value but the value will only be checked after all the nesting in the `if`, thus causing multiple loops that bail because of the same condition. It\\'s a bit ugly, but super fast.\\n\\n### Recursive solution\\nThe pruning, recursive solution is not nearly as clean, but is very quick. The only real trick to was to use a `switch` statement and abuse the fall-though to try the diffent length and handle the less than 255 at the same time.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```python\\n  def restoreIpAddresses(self, s):\\n    ret = []\\n    for a in range(1, 4):\\n      for b in range(1, 4):\\n        for c in range(1, 4):\\n          d = len(s) - a - b - c\\n          \"\"\"\\n          Last number must use all remaining digits. Check;\\n          1. The size of the last number is valid\\n          2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          \"\"\"\\n          if (1 <= d <= 3 and\\n            (1 == a or \\'0\\' != s[0        ]) and (a != 3 or s[         :a        ] <= \"255\") and\\n            (1 == b or \\'0\\' != s[a        ]) and (b != 3 or s[a        :a + b    ] <= \"255\") and\\n            (1 == c or \\'0\\' != s[a + b    ]) and (c != 3 or s[a + b    :a + b + c] <= \"255\") and\\n            (1 == d or \\'0\\' != s[a + b + c]) and (d != 3 or s[a + b + c:         ] <= \"255\")):\\n            ret.append(\\'.\\'.join([s[0:a], s[a:a + b], s[a + b:a + b + c], s[a + b + c:]]))\\n    return ret\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n   \\n    for (int a = 1; a <= 3; ++a) {\\n      for (int b = 1; b <= 3; ++b) {\\n        for (int c = 1; c <= 3; ++c) {\\n          int d = s.size() - a - b - c;\\n          // Last number must use all remaining digits. Check;\\n          // 1. The size of the last number is valid\\n          // 2. Every number uses 1 digit for 0 and is less than 255 if using 3 digits\\n          if (1 <= d && d <= 3 && \\n            (1 == a || \\'0\\' != s[0        ] && (3 != a || 0 < memcmp(\"256\", &s[0        ], 3))) &&\\n            (1 == b || \\'0\\' != s[a        ] && (3 != b || 0 < memcmp(\"256\", &s[a        ], 3))) &&\\n            (1 == c || \\'0\\' != s[a + b    ] && (3 != c || 0 < memcmp(\"256\", &s[a + b    ], 3))) &&\\n            (1 == d || \\'0\\' != s[a + b + c] && (3 != d || 0 < memcmp(\"256\", &s[a + b + c], 3)))) \\n          {\\n            ret.emplace_back(s.substr(0, a) + \".\" + s.substr(a, b) + \".\" + s.substr(a + b, c) + \".\" + s.substr(a + b + c));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\n```\\nchar ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }\\n          char* dest = (char*) malloc(len + 4);\\n          memcpy(dest        , s    , a    );\\n          dest[a] = \\'.\\';\\n          memcpy(dest + a + 1, s + a, b - a);\\n          dest[b + 1] = \\'.\\';\\n          memcpy(dest + b + 2, s + b, c - b);\\n          dest[c + 2] = \\'.\\';\\n          memcpy(dest + c + 3, s + c, len - c);\\n          dest[len + 3] = \\'\\\\0\\';\\n          ret[(*returnSize)++] = dest;\\n        }\\n      }\\n    }\\n  }\\n  return ret;\\n}\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    char temp[15 + 1] = {0};\\n    \\n    // Recursive function that progressively cycles through valid numbers lengths \\n    std::function <void (const char* pos, int len, char* buf, int count)> helper;\\n    helper = [&ret, &temp, &helper] (const char* pos, int len, char* buf, int count) -> void {\\n      // Check if there is the right amount of input string left\\n      if (len >= (4 - count) && len <= (4 - count) * 3) {\\n        if (4 == count)\\n        {\\n          ret.push_back(temp);\\n        } else {\\n          // \\'0\\' is a special case. \\'0\\' is valid number, \"00\" is not. Only recurse on a single digit\\n          int sub_len = (\\'0\\' == *pos) ? 1 : std::min(3, len);\\n\\n          // Recurse around, using upto 3 digits for the number, then 2, then 1\\n          buf += sprintf(buf, \"%s%.*s\", ((count) ? \".\" : \"\"), sub_len, pos);\\n          switch (sub_len) {\\n            default: \\n              if (0 < memcmp(\"256\", pos, 3)) {\\n                helper(pos + 3, len - 3, buf, count + 1);\\n              }\\n              --buf;  // Fall-through*/\\n            case 2: helper(pos + 2, len - 2, buf--, count + 1); // Fall-through\\n            case 1: helper(pos + 1, len - 1, buf--, count + 1);\\n          }\\n        }\\n      }\\n    };\\n    \\n    helper(s.c_str(), s.size(), temp, 0);\\n    return ret;\\n  }\\n```\n```cpp\\n  vector<string> restoreIpAddresses(string s) {\\n    std::vector<std::string> ret;\\n    int len[4];\\n    int offs[4] = {0};\\n   \\n    for (len[0] = 1; len[0] <= 3; ++len[0]) {\\n      for (len[1] = 1; len[1] <= 3; ++len[1]) {\\n        for (len[2] = 1; len[2] <= 3; ++len[2]) {\\n          std::partial_sum(std::begin(len), std::end(len) - 1, std::begin(offs) + 1);\\n          if (offs[3] >= s.size() - 3 && 1 <= (len[3] = s.size() - offs[3]) && \\n            all_of(begin(offs), end(offs), [l_it = begin(len), &s] (int off) mutable { \\n              return (1 == *l_it || \\'0\\' != s[off]) && (3 != *l_it++ || 0 < memcmp(\"256\", &s[off], 3)); \\n            }))\\n          {\\n            ret.emplace_back(s.substr(0, len[0]) + \".\" + s.substr(offs[1], len[1]) + \".\" + s.substr(offs[2], len[2]) + \".\" + s.substr(offs[3]));\\n          }\\n        }\\n      }\\n    }\\n  \\n    return ret;\\n  }\\n```\n```cpp\\nsprintf(buf, \"%.*s.%.*s.%.*s.%s\", a, &s[0], b, &s[a], c, &s[a + b], &s[a + b + c]);\\nret.emplace_back(buf);\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3080185,
                "title": "beats-100-simple-c-very-short-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply use brute force and one thing here is that length of any integer can\\'t be more than three because 255 is limit so we can use 4 loops of 3 size and check if individual integers are less than 256 .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse 4 loops from 1 to 3 and check the substrings are less than 256 .\\nSome Implementation Techniques to be taken care of:\\n- first check i+j+k+m== s.size because we should not take some part of string that is valid but not of given string size.\\n- then don\\'t take directly substr because it can have leading zeroes like \"`255 045 003 12`\" On taking stoi leading zeores will be gone then convert to string again.(Beacuse (str)\"045\"--> (int)$$45$$)\\n- then compare with 256 to all substrings use stoi again  for comparing .(Direct string comparison may not work)\\n- then add the dots in btween substrings and check if final length is given string length + 3 then push in ans (in case if it exceeds size or less than so make sure to check).\\n- **HelpFull?UpVoTe\\uD83D\\uDD3C:\\u2764**\\n# Complexity\\n- Time complexity:($$O(1)$$) Actually $$O(M^N*N)$$\\n- Since loops $$O(M*M*M*M)$$  and then substr take another N iterations.\\n- Here M=3 and N=4 so constant time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n- actually $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n       int temp=256;\\n        for(int i=1;i<=3;i++)\\n        for(int j=1;j<=3;j++)\\n        for(int k=1;k<=3;k++)\\n        for(int m=1;m<=3;m++)\\n            if(i+j+k+m==s.length()){\\n            string s1=to_string(stoi(s.substr(0,i)));\\n            string s2=to_string(stoi(s.substr(i,j)));\\n            string s3=to_string(stoi(s.substr(i+j,k)));\\n            string s4=to_string(stoi(s.substr(i+j+k,m)));\\n            if(stoi(s1)<temp and stoi(s2)<temp and stoi(s3)<temp and stoi(s4)<temp){\\n                string t=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                if(t.length()==s.length()+3)\\n                ans.push_back(t);\\n            }\\n            }\\n        return ans;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n       int temp=256;\\n        for(int i=1;i<=3;i++)\\n        for(int j=1;j<=3;j++)\\n        for(int k=1;k<=3;k++)\\n        for(int m=1;m<=3;m++)\\n            if(i+j+k+m==s.length()){\\n            string s1=to_string(stoi(s.substr(0,i)));\\n            string s2=to_string(stoi(s.substr(i,j)));\\n            string s3=to_string(stoi(s.substr(i+j,k)));\\n            string s4=to_string(stoi(s.substr(i+j+k,m)));\\n            if(stoi(s1)<temp and stoi(s2)<temp and stoi(s3)<temp and stoi(s4)<temp){\\n                string t=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                if(t.length()==s.length()+3)\\n                ans.push_back(t);\\n            }\\n            }\\n        return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079197,
                "title": "day-21-beginner-friendly-backtracking-solution-with-diagram",
                "content": "# Intuition\\n1. if length of string is greater than 12 then it never be a valid IP address.\\n2. we will put dot for every point and for each dot we have 3 choices.\\n![b58bfe69-5df9-4dfb-8d17-ea1cf7e3551b_1674264111.1136658.png](https://assets.leetcode.com/users/images/259966b7-f127-4826-b1e5-04fb798c881c_1674266598.3424137.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize an empty list (or vector in C++), res, to store the valid IP addresses.\\n2. Check if the length of the input string is greater than 12, if so return the empty list.\\n3. Create a backtrack function that takes four parameters: s, i, dots, and currIp.\\n4. s is the input string\\n5. i is the current index of the string being processed\\n6. dots represents the number of dots that have been added to the current IP address\\n7. currIp represents the current IP address being formed\\n8. Within the backtrack function, check if the number of dots is equal to 4 and the current index is equal to the length of the input string, in which case add the current IP address to the res list and return.\\n9. Check if the number of dots is greater than 4, if so return.\\n10. Iterate through the input string using a for loop, starting from the current index and ending at the minimum of current index plus 3 or the length of the input string.\\n11. Within the for loop, check if the substring of the input string from the current index to the current loop index is less than 256 and either the current index is equal to the loop index or the character at the current index of the input string is not equal to 0.\\n12. If the above conditions are met, recursively call the backtrack function, passing in the loop index plus 1, dots plus 1, current IP address concatenated with the substring of the input string and a dot as the parameters.\\n13. After the for loop, return the res list.\\n\\nThis algorithm generates all possible valid IP addresses from the given string by adding dots between the substrings of the input string and then checks if it is a valid IP address.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void backtrack(string s, int i, int dots, string currIp, vector<string>& res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.push_back(currIp.substr(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) \\n            return;\\n\\n        for (int j = i; j < min(i+3, (int)s.length()); j++) {\\n            //the i==j check is used to determine if the current substring being considered as a part of the IP address is a single digit or not. If i is equal to j, it means that the current substring is a single digit. This check is used in conjunction with the check s[i] != \\'0\\' to ensure that the IP address being considered is a valid one, where each segment is between 0-255 and no leading zeroes are present.\\n            if (stoi(s.substr(i, j-i+1)) < 256 && (i == j || s[i] != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substr(i, j-i+1) + \".\", res);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> res;\\n        if (s.length() > 12)\\n            return res;\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s.length() > 12) return res;\\n\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n    \\n    public void backtrack(String s, int i, int dots, String currIp, List<String> res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.add(currIp.substring(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) return;\\n\\n        for (int j = i; j < Math.min(i+3, s.length()); j++) {\\n            if (Integer.parseInt(s.substring(i, j+1)) < 256 && (i == j || s.charAt(i) != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substring(i, j+1) + \".\", res);\\n            }\\n        }\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        if len(s) > 12:\\n            return res\\n\\n        def backtrack(i , dots, currIp):\\n            if dots == 4 and i == len(s):\\n                res.append(currIp[:-1])\\n                return\\n            if dots > 4:\\n                return\\n\\n            for j in range(i, min(i+3, len(s))):\\n                if int(s[i:j+1]) < 256 and (i == j or s[i] != \"0\"):\\n                    backtrack(j + 1, dots + 1, currIp + s[i:j+1] + \".\")\\n\\n        backtrack(0, 0, \"\")\\n        return res\\n```\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Complexity\\n- Time complexity: **O(3^n)**\\nThe time complexity of the above code is O(3^4) which is equivalent to O(81).\\n\\n**The reason is that for each character in the input string, there are 3 choices:**\\n\\n1. The character is the last character of an octet, the next octet starts from the next character.\\n2. The character is the second last character of an octet, the next octet starts from the next character.\\n3. The character is the third last character of an octet, the next octet starts from the next character.\\n\\n**As we are using backtracking and at most 4 octets are possible , so it will check all the possible combinations of 3^4 which is equal to 81.**\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n1. The space complexity of the code is O(n), where n is the length of the input string. This is because the maximum recursion depth is equal to the length of the input string and each level of recursion requires O(n) space to store the current IP address. The resultant list of IP addresses also takes O(n) space as the length of each IP address is equal to the length of the input string.\\n2. It is worth noting that since we are keeping track of the number of dots and the current IP address, the actual space complexity is O(1) since the amount of extra space used does not depend on the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void backtrack(string s, int i, int dots, string currIp, vector<string>& res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.push_back(currIp.substr(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) \\n            return;\\n\\n        for (int j = i; j < min(i+3, (int)s.length()); j++) {\\n            //the i==j check is used to determine if the current substring being considered as a part of the IP address is a single digit or not. If i is equal to j, it means that the current substring is a single digit. This check is used in conjunction with the check s[i] != \\'0\\' to ensure that the IP address being considered is a valid one, where each segment is between 0-255 and no leading zeroes are present.\\n            if (stoi(s.substr(i, j-i+1)) < 256 && (i == j || s[i] != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substr(i, j-i+1) + \".\", res);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> res;\\n        if (s.length() > 12)\\n            return res;\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        if (s.length() > 12) return res;\\n\\n        backtrack(s, 0, 0, \"\", res);\\n        return res;\\n    }\\n    \\n    public void backtrack(String s, int i, int dots, String currIp, List<String> res) {\\n        if (dots == 4 && i == s.length()) {\\n            res.add(currIp.substring(0, currIp.length() - 1));\\n            return;\\n        }\\n        if (dots > 4) return;\\n\\n        for (int j = i; j < Math.min(i+3, s.length()); j++) {\\n            if (Integer.parseInt(s.substring(i, j+1)) < 256 && (i == j || s.charAt(i) != \\'0\\')) {\\n                backtrack(s, j+1, dots+1, currIp + s.substring(i, j+1) + \".\", res);\\n            }\\n        }\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        if len(s) > 12:\\n            return res\\n\\n        def backtrack(i , dots, currIp):\\n            if dots == 4 and i == len(s):\\n                res.append(currIp[:-1])\\n                return\\n            if dots > 4:\\n                return\\n\\n            for j in range(i, min(i+3, len(s))):\\n                if int(s[i:j+1]) < 256 and (i == j or s[i] != \"0\"):\\n                    backtrack(j + 1, dots + 1, currIp + s[i:j+1] + \".\")\\n\\n        backtrack(0, 0, \"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754098,
                "title": "must-read-highly-commented-cpp-code-each-and-every-line-commented-with-examples-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    string solution;\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        //initally our start==0 and part==0 as we haven\\'t start processing.\\n        backtracking(s, 0, 0);\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtracking(string s, int start, int part)\\n    {\\n        \\n        if(start == s.size() && part == 4)\\n        {\\n            result.push_back(solution);\\n            return;\\n        }\\n        //Start trasversing the string till the end of the string.\\n        for(int i = start; i < s.size(); i++)\\n        {\\n            //if we satisfy 3 Conditions, we need to continue else Not.\\n            /*\\n            1- if part<4 means if we have a.b. part==2, need more processing. \\n            2- (i-start<3): we are just handling max to max 3 characters. like if we have\\n                1234.5 stop processing.\\n            3- the string from start to current i. string(start,i)= is valid\\n            */\\n            if(part < 4 && i-start < 3 && validIP(s, start, i))\\n            {\\n                //append that string to solution.[ its appennd]\\n                solution.append(s.substr(start, i-start+1));\\n                //included 1 part so incrementing the part by 1.\\n                part++;\\n                //if parts remaining : then we add \\'.\\' else we dont need like 123.456.123.2\\n                if(part < 4) solution.push_back(\\'.\\');\\n                //go from i+1 and do the reaming from i+1 till end of the string.\\n                backtracking(s, i+1, part);\\n                // if its the last part No need of popping the last character eg: 255.255.111.35, \\n                //No need of popping the 35.\\n                if(part < 4) solution.pop_back();\\n                \\n                \\n                //decrement the parts coz we are trying the next combination.\\n                // eg: 255.255.11 part was 3, Now we are ready to remove 11, and try for 111 so do\\n                // parts--.\\n                part--;\\n                //remove the part added. \\n                for(int j = 0; j < i-start+1; j++) solution.pop_back();\\n            }\\n            //else continue;\\n        }\\n    }\\n    \\n    \\n    bool validIP(string s, int start, int end)\\n    {\\n        //find the substring from start to the end and convert into integer.\\n        string temp = s.substr(start, end-start+1);\\n        int ip = stoi(temp);\\n        \\n        //if we have ip=012, its invalid but if its ip=0 its valid like 127.0.0.1 :p\\n        if(s[start] == \\'0\\' && start != end) return false;\\n        //self explanatory\\n        else if(ip >= 0 && ip <= 255) return true;\\n        \\n        //eg: 256\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> result;\\n    string solution;\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        //initally our start==0 and part==0 as we haven\\'t start processing.\\n        backtracking(s, 0, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 30946,
                "title": "dfs-in-python",
                "content": "    class Solution(object):\\n        def restoreIpAddresses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            ans = []\\n            self.helper(ans, s, 4, [])\\n            return ['.'.join(x) for x in ans]\\n            \\n        def helper(self, ans, s, k, temp):\\n            if len(s) > k*3:\\n                return\\n            if k == 0:\\n                ans.append(temp[:])\\n            else:\\n                for i in range(min(3,len(s)-k+1)):\\n                    if i==2 and int(s[:3]) > 255 or i > 0 and s[0] == '0':\\n                        continue\\n                    self.helper(ans, s[i+1:], k-1, temp+[s[:i+1]])",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def restoreIpAddresses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            ans = []\\n            self.helper(ans, s, 4, [])\\n            return ['.'.join(x) for x in ans]\\n            \\n        def helper(self, ans, s, k, temp):\\n            if len(s) > k*3:\\n                return\\n            if k == 0:\\n                ans.append(temp[:])\\n            else:\\n                for i in range(min(3,len(s)-k+1)):\\n                    if i==2 and int(s[:3]) > 255 or i > 0 and s[0] == '0':\\n                        continue\\n                    self.helper(ans, s[i+1:], k-1, temp+[s[:i+1]])",
                "codeTag": "Java"
            },
            {
                "id": 672543,
                "title": "javascript-the-most-clean-backtracking-solution",
                "content": "```javascript\\nvar restoreIpAddresses = function(s) {\\n    const result = []\\n    \\n    function permute(arr, str) {\\n        if(arr.length === 3) {\\n            if(isValid(str)) result.push([...arr, str]);\\n            return;\\n        }\\n        \\n        for(let i = 1; i < 4; i++) {\\n            let subStr = str.slice(0, i);\\n            if(!isValid(subStr)) continue;\\n            permute([...arr, subStr], str.slice(i));\\n        }\\n    }\\n    \\n    function isValid(str) {\\n        if(+str > 255 || !str.length) return false;\\n        if(str.length >= 2 && str[0] === \\'0\\') return false;\\n        return true;\\n    }\\n    \\n    permute([], s);\\n    return result.map(x => x.join(\\'.\\'))\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar restoreIpAddresses = function(s) {\\n    const result = []\\n    \\n    function permute(arr, str) {\\n        if(arr.length === 3) {\\n            if(isValid(str)) result.push([...arr, str]);\\n            return;\\n        }\\n        \\n        for(let i = 1; i < 4; i++) {\\n            let subStr = str.slice(0, i);\\n            if(!isValid(subStr)) continue;\\n            permute([...arr, subStr], str.slice(i));\\n        }\\n    }\\n    \\n    function isValid(str) {\\n        if(+str > 255 || !str.length) return false;\\n        if(str.length >= 2 && str[0] === \\'0\\') return false;\\n        return true;\\n    }\\n    \\n    permute([], s);\\n    return result.map(x => x.join(\\'.\\'))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818933,
                "title": "python-backtracking-solution-99-with-illustration-and-example",
                "content": "The underlying backtracking algorithm is the same with problem 39/40/46/47/90.\\nBut this problem has more constraints thus needs to consider how to include each constraint in the codes.\\nFirstly, the condition to append one single answer to the answer list. I started with len(s) == 0 but found out I could have something like 0.0.0.0.0, which is an invalid IP address. Thus I added a counter k for each \\'.\\'  and k==4 is added to the condition\\n\\nSecond, I need to stop the operation if either hit the end(len(s)==0) or k==4. \\n\\nAlso, I need to include some validation conditions like below wihin the loop.    \\n\\t\\t\\'\\'\\'\\n\\t\\tif int(s[:i+1])>255:\\n            continue\\n        if i != 0 and s[0]==\\'0\\':\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nThe backtracking process illustrated below for better understanding. Also refer to my post for these backtracking problems for your information. \\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n\\n![image](https://assets.leetcode.com/users/images/c38255ec-14e1-4648-971f-6f6708447844_1598737546.865669.png)\\n\\n\\n\\t\\t\\n\\n\\n\\t\\'\\'\\'\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        k = 0\\n        self.backtrack(s,ans,k,\\'\\')\\n        return ans\\n        \\n    \\n    \\n    def backtrack(self, s, ans,k, temp=\\'\\'):\\n        if k==4 and len(s)==0:\\n            ans.append(temp[:-1])\\n            return\\n        if k==4 or len(s)==0:\\n            return\\n        \\n        for i in range(3):\\n            if k>4 or i+1>len(s):\\n                break\\n            \\n            if int(s[:i+1])>255:\\n                continue\\n            if i != 0 and s[0]==\\'0\\':\\n                continue\\n                    \\n            self.backtrack(s[i+1:], ans, k+1, temp+s[:i+1]+\\'.\\')",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "The underlying backtracking algorithm is the same with problem 39/40/46/47/90.\\nBut this problem has more constraints thus needs to consider how to include each constraint in the codes.\\nFirstly, the condition to append one single answer to the answer list. I started with len(s) == 0 but found out I could have something like 0.0.0.0.0, which is an invalid IP address. Thus I added a counter k for each \\'.\\'  and k==4 is added to the condition\\n\\nSecond, I need to stop the operation if either hit the end(len(s)==0) or k==4. \\n\\nAlso, I need to include some validation conditions like below wihin the loop.    \\n\\t\\t\\'\\'\\'\\n\\t\\tif int(s[:i+1])>255:\\n            continue\\n        if i != 0 and s[0]==\\'0\\':\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nThe backtracking process illustrated below for better understanding. Also refer to my post for these backtracking problems for your information. \\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n\\n![image](https://assets.leetcode.com/users/images/c38255ec-14e1-4648-971f-6f6708447844_1598737546.865669.png)\\n\\n\\n\\t\\t\\n\\n\\n\\t\\'\\'\\'\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = []\\n        k = 0\\n        self.backtrack(s,ans,k,\\'\\')\\n        return ans\\n        \\n    \\n    \\n    def backtrack(self, s, ans,k, temp=\\'\\'):\\n        if k==4 and len(s)==0:\\n            ans.append(temp[:-1])\\n            return\\n        if k==4 or len(s)==0:\\n            return\\n        \\n        for i in range(3):\\n            if k>4 or i+1>len(s):\\n                break\\n            \\n            if int(s[:i+1])>255:\\n                continue\\n            if i != 0 and s[0]==\\'0\\':\\n                continue\\n                    \\n            self.backtrack(s[i+1:], ans, k+1, temp+s[:i+1]+\\'.\\')",
                "codeTag": "Python3"
            },
            {
                "id": 791997,
                "title": "beautiful-code-of-backtracking-with-generic-explanation",
                "content": "**Inspiration: BackToBackSWE**\\n* **Choice**: Take a snippet of length 1 to 3 \\n* **Constraint**: Each snippet must be in the range [0,255] and not leading zeroes\\n* **Goal**: When the build pointer will be at the end and we have 4 snippets or segments in total\\n\\n*If we have more than 4 segments or the build pointer goes out of limit, that won\\'t give the valid decomposition and we have to backtrack and try another length for the snippet.*\\n\\n**Time and space: O(1) since we have limited ip addresses (There are only 2^32 ip addresses since ipV4 is of 32 bit.)** (More about this at the end)\\n\\n```\\nclass Solution {\\npublic:\\n    void decomposeIpAddresses(string s, vector<string>&snippets, vector<string>&ipAddresses, int buildPointer){\\n\\n        // goal or base case\\n        if(buildPointer == s.size() && snippets.size() == 4){\\n            cout<<\"a\"<<endl;\\n            ipAddresses.push_back(snippets[0] + \\'.\\'+ snippets[1] + \\'.\\' + snippets[2] + \\'.\\' + snippets[3]);\\n            return ;\\n        }\\n        else if(buildPointer == s.size() || snippets.size() == 4){\\n            return ;\\n        }\\n\\n\\n        for(int len = 1; len <= 3 && buildPointer + len <= s.size(); len++){\\n            // choice\\n            string snippet = s.substr(buildPointer, len);\\n\\n            // constraint\\n            if( (stoi(snippet) > 255) || (snippet.size() > 1 && snippet[0] == \\'0\\') )break;\\n\\n            // Choose , explore , Unchoose\\n            snippets.push_back(snippet);\\n            decomposeIpAddresses(s, snippets, ipAddresses, buildPointer+len);\\n            snippets.pop_back();\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ipAddresses;\\n        vector<string>snippets;\\n        decomposeIpAddresses(s, snippets, ipAddresses, 0);\\n        return ipAddresses;\\n    }\\n};\\n```\\nTime complexity:  The big O notation shows an upper bound of number of your operations as your input size increases. But for this problem the input size cannot go over 12 digits and there are no more than 2^32 possibilities for your IP address. So the curve of your graph becomes constant beyond a point as n (size of the string) can\\'t be greater than 12. Hence the upper bound for this algorithm is constant.",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void decomposeIpAddresses(string s, vector<string>&snippets, vector<string>&ipAddresses, int buildPointer){\\n\\n        // goal or base case\\n        if(buildPointer == s.size() && snippets.size() == 4){\\n            cout<<\"a\"<<endl;\\n            ipAddresses.push_back(snippets[0] + \\'.\\'+ snippets[1] + \\'.\\' + snippets[2] + \\'.\\' + snippets[3]);\\n            return ;\\n        }\\n        else if(buildPointer == s.size() || snippets.size() == 4){\\n            return ;\\n        }\\n\\n\\n        for(int len = 1; len <= 3 && buildPointer + len <= s.size(); len++){\\n            // choice\\n            string snippet = s.substr(buildPointer, len);\\n\\n            // constraint\\n            if( (stoi(snippet) > 255) || (snippet.size() > 1 && snippet[0] == \\'0\\') )break;\\n\\n            // Choose , explore , Unchoose\\n            snippets.push_back(snippet);\\n            decomposeIpAddresses(s, snippets, ipAddresses, buildPointer+len);\\n            snippets.pop_back();\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ipAddresses;\\n        vector<string>snippets;\\n        decomposeIpAddresses(s, snippets, ipAddresses, 0);\\n        return ipAddresses;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 31211,
                "title": "adding-a-python-solution-also-requesting-for-improvement",
                "content": "\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n             \\n         def restoreIpAddresses(self,s):\\n     \\n             answer = []\\n     \\n             s_len = len(s)\\n     \\n             for i in [1,2,3]:\\n                 for j in [i+1,i+2,i+3]:\\n                     for k in [j+1,j+2,j+3]:\\n                         if k >= s_len:\\n                             continue\\n                         s1 = s[:i]\\n                         s2 = s[i:j]\\n                         s3 = s[j:k]\\n                         s4 = s[k:]\\n                         if self.check_valid([s1,s2,s3,s4]):\\n                             new_string = s1 + \".\" + s2 + \".\" + s3 + \".\" + s4\\n                             answer.append(new_string)\\n     \\n             return answer\\n     \\n         def check_valid(self,str_list):\\n     \\n             for s in str_list:\\n                 if s[0] == \"0\" and s != \"0\":\\n                     return False\\n                 if int(s) > 255:\\n                     return False\\n     \\n             return True",
                "solutionTags": [],
                "code": "\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n             \\n         def restoreIpAddresses(self,s):\\n     \\n             answer = []\\n     \\n             s_len = len(s)\\n     \\n             for i in [1,2,3]:\\n                 for j in [i+1,i+2,i+3]:\\n                     for k in [j+1,j+2,j+3]:\\n                         if k >= s_len:\\n                             continue\\n                         s1 = s[:i]\\n                         s2 = s[i:j]\\n                         s3 = s[j:k]\\n                         s4 = s[k:]\\n                         if self.check_valid([s1,s2,s3,s4]):\\n                             new_string = s1 + \".\" + s2 + \".\" + s3 + \".\" + s4\\n                             answer.append(new_string)\\n     \\n             return answer\\n     \\n         def check_valid(self,str_list):\\n     \\n             for s in str_list:\\n                 if s[0] == \"0\" and s != \"0\":\\n                     return False\\n                 if int(s) > 255:\\n                     return False\\n     \\n             return True",
                "codeTag": "Java"
            },
            {
                "id": 1554723,
                "title": "beats-100-of-c-submissions-clear-commented-code-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079093,
                "title": "python3-simple-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def works(self, s):\\n        return s == str(int(s)) and int(s) <= 255\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        n = len(s)\\n        ans = []\\n        for i in range(1, n):\\n            for j in range(i + 1, n):\\n                for k in range(j + 1, n):\\n                    a, b, c, d = s[:i], s[i:j], s[j:k], s[k:]\\n                    if self.works(a) and self.works(b) and self.works(c) and self.works(d):\\n                        ans.append(f\\'{a}.{b}.{c}.{d}\\')\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def works(self, s):\\n        return s == str(int(s)) and int(s) <= 255\\n\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        n = len(s)\\n        ans = []\\n        for i in range(1, n):\\n            for j in range(i + 1, n):\\n                for k in range(j + 1, n):\\n                    a, b, c, d = s[:i], s[i:j], s[j:k], s[k:]\\n                    if self.works(a) and self.works(b) and self.works(c) and self.works(d):\\n                        ans.append(f\\'{a}.{b}.{c}.{d}\\')\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880655,
                "title": "easy-undersrtand-java-solution-with-explanation",
                "content": "```\\n   public List<String> restoreIpAddresses(String s) {\\n        List<String> addresses = new ArrayList<>();\\n        // if the length of the string is longer than 12 which can not form a valid IP\\n        if (s.length() > 12 || s.length() == 0)\\n            return addresses;\\n        backtracking(addresses, new ArrayList<String>(), s, 0);\\n        return addresses;\\n    }\\n\\n    private void backtracking(List<String> addresses, List<String> temp, String s, int start) {\\n        // once reach to end of the string and the have four num inside the list\\n        // then join these four nums and add to result list\\n        if (start == s.length() && temp.size() == 4) {\\n            addresses.add(String.join(\".\", temp));\\n            return;\\n        }\\n\\n        // each number is between 0 and 255\\n        // which is 1 digit to 3 digit\\n        // so we have three different choices for each number\\n        // 1. substring from start to start+1\\n        // 2. substring from start to start+2\\n        // 3. substring from start to start+3\\n        for (int i = 1; i <= 3; i++) {\\n            if (start + i > s.length())\\n                return;\\n            String address = s.substring(start, start + i);\\n            // check the address validation\\n            if (validAddress(address)) {\\n                // add valid num into List\\n                // start a new backtracking\\n                temp.add(address);\\n                backtracking(addresses, temp, s, start + i);\\n                temp.remove(temp.size() - 1);\\n\\n            }\\n        }\\n    }\\n\\n    // To valid the given address\\n    // each integer is between 0 and 255 and can not start with 0\\n    private boolean validAddress(String address) {\\n        return !((address.charAt(0) == \\'0\\' && address.length() > 1) || Integer.parseInt(address) > 255);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n   public List<String> restoreIpAddresses(String s) {\\n        List<String> addresses = new ArrayList<>();\\n        // if the length of the string is longer than 12 which can not form a valid IP\\n        if (s.length() > 12 || s.length() == 0)\\n            return addresses;\\n        backtracking(addresses, new ArrayList<String>(), s, 0);\\n        return addresses;\\n    }\\n\\n    private void backtracking(List<String> addresses, List<String> temp, String s, int start) {\\n        // once reach to end of the string and the have four num inside the list\\n        // then join these four nums and add to result list\\n        if (start == s.length() && temp.size() == 4) {\\n            addresses.add(String.join(\".\", temp));\\n            return;\\n        }\\n\\n        // each number is between 0 and 255\\n        // which is 1 digit to 3 digit\\n        // so we have three different choices for each number\\n        // 1. substring from start to start+1\\n        // 2. substring from start to start+2\\n        // 3. substring from start to start+3\\n        for (int i = 1; i <= 3; i++) {\\n            if (start + i > s.length())\\n                return;\\n            String address = s.substring(start, start + i);\\n            // check the address validation\\n            if (validAddress(address)) {\\n                // add valid num into List\\n                // start a new backtracking\\n                temp.add(address);\\n                backtracking(addresses, temp, s, start + i);\\n                temp.remove(temp.size() - 1);\\n\\n            }\\n        }\\n    }\\n\\n    // To valid the given address\\n    // each integer is between 0 and 255 and can not start with 0\\n    private boolean validAddress(String address) {\\n        return !((address.charAt(0) == \\'0\\' && address.length() > 1) || Integer.parseInt(address) > 255);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080515,
                "title": "recursion-deep-dive-explanation",
                "content": "\\n# Approach\\nFor every position, we have two choices, either to insert the dot over there, or to not insert, also we need all possible addresses. Recursion is a very obivous choice. for every possibility check whether there exists a valid address or not, if it does store it and return it.\\n\\n\\n# Code Explanation\\n***The convert_to_int(string str)*** function takes a string as input and converts it to an integer. It first checks if the string is empty or has more than 3 characters, in which case it returns 256. It then checks for leading zeroes in the string and if it finds any, it also returns 256. If the string is a valid number, it converts it to an integer and returns it.\\n\\n***The valid_ip(string IP_part)*** function takes a string as input and checks if it is a valid IP address. It first checks if the string contains any characters other than \\'.\\' or numbers and returns false if it finds any. It then iterates through the string, checking each substring between dots and using the convert_to_int(string str) function to convert it to an integer. If the integer is greater than 255 or the substring is empty, the function returns false. If all substrings are valid, the function returns true.\\n\\n***The recursive_function*** generates all possible IP addresses by adding dots to the input string. It takes four inputs: the input string, a vector to store the valid IP addresses, an integer \\'i\\' that keeps track of the current position in the string, and an integer \\'dot\\' that keeps track of the number of dots that have been added to the string. The function first checks if all 3 dots have been placed, and if so, it checks for the validity of the IP address using the valid_ip(string IP_part) function and stores it in the vector if it is valid. If all dots have not been placed yet, the function then checks if the current position \\'i\\' is within the bounds of the string. It then has two options: either not add a dot at the current position, or add a dot at the current position. In both cases, it calls itself recursively with the updated string, position and dot count.\\n\\nFinally, Call the recursive_function to generate **all possible IP addresses** and returns the vector of valid IP addresses.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    int convert_to_int(string str)\\n    {\\n        // Return 256 because number greater than 255 will return false\\n        if (str.size() == 0 || str.size() > 3)\\n            return 256;\\n        int leading_zeroes = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            if (str[i] != \\'0\\')\\n                break;\\n            else\\n                leading_zeroes++;\\n        }\\n        // If the number contains leading zeroes, we will return 256\\n        if (leading_zeroes >= 1 && (str.size() != 1))\\n            return 256;\\n        int converted_number = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            converted_number *= 10;\\n            converted_number += (str[i] - \\'0\\');\\n        }\\n        // Returning converted valid number\\n        return converted_number;\\n    }\\n    // Boolean function which will rwtuen true if IP address is valid\\n    bool valid_ip(string IP_part)\\n    {\\n        // If string contains characters other than \\'.\\' or numbers, we will return false\\n        for (int i = 0; i < IP_part.length(); i++)\\n            if (IP_part[i] != \\'.\\' && (IP_part[i] < \\'0\\' || IP_part[i] > \\'9\\'))\\n                return false;\\n        // Trying for a valid ip part between dots\\n        string valid_IP_part = \"\";\\n        for (int i = 0; i < IP_part.length(); i++)\\n        {\\n            if (IP_part[i] == \\'.\\')\\n            {\\n                // Return false if number is greater than 25 or 2 dots are adjacent\\n                if ((valid_IP_part == \"\") || (convert_to_int(valid_IP_part) > 255))\\n                    return false;\\n                else\\n                    valid_IP_part = \"\";\\n            }\\n            else\\n                valid_IP_part += IP_part[i];\\n        }\\n        // Checking the num because last nuumber escaped the check because of else\\n        if (convert_to_int(valid_IP_part) > 255)\\n            return false;\\n        return true;\\n    }\\n    void recursive_function(string s, vector<string> &ans, int i, int dot)\\n    {\\n        // If all dots have been placed, we will check for validity\\n        if (dot == 3)\\n        {\\n            // If IP adress will be Stored if valid\\n            if (valid_ip(s))\\n                ans.push_back(s);\\n            return;\\n        }\\n        if (i >= s.length())\\n            return;\\n        // Either we not put the dot\\n        recursive_function(s, ans, i + 1, dot);\\n        // Or we put the dot\\n        string temp;\\n        // Inserting the dot\\n        for (int k = 0; k < i; k++)\\n            temp += s[k];\\n        temp += \\'.\\';\\n        for (int k = i; k < s.length(); k++)\\n            temp += s[k];\\n        recursive_function(temp, ans, i + 1, dot + 1);\\n    }\\n\\npublic:\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        // Storing IP adresses\\n        vector<string> ans;\\n        recursive_function(s, ans, 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n***Exponential***: This is because for every position there are two operation, either to putting dot, or not putting dot. However this wont be done for more than three dots. (So, somewhere less than exponential.) The other functions have relatively lower complexities (is_valid: O(n), convert to int: O(str.length)).\\n\\n- Space complexity:\\n ***O(n)***: This is because after every function call a new stack frame to the call stack is added, and the maximum depth of the recursion stack is n.\\n\\n\\n*DO UPVOTE IF YOU FOUND THIS HELPFUL :)*",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    int convert_to_int(string str)\\n    {\\n        // Return 256 because number greater than 255 will return false\\n        if (str.size() == 0 || str.size() > 3)\\n            return 256;\\n        int leading_zeroes = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            if (str[i] != \\'0\\')\\n                break;\\n            else\\n                leading_zeroes++;\\n        }\\n        // If the number contains leading zeroes, we will return 256\\n        if (leading_zeroes >= 1 && (str.size() != 1))\\n            return 256;\\n        int converted_number = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            converted_number *= 10;\\n            converted_number += (str[i] - \\'0\\');\\n        }\\n        // Returning converted valid number\\n        return converted_number;\\n    }\\n    // Boolean function which will rwtuen true if IP address is valid\\n    bool valid_ip(string IP_part)\\n    {\\n        // If string contains characters other than \\'.\\' or numbers, we will return false\\n        for (int i = 0; i < IP_part.length(); i++)\\n            if (IP_part[i] != \\'.\\' && (IP_part[i] < \\'0\\' || IP_part[i] > \\'9\\'))\\n                return false;\\n        // Trying for a valid ip part between dots\\n        string valid_IP_part = \"\";\\n        for (int i = 0; i < IP_part.length(); i++)\\n        {\\n            if (IP_part[i] == \\'.\\')\\n            {\\n                // Return false if number is greater than 25 or 2 dots are adjacent\\n                if ((valid_IP_part == \"\") || (convert_to_int(valid_IP_part) > 255))\\n                    return false;\\n                else\\n                    valid_IP_part = \"\";\\n            }\\n            else\\n                valid_IP_part += IP_part[i];\\n        }\\n        // Checking the num because last nuumber escaped the check because of else\\n        if (convert_to_int(valid_IP_part) > 255)\\n            return false;\\n        return true;\\n    }\\n    void recursive_function(string s, vector<string> &ans, int i, int dot)\\n    {\\n        // If all dots have been placed, we will check for validity\\n        if (dot == 3)\\n        {\\n            // If IP adress will be Stored if valid\\n            if (valid_ip(s))\\n                ans.push_back(s);\\n            return;\\n        }\\n        if (i >= s.length())\\n            return;\\n        // Either we not put the dot\\n        recursive_function(s, ans, i + 1, dot);\\n        // Or we put the dot\\n        string temp;\\n        // Inserting the dot\\n        for (int k = 0; k < i; k++)\\n            temp += s[k];\\n        temp += \\'.\\';\\n        for (int k = i; k < s.length(); k++)\\n            temp += s[k];\\n        recursive_function(temp, ans, i + 1, dot + 1);\\n    }\\n\\npublic:\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        // Storing IP adresses\\n        vector<string> ans;\\n        recursive_function(s, ans, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778168,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737445,
                "title": "python-concise-backtracking-using-template",
                "content": "Runtime: 28 ms, faster than 94.82% of Python3 online submissions for Restore IP Addresses.\\nMemory Usage: 13.8 MB, less than 54.16% of Python3 online submissions for Restore IP Addresses.\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.res = []\\n        self.backtrack(s, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, s, current, start):\\n        if len(current) == 4 and start == len(s):\\n            self.res.append(\".\".join(current))\\n            return\\n        if len(current) > 4:\\n            return\\n        for i in range(start, min(start+3, len(s))):\\n            if s[start] == \\'0\\' and i > start:\\n                continue\\n            if int(s[start:i+1]) <= 255:\\n                self.backtrack(s, current + [s[start:i+1]], i + 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.res = []\\n        self.backtrack(s, [], 0)\\n        return self.res\\n    \\n    def backtrack(self, s, current, start):\\n        if len(current) == 4 and start == len(s):\\n            self.res.append(\".\".join(current))\\n            return\\n        if len(current) > 4:\\n            return\\n        for i in range(start, min(start+3, len(s))):\\n            if s[start] == \\'0\\' and i > start:\\n                continue\\n            if int(s[start:i+1]) <= 255:\\n                self.backtrack(s, current + [s[start:i+1]], i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504942,
                "title": "java-clean-code-with-choose-explore-unchoose-template-of-backtracking",
                "content": "```java\\npublic List<String> restoreIpAddresses(String s) {\\n\\tList<String> result = new ArrayList<>();\\n\\tif (s == null || s.length() == 0 || s.length() > 12) return result;\\n\\n\\trestoreIpAddressesHelper(s, 0, 0, new StringBuilder(), result);\\n\\treturn result;\\n}\\n\\nprivate void restoreIpAddressesHelper(String s, int index, int count, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  StringBuilder sb, List<String> result) {\\n\\t// Base cases\\n\\tif (index == s.length() && count == 3) {\\n\\t\\tresult.add(sb.toString());\\n\\t\\treturn;\\n\\t}\\n\\tif (count > 3) return;\\n\\n\\tfor (int i = index; i < s.length(); i++) {\\n\\t\\tString part = s.substring(index, i + 1);\\n\\n\\t\\tif (part.length() == 0 || part.length() > 1 && part.charAt(0) == \\'0\\' || \\n\\t\\t   Integer.valueOf(part) > 255) break; // No point of exploring more, so break from the loop\\n\\n\\t\\tint len = sb.length();\\n\\t\\t// Choose\\n\\t\\tsb.append(part);\\n\\n\\t\\t// Explore\\n\\t\\tif (i + 1 == s.length())\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count, sb, result);\\n\\t\\telse {\\n\\t\\t\\tsb.append(\".\"); // Add . in each time, except the last part\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count + 1, sb, result);\\n\\t\\t}\\t\\t\\n\\t\\t// Unchoose\\n\\t\\tsb.setLength(len);\\n\\t}        \\n}\\n\\t",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\npublic List<String> restoreIpAddresses(String s) {\\n\\tList<String> result = new ArrayList<>();\\n\\tif (s == null || s.length() == 0 || s.length() > 12) return result;\\n\\n\\trestoreIpAddressesHelper(s, 0, 0, new StringBuilder(), result);\\n\\treturn result;\\n}\\n\\nprivate void restoreIpAddressesHelper(String s, int index, int count, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  StringBuilder sb, List<String> result) {\\n\\t// Base cases\\n\\tif (index == s.length() && count == 3) {\\n\\t\\tresult.add(sb.toString());\\n\\t\\treturn;\\n\\t}\\n\\tif (count > 3) return;\\n\\n\\tfor (int i = index; i < s.length(); i++) {\\n\\t\\tString part = s.substring(index, i + 1);\\n\\n\\t\\tif (part.length() == 0 || part.length() > 1 && part.charAt(0) == \\'0\\' || \\n\\t\\t   Integer.valueOf(part) > 255) break; // No point of exploring more, so break from the loop\\n\\n\\t\\tint len = sb.length();\\n\\t\\t// Choose\\n\\t\\tsb.append(part);\\n\\n\\t\\t// Explore\\n\\t\\tif (i + 1 == s.length())\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count, sb, result);\\n\\t\\telse {\\n\\t\\t\\tsb.append(\".\"); // Add . in each time, except the last part\\n\\t\\t\\trestoreIpAddressesHelper(s, i + 1, count + 1, sb, result);\\n\\t\\t}\\t\\t\\n\\t\\t// Unchoose\\n\\t\\tsb.setLength(len);\\n\\t}        \\n}\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3079578,
                "title": "java-easy-understanding-using-recursion-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>al=new ArrayList<>();\\n        if(s.length()>12) return al;\\n        help(0,s,al,new ArrayList<>());\\n        return al;\\n    }\\n    public static void help(int ind,String s,List<String>al,ArrayList<String>ds){\\n        if(ind==s.length()&&ds.size()==4){\\n            al.add(String.join(\".\",ds));\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(ind+i>s.length()) return;\\n            String add=s.substring(ind,ind+i);\\n            if(!(add.charAt(0)==\\'0\\'&&add.length()>1||Integer.parseInt(add)>255)){\\n                ds.add(add);\\n                help(ind+i,s,al,ds);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>al=new ArrayList<>();\\n        if(s.length()>12) return al;\\n        help(0,s,al,new ArrayList<>());\\n        return al;\\n    }\\n    public static void help(int ind,String s,List<String>al,ArrayList<String>ds){\\n        if(ind==s.length()&&ds.size()==4){\\n            al.add(String.join(\".\",ds));\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(ind+i>s.length()) return;\\n            String add=s.substring(ind,ind+i);\\n            if(!(add.charAt(0)==\\'0\\'&&add.length()>1||Integer.parseInt(add)>255)){\\n                ds.add(add);\\n                help(ind+i,s,al,ds);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926120,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        if s.count > 12 || s.count < 4 { return [] }\\n        \\n        var chars = Array(s)     \\n        var res: [String] = []\\n        \\n        func backtarck(_ path: [Int], _ length: Int) {\\n            if path.count == 4 {\\n                if length == chars.count {\\n                    var string = \"\"\\n                    for (i, c) in chars.enumerated() {\\n                        string += String(c)\\n                        if i < length - 1 && path.contains(i + 1) {\\n                            string += \".\"\\n                        }\\n                    }\\n                    res.append(string)\\n                }\\n                return\\n            }\\n            \\n            var path = path\\n            for i in 1..<4 {\\n                if i + length > chars.count { break }\\n                \\n                if i >= 2 {\\n                    if Int(String(chars[length]))! == 0 { break }\\n                }\\n                \\n                if i == 3 {\\n                    if Int(String(chars[length]) + String(chars[length + 1]) + String(chars[length + 2]))! > 255 { break }\\n                }\\n                \\n                path.append(length + i)\\n                backtarck(path, length + i)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([], 0)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        if s.count > 12 || s.count < 4 { return [] }\\n        \\n        var chars = Array(s)     \\n        var res: [String] = []\\n        \\n        func backtarck(_ path: [Int], _ length: Int) {\\n            if path.count == 4 {\\n                if length == chars.count {\\n                    var string = \"\"\\n                    for (i, c) in chars.enumerated() {\\n                        string += String(c)\\n                        if i < length - 1 && path.contains(i + 1) {\\n                            string += \".\"\\n                        }\\n                    }\\n                    res.append(string)\\n                }\\n                return\\n            }\\n            \\n            var path = path\\n            for i in 1..<4 {\\n                if i + length > chars.count { break }\\n                \\n                if i >= 2 {\\n                    if Int(String(chars[length]))! == 0 { break }\\n                }\\n                \\n                if i == 3 {\\n                    if Int(String(chars[length]) + String(chars[length + 1]) + String(chars[length + 2]))! > 255 { break }\\n                }\\n                \\n                path.append(length + i)\\n                backtarck(path, length + i)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([], 0)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336483,
                "title": "simple-dfs-python-solution-36ms",
                "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self, s: str, path: List, result: List):\\n        \\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self, s: str, path: List, result: List):\\n        \\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31084,
                "title": "java-easy-to-understand-recursive-solution",
                "content": "        \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new ArrayList<>();\\n        dfs(s, 0, 0, \"\", ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(String s, int idx, int c, String path, List<String> ret) {\\n        if (c >= 4) {\\n            if (idx == s.length()) {\\n                ret.add(path.substring(0, path.length()-1));\\n            }\\n            return;\\n        }\\n        for (int i = idx+1; i <= s.length(); i++) {\\n            if (isValid(s.substring(idx, i))) {\\n                dfs(s, i, c+1, path + s.substring(idx, i) + '.', ret);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.startsWith(\"0\") && !s.equals(\"0\")) {\\n            return false;\\n        }\\n        return s.length() < 4 && 0 <= Integer.valueOf(s) && Integer.valueOf(s) < 256;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ret = new ArrayList<>();\\n        dfs(s, 0, 0, \"\", ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(String s, int idx, int c, String path, List<String> ret) {\\n        if (c >= 4) {\\n            if (idx == s.length()) {\\n                ret.add(path.substring(0, path.length()-1));\\n            }\\n            return;\\n        }\\n        for (int i = idx+1; i <= s.length(); i++) {\\n            if (isValid(s.substring(idx, i))) {\\n                dfs(s, i, c+1, path + s.substring(idx, i) + '.', ret);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.startsWith(\"0\") && !s.equals(\"0\")) {\\n            return false;\\n        }\\n        return s.length() < 4 && 0 <= Integer.valueOf(s) && Integer.valueOf(s) < 256;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3080285,
                "title": "c-simple-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void help(int idx, int k, vector<string> &make, string &s)\\n    {\\n        if (idx >= s.size())\\n        {\\n            if (k == -1)\\n            {\\n                string t;\\n                for (auto i : make)\\n                    t.append(i), t.push_back(\\'.\\');\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            return;\\n        }\\n\\n        if (k < 0)\\n            return;\\n\\n        if (s[idx] == \\'0\\')\\n        {\\n            string t;\\n            t.push_back(s[idx]);\\n            make.push_back(t);\\n            help(idx + 1, k - 1, make, s);\\n            make.pop_back();\\n            return;\\n        }\\n\\n        for (int i = idx; i < min(idx + 3, (int)s.size()); i++)\\n        {\\n            string t = s.substr(idx, i - idx + 1);\\n            int val = stoi(t);\\n            if (val >= 0 and val <= 255)\\n            {\\n                make.push_back(t);\\n                help(i + 1, k - 1, make, s);\\n                make.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        if (s.size() > 12)\\n            return {};\\n\\n        vector<string> make;\\n        help(0, 3, make, s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void help(int idx, int k, vector<string> &make, string &s)\\n    {\\n        if (idx >= s.size())\\n        {\\n            if (k == -1)\\n            {\\n                string t;\\n                for (auto i : make)\\n                    t.append(i), t.push_back(\\'.\\');\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            return;\\n        }\\n\\n        if (k < 0)\\n            return;\\n\\n        if (s[idx] == \\'0\\')\\n        {\\n            string t;\\n            t.push_back(s[idx]);\\n            make.push_back(t);\\n            help(idx + 1, k - 1, make, s);\\n            make.pop_back();\\n            return;\\n        }\\n\\n        for (int i = idx; i < min(idx + 3, (int)s.size()); i++)\\n        {\\n            string t = s.substr(idx, i - idx + 1);\\n            int val = stoi(t);\\n            if (val >= 0 and val <= 255)\\n            {\\n                make.push_back(t);\\n                help(i + 1, k - 1, make, s);\\n                make.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        if (s.size() > 12)\\n            return {};\\n\\n        vector<string> make;\\n        help(0, 3, make, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621595,
                "title": "c-simple-recursion-100-faster-than-all-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string &s , int indx , int len){\\n        if (indx + len > s.size()) return false;\\n        \\n        string _found = s.substr(indx , len);\\n        \\n        if (_found.size() > 1 && _found[0] == \\'0\\') return false;\\n        \\n        int num = stoi(_found);\\n        \\n        if (num > 255) return false;\\n        \\n        return true;\\n    }\\n    void recur(string &s , int indx , int used , vector<string> &res , string curr){\\n        if (indx == s.size() && used == 4){\\n            curr.pop_back();\\n            res.push_back(curr);\\n            return;\\n        }\\n        if (indx >= s.size() || used >= 4){\\n            return;\\n        }\\n        if (isValid(s , indx , 1)){\\n            recur(s , indx + 1 , used + 1 , res , curr + s.substr(indx,1) + \".\");\\n        }\\n        if (isValid(s , indx , 2)){\\n            recur(s , indx + 2 , used + 1 , res , curr + s.substr(indx,2) + \".\");\\n        }\\n        if (isValid(s , indx , 3)){\\n            recur(s , indx + 3 , used + 1 , res , curr + s.substr(indx,3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12) return {};\\n        vector<string> res;\\n        string curr = \"\";\\n        recur(s , 0 , 0 , res , curr);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string &s , int indx , int len){\\n        if (indx + len > s.size()) return false;\\n        \\n        string _found = s.substr(indx , len);\\n        \\n        if (_found.size() > 1 && _found[0] == \\'0\\') return false;\\n        \\n        int num = stoi(_found);\\n        \\n        if (num > 255) return false;\\n        \\n        return true;\\n    }\\n    void recur(string &s , int indx , int used , vector<string> &res , string curr){\\n        if (indx == s.size() && used == 4){\\n            curr.pop_back();\\n            res.push_back(curr);\\n            return;\\n        }\\n        if (indx >= s.size() || used >= 4){\\n            return;\\n        }\\n        if (isValid(s , indx , 1)){\\n            recur(s , indx + 1 , used + 1 , res , curr + s.substr(indx,1) + \".\");\\n        }\\n        if (isValid(s , indx , 2)){\\n            recur(s , indx + 2 , used + 1 , res , curr + s.substr(indx,2) + \".\");\\n        }\\n        if (isValid(s , indx , 3)){\\n            recur(s , indx + 3 , used + 1 , res , curr + s.substr(indx,3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12) return {};\\n        vector<string> res;\\n        string curr = \"\";\\n        recur(s , 0 , 0 , res , curr);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345810,
                "title": "easy-to-understand-javascript-backtracking",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if (s.length > 12 || s.length < 4) return [];\\n    const result = [];\\n    helper(s, [], result);\\n    return result;\\n};\\n\\nconst helper = (s, currSet, result) => {\\n    if (currSet.length === 4 && !s.length) {\\n        result.push(Array.from(currSet).join(\\'.\\'));\\n        return;\\n    }\\n    for (let i = 1; i < 4; i++) {\\n        if(s.length < i) continue; \\n        const str = s.slice(0,i);\\n        if ((str.length > 1 && str[0] === \\'0\\') || Number(str) > 255) continue;\\n        currSet.push(str);\\n        helper(s.slice(i), currSet, result);\\n        currSet.pop();\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if (s.length > 12 || s.length < 4) return [];\\n    const result = [];\\n    helper(s, [], result);\\n    return result;\\n};\\n\\nconst helper = (s, currSet, result) => {\\n    if (currSet.length === 4 && !s.length) {\\n        result.push(Array.from(currSet).join(\\'.\\'));\\n        return;\\n    }\\n    for (let i = 1; i < 4; i++) {\\n        if(s.length < i) continue; \\n        const str = s.slice(0,i);\\n        if ((str.length > 1 && str[0] === \\'0\\') || Number(str) > 255) continue;\\n        currSet.push(str);\\n        helper(s.slice(i), currSet, result);\\n        currSet.pop();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31060,
                "title": "c-backtracking-implementation",
                "content": "C# backtracking implementation\\n```\\n        public  IList<string> RestoreIpAddresses(string s)\\n        {\\n            List<string> res = new List<string>();\\n            List<string> ips = new List<string>();\\n\\n            Find(res, ips, s, 0);\\n            return res;\\n        }\\n\\n        private void Find(IList<string> res, IList<string> ips, string s, int start)\\n        {\\n            if (ips.Count == 4 && start == s.Length)\\n            {\\n                res.Add(string.Join(\".\", ips));\\n                return;\\n            }\\n\\n            if (s.Length - start > (4 - ips.Count) * 3) // pruning if right side contains more characters than needed\\n            {\\n                return;\\n            }\\n\\n            for (int i = start; i < start + 4 && i < s.Length; i++)\\n            {\\n                string ip = s.Substring(start, i - start + 1);\\n                if (int.Parse(ip) > 255 || int.Parse(ip).ToString() != ip) // prevent digit larger or starts with 0\\n                {\\n                    return;\\n                }\\n\\n                ips.Add(ip);\\n                Find(res, ips, s, i + 1);\\n                ips.RemoveAt(ips.Count - 1);\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public  IList<string> RestoreIpAddresses(string s)\\n        {\\n            List<string> res = new List<string>();\\n            List<string> ips = new List<string>();\\n\\n            Find(res, ips, s, 0);\\n            return res;\\n        }\\n\\n        private void Find(IList<string> res, IList<string> ips, string s, int start)\\n        {\\n            if (ips.Count == 4 && start == s.Length)\\n            {\\n                res.Add(string.Join(\".\", ips));\\n                return;\\n            }\\n\\n            if (s.Length - start > (4 - ips.Count) * 3) // pruning if right side contains more characters than needed\\n            {\\n                return;\\n            }\\n\\n            for (int i = start; i < start + 4 && i < s.Length; i++)\\n            {\\n                string ip = s.Substring(start, i - start + 1);\\n                if (int.Parse(ip) > 255 || int.Parse(ip).ToString() != ip) // prevent digit larger or starts with 0\\n                {\\n                    return;\\n                }\\n\\n                ips.Add(ip);\\n                Find(res, ips, s, i + 1);\\n                ips.RemoveAt(ips.Count - 1);\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079577,
                "title": "c-easy-code-comment-explanation-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:  \\n \\nbool subpart(string s, int i, int j){\\n         int len = j-i+1;\\n         if(len >3) return false;\\n         if(s[i] == \\'0\\'){\\n             if(len == 1) return true;\\n             return false;\\n                     }\\n         int num = stoi(s.substr(i,j-i+1));\\n         if(num>=0 && num<=255) return true;\\n         return false;\\n                          \\n   }\\n\\n  bool issafe(string s, int len, int i, int j, int k){\\n     if(subpart(s,0,i) && subpart(s,i+1,j) && subpart(s,j+1,k) && subpart(s,k+1,len-1))//checking each four part whether all these part is valid or not\\n        return true;\\n     else{\\n         return false;\\n         } \\n  }\\n\\n\\nvoid addstring(string s, int n, int i, int j, int k,vector<string> &res){//adding substring part along with . in our result string\\n    string temp;\\n    temp.append(s.substr(0,i+1));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(i+1,j-i));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(j+1,k-j));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(k+1,n-k-1));\\n    res.push_back(temp);\\n}\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        vector<string>res;\\n        int i,j,k;\\n        for(i=0;i<n-3;++i){//checking position of i,j,k in the string which can produce the required result\\n            for(j=i+1;j<n-2;++j){\\n                for(k=j+1;k<n-1;++k){\\n                    if(issafe(s,n,i,j,k))\\n                        addstring(s,n,i,j,k,res);\\n                }\\n            }\\n        }\\n          \\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```\\n**please upvote if you like my code**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n \\nbool subpart(string s, int i, int j){\\n         int len = j-i+1;\\n         if(len >3) return false;\\n         if(s[i] == \\'0\\'){\\n             if(len == 1) return true;\\n             return false;\\n                     }\\n         int num = stoi(s.substr(i,j-i+1));\\n         if(num>=0 && num<=255) return true;\\n         return false;\\n                          \\n   }\\n\\n  bool issafe(string s, int len, int i, int j, int k){\\n     if(subpart(s,0,i) && subpart(s,i+1,j) && subpart(s,j+1,k) && subpart(s,k+1,len-1))//checking each four part whether all these part is valid or not\\n        return true;\\n     else{\\n         return false;\\n         } \\n  }\\n\\n\\nvoid addstring(string s, int n, int i, int j, int k,vector<string> &res){//adding substring part along with . in our result string\\n    string temp;\\n    temp.append(s.substr(0,i+1));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(i+1,j-i));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(j+1,k-j));\\n    temp.push_back(\\'.\\');\\n    temp.append(s.substr(k+1,n-k-1));\\n    res.push_back(temp);\\n}\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        vector<string>res;\\n        int i,j,k;\\n        for(i=0;i<n-3;++i){//checking position of i,j,k in the string which can produce the required result\\n            for(j=i+1;j<n-2;++j){\\n                for(k=j+1;k<n-1;++k){\\n                    if(issafe(s,n,i,j,k))\\n                        addstring(s,n,i,j,k,res);\\n                }\\n            }\\n        }\\n          \\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745164,
                "title": "simple-backtracking-solution-runtime-100-faster-memory-97-lesser",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string str) {\\n        \\n        vector<string>v;\\n        string ans;\\n        helper(ans, str, 0, 0,v);\\n        return v;\\n        \\n    }\\n    \\n    void helper(string ans, string str, int idx, int k,vector<string>&v){\\n     \\n        if(k==4 ){\\n            if(idx>=str.length()){\\n                ans.pop_back();\\n                v.push_back(ans);\\n            }\\n            return ;\\n        }\\n\\t\\t\\n        string ip;\\n        for(int i=idx;i<str.length();i++){\\n            if(ip==\"0\"){\\n                return ;\\n            }\\n             ip=ip+str[i];\\n   \\n            if(stoi(ip)>=0 && stoi(ip) <=255){\\n                string x=ans;\\n                ans=ans+ip+\".\";\\n              \\n                helper(ans,str,i+1,k+1,v);\\n\\t\\t\\t\\t\\n                ans=x;\\n            }\\n            \\n            else if(stoi(ip)>255){\\n                return;\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string str) {\\n        \\n        vector<string>v;\\n        string ans;\\n        helper(ans, str, 0, 0,v);\\n        return v;\\n        \\n    }\\n    \\n    void helper(string ans, string str, int idx, int k,vector<string>&v){\\n     \\n        if(k==4 ){\\n            if(idx>=str.length()){\\n                ans.pop_back();\\n                v.push_back(ans);\\n            }\\n            return ;\\n        }\\n\\t\\t\\n        string ip;\\n        for(int i=idx;i<str.length();i++){\\n            if(ip==\"0\"){\\n                return ;\\n            }\\n             ip=ip+str[i];\\n   \\n            if(stoi(ip)>=0 && stoi(ip) <=255){\\n                string x=ans;\\n                ans=ans+ip+\".\";\\n              \\n                helper(ans,str,i+1,k+1,v);\\n\\t\\t\\t\\t\\n                ans=x;\\n            }\\n            \\n            else if(stoi(ip)>255){\\n                return;\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593871,
                "title": "javascript-backtracking-solution",
                "content": "Credits to https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\nThis is classical backtracking challenge.\\nI listed few more solutions for simmilar problems below:\\n* https://leetcode.com/problems/restore-ip-addresses\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    backtrack([], s, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, s, start) {\\n        if (start === s.length && tempArr.length === 4) {\\n            result.push(tempArr.join(\\'.\\'));\\n            return;\\n        } \\n\\n        if (tempArr.length === 4 || start > s.length) {\\n            return;\\n        }\\n\\n        for (let i = 1; i < 4; i++) {\\n            const sub = s.substring(start, start + i);\\n            if (sub.length > 1 && sub[0] === \\'0\\') {\\n                continue;\\n            }\\n            const int = parseInt(sub);\\n            if (int < 256 && int >= 0) {\\n                // 1:\\n                // tempArr.push(sub);\\n                // backtrack(tempArr, s, start + i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, sub], s, start + i);\\n            }\\n        }\\n    }\\n};\\n```\\n* https://leetcode.com/problems/combination-sum\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let result = [];\\n    backtrack([], target, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, remain, start){\\n        if(remain < 0){\\n            return;\\n        }\\n        else if (remain === 0){\\n            result.push(tempArr);\\n        }\\n        else {\\n            for(let i = start; i < candidates.length; i++){\\n                // 1:\\n                // tempArr.push(candidates[i]);\\n                // backtrack([...tempArr], remain - candidates[i], i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, candidates[i]], remain - candidates[i], i); // not i+1, because we can reuse same elements\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    backtrack([], s, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, s, start) {\\n        if (start === s.length && tempArr.length === 4) {\\n            result.push(tempArr.join(\\'.\\'));\\n            return;\\n        } \\n\\n        if (tempArr.length === 4 || start > s.length) {\\n            return;\\n        }\\n\\n        for (let i = 1; i < 4; i++) {\\n            const sub = s.substring(start, start + i);\\n            if (sub.length > 1 && sub[0] === \\'0\\') {\\n                continue;\\n            }\\n            const int = parseInt(sub);\\n            if (int < 256 && int >= 0) {\\n                // 1:\\n                // tempArr.push(sub);\\n                // backtrack(tempArr, s, start + i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, sub], s, start + i);\\n            }\\n        }\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let result = [];\\n    backtrack([], target, 0);\\n    return result;\\n    \\n    function backtrack(tempArr, remain, start){\\n        if(remain < 0){\\n            return;\\n        }\\n        else if (remain === 0){\\n            result.push(tempArr);\\n        }\\n        else {\\n            for(let i = start; i < candidates.length; i++){\\n                // 1:\\n                // tempArr.push(candidates[i]);\\n                // backtrack([...tempArr], remain - candidates[i], i);\\n                // tempArr.pop();\\n                // 2:\\n                backtrack([...tempArr, candidates[i]], remain - candidates[i], i); // not i+1, because we can reuse same elements\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168080,
                "title": "concise-java-backtracking-solution",
                "content": "```\\npublic List<String> restoreIpAddresses(String s)\\n    {\\n        List<String> result = new ArrayList<>();\\n        helper(result, s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void helper(List<String> result, String s, List<String> tempList)\\n    {\\n        if (tempList.size() == 4) {\\n            if (s.length() == 0) {\\n                result.add(String.join(\".\", tempList));\\n            }\\n            return;\\n        }\\n        for (int i = 1; i < 4; i++) {\\n            if (s.length() < i) {\\n                break;\\n            }\\n            String substring = s.substring(0, i);\\n            if ((substring.startsWith(\"0\") && substring.length() != 1) || Integer.parseInt(substring) > 255) {\\n                continue;\\n            }\\n            tempList.add(substring);\\n            helper(result, s.length() == i ? \"\" : s.substring(i, s.length()), tempList);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> restoreIpAddresses(String s)\\n    {\\n        List<String> result = new ArrayList<>();\\n        helper(result, s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void helper(List<String> result, String s, List<String> tempList)\\n    {\\n        if (tempList.size() == 4) {\\n            if (s.length() == 0) {\\n                result.add(String.join(\".\", tempList));\\n            }\\n            return;\\n        }\\n        for (int i = 1; i < 4; i++) {\\n            if (s.length() < i) {\\n                break;\\n            }\\n            String substring = s.substring(0, i);\\n            if ((substring.startsWith(\"0\") && substring.length() != 1) || Integer.parseInt(substring) > 255) {\\n                continue;\\n            }\\n            tempList.add(substring);\\n            helper(result, s.length() == i ? \"\" : s.substring(i, s.length()), tempList);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31066,
                "title": "simple-java-solution-beating-100-of-java-submissions",
                "content": "    /*Description of variables\\n    result - list of valid ip addr strings\\n    digits -char array representation of s\\n    len - length of s\\n    currIpAddr - char array that contains the IP addr we are building using backtracking\\n    remSegs - no. of segments remaining to be parsed. there 4 segments to an ip addr\\n    start - start index in the digits array for the current ip addr segment\\n    pos - next index to be populated in the currIpAddr array\\n\\n    */\\n\\n    public class Solution {\\n    \\n    private static final char DOT = '.';\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<String>();\\n        \\n        char[] digits = s.toCharArray();\\n        int len = s.length();\\n        char[] currIpAddr = new char[len+3];\\n        int pos = 0;\\n        generateIpAddresses(digits, 4, 0, len, currIpAddr, pos, result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateIpAddresses(char[] digits, int remSegs, int start, int len, \\n                                     char[] currIpAddr, int pos, List<String> result) {\\n            if(start == len && remSegs == 0) {\\n                result.add(String.valueOf(currIpAddr));\\n                return;\\n            }   \\n        \\n       //1. Checks for length of s too small\\n       //2. Maximum Length of the remaining segments. Since a sgemnt can be upto 3 digits\\n       // Length can not exceed 3x the remaining segments.\\n       //3. Minimum Length of s. Each segment has to be atleast 1 digit\\n        if((start > len) || ((len - start) > (3 * remSegs)) || ((len - start) < remSegs))\\n            return;\\n        \\n        if(remSegs < 4)\\n            currIpAddr[pos++] = DOT;\\n        \\n        int num = 0;\\n        \\n        for(int i = 0; i < Math.min(len-start, 3);i++) {\\n            num = (10*num) + (int)(digits[start+i] - '0');\\n            \\n            if(i > 0 && num < 10)// leading 0 cases i = 1, then the number should be > 10.\\n                return;\\n            \\n            ////\"010010\"\\n            //Valid: [\"0.10.0.10\",\"0.100.1.0\"]\\n            //Invalid: [\"0.1.0.010\",\"0.1.00.10\",\"0.1.001.0\",\"0.10.0.10\",\"0.10.01.0\",\"0.100.1.0\",\\n            //\"01.0.0.10\",\"01.0.01.0\",\"01.00.1.0\",\"010.0.1.0\"]\\n            \\n            if(num <= 255) {\\n                currIpAddr[pos+i] = digits[start+i];\\n                generateIpAddresses(digits, remSegs-1, start+i+1, len, currIpAddr, pos+i+1, result);\\n            }\\n        }\\n      }    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private static final char DOT = '.';\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<String>();\\n        \\n        char[] digits = s.toCharArray();\\n        int len = s.length();\\n        char[] currIpAddr = new char[len+3];\\n        int pos = 0;\\n        generateIpAddresses(digits, 4, 0, len, currIpAddr, pos, result);\\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 31146,
                "title": "my-short-c-recursive-version-4-ms-with-explanation",
                "content": "The idea is to have a recursive function buildIP to generate an IP string with \"num\" numbers using the substring [start, npos] of s. First it checks the substring has proper number of digits (>=num && <=3*num). Also it checks if the substring starts with '0' and has some extra digits. If so, it is not a valid case, so abandon it. Otherwise, if it is the last number, then check if it is no larger than 255 and if so, add to the resulting vector. If it is not the last number, recursively call itself to build the rest of the number sequence. For the current number, it can only be 1, 2, or 3 digits. Again, remember to check if it starts with '0' and is no larger than 255.\\n \\n\\n       class Solution {\\n        public:\\n            void  buildIP(vector<string> &res, string &s, int start, int num, string cur)\\n            {\\n                int numDigits = s.size()-start;\\n                if(numDigits<num || numDigits> 3*num) return;\\n                if(num==1)\\n                {\\n                    if((numDigits==1) || ( s[start]!='0' && atoi(s.substr(start).c_str())<=255))\\n                        res.push_back(cur + s.substr(start));\\n                }\\n                else\\n                {\\n                    buildIP(res, s, start+1, num-1, cur+ s.substr(start,1) + \".\");\\n                    if(s[start]!='0')\\n                    {\\n                        buildIP(res, s, start+2, num-1, cur+ s.substr(start,2) + \".\");\\n                        if(atoi(s.substr(start,3).c_str())<=255) buildIP(res, s, start+3, num-1, cur+ s.substr(start,3) + \".\");\\n                    }\\n                }\\n            }\\n        \\n            vector<string> restoreIpAddresses(string s) {\\n               int len = s.size();\\n               vector<string> res;\\n               buildIP(res, s, 0, 4, \"\");\\n               return res;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            void  buildIP(vector<string> &res, string &s, int start, int num, string cur)\\n            {\\n                int numDigits = s.size()-start;\\n                if(numDigits<num || numDigits> 3*num) return;\\n                if(num==1)\\n                {\\n                    if((numDigits==1) || ( s[start]!='0' && atoi(s.substr(start).c_str())<=255))\\n                        res.push_back(cur + s.substr(start));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3080381,
                "title": "c-backtracking-easy-approach-with-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntry out all possibilities. \\nfirst possibility: take single character\\nsecond and thirs possibility: take 2 and 3 characters respectively. for this case ensure that number doesn\\'t start with 0 and is less than 255\\ncount number of dots you add (i.e splits you have made). if this is equal to 3 (excluding last dot added ) and end of string is reached we have a valid ip\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can use dfs to explore all the combinations. \\nat each ith postion, we need to try out with next i +1, i+2 and i+3 substring. \\nif this substring is valid (for single digit 0-9 are valid cases and for 2 or 3 digits if them number doesn\\'t start with 0 and is less than 255) proceed for next 1 to 3 substr\\nwe stop only when \\n\\n# Complexity\\n- Time complexity:\\n- \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string sub) {\\n        if(sub.size()==1)\\n            return true;\\n        if(sub.size()>1 && sub[0]!=\\'0\\' && stoi(sub) <=255)\\n            return true;\\n        \\n        return false;\\n       \\n    }\\n    void dfs(vector<string>& ans, string s, string path, int i, int dots) {\\n// count number of dots, valid ip cannot have more than 3 dots.\\n// when end of string is reached and number of dot is 3 (after popping last one) then it is a valid ip\\n        if(dots==4) {\\n            if(i == s.length()) {\\n                path.pop_back();\\n                ans.push_back(path);\\n            }\\n            return; \\n        }\\n\\n        // iterate over next 1 to 3 substrings\\n        for(int k=1; k<=3; k++) {\\n            // if substr is >=0 and <=255 \\n            if(i+k<=s.length() && isValid(s.substr(i,k)))  {;\\n                dfs(ans, s, path+s.substr(i,k)+\\'.\\', i+k, dots+1);\\n            }\\n        }\\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans; \\n        string path; \\n        dfs(ans, s, path, 0, 0);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string sub) {\\n        if(sub.size()==1)\\n            return true;\\n        if(sub.size()>1 && sub[0]!=\\'0\\' && stoi(sub) <=255)\\n            return true;\\n        \\n        return false;\\n       \\n    }\\n    void dfs(vector<string>& ans, string s, string path, int i, int dots) {\\n// count number of dots, valid ip cannot have more than 3 dots.\\n// when end of string is reached and number of dot is 3 (after popping last one) then it is a valid ip\\n        if(dots==4) {\\n            if(i == s.length()) {\\n                path.pop_back();\\n                ans.push_back(path);\\n            }\\n            return; \\n        }\\n\\n        // iterate over next 1 to 3 substrings\\n        for(int k=1; k<=3; k++) {\\n            // if substr is >=0 and <=255 \\n            if(i+k<=s.length() && isValid(s.substr(i,k)))  {;\\n                dfs(ans, s, path+s.substr(i,k)+\\'.\\', i+k, dots+1);\\n            }\\n        }\\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans; \\n        string path; \\n        dfs(ans, s, path, 0, 0);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079523,
                "title": "java-backtracking-approach-better-than-leetcode-solution",
                "content": "```\\n// Approach #1: Backtracking Approach\\n\\n// Time complexity: O(m^n * n)\\n// Space complexity: O(m * n)\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        helper(s, 0, result, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void helper(String s, int index, List<String> result, List<String> list) {\\n        if (index >= s.length()) {\\n            if (list.size() == 4) \\n                result.add(String.join(\".\", list));\\n                \\n            return;\\n        }\\n        \\n        if (list.size() >= 4)\\n            return;   \\n        \\n        else {\\n            for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n                String str = s.substring(index, index + i);\\n                int ip = Integer.valueOf(str);\\n\\n                if (ip >= 0 && ip <= 255) {\\n                    list.add(str);\\n                    helper(s, index + i, result, list);\\n                    list.remove(list.size() - 1);\\n                }\\n                \\n                if (ip == 0)\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Approach #1: Backtracking Approach\\n\\n// Time complexity: O(m^n * n)\\n// Space complexity: O(m * n)\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        helper(s, 0, result, new ArrayList<>());\\n        return result;\\n    }\\n    \\n    private void helper(String s, int index, List<String> result, List<String> list) {\\n        if (index >= s.length()) {\\n            if (list.size() == 4) \\n                result.add(String.join(\".\", list));\\n                \\n            return;\\n        }\\n        \\n        if (list.size() >= 4)\\n            return;   \\n        \\n        else {\\n            for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n                String str = s.substring(index, index + i);\\n                int ip = Integer.valueOf(str);\\n\\n                if (ip >= 0 && ip <= 255) {\\n                    list.add(str);\\n                    helper(s, index + i, result, list);\\n                    list.remove(list.size() - 1);\\n                }\\n                \\n                if (ip == 0)\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079507,
                "title": "java-easy-recursive",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new LinkedList<>();\\n        // Call the helper method with the input string, the ans list, a counter initialized to 0, and empty strings for the current decimal and current IP address\\n        helper(s,ans,0,\"\",\"\");\\n        return ans;\\n    }\\n\\n    public void helper(String s, List<String> ans, int dec, String r ,String a){\\n        if(r.length()>2 && Integer.parseInt(r)>255)return;\\n        // If the number of parts in the current IP address is greater than 4, return\\n        if(dec>4) return;\\n        // If the current decimal String has more than 1 digit and starts with 0, return\\n        if(r.length()>1 && Integer.parseInt(r.charAt(0)+\"\")==0)return;\\n        // Concatenate the current decimal to the current IP address\\n        a+=r;\\n        // If the number of decimals is 4 and the input string is empty, add the current IP address to the list of valid IP addresses\\n        if(dec==4 && s.length()==0)ans.add(a);\\n        // If the current decimal is not empty, add a period to the current IP address\\n        if(r.length()>0)a+=\".\";\\n        // Recursively call the helper method with various substrings of the input string, incremented counter and the current IP address\\n        if(s.length()>0) helper(s.substring(1,s.length()),ans,dec+1,s.substring(0,1),a);\\n        if(s.length()>1) helper(s.substring(2,s.length()),ans,dec+1,s.substring(0,2),a);\\n        if(s.length()>2) helper(s.substring(3,s.length()),ans,dec+1,s.substring(0,3),a);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new LinkedList<>();\\n        // Call the helper method with the input string, the ans list, a counter initialized to 0, and empty strings for the current decimal and current IP address\\n        helper(s,ans,0,\"\",\"\");\\n        return ans;\\n    }\\n\\n    public void helper(String s, List<String> ans, int dec, String r ,String a){\\n        if(r.length()>2 && Integer.parseInt(r)>255)return;\\n        // If the number of parts in the current IP address is greater than 4, return\\n        if(dec>4) return;\\n        // If the current decimal String has more than 1 digit and starts with 0, return\\n        if(r.length()>1 && Integer.parseInt(r.charAt(0)+\"\")==0)return;\\n        // Concatenate the current decimal to the current IP address\\n        a+=r;\\n        // If the number of decimals is 4 and the input string is empty, add the current IP address to the list of valid IP addresses\\n        if(dec==4 && s.length()==0)ans.add(a);\\n        // If the current decimal is not empty, add a period to the current IP address\\n        if(r.length()>0)a+=\".\";\\n        // Recursively call the helper method with various substrings of the input string, incremented counter and the current IP address\\n        if(s.length()>0) helper(s.substring(1,s.length()),ans,dec+1,s.substring(0,1),a);\\n        if(s.length()>1) helper(s.substring(2,s.length()),ans,dec+1,s.substring(0,2),a);\\n        if(s.length()>2) helper(s.substring(3,s.length()),ans,dec+1,s.substring(0,3),a);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079467,
                "title": "0ms-runtime-code-c-python-explained",
                "content": "# Solution:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n=s.size();\\n        //if the size of string is 1 that is always possible so return true\\n        if(n==1){\\n            return true;\\n        }\\n        //if we have length >3 or string starts with 0 return false\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        //we are converting string to integer to check if it is less than equalto 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        //return true at last\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        //we will store our ans in ans vector of strings\\n        vector<string>ans;\\n        //the max length of the ip address could be 12 as 255.255.255.255 so \\n        //all the string s with size greater than 12 can have ans\\n        if(n>12){\\n            return ans;\\n        }\\n        //now we have our string of length 12 or less than 12 so now \\n            //1. we have to spit the s in parts such that it satisfy the ip address conditions\\n            //2. if all 4 strings satisfy the condition we will push into ans vector\\n        \\n        for(int i=1;i<=3;i++){//for the length before first \\'.\\'\\n            for(int j=1;j<=3;j++){//for the length between first and second \\'.\\'\\n                for(int k=1;k<=3;k++){//for the length between second and third \\'.\\'\\n                    //checking condition if the last segment is of length 3 or less\\n                    if(i+j+k<n&&i+j+k+3>=n){\\n                        //dividing the s int substrings \\n                        string a=s.substr(0,i);\\n                        string b=s.substr(i,j);\\n                        string c=s.substr(j+i,k);\\n                        string d=s.substr(i+j+k);\\n                        //if all the substring satisfy the check function condition \\n                        //then we will push into ans vector \\n                        if(check(a)&&check(b)&&check(c)&&check(d)){\\n                            ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //return the ans vector\\n        return ans;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```\\n\\n*Please upvote if helped*",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n=s.size();\\n        //if the size of string is 1 that is always possible so return true\\n        if(n==1){\\n            return true;\\n        }\\n        //if we have length >3 or string starts with 0 return false\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        //we are converting string to integer to check if it is less than equalto 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        //return true at last\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.size();\\n        //we will store our ans in ans vector of strings\\n        vector<string>ans;\\n        //the max length of the ip address could be 12 as 255.255.255.255 so \\n        //all the string s with size greater than 12 can have ans\\n        if(n>12){\\n            return ans;\\n        }\\n        //now we have our string of length 12 or less than 12 so now \\n            //1. we have to spit the s in parts such that it satisfy the ip address conditions\\n            //2. if all 4 strings satisfy the condition we will push into ans vector\\n        \\n        for(int i=1;i<=3;i++){//for the length before first \\'.\\'\\n            for(int j=1;j<=3;j++){//for the length between first and second \\'.\\'\\n                for(int k=1;k<=3;k++){//for the length between second and third \\'.\\'\\n                    //checking condition if the last segment is of length 3 or less\\n                    if(i+j+k<n&&i+j+k+3>=n){\\n                        //dividing the s int substrings \\n                        string a=s.substr(0,i);\\n                        string b=s.substr(i,j);\\n                        string c=s.substr(j+i,k);\\n                        string d=s.substr(i+j+k);\\n                        //if all the substring satisfy the check function condition \\n                        //then we will push into ans vector \\n                        if(check(a)&&check(b)&&check(c)&&check(d)){\\n                            ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //return the ans vector\\n        return ans;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # Store all addresses in res\\n        res = []\\n        \\n        def BT(i,address):\\n            \\n            # No more digit, so no more state can be generated.\\n            if i==len(s):\\n                # It is possible that the address contains less than 4 numbers\\n                # We only store the valid ones.\\n                if len(address)==4:\\n                    res.append( \\'.\\'.join(map(str,address)) )\\n                return\\n            \\n            # If the last number is 0, we can add the new digit to it (no leading zero)\\n            # After adding the new digit, the number has to be <= 255.\\n            if address[-1]!=0 and address[-1]*10+int(s[i]) <= 255:\\n                lastItem = address[-1]\\n                address[-1] = lastItem*10+int(s[i]) #change the current state to its neighboring state\\n                BT(i+1, address)                    #backtrack(state)\\n                address[-1] = lastItem              #restore the state (backtrack)\\n            \\n            # The address can not contain more than 4 numbers.\\n            if len(address)<4:\\n                address.append(int(s[i]))           #change the current state to its neighboring state\\n                BT(i+1,address)         #backtrack(state)\\n                address.pop()                       #restore the state (backtrack)\\n        \\n        BT(1,[int(s[0])])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078796,
                "title": "commented-java-solution-using-backtracking",
                "content": "In order to produce all solutions we must iterate over all collections of characters of size 1-3 and see if they form a valid IP integer. If it does, we add it to our \"temp\" list and continue recursing through the input until temp has 4 strings and is using all the digits from input. To proceed producing the other results that don\\'t contain the first collection of characters we chose, we remove the item we just added to temp and continue iterating over the size of collection of characters we may include in one integer of the IP address.\\n\\n```\\nclass Solution {\\n    // Stores a list of all possible IPs\\n    LinkedList<String> result = new LinkedList<String>();\\n    \\n    // Stores the current IP being evaluated.\\n    // Each item in this list is a number to be joined by \".\" to form an IP address.\\n    LinkedList<String> temp = new LinkedList<String>();\\n    \\n    private void backtrack(String input, int start, int length) {\\n        int n = input.length();\\n        \\n        // If the collective string length of temp is equal to the length of input & temp has 4 different strings, then add temp to result\\n        if(length == input.length() && temp.size() == 4) {\\n            result.add(String.join(\".\", temp));\\n        }\\n        // If temp size is greater than 4 its not a valid IP\\n        else if(temp.size() >= 4) {\\n            return;\\n        }\\n        \\n        // Iteratively add the next 3 characters to temp\\n        for(int i = 1; i <= 3; i++) {\\n            if(start + i > n) break;\\n            \\n            // Parse the next 1-3 characters\\n            String nextChars = input.substring(start, start+i);\\n            \\n            // Validate the value\\n            if(!isValid(nextChars)) continue;\\n            \\n            // Add the next few chars to temp\\n            temp.add(nextChars);\\n            \\n            // Recurse after choosing a group of characters to include\\n            backtrack(input, start+i, length+nextChars.length());\\n            \\n            // Remove the few chars from temp that we just added to obtain other possible solutions\\n            temp.removeLast();\\n        }\\n    }\\n    \\n    // Returns true if s is a valid integer to form an IP address\\n    private boolean isValid(String s) {\\n        if(s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        \\n        return Integer.parseInt(s) <= 255;\\n    }\\n    \\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        int n = s.length();\\n        if(n == 0 || n > 12) return result;\\n        backtrack(s, 0, 0);\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nLet me know if you have questions",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // Stores a list of all possible IPs\\n    LinkedList<String> result = new LinkedList<String>();\\n    \\n    // Stores the current IP being evaluated.\\n    // Each item in this list is a number to be joined by \".\" to form an IP address.\\n    LinkedList<String> temp = new LinkedList<String>();\\n    \\n    private void backtrack(String input, int start, int length) {\\n        int n = input.length();\\n        \\n        // If the collective string length of temp is equal to the length of input & temp has 4 different strings, then add temp to result\\n        if(length == input.length() && temp.size() == 4) {\\n            result.add(String.join(\".\", temp));\\n        }\\n        // If temp size is greater than 4 its not a valid IP\\n        else if(temp.size() >= 4) {\\n            return;\\n        }\\n        \\n        // Iteratively add the next 3 characters to temp\\n        for(int i = 1; i <= 3; i++) {\\n            if(start + i > n) break;\\n            \\n            // Parse the next 1-3 characters\\n            String nextChars = input.substring(start, start+i);\\n            \\n            // Validate the value\\n            if(!isValid(nextChars)) continue;\\n            \\n            // Add the next few chars to temp\\n            temp.add(nextChars);\\n            \\n            // Recurse after choosing a group of characters to include\\n            backtrack(input, start+i, length+nextChars.length());\\n            \\n            // Remove the few chars from temp that we just added to obtain other possible solutions\\n            temp.removeLast();\\n        }\\n    }\\n    \\n    // Returns true if s is a valid integer to form an IP address\\n    private boolean isValid(String s) {\\n        if(s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        \\n        return Integer.parseInt(s) <= 255;\\n    }\\n    \\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        int n = s.length();\\n        if(n == 0 || n > 12) return result;\\n        backtrack(s, 0, 0);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597069,
                "title": "my-java-backtrack-solution",
                "content": "\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\tList<String> result = new ArrayList<>();\\n\\t\\tif(s == null || s.length() == 0) return result;\\n\\t\\tbacktrack(result, s, \"\", 0, 0);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic void backtrack(List<String> res, String s, String curr, int start, int level) {\\n\\t\\tif(level >= 4) {\\n\\t\\t\\tif(start == s.length()) {\\n\\t\\t\\t\\tres.add(curr);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i = start; i < Math.min(start+3, s.length()); i++) {\\n\\t\\t\\tif(start != i && s.charAt(start) == \\'0\\') continue;\\n\\t\\t\\tint num = Integer.parseInt(s.substring(start, i+1));\\n\\t\\t\\tif(num > 255) break;\\n\\t\\t\\tif(curr == \"\") {\\n\\t\\t\\t\\tbacktrack(res, s, \"\"+ num, i+1, level+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbacktrack(res, s, curr + \".\"+ num, i+1, level+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\tList<String> result = new ArrayList<>();\\n\\t\\tif(s == null || s.length() == 0) return result;\\n\\t\\tbacktrack(result, s, \"\", 0, 0);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic void backtrack(List<String> res, String s, String curr, int start, int level) {\\n\\t\\tif(level >= 4) {\\n\\t\\t\\tif(start == s.length()) {\\n\\t\\t\\t\\tres.add(curr);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i = start; i < Math.min(start+3, s.length()); i++) {\\n\\t\\t\\tif(start != i && s.charAt(start) == \\'0\\') continue;\\n\\t\\t\\tint num = Integer.parseInt(s.substring(start, i+1));\\n\\t\\t\\tif(num > 255) break;\\n\\t\\t\\tif(curr == \"\") {\\n\\t\\t\\t\\tbacktrack(res, s, \"\"+ num, i+1, level+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbacktrack(res, s, curr + \".\"+ num, i+1, level+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 31028,
                "title": "simple-python-backtracking-solution",
                "content": "If the length of current is 4 and start point equals to the length of s, then add it to the result.\\nThen check the next 3 number from index start, and make sure that it does not exceed the total length of s. If the first digit is 0 and i>start, like 09 or 01, then skip those conditions.\\n\\n```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def bt(start, current):\\n            if len(current) == 4:\\n                if start == len(s):\\n                    result.append('.'.join(current))\\n                return\\n            for i in xrange(start+1, min(start+4, len(s)+1)):\\n                if i-1>start and s[start] == '0':\\n                    continue\\n                a = s[start:i]\\n                if 0 <= int(a) <= 255:\\n                    current.append(a)\\n                    bt(i, current)\\n                    current.pop()\\n        \\n        result = []\\n        bt(0, [])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def restoreIpAddresses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def bt(start, current):\\n            if len(current) == 4:\\n                if start == len(s):\\n                    result.append('.'.join(current))\\n                return\\n            for i in xrange(start+1, min(start+4, len(s)+1)):\\n                if i-1>start and s[start] == '0':\\n                    continue\\n                a = s[start:i]\\n                if 0 <= int(a) <= 255:\\n                    current.append(a)\\n                    bt(i, current)\\n                    current.pop()\\n        \\n        result = []\\n        bt(0, [])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31145,
                "title": "my-cpp-backtracking-solution",
                "content": "    class Solution {\\n    public:\\n    \\tvector<string> restoreIpAddresses(string s) {\\n    \\t\\tvector<string> res;\\n    \\t\\tstring ans;\\n    \\t\\tdfs(res, s,ans, 0,0);\\n    \\t\\treturn res;\\n    \\t}\\n    \\tvoid dfs(vector<string>& res, string s, string ans,int idx, int depth)\\n    \\t{\\n    \\t\\tif (depth > 4) return;\\n    \\t\\tif ((depth == 4) && (idx == s.size()))\\n    \\t\\t{\\n    \\t\\t    ans.erase(ans.end()-1);\\n    \\t\\t\\tres.push_back(ans);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = 1; i < 4; ++i)\\n    \\t\\t{\\n    \\t    \\tif (s[idx] == '0' && i>1) return;\\n    \\t\\t\\tif (idx + i > s.size()) return;\\n    \\t\\t\\tauto tmp = s.substr(idx, i);\\n    \\t\\t\\tif (stoi(tmp) < 256)\\n    \\t\\t\\t{\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\tdfs(res, s, ans+ tmp+\".\", idx + i, depth + 1);\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t{\\n    \\t\\t\\t\\treturn;\\n    \\t\\t\\t}\\n    \\t\\t}\\t\\t\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<string> restoreIpAddresses(string s) {\\n    \\t\\tvector<string> res;\\n    \\t\\tstring ans;\\n    \\t\\tdfs(res, s,ans, 0,0);\\n    \\t\\treturn res;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3083003,
                "title": "simplest-rejava-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe \"solve\" method uses a recursive approach to build all possible IP addresses by adding characters from the input string to the \"str\" variable either as it is or with a dot in front of it. When the index reaches the end of the input string or **the number of dots used reaches 4**, the current IP address is checked for validity using the \"correct\" method. If it is valid, it is added to the list of valid IP addresses.\\n\\nThe \"correct\" method checks if the given IP address is a valid IP address by checking **if the length of the IP address is not 0, if the last character is not a dot, if the length of each segment between dots is between 1 and 3 and if each segment is between 0 and 255 and also if there are 3 dots in the IP address.**\\n\\nIn summary, this code uses a recursive approach to generate all possible IP addresses from a given string and then checks each one for validity using the \"correct\" method.\\n\\n# Complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the above code is **O(n)** where **n is the length of the input string**. The main source of space usage is the *recursion stack* used by the \"solve\" method.\\n\\nThe maximum depth of the recursion will be equal to the length of the input string because at each level of the recursion, we are either adding a character or a dot to the IP address string. Since we are not storing any other data during the recursion, the space complexity is directly proportional to the length of the input string.\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        String str=\"\";\\n        List<String> ans=new ArrayList<>();\\n\\n        solve(ans,s,0,str,0,s.length());\\n        \\n        return ans;\\n    }\\n\\n    public void solve(List<String> a,String s,int index,String str, int nod,int n){\\n\\n        if(index==n || nod==4)\\n        {\\n            if(correct(str)==true )     a.add(str);\\n            \\n            return;\\n        }\\n\\n        //dont put a dot\\n        solve(a,s,index+1 , str+=s.charAt(index), nod,n);\\n\\n        //put the dot\\n        solve(a,s,index+1,str+=\\'.\\',nod+1,n);\\n        \\n        return;\\n    }\\n\\n    public boolean correct (String str)\\n    {\\n        \\n        if (str.length() == 0)                      return false;\\n        if(str.charAt(str.length() - 1) == \\'.\\' )    return false;\\n        \\n        String temp = \"\";\\n        int count = 0;\\n        for(int i = 0;i < str.length(); i++)\\n        {\\n           \\n            if(str.charAt(i) == \\'.\\' )\\n            {\\n                count++;\\n                if(temp.length()>3 || temp.length()==0)                     return false;\\n                if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n                if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n                temp=\"\";\\n            }\\n            else\\n            {\\n                temp+=str.charAt(i);\\n            }\\n            \\n        //last string will be left as in the string 125.34.54.789 temp will store 132 but as after 789 no \\'.\\' will be there so it wont check the conditions on \"789\"   \\n\\n        }\\n        if(temp.length()>3 || temp.length()==0)                     return false;\\n        if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n        if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n        if(count!=3)                                                return false;\\n       \\n        return true;\\n    }\\n}\\n\\n```\\n\\n***Please consider upvoting if you found this information helpful.***",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Recursion",
                    "String Matching"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        String str=\"\";\\n        List<String> ans=new ArrayList<>();\\n\\n        solve(ans,s,0,str,0,s.length());\\n        \\n        return ans;\\n    }\\n\\n    public void solve(List<String> a,String s,int index,String str, int nod,int n){\\n\\n        if(index==n || nod==4)\\n        {\\n            if(correct(str)==true )     a.add(str);\\n            \\n            return;\\n        }\\n\\n        //dont put a dot\\n        solve(a,s,index+1 , str+=s.charAt(index), nod,n);\\n\\n        //put the dot\\n        solve(a,s,index+1,str+=\\'.\\',nod+1,n);\\n        \\n        return;\\n    }\\n\\n    public boolean correct (String str)\\n    {\\n        \\n        if (str.length() == 0)                      return false;\\n        if(str.charAt(str.length() - 1) == \\'.\\' )    return false;\\n        \\n        String temp = \"\";\\n        int count = 0;\\n        for(int i = 0;i < str.length(); i++)\\n        {\\n           \\n            if(str.charAt(i) == \\'.\\' )\\n            {\\n                count++;\\n                if(temp.length()>3 || temp.length()==0)                     return false;\\n                if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n                if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n                temp=\"\";\\n            }\\n            else\\n            {\\n                temp+=str.charAt(i);\\n            }\\n            \\n        //last string will be left as in the string 125.34.54.789 temp will store 132 but as after 789 no \\'.\\' will be there so it wont check the conditions on \"789\"   \\n\\n        }\\n        if(temp.length()>3 || temp.length()==0)                     return false;\\n        if(temp.length()!=1 && temp.charAt(0)==\\'0\\')                 return false;\\n        if(Integer.valueOf(temp)<0 || Integer.valueOf(temp)>255)    return false;\\n        if(count!=3)                                                return false;\\n       \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082691,
                "title": "python-simple-backtracking",
                "content": "**Solution**:\\n    We can solve this problem with backtracking. At each iteration, we will pick the next term for a proposed ip address as long as the term is valid. We know that we have a valid ip if we used all digits and we picked 4 terms and thus, we can append the proposed ip into the result. Then, we backtrack.  \\n\\n**Complexity**:\\n    Time: O(3**n) \\n    Space: O(3\\\\**n)\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n\\n        # Find the number of digits\\n        n = len(s)\\n\\n        # If we have too little or too many digits to form a valid ip, end the search\\n        if not (4 <= n <= 12):\\n            return []\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Recursively forming valid ips\\n        def backtrack(i, ip):\\n\\n            # If we used all digits or we have 4 terms, we end the search\\n            if i == n or len(ip) == 4:\\n\\n                # If both conditions hold true, we have found a valid ip\\n                if i == n and len(ip) == 4:\\n                    res.append(\".\".join(ip))\\n\\n                return\\n\\n            # Else, we will pick the next term\\n            for j in range(i + 1, min(i + 4, n + 1)):\\n\\n                # If the next term is greater than 255, end the search\\n                if int(s[i:j]) > 255:\\n                    return\\n\\n                # Else, add the term into the ip\\n                ip.append(s[i:j])\\n\\n                # Go to the next term\\n                backtrack(j, ip)\\n\\n                # Once we return, pop the picked term from the ip\\n                ip.pop()\\n\\n                # If there is leading 0, we will end the search after picked the first possible term\\n                if s[i] == \"0\":\\n                    return\\n\\n        backtrack(0, [])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n\\n        # Find the number of digits\\n        n = len(s)\\n\\n        # If we have too little or too many digits to form a valid ip, end the search\\n        if not (4 <= n <= 12):\\n            return []\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Recursively forming valid ips\\n        def backtrack(i, ip):\\n\\n            # If we used all digits or we have 4 terms, we end the search\\n            if i == n or len(ip) == 4:\\n\\n                # If both conditions hold true, we have found a valid ip\\n                if i == n and len(ip) == 4:\\n                    res.append(\".\".join(ip))\\n\\n                return\\n\\n            # Else, we will pick the next term\\n            for j in range(i + 1, min(i + 4, n + 1)):\\n\\n                # If the next term is greater than 255, end the search\\n                if int(s[i:j]) > 255:\\n                    return\\n\\n                # Else, add the term into the ip\\n                ip.append(s[i:j])\\n\\n                # Go to the next term\\n                backtrack(j, ip)\\n\\n                # Once we return, pop the picked term from the ip\\n                ip.pop()\\n\\n                # If there is leading 0, we will end the search after picked the first possible term\\n                if s[i] == \"0\":\\n                    return\\n\\n        backtrack(0, [])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080249,
                "title": "recursion-optimal-w-explanation-c-nmcodex",
                "content": "Please upvote if you like it. Upvote costs nothing \\uD83D\\uDE0E\\n\\n> Many coders have been shared the best solutions. Hope this will also help you a lot.\\n# Intuition\\nDefinitely we need to check each and every possible string.\\n> String length is 20, then we should not worry about time limit. \\n> Even if length is greater, time will be still constant *(better explained in `Complexity Section`)*\\n\\nWe have three conditions:\\n```\\n1. Number of dots should be exactly 3.\\n2. When we take 2 or 3 letters make sure first letter shouldn\\'t be zero.\\n3. We can only take any number from 0-255.  \\n```\\n\\n# Approach\\n1. Take initial string `temp` as empty and  a variable for `dot` count.\\n2. Take all possibilities.\\n```\\nPossibility 1: Take 1 number.\\nPossibility 2: Take 2 number but also check that first letter shouldn\\'t be \\'0\\'.\\nPossibility 3: Take 3 number but also check that first letter shouldn\\'t be \\'0\\'and number shouldn\\'t exceed 255.\\n```\\n3. When complete string traversed and `dots are 3` then insert it in `unordered_set`.\\n> In code, insert element when dots are 4 because we delete last dot as well before inserting.\\n4. `If dots exceeds 4 return`.\\n5. Copy all elements from `set to vector` and then `return vector`\\n\\n# Complexity\\n- Time complexity:\\n> The IP address ranges from 0.0.0.0 to 255.255.255.255\\nSo, there can be maximum 2^32 address \\nTime complexity will be `constant` ---- **O(2^32)**  ----> **`O(1)`**.\\n- Space complexity:\\n> **`O(N) + Auxiliary space`**\\nUsing a unordered_set and recursion stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> set;\\n    void sol(int i, string s, string temp,int dot)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(dot==4)\\n            {\\n                temp.pop_back();\\n                set.insert(temp);\\n            }\\n            return;\\n        }\\n        if(dot>=4) return;\\n        sol(i+1,s,temp+s.substr(i,1)+\\'.\\',dot+1);\\n        if(s[i] != \\'0\\') sol(i+2,s,temp+s.substr(i,2)+\\'.\\',dot+1);\\n        if(s[i] !=\\'0\\' && stoi(s.substr(i,3))<=255)\\n            sol(i+3,s,temp+s.substr(i,3)+\\'.\\',dot+1);\\n\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        sol(0,s,\"\",0);\\n        vector<string> ans(set.begin(),set.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Recursion"
                ],
                "code": "```\\n1. Number of dots should be exactly 3.\\n2. When we take 2 or 3 letters make sure first letter shouldn\\'t be zero.\\n3. We can only take any number from 0-255.  \\n```\n```\\nPossibility 1: Take 1 number.\\nPossibility 2: Take 2 number but also check that first letter shouldn\\'t be \\'0\\'.\\nPossibility 3: Take 3 number but also check that first letter shouldn\\'t be \\'0\\'and number shouldn\\'t exceed 255.\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> set;\\n    void sol(int i, string s, string temp,int dot)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(dot==4)\\n            {\\n                temp.pop_back();\\n                set.insert(temp);\\n            }\\n            return;\\n        }\\n        if(dot>=4) return;\\n        sol(i+1,s,temp+s.substr(i,1)+\\'.\\',dot+1);\\n        if(s[i] != \\'0\\') sol(i+2,s,temp+s.substr(i,2)+\\'.\\',dot+1);\\n        if(s[i] !=\\'0\\' && stoi(s.substr(i,3))<=255)\\n            sol(i+3,s,temp+s.substr(i,3)+\\'.\\',dot+1);\\n\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        sol(0,s,\"\",0);\\n        vector<string> ans(set.begin(),set.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079985,
                "title": "java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    HashSet<String> set=new HashSet<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        ArrayList<String> arr=new ArrayList<>();\\n        dfs(0,s,arr);\\n        return new ArrayList<String>(set);\\n    }\\n    void dfs(int i,String s,ArrayList<String> arr)\\n    {\\n        if(arr.size()==4 && i==s.length())\\n        {\\n        set.add(String.join(\".\",arr));\\n        return;\\n        }\\n        for(int j=i+1;j<=Math.min(i+3,s.length());j++)\\n        {\\n            String str=s.substring(i,j);\\n            if(Integer.parseInt(str)<=255 && (str.equals(\"0\") || str.charAt(0)!=\\'0\\'))\\n            {\\n                arr.add(str);\\n                dfs(j,s,arr);\\n                arr.remove(arr.size()-1);\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<String> set=new HashSet<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        ArrayList<String> arr=new ArrayList<>();\\n        dfs(0,s,arr);\\n        return new ArrayList<String>(set);\\n    }\\n    void dfs(int i,String s,ArrayList<String> arr)\\n    {\\n        if(arr.size()==4 && i==s.length())\\n        {\\n        set.add(String.join(\".\",arr));\\n        return;\\n        }\\n        for(int j=i+1;j<=Math.min(i+3,s.length());j++)\\n        {\\n            String str=s.substring(i,j);\\n            if(Integer.parseInt(str)<=255 && (str.equals(\"0\") || str.charAt(0)!=\\'0\\'))\\n            {\\n                arr.add(str);\\n                dfs(j,s,arr);\\n                arr.remove(arr.size()-1);\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079544,
                "title": "python3-31-ms-faster-than-95-31-of-python3-clean-and-easy-to-understand",
                "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self,s,path,result):\\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        path = []\\n        result = []\\n        self.dfs(s, path, result)\\n        return result\\n    \\n    def dfs(self,s,path,result):\\n        if not s and len(path) == 4:\\n            s = \\'.\\'.join(path[::-1])\\n            result.append(s)\\n            return\\n        elif len(path) == 4: return \\n        else:\\n            for i in range(1, min(3, len(s))+1):\\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\\n                    if i > 1 and s[0]==\\'0\\': continue\\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\\n            return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3079244,
                "title": "c-backtracking-solution-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- base case if we place all dots then just check curr substr is valid or not, and push back to ans \\n- for every idx to n check if that curr substring (idx, i-idx+1) is valid or not .\\n    - if yes then push curr char and \\'.\\' and call furthur\\n    - backtrack also\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isSafe(string s){\\n    int n = s.size();\\n    if(n>=4||n<=0)return false;\\n    if(n>1&&s[0]==\\'0\\')return false;\\n    if(n&&stoi(s)>255)return false;\\n    return true;\\n}\\nvoid solve(string s,vector<string>& ans,string st,int idx,int dot){\\n    if(dot==3){\\n        if(isSafe(s.substr(idx))){\\n            ans.push_back(st+s.substr(idx));\\n        }\\n        return;\\n    }\\n    for(int i=idx;i<s.size();i++){\\n        if(isSafe(s.substr(idx,i-idx+1))){\\n            st.push_back(s[i]);\\n            st.push_back(\\'.\\');\\n            solve(s,ans,st,i+1,dot+1);\\n            st.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        string st = \"\";\\n        if(n<4)return ans;\\n        solve(s,ans,st,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isSafe(string s){\\n    int n = s.size();\\n    if(n>=4||n<=0)return false;\\n    if(n>1&&s[0]==\\'0\\')return false;\\n    if(n&&stoi(s)>255)return false;\\n    return true;\\n}\\nvoid solve(string s,vector<string>& ans,string st,int idx,int dot){\\n    if(dot==3){\\n        if(isSafe(s.substr(idx))){\\n            ans.push_back(st+s.substr(idx));\\n        }\\n        return;\\n    }\\n    for(int i=idx;i<s.size();i++){\\n        if(isSafe(s.substr(idx,i-idx+1))){\\n            st.push_back(s[i]);\\n            st.push_back(\\'.\\');\\n            solve(s,ans,st,i+1,dot+1);\\n            st.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        string st = \"\";\\n        if(n<4)return ans;\\n        solve(s,ans,st,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079131,
                "title": "95-javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/6vln3Liz3_g\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            res.push(temp.join(\\'.\\'))\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            if(arr.length < i) break;\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```\\nMap approach for avoiding duplicate\\n```\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n    let map ={}\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            let joined = temp.join(\\'.\\')\\n            if(map[joined] || temp[3] == \"\") return;\\n            map[joined] =1\\n            res.push(joined)\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            res.push(temp.join(\\'.\\'))\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            if(arr.length < i) break;\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```\n```\\nvar restoreIpAddresses = function(s) {\\n    if(s.length>12 || s.length <4) return []\\n\\n    let res = []\\n    let map ={}\\n    let iterate = (arr,temp) =>{\\n\\n        if(temp.length > 4) return;\\n\\n        if(arr.length ==0 && temp.length == 4){\\n            let joined = temp.join(\\'.\\')\\n            if(map[joined] || temp[3] == \"\") return;\\n            map[joined] =1\\n            res.push(joined)\\n            return;\\n        }\\n\\n        for(let i =1; i<4; i++){\\n            let value = arr.slice(0,i);\\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\\n            iterate(arr.slice(i),[...temp,value])\\n        }\\n    }\\n\\n    iterate(s,[])\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152282,
                "title": "java-solution-brute-force-o-1-time-well-explained",
                "content": "I totally agree that the problem description should be more clear. If you are confused by the problem, feel free to take a look of the post. I also attach the code below and the explanation to the time complexity. Hope it is helpful.\\n\\nHere are several rules of a valid IP address:\\n\\n  (1) **Three dots**. A Valid IP address contains **ONLY 3 dots**, i.e. \"192.168.0.1\".\\n  (2) **No zero leading** in each section, i.e. \"192.168.00.1\" or \"192.168.0.01\" These two IP address are both invalid.\\n  (3) The number in each section should be in the range **[0, 255]**. No greater than 255 && no smaller than 0.\\n  (4) A valid IP address should contains at least four digits, i.e. \"0.0.0.0\". It\\'s a valid IP address.\\n\\nBy my solution, we can achieve **O(1) time** and O(1) space. The reason we can achieve constant time complexity is because that there are only 256 possible numbers in a section (0 - 255). 256 is 2^8, and we have four sections in an IP address. Therefore, (2^8) * (2^8) * (2^8) * (2^8) = 2^32. Hence, we can achieve O(2^32) time complexity which is O(1) time.  \\n\\n\\n```\\nclass Solution \\n{\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        // O(1) time | O(1) space\\n        if(s == null) return new ArrayList<>();\\n        \\n        ArrayList<String> res = new ArrayList<>();\\n        int n = s.length();\\n        \\n        for(int i = 1; i < Math.min(n, 4); i++)\\n        {\\n            String[] currentIPAddressParts = new String[] {\"\", \"\", \"\", \"\"};\\n            currentIPAddressParts[0] = s.substring(0, i);\\n            \\n            if(!isValidPart(currentIPAddressParts[0]))\\n                continue;\\n            \\n            for(int j = i+1; j < i + Math.min(n-i, 4); j++)\\n            {\\n                currentIPAddressParts[1] = s.substring(i, j);\\n                \\n                if(!isValidPart(currentIPAddressParts[1]))\\n                    continue;\\n                \\n                for(int k = j+1; k < j + Math.min(n-j, 4); k++)\\n                {\\n                    currentIPAddressParts[2] = s.substring(j, k);\\n                    currentIPAddressParts[3] = s.substring(k);\\n                    \\n                    if(isValidPart(currentIPAddressParts[2]) && isValidPart(currentIPAddressParts[3]))\\n                        res.add(join(currentIPAddressParts));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isValidPart(String str)\\n    {\\n        int n = str.length();\\n        \\n        if(n > 3)   return false;\\n        \\n        return (str.charAt(0) != \\'0\\') ? (Integer.valueOf(str) <= 255) : (n == 1);\\n    }\\n    \\n    public String join(String[] strs)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            sb.append(strs[i]);\\n            \\n            if(i != strs.length-1)\\n                sb.append(\".\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<String> restoreIpAddresses(String s) \\n    {\\n        // O(1) time | O(1) space\\n        if(s == null) return new ArrayList<>();\\n        \\n        ArrayList<String> res = new ArrayList<>();\\n        int n = s.length();\\n        \\n        for(int i = 1; i < Math.min(n, 4); i++)\\n        {\\n            String[] currentIPAddressParts = new String[] {\"\", \"\", \"\", \"\"};\\n            currentIPAddressParts[0] = s.substring(0, i);\\n            \\n            if(!isValidPart(currentIPAddressParts[0]))\\n                continue;\\n            \\n            for(int j = i+1; j < i + Math.min(n-i, 4); j++)\\n            {\\n                currentIPAddressParts[1] = s.substring(i, j);\\n                \\n                if(!isValidPart(currentIPAddressParts[1]))\\n                    continue;\\n                \\n                for(int k = j+1; k < j + Math.min(n-j, 4); k++)\\n                {\\n                    currentIPAddressParts[2] = s.substring(j, k);\\n                    currentIPAddressParts[3] = s.substring(k);\\n                    \\n                    if(isValidPart(currentIPAddressParts[2]) && isValidPart(currentIPAddressParts[3]))\\n                        res.add(join(currentIPAddressParts));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isValidPart(String str)\\n    {\\n        int n = str.length();\\n        \\n        if(n > 3)   return false;\\n        \\n        return (str.charAt(0) != \\'0\\') ? (Integer.valueOf(str) <= 255) : (n == 1);\\n    }\\n    \\n    public String join(String[] strs)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            sb.append(strs[i]);\\n            \\n            if(i != strs.length-1)\\n                sb.append(\".\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420292,
                "title": "java-dfs-simple",
                "content": "```\\nclass Solution {\\n    \\n    List<String> res = new ArrayList<>(); \\n    \\n    public void helper(String s, int start, List<String> curr) { \\n        if(curr.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(curr.get(0) + \".\" +curr.get(1) + \".\" + curr.get(2) + \".\" + curr.get(3)); \\n            }\\n            return; \\n        } \\n        for(int i=start; i<s.length(); i++) {\\n            if(i != start && s.charAt(start) == \\'0\\') break; \\n            if(Integer.valueOf(s.substring(start,i+1)) > 255) break; \\n            curr.add(s.substring(start,i+1)); \\n            helper(s, i+1, curr);\\n            curr.remove(curr.size()-1); \\n        }        \\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> curr = new ArrayList<>(); \\n        StringBuilder sb = new StringBuilder(); \\n        helper(s, 0, curr); \\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<String> res = new ArrayList<>(); \\n    \\n    public void helper(String s, int start, List<String> curr) { \\n        if(curr.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(curr.get(0) + \".\" +curr.get(1) + \".\" + curr.get(2) + \".\" + curr.get(3)); \\n            }\\n            return; \\n        } \\n        for(int i=start; i<s.length(); i++) {\\n            if(i != start && s.charAt(start) == \\'0\\') break; \\n            if(Integer.valueOf(s.substring(start,i+1)) > 255) break; \\n            curr.add(s.substring(start,i+1)); \\n            helper(s, i+1, curr);\\n            curr.remove(curr.size()-1); \\n        }        \\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> curr = new ArrayList<>(); \\n        StringBuilder sb = new StringBuilder(); \\n        helper(s, 0, curr); \\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363591,
                "title": "java-backtracking-solution",
                "content": "```\\nprivate final static int MAX_VALUE = 255;\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if (s.length() == 0) {\\n            return res;\\n        }\\n        \\n        List<String> path = new ArrayList<>();\\n        int len = s.length();\\n        dfs(0, 4, len, s, path, res);\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(int start, int count, int len, String s, List<String> path, List<String> res) {\\n        \\n        int numOfDigitsLeft = len - start;\\n        \\n        if (3*count <  numOfDigitsLeft || numOfDigitsLeft < count) { \\n            return;\\n        }\\n        \\n        if (count == 0) {\\n            res.add(String.join(\".\", path));\\n            return;\\n        }\\n        \\n        for (int size = 1; size <= 3; size++) {\\n            if (start + size - 1 >= len ) {\\n                continue;\\n            }\\n            \\n            String num = s.substring(start, start + size);\\n            \\n            if (Integer.valueOf(num) <= MAX_VALUE\\n                && (num.length() == 1 || num.charAt(0) != \\'0\\')) {\\n                \\n                path.add(num);\\n                dfs(start + size, count - 1, len, s, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate final static int MAX_VALUE = 255;\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if (s.length() == 0) {\\n            return res;\\n        }\\n        \\n        List<String> path = new ArrayList<>();\\n        int len = s.length();\\n        dfs(0, 4, len, s, path, res);\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(int start, int count, int len, String s, List<String> path, List<String> res) {\\n        \\n        int numOfDigitsLeft = len - start;\\n        \\n        if (3*count <  numOfDigitsLeft || numOfDigitsLeft < count) { \\n            return;\\n        }\\n        \\n        if (count == 0) {\\n            res.add(String.join(\".\", path));\\n            return;\\n        }\\n        \\n        for (int size = 1; size <= 3; size++) {\\n            if (start + size - 1 >= len ) {\\n                continue;\\n            }\\n            \\n            String num = s.substring(start, start + size);\\n            \\n            if (Integer.valueOf(num) <= MAX_VALUE\\n                && (num.length() == 1 || num.charAt(0) != \\'0\\')) {\\n                \\n                path.add(num);\\n                dfs(start + size, count - 1, len, s, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319009,
                "title": "python-short-and-simple-backtracking-python-solution",
                "content": "I use \"level\" to refer to different portions of the IP address\\n```\\n#255.255.255.255\\n# ^  ^   ^   ^\\n#lv1 lv2 lv3 lv4\\n ```\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def backtrack(comb, s, level):\\n            if (level == 0) and (s == \"\"):\\n                res.append(comb[:-1])\\n            elif (level != 0):\\n                for i in range(1,min(3+1, len(s)+1)):\\n                    if (i > 1) and (s[0] == \\'0\\'): # cannot start with \\'0\\', i.e. \\'1.001.0.1\\'\\n                        continue\\n                    if ( 0<= int(s[0:i]) <=255 ) :\\n                        backtrack(comb+s[0:i]+\\'.\\', s[i:], level-1)\\n        \\n        backtrack(\"\", s, 4)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n#255.255.255.255\\n# ^  ^   ^   ^\\n#lv1 lv2 lv3 lv4\\n ```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        \\n        def backtrack(comb, s, level):\\n            if (level == 0) and (s == \"\"):\\n                res.append(comb[:-1])\\n            elif (level != 0):\\n                for i in range(1,min(3+1, len(s)+1)):\\n                    if (i > 1) and (s[0] == \\'0\\'): # cannot start with \\'0\\', i.e. \\'1.001.0.1\\'\\n                        continue\\n                    if ( 0<= int(s[0:i]) <=255 ) :\\n                        backtrack(comb+s[0:i]+\\'.\\', s[i:], level-1)\\n        \\n        backtrack(\"\", s, 4)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31087,
                "title": "short-easy-understand-4ms-backtracking-c-solution",
                "content": "    class Solution {\\n    private:\\n        void helper(string s,vector<string>& sol,vector<string>& res,int length){\\n            if(length==0 && sol.size() == 4){\\n                string tmp = \"\";\\n                tmp += (sol[0]+\".\");\\n                tmp += (sol[1]+\".\");\\n                tmp += (sol[2]+\".\");\\n                tmp += (sol[3]);\\n                res.push_back(tmp);\\n                return;\\n            }\\n            else if(sol.size()==4 && length!=0) return;\\n            else if(sol.size()!=4 && length==0) return;\\n            \\n            for(int i=1;i<=3 && i<=length;i++){\\n                string ts = s.substr(s.length()-length,i);\\n                int num = stoi(ts);\\n                if(num>=0 && num<=255 && (i==1 || ts[0]!='0')){\\n                    sol.push_back(ts);\\n                    helper(s,sol,res,length-i);\\n                    sol.pop_back();\\n                }\\n            }\\n        }\\n    public:\\n        vector<string> restoreIpAddresses(string s) {\\n            vector<string> res;\\n            vector<string> sol;\\n            helper(s,sol,res,s.length());\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    private:\\n        void helper(string s,vector<string>& sol,vector<string>& res,int length){\\n            if(length==0 && sol.size() == 4){\\n                string tmp = \"\";\\n                tmp += (sol[0]+\".\");\\n                tmp += (sol[1]+\".\");\\n                tmp += (sol[2]+\".\");\\n                tmp += (sol[3]);\\n                res.push_back(tmp);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31095,
                "title": "backtracking-solution-in-java-easy-to-understand",
                "content": "    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> result = new ArrayList<String>();\\n            if(s == null || s.length() == 0 || s.length() > 12){\\n                return result;\\n            }\\n            StringBuilder builder = new StringBuilder();\\n            helper(result, s, builder, 0, 0);\\n            return result;\\n        }\\n        \\n        private void helper(List<String> result, String s, StringBuilder builder, int start, int count){\\n            if(start == s.length() && count == 3){\\n                result.add(builder.toString());\\n                return;\\n            }\\n            for(int i = start + 1; i <= s.length(); i++){\\n                String tmp = s.substring(start, i);\\n                if(tmp.length() > 3 || tmp.length() > 1 && tmp.charAt(0) == '0' || Integer.parseInt(tmp) > 255){\\n                    return;\\n                }\\n                StringBuilder newBuilder = new StringBuilder(builder);\\n                if(newBuilder.length() != 0){\\n                    newBuilder.append(\".\");\\n                }\\n                newBuilder.append(tmp);\\n                helper(result, s, newBuilder, i, newBuilder.length() == tmp.length() ? count : count + 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n            List<String> result = new ArrayList<String>();\\n            if(s == null || s.length() == 0 || s.length() > 12){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3696351,
                "title": "superb-logic-with-backtracking-constraints-concept",
                "content": "# Awesome Logic with backtracking\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:# condition for valid IP address\\n                ans.append(temp[:-1])# to remove last dot\\n                return\\n            if k==4 or len(s)==0:# due to overflow IP address or not valid IP address\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s): # overflow condition or due to loop for 3 times irrespective of input size\\n                    break\\n                if int(s[:i+1])>255: # not valid Ip address condition\\n                    continue\\n                if i!=0 and s[0]==\"0\": to avoid \"0.011.34.012\" IP address\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  # main logic with restore ip address\\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:# condition for valid IP address\\n                ans.append(temp[:-1])# to remove last dot\\n                return\\n            if k==4 or len(s)==0:# due to overflow IP address or not valid IP address\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s): # overflow condition or due to loop for 3 times irrespective of input size\\n                    break\\n                if int(s[:i+1])>255: # not valid Ip address condition\\n                    continue\\n                if i!=0 and s[0]==\"0\": to avoid \"0.011.34.012\" IP address\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  # main logic with restore ip address\\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091216,
                "title": "c-string-partition-code-with-comments-simple-explanation",
                "content": "![93. Restore IP Addresses.png](https://assets.leetcode.com/users/images/f916078e-6ab9-48f4-bf63-a2f662defee9_1674494214.1065774.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string &s)\\n    {\\n        int n=s.size();\\n\\n        //base case\\n        if(n==1){\\n            return true;\\n        }\\n        //if length >3 or string starts with 0\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        // converting string to integer to check if it is less than equal to 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    // void solve(string &s, vector<string>&ans)\\n    // {\\n       \\n    // }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n\\n        // base case\\n        if(s.size()>12)\\n        return ans;\\n\\n        // divide string into 4 parts, each having length=3\\n        // iterate over each part & form corresponding substrings\\n\\n        for(int i=1;i<=3;i++) // 1st part\\n        {\\n            for(int j=1;j<=3;j++) // 2nd part\\n            {\\n                for(int k=1;k<=3;k++) // 3rd part\\n                {\\n                    if((i+j+k<s.size()) and (i+j+k+3>=s.size())) // check if last part is of length 3\\n                    {\\n                        string a=s.substr(0,i);\\n                        string b=s.substr((i+0),j);\\n                        string c=s.substr((j+i),k);\\n                        string d=s.substr(i+j+k);\\n\\n                        // if each substring is valid, then push into array\\n                        if(isValid(a) and isValid(b) and isValid(c) and isValid(d))\\n                        ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Pls upvote my solution, it helps me stay motivated to bring up more solutions like this :)**",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string &s)\\n    {\\n        int n=s.size();\\n\\n        //base case\\n        if(n==1){\\n            return true;\\n        }\\n        //if length >3 or string starts with 0\\n        if(n>3||s[0]==\\'0\\'){\\n            return false;\\n        }\\n        // converting string to integer to check if it is less than equal to 255\\n        int val=stoi(s);\\n        if(val>255){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    // void solve(string &s, vector<string>&ans)\\n    // {\\n       \\n    // }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n\\n        // base case\\n        if(s.size()>12)\\n        return ans;\\n\\n        // divide string into 4 parts, each having length=3\\n        // iterate over each part & form corresponding substrings\\n\\n        for(int i=1;i<=3;i++) // 1st part\\n        {\\n            for(int j=1;j<=3;j++) // 2nd part\\n            {\\n                for(int k=1;k<=3;k++) // 3rd part\\n                {\\n                    if((i+j+k<s.size()) and (i+j+k+3>=s.size())) // check if last part is of length 3\\n                    {\\n                        string a=s.substr(0,i);\\n                        string b=s.substr((i+0),j);\\n                        string c=s.substr((j+i),k);\\n                        string d=s.substr(i+j+k);\\n\\n                        // if each substring is valid, then push into array\\n                        if(isValid(a) and isValid(b) and isValid(c) and isValid(d))\\n                        ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085871,
                "title": "java-no-backtracking",
                "content": "# Please Upvote :D\\n---\\n![image.png](https://assets.leetcode.com/users/images/c68b647b-ba51-4581-9a86-8ca233011c3c_1674387621.138504.png)\\n\\n---\\n*We will be forming each part of the IP-address iteratively.*\\n``` java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s.length() > 12) {      // max length can be 3 x 4 = 12\\n            return ans;\\n        }\\n\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder(); // to store one address\\n        // length of each part can be min 1 and at max 3 \\n        // so we will one by one try with each length for first 3 parts\\n        for (int l1 = 1; l1 <= 3; l1++) {\\n            for (int l2 = 1; l2 <= 3; l2++) {\\n                for (int l3 = 1; l3 <= 3; l3++) {\\n                    // get the length for the 4th part\\n                    int l4 = len - l1 - l2 - l3;\\n                    // again, the 4th part should be of size 1-3\\n                    if (l4 > 0 && l4 <= 3) {    // if it is\\n                        // get the numbers from the partitioned strings\\n                        int p1 = getNum(s, 0, l1);\\n                        int p2 = getNum(s, l1, l1 + l2);\\n                        int p3 = getNum(s, l1 + l2, l1 + l2 + l3);\\n                        int p4 = getNum(s, l1 + l2 + l3, l1 + l2 + l3 + l4);\\n                        // if each of them is lesser than 255\\n                        // we can make it a candidate ip address\\n                        if (p1 <= 255 && p2 <= 255 && p3 <= 255 && p4 <= 255) {\\n                            sb.append(p1).append(\".\").append(p2).append(\".\")\\n                            .append(p3).append(\".\").append(p4);\\n                            \\n                            // IMPORTANT:\\n                            // We need to avoid leading zeros\\n                            // if in the string if we have \"025\", \\n                            // parseInt would convert it to 25\\n                            // so we will get a difference in the lengths\\n                            // otherwise length of our address should always be 3 + string\\'s length\\n                            // the +3 is because of the 3 \".\" (dots) that we have added\\n                            if (sb.length() == len + 3) {   // if that\\'s so\\n                                ans.add(sb.toString());     // add the IP to the ans list\\n                            }\\n                            // empty the stringbuilder coz we will create a new IP now\\n                            sb = new StringBuilder();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    // this method returns the numeric value of the part of the string\\n    // we chose to make the method separate to avoid typing the same long thing again and again\\n    private int getNum(String s, int i, int j) {\\n        return Integer.parseInt(s.substring(i, j));\\n    }\\n}\\n```\\n---\\n#### Time complexity: \\n- We are using `3` loops which would run `3 x 3 x 3` times.\\n- Inside that we are performing `substring()` operation `4` times on a string which can be at max `12` in length.\\n- So time complexity becomes $$O(3 * 3 * 3 * 4 * 12) => O(432)$$ in worst case which is constant in nature.\\n\\nSo we can say our time complexity is $$O(1)$$.\\n\\n---\\n#### Space complexity:\\nWe are using a stringbuilder who will store a string of size `12 + 3 = 15` at max which is again constant in nature.\\nSo we can say our space coplexity is $$O(1)$$.\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s.length() > 12) {      // max length can be 3 x 4 = 12\\n            return ans;\\n        }\\n\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder(); // to store one address\\n        // length of each part can be min 1 and at max 3 \\n        // so we will one by one try with each length for first 3 parts\\n        for (int l1 = 1; l1 <= 3; l1++) {\\n            for (int l2 = 1; l2 <= 3; l2++) {\\n                for (int l3 = 1; l3 <= 3; l3++) {\\n                    // get the length for the 4th part\\n                    int l4 = len - l1 - l2 - l3;\\n                    // again, the 4th part should be of size 1-3\\n                    if (l4 > 0 && l4 <= 3) {    // if it is\\n                        // get the numbers from the partitioned strings\\n                        int p1 = getNum(s, 0, l1);\\n                        int p2 = getNum(s, l1, l1 + l2);\\n                        int p3 = getNum(s, l1 + l2, l1 + l2 + l3);\\n                        int p4 = getNum(s, l1 + l2 + l3, l1 + l2 + l3 + l4);\\n                        // if each of them is lesser than 255\\n                        // we can make it a candidate ip address\\n                        if (p1 <= 255 && p2 <= 255 && p3 <= 255 && p4 <= 255) {\\n                            sb.append(p1).append(\".\").append(p2).append(\".\")\\n                            .append(p3).append(\".\").append(p4);\\n                            \\n                            // IMPORTANT:\\n                            // We need to avoid leading zeros\\n                            // if in the string if we have \"025\", \\n                            // parseInt would convert it to 25\\n                            // so we will get a difference in the lengths\\n                            // otherwise length of our address should always be 3 + string\\'s length\\n                            // the +3 is because of the 3 \".\" (dots) that we have added\\n                            if (sb.length() == len + 3) {   // if that\\'s so\\n                                ans.add(sb.toString());     // add the IP to the ans list\\n                            }\\n                            // empty the stringbuilder coz we will create a new IP now\\n                            sb = new StringBuilder();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    // this method returns the numeric value of the part of the string\\n    // we chose to make the method separate to avoid typing the same long thing again and again\\n    private int getNum(String s, int i, int j) {\\n        return Integer.parseInt(s.substring(i, j));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083045,
                "title": "c-solution-iterative-approach-simple-explanation",
                "content": "# Intuition \\nIterative Approach \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the length of the given string is greater than 12 that means there is no valid ip as maximum number is 255 and it has only 3 charater and we have to divide the string and insert dot 4 times.\\n2. Now divide the string into substrings and verify the condition on each substring\\n - length is less then or equal to 3 \\n - no leading zeros and\\n - it\\'s value in integer is less than or equal to 255\\n3. At the end insert the string into ans vector. \\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote if it helps you.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string str){\\n        if (str.size() == 1)\\n        return true;\\n        if (str.size() > 3|| str[0] == \\'0\\'|| stoi(str) > 255)\\n        return false;\\n        else\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        // check for length of the string as 255 has length 3 and only 4 such number are allowed\\n        if (s.size() > 12)\\n        return {};\\n        vector<string> v;\\n        for (int i = 1; i <= 3 ; i++)\\n        for (int j = 1 ; j <= 3 ; j++)\\n        for (int k = 1 ; k <= 3 ; k++)\\n        {\\n            if (i+j+k <s.size() && i+j+k+3 >= s.size()){\\n                string a =s.substr(0,i);\\n                string b =s.substr(i,j);\\n                string c =s.substr(i+j,k);\\n                string d =s.substr(i+j+k);\\n                if (check(a) && check(b) && check(c) && check(d))\\n                v.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string str){\\n        if (str.size() == 1)\\n        return true;\\n        if (str.size() > 3|| str[0] == \\'0\\'|| stoi(str) > 255)\\n        return false;\\n        else\\n        return true;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        // check for length of the string as 255 has length 3 and only 4 such number are allowed\\n        if (s.size() > 12)\\n        return {};\\n        vector<string> v;\\n        for (int i = 1; i <= 3 ; i++)\\n        for (int j = 1 ; j <= 3 ; j++)\\n        for (int k = 1 ; k <= 3 ; k++)\\n        {\\n            if (i+j+k <s.size() && i+j+k+3 >= s.size()){\\n                string a =s.substr(0,i);\\n                string b =s.substr(i,j);\\n                string c =s.substr(i+j,k);\\n                string d =s.substr(i+j+k);\\n                if (check(a) && check(b) && check(c) && check(d))\\n                v.push_back(a+\".\"+b+\".\"+c+\".\"+d);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082015,
                "title": "golang-simple-solution",
                "content": "# Intuition\\nDivide given string into valid 4 substring and check if each substring is valid\\n\\n# Approach\\n1. Divide given string into valid 4 substrings\\n2. Check value of each substring is valid (0-255)\\n3. Join substring and check if there was not leading zeros. After joining lengths should match\\n\\n# Complexity\\n- Time complexity:\\nWe run 3 for loops for 3 values (1,2,3)\\nO(3*3) -> O(1). We are not dependent on length of input string\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc restoreIpAddresses(s string) []string { \\n    res := []string{}\\n\\n    for a := 1; a <= 3; a++ {\\n        for b := 1; b <= 3; b++ {\\n            for c := 1; c <= 3; c++ {\\n\\n                d := len(s) - (a + b + c)\\n                if d > 0 && d <= 3 && a+b+c+d == len(s) {\\n                    A, _ := strconv.Atoi(s[:a])\\n                    B, _ := strconv.Atoi(s[a:a+b])\\n                    C, _ := strconv.Atoi(s[a+b:a+b+c])\\n                    D, _ := strconv.Atoi(s[a+b+c:])\\n\\n                    if A <= 255 && B <= 255 && C <= 255 && D <= 255 {\\n                        addr := fmt.Sprintf(\"%d.%d.%d.%d\", A, B, C, D)\\n                        \\n                        // To check if there was any leading zeros, \\n                        // If leading zeros was there, then len will be reduced\\n                        // +3, for 3 \\'.\\'\\n                        if len(addr) == len(s) + 3 {\\n                            res = append(res, addr)\\n                        }\\n                    } \\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc restoreIpAddresses(s string) []string { \\n    res := []string{}\\n\\n    for a := 1; a <= 3; a++ {\\n        for b := 1; b <= 3; b++ {\\n            for c := 1; c <= 3; c++ {\\n\\n                d := len(s) - (a + b + c)\\n                if d > 0 && d <= 3 && a+b+c+d == len(s) {\\n                    A, _ := strconv.Atoi(s[:a])\\n                    B, _ := strconv.Atoi(s[a:a+b])\\n                    C, _ := strconv.Atoi(s[a+b:a+b+c])\\n                    D, _ := strconv.Atoi(s[a+b+c:])\\n\\n                    if A <= 255 && B <= 255 && C <= 255 && D <= 255 {\\n                        addr := fmt.Sprintf(\"%d.%d.%d.%d\", A, B, C, D)\\n                        \\n                        // To check if there was any leading zeros, \\n                        // If leading zeros was there, then len will be reduced\\n                        // +3, for 3 \\'.\\'\\n                        if len(addr) == len(s) + 3 {\\n                            res = append(res, addr)\\n                        }\\n                    } \\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3081001,
                "title": "recursive-iterative-c",
                "content": "# Recursive\\n```\\nclass Solution {\\n    void dfs(int i, int cnt, string &s, string t, vector<string> & ans) {\\n        if(i == s.size() && cnt == 4) {\\n            t.pop_back();\\n            ans.push_back(t);\\n            return;\\n        }\\n        if(cnt > 4) return;\\n        for(int j=i; j<min(i + 3, (int)s.size()); j++) {\\n            if(stoi(s.substr(i, j - i + 1)) <= 255 && (i == j || s[i] != \\'0\\')) {\\n                dfs(j + 1, cnt + 1, s, t + s.substr(i, j - i + 1) + \".\", ans);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        if(s.size() > 12) return ans;\\n\\n        dfs(0, 0, s, \"\", ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Iterative\\n```\\nclass Solution {\\n    bool good(string s) {\\n        string str;\\n        for(char c : s) {\\n            if(c == \\'.\\') {\\n                if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n                str = \"\";\\n            }\\n            else str += c;\\n        }\\n        if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n        return true;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    string ip = s.substr(0, i + 1) + \".\" + s.substr(i + 1, j - i) + \".\" + \\n                                s.substr(j + 1, k - j) + \".\" + s.substr(k + 1);\\n                    if(good(ip)) ans.push_back(ip);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int cnt, string &s, string t, vector<string> & ans) {\\n        if(i == s.size() && cnt == 4) {\\n            t.pop_back();\\n            ans.push_back(t);\\n            return;\\n        }\\n        if(cnt > 4) return;\\n        for(int j=i; j<min(i + 3, (int)s.size()); j++) {\\n            if(stoi(s.substr(i, j - i + 1)) <= 255 && (i == j || s[i] != \\'0\\')) {\\n                dfs(j + 1, cnt + 1, s, t + s.substr(i, j - i + 1) + \".\", ans);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        if(s.size() > 12) return ans;\\n\\n        dfs(0, 0, s, \"\", ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool good(string s) {\\n        string str;\\n        for(char c : s) {\\n            if(c == \\'.\\') {\\n                if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n                str = \"\";\\n            }\\n            else str += c;\\n        }\\n        if(!str.size() || str.size() > 3 || stoi(str) > 255 || str[0] == \\'0\\' && str.size() > 1) return false;\\n        return true;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        int n = s.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    string ip = s.substr(0, i + 1) + \".\" + s.substr(i + 1, j - i) + \".\" + \\n                                s.substr(j + 1, k - j) + \".\" + s.substr(k + 1);\\n                    if(good(ip)) ans.push_back(ip);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080823,
                "title": "c-ez-recursive-solution-explained",
                "content": "**Time taken for execution : 4ms**\\nI am generating all the possible subsets by placing the 3 dots in every position of the given string and validating them before pushing them into the answer vector.\\nThe maximum valid IP address can be generated with a string of length 12 ***[ 255.255.255.255 ]*** .  So we can easily return an empty vector for strings of size > 12.\\nThe maximum possible set generated fore the string will be I guess some 1000, so generating all the set is feasible.\\n\\n**If someone can help me determine the time complexity of the following code it will be highly appreciated. Thank You.**\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string>ans;\\n    void calc(string &s,string w,int i,int dots,int prev){\\n        if(i==s.length()||dots==3){           \\n            ans.insert(w+s.substr(i));//If the number of dots is 3 and the rest of the string is not explored\\n            return;\\n        }\\n        for(int j=i;j<s.length();j++){            \\n            w+=s[j];           \\n            if(j-prev>=0&&j<s.length()-1){\\n                w+=\\'.\\';//Placing DOT\\n                calc(s,w,j+1,dots+1,j);                 \\n                w.pop_back();//Backtracking\\n            }\\n            else\\n                calc(s,w,j+1,dots,prev); \\n        }\\n    }\\nbool isValid(string s){\\n    int n=s.length();\\n    int i=0;\\n    int dots=0;\\n    while(i<n){\\n        if(s[i]==\\'.\\'){\\n            dots++;\\n            i++;\\n            continue;\\n        }\\n        string num=\"\";\\n        while(i<n&&s[i]!=\\'.\\'){\\n            num+=s[i];\\n            i++;\\n        }\\n        if((num[0]==\\'0\\'&&num.length()>1)||stoull(num)>255)//Avoid leading zeroes and if xcurrent number is greater than 255\\n            return false;\\n    }\\n    if(dots!=3)//Required number of dots not placed\\n        return false;\\n    return true;\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n        if(s.length()>12)//Max IP address possible is 255.255.255.255 ( Remove the dots so max length is 12)\\n            return {};\\n        calc(s,\"\",0,0,0);\\n        // for(auto i:ans)\\n        //     cout<<i<<\" \";\\n        vector<string>a;\\n        for(auto i:ans){\\n            if(isValid(i))\\n                a.push_back(i);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n    Keep count of the number of dots. Max dots should be 3    \\n    Put dot at position \\'i\\' [ 0 <= i < n-1 -> \\'n\\' is the length of the string]\\n    If dot is placed pop the last character of the string while backtracking.\\n    Generate all possible combination of IP addresses possible by placing the dots in various position\\n    Use a set for avoiding duplicates\\n    Validate each IP address according to the given conditions and push them into the answer vector.\\n    \\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>ans;\\n    void calc(string &s,string w,int i,int dots,int prev){\\n        if(i==s.length()||dots==3){           \\n            ans.insert(w+s.substr(i));//If the number of dots is 3 and the rest of the string is not explored\\n            return;\\n        }\\n        for(int j=i;j<s.length();j++){            \\n            w+=s[j];           \\n            if(j-prev>=0&&j<s.length()-1){\\n                w+=\\'.\\';//Placing DOT\\n                calc(s,w,j+1,dots+1,j);                 \\n                w.pop_back();//Backtracking\\n            }\\n            else\\n                calc(s,w,j+1,dots,prev); \\n        }\\n    }\\nbool isValid(string s){\\n    int n=s.length();\\n    int i=0;\\n    int dots=0;\\n    while(i<n){\\n        if(s[i]==\\'.\\'){\\n            dots++;\\n            i++;\\n            continue;\\n        }\\n        string num=\"\";\\n        while(i<n&&s[i]!=\\'.\\'){\\n            num+=s[i];\\n            i++;\\n        }\\n        if((num[0]==\\'0\\'&&num.length()>1)||stoull(num)>255)//Avoid leading zeroes and if xcurrent number is greater than 255\\n            return false;\\n    }\\n    if(dots!=3)//Required number of dots not placed\\n        return false;\\n    return true;\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n        if(s.length()>12)//Max IP address possible is 255.255.255.255 ( Remove the dots so max length is 12)\\n            return {};\\n        calc(s,\"\",0,0,0);\\n        // for(auto i:ans)\\n        //     cout<<i<<\" \";\\n        vector<string>a;\\n        for(auto i:ans){\\n            if(isValid(i))\\n                a.push_back(i);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n    Keep count of the number of dots. Max dots should be 3    \\n    Put dot at position \\'i\\' [ 0 <= i < n-1 -> \\'n\\' is the length of the string]\\n    If dot is placed pop the last character of the string while backtracking.\\n    Generate all possible combination of IP addresses possible by placing the dots in various position\\n    Use a set for avoiding duplicates\\n    Validate each IP address according to the given conditions and push them into the answer vector.\\n    \\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3080447,
                "title": "simple-recursion-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if(s.length()>12) return res;\\n        recursion(0,s,\"\",0);\\n        return res;\\n    }\\n    private void recursion(int idx, String str, String temp,int part){\\n        if(idx == str.length() || part == 4){\\n            if(idx == str.length() && part == 4) res.add(temp.substring(0, temp.length()-1));\\n            return;\\n        }\\n        recursion(idx+1,str,temp+str.charAt(idx)+\".\",part+1);\\n        if(idx+2<=str.length() && isValid(str.substring(idx, idx+2))) recursion(idx+2, str, temp+str.substring(idx, idx+2)+\".\", part+1);\\n        if(idx+3<=str.length() && isValid(str.substring(idx, idx+3))) recursion(idx+3, str, temp+str.substring(idx, idx+3)+\".\", part+1);\\n    }\\n    private boolean isValid(String str){\\n        if(str.charAt(0) == \\'0\\') return false;\\n        return Integer.parseInt(str)<=255;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if(s.length()>12) return res;\\n        recursion(0,s,\"\",0);\\n        return res;\\n    }\\n    private void recursion(int idx, String str, String temp,int part){\\n        if(idx == str.length() || part == 4){\\n            if(idx == str.length() && part == 4) res.add(temp.substring(0, temp.length()-1));\\n            return;\\n        }\\n        recursion(idx+1,str,temp+str.charAt(idx)+\".\",part+1);\\n        if(idx+2<=str.length() && isValid(str.substring(idx, idx+2))) recursion(idx+2, str, temp+str.substring(idx, idx+2)+\".\", part+1);\\n        if(idx+3<=str.length() && isValid(str.substring(idx, idx+3))) recursion(idx+3, str, temp+str.substring(idx, idx+3)+\".\", part+1);\\n    }\\n    private boolean isValid(String str){\\n        if(str.charAt(0) == \\'0\\') return false;\\n        return Integer.parseInt(str)<=255;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080432,
                "title": "python-backtracking",
                "content": "\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # isvalid function for checking ip number is valid or not\\n        def isvalid(str):\\n            if (str[0]==\"0\" and len(str)>1) or int(str)>255:\\n                return False\\n            return True\\n\\n        res=[]\\n        def back(i,ip,r):\\n            if i==len(s) and r==0:\\n                res.append(ip[:-1])\\n                return\\n            if i+1<=len(s) and isvalid(s[i:i+1]):\\n                back(i+1,ip+s[i:i+1]+\".\",r-1)\\n            if i+2<=len(s) and isvalid(s[i:i+2]):\\n                back(i+2,ip+s[i:i+2]+\".\",r-1)\\n            if i+3<=len(s) and isvalid(s[i:i+3]):\\n                back(i+3,ip+s[i:i+3]+\".\",r-1)\\n            return res\\n        return back(0,\"\",4)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # isvalid function for checking ip number is valid or not\\n        def isvalid(str):\\n            if (str[0]==\"0\" and len(str)>1) or int(str)>255:\\n                return False\\n            return True\\n\\n        res=[]\\n        def back(i,ip,r):\\n            if i==len(s) and r==0:\\n                res.append(ip[:-1])\\n                return\\n            if i+1<=len(s) and isvalid(s[i:i+1]):\\n                back(i+1,ip+s[i:i+1]+\".\",r-1)\\n            if i+2<=len(s) and isvalid(s[i:i+2]):\\n                back(i+2,ip+s[i:i+2]+\".\",r-1)\\n            if i+3<=len(s) and isvalid(s[i:i+3]):\\n                back(i+3,ip+s[i:i+3]+\".\",r-1)\\n            return res\\n        return back(0,\"\",4)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080261,
                "title": "easy-c-backtracking-approach-fast-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void helper(string s, int j, int count){\\n        //Hit the Bottom | Base Case\\n        if(count == 3)\\n        {\\n            if((s[0]!= \\'0\\' or 0==j) and j+1<=3 and stoi(s.substr(0, j+1))<=255)\\n                ans.push_back(s);\\n            return;\\n        }\\n        if(j==0)\\n            return;\\n\\n        for(int i=j; (i>0 and (i>= j-3)); i--){\\n            if((s[i]!= \\'0\\' or i==j) and stoi(s.substr(i, j-i+1))<=255){\\n                //Insert the \\'.\\' and call recursively\\n                s.insert(i, 1,\\'.\\');\\n                helper(s, i-1, count+1);\\n                //Backtrack\\n                s.erase(i, 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        helper(s, s.length()-1, 0);\\n        return ans;\\n    }\\n};\\n```\\n![fays.png](https://assets.leetcode.com/users/images/7890de43-b728-4040-b0ec-b8add9211e5c_1674286460.3253233.png)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void helper(string s, int j, int count){\\n        //Hit the Bottom | Base Case\\n        if(count == 3)\\n        {\\n            if((s[0]!= \\'0\\' or 0==j) and j+1<=3 and stoi(s.substr(0, j+1))<=255)\\n                ans.push_back(s);\\n            return;\\n        }\\n        if(j==0)\\n            return;\\n\\n        for(int i=j; (i>0 and (i>= j-3)); i--){\\n            if((s[i]!= \\'0\\' or i==j) and stoi(s.substr(i, j-i+1))<=255){\\n                //Insert the \\'.\\' and call recursively\\n                s.insert(i, 1,\\'.\\');\\n                helper(s, i-1, count+1);\\n                //Backtrack\\n                s.erase(i, 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        helper(s, s.length()-1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080237,
                "title": "easy-c-solution",
                "content": "Here is the simple c++ sol.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n        int n=s.size();\\n        string s1,s2,s3,s4,res;\\n        s1=s2=s3=s4=res=\"\";\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    s1=s.substr(0,i);\\n                    s2=s.substr(i,j-i);\\n                    s3=s.substr(j,k-j);\\n                    s4=s.substr(k);\\n                    if(s4.size()==0 || s3.size()==0 || s2.size()==0 || s1.size()==0) \\n                        continue;\\n                    \\n                    if(stoll(s1)>255 || (s1[0]==\\'0\\' && s1.size()>1)) continue;\\n                    if(stoll(s2)>255 || (s2[0]==\\'0\\' && s2.size()>1)) continue;                        \\n                    if(stoll(s3)>255 || (s3[0]==\\'0\\' && s3.size()>1)) continue;\\n                    if(stoll(s4)>255 || (s4[0]==\\'0\\' && s4.size()>1)) continue;\\n                    res=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                    ans.push_back(res);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>ans;\\n        int n=s.size();\\n        string s1,s2,s3,s4,res;\\n        s1=s2=s3=s4=res=\"\";\\n        for(int i=1;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    s1=s.substr(0,i);\\n                    s2=s.substr(i,j-i);\\n                    s3=s.substr(j,k-j);\\n                    s4=s.substr(k);\\n                    if(s4.size()==0 || s3.size()==0 || s2.size()==0 || s1.size()==0) \\n                        continue;\\n                    \\n                    if(stoll(s1)>255 || (s1[0]==\\'0\\' && s1.size()>1)) continue;\\n                    if(stoll(s2)>255 || (s2[0]==\\'0\\' && s2.size()>1)) continue;                        \\n                    if(stoll(s3)>255 || (s3[0]==\\'0\\' && s3.size()>1)) continue;\\n                    if(stoll(s4)>255 || (s4[0]==\\'0\\' && s4.size()>1)) continue;\\n                    res=s1+\".\"+s2+\".\"+s3+\".\"+s4;\\n                    ans.push_back(res);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080191,
                "title": "c-sweet-n-simple-backtracking-solution-with-valid-function",
                "content": "```\\n# Intuition\\n<!-- The problem describes takign an action that means choice and is obviously a backtracking problem.-->\\n\\n# Approach\\n<!-- We define a backtracking soltution with a for loop that traverse every possibility and backtracks it back to the start.\\nWe also have a valid function which checks following.\\n1) No. of digits=0 pr greater than 3\\n2) No. of digits if greater than 1 then 1st digit shouldnt be 0.\\n3) No no. should be greater than 255. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- T.c. ==> 3^4 ==>O(1) -->\\n\\n- Space complexity:\\n<!-- Space complexity = O(3*4) ==>O(1)-->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool valid(string temp)\\n    {\\n        if(temp.size()==0 || temp.size()>3 ||(temp.size()>1 && temp[0]==\\'0\\') || stoi(temp)>255)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    void Rec(int indx, string s, string temp, vector<string> &ans, int dots)\\n    {\\n        if(dots==0)\\n        {\\n            if(indx==s.size())\\n            {\\n                ans.push_back(temp.substr(0, temp.size()-1));\\n            }\\n            return;\\n        }\\n\\n        for(int i =indx;i<s.size();i++)\\n        {\\n            if(valid(s.substr(indx, i-indx+1)))\\n            {\\n                temp.push_back(s[i]);\\n                temp.push_back(\\'.\\');\\n                Rec(i+1, s, temp, ans, dots-1);\\n                temp.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        string temp;\\n        vector<string> ans;\\n        Rec(0, s, temp, ans, 4);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n# Intuition\\n<!-- The problem describes takign an action that means choice and is obviously a backtracking problem.-->\\n\\n# Approach\\n<!-- We define a backtracking soltution with a for loop that traverse every possibility and backtracks it back to the start.\\nWe also have a valid function which checks following.\\n1) No. of digits=0 pr greater than 3\\n2) No. of digits if greater than 1 then 1st digit shouldnt be 0.\\n3) No no. should be greater than 255. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- T.c. ==> 3^4 ==>O(1) -->\\n\\n- Space complexity:\\n<!-- Space complexity = O(3*4) ==>O(1)-->\\n\\n# Code\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079824,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isValid(string& s, int i, int j)\\n    {\\n        cout<<i<<\" \"<<j<<\" \";\\n        if(i<j && s[i]==\\'0\\')\\n        return false;\\n        string k;\\n        // for(int l=i;l<=j;l++)\\n        // k+=s[l];\\n        k=s.substr(i, j-i+1);\\n        if(stoi(k)<256)\\n        return true;\\n        return false;\\n    }\\n    void solve(string s, int ind, vector<string> v, int c)\\n    {\\n        int n = s.length();\\n        if (ind == n && c==4) {\\n            v.pop_back();\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(c>3)\\n        return;\\n        for (int i = ind; i < n && i<ind+3; i++)\\n        {\\n            if (isValid(s, ind, i))\\n            {\\n                \\n                v.push_back(s.substr(ind, i-ind+1));\\n                v.push_back(\".\");\\n                solve(s, i+1, v, c+1);\\n                v.pop_back();\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s, 0, v, 0);\\n        vector<string> ret;\\n        for(auto v:ans)\\n        {\\n            string k=\"\";\\n            for(string a:v)\\n            k+=a;\\n            ret.push_back(k);\\n        }\\n        return ret;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isValid(string& s, int i, int j)\\n    {\\n        cout<<i<<\" \"<<j<<\" \";\\n        if(i<j && s[i]==\\'0\\')\\n        return false;\\n        string k;\\n        // for(int l=i;l<=j;l++)\\n        // k+=s[l];\\n        k=s.substr(i, j-i+1);\\n        if(stoi(k)<256)\\n        return true;\\n        return false;\\n    }\\n    void solve(string s, int ind, vector<string> v, int c)\\n    {\\n        int n = s.length();\\n        if (ind == n && c==4) {\\n            v.pop_back();\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(c>3)\\n        return;\\n        for (int i = ind; i < n && i<ind+3; i++)\\n        {\\n            if (isValid(s, ind, i))\\n            {\\n                \\n                v.push_back(s.substr(ind, i-ind+1));\\n                v.push_back(\".\");\\n                solve(s, i+1, v, c+1);\\n                v.pop_back();\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s, 0, v, 0);\\n        vector<string> ret;\\n        for(auto v:ans)\\n        {\\n            string k=\"\";\\n            for(string a:v)\\n            k+=a;\\n            ret.push_back(k);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3079820,
                "title": "sundar-susheel-ubla-hua-ekdum-simple-sada-garam-garam-code",
                "content": "# Intuition\\nWe will consider every 1 ,2 and 3 size substrings and try to partition the string into 4 parts and see if they match our condition. We will make use of recursion(backtracking) in it.\\n\\n# Approach\\nWe will consider every 1,2 and 3 size substrings with conditions-\\n- The total partitions should be 4\\n- We should not have any preceding 0.\\n- If we reach the end we will add the string to our ans\\n\\nSo at every ind, we have 3 cases. \\n- We will add the single char to our ans string and add \".\" at end\\n- We will add the next 2 characters and add \".\" at end. Here we have to check whether it is valid or not(first char should not be 0).\\n- We will add the next 3 characters and add \".\" at end. Here we have to check whether it is valid or not(first char should not be 0) along with that it should not be greater that 255.\\n\\n# Complexity\\n- Time complexity:\\nWe are making 3 recursion calls at every index. SO TC (3^n).\\n\\n- Space complexity:\\nSC O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'0\\')\\n            return false;\\n        int n=stoi(s);\\n        if(n<=255)return true;\\n        return false;\\n    }\\n\\n    void helper(int ind,int part,int n,string &s,string ans,vector<string>&res)\\n    {\\n        if(ind==n and part==4)\\n        {\\n            ans.pop_back(); //To remove that last dot \".\"\\n            res.push_back(ans);\\n        }\\n        if(ind==n || part==4)return;\\n        \\n        helper(ind+1,part+1,n,s,ans+s[ind]+\".\",res);\\n        if(ind+2<=n and isValid(s.substr(ind,2)))\\n            helper(ind+2,part+1,n,s,ans+s.substr(ind,2)+\".\",res);\\n        if(ind+3<=n and isValid(s.substr(ind,3)))\\n            helper(ind+3,part+1,n,s,ans+s.substr(ind,3)+\".\",res);\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n=s.size();\\n        helper(0,0,n,s,\"\",res); \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'0\\')\\n            return false;\\n        int n=stoi(s);\\n        if(n<=255)return true;\\n        return false;\\n    }\\n\\n    void helper(int ind,int part,int n,string &s,string ans,vector<string>&res)\\n    {\\n        if(ind==n and part==4)\\n        {\\n            ans.pop_back(); //To remove that last dot \".\"\\n            res.push_back(ans);\\n        }\\n        if(ind==n || part==4)return;\\n        \\n        helper(ind+1,part+1,n,s,ans+s[ind]+\".\",res);\\n        if(ind+2<=n and isValid(s.substr(ind,2)))\\n            helper(ind+2,part+1,n,s,ans+s.substr(ind,2)+\".\",res);\\n        if(ind+3<=n and isValid(s.substr(ind,3)))\\n            helper(ind+3,part+1,n,s,ans+s.substr(ind,3)+\".\",res);\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n=s.size();\\n        helper(0,0,n,s,\"\",res); \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079724,
                "title": "backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand",
                "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n1. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\n2. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n4.  (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\nRequest \\uD83D\\uDE0A :\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/684aadb8-5eea-47f4-aef2-31007841e162_1674279208.2528946.png)\\n\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        string ip;\\n        dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n        return result;\\n    }\\n    void dfs(string s,int start,int step,string ip,vector<string>& result){\\n        if(start==s.size()&&step==4){\\n            ip.erase(ip.end()-1); //remove the last \\'.\\' from the last decimal number\\n            result.push_back(ip);\\n            return;\\n        }\\n        if(s.size()-start>(4-step)*3) return;\\n        if(s.size()-start<(4-step)) return;\\n        int num=0;\\n        for(int i=start;i<start+3;i++){\\n            num=num*10+(s[i]-\\'0\\');\\n            if(num<=255){\\n                ip+=s[i];\\n                dfs(s,i+1,step+1,ip+\\'.\\',result);\\n            }\\n            if(num==0) break;\\n        }\\n    }\\n};\\n\\n```\\n\\n```c++_Comments_explanation []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        for(int i=ind;i<s.size();i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n   public List<String> restoreIpAddresses(String s) {\\n    List<String> ret = new LinkedList<>();\\n    int[] path = new int[4];\\n    helper(ret, s, 0,  path, 0);\\n    return ret;\\n}\\n\\nvoid helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n    if(segment == 4 && idx == s.length() ){\\n        acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n        return ;\\n    }else if(segment == 4 || idx == s.length() ){\\n        return ;\\n    }\\n    \\n    for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n        int val = Integer.parseInt(s.substring(idx, idx + len));\\n        // range check, no leading 0.\\n        if(val > 255 || len >= 2  && s.charAt(idx) == \\'0\\') \\n            break; \\n            \\n        path[segment] = val;\\n        helper(acc, s, idx + len, path, segment + 1);\\n        path[segment] = -1; // for debug. \\n    }\\n}\\n}\\n```\\n```javascript []\\nvar restoreIpAddresses = function(s) {\\n\\tconst result=[]\\n\\tif(s.length > 12) return result\\n\\n\\tfunction dfs(start, dots, curIp){\\n\\t\\tif(dots === 4 && start === s.length) return result.push(curIp.slice(0,-1))\\n\\n\\t\\tif(dots > 4) return\\n\\n\\t\\tconst len = Math.min(s.length, start+3)\\n\\t\\tfor(let j=start; j<len; j++){\\n\\t\\t\\tif(parseInt(s.slice(start,j+1)) < 256 && (start===j || s[start] !==\\'0\\')){\\n\\t\\t\\t\\tdfs(j+1, dots+1, curIp + s.slice(start, j+1) +\\'.\\')\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0,0,\\'\\')\\n\\treturn result\\n};\\n```\\n```python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if int(s) not in range(255255255256):\\n            return []\\n        \\n        def valid(seg):\\n            if not (1 <= len(seg) <= 3):\\n                return False\\n            num = int(seg)\\n            return num in range(256) and str(num) == seg\\n        \\n        ans = []\\n        for dot1 in range(1, 4):\\n            o1 = s[0:dot1]\\n            if valid(o1):\\n                for dot2 in range(dot1+1, dot1+4):\\n                    o2 = s[dot1:dot2]\\n                    if valid(o2):\\n                        for dot3 in range(dot2+1, dot2+4):\\n                            o3 = s[dot2:dot3]\\n                            o4 = s[dot3:]\\n                            if valid(o3) and valid(o4):\\n                                ans.append(\".\".join((o1,o2,o3,o4)))\\n        return ans\\n```\\n\\n\\n\\n\\n\\n\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```C++ []\\n\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        string ip;\\n        dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result\\n        return result;\\n    }\\n    void dfs(string s,int start,int step,string ip,vector<string>& result){\\n        if(start==s.size()&&step==4){\\n            ip.erase(ip.end()-1); //remove the last \\'.\\' from the last decimal number\\n            result.push_back(ip);\\n            return;\\n        }\\n        if(s.size()-start>(4-step)*3) return;\\n        if(s.size()-start<(4-step)) return;\\n        int num=0;\\n        for(int i=start;i<start+3;i++){\\n            num=num*10+(s[i]-\\'0\\');\\n            if(num<=255){\\n                ip+=s[i];\\n                dfs(s,i+1,step+1,ip+\\'.\\',result);\\n            }\\n            if(num==0) break;\\n        }\\n    }\\n};\\n\\n```\n```c++_Comments_explanation []\\nclass Solution {\\npublic:\\n    // Helper function to check if a given string is a valid IP address segment\\n    bool valid(string temp){\\n        if(temp.size()>3 || temp.size()==0) return false; // segment length should be between 1 and 3\\n        if(temp.size()>1 && temp[0]==\\'0\\')   return false; // segment should not start with 0, unless it is a single digit\\n        if(temp.size() && stoi(temp)>255) return false; // segment should not be greater than 255\\n        return true;\\n    }\\n\\n    // Backtracking function to generate all possible IP addresses\\n    void solve(vector<string>& ans, string output, int ind, string s, int dots){\\n        if(dots == 3){ // if we have already added 3 dots, check if the remaining segment is valid\\n            if(valid(s.substr(ind)))\\n                ans.push_back(output+s.substr(ind));\\n            return;\\n        }\\n        for(int i=ind;i<s.size();i++){\\n            if(valid(s.substr(ind, i-ind+1))){\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, i+1, s, dots+1);\\n                output.pop_back(); //backtrack\\n            }\\n        }\\n\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string res;\\n        solve(ans, res, 0, s, 0);\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n   public List<String> restoreIpAddresses(String s) {\\n    List<String> ret = new LinkedList<>();\\n    int[] path = new int[4];\\n    helper(ret, s, 0,  path, 0);\\n    return ret;\\n}\\n\\nvoid helper(List<String> acc, String s, int idx, int[] path,  int segment){\\n    if(segment == 4 && idx == s.length() ){\\n        acc.add(path[0] + \".\" + path[1] + \".\"+ path[2] + \".\" + path[3]);\\n        return ;\\n    }else if(segment == 4 || idx == s.length() ){\\n        return ;\\n    }\\n    \\n    for(int len = 1; len <= 3 && idx + len <= s.length() ; len ++){\\n        int val = Integer.parseInt(s.substring(idx, idx + len));\\n        // range check, no leading 0.\\n        if(val > 255 || len >= 2  && s.charAt(idx) == \\'0\\') \\n            break; \\n            \\n        path[segment] = val;\\n        helper(acc, s, idx + len, path, segment + 1);\\n        path[segment] = -1; // for debug. \\n    }\\n}\\n}\\n```\n```javascript []\\nvar restoreIpAddresses = function(s) {\\n\\tconst result=[]\\n\\tif(s.length > 12) return result\\n\\n\\tfunction dfs(start, dots, curIp){\\n\\t\\tif(dots === 4 && start === s.length) return result.push(curIp.slice(0,-1))\\n\\n\\t\\tif(dots > 4) return\\n\\n\\t\\tconst len = Math.min(s.length, start+3)\\n\\t\\tfor(let j=start; j<len; j++){\\n\\t\\t\\tif(parseInt(s.slice(start,j+1)) < 256 && (start===j || s[start] !==\\'0\\')){\\n\\t\\t\\t\\tdfs(j+1, dots+1, curIp + s.slice(start, j+1) +\\'.\\')\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(0,0,\\'\\')\\n\\treturn result\\n};\\n```\n```python []\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if int(s) not in range(255255255256):\\n            return []\\n        \\n        def valid(seg):\\n            if not (1 <= len(seg) <= 3):\\n                return False\\n            num = int(seg)\\n            return num in range(256) and str(num) == seg\\n        \\n        ans = []\\n        for dot1 in range(1, 4):\\n            o1 = s[0:dot1]\\n            if valid(o1):\\n                for dot2 in range(dot1+1, dot1+4):\\n                    o2 = s[dot1:dot2]\\n                    if valid(o2):\\n                        for dot3 in range(dot2+1, dot2+4):\\n                            o3 = s[dot2:dot3]\\n                            o4 = s[dot3:]\\n                            if valid(o3) and valid(o4):\\n                                ans.append(\".\".join((o1,o2,o3,o4)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079606,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\n1. Generate all possible index `points` to divide given `s` into `4` parts such that `1 <= len(part) <= 3` for each `part`.\\n\\n2. Define `is_valid_ip` which takes `parts` and returns `true` if all `part` has `0 <= int(part) <= 255` and has no leading zeroes.\\n\\n3. Calculate `candidate_ips` by splitting `s` at `points`.\\n\\n4. Filter only the `valid_ips` from `candidate_ips`.\\n\\n5. Join each into a `string` and return.\\n\\n# Complexity\\n- Time complexity: $$O(m^n * n)$$\\n\\n- Space complexity: $$O(m * n)$$\\n\\nwhere,\\n`n is number of parts in ip, i.e 4`, and \\n`m is max length of each part, i.e 3`\\n\\n# Code\\n```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n        n = len(s)\\n        points = (\\n            (i, j, k)\\n            for i in range(0 + 1, min(0 + 4, n))\\n            for j in range(i + 1, min(i + 4, n))\\n            for k in range(j + 1, min(j + 4, n))\\n        )\\n\\n        is_valid_ip = lambda ip: all(map(lambda x: int(x) <= 255 and (len(x) == 1 or x[0] != \\'0\\'), ip))\\n        \\n        candidate_ips = ((s[:i], s[i:j], s[j:k], s[k:]) for i, j, k in points)\\n        valid_ips = filter(is_valid_ip, candidate_ips)\\n        return [\\'.\\'.join(ip) for ip in valid_ips]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> list[str]:\\n        n = len(s)\\n        points = (\\n            (i, j, k)\\n            for i in range(0 + 1, min(0 + 4, n))\\n            for j in range(i + 1, min(i + 4, n))\\n            for k in range(j + 1, min(j + 4, n))\\n        )\\n\\n        is_valid_ip = lambda ip: all(map(lambda x: int(x) <= 255 and (len(x) == 1 or x[0] != \\'0\\'), ip))\\n        \\n        candidate_ips = ((s[:i], s[i:j], s[j:k], s[k:]) for i, j, k in points)\\n        valid_ips = filter(is_valid_ip, candidate_ips)\\n        return [\\'.\\'.join(ip) for ip in valid_ips]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060566,
                "title": "c-java-100-solution-using-backtracking-restore-ip-addresses",
                "content": "# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795387,
                "title": "python-solution-backtrack-recursive-easy-comments",
                "content": "### Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Backtrack (Recursive) approach***\\n\\n### Complexity\\n- Time complexity: O(3^5)    \\n   ( As there are max 4 integers (chunk) in all )\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        size = len(s)\\n        # Check Edge Condition\\n        if size > 12: return []\\n\\n        res = []\\n\\n        def backtrack(i, dots, curIp):\\n            if i == size and dots == 4:\\n                res.append(curIp[:-1])  # discarding the last 4th dot\\n                return \\n            if dots > 4:  # Cannot cover entore number into IP address\\n                return \\n            \\n            end_offset = min(i+3, size)  # end place where we can put the next dot\\n\\n            for j in range(i, end_offset):  # j is the offset to place from {i}\\n                # place dot\\n                part = s[i:j+1]\\n                # 1. number must be lte. 255\\n                # 2. number must not start with 0\\n                if int(part) <= 255 and (i == j or s[i] != \\'0\\'):\\n                    backtrack(j+1, dots+1, curIp + part + \\'.\\')\\n            \\n        backtrack(0, 0, \\'\\')\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        size = len(s)\\n        # Check Edge Condition\\n        if size > 12: return []\\n\\n        res = []\\n\\n        def backtrack(i, dots, curIp):\\n            if i == size and dots == 4:\\n                res.append(curIp[:-1])  # discarding the last 4th dot\\n                return \\n            if dots > 4:  # Cannot cover entore number into IP address\\n                return \\n            \\n            end_offset = min(i+3, size)  # end place where we can put the next dot\\n\\n            for j in range(i, end_offset):  # j is the offset to place from {i}\\n                # place dot\\n                part = s[i:j+1]\\n                # 1. number must be lte. 255\\n                # 2. number must not start with 0\\n                if int(part) <= 255 and (i == j or s[i] != \\'0\\'):\\n                    backtrack(j+1, dots+1, curIp + part + \\'.\\')\\n            \\n        backtrack(0, 0, \\'\\')\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718493,
                "title": "very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string> restoreIpAddresses(string s) \\n    {  \\n         int idx=0;\\n         string str=\"\";\\n         int count=0;\\n         fun(s,idx,str,count);\\n         return ans;\\n    }\\n    void fun(string &s , int idx ,string str,int count)\\n    {\\n         if(count>4)\\n         return;\\n\\n         if(idx >= s.length() and count==4)\\n         {\\n              str.pop_back();\\n              ans.push_back(str);\\n              return;\\n         }\\n\\n         int num=0;\\n         string temp=\"\";\\n\\n         for(int i=idx;i<s.length();i++)\\n         {\\n             char ch = s[i];\\n             int digit = ch - \\'0\\';\\n\\n             num = (num*10) + digit;\\n             temp.push_back(ch);\\n\\n             //we need to check for the leading zeor\\'s\\n              if(temp.length()>1 and temp[0]==\\'0\\' and (num>0 or num==0)) \\n              {\\n                 return;\\t\\n              }\\n\\n             //now if eveything is ok then call for next segment\\n             if((num>=0 and num<=255))\\n             {\\n               fun(s,i+1,str+temp+\\'.\\',count+1);\\t\\n             }\\n             else\\n             {\\n               return;\\t\\n             }\\n\\n         }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string> restoreIpAddresses(string s) \\n    {  \\n         int idx=0;\\n         string str=\"\";\\n         int count=0;\\n         fun(s,idx,str,count);\\n         return ans;\\n    }\\n    void fun(string &s , int idx ,string str,int count)\\n    {\\n         if(count>4)\\n         return;\\n\\n         if(idx >= s.length() and count==4)\\n         {\\n              str.pop_back();\\n              ans.push_back(str);\\n              return;\\n         }\\n\\n         int num=0;\\n         string temp=\"\";\\n\\n         for(int i=idx;i<s.length();i++)\\n         {\\n             char ch = s[i];\\n             int digit = ch - \\'0\\';\\n\\n             num = (num*10) + digit;\\n             temp.push_back(ch);\\n\\n             //we need to check for the leading zeor\\'s\\n              if(temp.length()>1 and temp[0]==\\'0\\' and (num>0 or num==0)) \\n              {\\n                 return;\\t\\n              }\\n\\n             //now if eveything is ok then call for next segment\\n             if((num>=0 and num<=255))\\n             {\\n               fun(s,i+1,str+temp+\\'.\\',count+1);\\t\\n             }\\n             else\\n             {\\n               return;\\t\\n             }\\n\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906017,
                "title": "backtracking-c-commented",
                "content": "-> We simply have to divide the given string into 4 parts where integer value of each part should be between 0 to 255 .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> local ;\\n    int n ;\\n\\t\\n\\t// function to calculate the integer value of a string\\n    int stoint(string s){\\n        int num = 0 ;\\n        for(auto c : s){\\n            num = num*10 + (c-\\'0\\');\\n        }\\n        return num ;\\n    }\\n\\t\\n    void helper(string s , int idx , vector<string>& path , int part){\\n\\t\\tif(idx==n && part==0){         // we have reached the end of the string and also divided it in 4 parts\\n            local.push_back(path) ;     // so we can include this path in our answer.\\n            return ; \\n        }\\n    \\n        for(int i=idx ;  i<n ; i++){\\n            if(i-idx+1 > 3)             // each part can\\'t be greater than 255 so not more than 3 digits\\n                return ;\\n            string temp = s.substr(idx , i-idx+1) ;\\n            if(stoint(temp)>=0 && stoint(temp)<=255){\\n                if(temp[0]==\\'0\\' && temp.length()>1) return ;   // As we can\\'t have strings with leading zeroes\\n                path.push_back(temp) ;\\n                helper(s , i+1 , path , part-1) ;    \\n                path.pop_back() ;      // simple backtracking \\n            }\\n        } \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        n =  s.length() ;\\n        vector<string> path ;\\n       if(n<4 || n>12)   return {} ;\\n        \\n        helper(s , 0 , path , 4) ;\\n        vector<string> ans  ; \\n        for(auto arr : local){   // creating our final ans array\\n            string temp  = \"\";\\n            for(auto t : arr ){\\n                temp += t ;\\n                temp += \\'.\\' ;\\n            }\\n            temp.pop_back() ;   //as last element of string will be \\'.\\' \\n            ans.push_back(temp) ;\\n        }\\n        return ans  ;\\n    }\\n};\\n// Plz upvote if it helped.\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> local ;\\n    int n ;\\n\\t\\n\\t// function to calculate the integer value of a string\\n    int stoint(string s){\\n        int num = 0 ;\\n        for(auto c : s){\\n            num = num*10 + (c-\\'0\\');\\n        }\\n        return num ;\\n    }\\n\\t\\n    void helper(string s , int idx , vector<string>& path , int part){\\n\\t\\tif(idx==n && part==0){         // we have reached the end of the string and also divided it in 4 parts\\n            local.push_back(path) ;     // so we can include this path in our answer.\\n            return ; \\n        }\\n    \\n        for(int i=idx ;  i<n ; i++){\\n            if(i-idx+1 > 3)             // each part can\\'t be greater than 255 so not more than 3 digits\\n                return ;\\n            string temp = s.substr(idx , i-idx+1) ;\\n            if(stoint(temp)>=0 && stoint(temp)<=255){\\n                if(temp[0]==\\'0\\' && temp.length()>1) return ;   // As we can\\'t have strings with leading zeroes\\n                path.push_back(temp) ;\\n                helper(s , i+1 , path , part-1) ;    \\n                path.pop_back() ;      // simple backtracking \\n            }\\n        } \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        n =  s.length() ;\\n        vector<string> path ;\\n       if(n<4 || n>12)   return {} ;\\n        \\n        helper(s , 0 , path , 4) ;\\n        vector<string> ans  ; \\n        for(auto arr : local){   // creating our final ans array\\n            string temp  = \"\";\\n            for(auto t : arr ){\\n                temp += t ;\\n                temp += \\'.\\' ;\\n            }\\n            temp.pop_back() ;   //as last element of string will be \\'.\\' \\n            ans.push_back(temp) ;\\n        }\\n        return ans  ;\\n    }\\n};\\n// Plz upvote if it helped.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905399,
                "title": "intuitive-python-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans=[]\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.recurse(s,3,0)\\n        return self.ans\\n    \\n    def recurse(self,s:str,dots:int,idx:int)->None:\\n        if dots==0:\\n            if self.isValid(s[idx:]): \\n                self.ans.append(s)\\n            return \\n        dots-=1\\n        self.recurse(s[:idx+1]+\".\"+s[idx+1:],dots,idx+2)\\n        if self.isValid(s[idx:idx+2]):\\n            self.recurse(s[:idx+2]+\".\"+s[idx+2:],dots,idx+3)\\n        if self.isValid(s[idx:idx+3]):\\n            self.recurse(s[:idx+3]+\".\"+s[idx+3:],dots,idx+4)\\n        \\n    def isValid(self,s:str)->bool:\\n        if len(s)==0:\\n            return False\\n        if len(s)==1: \\n            return True\\n        if len(s)==2: \\n            return (s[0]!=\"0\")\\n        return (s[0]!=\"0\") and int(s)<=255",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans=[]\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        self.recurse(s,3,0)\\n        return self.ans\\n    \\n    def recurse(self,s:str,dots:int,idx:int)->None:\\n        if dots==0:\\n            if self.isValid(s[idx:]): \\n                self.ans.append(s)\\n            return \\n        dots-=1\\n        self.recurse(s[:idx+1]+\".\"+s[idx+1:],dots,idx+2)\\n        if self.isValid(s[idx:idx+2]):\\n            self.recurse(s[:idx+2]+\".\"+s[idx+2:],dots,idx+3)\\n        if self.isValid(s[idx:idx+3]):\\n            self.recurse(s[:idx+3]+\".\"+s[idx+3:],dots,idx+4)\\n        \\n    def isValid(self,s:str)->bool:\\n        if len(s)==0:\\n            return False\\n        if len(s)==1: \\n            return True\\n        if len(s)==2: \\n            return (s[0]!=\"0\")\\n        return (s[0]!=\"0\") and int(s)<=255",
                "codeTag": "Java"
            },
            {
                "id": 1498413,
                "title": "python-iterative-solution-not-optimal-solution-but-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def valid(s):\\n            if len(s)<1 or len(s)>3:\\n                return False\\n            if int(s)>255:\\n                return False\\n            if int(s)!=0 and s[0]==\\'0\\':\\n                return False\\n            if int(s)==0 and len(s)>1:\\n                return False\\n            return True\\n       \\n        ans = []\\n        for i in range(4):\\n            \\n            if not valid(s[:i]):\\n                continue\\n            \\n            for j in range(i,i+4):\\n                \\n                if not valid(s[i:j]):\\n                    continue\\n                \\n                for k in range(j,j+4):\\n                    \\n                    if not valid(s[j:k]):\\n                        continue\\n                    \\n                    if not valid(s[k:]):\\n                        continue\\n    \\n                    ans.append(s[:i]+\".\"+s[i:j]+\".\"+s[j:k]+\".\"+s[k:])\\n                   \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def valid(s):\\n            if len(s)<1 or len(s)>3:\\n                return False\\n            if int(s)>255:\\n                return False\\n            if int(s)!=0 and s[0]==\\'0\\':\\n                return False\\n            if int(s)==0 and len(s)>1:\\n                return False\\n            return True\\n       \\n        ans = []\\n        for i in range(4):\\n            \\n            if not valid(s[:i]):\\n                continue\\n            \\n            for j in range(i,i+4):\\n                \\n                if not valid(s[i:j]):\\n                    continue\\n                \\n                for k in range(j,j+4):\\n                    \\n                    if not valid(s[j:k]):\\n                        continue\\n                    \\n                    if not valid(s[k:]):\\n                        continue\\n    \\n                    ans.append(s[:i]+\".\"+s[i:j]+\".\"+s[j:k]+\".\"+s[k:])\\n                   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383843,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s.length()>12) return new ArrayList<>();\\n        computeIP(\"\", s, 0, 0);\\n        return ans;\\n    }\\n    public void computeIP(String cur, String s, int idx, int seg_num) {\\n        if (seg_num==4 && idx>=s.length()) ans.add(cur);\\n        for (int i = 1; i <= Math.min(3, s.length()-idx); i++) {\\n            String sub = s.substring(idx, idx+i);\\n            if (sub.length()>1&&sub.charAt(0)==\\'0\\') return;\\n            int temp = Integer.parseInt(sub);\\n            if (temp<=255 && temp>=0) {\\n                if (!cur.equals(\"\")) {\\n                    computeIP(cur.concat(\".\" + sub), s, idx+i, seg_num+1);\\n                }\\n                else {\\n                    computeIP(cur.concat(sub), s, idx+i, seg_num+1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s.length()>12) return new ArrayList<>();\\n        computeIP(\"\", s, 0, 0);\\n        return ans;\\n    }\\n    public void computeIP(String cur, String s, int idx, int seg_num) {\\n        if (seg_num==4 && idx>=s.length()) ans.add(cur);\\n        for (int i = 1; i <= Math.min(3, s.length()-idx); i++) {\\n            String sub = s.substring(idx, idx+i);\\n            if (sub.length()>1&&sub.charAt(0)==\\'0\\') return;\\n            int temp = Integer.parseInt(sub);\\n            if (temp<=255 && temp>=0) {\\n                if (!cur.equals(\"\")) {\\n                    computeIP(cur.concat(\".\" + sub), s, idx+i, seg_num+1);\\n                }\\n                else {\\n                    computeIP(cur.concat(sub), s, idx+i, seg_num+1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206516,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public IList<string> RestoreIpAddresses(string s) \\n    {\\n        IList<string> ans = new List<string>();\\n\\n        if(s.Length > 12)\\n            return ans;\\n        \\n        Backtrack(s,0,new List<string>(),ans);\\n        return ans;\\n    }\\n    \\n    private void Backtrack(string s, int st, IList<string> li, IList<string> ans)\\n    {\\n        if(st==s.Length && li.Count==4)\\n        {\\n            string ip = string.Join(\".\", li.ToArray());\\n            ans.Add(ip);\\n            return;\\n        }\\n        \\n        for(int len=1; len<=s.Length-st; len++)\\n        {\\n            string str = s.Substring(st,len);\\n            \\n            if(IsValid(str))\\n            {\\n                li.Add(str);\\n                Backtrack(s,st+len,li,ans);\\n                li.RemoveAt(li.Count-1);\\n            }\\n        }\\n    }\\n    \\n    private bool IsValid(string str)\\n    {\\n        if(str.Length > 3)\\n            return false;\\n        \\n        int num = int.Parse(str);\\n        \\n        if(num < 0 || num > 255 || str.Length != num.ToString().Length)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public IList<string> RestoreIpAddresses(string s) \\n    {\\n        IList<string> ans = new List<string>();\\n\\n        if(s.Length > 12)\\n            return ans;\\n        \\n        Backtrack(s,0,new List<string>(),ans);\\n        return ans;\\n    }\\n    \\n    private void Backtrack(string s, int st, IList<string> li, IList<string> ans)\\n    {\\n        if(st==s.Length && li.Count==4)\\n        {\\n            string ip = string.Join(\".\", li.ToArray());\\n            ans.Add(ip);\\n            return;\\n        }\\n        \\n        for(int len=1; len<=s.Length-st; len++)\\n        {\\n            string str = s.Substring(st,len);\\n            \\n            if(IsValid(str))\\n            {\\n                li.Add(str);\\n                Backtrack(s,st+len,li,ans);\\n                li.RemoveAt(li.Count-1);\\n            }\\n        }\\n    }\\n    \\n    private bool IsValid(string str)\\n    {\\n        if(str.Length > 3)\\n            return false;\\n        \\n        int num = int.Parse(str);\\n        \\n        if(num < 0 || num > 255 || str.Length != num.ToString().Length)\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179768,
                "title": "java-backtracking-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    List<String> list;\\n    public List<String> restoreIpAddresses(String s) {\\n        list = new ArrayList<>();\\n        //if string length is greater than 12 and smaller than 12 i can\\'t make a valid ip addres....think!\\n        if(s.length() < 4 || s.length() > 12){\\n            return list;\\n        }\\n        \\n        restoreIP(s, \"\" , 0);\\n        return list;\\n    }\\n    // idx shows the number of sections of ip we have covered like 123.22. now idx will be 2 cze we have used 2 dots\\n    // and atmost we can use 3\\n    void restoreIP(String s, String sub, int idx){\\n        \\n        if(s.length() == 0 || idx == 4){\\n            if(s.length() == 0 && idx == 4){\\n                //removing the last dot and then adding, because while making call we putted .\\n                // we do not need to check validity of string before adding because, while making call we have checked                 // all scenerio\\n                list.add(sub.substring(0, sub.length()-1));\\n            }\\n            return;\\n        }\\n        //1st chcek with string size of 1 i.e, 1. , 2.  etc. \\n        restoreIP(s.substring(1), sub + s.substring(0,1) + \".\" , idx+1);\\n        \\n        //2nd check for 2 length string\\n        if(s.length() >= 2 && s.charAt(0) != \\'0\\')\\n            restoreIP(s.substring(2), sub + s.substring(0,2) + \".\", idx + 1);\\n        \\n        //3rd check for 3 length string and if string value is greater than 255 it\\'s not valid..according to the question.\\n        if(s.length() >= 3 && s.charAt(0) != \\'0\\' && Integer.valueOf(s.substring(0,3)) <= 255)\\n            restoreIP(s.substring(3), sub + s.substring(0,3) + \".\" , idx + 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> list;\\n    public List<String> restoreIpAddresses(String s) {\\n        list = new ArrayList<>();\\n        //if string length is greater than 12 and smaller than 12 i can\\'t make a valid ip addres....think!\\n        if(s.length() < 4 || s.length() > 12){\\n            return list;\\n        }\\n        \\n        restoreIP(s, \"\" , 0);\\n        return list;\\n    }\\n    // idx shows the number of sections of ip we have covered like 123.22. now idx will be 2 cze we have used 2 dots\\n    // and atmost we can use 3\\n    void restoreIP(String s, String sub, int idx){\\n        \\n        if(s.length() == 0 || idx == 4){\\n            if(s.length() == 0 && idx == 4){\\n                //removing the last dot and then adding, because while making call we putted .\\n                // we do not need to check validity of string before adding because, while making call we have checked                 // all scenerio\\n                list.add(sub.substring(0, sub.length()-1));\\n            }\\n            return;\\n        }\\n        //1st chcek with string size of 1 i.e, 1. , 2.  etc. \\n        restoreIP(s.substring(1), sub + s.substring(0,1) + \".\" , idx+1);\\n        \\n        //2nd check for 2 length string\\n        if(s.length() >= 2 && s.charAt(0) != \\'0\\')\\n            restoreIP(s.substring(2), sub + s.substring(0,2) + \".\", idx + 1);\\n        \\n        //3rd check for 3 length string and if string value is greater than 255 it\\'s not valid..according to the question.\\n        if(s.length() >= 3 && s.charAt(0) != \\'0\\' && Integer.valueOf(s.substring(0,3)) <= 255)\\n            restoreIP(s.substring(3), sub + s.substring(0,3) + \".\" , idx + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789947,
                "title": "simple-python-backtracking",
                "content": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if not 4 <= len(s) <= 12:\\n            return []\\n        res = []\\n        self.backtrack(s, 0, \\'\\', res, 0)\\n        return res\\n\\n    def backtrack(self, s, start, path, res, count):\\n        if count == 4:\\n            if start == len(s):\\n                res.append(path[1:])\\n            return\\n\\n        for end in [start + 1, start + 2, start + 3]:\\n\\t\\t\\t# number between 0 and 255 and does not start with 0\\n            if end <= len(s) and 0 <= int(s[start: end]) <= 255 and str(int(s[start: end])) == s[start: end]:\\n                self.backtrack(s, end, path + \\'.\\' + s[start: end], res, count + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        if not 4 <= len(s) <= 12:\\n            return []\\n        res = []\\n        self.backtrack(s, 0, \\'\\', res, 0)\\n        return res\\n\\n    def backtrack(self, s, start, path, res, count):\\n        if count == 4:\\n            if start == len(s):\\n                res.append(path[1:])\\n            return\\n\\n        for end in [start + 1, start + 2, start + 3]:\\n\\t\\t\\t# number between 0 and 255 and does not start with 0\\n            if end <= len(s) and 0 <= int(s[start: end]) <= 255 and str(int(s[start: end])) == s[start: end]:\\n                self.backtrack(s, end, path + \\'.\\' + s[start: end], res, count + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774340,
                "title": "java-backtracking-1ms",
                "content": "```\\nclass Solution {\\n    \\n    List<String> ansList = new ArrayList<>();\\n    \\n    boolean isValid(String s){\\n        if(s.length()>3 || (s.length()>1 && s.charAt(0)==\\'0\\')) return false; \\n        int val = Integer.valueOf(s);\\n        return val>=0 && val<=255 ;\\n    }\\n    \\n    void solve(int depth, String s, StringBuilder sb){\\n        if(depth == 3){\\n           if(isValid(s)){\\n               sb.append(s);\\n               ansList.add(sb.toString());\\n               sb.setLength(sb.length()-s.length());\\n           }\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(i>=s.length()) break;\\n            String temp = s.substring(0,i);\\n            if(isValid(temp)){\\n                sb.append(temp).append(\".\");\\n                solve(depth+1,s.substring(i),sb);\\n                sb.setLength(sb.length()-(temp.length()+1));\\n            }\\n        }\\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        solve(0,s,new StringBuilder(\"\"));\\n        return ansList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> ansList = new ArrayList<>();\\n    \\n    boolean isValid(String s){\\n        if(s.length()>3 || (s.length()>1 && s.charAt(0)==\\'0\\')) return false; \\n        int val = Integer.valueOf(s);\\n        return val>=0 && val<=255 ;\\n    }\\n    \\n    void solve(int depth, String s, StringBuilder sb){\\n        if(depth == 3){\\n           if(isValid(s)){\\n               sb.append(s);\\n               ansList.add(sb.toString());\\n               sb.setLength(sb.length()-s.length());\\n           }\\n            return;\\n        }\\n        for(int i=1;i<=3;i++){\\n            if(i>=s.length()) break;\\n            String temp = s.substring(0,i);\\n            if(isValid(temp)){\\n                sb.append(temp).append(\".\");\\n                solve(depth+1,s.substring(i),sb);\\n                sb.setLength(sb.length()-(temp.length()+1));\\n            }\\n        }\\n    }\\n    \\n    public List<String> restoreIpAddresses(String s) {\\n        solve(0,s,new StringBuilder(\"\"));\\n        return ansList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283437,
                "title": "c-concise-recursive-solution",
                "content": "1. We try out all the three different lengths (1-3) at each index.\\n2. We check if the value obtained for each length is valid. If yes, we recursively proceed.\\n3. If the index reach the end and the number of strings on the path is 4, then we store the path.\\n4. For faster return, we can check if the current cout has already been at least 4.\\n```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        size = s.size();\\n        helper(s, 0, 0);\\n        return ret;\\n    }\\nprivate:\\n    int size;\\n    vector<string> ret;\\n    vector<string> path;\\n    void helper(string& s, int idx, int count) {\\n        if(idx == size && count == 4) {\\n            string tmp; for(auto& p : path) tmp += p + \".\"; tmp.pop_back();\\n            ret.push_back(tmp);\\n            return;\\n        }\\n        if(count > 4) return;\\n        for(int len = 1; len<=3 && len+idx-1<size; len++){\\n            string tmp = s.substr(idx, len);\\n            int val = stoi(tmp);\\n            if(val > 255 || (tmp.size()>1 && tmp[0] == \\'0\\')) continue;\\n            path.push_back(tmp);\\n            helper(s, len+idx, count+1);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        size = s.size();\\n        helper(s, 0, 0);\\n        return ret;\\n    }\\nprivate:\\n    int size;\\n    vector<string> ret;\\n    vector<string> path;\\n    void helper(string& s, int idx, int count) {\\n        if(idx == size && count == 4) {\\n            string tmp; for(auto& p : path) tmp += p + \".\"; tmp.pop_back();\\n            ret.push_back(tmp);\\n            return;\\n        }\\n        if(count > 4) return;\\n        for(int len = 1; len<=3 && len+idx-1<size; len++){\\n            string tmp = s.substr(idx, len);\\n            int val = stoi(tmp);\\n            if(val > 255 || (tmp.size()>1 && tmp[0] == \\'0\\')) continue;\\n            path.push_back(tmp);\\n            helper(s, len+idx, count+1);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253515,
                "title": "beats-100-c-4-small-loops",
                "content": "class Solution {\\npublic:\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n = s.length();\\n        if (!n) return vector<string>();\\n        \\n        for (int a = 1; a <= 3; a++) {\\n            for (int b = 1; b <= 3; b++) {\\n                for (int c = 1; c <= 3; c++) {\\n                    for (int d = 1; d <= 3; d++) {\\n                        if (a+b+c+d == n) {\\n                            int A = stoi(s.substr(0, a));\\n                            int B = stoi(s.substr(a, b));\\n                            int C = stoi(s.substr(a+b, c));\\n                            int D = stoi(s.substr(a+b+c, d));\\n                            \\n                            if (A <= 255 && B <= 255 && C <= 255 && D <= 255) {\\n                                string r = to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D);\\n                                if (r.length() == n+3)\\n                                    res.push_back(r);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string>res;\\n        int n = s.length();\\n        if (!n) return vector<string>();\\n        \\n        for (int a = 1; a <= 3; a++) {\\n            for (int b = 1; b <= 3; b++) {\\n                for (int c = 1; c <= 3; c++) {\\n                    for (int d = 1; d <= 3; d++) {\\n                        if (a+b+c+d == n) {\\n                            int A = stoi(s.substr(0, a));\\n                            int B = stoi(s.substr(a, b));\\n                            int C = stoi(s.substr(a+b, c));\\n                            int D = stoi(s.substr(a+b+c, d));\\n                            \\n                            if (A <= 255 && B <= 255 && C <= 255 && D <= 255) {\\n                                string r = to_string(A)+\".\"+to_string(B)+\".\"+to_string(C)+\".\"+to_string(D);\\n                                if (r.length() == n+3)\\n                                    res.push_back(r);\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 151356,
                "title": "javascript-backtracking",
                "content": "```js\\nfunction restoreIpAddresses(s) {\\n  const res = [];\\n  dfs([], 0);\\n  return res;\\n  \\n  function dfs(prefix, idx) {\\n    if (prefix.length === 4 && idx === s.length) {\\n      res.push(prefix.join(\\'.\\'));\\n      return;\\n    }\\n    \\n    if (prefix.length === 4 || idx === s.length) {\\n      return;\\n    }\\n    \\n    for (let r = idx; r < s.length; r++) {\\n      if (r !== idx && s[idx] === \\'0\\') return;\\n      \\n      const num = parseInt(s.slice(idx, r+1));\\n      if (num > 255) {\\n        return;\\n      }\\n      prefix.push(num);\\n      dfs(prefix, r+1);\\n      prefix.pop();\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction restoreIpAddresses(s) {\\n  const res = [];\\n  dfs([], 0);\\n  return res;\\n  \\n  function dfs(prefix, idx) {\\n    if (prefix.length === 4 && idx === s.length) {\\n      res.push(prefix.join(\\'.\\'));\\n      return;\\n    }\\n    \\n    if (prefix.length === 4 || idx === s.length) {\\n      return;\\n    }\\n    \\n    for (let r = idx; r < s.length; r++) {\\n      if (r !== idx && s[idx] === \\'0\\') return;\\n      \\n      const num = parseInt(s.slice(idx, r+1));\\n      if (num > 255) {\\n        return;\\n      }\\n      prefix.push(num);\\n      dfs(prefix, r+1);\\n      prefix.pop();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136053,
                "title": "c-runtime-beats-97-61-of-cpp-submissions",
                "content": "```\\nclass Solution {\\n  void solver(string s, int index, string address, vector<string> & res) {\\n    if (index == 4) {\\n      if (s.empty())\\n        res.push_back(address.substr(0, address.size() - 1)); // skip last dot.\\n      return;\\n    }\\n\\n    for (int i = 1; i < 4; ++i) {\\n      if (i <= s.size()) {\\n        if (i >= 2 && s[0] == \\'0\\') continue;\\n        string part = s.substr(0, i);\\n        if (i == 3 && atoi(part.c_str()) > 255) continue;\\n        solver(s.substr(i), index + 1, address + part + \".\", res);\\n      }\\n    }\\n  }\\n\\npublic:\\n  vector<string> restoreIpAddresses(string s) {\\n    vector<string> res;\\n    solver(s, 0, \"\", res);\\n    return res;\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  void solver(string s, int index, string address, vector<string> & res) {\\n    if (index == 4) {\\n      if (s.empty())\\n        res.push_back(address.substr(0, address.size() - 1)); // skip last dot.\\n      return;\\n    }\\n\\n    for (int i = 1; i < 4; ++i) {\\n      if (i <= s.size()) {\\n        if (i >= 2 && s[0] == \\'0\\') continue;\\n        string part = s.substr(0, i);\\n        if (i == 3 && atoi(part.c_str()) > 255) continue;\\n        solver(s.substr(i), index + 1, address + part + \".\", res);\\n      }\\n    }\\n  }\\n\\npublic:\\n  vector<string> restoreIpAddresses(string s) {\\n    vector<string> res;\\n    solver(s, 0, \"\", res);\\n    return res;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30942,
                "title": "c-0ms-recursive-solution-clean-and-easy-to-understand",
                "content": "```\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        help(ans, \"\", s, 0);\\n        return ans;\\n    }\\n    void help(vector<string>& ans, string cur, string s, int count){\\n        if(count == 4){\\n            if(s == \"\") ans.push_back(cur.substr(1));\\n            return;\\n        }\\n        if(s.size() >= 3 && s[0] != '0'){\\n            if(stoi(s.substr(0, 3)) <= 255)\\n                help(ans, cur + \".\" + s.substr(0, 3), s.substr(3), count + 1);\\n        }\\n        if(s.size() >= 2 && s[0] != '0') help(ans, cur + \".\" + s.substr(0, 2), s.substr(2), count + 1);\\n        if(s.size() >= 1) help(ans, cur + \".\" + s.substr(0, 1), s.substr(1), count + 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        help(ans, \"\", s, 0);\\n        return ans;\\n    }\\n    void help(vector<string>& ans, string cur, string s, int count){\\n        if(count == 4){\\n            if(s == \"\") ans.push_back(cur.substr(1));\\n            return;\\n        }\\n        if(s.size() >= 3 && s[0] != '0'){\\n            if(stoi(s.substr(0, 3)) <= 255)\\n                help(ans, cur + \".\" + s.substr(0, 3), s.substr(3), count + 1);\\n        }\\n        if(s.size() >= 2 && s[0] != '0') help(ans, cur + \".\" + s.substr(0, 2), s.substr(2), count + 1);\\n        if(s.size() >= 1) help(ans, cur + \".\" + s.substr(0, 1), s.substr(1), count + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31108,
                "title": "share-my-clean-dfs-java-code",
                "content": "    /*\\n        dfs. \\u5728\\u6bcf\\u4e00\\u5c42, \\u53d6\\u5b57\\u7b26\\u4e32\\u7684\\u524d1/2/3\\u4e2a\\u5b57\\u6bcd\\n        \\u7b2c\\u56db\\u5c42\\u65f6\\u68c0\\u67e5\\u5e76collect answer.\\n    */\\n    public class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n             List<String> ans = new ArrayList<>();\\n             dfs(ans, new StringBuilder(), s, 0);\\n             return ans;\\n        }\\n        \\n        private void dfs(List<String> ans, StringBuilder cur, String s, int level) {\\n            if (level == 4) {  // all previous 4 segments are done\\n                if (s.length() == 0) {  // s is entirely used\\n                    ans.add(cur.toString().substring(0, cur.length() - 1));  // remove the dot at tail\\n                }\\n                return;\\n            }\\n            for (int i = 1; i <= Math.min(3, s.length()); ++i) {  // length of each segment are at most 3\\n                String curPart = s.substring(0, i);\\n                if (curPart.length() > 1 && curPart.charAt(0) == '0' || Integer.parseInt(curPart) > 255) {\\n                    break;\\n                }\\n                cur.append(curPart).append(\".\");\\n                dfs(ans, cur, s.substring(i), level + 1);\\n                cur.delete(cur.length() - curPart.length() - 1, cur.length());\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> restoreIpAddresses(String s) {\\n             List<String> ans = new ArrayList<>();\\n             dfs(ans, new StringBuilder(), s, 0);\\n             return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31130,
                "title": "c-backtracking-solution-easy-understand",
                "content": "    class Solution {\\n    public:\\n    vector<string> restoreIpAddresses(string s) \\n    {\\n    \\tstd::vector<string> ans;\\n    \\tstd::vector<string> v;\\n\\n    \\tsplitIP(0, 4, s, ans, v);\\n\\n    \\treturn ans;\\n    }\\n\\n    private:\\n\\tvoid splitIP(int startIndex, int segments, string &str, std::vector<string> &ans, std::vector<string> &ip)\\n\\t{\\n\\t\\tif (startIndex >= str.length() && segments != 0)\\n\\t\\t\\treturn;\\n\\t\\tif (startIndex != str.length() && segments == 0)\\n\\t\\t\\treturn;\\n\\t\\tif (startIndex == str.length() && segments == 0)\\n\\t\\t{\\n\\t\\t\\tans.push_back(ip[0] + '.' + ip[1] + '.' + ip[2] + '.' + ip[3]);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = startIndex; i < startIndex + 3 && i < str.length(); ++i)\\n\\t\\t{\\n\\t\\t\\tstring digit = str.substr(startIndex, i - startIndex + 1);\\n\\n\\t\\t\\tif (stoi(digit) > 255)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tip.push_back(digit);\\n\\t\\t\\tsplitIP(i + 1, segments - 1, str, ans, ip);\\n\\t\\t\\tip.pop_back();\\n\\n\\t\\t\\tif (str[startIndex] == '0')\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t}\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n    vector<string> restoreIpAddresses(string s) \\n    {\\n    \\tstd::vector<string> ans;\\n    \\tstd::vector<string> v;\\n\\n    \\tsplitIP(0, 4, s, ans, v);\\n\\n    \\treturn ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 31197,
                "title": "accepted-recurssive-python-solution",
                "content": " Function split2intgers need an additional input numDig to denote the number of integer that should separated from the string. At the beginning this number is 4. Then recursively check all possible cases. \\n\\n \\n\\n      class Solution:\\n            # @param s, a string\\n            # @return a list of strings\\n            def split2intgers(self,string,numDig):\\n                res=[]\\n                if numDig==1: \\n                    if len(string)==1 or (len(string)==2 and string[0]>'0') or (len(string)==3 and string[0]>'0' and int(string[0:3])<=255):\\n                        return [string]\\n                    else:\\n                        return []\\n                else:\\n                    if len(string)<numDig:\\n                        return []\\n                    for ii in range(1,min(len(string)-numDig+1,3)+1):\\n                        tmp=string[0:ii]\\n                        if len(tmp)==1 or (len(tmp)==2 and tmp[0]!='0') or (len(tmp)==3 and tmp[0]!='0' and int(tmp[0:3])<=255):\\n                            list=self.split2intgers(string[ii:],numDig-1)\\n                            if list:\\n                                res+=[string[0:ii]+'.'+elem for elem in list]\\n                return res\\n            def restoreIpAddresses(self, s):\\n                #should be seperate into four \\n                res=self.split2intgers(s,4)\\n                return res",
                "solutionTags": [],
                "code": " Function split2intgers need an additional input numDig to denote the number of integer that should separated from the string. At the beginning this number is 4. Then recursively check all possible cases. \\n\\n \\n\\n      class Solution:\\n            # @param s, a string\\n            # @return a list of strings\\n            def split2intgers(self,string,numDig):\\n                res=[]\\n                if numDig==1: \\n                    if len(string)==1 or (len(string)==2 and string[0]>'0') or (len(string)==3 and string[0]>'0' and int(string[0:3])<=255):\\n                        return [string]\\n                    else:\\n                        return []\\n                else:\\n                    if len(string)<numDig:\\n                        return []\\n                    for ii in range(1,min(len(string)-numDig+1,3)+1):\\n                        tmp=string[0:ii]\\n                        if len(tmp)==1 or (len(tmp)==2 and tmp[0]!='0') or (len(tmp)==3 and tmp[0]!='0' and int(tmp[0:3])<=255):\\n                            list=self.split2intgers(string[ii:],numDig-1)\\n                            if list:\\n                                res+=[string[0:ii]+'.'+elem for elem in list]\\n                return res\\n            def restoreIpAddresses(self, s):\\n                #should be seperate into four \\n                res=self.split2intgers(s,4)\\n                return res",
                "codeTag": "Java"
            },
            {
                "id": 3187629,
                "title": "restore-ip-addresses-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s the step by step explanation of the algorithm:\\n\\n1. We define a recursive function restore_ip that takes four arguments: the current index in the string s, the current part number part, the current IP address ip, and the list of valid IP addresses result.\\n2. If we have reached the end of the string s and we have formed four parts in ip, we append ip to result.\\n3. If we have formed less than four parts in ip and there are still characters remaining in s, we try to place a dot after the next one or two digits.\\n4. If we have formed less than four parts in ip and there are at least two digits remaining in s, we try to place a dot after the next two digits.\\n5. If the current part in ip is not valid (i.e., it contains a leading zero or is greater than 255), we stop the recursion for this path.\\n6. If the current part in ip is valid, we recursively call restore_ip with the next index in s, the next part number, and the updated ip.\\n7. After all recursive calls are done, we return the list of valid IP addresses result.\\n\\n# Complexity\\n- Time complexity:\\n86.7%\\n\\n- Space complexity:\\n98.84%\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        result = []\\n        self.restore_ip(s, 0, 0, [], result)\\n        return result\\n    \\n    def restore_ip(self, s, index, part, ip, result):\\n        if index == len(s) and part == 4:\\n            result.append(\\'.\\'.join(ip))\\n        elif part < 4 and index < len(s):\\n            # try placing a dot after the next digit\\n            ip.append(s[index])\\n            self.restore_ip(s, index + 1, part + 1, ip, result)\\n            ip.pop()\\n            \\n            # try placing a dot after the next two digits\\n            if index + 1 < len(s) and s[index] != \\'0\\':\\n                ip.append(s[index:index + 2])\\n                self.restore_ip(s, index + 2, part + 1, ip, result)\\n                ip.pop()\\n                \\n            # try placing a dot after the next three digits\\n            if index + 2 < len(s) and s[index] != \\'0\\' and int(s[index:index + 3]) <= 255:\\n                ip.append(s[index:index + 3])\\n                self.restore_ip(s, index + 3, part + 1, ip, result)\\n                ip.pop()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        result = []\\n        self.restore_ip(s, 0, 0, [], result)\\n        return result\\n    \\n    def restore_ip(self, s, index, part, ip, result):\\n        if index == len(s) and part == 4:\\n            result.append(\\'.\\'.join(ip))\\n        elif part < 4 and index < len(s):\\n            # try placing a dot after the next digit\\n            ip.append(s[index])\\n            self.restore_ip(s, index + 1, part + 1, ip, result)\\n            ip.pop()\\n            \\n            # try placing a dot after the next two digits\\n            if index + 1 < len(s) and s[index] != \\'0\\':\\n                ip.append(s[index:index + 2])\\n                self.restore_ip(s, index + 2, part + 1, ip, result)\\n                ip.pop()\\n                \\n            # try placing a dot after the next three digits\\n            if index + 2 < len(s) and s[index] != \\'0\\' and int(s[index:index + 3]) <= 255:\\n                ip.append(s[index:index + 3])\\n                self.restore_ip(s, index + 3, part + 1, ip, result)\\n                ip.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089341,
                "title": "python-simple-dfs-28-ms-faster-than-96-21",
                "content": "https://leetcode.com/submissions/detail/883564385/  \\nRuntime: **28 ms**, faster than 96.21% of Python3 online submissions for Restore IP Addresses.  \\nMemory Usage: 13.9 MB, less than 28.27% of Python3 online submissions for Restore IP Addresses.   \\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        l, lst, ips = len(s), [([], 0)], []\\n        while lst: ## dfs\\n            ip, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                segment = s[i:j]\\n                if int(segment)>255: \\n                    break\\n                if j==l: ## reach the end\\n                    if len(ip)==3:\\n                        ips.append(ip+[segment])\\n                    break\\n                lst.append((ip+[segment], j))\\n                if segment==\\'0\\': ## e.g. segment \\'01\\' is not valid\\n                    break\\n        return [\\'.\\'.join(ip) for ip in ips]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        l, lst, ips = len(s), [([], 0)], []\\n        while lst: ## dfs\\n            ip, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                segment = s[i:j]\\n                if int(segment)>255: \\n                    break\\n                if j==l: ## reach the end\\n                    if len(ip)==3:\\n                        ips.append(ip+[segment])\\n                    break\\n                lst.append((ip+[segment], j))\\n                if segment==\\'0\\': ## e.g. segment \\'01\\' is not valid\\n                    break\\n        return [\\'.\\'.join(ip) for ip in ips]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081448,
                "title": "easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<string> result;\\n    // check validity of the string i.e. str should not start with 0 and should be in range of 0-255\\n    bool isValid(string str) {\\n        if(str[0] == \\'0\\')\\n            return false;\\n            \\n        //convert string to integer\\n        int val = stoi(str);\\n        \\n        return val <= 255;\\n    }\\n    // recursive function for generating ip address\\n    void solve(string& s, int idx, int part, string curr) {\\n        //valid ip is only possible when all the char of string is consumed and it has only 4 parts\\n        if(idx == n && part == 4) {\\n            result.push_back(curr.substr(0, curr.length()-1));\\n            return;\\n        }\\n        // if we consider 1 substr then the index range must be valid\\n        if(idx+1 <= n)\\n            solve(s, idx+1, part+1, curr + s.substr(idx, 1) + \".\");\\n        // if we choose 2 or 3 substr then the index and the str must have validity check\\n        if(idx+2 <= n && isValid(s.substr(idx, 2))) {\\n            solve(s, idx+2, part+1, curr + s.substr(idx, 2) + \".\");\\n        }\\n        \\n        if(idx+3 <= n && isValid(s.substr(idx, 3))) {\\n            solve(s, idx+3, part+1, curr + s.substr(idx, 3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        result.clear();\\n        \\n        n = s.length();\\n        // we cannot divide into 4 parts in which length is greater than 12\\n        if(n > 12)\\n          return result;\\n      \\n        int part = 0;\\n        string curr = \"\";\\n        \\n        solve(s, 0, part, curr);\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<string> result;\\n    // check validity of the string i.e. str should not start with 0 and should be in range of 0-255\\n    bool isValid(string str) {\\n        if(str[0] == \\'0\\')\\n            return false;\\n            \\n        //convert string to integer\\n        int val = stoi(str);\\n        \\n        return val <= 255;\\n    }\\n    // recursive function for generating ip address\\n    void solve(string& s, int idx, int part, string curr) {\\n        //valid ip is only possible when all the char of string is consumed and it has only 4 parts\\n        if(idx == n && part == 4) {\\n            result.push_back(curr.substr(0, curr.length()-1));\\n            return;\\n        }\\n        // if we consider 1 substr then the index range must be valid\\n        if(idx+1 <= n)\\n            solve(s, idx+1, part+1, curr + s.substr(idx, 1) + \".\");\\n        // if we choose 2 or 3 substr then the index and the str must have validity check\\n        if(idx+2 <= n && isValid(s.substr(idx, 2))) {\\n            solve(s, idx+2, part+1, curr + s.substr(idx, 2) + \".\");\\n        }\\n        \\n        if(idx+3 <= n && isValid(s.substr(idx, 3))) {\\n            solve(s, idx+3, part+1, curr + s.substr(idx, 3) + \".\");\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        result.clear();\\n        \\n        n = s.length();\\n        // we cannot divide into 4 parts in which length is greater than 12\\n        if(n > 12)\\n          return result;\\n      \\n        int part = 0;\\n        string curr = \"\";\\n        \\n        solve(s, 0, part, curr);\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081237,
                "title": "java-recursive-solution-o-m-n-n",
                "content": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        int n = s.length();\\n        if (n > 12) return res;\\n\\n        int parts = 0;\\n        String curr = \"\";\\n        f(s, 0, parts, n, curr, res);\\n        return res;\\n    }\\n\\n    private static void f(String s, int idx, int parts, int n, String curr, List<String> res) {\\n        if (idx == n && parts == 4) {\\n            res.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n\\n        if (idx + 1 <= n)\\n            f(s, idx + 1, parts + 1, n, curr + s.substring(idx, idx + 1) + \".\", res);\\n\\n        if (idx + 2 <= n && isValid(s.substring(idx, idx + 2)))\\n            f(s, idx + 2, parts + 1, n, curr + s.substring(idx, idx + 2) + \".\", res);\\n\\n        if (idx + 3 <= n && isValid(s.substring(idx, idx + 3)))\\n            f(s, idx + 3, parts + 1, n, curr + s.substring(idx, idx + 3) + \".\", res);\\n\\n    }\\n\\n    private static boolean isValid(String s) {\\n        if (s.charAt(0) == \\'0\\') return false;\\n        int val = Integer.parseInt(s);\\n        return val <= 255;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();\\n        int n = s.length();\\n        if (n > 12) return res;\\n\\n        int parts = 0;\\n        String curr = \"\";\\n        f(s, 0, parts, n, curr, res);\\n        return res;\\n    }\\n\\n    private static void f(String s, int idx, int parts, int n, String curr, List<String> res) {\\n        if (idx == n && parts == 4) {\\n            res.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n\\n        if (idx + 1 <= n)\\n            f(s, idx + 1, parts + 1, n, curr + s.substring(idx, idx + 1) + \".\", res);\\n\\n        if (idx + 2 <= n && isValid(s.substring(idx, idx + 2)))\\n            f(s, idx + 2, parts + 1, n, curr + s.substring(idx, idx + 2) + \".\", res);\\n\\n        if (idx + 3 <= n && isValid(s.substring(idx, idx + 3)))\\n            f(s, idx + 3, parts + 1, n, curr + s.substring(idx, idx + 3) + \".\", res);\\n\\n    }\\n\\n    private static boolean isValid(String s) {\\n        if (s.charAt(0) == \\'0\\') return false;\\n        int val = Integer.parseInt(s);\\n        return val <= 255;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080583,
                "title": "java-backtracking-string",
                "content": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s == null || s.length() < 4 || s.length() > 12) {\\n            // return empty list if input is null or not in the correct length range\\n            return new ArrayList<>();\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder(s);\\n        dfs(sb, 0, 3, ans);\\n\\n        return ans;\\n    }\\n\\n    \\n    private void dfs(StringBuilder sb, int index, int dotCount, List<String> ans) {\\n        if (dotCount == 0) {\\n            // base case, if all dots have been added, check if the IP address is valid\\n            if (isValid(sb)) {\\n                ans.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        if (index >= sb.length()) {\\n            return;\\n        }\\n\\n        //backtracking\\n        \\n        sb.insert(index, \".\");\\n        dfs(sb, index + 2, dotCount - 1, ans);\\n        sb.deleteCharAt(index);\\n\\n        dfs(sb, index + 1, dotCount, ans);\\n    }\\n\\n    \\n    private boolean isValid(StringBuilder sb) {\\n        String[] parts = sb.toString().split(\"\\\\\\\\.\");\\n        if (parts.length != 4) {\\n            return false;\\n        }\\n\\n        for (String part : parts) {\\n            if (part.length() == 0 || part.length() > 3) {\\n                return false;\\n            }\\n\\n            if (part.startsWith(\"0\") && part.length() > 1) {\\n                return false;\\n            }\\n\\n            int num = Integer.parseInt(part);\\n            if (num > 255) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**Do UpVote**",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> restoreIpAddresses(String s) {\\n        if (s == null || s.length() < 4 || s.length() > 12) {\\n            // return empty list if input is null or not in the correct length range\\n            return new ArrayList<>();\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder(s);\\n        dfs(sb, 0, 3, ans);\\n\\n        return ans;\\n    }\\n\\n    \\n    private void dfs(StringBuilder sb, int index, int dotCount, List<String> ans) {\\n        if (dotCount == 0) {\\n            // base case, if all dots have been added, check if the IP address is valid\\n            if (isValid(sb)) {\\n                ans.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        if (index >= sb.length()) {\\n            return;\\n        }\\n\\n        //backtracking\\n        \\n        sb.insert(index, \".\");\\n        dfs(sb, index + 2, dotCount - 1, ans);\\n        sb.deleteCharAt(index);\\n\\n        dfs(sb, index + 1, dotCount, ans);\\n    }\\n\\n    \\n    private boolean isValid(StringBuilder sb) {\\n        String[] parts = sb.toString().split(\"\\\\\\\\.\");\\n        if (parts.length != 4) {\\n            return false;\\n        }\\n\\n        for (String part : parts) {\\n            if (part.length() == 0 || part.length() > 3) {\\n                return false;\\n            }\\n\\n            if (part.startsWith(\"0\") && part.length() > 1) {\\n                return false;\\n            }\\n\\n            int num = Integer.parseInt(part);\\n            if (num > 255) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080525,
                "title": "java-recursive-code-with-explanation-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/4a164322-63c2-49e7-8692-78beb8580285_1674290937.229729.png)\\n\\n\\n\\uD83D\\uDC4D\\uD83D\\uDE0A**Upvote**\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        \\n        List<String> ans = new ArrayList<String>(); // for returing the ans list\\n        List<String> ls = new ArrayList<String>(); // for calculating IP address of exactly with 4 dots\\n\\n        allValidAddress(ans, ls, s);\\n\\n        return ans;\\n\\n    }\\n\\n    public void allValidAddress(List<String> ans, List<String> ls, String s)\\n    {\\n        int n = s.length();\\n\\n        if(ls.size() >= 4 && n != 0) // if ls length is 4 but our s string length is not equal to 0 means to valid IP.\\n        {\\n            return; // returning from recurive call\\n        }\\n\\n        if(n == 0) // if n == 0 \\n        {\\n            if(ls.size() == 4) // if ls list size is 4 so we can say we genrated a valid IP address with 4 dots\\n            {\\n                StringBuilder sb = new StringBuilder();\\n\\n                for(int i = 0; i < ls.size(); i++)\\n                {\\n                    if(i == 0)\\n                    {\\n                        sb.append(ls.get(i));\\n                    }\\n                    else\\n                    {\\n                        sb.append(\".\" + ls.get(i));\\n                    }\\n                }\\n                ans.add(sb.toString()); // adding IP address in ans list\\n            }\\n            return; // returning from the recursive call\\n        }\\n\\n        for(int i = 0; i < 3 && i < n; i++) // every time taking a string less than or equal to 3 size from s string\\n        {\\n            String tem = s.substring(0, i + 1); // taking tem string from 0 to i.\\n\\n            if(tem.length() > 1 && tem.charAt(0) == \\'0\\') //cheking leading zeros if tem contains the leading zeors.\\n            {    \\n                return; // returning from recursive call\\n            }\\n\\n            int x = Integer.parseInt(tem); // converting tem to int\\n\\n            if(x <= 255) // if x <= 255\\n            {\\n                ls.add(tem); // adding tem is ls\\n\\n                allValidAddress(ans, ls, s.substring(i + 1)); // doing recursive call for next substring from i to n.\\n\\n                ls.remove(ls.size() - 1); \\n        // if any condition becomes true for not a valid IP so during backtracking we have to undo all changes we made\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        \\n        List<String> ans = new ArrayList<String>(); // for returing the ans list\\n        List<String> ls = new ArrayList<String>(); // for calculating IP address of exactly with 4 dots\\n\\n        allValidAddress(ans, ls, s);\\n\\n        return ans;\\n\\n    }\\n\\n    public void allValidAddress(List<String> ans, List<String> ls, String s)\\n    {\\n        int n = s.length();\\n\\n        if(ls.size() >= 4 && n != 0) // if ls length is 4 but our s string length is not equal to 0 means to valid IP.\\n        {\\n            return; // returning from recurive call\\n        }\\n\\n        if(n == 0) // if n == 0 \\n        {\\n            if(ls.size() == 4) // if ls list size is 4 so we can say we genrated a valid IP address with 4 dots\\n            {\\n                StringBuilder sb = new StringBuilder();\\n\\n                for(int i = 0; i < ls.size(); i++)\\n                {\\n                    if(i == 0)\\n                    {\\n                        sb.append(ls.get(i));\\n                    }\\n                    else\\n                    {\\n                        sb.append(\".\" + ls.get(i));\\n                    }\\n                }\\n                ans.add(sb.toString()); // adding IP address in ans list\\n            }\\n            return; // returning from the recursive call\\n        }\\n\\n        for(int i = 0; i < 3 && i < n; i++) // every time taking a string less than or equal to 3 size from s string\\n        {\\n            String tem = s.substring(0, i + 1); // taking tem string from 0 to i.\\n\\n            if(tem.length() > 1 && tem.charAt(0) == \\'0\\') //cheking leading zeros if tem contains the leading zeors.\\n            {    \\n                return; // returning from recursive call\\n            }\\n\\n            int x = Integer.parseInt(tem); // converting tem to int\\n\\n            if(x <= 255) // if x <= 255\\n            {\\n                ls.add(tem); // adding tem is ls\\n\\n                allValidAddress(ans, ls, s.substring(i + 1)); // doing recursive call for next substring from i to n.\\n\\n                ls.remove(ls.size() - 1); \\n        // if any condition becomes true for not a valid IP so during backtracking we have to undo all changes we made\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080389,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(string temp) {\\n        if(temp.size() > 3 or temp.size() == 0) return false;\\n        if(temp.size() > 1 and temp[0] == \\'0\\')   return false;\\n        if(temp.size() && stoi(temp) > 255) return false;\\n        return true;\\n    }\\n\\n    void solve(vector<string>& ans, string output, string s, int id, int dots) {\\n        if(dots == 3){\\n            if(valid(s.substr(id))) ans.push_back(output + s.substr(id));\\n            return;\\n        }\\n        for(int i=id; i<s.size(); i++) {\\n            if(valid(s.substr(id, i - id + 1))) {\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, s, i + 1, dots + 1);\\n                output.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(ans, \"\", s, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(string temp) {\\n        if(temp.size() > 3 or temp.size() == 0) return false;\\n        if(temp.size() > 1 and temp[0] == \\'0\\')   return false;\\n        if(temp.size() && stoi(temp) > 255) return false;\\n        return true;\\n    }\\n\\n    void solve(vector<string>& ans, string output, string s, int id, int dots) {\\n        if(dots == 3){\\n            if(valid(s.substr(id))) ans.push_back(output + s.substr(id));\\n            return;\\n        }\\n        for(int i=id; i<s.size(); i++) {\\n            if(valid(s.substr(id, i - id + 1))) {\\n                output.push_back(s[i]);\\n                output.push_back(\\'.\\');\\n                solve(ans, output, s, i + 1, dots + 1);\\n                output.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(ans, \"\", s, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080342,
                "title": "100-0ms-beat-me-dfs-backtracking-beats-100-proof-concise-2ways",
                "content": "# UPVOTE PLS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/a10949e5-6062-412e-bde4-9f013bc3b35f_1674287824.969369.png)\\n\\n# Complexity\\n- Time complexity: o(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>  ans =new ArrayList<>();\\n        int L=s.length();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.toCharArray(),new StringBuilder(),0,0,ans);\\n        return ans;\\n    }\\n    private void dfs(char s[],StringBuilder sec,int level,int cnt,List<String>  ans){\\n        if(level>4) return;\\n        int num=0,L=sec.length();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==s.length+4)ans.add(sec.substring(0,L-1).toString());\\n            return;\\n        }\\n        for(int i=cnt;i<s.length && i<=cnt+2;i++){\\n            num = num*10+(int)(s[i]-\\'0\\');\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(num).append(\".\"),level+1,i+1,ans);\\n            sec.setLength(L);\\n        } }\\n```\\n```\\npublic List<String> restoreIpAddresses(String s) { //2nd \\n        List<String>  ans =new ArrayList<>();\\n         int L=s.length();\\n         if(L<4 ||L>12) return ans;\\n         dfs(s,ans,\"\",0);\\n         return ans;\\n    }\\n     private void dfs(String s,List<String>  ans, String res,int cnt){\\n         if(cnt==4){\\n             if(s.isEmpty()) ans.add(res);\\n            return;\\n         }\\n         for(int i=1;i<=Math.min(3,s.length());i++){\\n             String sec=s.substring(0,i);\\n             if(sec.length()>1 && sec.charAt(0)==\\'0\\' || Integer.parseInt(sec)>255) continue;\\n             dfs(s.substring(i),ans,res+sec+(cnt<3?\".\":\"\"),cnt+1);\\n         } }\\n```\\n\\n# c++\\n```\\nvector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        int L=s.size();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.c_str(),\"\",0,0,ans);\\n        return ans;\\n    } \\n    void dfs(const char* s,string sec,int level,int cnt,vector<string> ans){\\n        if(level>4) return;\\n        int num=0,L=sec.size();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==strlen(s)+4)ans.push_back(sec.substr(0,L-1));\\n            return;\\n        }\\n        for(int i=cnt;i<strlen(s) && i<=cnt+2;i++){\\n            num = num*10+(int(s[i]-\\'0\\'));\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(std::to_string(num)).append(\".\"),level+1,i+1,ans);\\n        } }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String>  ans =new ArrayList<>();\\n        int L=s.length();\\n        if(L<4 ||L>12) return ans;\\n        dfs(s.toCharArray(),new StringBuilder(),0,0,ans);\\n        return ans;\\n    }\\n    private void dfs(char s[],StringBuilder sec,int level,int cnt,List<String>  ans){\\n        if(level>4) return;\\n        int num=0,L=sec.length();\\n        if(level==4){//sub problem is ready to add into final ans \\n            if(L==s.length+4)ans.add(sec.substring(0,L-1).toString());\\n            return;\\n        }\\n        for(int i=cnt;i<s.length && i<=cnt+2;i++){\\n            num = num*10+(int)(s[i]-\\'0\\');\\n            if(num>255)break; //validate ip sec <=255\\n            dfs(s,sec.append(num).append(\".\"),level+1,i+1,ans);\\n            sec.setLength(L);\\n        } }\\n```\n```\\npublic List<String> restoreIpAddresses(String s) { //2nd \\n        List<String>  ans =new ArrayList<>();\\n         int L=s.length();\\n         if(L<4 ||L>12) return ans;\\n         dfs(s,ans,\"\",0);\\n         return ans;\\n    }\\n     private void dfs(String s,List<String>  ans, String res,int cnt){\\n         if(cnt==4){\\n             if(s.isEmpty()) ans.add(res);\\n            return;\\n         }\\n         for(int i=1;i<=Math.min(3,s.length());i++){\\n             String sec=s.substring(0,i);\\n             if(sec.length()>1 && sec.charAt(0)==\\'0\\' || Integer.parseInt(sec)>255) continue;\\n             dfs(s.substring(i),ans,res+sec+(cnt<3?\".\":\"\"),cnt+1);\\n         } }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080071,
                "title": "the-o-1-solution-and-backtracking-detailed-explanation",
                "content": "# Intuition\\nIP addresses are in the format of four octets, where each octet is a number between 0 and 255.\\nThe task is to find all possible ways of dividing a given string into four segments, such that each segment represents a valid octet in an IP address. The algorithm checks all possible combinations of dividing the string into four segments and checks if each segment represents a valid octet, if so it constructs a valid IP address and adds it to the result list.\\n\\n# Approach\\n1. Initialize an empty list called ***result*** to store the valid IP addresses.\\n2. Check if the length of the input string is less than 4 or greater than 12. If so, return the empty ***result*** list.\\n3. Use four nested for-loops to iterate through all possible combinations of the length of each segment of the IP address.\\n4. For each iteration, create a new StringBuilder object called ***ip*** to construct the current candidate IP address.\\n5. Use the substring() method to extract the individual segments from the input string, convert them to integers using the Integer.valueOf() method.\\n6. Check if each of the segments is less than or equal to 255, which is a requirement for valid IP addresses.\\n7. If all segments are valid, append them to the ***ip*** StringBuilder object, separated by periods.\\n8. Check if the length of the constructed IP address is equal to the length of the input string plus three (to account for the three periods added), and if so, add it to the ***result*** list.\\n9. Return the ***result*** list at the end of the method.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is **O(1)**, it is a constant time complexity because the number of iterations is fixed and does not depend on the size of the input. The outer for-loop runs four times, and each inner for-loop runs three times, so the total number of iterations is  81.\\n\\n- Space complexity:\\nThe space complexity of this code is O(n), where n is the number of valid IP addresses found. This is because the algorithm creates a new StringBuilder object for each valid IP address and adds it to the result list, so the maximum space needed is proportional to the number of valid IP addresses. However, this space usage can be considered as low as the number of valid IP addresses cannot be more than 3^4 = 81.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        if(s.length() < 4 || s.length() > 12){\\n            return result;\\n        }\\n        for(int i = 1; i <= 3; i++){\\n            for(int j = 1; j <= 3; j++){\\n                for(int k = 1; k <= 3; k++){\\n                    for (int l = 1; l <= 3; l++){\\n                        if(i + j + k + l == s.length()){\\n                            StringBuilder ip = new StringBuilder();\\n                            int n1 = Integer.valueOf(s.substring(0, i));\\n                            int n2 = Integer.valueOf(s.substring(i, i + j));\\n                            int n3 = Integer.valueOf(s.substring(i + j, i + j + k));\\n                            int n4 = Integer.valueOf(s.substring(i + j + k, i + j + k + l));\\n                            if(n1 <= 255 && n2 <= 255 && n3 <= 255 && n4 <= 255){\\n                                ip.append(n1).append(\\'.\\').append(n2).append(\\'.\\').append(n3).append(\\'.\\').append(n4);\\n                            }\\n                            if(ip.toString().length() == s.length() + 3){\\n                                result.add(ip.toString());\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n## Backtracking Approach\\n1. Create a method called \"backtrack()\" which takes four parameters: the input string, the current starting index of the next segment, a list to store the current candidate IP address, and the final result list.\\n2. Inside backtrack() method, check if the current candidate IP address has four segments. If it does, check if all characters of the input string have been used.\\n3. If all characters have been used, add the candidate IP address to the result list.\\n4. If the current candidate IP address does not have four segments, use a for-loop to iterate through all possible combinations of the next segment, from the current starting index to a maximum of three characters.\\n5. For each iteration, extract the segment using substring() method and check if it is a valid segment (i.e. less than or equal to 255 and not starting with a \"0\" if its length is greater than 1).\\n6. If the segment is valid, add it to the candidate IP address and call the backtrack() method recursively with the updated parameters.\\n7. Remove the last segment from the candidate IP address and continue with the next iteration.\\n8. Return the result list at the end of the method.\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        backtrack(s, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(String s, int start, List<String> ip, List<String> result) {\\n        if (ip.size() == 4) {\\n            if (start == s.length()) {\\n                result.add(String.join(\".\", ip));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String segment = s.substring(start, i + 1);\\n            if (segment.startsWith(\"0\") && segment.length() > 1 || Integer.parseInt(segment) > 255) {\\n                continue;\\n            }\\n            ip.add(segment);\\n            backtrack(s, i + 1, ip, result);\\n            ip.remove(ip.size() - 1);\\n        }\\n    }\\n}\\n```\\n> I understand that this can be improved further, but this is my current understanding of the problem. I will work on providing a more effective solution with an explanation.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        if(s.length() < 4 || s.length() > 12){\\n            return result;\\n        }\\n        for(int i = 1; i <= 3; i++){\\n            for(int j = 1; j <= 3; j++){\\n                for(int k = 1; k <= 3; k++){\\n                    for (int l = 1; l <= 3; l++){\\n                        if(i + j + k + l == s.length()){\\n                            StringBuilder ip = new StringBuilder();\\n                            int n1 = Integer.valueOf(s.substring(0, i));\\n                            int n2 = Integer.valueOf(s.substring(i, i + j));\\n                            int n3 = Integer.valueOf(s.substring(i + j, i + j + k));\\n                            int n4 = Integer.valueOf(s.substring(i + j + k, i + j + k + l));\\n                            if(n1 <= 255 && n2 <= 255 && n3 <= 255 && n4 <= 255){\\n                                ip.append(n1).append(\\'.\\').append(n2).append(\\'.\\').append(n3).append(\\'.\\').append(n4);\\n                            }\\n                            if(ip.toString().length() == s.length() + 3){\\n                                result.add(ip.toString());\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList();\\n        backtrack(s, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(String s, int start, List<String> ip, List<String> result) {\\n        if (ip.size() == 4) {\\n            if (start == s.length()) {\\n                result.add(String.join(\".\", ip));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String segment = s.substring(start, i + 1);\\n            if (segment.startsWith(\"0\") && segment.length() > 1 || Integer.parseInt(segment) > 255) {\\n                continue;\\n            }\\n            ip.add(segment);\\n            backtrack(s, i + 1, ip, result);\\n            ip.remove(ip.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080042,
                "title": "simple-java-beginners-helpful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        backtrack(s, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> temp, List<String> res) {\\n        if (temp.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(String.join(\".\", temp));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String sub = s.substring(start, i + 1);\\n            if (isValid(sub)) {\\n                temp.add(sub);\\n                backtrack(s, i + 1, temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        return num >= 0 && num <= 255;\\n    }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        backtrack(s, 0, new ArrayList<>(), res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> temp, List<String> res) {\\n        if (temp.size() == 4) {\\n            if (start == s.length()) {\\n                res.add(String.join(\".\", temp));\\n            }\\n            return;\\n        }\\n        for (int i = start; i < s.length() && i < start + 3; i++) {\\n            String sub = s.substring(start, i + 1);\\n            if (isValid(sub)) {\\n                temp.add(sub);\\n                backtrack(s, i + 1, temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        if (s.length() > 1 && s.charAt(0) == \\'0\\') {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        return num >= 0 && num <= 255;\\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080018,
                "title": "c-easy-solution-without-recursion",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    #define ll long long int\\n    bool isValidIP(string & str)\\n    {\\n\\n        if (str.length() > 3)\\n\\n            return false;\\n\\n        if (str.front() == \\'0\\' and str.length() > 1) //leading zeros\\n\\n            return false;\\n\\n        ll val = stoll(str);\\n\\n        return val >= 0 and val <= 255;\\n    }\\n\\n    vector<string> restoreIpAddresses(string str)\\n    {\\n        vector<string> res;\\n        for (ll i = 1; i <= 3 and i < str.length(); i++)\\n\\n        {\\n\\n            string first = str.substr(0, i);\\n\\n            if (isValidIP(first))\\n\\n            {\\n\\n                for (ll j = 1; j <= 3 and i + j < str.length(); j++)\\n\\n                {\\n\\n                    string second = str.substr(i, j);\\n\\n                    if (isValidIP(second))\\n\\n                    {\\n\\n                        for (ll k = 1; k <= 3 and i + j + k < str.length(); k++)\\n\\n                        {\\n\\n                            string third = str.substr(i + j, k);\\n\\n                            string fourth = str.substr(i + j + k);\\n\\n                            if (isValidIP(third) and isValidIP(fourth))\\n\\n                            {\\n\\n                                res.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    #define ll long long int\\n    bool isValidIP(string & str)\\n    {\\n\\n        if (str.length() > 3)\\n\\n            return false;\\n\\n        if (str.front() == \\'0\\' and str.length() > 1) //leading zeros\\n\\n            return false;\\n\\n        ll val = stoll(str);\\n\\n        return val >= 0 and val <= 255;\\n    }\\n\\n    vector<string> restoreIpAddresses(string str)\\n    {\\n        vector<string> res;\\n        for (ll i = 1; i <= 3 and i < str.length(); i++)\\n\\n        {\\n\\n            string first = str.substr(0, i);\\n\\n            if (isValidIP(first))\\n\\n            {\\n\\n                for (ll j = 1; j <= 3 and i + j < str.length(); j++)\\n\\n                {\\n\\n                    string second = str.substr(i, j);\\n\\n                    if (isValidIP(second))\\n\\n                    {\\n\\n                        for (ll k = 1; k <= 3 and i + j + k < str.length(); k++)\\n\\n                        {\\n\\n                            string third = str.substr(i + j, k);\\n\\n                            string fourth = str.substr(i + j + k);\\n\\n                            if (isValidIP(third) and isValidIP(fourth))\\n\\n                            {\\n\\n                                res.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079727,
                "title": "c-100-faster-solution-dfs",
                "content": "C++ 100% faster solution \\n\\nThe code is commented and so it is self explanatory approach\\n\\nThe idea used here is to try to form all possible combinations with DFS\\n\\n```\\nclass Solution {\\n    \\n    void util(string &s,vector<string> &ans,string curr,int ind,int curr_sec_count)\\n    {\\n        if(curr_sec_count == 4 && (s.length() == ind))//if we have found all the sections and reached the end\\n        {\\n            ans.push_back(curr);//add it to result\\n            return;//ans return\\n        }   \\n        if((s.length()-ind) > 3*(4-curr_sec_count) || ind >= s.length())\\n        return; // to check if remaining can even form valid ip\\n        \\n        //explore all possible lengths of sections\\n        for(int i=1;i<=3;i++)\\n        {\\n            string curr_sec = s.substr(ind,i);//we make the partition\\n            \\n            if((curr_sec.length()>1 && curr_sec[0]==\\'0\\')|| stoi(curr_sec)>255)//if conditions of a section\\n               continue;//are not satisfied we continue\\n            \\n            //make curr section ip by adding \\'.\\' at appropriate positions\\n            string temp = curr_sec_count == 0 ? curr_sec : (curr + \".\" + curr_sec);\\n            \\n            //call to further check the results\\n            util(s,ans,temp,ind+i,curr_sec_count+1);\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;//to store the result\\n        //call utility function \\n        util(s,ans,\"\",0,0);\\n        //return the result\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void util(string &s,vector<string> &ans,string curr,int ind,int curr_sec_count)\\n    {\\n        if(curr_sec_count == 4 && (s.length() == ind))//if we have found all the sections and reached the end\\n        {\\n            ans.push_back(curr);//add it to result\\n            return;//ans return\\n        }   \\n        if((s.length()-ind) > 3*(4-curr_sec_count) || ind >= s.length())\\n        return; // to check if remaining can even form valid ip\\n        \\n        //explore all possible lengths of sections\\n        for(int i=1;i<=3;i++)\\n        {\\n            string curr_sec = s.substr(ind,i);//we make the partition\\n            \\n            if((curr_sec.length()>1 && curr_sec[0]==\\'0\\')|| stoi(curr_sec)>255)//if conditions of a section\\n               continue;//are not satisfied we continue\\n            \\n            //make curr section ip by adding \\'.\\' at appropriate positions\\n            string temp = curr_sec_count == 0 ? curr_sec : (curr + \".\" + curr_sec);\\n            \\n            //call to further check the results\\n            util(s,ans,temp,ind+i,curr_sec_count+1);\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;//to store the result\\n        //call utility function \\n        util(s,ans,\"\",0,0);\\n        //return the result\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079608,
                "title": "java-solution-beats-93-2ms-runtime-explained-with-comments-2-methods",
                "content": "#### Approach 1--> Using String and StringBuilder (6ms runtime Faster than 60%)\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>(); //result list\\n        restore(s,0,res,\"\",0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,String t,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(t); //adding restoredIp to result\\n\\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx)); \\n           //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                if(idx==s.length()-1)\\n                    restore(s,idx+1,res,t+temp.toString(),dots); //dot should not be inserted at last\\n                else\\n                    restore(s,idx+1,res,t+temp.toString()+\\'.\\',dots+1); \\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n       //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\')\\n           return false;\\n       //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;\\n    }\\n}\\n```\\n### Optimization of above code using List<String>\\n#### Approach 2--> Using StringBuilder & List<String>(Converting it to String) (2ms runtime and Faster than 93%)\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();  //result list\\n        restore(s,0,res,new ArrayList<String>(),0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,ArrayList<String> list,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(buildString(list)); //adding restoredIp to result\\n        \\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx));\\n            //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                list.add(temp.toString()); //adding valid string to list\\n                if(idx==s.length()-1) //dot should not be inserted at last\\n                    restore(s,idx+1,res,list,dots);\\n                else{\\n                    list.add(\".\"); //adding dot to list\\n                    restore(s,idx+1,res,list,dots+1);//incrementing the count of dots\\n                    list.remove(list.size()-1);  //removing dot from list\\n                }\\n                list.remove(list.size()-1); //removing valid string from list\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n        //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\') \\n           return false;\\n        //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;  //else condition\\n    }\\n    \\n    //building string from ArrayList<String> using StringBuilder\\n    private String buildString(ArrayList<String> list){\\n        StringBuilder sb = new StringBuilder();\\n        for(String s:list)\\n             sb.append(s);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>(); //result list\\n        restore(s,0,res,\"\",0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,String t,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(t); //adding restoredIp to result\\n\\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx)); \\n           //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                if(idx==s.length()-1)\\n                    restore(s,idx+1,res,t+temp.toString(),dots); //dot should not be inserted at last\\n                else\\n                    restore(s,idx+1,res,t+temp.toString()+\\'.\\',dots+1); \\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n       //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\')\\n           return false;\\n       //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> res = new ArrayList<>();  //result list\\n        restore(s,0,res,new ArrayList<String>(),0);\\n        return res;\\n    }\\n\\n    private void restore(String s,int i,List<String> res,ArrayList<String> list,int dots)\\n    {\\n        //all characters of string included and no. of dots in restoredIp==3\\n        if(i==s.length()&&dots==3)\\n            res.add(buildString(list)); //adding restoredIp to result\\n        \\n        StringBuilder temp = new StringBuilder();\\n        for(int idx=i;idx<s.length();idx++){\\n            temp.append(s.charAt(idx));\\n            //checking for valid conditions.\\n            if(dots<=3 && isValid(temp.toString())){\\n                list.add(temp.toString()); //adding valid string to list\\n                if(idx==s.length()-1) //dot should not be inserted at last\\n                    restore(s,idx+1,res,list,dots);\\n                else{\\n                    list.add(\".\"); //adding dot to list\\n                    restore(s,idx+1,res,list,dots+1);//incrementing the count of dots\\n                    list.remove(list.size()-1);  //removing dot from list\\n                }\\n                list.remove(list.size()-1); //removing valid string from list\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(String s){\\n        //checking for 1st character to not be \\'0\\' when len(s)>1\\n        if(s.length()>1 && s.charAt(0)==\\'0\\') \\n           return false;\\n        //checking for String value to remain between [0,255]\\n        if(s.length()>0 && s.length()<4 && Integer.parseInt(s)<256)\\n           return true;\\n        return false;  //else condition\\n    }\\n    \\n    //building string from ArrayList<String> using StringBuilder\\n    private String buildString(ArrayList<String> list){\\n        StringBuilder sb = new StringBuilder();\\n        for(String s:list)\\n             sb.append(s);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079562,
                "title": "c-backtracking-super-easy-code-with-comments",
                "content": "# Upvote Please!    \\n\\t// Function to check     \\n\\tint check(string &ds, int pdot){\\n\\n        string sub = string(ds.begin() + pdot,ds.end());\\n        \\n        if(sub[0] == \\'0\\' && sub.size()>1) return 0;\\n\\n        int no = stoi(sub);\\n        \\n        if(no>255) return 0;\\n        \\n        return 1;\\n    }\\n    \\n\\t// recursive function that does all the work\\n    void solve(string &s, string ds, vector<string>&ans,int i,int pdot,int dcount){\\n        \\n\\t\\t// if every thing setisfy push the ds in the answer\\n        if(i == s.size()){\\n            if(check(ds,pdot) && dcount == 3) ans.push_back(ds);\\n            return ;\\n        }\\n        \\n\\t\\t// push the string ith element in the ds.\\n        ds.push_back(s[i]); \\n        \\n\\t\\t// now check if it was a right decision pushing the element in the ds\\n\\t\\t// -> If the decision was right then lets move to the next element of the string without adding \" . \" in the ds.\\n        if(check(ds,pdot)) solve(s,ds,ans,i+1,pdot,dcount);\\n        \\n\\t\\t\\n\\t\\t// lets add \" . \" in the ds.\\n\\t\\t// min there should be 1 element to add a \" . \" \\n\\t\\t// also not more that 3 dot should be there so 2 already present and one inside the block.\\n        if(ds.size() - pdot >1 && dcount <=2)\\n        {\\n            int size = ds.size()-1;\\n            ds[size] = \\'.\\';\\n\\t\\t\\t\\n\\t\\t\\t// add \" . \" at the end of the ds and update pdot i.e position of dot.\\n\\t\\t\\t// dcount is to track how many dot have been inserted.\\n            solve(s,ds,ans,i,size+1,++dcount);\\n        }\\n\\n        \\n        \\n    }\\n\\t\\n\\t// code starts from here\\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string ds;  \\n        vector<string>ans;  // if ds is a possible answer it will be inserted here.\\n        \\n        solve(s,ds,ans,0,0,0);\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "# Upvote Please!    \\n\\t// Function to check     \\n\\tint check(string &ds, int pdot){\\n\\n        string sub = string(ds.begin() + pdot,ds.end());\\n        \\n        if(sub[0] == \\'0\\' && sub.size()>1) return 0;\\n\\n        int no = stoi(sub);\\n        \\n        if(no>255) return 0;\\n        \\n        return 1;\\n    }\\n    \\n\\t// recursive function that does all the work\\n    void solve(string &s, string ds, vector<string>&ans,int i,int pdot,int dcount){\\n        \\n\\t\\t// if every thing setisfy push the ds in the answer\\n        if(i == s.size()){\\n            if(check(ds,pdot) && dcount == 3) ans.push_back(ds);\\n            return ;\\n        }\\n        \\n\\t\\t// push the string ith element in the ds.\\n        ds.push_back(s[i]); \\n        \\n\\t\\t// now check if it was a right decision pushing the element in the ds\\n\\t\\t// -> If the decision was right then lets move to the next element of the string without adding \" . \" in the ds.\\n        if(check(ds,pdot)) solve(s,ds,ans,i+1,pdot,dcount);\\n        \\n\\t\\t\\n\\t\\t// lets add \" . \" in the ds.\\n\\t\\t// min there should be 1 element to add a \" . \" \\n\\t\\t// also not more that 3 dot should be there so 2 already present and one inside the block.\\n        if(ds.size() - pdot >1 && dcount <=2)\\n        {\\n            int size = ds.size()-1;\\n            ds[size] = \\'.\\';\\n\\t\\t\\t\\n\\t\\t\\t// add \" . \" at the end of the ds and update pdot i.e position of dot.\\n\\t\\t\\t// dcount is to track how many dot have been inserted.\\n            solve(s,ds,ans,i,size+1,++dcount);\\n        }\\n\\n        \\n        \\n    }\\n\\t\\n\\t// code starts from here\\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string ds;  \\n        vector<string>ans;  // if ds is a possible answer it will be inserted here.\\n        \\n        solve(s,ds,ans,0,0,0);\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3079520,
                "title": "python-just-dfs-and-backtracking-explained",
                "content": "This is a common DFS and backtracking problem. \\n\\nWe just need to take care of special requirements:\\n(1) the total number of fields is 4;\\n(2) no leading \\'0\\' for a number if it is not \\'0\\'\\n\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # dfs and backtracking\\n        self.s = s\\n        self.len_s = len(s)\\n        self.ans = []\\n\\n        self.dfs(0, [])\\n\\n        return self.ans\\n\\n    def dfs(self, index, partition):\\n        if index == self.len_s:\\n            # we reached the end of the string\\n            if len(partition) == 4:\\n                self.ans.append(\".\".join(partition))\\n            return\\n        \\n        if index < self.len_s and len(partition) == 4:\\n            # we haven\\'t used all the characters to build 4 address fields\\n            return\\n\\n        if self.s[index] == \\'0\\':\\n            partition.append(\\'0\\')\\n            self.dfs(index + 1, partition)\\n            partition.pop()\\n        else:\\n            for i in range(index + 1, self.len_s + 1):\\n                if 0 <= int(self.s[index: i]) <= 255:\\n                    partition.append(self.s[index: i])\\n                    self.dfs(i, partition)\\n                    partition.pop()\\n                else:\\n                    # no need to check further as the value is not in the range of 0 ~ 255\\n                    break\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        # dfs and backtracking\\n        self.s = s\\n        self.len_s = len(s)\\n        self.ans = []\\n\\n        self.dfs(0, [])\\n\\n        return self.ans\\n\\n    def dfs(self, index, partition):\\n        if index == self.len_s:\\n            # we reached the end of the string\\n            if len(partition) == 4:\\n                self.ans.append(\".\".join(partition))\\n            return\\n        \\n        if index < self.len_s and len(partition) == 4:\\n            # we haven\\'t used all the characters to build 4 address fields\\n            return\\n\\n        if self.s[index] == \\'0\\':\\n            partition.append(\\'0\\')\\n            self.dfs(index + 1, partition)\\n            partition.pop()\\n        else:\\n            for i in range(index + 1, self.len_s + 1):\\n                if 0 <= int(self.s[index: i]) <= 255:\\n                    partition.append(self.s[index: i])\\n                    self.dfs(i, partition)\\n                    partition.pop()\\n                else:\\n                    # no need to check further as the value is not in the range of 0 ~ 255\\n                    break\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079362,
                "title": "easy-to-understand-backtracking",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/backtracking/RestoreIpAddresses.kt",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3079289,
                "title": "python3-recursion",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        S = len(s)\\n        ans = set()\\n        \\n        def rec(idx, arr):\\n            if idx == len(s):\\n                if len(arr) == 4: \\n                    ans.add(\".\".join(arr))\\n                return\\n            \\n            if s[idx] == \"0\":\\n                rec(idx+1, arr+[\"0\"])\\n                return\\n            \\n            for i in range(idx, S):\\n                if int(s[idx:i+1]) < 256:\\n                    rec(i+1, arr+[s[idx:i+1]])\\n                else:\\n                    break\\n        rec(0, [])\\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        S = len(s)\\n        ans = set()\\n        \\n        def rec(idx, arr):\\n            if idx == len(s):\\n                if len(arr) == 4: \\n                    ans.add(\".\".join(arr))\\n                return\\n            \\n            if s[idx] == \"0\":\\n                rec(idx+1, arr+[\"0\"])\\n                return\\n            \\n            for i in range(idx, S):\\n                if int(s[idx:i+1]) < 256:\\n                    rec(i+1, arr+[s[idx:i+1]])\\n                else:\\n                    break\\n        rec(0, [])\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 3079241,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidNumber(string s){\\n        return stoi(s)>=0 and stoi(s)<=255 and to_string(stoi(s))==s;\\n    }\\n    bool isValidIPAddress(string s){\\n        int n=s.size();\\n        s.push_back(\\'.\\');\\n        int i=0;\\n        while(i<=n){\\n            string temp;\\n            while(s[i]!=\\'.\\'){\\n                temp.push_back(s[i++]);\\n            }\\n            i++;\\n            if(temp.size()>3 or !isValidNumber(temp)){\\n                return false;\\n            }\\n        }\\n        s.pop_back();\\n        return true;\\n    }\\n    vector<string> ans;\\n    void solve(int idx,int dot,string& ds,string& s){\\n        int n=s.size();\\n        if(idx==n){\\n            if(isValidIPAddress(ds) and dot==0){\\n                ans.push_back(ds);\\n            }\\n            return ;\\n        }\\n        ds.push_back(s[idx]);\\n        if(dot>=1 and ds.back()!=\\'.\\' and idx!=n-1){\\n            ds.push_back(\\'.\\');\\n            solve(idx+1,dot-1,ds,s);\\n            ds.pop_back();\\n        }\\n        solve(idx+1,dot,ds,s);\\n        ds.pop_back();\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        string ds=\"\";\\n        solve(0,3,ds,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidNumber(string s){\\n        return stoi(s)>=0 and stoi(s)<=255 and to_string(stoi(s))==s;\\n    }\\n    bool isValidIPAddress(string s){\\n        int n=s.size();\\n        s.push_back(\\'.\\');\\n        int i=0;\\n        while(i<=n){\\n            string temp;\\n            while(s[i]!=\\'.\\'){\\n                temp.push_back(s[i++]);\\n            }\\n            i++;\\n            if(temp.size()>3 or !isValidNumber(temp)){\\n                return false;\\n            }\\n        }\\n        s.pop_back();\\n        return true;\\n    }\\n    vector<string> ans;\\n    void solve(int idx,int dot,string& ds,string& s){\\n        int n=s.size();\\n        if(idx==n){\\n            if(isValidIPAddress(ds) and dot==0){\\n                ans.push_back(ds);\\n            }\\n            return ;\\n        }\\n        ds.push_back(s[idx]);\\n        if(dot>=1 and ds.back()!=\\'.\\' and idx!=n-1){\\n            ds.push_back(\\'.\\');\\n            solve(idx+1,dot-1,ds,s);\\n            ds.pop_back();\\n        }\\n        solve(idx+1,dot,ds,s);\\n        ds.pop_back();\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        string ds=\"\";\\n        solve(0,3,ds,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079180,
                "title": "c-backtraking-video-solution",
                "content": "# Intuition & Approach\\nhttps://youtu.be/PFb5zPn0vvY\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<string> validAddresses;\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        n = s.size();\\n        solve(0, 0, \"\", s);\\n        return validAddresses;\\n    }\\n\\n    void solve(int idx, int numOfIntegers, string curAddress, string &s) {\\n        if (numOfIntegers > 4)\\n            return;\\n        \\n        if (numOfIntegers == 4 && idx == n) {\\n            curAddress.pop_back();\\n            validAddresses.push_back(curAddress);\\n            return;\\n        }\\n\\n        for (int i = 1; i <= 3 && idx + i <= n; ++i) {\\n            string curInteger = s.substr(idx, i);\\n            \\n            if (curInteger[0] == \\'0\\' && i != 1)\\n                break;\\n            \\n            if (stoi(curInteger) <= 255)\\n                solve(idx + i, numOfIntegers + 1, curAddress + curInteger + \".\", s);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<string> validAddresses;\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        n = s.size();\\n        solve(0, 0, \"\", s);\\n        return validAddresses;\\n    }\\n\\n    void solve(int idx, int numOfIntegers, string curAddress, string &s) {\\n        if (numOfIntegers > 4)\\n            return;\\n        \\n        if (numOfIntegers == 4 && idx == n) {\\n            curAddress.pop_back();\\n            validAddresses.push_back(curAddress);\\n            return;\\n        }\\n\\n        for (int i = 1; i <= 3 && idx + i <= n; ++i) {\\n            string curInteger = s.substr(idx, i);\\n            \\n            if (curInteger[0] == \\'0\\' && i != 1)\\n                break;\\n            \\n            if (stoi(curInteger) <= 255)\\n                solve(idx + i, numOfIntegers + 1, curAddress + curInteger + \".\", s);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079173,
                "title": "clean-and-clear-the-interview-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking problem where we try to place a dot in every possible position and then check if it is valid\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n spots to choose the placement of the first dot\\n- n - 1 spots to choose placement of second dot\\n- n - 2 for third\\n- n - 3 for fourth\\nTotal = n * (n - 1) * (n - 2) * (n - 3) = $$O(n^2)$$\\n- Space complexity: $$O(n^4)$$ \\nIn the worst case we need to store every possible permutation of dots\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def isValid(sequence):\\n            if len(sequence) < 7: return False\\n            values = sequence.split(\".\")\\n            if len(values) != 4: return False\\n            for val in values:\\n                if int(val) > 255 or (len(val) >= 2 and val[0] == \\'0\\'): return False\\n            return True\\n        res = []\\n        def backtrack(i, count, sequence):\\n            # check valid:\\n            if i == len(s):\\n                if sequence[-1] != \".\" and isValid(sequence):\\n                    res.append(sequence)\\n                return\\n            sequence += s[i]\\n            # add dot\\n            sequence += \".\"\\n            backtrack(i + 1, count + 1, sequence)\\n            # remove dot\\n            sequence = sequence[:-1]\\n            backtrack(i + 1, count, sequence)\\n        backtrack(0, 0, \"\")\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        def isValid(sequence):\\n            if len(sequence) < 7: return False\\n            values = sequence.split(\".\")\\n            if len(values) != 4: return False\\n            for val in values:\\n                if int(val) > 255 or (len(val) >= 2 and val[0] == \\'0\\'): return False\\n            return True\\n        res = []\\n        def backtrack(i, count, sequence):\\n            # check valid:\\n            if i == len(s):\\n                if sequence[-1] != \".\" and isValid(sequence):\\n                    res.append(sequence)\\n                return\\n            sequence += s[i]\\n            # add dot\\n            sequence += \".\"\\n            backtrack(i + 1, count + 1, sequence)\\n            # remove dot\\n            sequence = sequence[:-1]\\n            backtrack(i + 1, count, sequence)\\n        backtrack(0, 0, \"\")\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079164,
                "title": "typescript-dfs-backtracking",
                "content": "# Intuition\\nUse DFS for backtracking to generate all possible IP addresses\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n    $$O(3^n)$$ \\n\\n- Space complexity:\\n$$O(d)$$\\n> d auxiliary  call stack space \\n\\n# Code\\n```\\nfunction restoreIpAddresses(s: string): string[] {\\n    let result:string[] = [];\\n    const DFS  = (ip:string,index:number,octet:number) => {\\n        if(index >= s.length){\\n            return;\\n        }\\n        // last octet check\\n        if(octet == 3){\\n            //check if last digit is valid\\n            if(s.substring(index, index+1) != \"0\" || index+1 == s.length){\\n                if(Number(s.substring(index)) < 256){\\n                    ip += \\'.\\'\\n                    ip += s.substring(index);\\n                    result.push(ip)\\n                }\\n            }\\n            return\\n        }\\n        for(let i = 1; i <= 3 && index+i < s.length; i++){\\n            if(Number(s.substring(index, index+i)) < 256){\\n                DFS(ip + \\'.\\'+ s.substring(index, index+i),index+i, octet + 1);\\n            }\\n            //check for leading zero\\n            if(s.substring(index, index+1) == \"0\"){\\n                break;\\n            }\\n        }\\n    }\\n    for(let i = 1; i <= 3 && i < s.length ; i++){\\n        if(Number(s.substring(0, i)) < 256){\\n            DFS(s.substring(0, i), i, 1);\\n        }\\n        //check for leading zero\\n        if(s[0] == \"0\"){\\n                break;\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Backtracking"
                ],
                "code": "```\\nfunction restoreIpAddresses(s: string): string[] {\\n    let result:string[] = [];\\n    const DFS  = (ip:string,index:number,octet:number) => {\\n        if(index >= s.length){\\n            return;\\n        }\\n        // last octet check\\n        if(octet == 3){\\n            //check if last digit is valid\\n            if(s.substring(index, index+1) != \"0\" || index+1 == s.length){\\n                if(Number(s.substring(index)) < 256){\\n                    ip += \\'.\\'\\n                    ip += s.substring(index);\\n                    result.push(ip)\\n                }\\n            }\\n            return\\n        }\\n        for(let i = 1; i <= 3 && index+i < s.length; i++){\\n            if(Number(s.substring(index, index+i)) < 256){\\n                DFS(ip + \\'.\\'+ s.substring(index, index+i),index+i, octet + 1);\\n            }\\n            //check for leading zero\\n            if(s.substring(index, index+1) == \"0\"){\\n                break;\\n            }\\n        }\\n    }\\n    for(let i = 1; i <= 3 && i < s.length ; i++){\\n        if(Number(s.substring(0, i)) < 256){\\n            DFS(s.substring(0, i), i, 1);\\n        }\\n        //check for leading zero\\n        if(s[0] == \"0\"){\\n                break;\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079140,
                "title": "beats-100-c-java-using-dfs-backtracking",
                "content": "> ## ***UPVOTE if U find it useful***\\n\\n# using backtracking\\n## **complexity \\n  Time complexity : O(2^n)\\n  Space complexity: O(n)**\\n```java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# using DFS + Backtracking Beats 100%\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```\\n```java []\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    void backtrack(String s, String path, int index, int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            ans.add(path.substring(0,path.length()-1));\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            String num = s.substring(index, index + i);\\n            if (num.charAt(0) == \\'0\\' && i != 1) break;\\n            else if (Integer.parseInt(num) <= 255) {\\n                backtrack(s, path + s.substring(index, index + i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    public List<String> restoreIpAddresses(String s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    } \\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void backtrack(string& s, string path, int index,  int count) {\\n        if (count > 4) return;\\n        if (count == 4 && index >= s.length()) {\\n            path.pop_back();\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) {\\n            string num = s.substr(index, i);\\n            if (num[0] == \\'0\\' && i != 1) break;\\n            else if (stol(num) <= 255) {\\n                backtrack(s, path + s.substr(index, i) + \".\", index + i,count + 1);\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        backtrack(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string s,vector<string> &v,int index){\\n        int m=v.size(),n=s.size();\\n        //if number of ip addresses in the vector is 4 and whole string is traversed\\n        if(index==n and m==4){\\n            ans.push_back(v[0]+\\'.\\'+v[1]+\\'.\\'+v[2]+\\'.\\'+v[3]);\\n            return;\\n        }\\n        \\n        // if either out of index or number of ip addresses is greater than 4 just return\\n        if(index>n or m>4){\\n            return;\\n        }\\n        \\n        // looping for different length of ip address from the current index\\n        for(int i=0;i<3;i++){\\n            // if it is possible to have ip address of i+1 length\\n            if(index+i<=n-1){\\n                string str=s.substr(index,i+1);\\n                // if current ip a valid one \\n                if((i==0 and str>=\"0\" and str<=\"9\") or (i==1 and str>=\"10\" and str<=\"99\") or (i==2 and str>=\"100\" and str<=\"255\")){\\n                    v.push_back(str);\\n                    solve(s,v,index+i+1);\\n                    v.pop_back();   // backtracking\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> v;\\n        solve(s,v,0);\\n        return ans;\\n    }\\n};\\n```\n```java []\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079082,
                "title": "daily-leetcoding-challenge-january-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/restore-ip-addresses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/restore-ip-addresses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3065416,
                "title": "javascript-clean-backtracking-solution-with-explanation",
                "content": "# Intuition\\nThis is similar to [Word Break](https://leetcode.com/problems/word-break/) except instead of checking if a string segment exists in a dictionary, we use a helper function to validate it.\\n\\n# Approach\\n1. In the main backtracking loop, build up the IP address segment.\\n2. If the segment is invalid, don\\'t use it.  Valid segment in this context means\\na. The segment should be a value <= 255.\\nb. The segment cannot be left zero padded if its length > 1.\\nc. If we already have 3 segments in our IP address candidate, the current segment length has to be equal to the remaining length of the input string.  Remember, you have to use all the digits in the input string to form the IP address.\\n3. Otherwise,  backtrack.\\n\\n# Complexity\\n- Time complexity: -\\n\\n- Space complexity: -\\n```\\n# Code\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    solve(s, 0, [], result);\\n    return result;\\n};\\n\\nconst solve = (s, start, candidate, result) => {\\n    if (candidate.length === 4) {\\n        result.push(candidate.join(\\'.\\'));\\n        return;\\n    }\\n\\n    let segment = \\'\\';\\n    for (let i = start; i < s.length; i++) {\\n        segment += s[i];\\n        if (!isValidSegment(s, start, segment, candidate)) {\\n            continue;\\n        }\\n        candidate.push(segment);\\n        solve(s, i + 1, candidate, result);\\n        candidate.pop();\\n    }\\n}\\n\\nconst isValidSegment = (s, start, segment, candidate) => {\\n    if (Number(segment) > 255) {\\n        return false;\\n    }\\n\\n    if (segment.length > 1 && segment[0] === \\'0\\') {\\n        return false;\\n    }\\n\\n    const remainingLength = s.length - start;\\n    if (candidate.length === 3 && segment.length < remainingLength) {\\n        return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n# Code\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar restoreIpAddresses = function(s) {\\n    const result = [];\\n    solve(s, 0, [], result);\\n    return result;\\n};\\n\\nconst solve = (s, start, candidate, result) => {\\n    if (candidate.length === 4) {\\n        result.push(candidate.join(\\'.\\'));\\n        return;\\n    }\\n\\n    let segment = \\'\\';\\n    for (let i = start; i < s.length; i++) {\\n        segment += s[i];\\n        if (!isValidSegment(s, start, segment, candidate)) {\\n            continue;\\n        }\\n        candidate.push(segment);\\n        solve(s, i + 1, candidate, result);\\n        candidate.pop();\\n    }\\n}\\n\\nconst isValidSegment = (s, start, segment, candidate) => {\\n    if (Number(segment) > 255) {\\n        return false;\\n    }\\n\\n    if (segment.length > 1 && segment[0] === \\'0\\') {\\n        return false;\\n    }\\n\\n    const remainingLength = s.length - start;\\n    if (candidate.length === 3 && segment.length < remainingLength) {\\n        return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2673083,
                "title": "c-100-faster-very-simple-3-cases-explanation-recursion",
                "content": "```\\nclass Solution {\\n    vector<string> ans;\\npublic:\\n    void restoreDFS(string s, string temp, int dot, int index) {\\n        if (index == s.size() and dot == 4) {\\n            temp.pop_back();\\n            ans.push_back(move(temp));\\n            return;\\n        }\\n        if (index >= s.size() or dot >= 4) {\\n            return;\\n        }\\n\\t\\t\\n        // case 1: For first dot it doesnot matter what number it is\\n        restoreDFS(s, temp + s[index] + \\'.\\', dot + 1, index + 1);\\n\\t\\t\\n\\t\\t// case 2: For 2 numbers the first char cannot be a zero\\n        if (s[index] != \\'0\\') {\\n            restoreDFS(s, temp + s.substr(index, 2) + \\'.\\', dot + 1, index + 2);\\n        }\\n\\t\\t\\n\\t\\t// case 3: For 3 numbers whole number cannot be larger than 255 with no leading zero\\n        if (s[index] != \\'0\\' and (stoi(s.substr(index, 3)) < 256)) {\\n            restoreDFS(s, temp + s.substr(index, 3) + \\'.\\', dot + 1, index + 3);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12 or s.size() < 4) return ans;\\n        restoreDFS(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\npublic:\\n    void restoreDFS(string s, string temp, int dot, int index) {\\n        if (index == s.size() and dot == 4) {\\n            temp.pop_back();\\n            ans.push_back(move(temp));\\n            return;\\n        }\\n        if (index >= s.size() or dot >= 4) {\\n            return;\\n        }\\n\\t\\t\\n        // case 1: For first dot it doesnot matter what number it is\\n        restoreDFS(s, temp + s[index] + \\'.\\', dot + 1, index + 1);\\n\\t\\t\\n\\t\\t// case 2: For 2 numbers the first char cannot be a zero\\n        if (s[index] != \\'0\\') {\\n            restoreDFS(s, temp + s.substr(index, 2) + \\'.\\', dot + 1, index + 2);\\n        }\\n\\t\\t\\n\\t\\t// case 3: For 3 numbers whole number cannot be larger than 255 with no leading zero\\n        if (s[index] != \\'0\\' and (stoi(s.substr(index, 3)) < 256)) {\\n            restoreDFS(s, temp + s.substr(index, 3) + \\'.\\', dot + 1, index + 3);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        if (s.size() > 12 or s.size() < 4) return ans;\\n        restoreDFS(s, \"\", 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384635,
                "title": "c-backtracking-recursion",
                "content": "class Solution {\\npublic:\\n     ```\\n```\\n   void func(vector<string>& ans, string temp, int start,string s,int c)\\n        {\\n                if(c==4)\\n                {\\n                        if(start==s.size())\\n                        {\\n                                temp.pop_back();\\n                                ans.push_back(temp);\\n                        }\\n                                return;\\n                }\\n                int num=0;\\n                for(int i=start;i<s.size();i++)\\n                {\\n                        \\n                        num=num*10+(s[i]-\\'0\\');\\n                        if(num>255)\\n                        {\\n                                break;\\n                        }\\n                        if(s[i]==\\'0\\')\\n                        {\\n                                temp=temp+\"0\"+\".\";\\n                                func(ans,temp,i+1,s,c+1);\\n                                \\n//if digit is zero and the number after previous .(consider \"0.0\") is also zero then there wont be any further placing of . in this current loop so we break the for loop\\n                                if(num==0)\\n                                break;\\n                                \\n//else the number was not zero so we can make use of normal backtracking\\n                                else\\n                                        temp.pop_back();\\n                        }\\n                        \\n//Normal BackTrack for any other digit\\n                        else {\\n                                temp=temp+s[i]+\".\";\\n                                 func(ans,temp,i+1,s,c+1);\\n                                temp.pop_back();\\n                        }\\n                }\\n        }\\n    vector<string> restoreIpAddresses(string s)\\n    {\\n        vector<string> ans;\\n            string temp=\"\";\\n            int c=0;\\n            func(ans,temp,0,s,c);\\n            return ans;\\n    }\\n```\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383310,
                "title": "simple-python-complex-time-complexity-code-faster-than-100",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        def isValid(st):\\n            if(len(st)!=len(str(int(st)))):\\n                return False\\n            st = int(st)\\n            if(st>255 or st<0):\\n                return False\\n            return True\\n        \\n        validIps = []\\n        for i in range(1,4):\\n            s1 = s[:i]\\n            if(not isValid(s1)):\\n                continue\\n            for j in range(i+1, min(len(s), i+4)):\\n                s2 = s[i:j]\\n                if(not isValid(s2)):\\n                    continue\\n                for k in range(j+1,min(len(s), j+4)):\\n                    s3 = s[j:k]\\n                    if(not isValid(s3)):\\n                        continue\\n                    s4 = s[k:]\\n                    if(not isValid(s4)):\\n                        continue\\n                    currentIp = s1+\".\"+s2+\".\"+s3+\".\"+s4\\n                    validIps.append(currentIp)\\n        return validIps\\n",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        def isValid(st):\\n            if(len(st)!=len(str(int(st)))):\\n                return False\\n            st = int(st)\\n            if(st>255 or st<0):\\n                return False\\n            return True\\n        \\n        validIps = []\\n        for i in range(1,4):\\n            s1 = s[:i]\\n            if(not isValid(s1)):\\n                continue\\n            for j in range(i+1, min(len(s), i+4)):\\n                s2 = s[i:j]\\n                if(not isValid(s2)):\\n                    continue\\n                for k in range(j+1,min(len(s), j+4)):\\n                    s3 = s[j:k]\\n                    if(not isValid(s3)):\\n                        continue\\n                    s4 = s[k:]\\n                    if(not isValid(s4)):\\n                        continue\\n                    currentIp = s1+\".\"+s2+\".\"+s3+\".\"+s4\\n                    validIps.append(currentIp)\\n        return validIps\\n",
                "codeTag": "Java"
            },
            {
                "id": 2336781,
                "title": "c-faster-then-100-69-less-memory-backtracking-simple",
                "content": "```\\nvoid help(int ind, string &t, vector<string> &ans,int &ct,int prev,string s)\\n    {\\n        int i,strval=0,j;\\n        if(ct==3 )\\n        {\\n            strval=0;\\n            for(i=ind;i<s.size();i++)\\n            {\\n                strval = strval*10 + s[i]-\\'0\\';\\n            }\\n            if(s[ind]==\\'0\\' && ind!= s.size()-1)\\n            {\\n                return;\\n            }\\n            if(strval<=255 )\\n            {\\n                for(i=ind;i<s.size();i++)\\n                {\\n                   t.push_back(s[i]);\\n                }\\n                ans.push_back(t);\\n                for(i=ind;i<s.size();i++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            \\n            return;\\n        }\\n        strval=0;\\n        for(i=ind;i<s.size()-1;i++)\\n        {\\n            strval= strval*10 + s[i] - 48;\\n            \\n            if(strval==0)\\n            {\\n                t.push_back(\\'0\\');\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                t.pop_back();\\n                t.pop_back();\\n                break;\\n            }\\n            if(strval>0 &&  strval<=255)\\n            {\\n                for(j=ind;j<=i;j++)\\n                {\\n                    t.push_back(s[j]);\\n                }\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                for(j=0;j<i-ind+2;j++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            else{\\n                return;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string t;\\n        int strval,ind=0,ct=0,prev=0;\\n        vector<string> ans;\\n        if(s.size()>12)\\n        {\\n            return ans;\\n        }\\n        else{\\n            help(ind,t,ans,ct,prev,s);\\n            return ans;\\n        }\\n        \\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nvoid help(int ind, string &t, vector<string> &ans,int &ct,int prev,string s)\\n    {\\n        int i,strval=0,j;\\n        if(ct==3 )\\n        {\\n            strval=0;\\n            for(i=ind;i<s.size();i++)\\n            {\\n                strval = strval*10 + s[i]-\\'0\\';\\n            }\\n            if(s[ind]==\\'0\\' && ind!= s.size()-1)\\n            {\\n                return;\\n            }\\n            if(strval<=255 )\\n            {\\n                for(i=ind;i<s.size();i++)\\n                {\\n                   t.push_back(s[i]);\\n                }\\n                ans.push_back(t);\\n                for(i=ind;i<s.size();i++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            \\n            return;\\n        }\\n        strval=0;\\n        for(i=ind;i<s.size()-1;i++)\\n        {\\n            strval= strval*10 + s[i] - 48;\\n            \\n            if(strval==0)\\n            {\\n                t.push_back(\\'0\\');\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                t.pop_back();\\n                t.pop_back();\\n                break;\\n            }\\n            if(strval>0 &&  strval<=255)\\n            {\\n                for(j=ind;j<=i;j++)\\n                {\\n                    t.push_back(s[j]);\\n                }\\n                t.push_back(\\'.\\');\\n                ct++;\\n                help(i+1,t,ans,ct,i-ind+2,s);\\n                ct--;\\n                for(j=0;j<i-ind+2;j++)\\n                {\\n                    t.pop_back();\\n                }\\n            }\\n            else{\\n                return;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        \\n        string t;\\n        int strval,ind=0,ct=0,prev=0;\\n        vector<string> ans;\\n        if(s.size()>12)\\n        {\\n            return ans;\\n        }\\n        else{\\n            help(ind,t,ans,ct,prev,s);\\n            return ans;\\n        }\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2271339,
                "title": "best-working-java-solution-3-loops-only-beats-97",
                "content": "```\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ArrayList<String> genIp(String s) {\\n    ArrayList<String> result = new ArrayList<>();\\n    StringBuffer ip = new StringBuffer();\\n    for(int a=1; a<=3; a++){\\n        for(int b=1; b<=3; b++){\\n            for(int c=1; c<=3; c++){\\n                int d = s.length()-(a+b+c);\\n                if (d>=1 && d<=3) {\\n                    int A = Integer.parseInt(s.substring(0, a));\\n                    int B = Integer.parseInt(s.substring(a, a+b));\\n                    int C = Integer.parseInt(s.substring(a+b, a+b+c));\\n                    int D = Integer.parseInt(s.substring(a+b+c, a+b+c+d));\\n                    if(A<=255 && B<=255 && C<=255 && D<=255){\\n                        ip.append(A).append(\".\").append(B).append(\".\")\\n                          .append(C).append(\".\").append(D);\\n                        if (ip.length() == s.length() + 3) {\\n                           result.add(ip.toString()); \\n                        }\\n                        ip = new StringBuffer();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2222868,
                "title": "beginner-friendly-dfs-backtracking-solution-in-c",
                "content": "\\t\\t\\n\\t\\tvoid solve(string s, vector<string> &ans, string output, int dots){       \\n\\t\\t\\tif(dots == 0){  //4 Dots have been places. 3->2->1->0 , hence the base case                        \\n            \\n            if(s[0]==\\'0\\' and s.length()>1){  //check if the last substring doesnt start with 0\\n                return;\\n            }\\n            int num = stoll(s);\\n            if(num>=0 and num<= 255){   //check if the last substring is within limits (i.e 0 and 255)\\n                output += s;    \\n                ans.push_back(output);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){  //here we are trying all possible combi in which we can place dots\\n            string left = s.substr(0,i);\\n            if(left.length()<=0 or (left.length()>1 and left[0]==\\'0\\')){ //check for empty string and if the substr starts with 0\\n                continue;\\n            }\\n            string right = s.substr(i); //remaining string / right part of the string\\n            int num = stoll(left); \\n            if(num>=0 and num<=255){ //check if the substring is valid\\n                solve(right, ans, output + left + \".\", dots - 1);\\n            }\\n        }    \\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(s,ans,\"\",3);\\n        return ans;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\t\\t\\n\\t\\tvoid solve(string s, vector<string> &ans, string output, int dots){       \\n\\t\\t\\tif(dots == 0){  //4 Dots have been places. 3->2->1->0 , hence the base case                        \\n            \\n            if(s[0]==\\'0\\' and s.length()>1){  //check if the last substring doesnt start with 0\\n                return;\\n            }\\n            int num = stoll(s);\\n            if(num>=0 and num<= 255){   //check if the last substring is within limits (i.e 0 and 255)\\n                output += s;    \\n                ans.push_back(output);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){  //here we are trying all possible combi in which we can place dots\\n            string left = s.substr(0,i);\\n            if(left.length()<=0 or (left.length()>1 and left[0]==\\'0\\')){ //check for empty string and if the substr starts with 0\\n                continue;\\n            }\\n            string right = s.substr(i); //remaining string / right part of the string\\n            int num = stoll(left); \\n            if(num>=0 and num<=255){ //check if the substring is valid\\n                solve(right, ans, output + left + \".\", dots - 1);\\n            }\\n        }    \\n        \\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        solve(s,ans,\"\",3);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2207698,
                "title": "javascript-simple-efficient-solution",
                "content": "```\\nvar restoreIpAddresses = function (s) {\\n\\n\\tconst isValid = str => {\\n\\t\\tif (str === \\'0\\') return true;\\n\\t\\tif (str[0] === \\'0\\') return false;\\n\\t\\treturn parseInt(str) <= 255;\\n\\t}\\n\\n\\tlet rVal = [];\\n\\tfor (let i = 1; i < 4 && i < s.length - 2; i++) {\\n\\t\\tconst fir = s.substring(0, i);\\n\\t\\tif (!isValid(fir)) continue;\\n\\n\\t\\tfor (let j = i + 1; j < i + 4 && j < s.length - 1; j++) {\\n\\t\\t\\tconst sec = s.substring(i, j);\\n\\t\\t\\tif (!isValid(sec)) continue;\\n\\n\\t\\t\\tfor (let k = j + 1; k < j + 4 && k < s.length; k++) {\\n\\t\\t\\t\\tconst thir = s.substring(j, k);\\n\\t\\t\\t\\tif (!isValid(thir)) continue;\\n\\n\\t\\t\\t\\tconst forth = s.substring(k);\\n\\t\\t\\t\\tif (forth.length > 3 || !isValid(forth)) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\trVal.push([fir, sec, thir, forth].join(\\'.\\'))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn rVal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar restoreIpAddresses = function (s) {\\n\\n\\tconst isValid = str => {\\n\\t\\tif (str === \\'0\\') return true;\\n\\t\\tif (str[0] === \\'0\\') return false;\\n\\t\\treturn parseInt(str) <= 255;\\n\\t}\\n\\n\\tlet rVal = [];\\n\\tfor (let i = 1; i < 4 && i < s.length - 2; i++) {\\n\\t\\tconst fir = s.substring(0, i);\\n\\t\\tif (!isValid(fir)) continue;\\n\\n\\t\\tfor (let j = i + 1; j < i + 4 && j < s.length - 1; j++) {\\n\\t\\t\\tconst sec = s.substring(i, j);\\n\\t\\t\\tif (!isValid(sec)) continue;\\n\\n\\t\\t\\tfor (let k = j + 1; k < j + 4 && k < s.length; k++) {\\n\\t\\t\\t\\tconst thir = s.substring(j, k);\\n\\t\\t\\t\\tif (!isValid(thir)) continue;\\n\\n\\t\\t\\t\\tconst forth = s.substring(k);\\n\\t\\t\\t\\tif (forth.length > 3 || !isValid(forth)) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\trVal.push([fir, sec, thir, forth].join(\\'.\\'))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn rVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028226,
                "title": "recursion-easy-to-understand-c",
                "content": "**APPROACH:**\\n* We know that that given string can be formed into IP address by dividing it into either 3-bit or 2-bit or 1-bit without any leading zero in first two conditions.\\n* so we have option of dividing string into 3 ways : Make group of 3-3 characters **OR** make group of 2-2 characters **OR** make group of 1 character. With checking condition of **no leading zero** and value of bits is **between 0 and 255 inclusive.**\\n* If group of 3 bit is invalid to use either of false of leading zero condition as well as overflow of value range 2- bit character condition is then followed.\\n* with every **success call** i**ncrement part by 1** and **bits value by the length of character chosen.**\\n* when bits reaches the same length as string length it means all characters are taken and ans is printed after neglecting that last dot.\\n\\n\\n**CODE:**\\n\\n```\\n  int len=0;\\n    vector<string>res;\\n    \\n    bool valid(string s)\\n    {\\n        if(s.length()>1&&s[0]==\\'0\\')\\n        {\\n            return false;\\n        }\\n        int num=0;\\n        num=stoi(s);\\n        if(num>=0&&num<=255)\\n        {\\n            return true;\\n        }\\n        return false;\\n    \\n    }\\n    void helper(string s,string ans,int parts,int idx,int bits)\\n    {\\n         //IF ALL 4 PARTS ARE FORMED AND WHOLE STRING IS COVERED\\n         if(parts==4&&bits==len)\\n        {\\n             ans[ans.length()-1]=NULL;  //FOR REMOVING THAT LAST DOT\\n             res.push_back(ans);\\n             return ;\\n        }\\n        \\n        //IF IDX GETS LARGER THAN LENGTH\\n           if(idx>=len)\\n           {\\n               return ;\\n           }\\n\\n        \\n        //FOR FORMING 3 CHARACTER IP BIT\\n        \\n        if(idx+2<s.length()&&valid(s.substr(idx,3)))\\n        {\\n            helper(s,  ans+s.substr(idx,3)+\".\",  parts+1,  idx+3,  bits+3);\\n        }\\n        \\n        \\n        //FOR FORMING 2 CHARACTER IP BIT\\n        \\n         if(idx+1<s.length()&&valid(s.substr(idx,2)))\\n        {\\n            helper(s,  ans+s.substr(idx,2)+\".\",  parts+1,  idx+2,  bits+2);\\n        }\\n        \\n        \\n        //FOR FORMING 1 CHARACTER IP BIT\\n        \\n        if(idx<s.length()&&valid(s.substr(idx,1)))\\n        {\\n            helper(s, ans+s.substr(idx,1)+\".\",  parts+1,  idx+1,  bits+1);\\n        }\\n        \\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        len=s.length();\\n    //       string  ans  parts idx  bits\\n        helper( s ,  \"\" ,  0 ,  0 ,  0 );\\n        return res;\\n    }\\n\\t\\n\\t\\n\\t```\\n\\n\\n**Not the best solution Feel free to suggest changes to make it better.**\\nENJOYING LEARNING :)\\n\\n\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n  int len=0;\\n    vector<string>res;\\n    \\n    bool valid(string s)\\n    {\\n        if(s.length()>1&&s[0]==\\'0\\')\\n        {\\n            return false;\\n        }\\n        int num=0;\\n        num=stoi(s);\\n        if(num>=0&&num<=255)\\n        {\\n            return true;\\n        }\\n        return false;\\n    \\n    }\\n    void helper(string s,string ans,int parts,int idx,int bits)\\n    {\\n         //IF ALL 4 PARTS ARE FORMED AND WHOLE STRING IS COVERED\\n         if(parts==4&&bits==len)\\n        {\\n             ans[ans.length()-1]=NULL;  //FOR REMOVING THAT LAST DOT\\n             res.push_back(ans);\\n             return ;\\n        }\\n        \\n        //IF IDX GETS LARGER THAN LENGTH\\n           if(idx>=len)\\n           {\\n               return ;\\n           }\\n\\n        \\n        //FOR FORMING 3 CHARACTER IP BIT\\n        \\n        if(idx+2<s.length()&&valid(s.substr(idx,3)))\\n        {\\n            helper(s,  ans+s.substr(idx,3)+\".\",  parts+1,  idx+3,  bits+3);\\n        }\\n        \\n        \\n        //FOR FORMING 2 CHARACTER IP BIT\\n        \\n         if(idx+1<s.length()&&valid(s.substr(idx,2)))\\n        {\\n            helper(s,  ans+s.substr(idx,2)+\".\",  parts+1,  idx+2,  bits+2);\\n        }\\n        \\n        \\n        //FOR FORMING 1 CHARACTER IP BIT\\n        \\n        if(idx<s.length()&&valid(s.substr(idx,1)))\\n        {\\n            helper(s, ans+s.substr(idx,1)+\".\",  parts+1,  idx+1,  bits+1);\\n        }\\n        \\n        \\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n        len=s.length();\\n    //       string  ans  parts idx  bits\\n        helper( s ,  \"\" ,  0 ,  0 ,  0 );\\n        return res;\\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969572,
                "title": "java-code-with-easy-explaination",
                "content": "\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        //list to return and store ans\\n        List<String> ans = new ArrayList<>();\\n        \\n        //calling helper function\\n        //params(provided_string , ans_generated , dot_count , answer)\\n        solve(s , \"\" , 4, ans);\\n        return ans;\\n    }\\n    \\n    void solve(String str , String curr, int dotCount, List<String> ans){\\n        if(dotCount == 0 && str.length() == 0)\\n        {\\n            //add answer except the last \\'.\\' if we reach to end of string and dots are also exhausted \\n            ans.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n        \\n        //min_length as we can only take max of 3 nums in ip address\\n        //we check if we have the length of string more than 3 length so just skip the other char of string\\n        int minLength = Math.min(str.length() , 3);\\n        \\n        for(int i = 0; i < minLength; i++){\\n            String s = str.substring(0,i+1); // add the char to our ans one by one\\n            if(check(s)){ // check if we have the correct number within range\\n                solve(str.substring(i + 1) , curr+s+\\'.\\' , dotCount-1 , ans); // call recursive function by decresing dots count\\n            }\\n        }\\n    }\\n    \\n    boolean check(String str){\\n        //check for zero eg - \\'01\\' is not valid only \\'0.1.3\\' is accepted\\n        if(str.length() > 1 && str.charAt(0) == \\'0\\')\\n            return false;\\n        \\n        //check for range of number (0 - 255)\\n        if(Integer.parseInt(str) > 255)\\n            return false;\\n        \\n        //reached here indicates our string can be a valid answer\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        //list to return and store ans\\n        List<String> ans = new ArrayList<>();\\n        \\n        //calling helper function\\n        //params(provided_string , ans_generated , dot_count , answer)\\n        solve(s , \"\" , 4, ans);\\n        return ans;\\n    }\\n    \\n    void solve(String str , String curr, int dotCount, List<String> ans){\\n        if(dotCount == 0 && str.length() == 0)\\n        {\\n            //add answer except the last \\'.\\' if we reach to end of string and dots are also exhausted \\n            ans.add(curr.substring(0, curr.length() - 1));\\n            return;\\n        }\\n        \\n        //min_length as we can only take max of 3 nums in ip address\\n        //we check if we have the length of string more than 3 length so just skip the other char of string\\n        int minLength = Math.min(str.length() , 3);\\n        \\n        for(int i = 0; i < minLength; i++){\\n            String s = str.substring(0,i+1); // add the char to our ans one by one\\n            if(check(s)){ // check if we have the correct number within range\\n                solve(str.substring(i + 1) , curr+s+\\'.\\' , dotCount-1 , ans); // call recursive function by decresing dots count\\n            }\\n        }\\n    }\\n    \\n    boolean check(String str){\\n        //check for zero eg - \\'01\\' is not valid only \\'0.1.3\\' is accepted\\n        if(str.length() > 1 && str.charAt(0) == \\'0\\')\\n            return false;\\n        \\n        //check for range of number (0 - 255)\\n        if(Integer.parseInt(str) > 255)\\n            return false;\\n        \\n        //reached here indicates our string can be a valid answer\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874942,
                "title": "easy-java-backtracking-with-comments-beats-99-97",
                "content": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        List<String> curr = new ArrayList<>();\\n        findValid(s, curr, result);\\n        return result;\\n    }\\n    \\n    private void findValid(String s, List<String> curr, List<String> result) {\\n\\t\\t// Empty String can\\'t be valid\\n        if (s.equals(\"\")) {\\n            return;\\n        }\\n\\t\\t// If we already have three valid IP numbers, the remaining string passed into the method should constitute \\n\\t\\t// the 4th IP number. If it is valid, we add that set of 4 IP numbers to our valid IP address list\\n        if (curr.size() == 3) {\\n            if (checkValidNum(s)) {\\n                StringBuilder sb = new StringBuilder(curr.get(0));\\n                sb.append(\".\").append(curr.get(1)).append(\".\").append(curr.get(2)).append(\".\").append(s);\\n                result.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\t\\t// We can have IP address numbers of one, two, and three digits, so we try each of these options. \\n\\t\\t// For example, if we have the string 123456, we can pick:\\n\\t\\t// 1, and then find remaining valid IP numbers out of 23456, or\\n\\t\\t// 12, and then find remaining valid IP numbers out of 3456, or\\n\\t\\t// 123, and then find remaining valid IP numbers out of 456.\\n\\t\\t//\\n\\t\\t// The Math.min ensures we don\\'t try to take a IP number greater than our remaining\\n\\t\\t// IP string.\\n        for (int i = 1; i < Math.min(s.length(), 4); i++) {\\n            if (checkValidNum(s.substring(0, i))) {\\n                curr.add(s.substring(0, i));\\n                findValid(s.substring(i), curr, result);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n\\t// Checks if a string is a valid IP number\\n    private boolean checkValidNum(String s) {\\n        if (s.length() > 3 || (s.length() > 1 && s.charAt(0) == \\'0\\')) {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        if (num < 0 || num > 255) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nThe idea here is we take the start of the IP string, and try the three possible IP numbers. With each possibility, we remove the first IP number from the string, and then recurse with the new string. We use classic backtracking to explore all possible combinations of IP numbers to create an address.\\n\\nHope this helps, let me know if I missed anything.",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        List<String> curr = new ArrayList<>();\\n        findValid(s, curr, result);\\n        return result;\\n    }\\n    \\n    private void findValid(String s, List<String> curr, List<String> result) {\\n\\t\\t// Empty String can\\'t be valid\\n        if (s.equals(\"\")) {\\n            return;\\n        }\\n\\t\\t// If we already have three valid IP numbers, the remaining string passed into the method should constitute \\n\\t\\t// the 4th IP number. If it is valid, we add that set of 4 IP numbers to our valid IP address list\\n        if (curr.size() == 3) {\\n            if (checkValidNum(s)) {\\n                StringBuilder sb = new StringBuilder(curr.get(0));\\n                sb.append(\".\").append(curr.get(1)).append(\".\").append(curr.get(2)).append(\".\").append(s);\\n                result.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\t\\t// We can have IP address numbers of one, two, and three digits, so we try each of these options. \\n\\t\\t// For example, if we have the string 123456, we can pick:\\n\\t\\t// 1, and then find remaining valid IP numbers out of 23456, or\\n\\t\\t// 12, and then find remaining valid IP numbers out of 3456, or\\n\\t\\t// 123, and then find remaining valid IP numbers out of 456.\\n\\t\\t//\\n\\t\\t// The Math.min ensures we don\\'t try to take a IP number greater than our remaining\\n\\t\\t// IP string.\\n        for (int i = 1; i < Math.min(s.length(), 4); i++) {\\n            if (checkValidNum(s.substring(0, i))) {\\n                curr.add(s.substring(0, i));\\n                findValid(s.substring(i), curr, result);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n\\t// Checks if a string is a valid IP number\\n    private boolean checkValidNum(String s) {\\n        if (s.length() > 3 || (s.length() > 1 && s.charAt(0) == \\'0\\')) {\\n            return false;\\n        }\\n        int num = Integer.parseInt(s);\\n        if (num < 0 || num > 255) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872914,
                "title": "c-backtrcking-easy-to-understand-clean-code",
                "content": "# Approach 1\\nBy passing string as parameter\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void restore(string &s,int n,int i,int dots,string t)\\n    {\\n        if(i==n)\\n        {\\n            if(dots==4)\\n            {\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            \\n            return;\\n        }\\n\\n        if(dots>3)\\n        return;\\n        \\n        if(s[i]==\\'0\\')\\n        {\\n            restore(s,n,i+1,dots+1,t+s[i]+\".\");\\n            return;\\n        }\\n        \\n        string x=\"\";\\n        for(int j=0;j<3 && i+j<n;j++)\\n        {\\n            x+=s[i+j];\\n\\n            if(stoi(x)>255)\\n            return;\\n\\n            restore(s,n,i+j+1,dots+1,t+x+\".\");\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        restore(s,s.length(),0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing common string \\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string t;\\n    \\n    void restore(int in,string s,int n,int dots)\\n    {\\n        if(in==n)\\n        {\\n            t.pop_back();\\n            \\n            if(dots==4)\\n                ans.push_back(t);\\n            \\n            return;\\n        }\\n        \\n        if(dots>3)\\n            return;\\n        \\n        string num=\"\";\\n        string x=t;\\n        \\n        if(s[in]==\\'0\\')\\n        {\\n            t+=s[in];\\n            t+=\\'.\\';\\n            restore(in+1,s,n,dots+1);\\n            t=x;\\n            return;\\n        }\\n        \\n        int i;        \\n        for(i=in;i<n && i<in+3;i++)\\n        {\\n            num+=s[i];\\n            \\n            if(stoi(num)>255)\\n            return;\\n            \\n            t+=num;\\n            t+=\\'.\\';\\n            restore(i+1,s,n,dots+1);\\n            t=x;\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.length();\\n        if(n>12)\\n            return ans;\\n        \\n        restore(0,s,n,0);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do share your suggestions & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    void restore(string &s,int n,int i,int dots,string t)\\n    {\\n        if(i==n)\\n        {\\n            if(dots==4)\\n            {\\n                t.pop_back();\\n                ans.push_back(t);\\n            }\\n            \\n            return;\\n        }\\n\\n        if(dots>3)\\n        return;\\n        \\n        if(s[i]==\\'0\\')\\n        {\\n            restore(s,n,i+1,dots+1,t+s[i]+\".\");\\n            return;\\n        }\\n        \\n        string x=\"\";\\n        for(int j=0;j<3 && i+j<n;j++)\\n        {\\n            x+=s[i+j];\\n\\n            if(stoi(x)>255)\\n            return;\\n\\n            restore(s,n,i+j+1,dots+1,t+x+\".\");\\n        }\\n    }\\n\\n    vector<string> restoreIpAddresses(string s) {\\n        restore(s,s.length(),0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string t;\\n    \\n    void restore(int in,string s,int n,int dots)\\n    {\\n        if(in==n)\\n        {\\n            t.pop_back();\\n            \\n            if(dots==4)\\n                ans.push_back(t);\\n            \\n            return;\\n        }\\n        \\n        if(dots>3)\\n            return;\\n        \\n        string num=\"\";\\n        string x=t;\\n        \\n        if(s[in]==\\'0\\')\\n        {\\n            t+=s[in];\\n            t+=\\'.\\';\\n            restore(in+1,s,n,dots+1);\\n            t=x;\\n            return;\\n        }\\n        \\n        int i;        \\n        for(i=in;i<n && i<in+3;i++)\\n        {\\n            num+=s[i];\\n            \\n            if(stoi(num)>255)\\n            return;\\n            \\n            t+=num;\\n            t+=\\'.\\';\\n            restore(i+1,s,n,dots+1);\\n            t=x;\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        int n=s.length();\\n        if(n>12)\\n            return ans;\\n        \\n        restore(0,s,n,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868182,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def check(self,ip):\\n        temp=ip.split(\\'.\\')\\n        # print(temp)\\n        for i in temp:\\n            if(len(i)!=1):\\n                if(len(i)==2):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                elif(len(i)==3):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                    elif(int(i)>255):\\n                        # print(i)\\n                        return False\\n                else:\\n                    return False\\n        return True\\n    \\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n\\t#length should be less than 12 because 255.255.255.255 is the largest combination possible\\n        if(len(s)>12):\\n            return[]\\n        else:\\n            i=0\\n            ans=[]\\n            while(i<=3 and i<len(s)):\\n                j=1\\n                while(j<=3 and i+j<len(s)):\\n                    k=1\\n                    while(k<=3 and i+j+k<len(s)):\\n                        temp=s[:i+1]+\\'.\\'+s[i+1:i+j+1]+\\'.\\'+s[i+j+1:i+j+k+1]+\\'.\\'+s[i+j+k+1:]\\n                        # print(temp)\\n                        if(self.check(temp)==True):\\n                            ans.append(temp)\\n                        k+=1\\n                    j+=1\\n                i+=1\\n            return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def check(self,ip):\\n        temp=ip.split(\\'.\\')\\n        # print(temp)\\n        for i in temp:\\n            if(len(i)!=1):\\n                if(len(i)==2):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                elif(len(i)==3):\\n                    if(i[0]==\\'0\\'):\\n                        return False\\n                    elif(int(i)>255):\\n                        # print(i)\\n                        return False\\n                else:\\n                    return False\\n        return True\\n    \\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n\\t#length should be less than 12 because 255.255.255.255 is the largest combination possible\\n        if(len(s)>12):\\n            return[]\\n        else:\\n            i=0\\n            ans=[]\\n            while(i<=3 and i<len(s)):\\n                j=1\\n                while(j<=3 and i+j<len(s)):\\n                    k=1\\n                    while(k<=3 and i+j+k<len(s)):\\n                        temp=s[:i+1]+\\'.\\'+s[i+1:i+j+1]+\\'.\\'+s[i+j+1:i+j+k+1]+\\'.\\'+s[i+j+k+1:]\\n                        # print(temp)\\n                        if(self.check(temp)==True):\\n                            ans.append(temp)\\n                        k+=1\\n                    j+=1\\n                i+=1\\n            return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1707782,
                "title": "c-backtracking-dfs-solution-explained-100-time-70-space",
                "content": "Nice problem which is a variant of more common combinatorics problems, but, as such, offers room for the same kind of approach to tackle it: a good old backtracking DFS across all the branches of our decision tree.\\n\\nIt would be tempting to try and move the `3` dots we have to consider creating a lot of substrings here and there, but that would not be too convenient, considering how many times we might be doing the same work over and over again, while progressing with partial strings we have already validated (and only once) is probably a much better approach.\\n\\nAnd to do so, we will need a few variables, all at class level:\\n* `res` will be our accumulator variable, storing the valid permutations we will find for the provided digits;\\n* `s` will store our initial string at class level, `tmp` our temporary one (as mentioned above to proceed incrementally with already validated string chunks);\\n* `len` will store the length of our initial input;\\n* `digitsLeft` will keep track of how many digits we still need to add in our current `tmp` iteration, initially set to `4`.\\n\\nIn our main function, we will first of all give a proper value to `len`, then check if it is a value worth checking: any string outside of the `4 - 12` range would of course not work for us, providing either too few or too many digits for us to parse.\\n\\nIf we are still in, then we can assign a proper value to `s` and launch our `dfs` helper to compute all the possible permutations.\\n\\nThis helper function will take only one parameter (since I prefer keep as much as possible at class level, instead of passing copies or references of any information at class level), `start`, telling us from which character in `s` we start parsing; we will then:\\n* check if we reached an end case - ie: we are done adding digits to `tmp` (`digitsLeft == 0`), in which case:\\n\\t* if we know we exactly finished parsing the string (`start == len`) we also know we are checking a valid string, so we can append it to `res`;\\n\\t* in any case, we stop recursing with a `return` statement;\\n* if we are in the general case, we need to then consider three possible scenarios:\\n\\t* we can add `1` digit to `tmp`, which is always a valid scenario (I still left a conditional as a placeholder, in order to further optimise that on later iterations and, in any case, more easily tell the decision block apart):\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 1`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`;\\n\\t* we can add `2` digits to `tmp`, provided we have enough characters left and the first one is not `\\'0\\'` (no leading zeroes allowed!):\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `s[start + 1]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 2`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`;\\n\\t* we can add `3` digits to `tmp`, provided we have enough characters left and the first one is `\\'1\\'` followed by any number of `\\'2\\'` followed by any number `< \\'4\\'` or followed by `\\'5\\'` in turn: by any third digits `< \\'6\\'`:\\n\\t\\t* we will decrease `digitsLeft`;\\n\\t\\t* add `s[start]` to `tmp`;\\n\\t\\t* add `s[start + 1]` to `tmp`;\\n\\t\\t* add `s[start + 2]` to `tmp`;\\n\\t\\t* add `\\'.\\'` to `tmp` if we still have `digitsLeft` to add later;\\n\\t\\t* recursively call `dfs` with `start + 2`;\\n\\t\\t* backtrack on both `tmp and `digitsLeft`.\\n\\nOnce done, we can just `return` `res` and be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // general case\\n        // 1 digit addition\\n        if (true) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 1 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 2 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 3 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nHey, we are adding and removing a lot of characters in our three cases, arent\\'t we? Well, it turns out that the third case will be valid only if the first two digits are in the valid range and the first to digits are in the valid range when the first one is (which happens always), so we can avoid a bit of repeated code, manage `digitsLeft` only once and streamline our construction of `tmp` a bit more efficiently and in a DRYer fashion, like this:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size();\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (true) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating tmp and recursing\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating tmp and recursing\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nNow, remember that placeholder conditional I put before the first block for adding one digit to `tmp`?\\n\\nI wanted to optimise it so that it would give us only calls when we have enough characters left to recurse; for example, if our initial string is `\"255255255255\"`, there is clearly no point in taking only `\\'2`\\', since we cannot make `3` other valid digits with the left over (`\"55255255255\"`); it turns out it works wonders, since I tried for example without these conditionals the previous code for `\"25525511135\"` would have `71` recursive calls; with my code, it is now only `9`\\uD83D\\uDE0E!\\n\\nWe will also need to update `tmp` regardless at each step, since we might have some cases in which the second digit is not enough, but the third is okay or the like; but it works wonders in this new version:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\\n\\nThe last tiny bit of optimisation, to avoid reallocations, will be to set `res` initially always to get the maximum capacity of `19` (the longest possible series of permutations we might have for a string like `\"11111111\"`) and then resize accordingly, to avoid reallocations - it saves a bit of memory, it seems, but not as much as cutting on the needless recursions:\\n\\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4, w = 0;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res[w++] = tmp;\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        res.resize(19);\\n        dfs();\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // general case\\n        // 1 digit addition\\n        if (true) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 1 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 2 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating digitsLeft and tmp\\n            digitsLeft--;\\n            tmp += s[start];\\n            tmp += s[start + 1];\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n            // backtracking digitsLeft and tmp\\n            tmp.resize(tmp.size() - 3 - (bool)digitsLeft);\\n            digitsLeft++;\\n        }\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size();\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (true) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && start < len - 1) {\\n            // updating tmp and recursing\\n            tmp += s[start + 1];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && start < len - 2) {\\n            // updating tmp and recursing\\n            tmp += s[start + 2];\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res.push_back(tmp);\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        dfs();\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    vector<string> res;\\n    string s, tmp;\\n    int len, digitsLeft = 4, w = 0;\\n    void dfs(int start = 0) {\\n        // end case - no more digits to add\\n        if (!digitsLeft) {\\n            // if we are exactly at the end, we know it is a valid match\\n            if (start == len) res[w++] = tmp;\\n            return;\\n        }\\n        // support variables\\n        int tmpStartLen = tmp.size(), charsLeft = len - start, lmtL, lmtR;\\n        // general cases:\\n        // updating digitsLeft and tmp\\n        digitsLeft--;\\n        lmtL = 1 * digitsLeft, lmtR = 3 * lmtL;\\n        tmp += s[start];\\n        // 1 digit addition\\n        if (--charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 1);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        tmp += s[start + 1];\\n        // 2 digits addition\\n        if (s[start] != \\'0\\' && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 2);\\n            // backtracking the dot\\n            if (digitsLeft) tmp.pop_back();\\n        }\\n        // 3 digits addition\\n        tmp += s[start + 2];\\n        if ((s[start] == \\'1\\' || s[start] == \\'2\\' && (s[start + 1] < \\'5\\' || s[start + 1] == \\'5\\' && s[start + 2] < \\'6\\')) && --charsLeft >= lmtL && charsLeft <= lmtR) {\\n            // updating tmp and recursing\\n            if (digitsLeft) tmp += \\'.\\';\\n            dfs(start + 3);\\n        }\\n        // backtracking digitsLeft and tmp\\n        tmp.resize(tmpStartLen);\\n        digitsLeft++;\\n    }\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        // updating len and checking if we can proceed or not\\n        len = s.size();\\n        if (len < 4 || len > 12) return res;\\n        // updating s and generating the results\\n        this->s = s;\\n        res.resize(19);\\n        dfs();\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662631,
                "title": "intuitive-easy-to-understand-c-code",
                "content": "```\\nbool isValidPart(const string &s) {\\n        // \"00\", \"000\", \"01\", etc are not valid, but \"0\" is valid\\n        if(s.size() > 3 || s.front() == \\'0\\' && s.size() > 1) return false;\\n\\n        int val = stoi(s);\\n        return val <= 255 && val >= 0;\\n    }\\n\\n    vector<string> restoreIpAddresses(const string &s) {\\n        vector<string> result;\\n        for(size_t i = 1; i < 4 && i < s.size(); ++i) {\\n            const string first = s.substr(0, i);\\n            if(isValidPart(first)) {\\n                for(size_t j = 1; i + j < s.size() && j < 4; ++j) {\\n                    const string second = s.substr(i, j);\\n                    if(isValidPart(second)) {\\n                        for(size_t k = 1; i + j + k < s.size() && k < 4; ++k) {\\n                            const string third = s.substr(i + j, k), fourth = s.substr(i + j + k);\\n                            if(isValidPart(third) && isValidPart(fourth)) {\\n                                result.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\nAn upvote would be appreciated. ^_^",
                "solutionTags": [],
                "code": "```\\nbool isValidPart(const string &s) {\\n        // \"00\", \"000\", \"01\", etc are not valid, but \"0\" is valid\\n        if(s.size() > 3 || s.front() == \\'0\\' && s.size() > 1) return false;\\n\\n        int val = stoi(s);\\n        return val <= 255 && val >= 0;\\n    }\\n\\n    vector<string> restoreIpAddresses(const string &s) {\\n        vector<string> result;\\n        for(size_t i = 1; i < 4 && i < s.size(); ++i) {\\n            const string first = s.substr(0, i);\\n            if(isValidPart(first)) {\\n                for(size_t j = 1; i + j < s.size() && j < 4; ++j) {\\n                    const string second = s.substr(i, j);\\n                    if(isValidPart(second)) {\\n                        for(size_t k = 1; i + j + k < s.size() && k < 4; ++k) {\\n                            const string third = s.substr(i + j, k), fourth = s.substr(i + j + k);\\n                            if(isValidPart(third) && isValidPart(fourth)) {\\n                                result.emplace_back(first + \".\" + second + \".\" + third + \".\" + fourth);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1433047,
                "title": "c-bracktracking-solution",
                "content": "```\\nclass Solution {\\n    \\n    bool isValid(const string& part){\\n        if((part[0] == \\'0\\' && part.size() != 1) || part.size() > 3 || stoi(part) > 255)\\n            return false;\\n        return true;\\n    }\\n    \\n    void util(const string& str, int s, string formedString, string subres, vector<string>& result, int count){\\n        if(formedString!= \"\" && (!isValid(formedString) || count > 4)){\\n            return;\\n        }\\n        subres += formedString == \"\" ? \"\" : formedString + \".\";\\n        if(subres.size()-4 == str.size()){\\n            subres.pop_back();\\n            result.push_back(subres);\\n            return;\\n        }\\n        formedString = \"\";\\n        for(int i = s; i < s+3 && i < str.size(); i++){\\n            formedString.append(1, str[i]);\\n            util(str, i+1, formedString, subres, result, count+1);\\n        }\\n    }\\n    \\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        util(s, 0, \"\", \"\", result, 0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    bool isValid(const string& part){\\n        if((part[0] == \\'0\\' && part.size() != 1) || part.size() > 3 || stoi(part) > 255)\\n            return false;\\n        return true;\\n    }\\n    \\n    void util(const string& str, int s, string formedString, string subres, vector<string>& result, int count){\\n        if(formedString!= \"\" && (!isValid(formedString) || count > 4)){\\n            return;\\n        }\\n        subres += formedString == \"\" ? \"\" : formedString + \".\";\\n        if(subres.size()-4 == str.size()){\\n            subres.pop_back();\\n            result.push_back(subres);\\n            return;\\n        }\\n        formedString = \"\";\\n        for(int i = s; i < s+3 && i < str.size(); i++){\\n            formedString.append(1, str[i]);\\n            util(str, i+1, formedString, subres, result, count+1);\\n        }\\n    }\\n    \\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> result;\\n        util(s, 0, \"\", \"\", result, 0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381550,
                "title": "swift-restore-ip-addresses-test-cases",
                "content": "```swift\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var result: [String] = []\\n        func helper(_ i: Int, _ arr: inout [String]) {\\n            guard i != s.count else {\\n                if arr.count == 4 { result.append(arr.joined(separator: \".\")) }\\n                return\\n            }\\n            if arr.count >= 4 { return }\\n            for end in i ..< min(s.count, i + 3) {\\n                let text = String(s[i ... end])\\n                if let num = Int(text), num >= 0, num < 256, \"\\\\(num)\" == text {\\n                    arr.append(text)\\n                    helper(end + 1, &arr)\\n                    arr.removeLast()\\n                }\\n            }\\n        }\\n        var array: [String] = []\\n        helper(0, &array)\\n        return result\\n    }\\n}\\n```\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.074 (0.077) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.restoreIpAddresses(\"25525511135\")\\n        XCTAssertEqual(res, [\"255.255.11.135\",\"255.255.111.35\"])\\n    }\\n    func test1() {\\n        let res = s.restoreIpAddresses(\"0000\")\\n        XCTAssertEqual(res, [\"0.0.0.0\"])\\n    }\\n    func test2() {\\n        let res = s.restoreIpAddresses(\"1111\")\\n        XCTAssertEqual(res, [\"1.1.1.1\"])\\n    }\\n    func test3() {\\n        let res = s.restoreIpAddresses(\"010010\")\\n        XCTAssertEqual(res, [\"0.10.0.10\",\"0.100.1.0\"])\\n    }\\n    func test4() {\\n        let res = s.restoreIpAddresses(\"101023\")\\n        XCTAssertEqual(res, [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func restoreIpAddresses(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var result: [String] = []\\n        func helper(_ i: Int, _ arr: inout [String]) {\\n            guard i != s.count else {\\n                if arr.count == 4 { result.append(arr.joined(separator: \".\")) }\\n                return\\n            }\\n            if arr.count >= 4 { return }\\n            for end in i ..< min(s.count, i + 3) {\\n                let text = String(s[i ... end])\\n                if let num = Int(text), num >= 0, num < 256, \"\\\\(num)\" == text {\\n                    arr.append(text)\\n                    helper(end + 1, &arr)\\n                    arr.removeLast()\\n                }\\n            }\\n        }\\n        var array: [String] = []\\n        helper(0, &array)\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.074 (0.077) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.restoreIpAddresses(\"25525511135\")\\n        XCTAssertEqual(res, [\"255.255.11.135\",\"255.255.111.35\"])\\n    }\\n    func test1() {\\n        let res = s.restoreIpAddresses(\"0000\")\\n        XCTAssertEqual(res, [\"0.0.0.0\"])\\n    }\\n    func test2() {\\n        let res = s.restoreIpAddresses(\"1111\")\\n        XCTAssertEqual(res, [\"1.1.1.1\"])\\n    }\\n    func test3() {\\n        let res = s.restoreIpAddresses(\"010010\")\\n        XCTAssertEqual(res, [\"0.10.0.10\",\"0.100.1.0\"])\\n    }\\n    func test4() {\\n        let res = s.restoreIpAddresses(\"101023\")\\n        XCTAssertEqual(res, [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340970,
                "title": "java-easy-accepted-solution",
                "content": "\\' \\' \\'\\n\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n\\n\\t\\tint n = s.length();\\n\\n\\t\\tfor (int i = 0; i < 4 && i <= n - 3; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < i + 4 && j <= n - 2; j++) {\\n\\t\\t\\t\\tfor (int k = j + 1; k < j + 4 && k <= n - 1; k++) {\\n\\n\\t\\t\\t\\t\\tString s1 = s.substring(0, i), \\n                      s2 = s.substring(i, j), \\n                      s3 = s.substring(j, k), \\n                      s4 = s.substring(k, n);\\n                    \\n\\t\\t\\t\\t\\tif (check(s1) && check(s2) && check(s3) && check(s4)) {\\n\\t\\t\\t\\t\\t\\tresult.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n    \\n    public boolean check(String s) {\\n\\n\\t\\tif (s.length() > 3 || \\n            s.length() == 0 || \\n            s.charAt(0) == \\'0\\' && s.length() > 1 || \\n            Integer.parseInt(s) > 255) \\n         {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n\\n\\t\\tint n = s.length();\\n\\n\\t\\tfor (int i = 0; i < 4 && i <= n - 3; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < i + 4 && j <= n - 2; j++) {\\n\\t\\t\\t\\tfor (int k = j + 1; k < j + 4 && k <= n - 1; k++) {\\n\\n\\t\\t\\t\\t\\tString s1 = s.substring(0, i), \\n                      s2 = s.substring(i, j), \\n                      s3 = s.substring(j, k), \\n                      s4 = s.substring(k, n);\\n                    \\n\\t\\t\\t\\t\\tif (check(s1) && check(s2) && check(s3) && check(s4)) {\\n\\t\\t\\t\\t\\t\\tresult.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1323898,
                "title": "what-if-the-length-of-string-is-greater-than-12-java-solution-1ms",
                "content": "\\tclass Solution {\\n\\t\\n\\t// Ip address can have max 12 numeric digits, Right? So no need to do anything for test case with length of string is greater than 12.\\n\\t\\tList<String> res;\\n\\t\\tpublic void restoreIp(String s, int idx, int state, StringBuilder cans) {\\n\\t\\t\\tif(idx == s.length()) {\\n\\t\\t\\t\\tif(state == 5) {\\n\\t\\t\\t\\t\\tres.add(cans.substring(1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(state == 5) return;\\n\\t\\t\\tfor(int i=1; i+idx <= s.length() && i <= 3; i++) {\\n\\t\\t\\t\\tString currStr = s.substring(idx, idx+i);\\n\\t\\t\\t\\tif(currStr.length() >= 2 && currStr.charAt(0) == \\'0\\') return;\\n\\t\\t\\t\\tint value = Integer.parseInt(currStr);\\n\\t\\t\\t\\tif(value >= 0 && value <= 255) {\\n\\t\\t\\t\\t\\tcans.append(\\'.\\').append(currStr);\\n\\t\\t\\t\\t\\trestoreIp(s, i+idx, state+1, cans);\\n\\t\\t\\t\\t\\tcans.delete(cans.length() - currStr.length() - 1, cans.length());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic List<String> restoreIpAddresses(String s) {\\n\\t\\t\\tres = new ArrayList<>();\\n\\t\\t\\tif(s.length() > 12) return res;\\n\\t\\t\\trestoreIp(s, 0, 1, new StringBuilder());\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\n\\t// Ip address can have max 12 numeric digits, Right? So no need to do anything for test case with length of string is greater than 12.\\n\\t\\tList<String> res;\\n\\t\\tpublic void restoreIp(String s, int idx, int state, StringBuilder cans) {\\n\\t\\t\\tif(idx == s.length()) {\\n\\t\\t\\t\\tif(state == 5) {\\n\\t\\t\\t\\t\\tres.add(cans.substring(1));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1231786,
                "title": "c-backtracking",
                "content": "simple backtracking algorithm checking every condition\\nhere \\n\\ti=next index to be considered of string s\\n\\tcnt=number of elements\\n```\\nclass Solution {\\npublic:\\n    void bt(string s,string x,int i,int cnt,vector<string> &ans)\\n    {\\n\\t\\tif(cnt>4)\\n        {\\n            return;\\n        }\\n        if(i==s.size() && cnt==4)\\n        {\\n            x=x.substr(0,x.size()-1);\\n            ans.push_back(x);\\n            return;\\n        }\\n        int p=0;\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(j!=i && p==0) //to check of recuring zeros\\n            {\\n                break;\\n            }\\n            p*=10;\\n            p+=s[j]-\\'0\\';\\n            if(p>=0 && p<=255)\\n            {\\n                string y=x;\\n                x+=to_string(p);\\n                x+=\\'.\\';\\n                bt(s,x,j+1,cnt+1,ans);\\n                x=y;\\n            }\\n            if(p>255)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n       vector<string> ans;\\n        if(s.length()>12) //length must be less than 12\\n        {\\n            return ans;\\n        }\\n        string x;\\n        bt(s,x,0,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void bt(string s,string x,int i,int cnt,vector<string> &ans)\\n    {\\n\\t\\tif(cnt>4)\\n        {\\n            return;\\n        }\\n        if(i==s.size() && cnt==4)\\n        {\\n            x=x.substr(0,x.size()-1);\\n            ans.push_back(x);\\n            return;\\n        }\\n        int p=0;\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(j!=i && p==0) //to check of recuring zeros\\n            {\\n                break;\\n            }\\n            p*=10;\\n            p+=s[j]-\\'0\\';\\n            if(p>=0 && p<=255)\\n            {\\n                string y=x;\\n                x+=to_string(p);\\n                x+=\\'.\\';\\n                bt(s,x,j+1,cnt+1,ans);\\n                x=y;\\n            }\\n            if(p>255)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    vector<string> restoreIpAddresses(string s) {\\n       vector<string> ans;\\n        if(s.length()>12) //length must be less than 12\\n        {\\n            return ans;\\n        }\\n        string x;\\n        bt(s,x,0,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215702,
                "title": "python-recursion-no-backtracking",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = set()\\n        if len(s) < 4 or len(s) > 12:\\n            return ans\\n        \\n        def isValid(num):\\n            if not num:\\n                return False\\n            if len(num) == 1:\\n                return True\\n            if len(num) > 3:\\n                return False\\n            if num.startswith(\\'0\\'):\\n                return False\\n            if int(num) > 255:\\n                return False\\n            return True\\n        \\n        def dfs(curr_index, address_till_now, number_of_points):\\n            if number_of_points == 3:\\n                if isValid(s[curr_index: ]):\\n                    new_address = address_till_now + \\'.\\'+ s[curr_index: ]\\n                    ans.add(new_address[1:])\\n                return \\n            for next_index in [curr_index + 1, curr_index + 2, curr_index + 3]:\\n                if isValid(s[curr_index: next_index]):\\n                    dfs(next_index, address_till_now + \\'.\\' + s[curr_index: next_index], number_of_points + 1)\\n                    \\n        dfs(0, \\'\\', 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans = set()\\n        if len(s) < 4 or len(s) > 12:\\n            return ans\\n        \\n        def isValid(num):\\n            if not num:\\n                return False\\n            if len(num) == 1:\\n                return True\\n            if len(num) > 3:\\n                return False\\n            if num.startswith(\\'0\\'):\\n                return False\\n            if int(num) > 255:\\n                return False\\n            return True\\n        \\n        def dfs(curr_index, address_till_now, number_of_points):\\n            if number_of_points == 3:\\n                if isValid(s[curr_index: ]):\\n                    new_address = address_till_now + \\'.\\'+ s[curr_index: ]\\n                    ans.add(new_address[1:])\\n                return \\n            for next_index in [curr_index + 1, curr_index + 2, curr_index + 3]:\\n                if isValid(s[curr_index: next_index]):\\n                    dfs(next_index, address_till_now + \\'.\\' + s[curr_index: next_index], number_of_points + 1)\\n                    \\n        dfs(0, \\'\\', 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944975,
                "title": "java-backtrack-solution-with-complexity-explanation",
                "content": "Let\\'s define general problem: given string `s`, find all possible groups of `M` numbers with each number at most `K` digit length. The time complexity of this code will be `O(MK\\xB2 K^M)`. Here is the code with comments.\\nIn reality a lot of  unnecessary branches are deleted, so this complexity is upper bound. Also, we can improve complexity to `O(MK K^M)`\\n\\n```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        backtrack(s, result, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(String s, List<String> result, List<String> cur, int index) { // O(MK\\xB2) per node, at most K^M nodes\\n        if (index >= s.length()) {\\n            if (cur.size() == 4) {\\n                result.add(String.join(\".\", cur)); // O(M)\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (cur.size() == 4) {\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) { // O(K)\\n            int value = Integer.parseInt(s.substring(index, index + i)); // O(K)\\n            \\n            if (value >= 0 && value <= 255 && Integer.toString(value).length() == i) {\\n                cur.add(Integer.toString(value));\\n                backtrack(s, result, cur, index + i);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> restoreIpAddresses(String s) {\\n        List<String> result = new ArrayList<>();\\n        backtrack(s, result, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(String s, List<String> result, List<String> cur, int index) { // O(MK\\xB2) per node, at most K^M nodes\\n        if (index >= s.length()) {\\n            if (cur.size() == 4) {\\n                result.add(String.join(\".\", cur)); // O(M)\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (cur.size() == 4) {\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= 3 && index + i <= s.length(); i++) { // O(K)\\n            int value = Integer.parseInt(s.substring(index, index + i)); // O(K)\\n            \\n            if (value >= 0 && value <= 255 && Integer.toString(value).length() == i) {\\n                cur.add(Integer.toString(value));\\n                backtrack(s, result, cur, index + i);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838805,
                "title": "simple-js-backtrack-solution-with-comments-beat-97",
                "content": "```\\n// for every ip field, it can be 1 to 3 digits slice the current s and pass the remain s to next recursive\\n// the backtrack is if the sliced ip field is valid then go to next recursive\\n\\nvar restoreIpAddresses = function(s) {\\n  const res = [];\\n  if(s.length < 4) return res;\\n  dfs([], s, res);\\n  return res;\\n};\\n\\n\\nfunction dfs(tmp, s, res) {\\n  if(tmp.length === 4) {\\n    if(s === \\'\\') res.push(tmp.join(\\'.\\'));\\n    return;\\n  }\\n  \\n  for(let i = 1; i <= 3; i++) {\\n    if(s.length >= i) {\\n      const ipItem = s.slice(0, i);\\n      const ipItemVal = parseInt(ipItem);\\n      if(ipItemVal >= 0 && ipItemVal <= 255 && ipItem === ipItemVal.toString()) {\\n        dfs([...tmp, ipItem], s.slice(i), res);\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// for every ip field, it can be 1 to 3 digits slice the current s and pass the remain s to next recursive\\n// the backtrack is if the sliced ip field is valid then go to next recursive\\n\\nvar restoreIpAddresses = function(s) {\\n  const res = [];\\n  if(s.length < 4) return res;\\n  dfs([], s, res);\\n  return res;\\n};\\n\\n\\nfunction dfs(tmp, s, res) {\\n  if(tmp.length === 4) {\\n    if(s === \\'\\') res.push(tmp.join(\\'.\\'));\\n    return;\\n  }\\n  \\n  for(let i = 1; i <= 3; i++) {\\n    if(s.length >= i) {\\n      const ipItem = s.slice(0, i);\\n      const ipItemVal = parseInt(ipItem);\\n      if(ipItemVal >= 0 && ipItemVal <= 255 && ipItem === ipItemVal.toString()) {\\n        dfs([...tmp, ipItem], s.slice(i), res);\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817580,
                "title": "my-simple-dfs-python-solution-beat-99-14",
                "content": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        ret = []\\n        self.dfs(ret, s, [])\\n        return ret\\n\\n    def dfs(self, ret, s, path_list):\\n        if len(path_list) == 4:\\n            if s == \\'\\':\\n                ret.append(\\'.\\'.join(path_list))\\n            return\\n        if not s:\\n            return\\n        if s[0] == \\'0\\':\\n            temp_path_list = path_list[::]\\n            temp_path_list.append(\\'0\\')\\n            self.dfs(ret, s[1:], temp_path_list)\\n            return\\n        for i in range(len(s)):\\n            if i >= 3:\\n                break\\n            if int(s[:i + 1]) <= 255:\\n                temp_path_list = path_list[::]\\n                temp_path_list.append(s[:i + 1])\\n                self.dfs(ret, s[i + 1:], temp_path_list)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str):\\n        ret = []\\n        self.dfs(ret, s, [])\\n        return ret\\n\\n    def dfs(self, ret, s, path_list):\\n        if len(path_list) == 4:\\n            if s == \\'\\':\\n                ret.append(\\'.\\'.join(path_list))\\n            return\\n        if not s:\\n            return\\n        if s[0] == \\'0\\':\\n            temp_path_list = path_list[::]\\n            temp_path_list.append(\\'0\\')\\n            self.dfs(ret, s[1:], temp_path_list)\\n            return\\n        for i in range(len(s)):\\n            if i >= 3:\\n                break\\n            if int(s[:i + 1]) <= 255:\\n                temp_path_list = path_list[::]\\n                temp_path_list.append(s[:i + 1])\\n                self.dfs(ret, s[i + 1:], temp_path_list)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1767147,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1564690,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1696219,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767384,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567853,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1565487,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1566476,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567190,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1573001,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767612,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767147,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1564690,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1696219,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767384,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567853,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1565487,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1566476,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1567190,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1573001,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767612,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "I think this year leetcode will make us master in each topic one by one.\\n"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Agreed, and I also love the way they are taking it form easy to higher difficulties for each topic."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Exactly!"
                    },
                    {
                        "username": "ycai77",
                        "content": "Here we have\\n\\nInput: \\t\"010010\"\\n\\nOutput: \\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected: \\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\n\\nMay I know why \"0.1.0.10\" is not valid? From previous test cases, I know even '0.0.0.0' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "nasibsltn",
                        "content": "You are not allowed to reorder or remove any digits in s."
                    },
                    {
                        "username": "vadhananmadhi",
                        "content": "The input is 010010 , but you have taken the input as 01010. That\\'s the problem. First , I got confused actually! :("
                    },
                    {
                        "username": "uzairnizamuddin",
                        "content": "length of your input string is 6 but in the output you have few cases with less than 6 chars. even 0.1.0.10 length is 5 not 6. that\\'s why it\\'s not included."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "\"0.1.0.10\" is valid but \"0.1.0.010\" or \"0.1.00.10\" is not valid.\\nFor IP\\'s it should\\'t have leading zeros. either it is a number other than 0 or just 0.\\nHoep that helps! "
                    },
                    {
                        "username": "DXDE443",
                        "content": "Because there\\'re two 0s between the 1s."
                    },
                    {
                        "username": "sigrid1019",
                        "content": "Because the corresponding input of \"0.1.0.10\" is \"01010\", not \"010010\". You have to consider the problem of leading zeros. "
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "1. I highly recommend learning how to solve [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) before this!\\n2. Keep track of the number of dots that you\\'ve used,  the current number you\\'re seeing if you can add, and the current string you\\'re building!"
                    },
                    {
                        "username": "varun21vaidya",
                        "content": "definitely helped !! "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Yes ! The 1st tip is pretty good, I have done 131 before and this was a cake walk for me."
                    },
                    {
                        "username": "joseph261059",
                        "content": "If the length of the text is more than 12, just return empty array, as it is not possible to have a valid IP"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@RAOdotSH](/RAOdotSH) s[0] = 0 can be valid"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "[@RAOdotSH](/RAOdotSH) I used this \\nn < 4 || n > 12 || Long.parseLong(s) > 255255255255L"
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "[@m_manan](/m_manan) But there is also a trick condition for this.\\nLike if length is greater than 3 but the number is less than 0 or greater than 255 and also if s[0] is 0"
                    },
                    {
                        "username": "m_manan",
                        "content": "same goes if it is less than 4"
                    },
                    {
                        "username": "shuanglengchanghehxy",
                        "content": "How to solve this question\\uff1f I have  no idea. Please help me ."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@Emoclaw](/Emoclaw) I wonder what he/she is doing now !"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "[@djslim](/djslim) It\\'s been 10 years so they might\\'ve solved it by now XD"
                    },
                    {
                        "username": "djslim",
                        "content": "try some more fundamental backtracking problem e.g. https://leetcode.com/problems/combination-sum/"
                    },
                    {
                        "username": "skylight1984",
                        "content": "The question itself is not difficult at all, but it does not explain clearly. For example, for string \"010010\", does it allow \"0.1.001.0\" or \"0.1.00.1.0\"? Can our output keep the leading zeros?\\n\\nHad to submit a couple of times and see the expected answer to figure out all the requirements."
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "It is clearly mentioned that leading 0s are not allowed."
                    },
                    {
                        "username": "Idrissa_242",
                        "content": " Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. According the problem statement , so I guess  it does not allow either of them (0.1.001.0 or 0.1.00.1.0) because both have leading 0's therefore you should remove the leading 0's then the solution might be something like this  [\"0.10.0.10\",\"0.100.1.0\"]"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "I think that the condition can be rephrased as: if the four substrings are in the form `s_i`, for `i=0,1,2,3`, then either the entire `s_i` is `0`, or does not starts with `0` and the number it represents is within the range `0-256`."
                    },
                    {
                        "username": "fangzhenpeng",
                        "content": "preceding zeros are handled.\\n\\nInput:\\t\"010010\"\\n\\nOutput:\\t[\"0.1.0.10\",\"0.1.1.0\",\"0.10.0.10\",\"0.10.1.0\",\"0.100.1.0\",\"1.0.0.10\",\"1.0.1.0\",\"10.0.1.0\"]\\n\\nExpected:\\t[\"0.10.0.10\",\"0.100.1.0\"]\\n\\nThough the Output can be easily transferred to Expected by comparing the length with original string, I feel the Output is more reasonable."
                    },
                    {
                        "username": "reknix",
                        "content": "Quite simple. \\n\\n1. Need to have 4 parts\\n2. Each of the parts need to be between 0 and 255, inclusive. \\n\\nHope this is helpful. This information is enough to solve the question. Good luck :)"
                    },
                    {
                        "username": "vin9897",
                        "content": "woooo! what a wonderful information"
                    },
                    {
                        "username": "itaib2004",
                        "content": "Can\\'t have leading zeroes is also important imo"
                    },
                    {
                        "username": "JeeyoCal123",
                        "content": "For input \"25525511135\"\\nmy code outputs\\n[\"25.525.511.135\",\"255.25.511.135\",\"255.255.11.135\",\"255.255.111.35\"]\\nBut the answer is \\n[\"255.255.11.135\",\"255.255.111.35\"]\\nWhy is the first two results from mine invalid?\\n\\n\"25.525.511.135\",\"255.25.511.135\"\\n\\nThey follow the rules of keeping the digit order, the dots etc. So why are they not included??"
                    },
                    {
                        "username": "lakshya__26",
                        "content": "Each value should be less than or equal to 255 but your second and third values are 525 and 511 respectively which are more than 255 so your output is wrong."
                    },
                    {
                        "username": "sharingiscaring123",
                        "content": "for \\'25.525.511.135\\', the second octet value is 525, which is greater than 255"
                    },
                    {
                        "username": "nanda_8",
                        "content": "Glad to see Leetcode throwing problems from different topics :}\\n"
                    }
                ]
            },
            {
                "id": 1767434,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767409,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767087,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767819,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767353,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1767299,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1985960,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1973018,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1969609,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1853189,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "who failed multiple edge cases like me?\\uD83D\\uDE02\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "\"192.168.1.312\" why isn\\'t this one a valid IP address!!!?"
                    },
                    {
                        "username": "Ankita_Sahoo",
                        "content": "[@Firebelias12](/Firebelias12) 312 > 255 , go through the given data and 1st check if the length is <=12"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "312 > 255"
                    },
                    {
                        "username": "Emoclaw",
                        "content": "This is a simple backtracking problem with a few slightly convoluted conditions.\n\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\n2. When selecting a candidate, it can't have more than 3 characters (2552.55.111.35 is not valid)\n3. When selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\n4. When selecting a candidate, IF the candidate has 2 or more characters, then the first can't be a zero. (1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\n\n\n\nIn my case, I checked the first condition before adding the temp array to the result (using join in python to make it a string) and the other three when selecting candidates to recurse\nAlso condition 2 is not necessary as it's covered by 3 and 4, but it makes the solution faster by allowing you to break early. Once we've reached an oversized candidate, there's no need to check the rest of the string."
                    },
                    {
                        "username": "RAOdotSH",
                        "content": "I don\\'t think it is that complicated. You can just use simple intution of finding 4 different strings and checking if they are valid or not. All the four points you stated are correct and good to go. "
                    },
                    {
                        "username": "Pranav_2510",
                        "content": "I did not feel this being a backtracking question, instead seemed to be a DFS styled recursion.\\nPlease ping me if I\\'m missing something."
                    },
                    {
                        "username": "kailasrathod",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\n1. There needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\n2. When selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\n3. IF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\n4. The main idea to solve this problem is to use Recursion.\\n4.1 Consider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\n5. At every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\n6. At each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\n7. When we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "sonal91022",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079577/c-easy-code-comment-explanation-easy-to-understand/\\n\\nc++ easy code "
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unexpectedly difficult. Spent >20 min.\\n\\nTest generator:\\n\\n```\\narr = [str(random.randint(0, 9)) for _ in range(random.randint(4, 13))]\\njson_str = \"\".join(arr)\\nprint(json_str)\\npyperclip.copy(json_str)\\n```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "One of my favorite problems"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "Python3 solution :\n                       https://leetcode.com/problems/restore-ip-addresses/solutions/3761564/py3-very-easy-and-clean-solution/"
                    },
                    {
                        "username": "anonymous_717",
                        "content": "\\nwhy this giving runtime error\\n\\n\\nvoid solve(string s,string str,string l,vector<string> &ans,int index,int n,int o){\\n        if(index>=n&&o==3){\\n            ans.push_back(str);\\n            return;\\n        }else if(index>=n)return;\\n        if(o>3)return;\\n        if(o>=3&&stoi(s.substr(index,s.length()-index))>255)return;\\n        string k=\"\";\\n        if(index<s.length()&&stoi(l+s[index])<=255&&l!=\"0\"){\\n            solve(s,str+s[index],l+s[index],ans,index+1,n,o);\\n            if(str[str.length()-1]!=\\'.\\'&&str.length()>=1){\\n                solve(s,str+\\'.\\',k,ans,index,n,++o);   \\n            }\\n        }else {\\n            solve(s,str+\\'.\\',k,ans,index,n,++o);\\n        }\\n    }\\n    \\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> ans;\\n        string str=\"\",k=\"\";\\n        int n=s.length();\\n        solve(s,str,k,ans,0,n,0);\\n        return ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1809457,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1798472,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1769855,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768530,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768193,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768189,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768071,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768051,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1768005,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1767964,
                "content": [
                    {
                        "username": "Nebula64",
                        "content": "It was a good question on backtracking. The problem is not difficult but the requirements are. This question requires backtracking with some addititonal requirements from the question. This question took a while for me to solve. \nYou have to keep in mind the number of points you are using and the range of numbers in each section and also the length of the string. Pretty good !!"
                    },
                    {
                        "username": "ravirajladha",
                        "content": "What do you mean by it can\\'t lead by 0 ?"
                    },
                    {
                        "username": "gbiems",
                        "content": "This is the closest to a real on the job programming problem I\\'ve ever seen on leetcode. Interesting that it\\'s a medium difficulty problem considering that you really don\\'t need any advanced techniques to get a decent performing solution. \\n\\nThere\\'s only three dots, so you really don\\'t need backtracking, you can solve this one with a few loops. This is the sort of problem I would have been able to solve before I started doing leetcode and learned more about dynamic programming, backtracking, recursion, tree traversal, etc. \\n\\nAs a personal exercise, I am going to go back and write a recursive solution that works for an arbitrary number of dots, since that\\'s the kind of technique more likely to be required in an interview. \\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can we USE stoi and stoll > \\n\\'s\\' must consist of values from 0 to 9 only as they are saying this . but i am using stoll and it throws error..."
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "go about like working with a state change diagram/tree, will really make you think what kind of solution you will end up with and where to put the requirements\n\nquite a question to test the backtracking (+tracking) skills ;)"
                    },
                    {
                        "username": "TITIKSHA_KUMARI",
                        "content": "May I know why \"0.1.0.10\" is not valid? From previous test cases, I know even \\'0.0.0.0\\' is counted as valid.\\nYour input is highly appreciated."
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "It is valid for \"01010\" case where you have \"0.1.0.10\" and \"0.10.1.0\""
                    },
                    {
                        "username": "jay61226",
                        "content": "This is a backtracking solution that uses a helper function called backtrack. The backtrack function takes in four parameters: result (to store all valid IP addresses), s (the input string), current (an array representing the current IP address being built), and index (the current index of the input string that is being processed).\\n\\nThe function first checks if the current IP address has 4 parts and if all characters of the input string have been processed, in which case it pushes the current IP address (as a string) to the result array. If the current IP address has 4 parts or all characters of the input string have been processed, it returns.\\n\\nOtherwise, the function uses a loop to iterate through the next three characters of the input string starting from the current index. For each iteration, the function checks if the current substring is a valid number (between 0 and 255, inclusive, and no leading zeroes) and, if so, it pushes the number to the current IP address array and calls the backtrack function recursively with the updated current array and the next index. Finally, it pops the number from the current IP address array to backtrack and try the next combination."
                    },
                    {
                        "username": "andrew99154",
                        "content": "I even use DP to solve this problem. People who use iterative methods to solve problems just show that I\\'m a NOOB."
                    },
                    {
                        "username": "bumholio",
                        "content": "It\\'s pretty elementary to write a loop that generates half of a correct IP, ie. \"255.255\": just move the dot inside the string from position 1 to n-1, and each time check if both bytes are valid. If they are, add the solution to the set.\\n\\nBased on this simple algorithm, add a dots parameter to the function, recurse to (dots-1) for the tail and, for each valid first byte, add to the result array all combinations of (valid first byte \".\" valid_tail).\\n\\nThen simply call the recursive function with the full IP and dots=3 "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "```\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        for i in range(1, 4):\\n            for j in range(i+1, i+4):\\n                for k in range(j+1, j+4):\\n                    if k < n-1:\\n                        s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\\n                        if self.isValid(s1) and self.isValid(s2) and self.isValid(s3) and self.isValid(s4):\\n                            res.append(s1 + \\'.\\' + s2 + \\'.\\' + s3 + \\'.\\' + s4)\\n        return res\\n\\n    def isValid(self,s):\\n        return 0 <= int(s) <= 255 and str(int(s)) == s\\n```\\n\\ncan anyone plz find out whats wrong in this code can\\'t seem to figue out. \\nim failing this case\\ns =\\n\"101023\"\\nOutput\\n[\"1.0.10.23\",\"10.1.0.23\"]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "```python\nif k < n-1\n```\nshould be  changed to \n```python\nif k < n\n```"
                    }
                ]
            },
            {
                "id": 1767956,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767955,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767915,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767914,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767893,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767864,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767847,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767837,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767815,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767610,
                "content": [
                    {
                        "username": "jahid_shakil",
                        "content": "A complete Easy less week."
                    },
                    {
                        "username": "black_pearl98",
                        "content": "Solve using BackTracking"
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<String> restoreIpAddresses(String s) {\\n         List<String> res = new ArrayList<>();\\n        int len = s.length();\\n        for (int i = 1; i < 4 && i < len - 2; i++) {\\n            for (int j = i + 1; j < i + 4 && j < len - 1; j++) {\\n                for (int k = j + 1; k < j + 4 && k < len; k++) {\\n                    String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);\\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\\n                        res.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == \\'0\\' && s.length() > 1) ||          Integer.parseInt(s) > 255)\\n            return false;\\n        return true;\\n    }"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This problem seems hard to me when i went for recursion solution. Anyway a good problem."
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "1-from the examples we know that we should consider each element and we know that each element is a digit\\n2-we can accept the answer if it was only divide by 3 dots (4 sections)\\n3-every section will represent an integer so it cant be empty ([])  and it cant have more than three digits ([1,2,4,1]) cause it \\n   will be >255 and [0,2,5,5] is invalid cause it starts with zero\\n4- finally we know all the numbers are >0\\nwe can think of approach that we can put in each section one number at least and three numbers at most \\nso for each number we can put it by it self and we can  put it with one element after it and we can put it with tow elements after\\nit without breaking the rules  "
                    },
                    {
                        "username": "omen4326",
                        "content": "Try to keep track of dotCnt and try to use your basic recursion approach you will definitely able to crack the question.\\nHint can be that try how you will take the part of the string and check whether its valid for ip or not .\\none basic condition can be very simple who so ever had studied networking:) i.e its length can\\'t be greater > ? try to figure out you will came to know :)\\nbest of luck !!!!"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation  https://youtu.be/1OoZUywftGI"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This problem is quite easy if you understand Recursion.\\nYou should see this to understand how to solve this with 2 easy approaches: https://youtu.be/qbmVLOLarek"
                    },
                    {
                        "username": "Diamantis",
                        "content": "The worst problems for me are the ones that have a fairly straightforward solution concept but requite a lot of coding and edge case handling."
                    },
                    {
                        "username": "_ultimate_",
                        "content": "simple recursive solution \\n\\nclass Solution {\\npublic:\\n\\nvector<string> ans;\\n\\nbool isvalid(string temp)\\n{\\n    int p=0;int j=0;\\n    while(j<temp.size())\\n    {\\n        if(temp[j+1]==\\'.\\')\\n        {\\n            string eval;\\n            while(p<=j)\\n            {\\n                eval.push_back(temp[p]);p++;\\n                \\n            }\\n            int evall=stoi(eval);\\n                if(eval[0]==\\'0\\' && eval.size()>1){return false;}\\n                if(evall>255){return false;}\\n            p=j+2;\\n            j=p;\\n            continue;\\n        }\\n        j++;\\n    }\\n\\n    return true;\\n}\\n\\n\\nvoid helper(string s,int i,int n,string temp,int dot)\\n{\\n    if(i>=n)\\n    {\\n          \\n          if(dot!=4){return;}\\n          if(isvalid(temp)){temp.pop_back();\\n              ans.push_back(temp);}\\n          \\n\\n          return;\\n    }\\n\\n   \\n\\n    temp.push_back(s[i]);temp.push_back(\\'.\\');\\n    helper(s,i+1,n,temp,dot+1);\\n    \\n    if(i+1<n){\\n    temp.pop_back();\\n    temp.push_back(s[i+1]);temp.push_back(\\'.\\');\\n    helper(s,i+2,n,temp,dot+1);}\\n     \\n     if(i+2<n){\\n     temp.pop_back();\\n    temp.push_back(s[i+2]);temp.push_back(\\'.\\');\\n    helper(s,i+3,n,temp,dot+1);\\n     }\\n}\\n    vector<string> restoreIpAddresses(string s) {\\n\\n        if(s.size()>12){return ans;}\\n\\n        string temp;\\n        helper(s,0,s.size(),temp,0);\\n\\n        return ans;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767556,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767398,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767396,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767395,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767357,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767354,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767352,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767348,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767347,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1767346,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "Can someone explain me the time complexity of the backtracking approach..\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "well this week is amazing-problems-week!"
                    },
                    {
                        "username": "jeyakumar25",
                        "content": "constrains are wrong: s.length should be max of 12(4*3) only. But It\\'s wrong as 20."
                    },
                    {
                        "username": "thisannie",
                        "content": "It\\'s not wrong though. its just that for length>12 you can not return valid IP so you return null."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Finally an Easy after so much time."
                    },
                    {
                        "username": "thisannie",
                        "content": "Question can be simply stated as:\\nreturn all valid IP address of given  string.\\n\\nValid IP address contains 4 numbers seperated by ` . ` \\nEx `\"w.x.y.z\"` is valid where, 0<= `w`,`x`,`y`,`z` <= 255 and none of the them should have leading zeros like `x != 012 or 0021` but `x = 0` is valid therefore `0.0.0.0` is valid but `012.124.32.56` is not valid.\\n\\nhope this helps in clear understanding of question. :)"
                    },
                    {
                        "username": "gupta97540",
                        "content": "Surprised that chatGpt solve this . "
                    },
                    {
                        "username": "kailasrathod",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n\\n\\nhttps://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "Exaplanation to Approach :\\n\\nThis is a backtracking problem with a few slightly convoluted conditions.\\n\\nThere needs to be 4 parts per IP. There are always three dots/four candidates (2.5.5.2.5.5.1.1.1.3.5 is not valid, neither is 1.1.1)\\n\\nWhen selecting a candidate, it can\\'t have more than 3 characters (2552.55.111.35 is not valid)\\nWhen selecting a candidate, its characters cant be above 255 (25.525.511.135 is not valid because of 525 and 511)\\nWhen selecting a candidate\\nIF the candidate has 2 or more characters, then the first can\\'t be a zero.\\n(1.0.1.023 is not valid as member 023 is size>1 and leads with 0. But 0.0.0.0 is valid as each candidate is size 1)\\nThe main idea to solve this problem is to use Recursion.\\nConsider every position of the input string and, there exist two possible cases:\\nPlace a dot over the current position.\\nTake this character, i.e don\\u2019t place the dot over this position.\\nAt every step of the recursion, we have the following data:\\ncurr stores the string between two dots.\\nres stores the possible IP Address.\\nindex stores the current position in the input string.\\nAt each index, first, add the character to curr and check whether the integer that we have is in the range [0,255] then, we can move further otherwise return.\\nWhen we reach the end of the input string, we\\u2019ll check whether we have a valid IP Address or not, If yes, insert the IP Address into our answer.\\n"
                    },
                    {
                        "username": "rathodsiddharth",
                        "content": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079724/backtracking-for-beginners-c-java-js-py-easy-code-explanation-easy-to-understand/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Valid Phone Numbers",
        "question_content": "<p>Given a text file <code>file.txt</code> that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.</p>\n\n<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>\n\n<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>file.txt</code> has the following content:</p>\n\n<pre>\n987-123-4567\n123 456 7890\n(123) 456-7890\n</pre>\n\n<p>Your script should output the following valid phone numbers:</p>\n\n<pre>\n987-123-4567\n(123) 456-7890\n</pre>\n",
        "solutions": [
            {
                "id": 2254239,
                "title": "bash-simple-regular-expression-with-explanation",
                "content": "\\n```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```\\nthis is a grep command accepting two regular expressions\\n1 .```^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\\n2 .```^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\\n\\nThe construction is as follows \\n* ^: indicates the starting of the string\\n* $: indicates the end of the string\\n* [0-9]\\\\\\\\{3\\\\\\\\} : represent 3 numbers (\\\\\\\\{3\\\\\\\\})  between the range 0-9 ([0-9] a digit in the range) \\n* \\\\\\\\: suppresses the specialness of the character\\n* -e: to include multiple regex",
                "solutionTags": [],
                "code": "```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```\n```^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```\n```^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$```",
                "codeTag": "Unknown"
            },
            {
                "id": 2206032,
                "title": "simple-bash-solutions-explained-grep-awk",
                "content": "I have compiled a list of possible solutions using grep or awk as well as explaining the tools/syntax used. Hope it helps!\\n\\n**Common syntax explained:**\\n* `^` Start of a line (not just within a line, ex `112-122-2313` **not** `022121-112-2313`)\\n* `[0-9]` regex expression to represent any digit between 0 and 9.\\n* `\\\\d` any digit (Perl-flavoured regular expression) *Note the compiler uses GNU/Linux so to use \\\\d use the `-P` tag*\\n* `{3}` repeated exactly 3 times, `{4}` repeated 4 times ect, hence `[0-9]{3}` means three numbers from 0-9.\\n* `$` end of a line\\n* `|` or expression\\n* `()` used to group expressions\\n* `\\\\(` or`\\\\)` used for literal parentheses \\n\\n\\n##### 1. Using a `grep` search with the extended regular expressions.\\n`-E` Extended regular expressions same as `egrep`\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\\nor\\n```\\negrep \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\\n\\n\\n##### 2. Using `grep` with Perl-flavoured regular expression\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n\\n##### 3. Using an `awk` search with regex values\\n```\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\n```\\negrep \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n```\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492218,
                "title": "small-regex-100-faster",
                "content": "```\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 661297,
                "title": "valid-numbers",
                "content": "```\\nPlease find the solution : \\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n\\nExplaination : \\ngrep -P \\u2018^()\\n\\nWhat in these parentheses should come in the beginning.\\ngrep -P \\u2018^(\\\\d{3}-\\n\\\\d{3}  - means 3 digits should come in these parenthesis.\\nGrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\u2019\\n| = Means Or\\n\\\\(\\\\d{3}\\\\) )\\u2019 = \\\\d{3}\\\\ means it should contain 3 digit  and a space\\n\\ngrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\u2019\\n\\\\d{3}-\\\\d{4} = means 3 digits and 4 digits\\n\\n\\nReference : https://www.***.org/regular-expression-grep/",
                "solutionTags": [],
                "code": "```\\nPlease find the solution : \\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n\\nExplaination : \\ngrep -P \\u2018^()\\n\\nWhat in these parentheses should come in the beginning.\\ngrep -P \\u2018^(\\\\d{3}-\\n\\\\d{3}  - means 3 digits should come in these parenthesis.\\nGrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\u2019\\n| = Means Or\\n\\\\(\\\\d{3}\\\\) )\\u2019 = \\\\d{3}\\\\ means it should contain 3 digit  and a space\\n\\ngrep -P \\u2018^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\u2019\\n\\\\d{3}-\\\\d{4} = means 3 digits and 4 digits\\n\\n\\nReference : https://www.***.org/regular-expression-grep/",
                "codeTag": "Unknown"
            },
            {
                "id": 843424,
                "title": "bash-easy-one-liner",
                "content": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558581,
                "title": "bash-grep-bre-ere-pcre",
                "content": "Regular exrepssion (regex) has at least 3 official flavors: \\n1) basic regex (BRE)\\n2) extended regex (ERE)\\n3) perl-compatible regex (PCRE)\\n\\nThey share great resemblance and yet differ in details. Below implementation uses `grep` as an example which by default applies BRE. `-E` turns on ERE and `-P` turns on PCRE. \\n\\n```\\ngrep \"^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt # BRE\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |^[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"      file.txt # ERE\\ngrep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\"                   file.txt #PCRE\\n```",
                "solutionTags": [],
                "code": "```\\ngrep \"^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt # BRE\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |^[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"      file.txt # ERE\\ngrep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\"                   file.txt #PCRE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474498,
                "title": "this-solution-is-faster-than-100-00-of-bash-online-submissions-for-valid-phone-numbers",
                "content": "```\\negrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\negrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362277,
                "title": "simple-the-interviewer-who-asked-this-question-should-be-disqualified-from-interview-panel",
                "content": "Simple: the interviewer who asked this question should be disqualified from interview panel.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1477728,
                "title": "two-one-line-solution-grep-or-sed-unix-solution",
                "content": "grep (find the numbers which are matched, which is straight-forward):\\n```\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\\nsed (delete the numbers which are mismatched):\\n```\\nsed \\'/^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/!d\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\n```\\nsed \\'/^\\\\(([0-9]\\\\{3\\\\}) \\\\|[0-9]\\\\{3\\\\}-\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/!d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 380998,
                "title": "why-is-this-failing-when-it-works-locally",
                "content": "```\\ngrep -E -o \"\\\\((\\\\d{3})) \\\\d{3}-\\\\d{4}|\\\\d{3}-\\\\d{3}-\\\\d{4}\" file.txt\\n```\\n\\npasses 21/26 test cases but not \\n123-456-7891 ?",
                "solutionTags": [],
                "code": "```\\ngrep -E -o \"\\\\((\\\\d{3})) \\\\d{3}-\\\\d{4}|\\\\d{3}-\\\\d{3}-\\\\d{4}\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733675,
                "title": "grep-easy-pattern-matching",
                "content": "```\\n# GREP stands for Global search for Regular Expression and Print out\\n# grep [options] pattern [files]\\n# This is the syntax.\\n\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\nPlease **UpVote**, if you understood the code.",
                "solutionTags": [],
                "code": "```\\n# GREP stands for Global search for Regular Expression and Print out\\n# grep [options] pattern [files]\\n# This is the syntax.\\n\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468126,
                "title": "simplest-regex",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n#   ^ -> Start of the Line.\\n#   $ -> End of the Line.\\n#   ([0-9]) -> Value Range can be between 0 to 9.\\n#   ([0-9]{3}) -> Value Range can be between 0 to 9 and repeats three times.\\n#   (a | b) -> Possible values are a or b.\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n#   ^ -> Start of the Line.\\n#   $ -> End of the Line.\\n#   ([0-9]) -> Value Range can be between 0 to 9.\\n#   ([0-9]{3}) -> Value Range can be between 0 to 9 and repeats three times.\\n#   (a | b) -> Possible values are a or b.\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 834603,
                "title": "solution-0ms-100-3-1mb",
                "content": "```bash\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 87.19% of Bash online submissions for Valid Phone Numbers.\\negrep \"^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 87.19% of Bash online submissions for Valid Phone Numbers.\\negrep \"^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218882,
                "title": "193-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\n- grep command is used to search for a pattern in a file or files.\\n- -E option is used to enable extended regular expressions.\\n```\\n\\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' \\n``` \\nis the regular expression pattern that we want to match against each line in the file.\\n- ^ and $ are used to specify the beginning and end of the line respectively, to ensure that the entire line matches the pattern.\\n- \\\\( and \\\\) are used to match parentheses, which are escaped with backslashes because they have special meaning in regular expressions.\\n- [0-9]{3} is used to match exactly three digits.\\n- | is used to specify an alternative match, either a group of three digits surrounded by parentheses, followed by a space, or a group of three digits separated by a hyphen.\\n- file.txt is the name of the file that we want to search.\\n\\nThis regular expression matches phone numbers in the format (xxx) xxx-xxxx or xxx-xxx-xxxx.\\n\\nThe output of this one-liner bash script will be the list of valid phone numbers in the file.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n\\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' \\n```\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1154012,
                "title": "grep-p-solution",
                "content": "## Intro\\n\\nThis is a simple Perl RegEx solution. It requires no other commands. If additional challenges were added, this may become a bit too noisy as a one liner.\\n\\n## Solution\\n\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4}$\\' file.txt \\n```\\n\\n## Breakdown\\n\\nWe start off with the start of line (`^`) check. Without this, we could hit invalid entries that say start with other characters.\\n\\n`(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)` - This is a group selector inside the outer parentheses (`()`), which is primarily for the usage of the pipe (`|`) which is used as an or. So to break it down further:\\n\\n```\\n(\\n\\t\\\\(\\\\d{3}\\\\) \\n|\\n\\t\\\\d{3}-\\n)\\n```\\n\\nSo we have two different start of line options, only matching the two possibilities we have. The top one is selecting a literal open parantheses, 3 digits, and a literal closing parantheses, followed by a space. Using curly braces with a number inside can be used to represent how many of a given character prior should exist. So this says 3 `\\\\d` should exist. `\\\\d` is any digit, same as `[0-9]`.\\n\\nThe bottom searchers for 3 digits followed by a hyphen.\\n\\n```\\n\\\\d{3}\\\\-\\\\d{4}$\\n```\\n\\nWhat remains is 3 digits, a literal hyphen, and 4 digits, then end of line. We must anchor to the end of line using `$`, as sometimes there may be trailing whitespace or other characters.",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4}$\\' file.txt \\n```\n```\\n(\\n\\t\\\\(\\\\d{3}\\\\) \\n|\\n\\t\\\\d{3}-\\n)\\n```\n```\\n\\\\d{3}\\\\-\\\\d{4}$\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122020,
                "title": "short-solution-using-grep-with-explanation",
                "content": "**One-liner solution**\\n```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\\n\\n**^ symbol for must begin with, xxx- OR \\'(xxx) \\' quoted for space.**\\n```\\n^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)\\n```\\n\\n**$ symbol for must end with xxx-xxxx**\\n```\\n[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\n```\\n\\n**where x\\'s are digits**",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```\n```\\n^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)\\n```\n```\\n[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413833,
                "title": "grep-only-0ms-extended-regex-and-regex",
                "content": "```BASH\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 4 ms, faster than 55.11% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\|[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\)$\\' file.txt\\n```\\n\\n- https://www.gnu.org/software/grep/manual/grep.html\\n**-E**\\n**--extended-regexp**\\nInterpret patterns as extended regular expressions (EREs). (-E is specified by POSIX.)\\n\\n- https://www.zyxware.com/articles/4627/difference-between-grep-and-egrep\\n In egrep, +, ?, |, (, and ),  treated as meta characters. Where as in grep, they are rather treated as pattern instead of meta characters. By including \\'backslash\\' followed by meta character can let the grep to treat it as meta characters like \\\\?, \\\\+, \\\\{, \\\\|, \\\\(, and \\\\). \\n",
                "solutionTags": [],
                "code": "```BASH\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 0 ms, faster than 100.00% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n# https://leetcode.com/problems/valid-phone-numbers/submissions/\\n# Runtime: 4 ms, faster than 55.11% of Bash online submissions for Valid Phone Numbers.\\n# Memory Usage: 3.1 MB, less than 96.43% of Bash online submissions for Valid Phone Numbers.\\ngrep \\'^\\\\(([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\|[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\\\)$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55474,
                "title": "simple-solution-using-awk",
                "content": "```\\nawk '/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk '/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2722034,
                "title": "one-line-bash-solution",
                "content": "`grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt`",
                "solutionTags": [],
                "code": "`grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 1290845,
                "title": "awk-and-regex",
                "content": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4}|\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4}|\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038346,
                "title": "grep-regex",
                "content": "```\\ngrep -o \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -o \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276464,
                "title": "grep-solution-beats-100",
                "content": "A easy way to get it by using grep\\n\\n-E means use regular expression\\n\\n```\\ncat file.txt | grep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199579,
                "title": "one-line-grep-e",
                "content": "```\\ngrep -E  -e \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E  -e \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55492,
                "title": "my-grep-e-solution",
                "content": "    # Read from the file file.txt and output all valid phone numbers to stdout.\\n    \\n    # use grep -P\\n    grep -P '^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and output all valid phone numbers to stdout.\\n    \\n    # use grep -P\\n    grep -P '^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2562390,
                "title": "simple-sol-using-grep",
                "content": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259212,
                "title": "proper-grep-solution-with-standard-pcre-regex",
                "content": "Easy to understand what is going on.\\n\\nGrep flags used:\\n* \\t```-o``` for printing results in newline\\n* \\t```-P``` to enable standard PCRE regex matching followed by the regex expression.\\n\\n```\\ngrep -o -P \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```-o```\n```-P```\n```\\ngrep -o -P \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035332,
                "title": "grep-e",
                "content": "here is my code.\\nI use grep with extended RE.\\n`[0-9]{3}` means digit exactly 3 times\\n`^` is start of line\\n`$` is end of line\\n`|` is alternative\\n`()` are for grouping\\n`\\\\(` `\\\\)` are literally parentasis (not interpered as grouping)\\n```bash\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4}$)|^(\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4}$)|^(\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903384,
                "title": "grep-e-solution-with-regex",
                "content": "## grep -E Solution with regex\\n--- \\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604453,
                "title": "0ms-solution-100-faster",
                "content": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196980,
                "title": "sed-regex-1-liner-explanation",
                "content": "## Explanation\\nThe idea is to local certain pattern and print them out. `regex` is the perfect choice to locate the pattern. `sed` can be a easy to use helper here.\\n\\nThere are 2 patterns needed:\\n- For `123-456-7890`, we can use pattern like this\\n\\t- `^[0-9]{3}-[0-9]{3}-[0-9]{4}$`\\n\\t- Meaning starting with 3 digits (`^[0-9]{3}`), then a dash `-`, another 3 digits (`[0-9]{3}`) with a dash `-`, then ending with 4 digits (`[0-9]{4}$`)\\n- For `(123) 456-7890`, pattern will be like\\n\\t- `^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$`\\n\\t- Meaning starting with a open parenthesis `\\\\(` need to use back slash to escape, then 3 digits (`[0-9]{3}`) and a ending parenthesis `\\\\)`, then a space ` `, the rest will be similar to the first pattern\\n\\nIn `sed`:\\n- `-n`: is to silence the auto printout (default by `sed`)\\n- `-r`: is to use extended regex \\n\\n## Implementation\\n```bash\\n# Implementation with 2 patterns\\nsed -nr \\'/^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/p\\' file.txt\\n\\n# If we merge the similar part, the regex will be like\\nsed -nr \\'/(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\n# Implementation with 2 patterns\\nsed -nr \\'/^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/p\\' file.txt\\n\\n# If we merge the similar part, the regex will be like\\nsed -nr \\'/(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989190,
                "title": "grep-extended-regex",
                "content": "```\\ngrep -E \"^[0-9]{3}[-]{1}[0-9]{3}[-]{1}[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ {1}[0-9]{3}[-]{1}[0-9]{4}$\" file.txt",
                "solutionTags": [],
                "code": "```\\ngrep -E \"^[0-9]{3}[-]{1}[0-9]{3}[-]{1}[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ {1}[0-9]{3}[-]{1}[0-9]{4}$\" file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2953181,
                "title": "just-bash-regex",
                "content": "Using bash regex only.\\nRead a file line by line, first check the simple expression in case most of the phone numbers will be in a simpler format.\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nwhile read line; do if [[ $line =~ (^[0-9]{3}-[0-9]{3}-[0-9]{4}$) || $line =~ (^\\\\([0-9]{3}\\\\)[ ]{1}[0-9]{3}-[0-9]{4}$) ]]; then echo $line; fi; done < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nwhile read line; do if [[ $line =~ (^[0-9]{3}-[0-9]{3}-[0-9]{4}$) || $line =~ (^\\\\([0-9]{3}\\\\)[ ]{1}[0-9]{3}-[0-9]{4}$) ]]; then echo $line; fi; done < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709293,
                "title": "bash-one-liner",
                "content": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310460,
                "title": "bash-cat-grep",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"(^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3,3}\\\\) [0-9]{3}-[0-9]{4}$)\"\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"(^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3,3}\\\\) [0-9]{3}-[0-9]{4}$)\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950357,
                "title": "this-solution-can-not-be-more-uglier-but-hey-at-least-it-works-d",
                "content": "\\tpublic static boolean isValid(String num){\\n\\t\\t\\tnum.trim();\\n\\t\\t\\tString[] tokens0 = num.split(\" +\");\\n\\t\\t\\tif (tokens0.length == 3) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tString[] tokens = num.split(\"\\\\\\\\-\" );\\n\\t\\t\\tif (tokens.length == 3) {\\n\\t\\t\\t\\tif (tokens[0].length() == 3 && tokens[1].length() == 3 && tokens[2].length() == 4 && onlyDigits(tokens[0]) && onlyDigits(tokens[1]) && onlyDigits(tokens[2])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return false;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (tokens.length == 2) {\\n\\t\\t\\t\\tif (tokens[0].charAt(0) == \\'(\\' && tokens[0].charAt(4) == \\')\\'  && onlyDigits(tokens[0].substring(1 , 4)) && onlyDigits(tokens[0].substring(6)) && onlyDigits(tokens[1])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0 ; i < tokens.length ; i++) {\\n\\t\\t\\t\\tSystem.out.println(tokens[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic static boolean onlyDigits(String str) {\\n\\t\\t\\tfor (int i = 0; i < str.length(); i++) {\\n\\t\\t\\t\\tif (str.charAt(i) >= \\'0\\'\\n\\t\\t\\t\\t\\t\\t&& str.charAt(i) <= \\'9\\') return true;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic static boolean isValid(String num){\\n\\t\\t\\tnum.trim();\\n\\t\\t\\tString[] tokens0 = num.split(\" +\");\\n\\t\\t\\tif (tokens0.length == 3) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tString[] tokens = num.split(\"\\\\\\\\-\" );\\n\\t\\t\\tif (tokens.length == 3) {\\n\\t\\t\\t\\tif (tokens[0].length() == 3 && tokens[1].length() == 3 && tokens[2].length() == 4 && onlyDigits(tokens[0]) && onlyDigits(tokens[1]) && onlyDigits(tokens[2])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return false;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (tokens.length == 2) {\\n\\t\\t\\t\\tif (tokens[0].charAt(0) == \\'(\\' && tokens[0].charAt(4) == \\')\\'  && onlyDigits(tokens[0].substring(1 , 4)) && onlyDigits(tokens[0].substring(6)) && onlyDigits(tokens[1])) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0 ; i < tokens.length ; i++) {\\n\\t\\t\\t\\tSystem.out.println(tokens[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic static boolean onlyDigits(String str) {\\n\\t\\t\\tfor (int i = 0; i < str.length(); i++) {\\n\\t\\t\\t\\tif (str.charAt(i) >= \\'0\\'\\n\\t\\t\\t\\t\\t\\t&& str.charAt(i) <= \\'9\\') return true;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 619864,
                "title": "grep-e-approach-simplified",
                "content": "```\\ngrep -E \\'^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345439,
                "title": "grep-e-solution-is-pretty-straightforward-to-me-why-doesn-t-this-work-any-ideas",
                "content": "```\\ngrep -e \"\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\" -e \"(\\\\d\\\\d\\\\d) \\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\"\\n```\\n",
                "solutionTags": [],
                "code": "```\\ngrep -e \"\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\" -e \"(\\\\d\\\\d\\\\d) \\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315493,
                "title": "grep-e-solution",
                "content": "```grep -e \\'^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' -e \\'^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt```",
                "solutionTags": [],
                "code": "```grep -e \\'^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' -e \\'^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 307062,
                "title": "using-bash-regex",
                "content": "```\\n#!/usr/bin/env bash\\n\\nwhile read line; do\\n    if [[ \"$line\" =~ ^((\\\\([0-9]{3}\\\\) )|[0-9]{3}-)[0-9]{3}-[0-9]{4}$ ]]; then\\n        echo $line\\n    fi\\ndone < \"file.txt\"\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/env bash\\n\\nwhile read line; do\\n    if [[ \"$line\" =~ ^((\\\\([0-9]{3}\\\\) )|[0-9]{3}-)[0-9]{3}-[0-9]{4}$ ]]; then\\n        echo $line\\n    fi\\ndone < \"file.txt\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134523,
                "title": "why-is-grep-e-d-3-d-3-d-4-d-3-d-3-d-4-file-txt-wrong",
                "content": "```\\ngrep -E \\'^\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}$|^\\\\d{3}-\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\nError message:\\n\\n```\\nInput:\\n123-456-7891\\nExpected:\\n123-456-7891\\n```\\n\\n\\nHowever, the following works:\\n\\n```\\ngrep -E \\'^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nThe only difference is `[0-9]` instead of `\\\\d`.\\n\\nOn my laptop (macOS), both work.",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'^\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}$|^\\\\d{3}-\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\nInput:\\n123-456-7891\\nExpected:\\n123-456-7891\\n```\n```\\ngrep -E \\'^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519756,
                "title": "easy-and-simple-0-wow-0-0",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```\\nThis script uses grep command with extended regular expressions (-E) to match the pattern of valid phone numbers. The pattern matches either (xxx) xxx-xxxx or xxx-xxx-xxxx format. The ^ and $ characters are used to match the beginning and end of each line respectively13",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524504,
                "title": "simple-solution-with-grep-e-with-or-detail-explanation",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nFor detail explnation please refer:\\nhttps://leet-codes.blogspot.com/2022/09/193-valid-phone-numbers.html\\n",
                "solutionTags": [],
                "code": "```\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400775,
                "title": "one-line-grep-command",
                "content": "`grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt`",
                "solutionTags": [],
                "code": "`grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 2297326,
                "title": "regex-runtime-649-ms-faster-than-5-46-of-go-submissions",
                "content": "**Complexity Analysis**\\n* Time: O(N), where N is the number of lines within the file.txt.\\n* Space: O(1), constant number of variables used.\\n\\n```sh\\nfunction isValid()\\n{\\n  if [[ $1 =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  if [[ $1 =~ ^[(][0-9]{3}[)][[:space:]][0-9]{3}[-][0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  return $(false)\\n}\\n\\nIFS=$\\'\\\\n\\'\\nfor i in $(cat file.txt); do\\n  if isValid $i; then\\n    echo $i\\n  fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```sh\\nfunction isValid()\\n{\\n  if [[ $1 =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  if [[ $1 =~ ^[(][0-9]{3}[)][[:space:]][0-9]{3}[-][0-9]{4}$ ]]; then\\n    return $(true)\\n  fi\\n  return $(false)\\n}\\n\\nIFS=$\\'\\\\n\\'\\nfor i in $(cat file.txt); do\\n  if isValid $i; then\\n    echo $i\\n  fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2241958,
                "title": "one-line-solution-with-regex",
                "content": "Here is my solution:\\n\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\nor \\n\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112639,
                "title": "bash-easy-one-liner",
                "content": "https://leetcode.com/problems/valid-phone-numbers/discuss/843424/BASH-Easy-One-Liner\\n\\n```\\n1) grep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```\\n\\n```\\n2) grep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n```\\n3) egrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n1) grep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})$\\' file.txt\\n```\n```\\n2) grep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\n```\\n3) egrep \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713083,
                "title": "grep-runtime-4-ms-memory-usage-3-1-mb",
                "content": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -Po \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1413815,
                "title": "0ms-solution-100-faster",
                "content": "```grep -P \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" file.txt```",
                "solutionTags": [],
                "code": "```grep -P \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349446,
                "title": "egrep-solution-with-cat",
                "content": "```\\ncat file.txt | egrep  \"^((\\\\([0-9]{3}\\\\) )|([0-9]{3}-))[0-9]{3}-{0,1}[0-9]{4}$\"\\n```\\n",
                "solutionTags": [],
                "code": "```\\ncat file.txt | egrep  \"^((\\\\([0-9]{3}\\\\) )|([0-9]{3}-))[0-9]{3}-{0,1}[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239047,
                "title": "no-grep-solution-actually-works",
                "content": "It took me a while, as some attempts \"work on my machine\" but not here lol. I\\'m sure this can be simplified, but it took me a few hours to get this to work, so will stop here and see if anyone out there improves upon it. Using a slightly shorter regex, and even looking at SO examples, people seem to not care about a number formatted like so `(123 456-7890` where one of the parentheses was missing. It wasn\\'t part of the tested inputs, but I wanted to account for it as an exercise.\\n\\nSo, I just resorted to using the `|` (or) operator to check both formats. It was key to include `^$` both times as without it, the regex would match the number \"0(001...\".\\n\\n\\n```\\n#!/bin/bash\\n\\ncat file.txt | while read line\\ndo\\n  if [[ \"$line\" =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ [0-9]{3}-[0-9]{4}$ ]]; then\\n    echo $line\\n  fi  \\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ncat file.txt | while read line\\ndo\\n  if [[ \"$line\" =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\)\\\\ [0-9]{3}-[0-9]{4}$ ]]; then\\n    echo $line\\n  fi  \\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027254,
                "title": "grep-p",
                "content": "```grep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\" file.txt```",
                "solutionTags": [],
                "code": "```grep -P \"^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\" file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 703796,
                "title": "query-related-to-input",
                "content": "Can anyone tell me why this input is not valid \\n```(001)-345-0000```\\n\\nthis is my bash one liner\\n```grep -P \\'^(\\\\(?\\\\d{3}|\\\\d{3})\\\\)?[\\\\s|-]\\\\d{3}-\\\\d{4}$\\' file.txt```\\n\\nit also accepts the above number but gets an error saying it should not get accepted\\n",
                "solutionTags": [],
                "code": "```(001)-345-0000```\n```grep -P \\'^(\\\\(?\\\\d{3}|\\\\d{3})\\\\)?[\\\\s|-]\\\\d{3}-\\\\d{4}$\\' file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 576595,
                "title": "grep-e",
                "content": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n\\n",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 553002,
                "title": "mac-bash-or-linux-bash",
                "content": "At first, I use this code:\\n```\\ncat file.txt | grep -E \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\)\\\\ )\\\\d{3}-\\\\d{4}$\"\\n```\\nIt works in my mac bash shell, but failed for the submission.\\nThen I changed my code to below:\\n```\\ncat file.txt | grep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\)\\\\ )[0-9]{3}-[0-9]{4}$\"\\n```\\nThen passed...",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\)\\\\ )\\\\d{3}-\\\\d{4}$\"\\n```\n```\\ncat file.txt | grep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\)\\\\ )[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434768,
                "title": "solution-without-grep-awk-sed",
                "content": "```\\nwhile read LINE; do if [[ $LINE =~ (^\\\\([0-9]{3}\\\\)[[:blank:]][0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$) ]]; then echo $LINE; fi; done < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nwhile read LINE; do if [[ $LINE =~ (^\\\\([0-9]{3}\\\\)[[:blank:]][0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$) ]]; then echo $LINE; fi; done < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429265,
                "title": "trivial-awk-solution-probably-been-posted-before",
                "content": "```\\nawk -e \\'/^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/{ print; }\\' file.txt;\\n```",
                "solutionTags": [],
                "code": "```\\nawk -e \\'/^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/{ print; }\\' file.txt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399441,
                "title": "time-0ms-beats-100-with-memory-3-1-mb-simple-using-regex-grep",
                "content": "```\\ncat file.txt | grep -E \"(^[0-9]{3}-|^\\\\([0-9]{3}\\\\)\\\\s)[0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | grep -E \"(^[0-9]{3}-|^\\\\([0-9]{3}\\\\)\\\\s)[0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331165,
                "title": "grep-p-solution-using-conditional-regex-with-explanation",
                "content": "Conditional regular expressions are not always the most efficient solution. However, they _can_ be really useful in reducing the length of the regular expression by removing a long \"or\" statement with repeating elements. This is not one of those cases, but it\\'s a fun solution. The downside is that they are harder to read.\\n\\n```bash\\ngrep -xP \\'(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\\n\\n`(\\\\()?` - capture opening parenthesis at start as group 1, if it exists\\n`\\\\d{3}` - 3 digit area code\\n`(?(1)\\\\) |-)` - If an opening parenthesis was captured as group 1, grab a closing parenthesis followed by a space. Otherwise, look for a dash.\\n`\\\\d{3}-\\\\d{4}` - get the rest of the number.\\n\\nThis is effectively equivalent to \\n```bash\\ngrep -xP \\'(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```bash\\ngrep -xP \\'(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```\n```bash\\ngrep -xP \\'(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319401,
                "title": "egrep-solution",
                "content": "```\\ncat file.txt | egrep \\'^(\\\\([[:digit:]]{3}\\\\) |[[:digit:]]{3}-)[[:digit:]]{3}-[[:digit:]]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | egrep \\'^(\\\\([[:digit:]]{3}\\\\) |[[:digit:]]{3}-)[[:digit:]]{3}-[[:digit:]]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274502,
                "title": "egrep-solution",
                "content": "```bash\\ncat file.txt | egrep \\'^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\'\\n```",
                "solutionTags": [],
                "code": "```bash\\ncat file.txt | egrep \\'^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261478,
                "title": "fastest-awk-solution-8ms",
                "content": "```awk\\nawk \\'{if($0 ~ /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/ || $0 ~ /^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/){printf $0\"\\\\n\"}}\\' file.txt\\n```\\n\\nSimply processes each line and checks if the entire record (default newline separated) has exactly the needed formats specified and prints each line that does.",
                "solutionTags": [],
                "code": "```awk\\nawk \\'{if($0 ~ /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/ || $0 ~ /^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$/){printf $0\"\\\\n\"}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182286,
                "title": "grep",
                "content": "Never use solutions like these.\nDebugging this would be hell.\n```\ngrep \"^\\(\\([0-9]\\{3\\}-\\)\\|\\(([0-9]\\{3\\})\\s\\)\\)[0-9]\\{3\\}-[0-9]\\{4\\}$\" file.txt\n```",
                "solutionTags": [],
                "code": "```\ngrep \"^\\(\\([0-9]\\{3\\}-\\)\\|\\(([0-9]\\{3\\})\\s\\)\\)[0-9]\\{3\\}-[0-9]\\{4\\}$\" file.txt\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55477,
                "title": "whereis-wrong-with-my-pattern-ask-for-help",
                "content": "my grep solution, the code is like:\\n```\\ngrep \"\\\\(?\\\\d{3}\\\\)?[- ]\\\\d{3}-\\\\d{4}\" file.txt\\n```\\nbut when it came across test case \"123-456-7891\", it didn't print out anything. could someone tell me why please?\\nYet I put test case \"123-456-7891\" into a file, and open it with notepad++ on windows, using the same pattern to find matched lines, and it worked! That really makes me confused",
                "solutionTags": [],
                "code": "```\\ngrep \"\\\\(?\\\\d{3}\\\\)?[- ]\\\\d{3}-\\\\d{4}\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55498,
                "title": "wrong-output-of-shell-question-valid-phone-number",
                "content": "For Shell Question \"valid phone number\", I submitted the below code: \\n\\n     while read LINE\\n     do\\n         if [[ $LINE =~ \"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" ]] || [[ $LINE =~ \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\" ]]; then\\n             echo $LINE\\n         fi\\n     done < 'file.txt'\\n\\nFinally, Leetcode judge my code to wrong output by one input \"123-456-7891\".\\nHowever, such input can be pass from my own test.\\n\\n    ytjiang@xxxxx:~/code_practice % sh ValidPhoneNumber.sh\\n    123-456-7891\\n\\nReally wired me....\\n\\nThanks in advance!",
                "solutionTags": [],
                "code": "For Shell Question \"valid phone number\", I submitted the below code: \\n\\n     while read LINE\\n     do\\n         if [[ $LINE =~ \"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\" ]] || [[ $LINE =~ \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\" ]]; then\\n             echo $LINE\\n         fi\\n     done < 'file.txt'\\n\\nFinally, Leetcode judge my code to wrong output by one input \"123-456-7891\".\\nHowever, such input can be pass from my own test.\\n\\n    ytjiang@xxxxx:~/code_practice % sh ValidPhoneNumber.sh\\n    123-456-7891\\n\\nReally wired me....\\n\\nThanks in advance!",
                "codeTag": "Unknown"
            },
            {
                "id": 4077522,
                "title": "it-was-easy",
                "content": "\\u0628\\u0633\\u0645 \\u0627\\u0644\\u0644\\u0647 \\u0627\\u0644\\u0631\\u062D\\u0645\\u0646 \\u0627\\u0644\\u0631\\u062D\\u06CC\\u0645\\n## hello guys!\\nIt was really easy :) . am I rigth?\\nIt was only necessary to use the **`grep`** command and to know **Regex**.\\nu should have written something like this command :\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\nGod bless you and have nice time my friend !!",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076529,
                "title": "bash-script-to-extract-and-print-valid-phone-numbers-from-a-text-file",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find and print valid phone numbers from a text file. We need to define the patterns for valid phone numbers and extract them from the file.\\n\\n\\n# ApproachSpace complexity: The space complexity is constant, as it does not depend on the size of the input file. Therefore, the space complexity is O(1).\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use the grep command with regular expressions to match and extract valid phone numbers from the text file.\\nWe define two regular expressions to match two formats: (xxx) xxx-xxxx and xxx-xxx-xxxx.\\nThe -E option enables extended regular expressions.\\nWe use ^ to match the start of the line and $ to match the end of the line to ensure that we capture complete phone numbers.\\nWe use \\\\( and \\\\) to match parentheses and [0-9]{3} to match exactly three digits.\\nWe use [0-9]{4} to match exactly four digits.\\nThe | character is used to match either of the two formats.\\nFinally, we specify the input file as file.txt to search for valid phone numbers in it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n The grep command operates in linear time based on the size of the input file, making it efficient for large files. So, the time complexity is O(n), where n is the size of the input file.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is constant, as it does not depend on the size of the input file. Therefore, the space complexity is O(1).\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024485,
                "title": "one-line-solution-with-grep-99-5-performance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCommand checks two pattern in regex\\n1. `xxx-xxx-xxxx`\\n2. `(xxx) xxx-xxxx`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023972,
                "title": "simple-grep-and-regex-with-explanation-95-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe most straight forward approach would be to use grep. grep already knows how to handle multilines so no special treatment required. Next is to just figure out a pattern.\\n\\nThe latter half of the number format share a common pattern, so it should allow me to combine the patterns into a single pattern with a `|` \\'or\\' operator\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first iteration omitted the line beginning/ending, which caught me off guard when the number is invalid when there are more numbers at the ends of it.\\n\\nSome considerations involve which flavor of grep do we want to use?\\nHow complex do we want our code?\\nDo we want to try fix broken formatted numbers?\\n\\nin the end, KISS applies\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ as each line is evaluated just once\\n\\n- Space complexity: $$O(1)$$ you only store matches, at most you\\'d store two copy of the same file in memory\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```\\n`-o` returns only pattern without the full line. It\\'s moot here since the whole line is to be matched, but would be handy if the phone number is hidden between other text.\\n\\n`-E` just enables the extended regex (ERE). See [difference](https://www.gnu.org/software/sed/manual/html_node/BRE-vs-ERE.html) of Basic Regular Expressions (BRE) vs Extended Regular Expressions (ERE). **TL;DR** ERE is more readable and you end up with less `\\\\`.\\n\\n# [Regex Explanation](regexr.com/7jt1e)",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -oE \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004162,
                "title": "bash-simple-solution-grep",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```\\n\\n",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962899,
                "title": "one-liner-bash-command-to-get-valid-phone-numbers-with-minimum-complexity",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis script uses grep with the -E flag to enable extended regular expressions. The regular expression used in the script matches either of the valid phone number formats you mentioned. It uses the ^ and $ anchors to match the entire line, ensuring that there are no leading or trailing characters. \\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n\\n```\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938487,
                "title": "using-bash-pattern-matching",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\nIFS=\\'\\n\\'\\nwhile read -r phone; do\\n\\tcase \"$phone\" in\\n\\t\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n\\t\\t\\tprintf \\'%s\\\\n\\' \"$phone\"\\n\\t\\t\\t;;\\n\\tesac\\ndone < file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\nIFS=\\'\\n\\'\\nwhile read -r phone; do\\n\\tcase \"$phone\" in\\n\\t\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n\\t\\t\\tprintf \\'%s\\\\n\\' \"$phone\"\\n\\t\\t\\t;;\\n\\tesac\\ndone < file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926378,
                "title": "simple-shell-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n    \\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n    \\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9])\\n        echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926363,
                "title": "simple-shell-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]) echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read -r w; do\\n\\tcase \"$w\" in\\n\\t[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]|\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]) echo \"$w\" ;;\\n\\tesac\\ndone <file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919277,
                "title": "using-awk-command",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nawk \\'/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nawk \\'/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900004,
                "title": "bash",
                "content": "`grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4} file.txt`",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "`grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}\\\\-\\\\d{4} file.txt`",
                "codeTag": "Unknown"
            },
            {
                "id": 3892269,
                "title": "bash-with-regular-expression-and-grep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n#!/bin/bash\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n#!/bin/bash\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881004,
                "title": "faster-than-99-54",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855494,
                "title": "bash-expected-solution-grep-and-regex",
                "content": "# Solution\\n```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -e \"^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833012,
                "title": "grep-regex-full-regex-step-by-step-explanation",
                "content": "# Approach\\n`grep` is a CLI tool that can be used to extract text from a file (among other things) that matches a regular expression (RegEx).\\n\\nFirst, `grep` can be used like `grep -E \\'\\' file.txt` where the regular expression goes inside the `\\'\\'`.\\n\\nTo denote that the full string is matched, `^` and `$` is used to denote start of the string and end of the string respectively. So regex is now `^$`.\\n\\nEach `x` represents a digit, which is `[0-9]` in RegEx. `xxx` denotes exactly 3 digits, which can be represented as `[0-9]{3}` in Regex, while `-` and ` ` can be matched by `-` and ` ` respectively. Also `(` and `)` can be matched by `\\\\(` and `\\\\)` (`(` and `)` need to be escaped using the `\\\\` as without escaping, they represent a group in RegEx).\\n\\nSo `xxx-xxx-xxxx` can be matched by `^[0-9]{3}-[0-9]{3}-[0-9]{4}$` and `(xxx) xxx-xxxx` can be matched by `^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$`.\\n\\nCombining these with an OR gives the final regex as:\\n`^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$`\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807278,
                "title": "bash-egrep",
                "content": "```\\n#!/bin/bash\\n\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/bash\\n\\negrep \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3792036,
                "title": "simple-solution-using-grep-extended-and-regex",
                "content": "# Intuition\\nTo output patterns that matches either of the two cases, we can use regex for pattern matching and grep.\\n\\n# Aproach\\nIn both the cases, the last part of the pattern matching requires \\n1. number `0-9` 3 times - `[0-9]{3}`\\n2. then a `-` \\n3. and then `0-9` 4 times - `[0-9]{4}`\\n4. followed by the end of the line - `dollar sign`.\\n\\nRegex for this would be `[0-9]{3}-[0-9]{4}$`.\\n\\nFor the first part of the pattern, the pattern is either - `\\\\([0-9]{3}\\\\) ` or `[0-9]{3}-`. Start of the line is denoted by `^`\\n\\nThis can be expressed in regex as  `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`\\n\\n\\n# Code\\nFinal regex is the combination of the two regex. We will be using extended grep (by using -E) as the normal grep command does not support some of the regex used here.\\n\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791792,
                "title": "one-line-solution-using-grep-command",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\nin this script uses grep command with (-E) treats as an extended regular expression. it is used for matching the pattern of valid phone numbers.So by this the pattern matches to the (123) 456_7890 or 987-123-4567 format. ^ used for match the beginning and $ used for end of line respectively. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740773,
                "title": "beats-70-online-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706732,
                "title": "valid-phone-numbers-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep -o \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep -o \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3701455,
                "title": "using-grep-p",
                "content": "# Code\\n```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691134,
                "title": "beats-100-and-detailed-explanation",
                "content": "# Intuition\\nThe one-liner bash script aims to extract and print all valid phone numbers from a given text file.\\n\\n# Approach\\nThe one-liner script utilizes the `grep` command with extended regular expression support to extract valid phone numbers from a text file.\\n\\n- `grep -E`: Invokes `grep` with extended regular expression support.\\n- `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`: This part of the pattern matches either \"(xxx) \" or \"xxx-\" at the beginning of a line.\\n- `[0-9]{3}-[0-9]{4}$`: This part matches \"xxx-xxxx\" at the end of a line.\\n- `file.txt`: Represents the input file from which valid phone numbers will be extracted.\\n\\nBy running this one-liner script, it will print all valid phone numbers that match the specified formats from the `file.txt` input file.\\n\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of lines in the input file.\\n- Space complexity: O(1), as the script uses a constant amount of additional space.\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "# Intuition\\nThe one-liner bash script aims to extract and print all valid phone numbers from a given text file.\\n\\n# Approach\\nThe one-liner script utilizes the `grep` command with extended regular expression support to extract valid phone numbers from a text file.\\n\\n- `grep -E`: Invokes `grep` with extended regular expression support.\\n- `^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)`: This part of the pattern matches either \"(xxx) \" or \"xxx-\" at the beginning of a line.\\n- `[0-9]{3}-[0-9]{4}$`: This part matches \"xxx-xxxx\" at the end of a line.\\n- `file.txt`: Represents the input file from which valid phone numbers will be extracted.\\n\\nBy running this one-liner script, it will print all valid phone numbers that match the specified formats from the `file.txt` input file.\\n\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of lines in the input file.\\n- Space complexity: O(1), as the script uses a constant amount of additional space.\\n\\n# Code\\n```bash\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3675921,
                "title": "bash",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})\\n``` ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669706,
                "title": "two-short-accepted-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` bash []\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n# grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```\\n\\n``` bash []\\n# grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "``` bash []\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n# grep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```\n``` bash []\\n# grep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660167,
                "title": "mine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659229,
                "title": "use-sed",
                "content": "# Intuition\\nUse `sed`\\n\\n# Approach\\n`BSD sed` accepts a `-E` option for specifying extended (modern) regular expressions.\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(mn)$ - $m, n$ are the maxlength of lines in the file, and number of lines in the file\\n\\n- Space complexity:\\n$O(m)$ - `sed` processes a line of input file at a time held within its memory\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n -E \\'/^(([0-9]{3}-[0-9]{3}-[0-9]{4})|([(][0-9]{3}[)] [0-9]{3}-[0-9]{4}))$/p\\' file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n -E \\'/^(([0-9]{3}-[0-9]{3}-[0-9]{4})|([(][0-9]{3}[)] [0-9]{3}-[0-9]{4}))$/p\\' file.txt\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615463,
                "title": "valid-phone-numbers-intuition-with-image",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![2023-06-09_03-41-45.png](https://assets.leetcode.com/users/images/f47f81e2-c687-4d76-83a2-687590a0cc53_1686262419.4819312.png)\\n\\n\\n# Code\\n```\\ngrep -P \\'^(\\\\([\\\\d]{3}\\\\) |[\\\\d]{3}-)[\\\\d]{3}-[\\\\d]{4} file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\([\\\\d]{3}\\\\) |[\\\\d]{3}-)[\\\\d]{3}-[\\\\d]{4} file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612561,
                "title": "bash-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596986,
                "title": "using-regular-expression-matching-operator-bash-hyder-nabi",
                "content": "# Steps: \\n1. Read the input file line by line.\\n2. For each line X\\n    a. Match the line againest the pattern using =~ operator\\n    b. Print the line if match was successful\\n    c. Skip otherwise.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NoOfLines))$$\\n- Assuming the comparison takes $$O(1)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\nwhile read line; do\\n\\tif [[ $line =~ $pattern ]]\\n\\tthen\\n\\t\\techo $line;\\n\\tfi\\ndone < $file;\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\"\\nwhile read line; do\\n\\tif [[ $line =~ $pattern ]]\\n\\tthen\\n\\t\\techo $line;\\n\\tfi\\ndone < $file;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544077,
                "title": "egrep-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \\'(^[0-9]{3}-|^\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529042,
                "title": "valid-phone-number-with-grep-and-regex-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI wanted to read the file line by line but then I realised that this could be solved more easily through regex.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt was a lot of trial and errors because I could not see the tests to prepare my regex for it, after strugling for a while I took a look at some solutions and it helped me compose mine a lot better, for some reason using -P the Perl regex parsing method worked better than the -E Extended regex mode.\\n\\n# Explanation\\n\\nREGEX `^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$`\\n\\nThe first part `^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$` to catch `987-123-4567`\\n\\n- `^` it must begin with what comes after this sign\\n- `[\\\\d]{3}` grabs the first 3 digits\\n- `-[\\\\d]{3}` grabs 3 more digits, with a -\\n- `-[\\\\d]{4}` grabs the last 4 digits with a -\\n- `DOLLAR SIGN` it must end with what came before this sign\\n\\nThe second part `^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}DOLLAR SIGN` to catch `(123) 456-7890`\\n\\n- `^` it must begin with what comes after this sign\\n- `\\\\(\\\\d{3}\\\\)` grabs the first 3 digits in between `(`, `)`\\n- `\\\\s` adds a white space\\n- `[\\\\d]{3}` grabs 3 more digits\\n- `-[\\\\d]{4}` grabs the last 4 digits with a -\\n- `DOLLAR SIGN` it must end with what came before this sign\\n\\n\\n# Code\\n```sh\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \"^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$\" file.txt \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```sh\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \"^[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}$|^\\\\(\\\\d{3}\\\\)\\\\s[\\\\d]{3}-[\\\\d]{4}$\" file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516737,
                "title": "a-simple-grep-approch-with-regexp",
                "content": "# Intuition\\nUsing a simple grep with regexp\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\ngrep -E \"^(\\\\([0-9]{3}\\\\)\\\\s{1}|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3511116,
                "title": "grep-one-liner-for-personal-note",
                "content": "- `.` - matches any single character except a newline.\\n- `^` - matches the start of a line.\\n- `$` - matches the end of a line.\\n- `*` - matches zero or more occurrences of the previous character or pattern.\\n- `+` - matches one or more occurrences of the previous character or pattern.\\n- `?` - matches zero or one occurrence of the previous character or pattern.\\n- `{m}` - matches exactly `m` occurrences of the previous character or pattern.\\n- `{m,n}` - matches between `m` and `n` occurrences of the previous character or pattern.\\n- `[abc]` - matches any of the characters `a`, `b`, or `c`.\\n- `[^abc]` - matches any character except `a`, `b`, or `c`.\\n- `[a-z]` - matches any character between `a` and `z`.\\n- `(` and `)` - used for grouping patterns together.\\n- `|` - used to specify alternatives between patterns.\\n- `\\\\` - used to escape a special character or to give special meaning to a character.\\n\\n# Code\\n```bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505123,
                "title": "bash-grep-regex",
                "content": "# Intuition\\nUse grep with a regular expression.\\n\\n# Approach\\nUse grep with a regular expression.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\ngrep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \"^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490365,
                "title": "unique-solution-with-while-loop",
                "content": "##### Complexity \\nSee this image for reference\\n\\n![Uq.jpg](https://assets.leetcode.com/users/images/79b2042e-1ec6-4052-b802-b48d25982efd_1683309341.9463682.jpeg)\\n\\n\\n# Code\\n```Bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```Bash\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474368,
                "title": "solution",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}) file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}) file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473779,
                "title": "your-mother",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI sucked monkey. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBecome a monkey. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n) runtime because it\\'s too big brain for you clowns.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nNo space complexity because it\\'s too complex for your tiny brains.\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngrep -Po \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngrep -Po \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3460156,
                "title": "laconic-solution-of-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUtilize RegExp\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRegular expression\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n90ns\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n3.0 mb\\n# Code\\n```\\ngrep -Po \"^(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\\\b\" ./file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -Po \"^(\\\\()?\\\\d{3}(?(1)\\\\) |-)\\\\d{3}-\\\\d{4}\\\\b\" ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453539,
                "title": "one-line-bash-command",
                "content": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3451451,
                "title": "with-explanation",
                "content": "https://leetcode.com/problems/valid-phone-numbers/solutions/3218882/193-solution-step-by-step-explanation/ \\n\\nplease check for more explanation\\n\\n# Approach\\n^ and $ are used to specify the beginning and end of the line respectively, to ensure that the entire line matches the pattern. - ( and ) are used to match parentheses, which are escaped with backslashes because they have special meaning in regular expressions. - [0-9]{3} is used to match exactly three digits. - | is used to specify an alternative match, either a group of three digits surrounded by parentheses, followed by a space, or a group of three digits separated by a hyphen. - file.txt is the name of the file that we want to search. This regular expression matches phone numbers in the format (xxx) xxx-xxxx or xxx-xxx-xxxx. The output of this one-liner bash script will be the list of valid phone numbers in the file.\\n\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3402595,
                "title": "oneline-bash-command",
                "content": "\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3396239,
                "title": "bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389178,
                "title": "valid-phone-num-bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370702,
                "title": "193-valid-phone-numbers",
                "content": "# Intuition\\nThe problem requires us to extract all valid phone numbers from a text file, where a valid phone number is defined as a number in either (xxx) xxx-xxxx or xxx-xxx-xxxx format. The task is to write a one-liner bash script that can extract all valid phone numbers from the file.\\n\\n# Approach\\nThe approach involves using the grep command with extended regular expression syntax (-E option) to match lines that start with either (xxx) or xxx-, followed by three digits, a hyphen, and then four digits. The ^ and $ characters anchor the expression to the beginning and end of each line. The | character inside the parentheses matches either (xxx) or xxx-.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the program is O(n), where n is the total number of characters in the input file. This is because grep processes each line of the file only once, and its time complexity is proportional to the number of characters in the line.\\n\\n- Space complexity:\\nThe space complexity of the program is O(1), because it doesn\\'t require any extra space beyond the input file and the memory used by the grep command. The grep command works on a line-by-line basis and doesn\\'t store the entire input file in memory at once.\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368147,
                "title": "single-line-use-grep",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364420,
                "title": "code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341072,
                "title": "simple-regex-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Just simple Regex \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> -\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> - \\n \\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}$|^[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336424,
                "title": "grep-p-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nm)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326851,
                "title": "using-gawk-to-solve-this-problem-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$0 prints the entire input if it pass the testcase.\\ninput is each new line from the file.\\n\\nTips:\\nYou have to escape parenthesis using backslash \\\\\\n{3} means 3 occurence.\\n[0-9] is the range\\nand (apple|mango) means either apple or mango.\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngawk --re-interval \\'/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/{print $0}\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\ngawk --re-interval \\'/^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/{print $0}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3310752,
                "title": "one-line",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285570,
                "title": "sed-easy-solution-1-line-solution-easy-explanation",
                "content": "\\n# Code\\n```\\n sed -n \\'/^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)[[:digit:]]\\\\{3\\\\}-[[:digit:]]\\\\{4\\\\}$/p\\' file.txt\\n```\\n# Explanation\\n- ```-n``` supress the default printing behaviour of sed.\\n\\n- ```^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)``` \\'XXX \\' or \\'(XXX)\\'\\n     - ```^\\\\(<pattern 1>\\\\|\\\\(<pattern 2>\\\\)\\\\)``` should start with this pattern.\\n- ```\\\\([[:digit:]]\\\\)\\\\{3\\\\}-``` \\'XXX-\\'\\n- ```[[:digit:]]\\\\{4\\\\}``` \\'XXX\\'\\n- ```$``` represents the End of the Line\\n- ```(/<Regular expression pattern>/p)``` syntax for sed command to print the matched RE.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n sed -n \\'/^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)[[:digit:]]\\\\{3\\\\}-[[:digit:]]\\\\{4\\\\}$/p\\' file.txt\\n```\n```-n```\n```^\\\\([[:digit:]]\\\\{3\\\\}-\\\\|([[:digit:]]\\\\{3\\\\}) \\\\)```\n```^\\\\(<pattern 1>\\\\|\\\\(<pattern 2>\\\\)\\\\)```\n```\\\\([[:digit:]]\\\\)\\\\{3\\\\}-```\n```[[:digit:]]\\\\{4\\\\}```\n```$```\n```(/<Regular expression pattern>/p)```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276839,
                "title": "193-valid-phone-numbers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3244342,
                "title": "one-liner-with-explanation",
                "content": "# How it\\'s works\\n\\n- The grep command is used to search for lines in `file.txt` that match a regular expression.\\n\\n- The regular expression used in the command matches two possible formats for a valid phone number:\\n\\n- The phone number starts with an opening parenthesis, followed by three digits, a closing parenthesis, a space, three digits, a dash, and four digits.\\n\\n- The phone number starts with three digits, a dash, three digits, a dash, and four digits.\\nThe `-E` option is used to enable extended regular expressions.\\n\\n- The `^` and `$` symbols are used to ensure that the regular expression matches the entire line (i.e., the phone number must be the only thing on the line).\\n\\n- The | symbol is used to allow either the (xxx) xxx-xxxx or xxx-xxx-xxxx format to match.\\n\\n\\n\\n# Code\\n```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3219386,
                "title": "some-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"(^\\\\([0-9]{3}\\\\) |^[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \"(^\\\\([0-9]{3}\\\\) |^[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209903,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}\\\\-[0-9]{4}|[0-9]{3}\\\\-[0-9]{3}\\\\-[0-9]{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169534,
                "title": "sed-regex",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n \\'/^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\|^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\nsed -n \\'/^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\|^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$/p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162746,
                "title": "easy-method-100-faster-one-linear",
                "content": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3157858,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -o \\'\\\\(^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\\\|\\\\(^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -o \\'\\\\(^[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\\\|\\\\(^([0-9]\\\\{3\\\\})\\\\s[0-9]\\\\{3\\\\}\\\\-[0-9]\\\\{4\\\\}$\\\\)\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133940,
                "title": "very-easy-soln",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132608,
                "title": "easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-\\\\d{3}-\\\\d{4}|\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125290,
                "title": "clean-code-high-speed-beats-98-9",
                "content": "# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3121902,
                "title": "accepted-bash",
                "content": "```\\ncat file.txt | grep -E \"^[[:digit:]]{3}-[[:digit:]]{3}-[[:digit:]]{4}$|^\\\\([[:digit:]]{3}\\\\) [[:digit:]]{3}-[[:digit:]]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | grep -E \"^[[:digit:]]{3}-[[:digit:]]{3}-[[:digit:]]{4}$|^\\\\([[:digit:]]{3}\\\\) [[:digit:]]{3}-[[:digit:]]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107103,
                "title": "readable-bash-solution-with-an-explanation",
                "content": "# Intuition\\nWe need a way to read out a file\\'s contents with applied filtering on a line basis. \\n\\n * *cat* short for concatenate (verb, to join or link together, as though in a chain) is a program to read one or multiple files and print them on the standard output of the terminal.\\n example:\\n ```\\n $ cat file.txt\\n987-123-4567\\n123 456 7890\\n(123) 456-7890\\n```\\n * *grep* is the second piece of the puzzle. It is a program that takes whatever is passed to it and applies user supplied filtering in the form of *regular expressions* to each line.\\n ```\\n$ grep \\'foobar\\'\\nfoobarbaz # user input, must finish with a new line, Enter key\\nfoobarbaz # grep says it is a match\\nnotfoo # user input and no match (does not get printed twice)\\nnotbar # user input, no match\\nnotfoobar # user input\\nnotfoobar # grep matches it\\n# hit Ctrl+D to exit from grep\\n$ \\n```\\nNow let\\'s filter based on the formats in the problem description.\\n\\nThe first  pattern is `xxx-xxx-xxxx`, where `x` is any digit from 0 to 9. By default, grep understands only basic regular expressions, you can read up on what exactly that is by typing `man grep` inside a terminal. If we want the full regex experience we have to supply the `-P` flag, denoting that we want to use Perl flavoured regular expressions. We do this so we can use `\\\\d` to denote a digit, which grep wouldn\\'t understand otherwise.\\n\\nSo our first pattern would be \\n`^\\\\d{3}-\\\\d{3}-\\\\d{4}$`<br><br>\\n\\nIt reads as the following - 3 digits, followed by a hyphen `-` and 3 more digits, followed by a hyphen `-` and 4 more digits. The caret symbol `^` and the dollar `$` denote that we want that to be the full line. Caret means match the match has to begin from the first symbol on the line, and dollar means that it should be the last as well. In other words nothing should follow or preceed it.\\n\\nOur second pattern should match `(xxx) xxx-xxxx`, so the regex would look something like this:\\n`\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}`\\n\\nNote the escaping of the brackets with `\\\\(`, we do this because `(` is a special symbol for grouping things, so we have to escape it.\\n\\nThe last problem that we have to solve is to write a single regular expression that matches our first pattern *OR* our second one. we can do this like so - `(foo|bar)` this would either foo or bar.\\n\\nSo our final expression would look like this:\\n\\n`grep -P \"(\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})|\\\\d{3}-\\\\d{3}-\\\\d{4}\"`\\n\\n\\n\\nNow we need a way to combine *cat* and *grep*. In the terminal world, we use *pipes*, denoted by the `|` symbol. What piping does is that it feeds the output of one command to the next, like making a real pipe. We want to feed *grep* the output of `cat file.txt`:\\n`cat file.txt | grep -P \"(\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4})|\\\\d{3}-\\\\d{3}-\\\\d{4}\"`\\n\\nTo make things more readable I like to extract the simple subpatterns inside bash variables, and so we come to our\\n\\n# Final Solution\\n```\\npattern_one=\\'\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}\\'\\npattern_two=\\'\\\\d{3}-\\\\d{3}-\\\\d{4}\\'\\ncat file.txt | grep -P \"^($pattern_one|$pattern_two)$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n $ cat file.txt\\n987-123-4567\\n123 456 7890\\n(123) 456-7890\\n```\n```\\n$ grep \\'foobar\\'\\nfoobarbaz # user input, must finish with a new line, Enter key\\nfoobarbaz # grep says it is a match\\nnotfoo # user input and no match (does not get printed twice)\\nnotbar # user input, no match\\nnotfoobar # user input\\nnotfoobar # grep matches it\\n# hit Ctrl+D to exit from grep\\n$ \\n```\n```\\npattern_one=\\'\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}\\'\\npattern_two=\\'\\\\d{3}-\\\\d{3}-\\\\d{4}\\'\\ncat file.txt | grep -P \"^($pattern_one|$pattern_two)$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095416,
                "title": "worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090510,
                "title": "80-beat-simple-validation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069619,
                "title": "trivial-beats-100",
                "content": "\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -E \\'^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068129,
                "title": "valid-phone-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\nfile=\"file.txt\"\\n\\nwhile read -r line; do\\n    format1=\\'(^([0-9]{3})[-][0-9]{3}[-]([0-9]{4})$)\\'\\n    format2=\\'^(\\\\([0-9]{3}\\\\)[ ][0-9]{3}[-]([0-9]{4})$)\\'\\n    if [[ $line =~ $format1 || $line =~ $format2 ]];then\\n        echo $line\\n    fi\\ndone <$file\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\nfile=\"file.txt\"\\n\\nwhile read -r line; do\\n    format1=\\'(^([0-9]{3})[-][0-9]{3}[-]([0-9]{4})$)\\'\\n    format2=\\'^(\\\\([0-9]{3}\\\\)[ ][0-9]{3}[-]([0-9]{4})$)\\'\\n    if [[ $line =~ $format1 || $line =~ $format2 ]];then\\n        echo $line\\n    fi\\ndone <$file\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056937,
                "title": "valid-phone-numbers-bash-solution",
                "content": "One Liner Bash Solution\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042657,
                "title": "grep-p-d-3-d-3-d-3-d-4-file-txt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe grep code has four parts in it as the valid phone number can be constructed using the possible combiantion of any three from the below four parts.\\n\\n1. ^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) ) ---> valid phone number can start ^(... either with \\n\\\\d{3}- --> 3 digits and - or (|) #2\\n2.  \\\\(\\\\d{3}\\\\) ) --> (3 digits and one space)\\n3. d{3}- --> 3 digits and a dash\\n4. d{4} --> 4 digits \\n\\nAny combination of above 1,3,4 or 1,2,4 is a valid phone number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011494,
                "title": "one-line-grep-with-shortest-regex",
                "content": "# Code\\n```\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n```\\n\\n## Regex explain\\n\\nStart with `999-` or `(999) ` followed by `999-9999` then end line. Where `9` means numbers from `0` to `9`.\\n\\n`^` - Start line\\n`()` - Group expression\\n`\\\\d` - any number 0 to 9\\n`{n}` - repeat expression n times\\n`|` - or operator\\n`$` - Finish line",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3006820,
                "title": "grep-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by using a regular expression to match valid phone numbers in a file.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach to this problem is to use the grep command and a regular expression to search for valid phone numbers in the file.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis will depend on the implementation of grep and the size of the file. In general, the time complexity of grep is linear with respect to the size of the input.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis will also depend on the implementation of grep and the size of the file. In general, the space complexity of grep is linear with respect to the size of the input.\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2988675,
                "title": "bash-valid-phone-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use `grep` to search the a particular pattern of characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermined the regex of the valid phone numbers then use the `grep` to filter them\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n``` file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\ngrep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981642,
                "title": "pure-posix-compliant-shell-solution-without-external-commands-beats-99-89",
                "content": "# Approach\\n\\nPure POSIX shell without calls to external commands. This will work not only on Bash, but virtually any POSIX-compliant shell going back to the 80s.\\n\\nIn addition, despite being marginally slower (beats 99.89%) than what some other users have reported out of grep solutions, this is actually significantly faster than any of those solutions due to the fact that calls to external commands require the shell to fork.\\n\\nAs such, this can be as much as ~50x faster than grep.\\n\\n# Code\\n```\\n#!/bin/sh\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n\\n```\\n\\n# Benchmarks\\n\\n* zsh = Homebrew zsh 5.9.0.1-dev\\n* bash5 = Homebrew Bash 5.2.2\\n* bash3 = Apple\\'s Bash 3.2.57\\n* dash = pkgsrc Debian Almquist shell\\n* yash = pkgsrc yash\\n* bosh = pkgsrc Schily bosh\\n* pbosh = pkgsrc Schily pbosh\\n* mksh = pkgsrc MirBSD Korn Shell\\n* oksh = pkgsrc OpenBSD Korn Shell\\n* pdksh = pkgsrc Public Domain Korn Shell\\n* ksh93 = pkgsrc AT&T Ksh93 Korn Shell (93u+m/1.0.4+f7ce04bb)\\n* ksh93u_plus = Apple\\'s AT&T Ksh93 Korn Shell (93u+ 2012-08-01)\\n* awk = pkgsrc awk (OneTrueAwk 20211208)\\n* nawk = pkgsrc nawk (OneTrueAwk 20121220)\\n* mawk = Homebrew mawk (1.3.4 20200120)\\n* bgrep = Apple\\'s FreeBSD grep (2.6.0-FreeBSD)\\n* ggrep = Homebrew GNU grep (3.8)\\n\\n```shell\\n./shellbench -s zsh,bash5,bash3,dash,yash,bosh,pbosh,mksh,oksh,pdksh,ksh93,ksh93u_plus sample/leetcode/193/193.sh\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\nname                                  zsh      bash5      bash3       dash       yash       bosh      pbosh       mksh       oksh      pdksh      ksh93 ksh93u_plus\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n193.sh: builtins                   23,339     32,790     23,939     26,722     17,472     24,304     24,949     26,239     49,134     51,275     55,179     51,648 \\n193.sh: awk                           614        621        624        645        619        610        614        621        620        619        826        381 \\n193.sh: mawk                          620        614        618        640        618        624        619        625        619        629        842        380 \\n193.sh: nawk                          698        708        713        746        716        694        691        719        720        728        976        433 \\n193.sh: gawk                          694        611        719        734        706        589        672        719        718        675        985        424 \\n193.sh: bgrep -E                      723        743        765        782        737        742        757        752        726        733      1,062        379 \\n193.sh: ggrep -E                      542        540        539        563        541        522        538        552        547        531        698        347 \\n193.sh: ggrep -P                      543        557        560        573        557        554        549        555        552        553        696        350 \\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n* count: number of executions per second\\n```\\n\\n```shell\\n#!/bin/sh\\n#bench \"builtins\"\\n@begin\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n@end\\n\\n#bench \"awk\"\\n@begin\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"mawk\"\\n@begin\\nmawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"nawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"gawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"bgrep -E\"\\n@begin\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -E\"\\n@begin\\nggrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -P\"\\n@begin\\nggrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n@end\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/sh\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n\\n```\n```shell\\n./shellbench -s zsh,bash5,bash3,dash,yash,bosh,pbosh,mksh,oksh,pdksh,ksh93,ksh93u_plus sample/leetcode/193/193.sh\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\nname                                  zsh      bash5      bash3       dash       yash       bosh      pbosh       mksh       oksh      pdksh      ksh93 ksh93u_plus\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n193.sh: builtins                   23,339     32,790     23,939     26,722     17,472     24,304     24,949     26,239     49,134     51,275     55,179     51,648 \\n193.sh: awk                           614        621        624        645        619        610        614        621        620        619        826        381 \\n193.sh: mawk                          620        614        618        640        618        624        619        625        619        629        842        380 \\n193.sh: nawk                          698        708        713        746        716        694        691        719        720        728        976        433 \\n193.sh: gawk                          694        611        719        734        706        589        672        719        718        675        985        424 \\n193.sh: bgrep -E                      723        743        765        782        737        742        757        752        726        733      1,062        379 \\n193.sh: ggrep -E                      542        540        539        563        541        522        538        552        547        531        698        347 \\n193.sh: ggrep -P                      543        557        560        573        557        554        549        555        552        553        696        350 \\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n* count: number of executions per second\\n```\n```shell\\n#!/bin/sh\\n#bench \"builtins\"\\n@begin\\np=\\\\([0-9][0-9][0-9]\\\\)\\\\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\np2=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\\n\\nwhile read -r line; do\\n  case \"$line\" in\\n    $p)\\n    echo \"$line\"\\n    ;;\\n    $p2)\\n    echo \"$line\"\\n    ;;\\n  esac\\ndone < file.txt\\n@end\\n\\n#bench \"awk\"\\n@begin\\nawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"mawk\"\\n@begin\\nmawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"nawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"gawk\"\\n@begin\\nnawk \\'/^((\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4})$/\\' file.txt\\n@end\\n\\n#bench \"bgrep -E\"\\n@begin\\ngrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -E\"\\n@begin\\nggrep -E \\'^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$|^([0-9]{3}-[0-9]{3}-[0-9]{4})$\\' file.txt\\n@end\\n\\n#bench \"ggrep -P\"\\n@begin\\nggrep -P \\'^(\\\\(\\\\d{3}\\\\) |\\\\d{3}-)\\\\d{3}-\\\\d{4}$\\' file.txt\\n@end\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967963,
                "title": "grep-short-and-fast-explanation",
                "content": "```\\ngrep -E \\'^([[:digit:]]{3}-|^\\\\([[:digit:]]{3}\\\\) )[[:digit:]]{3}-[[:digit:]]{4}$\\' file.txt\\n```\\nOr just this. Where [0-9] instead of [:digit:].\\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```\\n\\n# Idea\\nWe need to check for one of this formats\\n(xxx) xxx-xxxx\\nxxx-xxx-xxxx\\n\\nAt the beginning we want one of the following:\\na) \"(xxx) \" ```\\\\([0-9]{3}\\\\) ```\\nb) \"xxx-\" ```[0-9]{3}\\\\-```\\nRest is same for both:\\n\"xxx-xxxx\" ```[0-9]{3}\\\\-[0-9]{4}```\\n\\n# Symbols meaning\\n**a|b** - Regex matches any string matching one of them.\\n**(a|b)** - To make subexpression\\n**\\\\\\\\** - Disabling/enabling meta-character\\n**{m}** - The preceding item is matched exactly m times. We can also use **{m,n}** or **{m,}** (m and more times), **{,n}** (at most n times).\\n**^** - The begin of a line\\n**$** - The end of a line.\\n**[:digit:] [:upper:] [:alpha:] [:alnum:]** - Character classes. Better not to use [a-z] to avoid dependence on language settings, as some languages have \\xE0,\\u010D,\\u017E ...\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ngrep -E \\'^([[:digit:]]{3}-|^\\\\([[:digit:]]{3}\\\\) )[[:digit:]]{3}-[[:digit:]]{4}$\\' file.txt\\n```\n```\\ngrep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}\\\\-)[0-9]{3}\\\\-[0-9]{4}$\" file.txt\\n```\n```\\\\([0-9]{3}\\\\) ```\n```[0-9]{3}\\\\-```\n```[0-9]{3}\\\\-[0-9]{4}```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957212,
                "title": "simple-grep-solution",
                "content": "# Approach\\nUse the `grep` command with [this regex pattern](https://regex101.com/r/Z7q2pZ/1) to show the valid phone numbers.\\n\\n# Code\\n```sh\\n#!/bin/sh\\n\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3,3}\\\\) |[0-9]{3,3}-){1,1}[0-9]{3,3}-[0-9]{4,4}$\"\\n\\ngrep -Ei \"$pattern\" $file\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```sh\\n#!/bin/sh\\n\\nfile=\"file.txt\"\\npattern=\"^(\\\\([0-9]{3,3}\\\\) |[0-9]{3,3}-){1,1}[0-9]{3,3}-[0-9]{4,4}$\"\\n\\ngrep -Ei \"$pattern\" $file\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937314,
                "title": "simple-one-line-100ms-beats-79-20",
                "content": "# Code\\n```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2934322,
                "title": "bash-grep-e",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ncat file.txt | grep -E \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2883195,
                "title": "one-line-shell-command-vs-bash-script-grep-e-matching-regular-expression-re",
                "content": "# Intuition\\nMy first thoughts focused on UNIX/Linux filter. It is a command that:\\n- Takes its input from standard inputs\\n- Precesses it according to some parameters and options\\n- Prodices its output on standard output\\n\\nIn general, filters are useful tool for text file processing.\\nIn addition, since the text requires yoo to serach the input file for lines containing a match to the given pattern, I select **grep -E** or **egrep** command beacuse it uses extended **Regular Expression** for matching the pattern.\\n**grep format: grep [options] pattern [file]**\\n\\n# Approach\\nThe text asks for two REs.\\nTherefore, the RE must have two expressions connected by an OR -> |.\\nThe character \\'\\\\\\' is used for special characters, such as \\'(\\' or \\')\\'.\\nThe \\'\\\\s\\' character is used for space or tab.\\nThe \\'\\\\s\\' character is used for space or tab\\nThe \\'^\\' character is used for the beginning of the line\\nthe \\'$\\' character is used for the end of the line\\nThe expression \\'[0-9]{3}\\' is used to identify a set of three digits.\\n\\nIn addition to the shell command version, I also added the bash script version.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n\\nshell command:\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n```\\n\\nBash script:\\n```\\n#!/bin/bash\\n\\nif [ $# -ne 1]\\nthen\\n    echo \"Run as $0 file.txt\"\\n    exit 1\\nfi\\n\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n```\n```\\n#!/bin/bash\\n\\nif [ $# -ne 1]\\nthen\\n    echo \"Run as $0 file.txt\"\\n    exit 1\\nfi\\n\\negrep \"(^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$)|(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)\" file.txt\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2881574,
                "title": "bash-script-regex-awk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n awk \\'/^\\\\([0-9]{3}\\\\)\\\\s[0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$/\\' file.txt\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\n\\n\\n\\nreg1=\"^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$\"\\nreg2=\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\"\\n\\nwhile read\\ndo\\n    if [[ $REPLY =~ $reg1 || $REPLY =~ $reg2 ]]\\n    then\\n     echo $REPLY\\n    fi\\ndone<file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2878947,
                "title": "bash-beats-100-easy-to-understand",
                "content": "# Intuition\\nCheck each number line by line.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead the file line by line and then use regular expression to verify the valid phone number.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwhile read line\\ndo\\n    if [[ $line == [0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\n    if [[ $line == [\\'(\\'][0-9][0-9][0-9][\\')\\'][[:space:]][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nwhile read line\\ndo\\n    if [[ $line == [0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\n    if [[ $line == [\\'(\\'][0-9][0-9][0-9][\\')\\'][[:space:]][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] ]]\\n    then echo $line\\n    fi\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868701,
                "title": "valid-phone-numbers",
                "content": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n",
                "solutionTags": [],
                "code": "```\\ngrep \\'^\\\\([0-9]\\\\{3\\\\}-\\\\|([0-9]\\\\{3\\\\}) \\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\' file.txt\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2863876,
                "title": "bash-using-while-and-if-statements",
                "content": "```\\n#!/bin/bash\\nfile_name=\"file.txt\"\\nphone_number_regx=\\'(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)|(^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$)\\'\\n\\nwhile read line;\\ndo\\n\\tif [[ \"$line\" =~ $phone_number_regx ]]; then\\n\\t\\techo $line\\n\\tfi\\ndone<$file_name\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\nfile_name=\"file.txt\"\\nphone_number_regx=\\'(^[0-9]{3}-[0-9]{3}-[0-9]{4}$)|(^\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}$)\\'\\n\\nwhile read line;\\ndo\\n\\tif [[ \"$line\" =~ $phone_number_regx ]]; then\\n\\t\\techo $line\\n\\tfi\\ndone<$file_name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848522,
                "title": "1-line-using-grep-regex",
                "content": "\\tgrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n\\ti",
                "solutionTags": [],
                "code": "\\tgrep -P \\'(^\\\\(\\\\d{3}\\\\) \\\\d{3}\\\\-\\\\d{4}$)|(^\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}$)\\' file.txt\\n\\ti",
                "codeTag": "Unknown"
            },
            {
                "id": 2810953,
                "title": "o-n-83ms-grep-regex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse regEx in grep\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngrep -E \\'regEx\\' file.txt\\n^([0-9]{3}-[0-9]{3}-[0-9]{4})\\\\$\\n^(\\\\\\\\([0-9]{3}\\\\\\\\) [0-9]{3}-[0-9]{4})\\\\$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) traverse of the file.txt\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if grep just gets lines not the whole file\\n\\n# Code\\n```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$\\' ./file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "String Matching"
                ],
                "code": "```\\n# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\'^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$\\' ./file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807343,
                "title": "solution-using-awk-pattern",
                "content": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'/^([0-9]{3}-[0-9]{3}-[0-9]{4})$|^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4})$/\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728317,
                "title": "one-liner-using-grep-regex",
                "content": "```bash\\ngrep -P \\'(^\\\\d{3}-|^\\\\(\\\\d{3}\\\\)\\\\s)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\ngrep -P \\'(^\\\\d{3}-|^\\\\(\\\\d{3}\\\\)\\\\s)\\\\d{3}-\\\\d{4}$\\' file.txt\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564611,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564656,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570699,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570151,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572572,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1566622,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569013,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1567736,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569012,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1568421,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564611,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1564656,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570699,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1570151,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572572,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1566622,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569013,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1567736,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1569012,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1568421,
                "content": [
                    {
                        "username": "steve.j.sun",
                        "content": "    grep -e '\\\\(^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\\\\)' -e '\\\\(^([0-9]\\\\{3\\\\})[ ]\\\\{1\\\\}[0-9]\\\\{3\\\\}-\\\\([0-9]\\\\{4\\\\}\\\\)$\\\\)'  file.txt\\n\\n1. In Bash, we use `\\\\` to escape next one trailing character;\\n2. `^` is used to denote the beginning of a line\\n3. `$` is used to denote the end of a line\\n4. `{M}` is used to denote to match exactly `M` times of the previous occurence/regex\\n5. `(...)` is used to group pattern/regex together\\n\\nBack to this problem: it requires us to match two patterns, for better readability, I used -e and separate the two patterns into two regexes, the first one matches this case: `xxx-xxx-xxxx` and the second one matches this case: `(xxx) xxx-xxxx`\\n\\nPlease vote this post up if you find it helpful for your understanding!\\n\\nCheers!"
                    },
                    {
                        "username": "babichfx",
                        "content": "Discussion is not a place for solutions"
                    },
                    {
                        "username": "luangong",
                        "content": "Using `grep`:\\n\\n    grep -P '^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$' file.txt\\n\\nUsing `sed`:\\n\\n    sed -n -r '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/p' file.txt\\n\\nUsing `awk`:\\n\\n    awk '/^([0-9]{3}-|\\\\([0-9]{3}\\\\) )[0-9]{3}-[0-9]{4}$/' file.txt"
                    },
                    {
                        "username": "jaschon",
                        "content": "Just noticed that Leet\\'s version of grep doesn\\'t work with \\\\d (all digits shortcut). You must use [0-9]. Ugh."
                    },
                    {
                        "username": "martian0x80",
                        "content": "`grep` accepts only basic regular expressions, you can supply `-P` for PCRE (Perl Compatible Regular Expression) compatibility."
                    },
                    {
                        "username": "allen134",
                        "content": "`grep -E \\'(?:\\\\d{3}\\\\-|\\\\(\\\\d{3}\\\\) )\\\\d{3}\\\\-\\\\d{4}\\' file.txt`\\n\\nfails for `123-456-7891` but why?\\n"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Trapped into the same problem.\\nChanging `\\\\d` to `[0-9]` letting this test pass. Weiurd."
                    },
                    {
                        "username": "andyyaldoo",
                        "content": "`grep -E \"^\\\\(?\\\\d{3}\\\\)?[ -]\\\\d{3}-\\\\d{4}$\" file.txt`\\n\\nIt fails on test case `123-456-7891`"
                    },
                    {
                        "username": "krlinus",
                        "content": "rbash: ./prog.sh: Permission denied\\n\\nAnyone with similar experience and what can be done about it?"
                    },
                    {
                        "username": "user1021LN",
                        "content": "as pokhriyadeepak1998 said, give permission to the file by executing this in the directory where the file exists:\\nsudo chmod 777 ./prog.sh\\n\\nand before that make sure you typed\\n#!/bin/bash\\nin the beginning of the file, or replace bash with whatever you want to use"
                    },
                    {
                        "username": "pokhriyadeepak1998",
                        "content": "have you given permission to execute the file using chmod command\\n"
                    },
                    {
                        "username": "xiaohui5319",
                        "content": "    grep -e \"^[0-9]\\\\{3\\\\}-[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" -e \"^([0-9]\\\\{3\\\\}) [0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "vincentoldfriend",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt"
                    },
                    {
                        "username": "Zoloholic",
                        "content": "grep -Po \"^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\" file.txt   <<< escaped the brackets .. this works"
                    },
                    {
                        "username": "yilonglucky",
                        "content": "I spent one hour to solve this puzzle with grep but failed. I thought it was totally NOT easy level! Or that means I'm in low level?\\nI failed in these cases:(\\n1-1-706-7938\\n+31 365-492-5931\\n37 9-858-6497\\n+978-878-1324\\n-686-511-4033\\n\\nI suggest move this question into at least \"Medium\""
                    },
                    {
                        "username": "shubham_rocko",
                        "content": "cat file.txt | grep -E \"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\""
                    }
                ]
            },
            {
                "id": 1572907,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571409,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571410,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1571411,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 2051023,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1963994,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1928438,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1928138,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1728427,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            },
            {
                "id": 1712426,
                "content": [
                    {
                        "username": "overthrow",
                        "content": "grep -P \\'^(\\\\d{3}-|\\\\(\\\\d{3}\\\\) )\\\\d{3}-\\\\d{4}$\\' file.txt"
                    },
                    {
                        "username": "PressTheRedButton",
                        "content": "My Statement is:\\ngrep '^(*\\\\d\\\\{3\\\\})*[- ]\\\\d\\\\{3\\\\}-\\\\d\\\\{4\\\\}$' file.txt\\n\\nWhen I run this locally against '123-456-7891' it returns it. Leetcode is saying that it doesn't."
                    },
                    {
                        "username": "peng73",
                        "content": "awk '/^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$|^\\\\([0-9][0-9][0-9]\\\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$/' file.txt"
                    },
                    {
                        "username": "xcv58",
                        "content": "Just use grep, the case (000) and 000- should handle by or operator.\\n\\n    grep \"^\\\\(\\\\([0-9]\\\\{3\\\\}-\\\\)\\\\|\\\\(([0-9]\\\\{3\\\\}) \\\\)\\\\)[0-9]\\\\{3\\\\}-[0-9]\\\\{4\\\\}$\" file.txt"
                    },
                    {
                        "username": "23024_06777",
                        "content": "grep -e pattern1 -e pattern2 file"
                    },
                    {
                        "username": "Vucius",
                        "content": "I still don\\'t understand why this command doesn\\'t work. Can someone please explain to me? \\n```\\ngrep -E \\'(\\\\(\\\\d{3}\\\\)[ ]|\\\\d{3}[-])\\\\d{3}[-]\\\\d{4}\\' file.txt\\n```"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Wrong answer:\\nInput\\n123-456-7891\\nExpected\\n123-456-7891\\n\\nOkay, so where is the issue again? Highly infuriating.\\n\\nMy code is:\\n`grep -E \"^([0-9]{3}\\\\-|\\\\([0-9]{3}\\\\) )[0-9]{3}\\\\-[0-9]{4}\\\\n$\" \"file.txt\"`"
                    },
                    {
                        "username": "shekelboi",
                        "content": "The issue was that it matched the \\\\n in the end by the way. I removed that and it solved the issue. It\\'s really annoying however that leetcode doesn\\'t show the match for the newline character (there wasn\\'t a new line in the end of the Input)"
                    },
                    {
                        "username": "camsteffen",
                        "content": "You can use `\\\\d` with the `-P` flag."
                    },
                    {
                        "username": "hsjoshi28",
                        "content": "Why some regex\\'s work at regexr.com but not in shell and vice versa??"
                    },
                    {
                        "username": "App-arition",
                        "content": "Can someone explain why  `v=12\\nx=14\\nwhile read line\\ndo\\n    n=${#line}\\n    if [ \"$n\" -ge \"$v\" ] || [ \"$n\" -eq \"$x\" ] && ! [[ \"$line\" =~ [^a-z] ]];then\\n        echo \"$line\"\\n    fi\\ndone < file.txt` fails on 123-456-7891 ???"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flip Game",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568287,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            },
            {
                "id": 1572561,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            },
            {
                "id": 1571854,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            },
            {
                "id": 1879804,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            },
            {
                "id": 1753909,
                "content": [
                    {
                        "username": "ddoudle",
                        "content": "This sentence in discriptions is useless: \\nThe game ends when a person can no longer make a move and therefore the other person will be the winner."
                    },
                    {
                        "username": "omaha",
                        "content": "The question says it is a flip game, so I wrote code for flipping both \\'--\\' and \\'++\\' , but I see that only \\'++\\' are flipped, but not \\'--\\'. Anyone suggest how you got to understand and code it that way? Isn\\'t the question misleading or did I understand it wrong?\\n\\nThanks in advance."
                    },
                    {
                        "username": "yguan1",
                        "content": "if both \\'++\\' and \\'--\\' can be flipped, the game will never end."
                    },
                    {
                        "username": "codeywodey",
                        "content": "Why is the discussion forum full of solutions to problems? Why not post these in the forum under the solution tab? Seems like discussiong would be a good place to discuss the soundness and quality of the problem statement, test cases, etc. "
                    },
                    {
                        "username": "thegeorgejoseph",
                        "content": "Crazy, sounded like a Recursive/ Backtracking solution but ended up being a Sliding Window/ Naive one"
                    },
                    {
                        "username": "chazkondo",
                        "content": "Description is confusing -> \\n\\nBasically, you can flip consecutive `plus` characters \\'++\\' to \\'--\\'. Once flipped to \\'--\\', it can no longer be flipped back to \\'++\\'."
                    }
                ]
            }
        ]
    },
    {
        "title": "UTF-8 Validation",
        "question_content": "<p>Given an integer array <code>data</code> representing the data, return whether it is a valid <strong>UTF-8</strong> encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).</p>\n\n<p>A character in <strong>UTF8</strong> can be from <strong>1 to 4 bytes</strong> long, subjected to the following rules:</p>\n\n<ol>\n\t<li>For a <strong>1-byte</strong> character, the first bit is a <code>0</code>, followed by its Unicode code.</li>\n\t<li>For an <strong>n-bytes</strong> character, the first <code>n</code> bits are all one&#39;s, the <code>n + 1</code> bit is <code>0</code>, followed by <code>n - 1</code> bytes with the most significant <code>2</code> bits being <code>10</code>.</li>\n</ol>\n\n<p>This is how the UTF-8 encoding would work:</p>\n\n<pre>\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n</pre>\n\n<p><code>x</code> denotes a bit in the binary form of a byte that may be either <code>0</code> or <code>1</code>.</p>\n\n<p><strong>Note: </strong>The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> data = [197,130,1]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> data = [235,140,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one&#39;s and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that&#39;s correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= data.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= data[i] &lt;= 255</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 87462,
                "title": "concise-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int count = 0;\\n        for (auto c : data) {\\n            if (count == 0) {\\n                if ((c >> 5) == 0b110) count = 1;\\n                else if ((c >> 4) == 0b1110) count = 2;\\n                else if ((c >> 3) == 0b11110) count = 3;\\n                else if ((c >> 7)) return false;\\n            } else {\\n                if ((c >> 6) != 0b10) return false;\\n                count--;\\n            }\\n        }\\n        return count == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int count = 0;\\n        for (auto c : data) {\\n            if (count == 0) {\\n                if ((c >> 5) == 0b110) count = 1;\\n                else if ((c >> 4) == 0b1110) count = 2;\\n                else if ((c >> 3) == 0b11110) count = 3;\\n                else if ((c >> 7)) return false;\\n            } else {\\n                if ((c >> 6) != 0b10) return false;\\n                count--;\\n            }\\n        }\\n        return count == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568917,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity : O(N) where N is the number of elements in data\\n// Space Complexity: O(1) \\nclass Solution {\\npublic:\\n    // the idea is to keep track the number of segments of utf-8 octet sequence left\\n    // we increase / decrease the count based on some cases\\n    // first you need to know that `x >> n` means shift the number `x` `n` bits to the right\\n    // e.g. shift 110xxxxx 5 bits to the right becomes 110 (in binary format)\\n    // e.g. shift 11110xxx 4 bits to the right becomes 1111 (in binary format)\\n    // second, 0bxxxx is a binary literal which means xxxx is a binary number\\n    // alternatively, you can use decimal format but it\\'s not that convenient in this problem\\n    // e.g. 0b1110 -> 14\\n    // e.g. 0b11000000 -> 192\\n    bool validUtf8(vector<int>& data) {\\n        // used to track the remaining number of segments\\n        int remaining = 0;\\n        // iterate each data and perform the following logic\\n        for (auto& x : data) {\\n            // case 1: there is no remaining segement left, \\n            // then it means we should check the first segement of UTF-8 octet sequence\\n            // i.e. 0xxxxxxx (for no of. bytes = 1)\\n            // i.e. 110xxxxx (for no of. bytes = 2)\\n            // i.e. 1110xxxx (for no of. bytes = 3)\\n            // i.e. 11110xxx (for no of. bytes = 4)\\n            if (remaining == 0) {\\n                if ((x >> 5) == 0b110) {\\n                    // case 1.1 - shift `x` 5 bits to the right\\n                    // i.e making the first (8 - 5) = 3 bits left\\n                    // e.g (110xxxxx >> 5) becomes 110 (in binary format)\\n                    // if it is 0b110, \\n                    // then it is only possible to form `110xxxxx 10xxxxxx` \\n                    // so we set remaining to 1 to look for `10xxxxxx` later\\n                    remaining = 1;\\n                } else if ((x >> 4) == 0b1110) {\\n                    // case 1.2 -  shift `x` 4 bits to the right\\n                    // i.e making the first (8 - 4) = 4 bits left\\n                    // e.g (1110xxxx >> 4) becomes 1110 (in binary format)\\n                    // if it is 0b1110, \\n                    // then it is only possible to form `1110xxxx 10xxxxxx 10xxxxxx`\\n                    // so we set remaining to 2 to look for `10xxxxxx 10xxxxxx` later\\n                     remaining = 2;\\n                } else if ((x >> 3) == 0b11110) {\\n                    // case 1.3 -  shift `x` 3 bits to the right\\n                    // i.e making the first (8 - 3) = 5 bits left\\n                    // e.g (11110xxx >> 5) becomes 11110 (in binary format)\\n                    // if it is 0b11110, \\n                    // then it is only possible to form `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`\\n                    // so we set remaining to 3 to look for `10xxxxxx 10xxxxxx 10xxxxxx` later\\n                    remaining = 3;\\n                } else if ((x >> 7) != 0) {\\n                     // case 1.4 -  shift `x` 7 bits to the right\\n                    // i.e making the first (8 - 7) = 1 bit left\\n                    // e.g (0xxxxxxx >> 7) becomes 0 (in binary format)\\n                    // here we cover the last case which is when Number of Bytes = 1\\n                    // we need to make sure the first bit is 0\\n                    // otherwise, it is not valid\\n                    return false;\\n                }\\n            } else {\\n                // case 2: check 10xxxxxx\\n                // if we enter this part, that means it may be number of bytes 2, 3, or 4.\\n                // based on the table in problem statement, we know what\\'s left is just `10xxxxxx`\\n                // therefore, we shift `x` 6 bits to the right\\n                // i.e making the first (8 - 6) = 2 bits left\\n                // e.g (10xxxxxx >> 6) becomes 10 (in binary format)\\n                // if the first 2 bits are not 10 (in binary format), then it is not valid\\n                if ((x >> 6) != 0b10) return false;\\n                // otherwise, this segement is ok so we decrease `remaining` by 1\\n                else remaining--;\\n            }\\n        }\\n        // at the end, remaining will be 0 if data can represent the octet sequence \\n        return remaining == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n// Time Complexity : O(N) where N is the number of elements in data\\n// Space Complexity: O(1) \\nclass Solution {\\npublic:\\n    // the idea is to keep track the number of segments of utf-8 octet sequence left\\n    // we increase / decrease the count based on some cases\\n    // first you need to know that `x >> n` means shift the number `x` `n` bits to the right\\n    // e.g. shift 110xxxxx 5 bits to the right becomes 110 (in binary format)\\n    // e.g. shift 11110xxx 4 bits to the right becomes 1111 (in binary format)\\n    // second, 0bxxxx is a binary literal which means xxxx is a binary number\\n    // alternatively, you can use decimal format but it\\'s not that convenient in this problem\\n    // e.g. 0b1110 -> 14\\n    // e.g. 0b11000000 -> 192\\n    bool validUtf8(vector<int>& data) {\\n        // used to track the remaining number of segments\\n        int remaining = 0;\\n        // iterate each data and perform the following logic\\n        for (auto& x : data) {\\n            // case 1: there is no remaining segement left, \\n            // then it means we should check the first segement of UTF-8 octet sequence\\n            // i.e. 0xxxxxxx (for no of. bytes = 1)\\n            // i.e. 110xxxxx (for no of. bytes = 2)\\n            // i.e. 1110xxxx (for no of. bytes = 3)\\n            // i.e. 11110xxx (for no of. bytes = 4)\\n            if (remaining == 0) {\\n                if ((x >> 5) == 0b110) {\\n                    // case 1.1 - shift `x` 5 bits to the right\\n                    // i.e making the first (8 - 5) = 3 bits left\\n                    // e.g (110xxxxx >> 5) becomes 110 (in binary format)\\n                    // if it is 0b110, \\n                    // then it is only possible to form `110xxxxx 10xxxxxx` \\n                    // so we set remaining to 1 to look for `10xxxxxx` later\\n                    remaining = 1;\\n                } else if ((x >> 4) == 0b1110) {\\n                    // case 1.2 -  shift `x` 4 bits to the right\\n                    // i.e making the first (8 - 4) = 4 bits left\\n                    // e.g (1110xxxx >> 4) becomes 1110 (in binary format)\\n                    // if it is 0b1110, \\n                    // then it is only possible to form `1110xxxx 10xxxxxx 10xxxxxx`\\n                    // so we set remaining to 2 to look for `10xxxxxx 10xxxxxx` later\\n                     remaining = 2;\\n                } else if ((x >> 3) == 0b11110) {\\n                    // case 1.3 -  shift `x` 3 bits to the right\\n                    // i.e making the first (8 - 3) = 5 bits left\\n                    // e.g (11110xxx >> 5) becomes 11110 (in binary format)\\n                    // if it is 0b11110, \\n                    // then it is only possible to form `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`\\n                    // so we set remaining to 3 to look for `10xxxxxx 10xxxxxx 10xxxxxx` later\\n                    remaining = 3;\\n                } else if ((x >> 7) != 0) {\\n                     // case 1.4 -  shift `x` 7 bits to the right\\n                    // i.e making the first (8 - 7) = 1 bit left\\n                    // e.g (0xxxxxxx >> 7) becomes 0 (in binary format)\\n                    // here we cover the last case which is when Number of Bytes = 1\\n                    // we need to make sure the first bit is 0\\n                    // otherwise, it is not valid\\n                    return false;\\n                }\\n            } else {\\n                // case 2: check 10xxxxxx\\n                // if we enter this part, that means it may be number of bytes 2, 3, or 4.\\n                // based on the table in problem statement, we know what\\'s left is just `10xxxxxx`\\n                // therefore, we shift `x` 6 bits to the right\\n                // i.e making the first (8 - 6) = 2 bits left\\n                // e.g (10xxxxxx >> 6) becomes 10 (in binary format)\\n                // if the first 2 bits are not 10 (in binary format), then it is not valid\\n                if ((x >> 6) != 0b10) return false;\\n                // otherwise, this segement is ok so we decrease `remaining` by 1\\n                else remaining--;\\n            }\\n        }\\n        // at the end, remaining will be 0 if data can represent the octet sequence \\n        return remaining == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87464,
                "title": "bit-manipulation-java-6ms",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n\\tif(data==null || data.length==0) return false;\\n\\tboolean isValid = true;\\n\\tfor(int i=0;i<data.length;i++) {\\n\\t\\tif(data[i]>255) return false; // 1 after 8th digit, 100000000\\n\\t\\tint numberOfBytes = 0;\\n\\t\\tif((data[i] & 128) == 0) { // 0xxxxxxx, 1 byte, 128(10000000)\\n\\t\\t\\tnumberOfBytes = 1;\\n\\t\\t} else if((data[i] & 224) == 192) { // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\\n\\t\\t\\tnumberOfBytes = 2;\\n\\t\\t} else if((data[i] & 240) == 224) { // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\\n\\t\\t\\tnumberOfBytes = 3;\\n\\t\\t} else if((data[i] & 248) == 240) { // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\\n\\t\\t\\tnumberOfBytes = 4;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int j=1;j<numberOfBytes;j++) { // check that the next n bytes start with 10xxxxxx\\n\\t\\t\\tif(i+j>=data.length) return false;\\n\\t\\t\\tif((data[i+j] & 192) != 128) return false; // 192(11000000), 128(10000000)\\n\\t\\t}\\n\\t\\ti=i+numberOfBytes-1;\\n\\t}\\n\\treturn isValid;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n\\tif(data==null || data.length==0) return false;\\n\\tboolean isValid = true;\\n\\tfor(int i=0;i<data.length;i++) {\\n\\t\\tif(data[i]>255) return false; // 1 after 8th digit, 100000000\\n\\t\\tint numberOfBytes = 0;\\n\\t\\tif((data[i] & 128) == 0) { // 0xxxxxxx, 1 byte, 128(10000000)\\n\\t\\t\\tnumberOfBytes = 1;\\n\\t\\t} else if((data[i] & 224) == 192) { // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\\n\\t\\t\\tnumberOfBytes = 2;\\n\\t\\t} else if((data[i] & 240) == 224) { // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\\n\\t\\t\\tnumberOfBytes = 3;\\n\\t\\t} else if((data[i] & 248) == 240) { // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\\n\\t\\t\\tnumberOfBytes = 4;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int j=1;j<numberOfBytes;j++) { // check that the next n bytes start with 10xxxxxx\\n\\t\\t\\tif(i+j>=data.length) return false;\\n\\t\\t\\tif((data[i+j] & 192) != 128) return false; // 192(11000000), 128(10000000)\\n\\t\\t}\\n\\t\\ti=i+numberOfBytes-1;\\n\\t}\\n\\treturn isValid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568936,
                "title": "c-bit-manipulation-approach",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Intuition:**\\nSince we need to translate the provided data array into a `sequence` of valid `UTF-8 encoded characters` there is definitely an underlying concept of `bit manipulation` to be used, let\\'s see how we can achieve this.\\n\\n**Approach:**\\n* We will initially take a **count** variable initialized to 0;\\n* Then we will iterate over the given array and will store the value from data array in ele = data[i]\\n* If **count** is still 0 then below are the things that we need to take care of:\\n1. * **If x/32 = 110**, then set count as 1. `(x/32 is same as doing x >> 5 as 2^5 = 32)`\\n2. * **Else if x/16 = 1110**, then count = 2 `(x/16 is same as doing x >> 4 as 2^4 = 16)`\\n3. * **Else If x/8 = 11110**, then count = 3. `(x/8 is same as doing x >> 3 as 2^3 = 8)`\\n4. * **Else if x/128 is 0**, then return false. `(x/128 is same as doing x >> 7 as 2^7 = 128)`\\n5. * **Else if x/64 is not 10**, then decrease the **count** and return **false**.\\n* Finally if **count** is 0 return true;\\n\\n**C++:**\\n```\\nclass Solution{\\npublic:\\n  bool validUtf8(vector<int> &data){\\n    int n = data.size(); \\n    int count = 0;       \\n    for (int i = 0; i < n; i++){    \\n      int ele = data[i]; \\n      if (!count){ \\n\\t   // if the first 3 bits are 110, then the next byte is part of the current UTF-8 character\\n        if ((ele >> 5) == 0b110) \\n          count = 1; \\n\\t\\t// if the first 4 bits are 1110, then the next 2 bytes are part of the current UTF-8 character  \\n        else if ((ele >> 4) == 0b1110)\\n          count = 2; \\n\\t\\t // if the first 5 bits are 11110, then the next 3 bytes are part of the current UTF-8 character\\n        else if ((ele >> 3) == 0b11110)\\n          count = 3; \\n\\t\\t // if the first bit is 1, then return false\\n        else if ((ele >> 7))\\n          return false; \\n      }\\n      else{\\n\\t   // if the first 2 bits are not 10, then return false\\n        if ((ele >> 6) != 0b10)\\n          return false; \\n        count--;        \\n      }\\n    }\\n    return (count == 0); \\n  }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**\\n**Space Complexity:** **O(1)**\\n****",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n  bool validUtf8(vector<int> &data){\\n    int n = data.size(); \\n    int count = 0;       \\n    for (int i = 0; i < n; i++){    \\n      int ele = data[i]; \\n      if (!count){ \\n\\t   // if the first 3 bits are 110, then the next byte is part of the current UTF-8 character\\n        if ((ele >> 5) == 0b110) \\n          count = 1; \\n\\t\\t// if the first 4 bits are 1110, then the next 2 bytes are part of the current UTF-8 character  \\n        else if ((ele >> 4) == 0b1110)\\n          count = 2; \\n\\t\\t // if the first 5 bits are 11110, then the next 3 bytes are part of the current UTF-8 character\\n        else if ((ele >> 3) == 0b11110)\\n          count = 3; \\n\\t\\t // if the first bit is 1, then return false\\n        else if ((ele >> 7))\\n          return false; \\n      }\\n      else{\\n\\t   // if the first 2 bits are not 10, then return false\\n        if ((ele >> 6) != 0b10)\\n          return false; \\n        count--;        \\n      }\\n    }\\n    return (count == 0); \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87485,
                "title": "o-n-java-solution-with-detailed-explaination",
                "content": "```\\npublic class Solution {\\n    /*\\n     * Thought-way: \\n     * As long as every byte in the array is of right type, it is a valid UTF-8 encoding.\\n     * \\n     * Method: \\n     * Start from index 0, determine each byte's type and check its validity.\\n     *\\n     * There are five kinds of valid byte type: 0**, 10**, 110**,1110** and 11110**\\n     * Give them type numbers, 0, 1, 2, 3, 4 which are the index of the first 0 from left. \\n     * So, the index of the first 0 determines the byte type.\\n     *\\n     * if a byte belongs to one of them:\\n        1 : if it is type 0, continue\\n        2 : if it is type 2 or 3 or 4, check whether the following 1, 2, and 3 byte(s) are of type 1 or not\\n                if not, return false;\\n     * else if a byte is type 1 or not of valid type, return false\\n     *\\n     * Analysis :\\n     * The faster you can determine the type, the quicker you can get. \\n     * Time O(n), space O(1)\\n     * real performance: 7ms\\n     */\\n     \\n    // Hard code \"masks\" array to find the index of the first appearance of 0 in the lower 8 bits of each integer.\\n    private int[] masks = {128, 64, 32, 16, 8};\\n    public boolean validUtf8(int[] data) {\\n        int len = data.length;\\n        for (int i = 0; i < len; i ++) {\\n            int curr = data[i];\\n            int type = getType(curr);\\n            if (type == 0) {\\n                continue;\\n            } else if (type > 1 && i + type <= len) {\\n                while (type-- > 1) {\\n                    if (getType(data[++i]) != 1) {\\n                        return false;\\n                    }\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int getType(int num) {\\n        for (int i = 0; i < 5; i ++) {\\n            if ((masks[i] & num) == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /*\\n     * Thought-way: \\n     * As long as every byte in the array is of right type, it is a valid UTF-8 encoding.\\n     * \\n     * Method: \\n     * Start from index 0, determine each byte's type and check its validity.\\n     *\\n     * There are five kinds of valid byte type: 0**, 10**, 110**,1110** and 11110**\\n     * Give them type numbers, 0, 1, 2, 3, 4 which are the index of the first 0 from left. \\n     * So, the index of the first 0 determines the byte type.\\n     *\\n     * if a byte belongs to one of them:\\n        1 : if it is type 0, continue\\n        2 : if it is type 2 or 3 or 4, check whether the following 1, 2, and 3 byte(s) are of type 1 or not\\n                if not, return false;\\n     * else if a byte is type 1 or not of valid type, return false\\n     *\\n     * Analysis :\\n     * The faster you can determine the type, the quicker you can get. \\n     * Time O(n), space O(1)\\n     * real performance: 7ms\\n     */\\n     \\n    // Hard code \"masks\" array to find the index of the first appearance of 0 in the lower 8 bits of each integer.\\n    private int[] masks = {128, 64, 32, 16, 8};\\n    public boolean validUtf8(int[] data) {\\n        int len = data.length;\\n        for (int i = 0; i < len; i ++) {\\n            int curr = data[i];\\n            int type = getType(curr);\\n            if (type == 0) {\\n                continue;\\n            } else if (type > 1 && i + type <= len) {\\n                while (type-- > 1) {\\n                    if (getType(data[++i]) != 1) {\\n                        return false;\\n                    }\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int getType(int num) {\\n        for (int i = 0; i < 5; i ++) {\\n            if ((masks[i] & num) == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145982,
                "title": "java-code-one-loop-and-bit-shift",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n         int cnt = 0;\\n        for(int d : data){\\n            if(cnt == 0){\\n                if((d>>5) == 0b110) cnt = 1;\\n               else if((d>>4) == 0b1110) cnt=2;\\n               else if((d>>3) == 0b11110) cnt=3;\\n               else if((d>>7) != 0) return false;\\n            }else{\\n                if((d>>6) != 0b10) return false;\\n                cnt--;\\n            }\\n        }\\n        return cnt == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n         int cnt = 0;\\n        for(int d : data){\\n            if(cnt == 0){\\n                if((d>>5) == 0b110) cnt = 1;\\n               else if((d>>4) == 0b1110) cnt=2;\\n               else if((d>>3) == 0b11110) cnt=3;\\n               else if((d>>7) != 0) return false;\\n            }else{\\n                if((d>>6) != 0b10) return false;\\n                cnt--;\\n            }\\n        }\\n        return cnt == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87494,
                "title": "short-n-clean-12-lines-python-solution",
                "content": "```\\ndef check(nums, start, size):\\n    for i in range(start + 1, start + size + 1):\\n        if i >= len(nums) or (nums[i] >> 6) != 0b10: return False\\n    return True\\n\\nclass Solution(object):\\n    def validUtf8(self, nums, start=0):\\n        while start < len(nums):\\n            first = nums[start]\\n            if   (first >> 3) == 0b11110 and check(nums, start, 3): start += 4\\n            elif (first >> 4) == 0b1110  and check(nums, start, 2): start += 3\\n            elif (first >> 5) == 0b110   and check(nums, start, 1): start += 2\\n            elif (first >> 7) == 0:                                 start += 1\\n            else:                                                   return False\\n        return True\\n\\n# 45 / 45 test cases passed.\\n# Status: Accepted\\n# Runtime: 89 ms\\n```",
                "solutionTags": [],
                "code": "```\\ndef check(nums, start, size):\\n    for i in range(start + 1, start + size + 1):\\n        if i >= len(nums) or (nums[i] >> 6) != 0b10: return False\\n    return True\\n\\nclass Solution(object):\\n    def validUtf8(self, nums, start=0):\\n        while start < len(nums):\\n            first = nums[start]\\n            if   (first >> 3) == 0b11110 and check(nums, start, 3): start += 4\\n            elif (first >> 4) == 0b1110  and check(nums, start, 2): start += 3\\n            elif (first >> 5) == 0b110   and check(nums, start, 1): start += 2\\n            elif (first >> 7) == 0:                                 start += 1\\n            else:                                                   return False\\n        return True\\n\\n# 45 / 45 test cases passed.\\n# Status: Accepted\\n# Runtime: 89 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87478,
                "title": "simplest-python-solution",
                "content": "This is a simple implementation using a marker to count bytes.\\n\\n```\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        count = 0\\n        \\n        for byte in data:\\n            if byte >= 128 and byte <= 191:\\n                if not count:\\n                    return False\\n                count -= 1\\n            else:\\n                if count:\\n                    return False\\n                if byte < 128:\\n                    continue\\n                elif byte < 224:\\n                    count = 1\\n                elif byte < 240:\\n                    count = 2\\n                elif byte < 248:\\n                    count = 3\\n                else:\\n                    return False\\n                    \\n        return count == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        count = 0\\n        \\n        for byte in data:\\n            if byte >= 128 and byte <= 191:\\n                if not count:\\n                    return False\\n                count -= 1\\n            else:\\n                if count:\\n                    return False\\n                if byte < 128:\\n                    continue\\n                elif byte < 224:\\n                    count = 1\\n                elif byte < 240:\\n                    count = 2\\n                elif byte < 248:\\n                    count = 3\\n                else:\\n                    return False\\n                    \\n        return count == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569031,
                "title": "java-solution-and-explanation-bit-manipulation",
                "content": "**PLEASE UPVOTE IF YOU LIKE :)** \\n\\nThe bit manipulation method involves shifting the bits to get only the bit value of importance:\\n- 1 byte = 0xxxxxxx\\n- 2 bytes = 110xxxxx 10xxxxxx\\n- 3 bytes = 1110xxxx 10xxxxxx 10xxxxxx\\n- 4 bytes = 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n\\nWe can then use a counter to keep track, if we are in the case for 2, 3 or 4 bytes.\\n```\\n    public boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for (int value : data) {\\n            if (count == 0) {\\n                if (value >> 3 == 0b11110) {\\n                    count = 3;\\n                } else if (value >> 4 == 0b1110) {\\n                    count = 2;\\n                } else if (value >> 5 == 0b110) {\\n                    count = 1;\\n                } else if (value >> 7 == 0b0) {\\n                    count = 0;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if (value >> 6 == 0b10) {\\n                    count--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n```\\n\\nIf you are unfamiliar with bit manipulation, here is a solution that check for the value of the integers:\\n- 0xxxxxxx\\n\\t- `<= 127`\\n- 10xxxxxx \\n\\t- `>= 128 && <= 191`\\n- 110xxxxx\\n\\t- `>= 192 && <= 223`\\n- 1110xxxx\\n\\t- `>= 224 && <= 239`\\n- 11110xxx\\n\\t- `>= 240 && <= 247`\\n```\\npublic boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for (int integer : data) {\\n            if (integer > 247) {\\n                return false;\\n            }\\n            if (count == 0) {\\n                if (integer >= 240) {\\n                    count = 3;\\n                } else if (integer >= 224) {\\n                    count = 2;\\n                } else if (integer >= 192) {\\n                    count = 1;\\n                } else if (integer >= 128) {\\n                    return false;\\n                }\\n            } else {\\n                if (integer >= 128 && integer <= 191) {\\n                    count--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n```\\n\\nThank you for reading~",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for (int value : data) {\\n            if (count == 0) {\\n                if (value >> 3 == 0b11110) {\\n                    count = 3;\\n                } else if (value >> 4 == 0b1110) {\\n                    count = 2;\\n                } else if (value >> 5 == 0b110) {\\n                    count = 1;\\n                } else if (value >> 7 == 0b0) {\\n                    count = 0;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if (value >> 6 == 0b10) {\\n                    count--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n```\n```\\npublic boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for (int integer : data) {\\n            if (integer > 247) {\\n                return false;\\n            }\\n            if (count == 0) {\\n                if (integer >= 240) {\\n                    count = 3;\\n                } else if (integer >= 224) {\\n                    count = 2;\\n                } else if (integer >= 192) {\\n                    count = 1;\\n                } else if (integer >= 128) {\\n                    return false;\\n                }\\n            } else {\\n                if (integer >= 128 && integer <= 191) {\\n                    count--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87470,
                "title": "one-pass-simple-solution",
                "content": "public class Solution {\\n\\n    public bool ValidUtf8(int[] data) {\\n        int bitCount = 0;\\n        \\n        foreach(int n in data){\\n            \\n            if(n >= 192){\\n                if(bitCount != 0)\\n                    return false;\\n                else if(n >= 240)\\n                    bitCount = 3;\\n                else if(n >= 224)\\n                    bitCount = 2;\\n                else\\n                    bitCount = 1;\\n            }else if(n >= 128){\\n                bitCount--;\\n                if(bitCount < 0)\\n                    return false;\\n            }else if(bitCount > 0){\\n                return false;\\n            }\\n        }\\n        \\n        return bitCount == 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public bool ValidUtf8(int[] data) {\\n        int bitCount = 0;\\n        \\n        foreach(int n in data){\\n            \\n            if(n >= 192){\\n                if(bitCount != 0)\\n                    return false;\\n                else if(n >= 240)\\n                    bitCount = 3;\\n                else if(n >= 224)\\n                    bitCount = 2;\\n                else\\n                    bitCount = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2568814,
                "title": "clean-concise-c-java-code",
                "content": "# Our objective\\nTo translate the provided data array into a sequence of valid UTF-8 encoded characters\\n\\n--------------------\\n\\n# Approach\\n\\n**To solve this, we will follow these steps:**\\n\\n> **Step 1:** Start with count = 0.\\n\\n> **Step 2:** for i ranging from 0 to the size of the data array.\\n\\n>> **Step 2.1:** Take the value from data arra and store it in x \\xA0= data[i]\\n\\n>> **Step 2.2:** If the count is 0, then\\n\\n>>> If x/32 = 110, then set count as 1.   ***(x/32 is same as doing x >> 5 as 2^5 = 32)***\\n\\n>>> Else if x/16 = 1110, then count = 2   ***(x/16 is same as doing x >> 4 as 2^4 = 16)***\\n\\n>>> Else If x/8 = 11110, then count = 3.   ***(x/8 is same as doing x >> 3 as 2^3 = 8)***\\n\\n>>> Else if x/128 is 0, then return false.    ***(x/128 is same as doing x >> 7 as 2^7 = 128)***\\n\\n>>**Step 2.3:** Else If x/64 is not 10, then return false and decrease the count by 1.\\n\\n> **Step 3:** When the count is 0, return true.\\n\\n------------------------------------------\\n\\n# Complexity\\n\\n\\n```\\nComplexity: \\n* TC: O(N)\\n* SC: O(1)\\n```\\n\\n-------------------------------\\n\\n# Code:\\n\\n<iframe src=\"https://leetcode.com/playground/C8dd2Bwf/shared\" frameBorder=\"0\" width=\"800\" height=\"480\"></iframe>\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nComplexity: \\n* TC: O(N)\\n* SC: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156588,
                "title": "my-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data):\\n        \\n        def rest(i):\\n            if len(data) < i: return False\\n            for _ in range(i):\\n                if not data.pop().startswith(\"10\"): return False\\n            return True\\n        \\n        data = [str(bin(seq)[2:].zfill(8)) for seq in data[::-1]]\\n        while data:\\n            seq = data.pop()\\n            if seq.startswith(\"0\"): continue\\n            if seq.startswith(\"110\"):\\n                if not rest(1): return False\\n            elif seq.startswith(\"1110\"):\\n                if not rest(2): return False\\n            elif seq.startswith(\"11110\"):\\n                if not rest(3): return False\\n            else: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data):\\n        \\n        def rest(i):\\n            if len(data) < i: return False\\n            for _ in range(i):\\n                if not data.pop().startswith(\"10\"): return False\\n            return True\\n        \\n        data = [str(bin(seq)[2:].zfill(8)) for seq in data[::-1]]\\n        while data:\\n            seq = data.pop()\\n            if seq.startswith(\"0\"): continue\\n            if seq.startswith(\"110\"):\\n                if not rest(1): return False\\n            elif seq.startswith(\"1110\"):\\n                if not rest(2): return False\\n            elif seq.startswith(\"11110\"):\\n                if not rest(3): return False\\n            else: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569284,
                "title": "short-java-solution",
                "content": "**Code:**\\n\\n    public boolean validUtf8(int[] data) {\\n        int mask = 128, n = 0;\\n        for(int i=0; i<data.length; i++){\\n            if(n!=0){\\n                if(calc(data[i])!=-1) return false;\\n                n--; continue;\\n            }\\n            n = (mask&data[i])==0 ? 0 : calc(data[i])-1; \\n            if(n<0 || i+n>=data.length) return false;\\n            if(n>0 && ((mask>>n+1)&data[i])!=0) return false;\\n        }\\n        return n==0;\\n    }\\n    \\n    int calc(int val){\\n        int n = 0;\\n        for(int mask = 128; (mask&val)!=0 && n!=4; n++)\\n            val = val<<1;\\n        return n==1 ? -1 : n;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n\\n    public boolean validUtf8(int[] data) {\\n        int mask = 128, n = 0;\\n        for(int i=0; i<data.length; i++){\\n            if(n!=0){\\n                if(calc(data[i])!=-1) return false;\\n                n--; continue;\\n            }\\n            n = (mask&data[i])==0 ? 0 : calc(data[i])-1; \\n            if(n<0 || i+n>=data.length) return false;\\n            if(n>0 && ((mask>>n+1)&data[i])!=0) return false;\\n        }\\n        return n==0;\\n    }\\n    \\n    int calc(int val){\\n        int n = 0;\\n        for(int mask = 128; (mask&val)!=0 && n!=4; n++)\\n            val = val<<1;\\n        return n==1 ? -1 : n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2570835,
                "title": "solution-explained-language-independent",
                "content": "After reading this solution, many of you might tag this problem as easy and not medium\\nDo let me know in comments if you guys find it difficult to understand some point, will keep those points in mind for future posts\\n\\nLet me first repost the desired part of question here :)\\n\\nThis is how the UTF-8 encoding would work:\\n\\n```\\n Number of Bytes   |        UTF-8 Octet Sequence\\n                       |              (binary)\\n   --------------------+-----------------------------------------\\n            1          |   0xxxxxxx\\n            2          |   110xxxxx 10xxxxxx\\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n```\\n\\nSo, a UTF-8 can have 1 to 4 byes\\n\\nLets break down the problem\\n0. We cannot have more than 4 bytes in UTF-8\\n1. To check the number of bytes i.e. 1,2,3,4 or something else\\n2. Now the next n-1 numbers should have 10 in their most significant bit\\n3. One more point, will cover later ;)\\n4. Lets bring it all togeather\\n\\nLet me take both parts one by one\\n\\n**1. To check the number of bytes i.e. 1,2,3,4 or something else**\\n\\nLet me create a method getNumberOfBytes, which takes an integer number as input and tell me the number of bytes in this sequence\\n\\n```\\n public int getNumberOfBytes(int data){\\n        //If it starts with 0 then, right shifting it by 7 times gives 0\\n        if((data>>7)==0) return 1;\\n        //If it starts with 110, then right shifting by 5 times gives 110 i.e. 6\\n        if((data>>5)==6) return 2;\\n        //If it starts with 1110, then right shifting by 4 times gives 1110 i.e. 14\\n        if((data>>4)==14) return 3;\\n        //If it starts with 11110, then right shifting by 3 times gives 11110 i.e. 30\\n        if((data>>3)==30) return 4;\\n        else return -1;\\n    }\\n```\\n\\n**2. Now the next n-1 numbers should have 10 in their most significant bit**\\nThis will check, if the number actually has 10 in its MSB.\\nThis will be called for the next n-1 numbers\\'\\n```\\n//To check if number actually starts with 10\\n    public boolean isTrailingNumber(int data){\\n        //If it starts with 10, then right shifting by 6 times gives 10 i.e. 2\\n        return ((data>>6)==2);\\n    }\\n```\\n\\n**3. One more point, will cover later ;)**\\nNow, we find out the number of bits in point 1, and for remaining n-1 elements we checked if they are having 10 in their MSB.\\nWhat if we get number of bytes as n, but we dont have n numbes after that ?\\nSo, its better if after getting the number of bytes we also check if we have n-1 numbers after it. This will save our bit operation for trailing numbers\\n\\n**4. Lets bring it all togeather**\\nNow, lets write our parent code which uses the code written in 1 & 2 plus some more logic :)\\n\\nI will be using a pointer technique here to iterate over array.\\n\\n```\\npublic boolean validUtf8(int[] data) {\\n        //Initialize pointer to 0\\n        int p=0;\\n        //Run a loop till pointer reaches the end\\n        while(p<data.length){\\n            //Get the number of bytes for the data\\n            int numberOfBytes = getNumberOfBytes(data[p]);\\n            //If number of bytes is not 1,2,3 or 4 or something else, we will return false\\n            if(numberOfBytes==-1) return false;\\n            //To check if we have n-1 number after this point\\n            if(numberOfBytes>data.length-p) return false;\\n            //Increment the pointer for next iteration\\n            p++;\\n            //Now if we have numberOfBytes more than 1, we need to check that next n-1 numbers should start with 10 in MSB\\n            while (numberOfBytes>1){\\n                //Using the numberOfBytes as the counter itself\\n                numberOfBytes--;\\n                //If this number doesn\\'t starts with 10, we can return false from here\\n                if(!isTrailingNumber(data[p]))\\n                    return false;\\n                //Increment the main pointer so we dont process this entry again :)\\n                p++;\\n            }\\n        }\\n        //If everything goes right, we will land here :)\\n        return true;\\n    }\\n\\n```\\nPlease comment and upvote guys if you like this solution",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n Number of Bytes   |        UTF-8 Octet Sequence\\n                       |              (binary)\\n   --------------------+-----------------------------------------\\n            1          |   0xxxxxxx\\n            2          |   110xxxxx 10xxxxxx\\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n```\n```\\n public int getNumberOfBytes(int data){\\n        //If it starts with 0 then, right shifting it by 7 times gives 0\\n        if((data>>7)==0) return 1;\\n        //If it starts with 110, then right shifting by 5 times gives 110 i.e. 6\\n        if((data>>5)==6) return 2;\\n        //If it starts with 1110, then right shifting by 4 times gives 1110 i.e. 14\\n        if((data>>4)==14) return 3;\\n        //If it starts with 11110, then right shifting by 3 times gives 11110 i.e. 30\\n        if((data>>3)==30) return 4;\\n        else return -1;\\n    }\\n```\n```\\n//To check if number actually starts with 10\\n    public boolean isTrailingNumber(int data){\\n        //If it starts with 10, then right shifting by 6 times gives 10 i.e. 2\\n        return ((data>>6)==2);\\n    }\\n```\n```\\npublic boolean validUtf8(int[] data) {\\n        //Initialize pointer to 0\\n        int p=0;\\n        //Run a loop till pointer reaches the end\\n        while(p<data.length){\\n            //Get the number of bytes for the data\\n            int numberOfBytes = getNumberOfBytes(data[p]);\\n            //If number of bytes is not 1,2,3 or 4 or something else, we will return false\\n            if(numberOfBytes==-1) return false;\\n            //To check if we have n-1 number after this point\\n            if(numberOfBytes>data.length-p) return false;\\n            //Increment the pointer for next iteration\\n            p++;\\n            //Now if we have numberOfBytes more than 1, we need to check that next n-1 numbers should start with 10 in MSB\\n            while (numberOfBytes>1){\\n                //Using the numberOfBytes as the counter itself\\n                numberOfBytes--;\\n                //If this number doesn\\'t starts with 10, we can return false from here\\n                if(!isTrailingNumber(data[p]))\\n                    return false;\\n                //Increment the main pointer so we dont process this entry again :)\\n                p++;\\n            }\\n        }\\n        //If everything goes right, we will land here :)\\n        return true;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569230,
                "title": "python-bit-manipulation-explained-and-commented",
                "content": "# Logic explanation\\n1. We need to check for UTF-8 validity, the rules:\\n* Either the character is encoded on the first byte, which starts with 0xxxxxxx\\n* Or the character is encoded on `2<=n<=4` bytes, where the first byte starts with `n` set bits, followed by 1 unset bit, and the rest of the n-1 bytes should start with 10xxxxxx\\n\\n2. We are given an array of data integers, we care only about the least significant byte (last 8 bits)\\n\\n3. Simulate that logic\\n\\nThe code is heavily commented, go through it.\\n\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        i = 0\\n        \\n        while i < n:\\n            valid_encoding = False\\n            if self.one_byte_encoding(data[i]):\\n                i += 1\\n                valid_encoding = True\\n            \\n            for byte_len in range(2, 4 + 1):\\n                if self.byte_encoding(byte_len, data, i):\\n                    i += byte_len\\n                    valid_encoding = True\\n                    break\\n            \\n            if not valid_encoding:\\n                return False\\n        return True\\n    \\n    def one_byte_encoding(self, number: int):\\n\\t\\t# check if 8th bit is set\\n        if number & 1 << 7 == 0:\\n            return True\\n        return False\\n\\n    def byte_encoding(self, byte_len, data, i):\\n        # out of bound check\\n        if i + byte_len > len(data):\\n            return False\\n\\n        # first byte should be byte_len 1\\'s followed by 0\\n        first_byte = data[i]\\n        for j in range(byte_len):\\n            if first_byte & 1<<(7-j) == 0:\\n                return False\\n\\n        # check n+1 bit to be 0\\n        if first_byte & 1 << 7 - byte_len != 0:\\n            return False\\n\\n\\t\\t# the rest n-1 bytes should be 10xxxxxx\\n        for j in range(i+1, i + 1 + (byte_len - 1)):\\n            # check 10xxxxxx\\n            if data[j] & 1<<7 == 0:\\n                return False\\n            if data[j] & 1<< 6 != 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        i = 0\\n        \\n        while i < n:\\n            valid_encoding = False\\n            if self.one_byte_encoding(data[i]):\\n                i += 1\\n                valid_encoding = True\\n            \\n            for byte_len in range(2, 4 + 1):\\n                if self.byte_encoding(byte_len, data, i):\\n                    i += byte_len\\n                    valid_encoding = True\\n                    break\\n            \\n            if not valid_encoding:\\n                return False\\n        return True\\n    \\n    def one_byte_encoding(self, number: int):\\n\\t\\t# check if 8th bit is set\\n        if number & 1 << 7 == 0:\\n            return True\\n        return False\\n\\n    def byte_encoding(self, byte_len, data, i):\\n        # out of bound check\\n        if i + byte_len > len(data):\\n            return False\\n\\n        # first byte should be byte_len 1\\'s followed by 0\\n        first_byte = data[i]\\n        for j in range(byte_len):\\n            if first_byte & 1<<(7-j) == 0:\\n                return False\\n\\n        # check n+1 bit to be 0\\n        if first_byte & 1 << 7 - byte_len != 0:\\n            return False\\n\\n\\t\\t# the rest n-1 bytes should be 10xxxxxx\\n        for j in range(i+1, i + 1 + (byte_len - 1)):\\n            # check 10xxxxxx\\n            if data[j] & 1<<7 == 0:\\n                return False\\n            if data[j] & 1<< 6 != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458797,
                "title": "javascript-solution-string-bit-manipulation",
                "content": "### The idea - String Manipulation\\n1. Convert into binary strings\\n2. Find the lengh of leading `1` using `indexOf(0)`\\n3. Use `current` as a counter for the on-going UTF8 length\\n4. A length of `1` or `>4`  is considered invalid\\n```\\nvar validUtf8 = function(data) {\\n    let binary = data.map((i)=>{\\n        let b = \"00000000\" + i.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n    let current = 0; // current UTF8 length\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            if (bytes==0) continue; // skip single byte character\\n            if (bytes > 4 || bytes < 2) return false; // length thats > 4 or < 2 is an invalid utf encoding\\n            current = bytes; // set the remaining length\\n        } else {\\n            if (bytes != 1) return false\\n        }\\n        current--;\\n    }\\n    return current==0;\\n};\\n```\\n### The idea - Bit Manipulation\\n1. Exactly the same, but using bit masks.\\n``` javascript \\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    let mostSig = 1<<7;\\n    let secSig = 1<<6\\n    for (let n of data) {\\n        if (count == 0) {\\n            let mask = 1<<7;\\n            while (n & mask) {\\n                mask = mask>>1;\\n                count++;\\n            }\\n            if (count == 0) continue;\\n            if (count == 1 || count > 4) return false;\\n        } else {\\n            if (!(n&mostSig && !(n&secSig))) return false;\\n        }\\n        count--;\\n    }\\n    return count == 0;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar validUtf8 = function(data) {\\n    let binary = data.map((i)=>{\\n        let b = \"00000000\" + i.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n    let current = 0; // current UTF8 length\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            if (bytes==0) continue; // skip single byte character\\n            if (bytes > 4 || bytes < 2) return false; // length thats > 4 or < 2 is an invalid utf encoding\\n            current = bytes; // set the remaining length\\n        } else {\\n            if (bytes != 1) return false\\n        }\\n        current--;\\n    }\\n    return current==0;\\n};\\n```\n``` javascript \\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    let mostSig = 1<<7;\\n    let secSig = 1<<6\\n    for (let n of data) {\\n        if (count == 0) {\\n            let mask = 1<<7;\\n            while (n & mask) {\\n                mask = mask>>1;\\n                count++;\\n            }\\n            if (count == 0) continue;\\n            if (count == 1 || count > 4) return false;\\n        } else {\\n            if (!(n&mostSig && !(n&secSig))) return false;\\n        }\\n        count--;\\n    }\\n    return count == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569878,
                "title": "short-and-easy-solution",
                "content": "Credits to @fight.for.dream!\\n\\n```csharp\\npublic bool ValidUtf8(int[] bytes)\\n{\\n\\tint n = 0;\\n\\n\\tforeach (int b in bytes)\\n\\t{\\n\\t\\tif (n == 0)\\n\\t\\t{\\n\\t\\t\\tif (b >> 5 == 0b110) { n = 1; continue; }\\n\\t\\t\\tif (b >> 4 == 0b1110) { n = 2; continue; }\\n\\t\\t\\tif (b >> 3 == 0b11110) { n = 3; continue; }\\n\\n\\t\\t\\tif (b >> 7 != 0) return false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (b >> 6 != 0b10) return false;\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn n == 0;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic bool ValidUtf8(int[] bytes)\\n{\\n\\tint n = 0;\\n\\n\\tforeach (int b in bytes)\\n\\t{\\n\\t\\tif (n == 0)\\n\\t\\t{\\n\\t\\t\\tif (b >> 5 == 0b110) { n = 1; continue; }\\n\\t\\t\\tif (b >> 4 == 0b1110) { n = 2; continue; }\\n\\t\\t\\tif (b >> 3 == 0b11110) { n = 3; continue; }\\n\\n\\t\\t\\tif (b >> 7 != 0) return false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (b >> 6 != 0b10) return false;\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn n == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569516,
                "title": "java-easy-fast-bit-manipulations",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for UTF-8 Validation.\\nMemory Usage: 42.9 MB, less than 93.01% of Java online submissions for UTF-8 Validation.\\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if     ((data[i]>>7) == 0) i++;\\n      else if((data[i]>>5) == 6  && i+1 < data.length && (data[i+1]>>6) == 2) i += 2;\\n      else if((data[i]>>4) == 14 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if((data[i]>>3) == 30 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }\\n}\\n```\\n\\n**less eficient version:**\\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if((data[i]>>7) == 0) i++;\\n      else if(i+1 < data.length && (data[i]>>5) == 6  && (data[i+1]>>6) == 2) i += 2;\\n      else if(i+2 < data.length && (data[i]>>4) == 14 && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if(i+2 < data.length && (data[i]>>3) == 30 && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if     ((data[i]>>7) == 0) i++;\\n      else if((data[i]>>5) == 6  && i+1 < data.length && (data[i+1]>>6) == 2) i += 2;\\n      else if((data[i]>>4) == 14 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if((data[i]>>3) == 30 && i+2 < data.length && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }\\n}\\n```\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    \\n    for(int i = 0; i < data.length;)\\n      if((data[i]>>7) == 0) i++;\\n      else if(i+1 < data.length && (data[i]>>5) == 6  && (data[i+1]>>6) == 2) i += 2;\\n      else if(i+2 < data.length && (data[i]>>4) == 14 && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2) i += 3;\\n      else if(i+2 < data.length && (data[i]>>3) == 30 && (data[i+1]>>6) == 2 && (data[i+2]>>6) == 2 && (data[i+3]>>6) == 2) i += 4;\\n      else return false;\\n    \\n    return true;      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569103,
                "title": "c-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        for(int i=0;i<data.size();i++){\\n            int x=0,y=data[i];\\n            for(int j=7;j>=0;j--){\\n                if(!(y&(1<<j)))break;\\n                x++;\\n            }\\n            int t=x-1,j=i+1;\\n            if(x==1||x>4)return false;\\n            while(t>0 && j<data.size()){\\n               y=data[j];\\n               int b1=(1<<7),b2=(1<<6); \\n               if(!((y&b1) && !(y&b2))){\\n                   return false;\\n               } \\n               j++;t--; \\n            }\\n            if(t>0)return false;\\n            i=j-1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        for(int i=0;i<data.size();i++){\\n            int x=0,y=data[i];\\n            for(int j=7;j>=0;j--){\\n                if(!(y&(1<<j)))break;\\n                x++;\\n            }\\n            int t=x-1,j=i+1;\\n            if(x==1||x>4)return false;\\n            while(t>0 && j<data.size()){\\n               y=data[j];\\n               int b1=(1<<7),b2=(1<<6); \\n               if(!((y&b1) && !(y&b2))){\\n                   return false;\\n               } \\n               j++;t--; \\n            }\\n            if(t>0)return false;\\n            i=j-1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569000,
                "title": "java-easy-solution-bit-manipulation-97-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    private static final int bit_7_mask = 1 << 7;\\n    private static final int bit_6_mask = 1 << 6;\\n    private static final int bit_5_mask = 1 << 5;\\n    private static final int bit_4_mask = 1 << 4;\\n    private static final int bit_3_mask = 1 << 3;\\n    \\n    public boolean validUtf8(int[] data) {\\n        int size = data.length;\\n        \\n        int i = 0, count = 1;\\n        int first, byteZ;\\n        \\n        while( i < size) {\\n            first = data[i++];\\n            byteZ = getBytes(first);\\n            \\n            if(byteZ == -1)\\n                return false;\\n            \\n            while(count < byteZ) {\\n                count++;\\n                if ((i == size) || (data[i++] < bit_7_mask))\\n                    return false;\\n            }\\n            count = 1;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int getBytes(int first) {\\n        int i = 0;\\n\\n        if((first & bit_7_mask) == 0)\\n            return 1;\\n        \\n        else if((first & bit_6_mask) == 0)\\n            return -1;\\n        \\n        else if((first & bit_5_mask) == 0)\\n            return 2;\\n        \\n        else if((first & bit_4_mask) == 0)\\n            return 3;\\n        \\n        else if((first & bit_3_mask) == 0)\\n            return 4;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    private static final int bit_7_mask = 1 << 7;\\n    private static final int bit_6_mask = 1 << 6;\\n    private static final int bit_5_mask = 1 << 5;\\n    private static final int bit_4_mask = 1 << 4;\\n    private static final int bit_3_mask = 1 << 3;\\n    \\n    public boolean validUtf8(int[] data) {\\n        int size = data.length;\\n        \\n        int i = 0, count = 1;\\n        int first, byteZ;\\n        \\n        while( i < size) {\\n            first = data[i++];\\n            byteZ = getBytes(first);\\n            \\n            if(byteZ == -1)\\n                return false;\\n            \\n            while(count < byteZ) {\\n                count++;\\n                if ((i == size) || (data[i++] < bit_7_mask))\\n                    return false;\\n            }\\n            count = 1;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int getBytes(int first) {\\n        int i = 0;\\n\\n        if((first & bit_7_mask) == 0)\\n            return 1;\\n        \\n        else if((first & bit_6_mask) == 0)\\n            return -1;\\n        \\n        else if((first & bit_5_mask) == 0)\\n            return 2;\\n        \\n        else if((first & bit_4_mask) == 0)\\n            return 3;\\n        \\n        else if((first & bit_3_mask) == 0)\\n            return 4;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387751,
                "title": "easy-c-solution-using-bitmasking-beats-69",
                "content": "\\n```\\nint rb=0;\\n        for(auto i:data){\\n            if(rb==0){\\n                \\n                if((i>>7)==0){\\n                    rb=0;\\n                }else if((i>>5)==0b110){\\n                    rb=1;\\n                }else if((i>>4)==0b1110){\\n                    rb=2;\\n                }else if((i>>3)==0b11110){\\n                    rb=3;\\n                }else return false;\\n                \\n            }else{\\n                if((i>>6)==0b10) rb--;\\n                else return false;\\n            }\\n        }\\n        if(rb==0) return true;\\n        else return false;\\n```",
                "solutionTags": [],
                "code": "```\\nint rb=0;\\n        for(auto i:data){\\n            if(rb==0){\\n                \\n                if((i>>7)==0){\\n                    rb=0;\\n                }else if((i>>5)==0b110){\\n                    rb=1;\\n                }else if((i>>4)==0b1110){\\n                    rb=2;\\n                }else if((i>>3)==0b11110){\\n                    rb=3;\\n                }else return false;\\n                \\n            }else{\\n                if((i>>6)==0b10) rb--;\\n                else return false;\\n            }\\n        }\\n        if(rb==0) return true;\\n        else return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493355,
                "title": "java-dfa-solution-with-explanation",
                "content": "**Intuition**\\nIt\\'s obviously a bit manipulation problem. But also there are lots of states need to be considered. An encoded UTF-8 character is possiblely represented by 1 to 4 bytes, which actually depends on the first byte. So after we have encountered the first byte, the next following 0 ~ 3 byte(s) must satisfy some constraints. Isn\\'t it like a state machine? Namely, DFA (Deterministic Finite Automaton).\\n**Algorithm**\\nFollow me up to build the DFA. Input is a byte represented by an integer and initial state is `0` (clear, all previous bytes are handled). Then all the valid inputs are `0xxxxxxx`, `110xxxxx`, `1110xxxxx`, `11110xxx`. So state `0` can transfer to four states. Wait, just think of the input `0xxxxxxx`: it means a single byte UTF-8 character, so all the previous byte are cleared again. Here I directly give the DFA. Any question is welcome.\\n![image](https://assets.leetcode.com/users/zdxiq125/image_1580299754.png)\\nWe take  a quick glance of the longest path `0` -> `3` -> `5` -> `6` -> `0`, which is relate to a 4-byte UTF-8 character. After encounters four bytes (`11110xxx`, `10xxxxxx`, `10xxxxxx`, `10xxxxxx` in order), the state return to `0` again. Any other inputs are illegal and will result validation failure. State `0` is the initial state and the final state.\\n**Code**\\n```java\\nclass Solution {\\n    // input types: determined by most significant 1 ~ 5 bits\\n    static final int TYPE_0 = 0b00000000;\\n    static final int TYPE_1 = 0b10000000;\\n    static final int TYPE_2 = 0b11000000;\\n    static final int TYPE_3 = 0b11100000;\\n    static final int TYPE_4 = 0b11110000;\\n    // masks for most significant 1 to 5 bis\\n    static final int[] MASKS = new int[]{0b10000000, 0b11000000, 0b11100000, 0b11110000, 0b11111000};\\n    // input type enumation\\n    static final int[] TYPES = new int[]{TYPE_0, TYPE_1, TYPE_2, TYPE_3, TYPE_4};\\n    // map of cur_stat : (input_type : next_stat)\\n    static final Map<Integer, Map<Integer, Integer>> DFA = new HashMap<>();\\n\\t\\n\\tprivate static int getType(int in) {\\n        // type 0: 0xxxxxxx\\n        // type 1: 10xxxxxx\\n        // type 2: 110xxxxx\\n        // type 3: 1110xxxx\\n        // type 4: 11110xxx\\n        for (int i = 0; i < TYPES.length; i++) {\\n            if ((MASKS[i] & in) == TYPES[i]) {\\n                return TYPES[i];\\n            }\\n        }\\n\\t\\t// unreachable. unless input is \"11111xxx\" which is not a valid utf-8 character.\\n        return -1;\\n    }\\n    // build the dfa\\n    static {\\n        DFA.put(0, Map.of(TYPE_0, 0, TYPE_2, 1, TYPE_3, 2, TYPE_4, 3));\\n        DFA.put(1, Map.of(TYPE_1, 0));\\n        DFA.put(2, Map.of(TYPE_1, 4));\\n        DFA.put(4, Map.of(TYPE_1, 0));\\n        DFA.put(3, Map.of(TYPE_1, 5));\\n        DFA.put(5, Map.of(TYPE_1, 6));\\n        DFA.put(6, Map.of(TYPE_1, 0));\\n    }\\n    \\n    public boolean validUtf8(int[] data) {\\n        int cur = 0;\\n        for (int input : data) {\\n            Integer next = getNext(cur, input);\\n            if (next == null) {\\n                return false;\\n            }\\n            cur = next;\\n        }\\n        return cur == 0;\\n    }\\n    \\n    private static Integer getNext(int cur, int input) {\\n        int type = getType(input);\\n        if (type == -1) return null;\\n        return DFA.get(cur).get(type);\\n    }\\n}\\n```\\n**Complexity**\\nTime: O(n)\\nSpace: O(1)",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    // input types: determined by most significant 1 ~ 5 bits\\n    static final int TYPE_0 = 0b00000000;\\n    static final int TYPE_1 = 0b10000000;\\n    static final int TYPE_2 = 0b11000000;\\n    static final int TYPE_3 = 0b11100000;\\n    static final int TYPE_4 = 0b11110000;\\n    // masks for most significant 1 to 5 bis\\n    static final int[] MASKS = new int[]{0b10000000, 0b11000000, 0b11100000, 0b11110000, 0b11111000};\\n    // input type enumation\\n    static final int[] TYPES = new int[]{TYPE_0, TYPE_1, TYPE_2, TYPE_3, TYPE_4};\\n    // map of cur_stat : (input_type : next_stat)\\n    static final Map<Integer, Map<Integer, Integer>> DFA = new HashMap<>();\\n\\t\\n\\tprivate static int getType(int in) {\\n        // type 0: 0xxxxxxx\\n        // type 1: 10xxxxxx\\n        // type 2: 110xxxxx\\n        // type 3: 1110xxxx\\n        // type 4: 11110xxx\\n        for (int i = 0; i < TYPES.length; i++) {\\n            if ((MASKS[i] & in) == TYPES[i]) {\\n                return TYPES[i];\\n            }\\n        }\\n\\t\\t// unreachable. unless input is \"11111xxx\" which is not a valid utf-8 character.\\n        return -1;\\n    }\\n    // build the dfa\\n    static {\\n        DFA.put(0, Map.of(TYPE_0, 0, TYPE_2, 1, TYPE_3, 2, TYPE_4, 3));\\n        DFA.put(1, Map.of(TYPE_1, 0));\\n        DFA.put(2, Map.of(TYPE_1, 4));\\n        DFA.put(4, Map.of(TYPE_1, 0));\\n        DFA.put(3, Map.of(TYPE_1, 5));\\n        DFA.put(5, Map.of(TYPE_1, 6));\\n        DFA.put(6, Map.of(TYPE_1, 0));\\n    }\\n    \\n    public boolean validUtf8(int[] data) {\\n        int cur = 0;\\n        for (int input : data) {\\n            Integer next = getNext(cur, input);\\n            if (next == null) {\\n                return false;\\n            }\\n            cur = next;\\n        }\\n        return cur == 0;\\n    }\\n    \\n    private static Integer getNext(int cur, int input) {\\n        int type = getType(input);\\n        if (type == -1) return null;\\n        return DFA.get(cur).get(type);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257077,
                "title": "393-time-93-77-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a counter variable count to keep track of how many continuation bytes are expected.\\n```\\ncount = 0\\n```\\n2. Iterate through each integer in the input data list data.\\n```\\nfor num in data:\\n```\\n3. If the count is 0, check how many leading 1\\'s there are in the current integer to determine how many bytes are expected for the current character. If the first few bits of the current integer do not match any valid UTF-8 patterns or if the first bit of the current integer is a 1 (indicating that it is not the start of a character), return False.\\n```\\nif count == 0:\\n    if (num >> 5) == 0b110:\\n        count = 1\\n    elif (num >> 4) == 0b1110:\\n        count = 2\\n    elif (num >> 3) == 0b11110:\\n        count = 3\\n    elif (num >> 7) != 0:\\n        return False\\n```\\n4. If the count is not 0, check if the current integer is a continuation byte (i.e. the first two bits are 10). If not, return False. Subtract 1 from the count since a continuation byte has been encountered.\\n```\\nelse:\\n    if (num >> 6) != 0b10:\\n        return False\\n    count -= 1\\n```\\n5. After iterating through all the integers, if the count is still not 0, it is invalid. Return False.\\n```\\nreturn count == 0\\n```\\nOverall, the solution works by iterating through each integer in the input data list and checking if it is a valid start byte or continuation byte for a UTF-8 character. The count variable is used to keep track of how many continuation bytes are expected for the current character. If the input data list contains a valid sequence of bytes for a UTF-8 character, the count variable should end up at 0 after all the integers have been processed.\\n\\n# Complexity\\n- Time complexity:\\nThe solution involves iterating through each integer in the input data list exactly once. Within the iteration, the bitwise operations used to check the number of leading 1\\'s and the continuation bytes take constant time. Therefore, the time complexity of the solution is O(n), where n is the length of the input data list.\\n\\n- Space complexity:\\nThe solution uses a constant amount of extra space to store the counter variable. Therefore, the space complexity of the solution is O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        # Initialize a counter variable\\n        count = 0\\n        \\n        # Iterate through each integer in the input data list\\n        for num in data:\\n            # If the count is 0, check how many leading 1\\'s there are in the current integer\\n            if count == 0:\\n                if (num >> 5) == 0b110:\\n                    count = 1\\n                elif (num >> 4) == 0b1110:\\n                    count = 2\\n                elif (num >> 3) == 0b11110:\\n                    count = 3\\n                elif (num >> 7) != 0:\\n                    return False\\n            # If the count is not 0, check if the current integer is a continuation byte\\n            else:\\n                if (num >> 6) != 0b10:\\n                    return False\\n                count -= 1\\n        \\n        # If the count is still not 0 after iterating through all the integers, it is invalid\\n        return count == 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\ncount = 0\\n```\n```\\nfor num in data:\\n```\n```\\nif count == 0:\\n    if (num >> 5) == 0b110:\\n        count = 1\\n    elif (num >> 4) == 0b1110:\\n        count = 2\\n    elif (num >> 3) == 0b11110:\\n        count = 3\\n    elif (num >> 7) != 0:\\n        return False\\n```\n```\\nelse:\\n    if (num >> 6) != 0b10:\\n        return False\\n    count -= 1\\n```\n```\\nreturn count == 0\\n```\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        # Initialize a counter variable\\n        count = 0\\n        \\n        # Iterate through each integer in the input data list\\n        for num in data:\\n            # If the count is 0, check how many leading 1\\'s there are in the current integer\\n            if count == 0:\\n                if (num >> 5) == 0b110:\\n                    count = 1\\n                elif (num >> 4) == 0b1110:\\n                    count = 2\\n                elif (num >> 3) == 0b11110:\\n                    count = 3\\n                elif (num >> 7) != 0:\\n                    return False\\n            # If the count is not 0, check if the current integer is a continuation byte\\n            else:\\n                if (num >> 6) != 0b10:\\n                    return False\\n                count -= 1\\n        \\n        # If the count is still not 0 after iterating through all the integers, it is invalid\\n        return count == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568921,
                "title": "o-n-o-n-na-ve-solution-no-bit-manipulation",
                "content": "A very simple solution with both time and space complexity being `O(N)`.\\n\\n**Approach**\\n* The basic idea is that we need a binary representation of the integers so create a list of binary representations.\\n* Next, we iterate through this list and check if the current binary string represents a 1-byte or a 2-byte or a 3-byte or a 4-byte data.\\n* If the current string represents a `1`-byte data we move to the next string\\n* If the current string represents a `k`-byte data where we `k=2,3,4`, we also check if we have at least `1,2,3` additional bytes next to it respectively. If it does, we check these bytes first two characters to be `10` and increment the loop variable `i` accordingly.\\n* If none of the above checks is true for the current string, the `else` case, it is an invalid UTF-8 representation and we return `False`.\\n* At the end of the loop we return True since it has gone through all the numbers at this point which verifies the array to be a valid UTF-8 encoding.\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n\\t    # a list to store binary representation of the numbers\\n        sequence = []\\n\\t\\t# get binary representation of all the numbers\\n        for d in data:\\n            sequence.append(\"{0:08b}\".format(d))\\n        \\n        i = 0\\n        n = len(sequence)\\n        while i < n:\\n            if sequence[i][0] == \\'0\\': # 1-byte check\\n                i += 1\\n                continue\\n            if sequence[i][:3] == \\'110\\' and n-i>=1: # 2-byte check\\n                if sequence[i+1][:2] == \\'10\\':\\n                    i += 2\\n                    continue\\n            if sequence[i][:4] == \\'1110\\' and n-i>=2: # 3-byte check\\n                if sequence[i+1][:2] == \\'10\\' and sequence[i+2][:2] == \\'10\\':\\n                    i += 3\\n                    continue\\n            if sequence[i][:5] == \\'11110\\' and n-i>=3: # 4-byte check\\n                if sequence[i+1][:2] == \\'10\\' and sequence[i+2][:2] == \\'10\\' and sequence[i+3][:2] == \\'10\\':\\n                    i += 4\\n                    continue\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n\\t    # a list to store binary representation of the numbers\\n        sequence = []\\n\\t\\t# get binary representation of all the numbers\\n        for d in data:\\n            sequence.append(\"{0:08b}\".format(d))\\n        \\n        i = 0\\n        n = len(sequence)\\n        while i < n:\\n            if sequence[i][0] == \\'0\\': # 1-byte check\\n                i += 1\\n                continue\\n            if sequence[i][:3] == \\'110\\' and n-i>=1: # 2-byte check\\n                if sequence[i+1][:2] == \\'10\\':\\n                    i += 2\\n                    continue\\n            if sequence[i][:4] == \\'1110\\' and n-i>=2: # 3-byte check\\n                if sequence[i+1][:2] == \\'10\\' and sequence[i+2][:2] == \\'10\\':\\n                    i += 3\\n                    continue\\n            if sequence[i][:5] == \\'11110\\' and n-i>=3: # 4-byte check\\n                if sequence[i+1][:2] == \\'10\\' and sequence[i+2][:2] == \\'10\\' and sequence[i+3][:2] == \\'10\\':\\n                    i += 4\\n                    continue\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568848,
                "title": "python3-dp-memoization-neat-solution-o-n",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        l = [2**i for i in range(7, -1, -1)]\\n        \\n        def isXByteSeq(pos, X):\\n            f = data[pos]\\n            rem = data[pos+1:pos+X]\\n            ret = (f&l[X]) == 0\\n            for i in range(X):\\n                ret &= (f&l[i]) != 0\\n            for num in rem:\\n                ret &= (num&l[0]) != 0\\n                ret &= (num&l[1]) == 0\\n            return ret\\n            \\n        @cache\\n        def res(pos = 0):\\n            ret = False\\n            if pos == n:\\n                ret = True\\n            if pos + 3 < n:\\n                ret |= isXByteSeq(pos, 4) and res(pos + 4)\\n            if pos + 2 < n:\\n                ret |= isXByteSeq(pos, 3) and res(pos + 3)\\n            if pos + 1 < n:\\n                ret |= isXByteSeq(pos, 2) and res(pos + 2)\\n            if pos < n:\\n                ret |= isXByteSeq(pos, 0) and res(pos + 1)\\n            return ret\\n        \\n        return res()\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        l = [2**i for i in range(7, -1, -1)]\\n        \\n        def isXByteSeq(pos, X):\\n            f = data[pos]\\n            rem = data[pos+1:pos+X]\\n            ret = (f&l[X]) == 0\\n            for i in range(X):\\n                ret &= (f&l[i]) != 0\\n            for num in rem:\\n                ret &= (num&l[0]) != 0\\n                ret &= (num&l[1]) == 0\\n            return ret\\n            \\n        @cache\\n        def res(pos = 0):\\n            ret = False\\n            if pos == n:\\n                ret = True\\n            if pos + 3 < n:\\n                ret |= isXByteSeq(pos, 4) and res(pos + 4)\\n            if pos + 2 < n:\\n                ret |= isXByteSeq(pos, 3) and res(pos + 3)\\n            if pos + 1 < n:\\n                ret |= isXByteSeq(pos, 2) and res(pos + 2)\\n            if pos < n:\\n                ret |= isXByteSeq(pos, 0) and res(pos + 1)\\n            return ret\\n        \\n        return res()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568689,
                "title": "daily-leetcoding-challenge-september-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/utf-8-validation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** String Manipulation.\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/utf-8-validation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 87452,
                "title": "27-49-pass-python-easy-to-understand-don-t-understand-why-case-250-145-145-145-145-need-return-false",
                "content": "Failed for case [250, 145, 145, 145, 145], expect false, my code return true.\\n\\nDon't understand why this case is false.\\n-----------------------------------------------------------\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        print \"inputed data = \", data\\n        numData = len(data)\\n        print \"numData = \", numData\\n\\n        if numData < 1:\\n            return False\\n\\n        binData = []\\n        for d in data:\\n            binData.append(str('{:08b}'.format(d)))\\n        # binData = bin(data)\\n        #\\n        print \"binData = \", binData\\n\\n        def detectOnes(string):\\n            #print \"detectOnes string = \", string\\n\\n            try:\\n                firstZero = string.index('0')\\n            except:\\n                firstZero = 8\\n            #print \"firstZero = \", firstZero\\n\\n            numStartOnes = firstZero\\n            #print \"numStartOnes = \", numStartOnes\\n\\n            return numStartOnes\\n\\n        flagValid = True\\n        while len(binData) > 0 and flagValid == True:\\n            curBinData = binData.pop(0)\\n            print \"curBinData = \", curBinData\\n\\n            curFirstZero = detectOnes(curBinData)\\n            print \"curFirstZero = \", curFirstZero\\n\\n            if curFirstZero == 0:\\n                print \"start with 0, must be a unicode code\"\\n            elif curFirstZero == 1:\\n                print \"one 1 in beginning of string\"\\n                flagValid = False\\n                break\\n            elif curFirstZero == 8:\\n                print \"something is wrong, not valid\"\\n                flagValid = False\\n                break\\n            else:\\n                print \"need more check\"\\n                for i in range(1, curFirstZero):\\n                    if len(binData) < 1:\\n                        flagValid = False\\n                        break\\n\\n                    newCurBinData = binData.pop(0)\\n                    print \"newCurBinData = \", newCurBinData\\n                    if detectOnes(newCurBinData) != 1:\\n                        flagValid = False\\n                        break\\n\\n\\n        print \"return flagValid = \", flagValid\\n        return flagValid",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        print \"inputed data = \", data\\n        numData = len(data)\\n        print \"numData = \", numData\\n\\n        if numData < 1:\\n            return False\\n\\n        binData = []\\n        for d in data:\\n            binData.append(str('{:08b}",
                "codeTag": "Java"
            },
            {
                "id": 87489,
                "title": "o-n-solution-using-java",
                "content": "\\n```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int n = data.length;\\n        if (n == 0) return true;\\n        int skip = 0b10000000;\\n        int check = 0;\\n        for (int i = 0; i < data.length; i++) {\\n            if (check > 0) {\\n                if ((data[i] & skip) == skip) check--;\\n                else return false;\\n            } else {\\n                check = getOneBitCountFromHead(data[i]);\\n                if (check < 0) return false;\\n            }\\n        }\\n        return check == 0;\\n    }\\n    private int getOneBitCountFromHead(int num) {\\n        if ((num & 0b11110000) == 0b11110000) return 3;\\n        if ((num & 0b11100000) == 0b11100000) return 2;\\n        if ((num & 0b11000000) == 0b11000000) return 1;\\n        if ((num & 0b10000000) == 0b10000000) return -1; //error\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int n = data.length;\\n        if (n == 0) return true;\\n        int skip = 0b10000000;\\n        int check = 0;\\n        for (int i = 0; i < data.length; i++) {\\n            if (check > 0) {\\n                if ((data[i] & skip) == skip) check--;\\n                else return false;\\n            } else {\\n                check = getOneBitCountFromHead(data[i]);\\n                if (check < 0) return false;\\n            }\\n        }\\n        return check == 0;\\n    }\\n    private int getOneBitCountFromHead(int num) {\\n        if ((num & 0b11110000) == 0b11110000) return 3;\\n        if ((num & 0b11100000) == 0b11100000) return 2;\\n        if ((num & 0b11000000) == 0b11000000) return 1;\\n        if ((num & 0b10000000) == 0b10000000) return -1; //error\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577038,
                "title": "python3-10-lines-binary-pad-w-explanation-t-m-95-97",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        \\n        count = 0                                   # Keep a tally of non-first bytes required\\n        \\n        for byte in data:                           # Pad out bytes to nine digits and ignore the 1st 1\\n            byte|= 256                                  # Ex: 35 = 0b100101 --> 35|256 = 0b1_00100101\\n\\t\\t\\t\\n                                                    # Check for bad bytes.\\n            if (byte >> 3 == 0b1_11111 or               # One of first five digits must be a 1\\n                (byte >> 6 == 0b1_10)^(count>0)):       # Non-first byte can happen if and only if the current count !=0.\\n                return False\\n                                                    # Update counts after new byte. (1-byte -> no change\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# to count required because count == 0.)\\n            if   byte >> 5 == 0b1_110 : count = 1       # 2-byte first byte\\n            elif byte >> 4 == 0b1_1110: count = 2       # 3-byte first byte\\n            elif byte >> 4 == 0b1_1111: count = 3       # 4-byte first byte\\n            elif byte >> 6 == 0b1_10  : count-= 1       # non-first bytes\\n\\n        return not count                            # Check for zero-count at EOL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        \\n        count = 0                                   # Keep a tally of non-first bytes required\\n        \\n        for byte in data:                           # Pad out bytes to nine digits and ignore the 1st 1\\n            byte|= 256                                  # Ex: 35 = 0b100101 --> 35|256 = 0b1_00100101\\n\\t\\t\\t\\n                                                    # Check for bad bytes.\\n            if (byte >> 3 == 0b1_11111 or               # One of first five digits must be a 1\\n                (byte >> 6 == 0b1_10)^(count>0)):       # Non-first byte can happen if and only if the current count !=0.\\n                return False\\n                                                    # Update counts after new byte. (1-byte -> no change\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# to count required because count == 0.)\\n            if   byte >> 5 == 0b1_110 : count = 1       # 2-byte first byte\\n            elif byte >> 4 == 0b1_1110: count = 2       # 3-byte first byte\\n            elif byte >> 4 == 0b1_1111: count = 3       # 4-byte first byte\\n            elif byte >> 6 == 0b1_10  : count-= 1       # non-first bytes\\n\\n        return not count                            # Check for zero-count at EOL",
                "codeTag": "Java"
            },
            {
                "id": 2572762,
                "title": "c-easy-recursion-solution",
                "content": "//Consider all four cases and iterate the index based on which case you have encounter//\\n//if it reaches the last index without any problem, that means its the correct UTF-8 code//\\n\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> &data, int i,int n){\\n        if(i == n){\\n            return true;\\n        }\\n        if((data[i]&(1<<7)) == 0){\\n            return solve(data,i+1,n);\\n        }\\n        else if(i<(n-1) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0) return solve(data,i+2,n);\\n        }\\n        else if(i<(n-2) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) != 0 && (data[i]&(1<<4)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0 && (data[i+2]&(1<<7)) != 0 && (data[i+2]&(1<<6)) == 0) return solve(data,i+3,n);\\n        }\\n        else if(i<(n-3) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) != 0 && (data[i]&(1<<4)) != 0 && (data[i]&(1<<3)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0 && (data[i+2]&(1<<7)) != 0 && (data[i+2]&(1<<6)) == 0 && (data[i+3]&(1<<7)) != 0 && (data[i+3]&(1<<6)) == 0) return solve(data,i+4,n);\\n        }\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        return solve(data,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> &data, int i,int n){\\n        if(i == n){\\n            return true;\\n        }\\n        if((data[i]&(1<<7)) == 0){\\n            return solve(data,i+1,n);\\n        }\\n        else if(i<(n-1) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0) return solve(data,i+2,n);\\n        }\\n        else if(i<(n-2) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) != 0 && (data[i]&(1<<4)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0 && (data[i+2]&(1<<7)) != 0 && (data[i+2]&(1<<6)) == 0) return solve(data,i+3,n);\\n        }\\n        else if(i<(n-3) && (data[i]&(1<<7)) != 0 && (data[i]&(1<<6)) != 0 && (data[i]&(1<<5)) != 0 && (data[i]&(1<<4)) != 0 && (data[i]&(1<<3)) == 0){\\n            if((data[i+1]&(1<<7)) != 0 && (data[i+1]&(1<<6)) == 0 && (data[i+2]&(1<<7)) != 0 && (data[i+2]&(1<<6)) == 0 && (data[i+3]&(1<<7)) != 0 && (data[i+3]&(1<<6)) == 0) return solve(data,i+4,n);\\n        }\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        return solve(data,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570991,
                "title": "c-implementation-easiest-solution",
                "content": "class Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int cnt = 0;\\n        for (auto i : data) {\\n            if (cnt == 0) {\\n                if ((i >> 5) == 0b110) \\n                    cnt = 1;\\n                else if ((i >> 4) == 0b1110) \\n                    cnt = 2;\\n                else if ((i >> 3) == 0b11110)\\n                    cnt = 3;\\n                else if ((i >> 7)) \\n                    return false;\\n                \\n            } \\n            else {\\n                if ((i >> 6) != 0b10)\\n                    return false;\\n                cnt--;\\n            }\\n        }\\n        return cnt==0;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int cnt = 0;\\n        for (auto i : data) {\\n            if (cnt == 0) {\\n                if ((i >> 5) == 0b110) \\n                    cnt = 1;\\n                else if ((i >> 4) == 0b1110) \\n                    cnt = 2;\\n                else if ((i >> 3) == 0b11110)\\n                    cnt = 3;\\n                else if ((i >> 7)) \\n                    return false;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2570058,
                "title": "c-use-bit-manipulation",
                "content": "**Code:**\\n```\\nclass Solution \\n{\\npublic:\\n    bool validUtf8(vector<int>& data) \\n    {\\n        int cnt=0;\\n        for(auto it : data)\\n        {\\n            if(cnt==0) //for 1st 1 byte of data or first number, Eg-1: 197\\n            {\\n                //0b used for binary number\\n                if((it>>5) == 0b110) cnt=1; //check first 3 bit of it is equal to 110\\n                else if((it>>4) == 0b1110) cnt=2; //check first 4 bit of it is equal to 1110\\n                else if((it>>3) == 0b11110) cnt=3; //check first 5 bit of it is equal to 11110\\n                else if((it>>7)) return false;\\n            }\\n            \\n            else //for next bytes of data or remaining number,Eg-2: 130, 1\\n            {\\n                if(it>>6 != 0b10) return false; //check n-1 bytes equal to 10 or not\\n                cnt--;\\n            }\\n            \\n        }\\n        return cnt==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool validUtf8(vector<int>& data) \\n    {\\n        int cnt=0;\\n        for(auto it : data)\\n        {\\n            if(cnt==0) //for 1st 1 byte of data or first number, Eg-1: 197\\n            {\\n                //0b used for binary number\\n                if((it>>5) == 0b110) cnt=1; //check first 3 bit of it is equal to 110\\n                else if((it>>4) == 0b1110) cnt=2; //check first 4 bit of it is equal to 1110\\n                else if((it>>3) == 0b11110) cnt=3; //check first 5 bit of it is equal to 11110\\n                else if((it>>7)) return false;\\n            }\\n            \\n            else //for next bytes of data or remaining number,Eg-2: 130, 1\\n            {\\n                if(it>>6 != 0b10) return false; //check n-1 bytes equal to 10 or not\\n                cnt--;\\n            }\\n            \\n        }\\n        return cnt==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569537,
                "title": "python-very-simple-bit-shift",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        i = 0\\n        while i < len(data):\\n            if data[i] >> 7 == 0:\\n                i += 1\\n            elif data[i] >> 5 == 0b110:\\n                if i+1 == len(data) or data[i+1] >> 6 != 0b10:\\n                    return False\\n                i += 2\\n            elif data[i] >> 4 == 0b1110:\\n                if i+2 >= len(data) or data[i+1] >> 6 != 0b10 or data[i+2] >> 6 != 0b10:\\n                    return False\\n                i += 3\\n            elif data[i] >> 3 == 0b11110:\\n                if i+3 >= len(data) or data[i+1] >> 6 != 0b10 or data[i+2] >> 6 != 0b10 or data[i+3] >> 6 != 0b10:\\n                    return False\\n                i += 4\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        i = 0\\n        while i < len(data):\\n            if data[i] >> 7 == 0:\\n                i += 1\\n            elif data[i] >> 5 == 0b110:\\n                if i+1 == len(data) or data[i+1] >> 6 != 0b10:\\n                    return False\\n                i += 2\\n            elif data[i] >> 4 == 0b1110:\\n                if i+2 >= len(data) or data[i+1] >> 6 != 0b10 or data[i+2] >> 6 != 0b10:\\n                    return False\\n                i += 3\\n            elif data[i] >> 3 == 0b11110:\\n                if i+3 >= len(data) or data[i+1] >> 6 != 0b10 or data[i+2] >> 6 != 0b10 or data[i+3] >> 6 != 0b10:\\n                    return False\\n                i += 4\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569021,
                "title": "js-javascript-nubby-s-solution",
                "content": "# Any feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nconst validUtf8 = function(data) {\\n  let next;\\n  let arr = data.map((num) => num.toString(2).padStart(8, \"0\"));\\n  let len = arr.length;\\n  \\n  for (let i = 0; i < len; i++) {\\n    if (arr[i][0] === \\'0\\') continue;\\n    else {\\n      if (arr[i].slice(0,3) === \\'110\\') {\\n        next = 1;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else if (arr[i].slice(0, 4) === \\'1110\\') {\\n        next = 2;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else if (arr[i].slice(0,5) === \\'11110\\') {\\n        next = 3;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else return false;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst validUtf8 = function(data) {\\n  let next;\\n  let arr = data.map((num) => num.toString(2).padStart(8, \"0\"));\\n  let len = arr.length;\\n  \\n  for (let i = 0; i < len; i++) {\\n    if (arr[i][0] === \\'0\\') continue;\\n    else {\\n      if (arr[i].slice(0,3) === \\'110\\') {\\n        next = 1;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else if (arr[i].slice(0, 4) === \\'1110\\') {\\n        next = 2;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else if (arr[i].slice(0,5) === \\'11110\\') {\\n        next = 3;\\n        if (i + next >= len) return false;\\n        while (next) {\\n          next--;\\n          if (arr[++i].slice(0, 2) !== \\'10\\') return false;\\n        }\\n      } else return false;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568826,
                "title": "java-bit-manipulation-easy-playground-solution",
                "content": "***plz... upvote! if you find my solution helpful.*** \\n\\nStatus: **Accepted***\\nRuntime: 1 ms\\nMemory Usage: 47.5 MB\\nAll test cases passed.\\n\\n<iframe src=\"https://leetcode.com/playground/WwrAMyK4/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "***plz... upvote! if you find my solution helpful.*** \\n\\nStatus: **Accepted***\\nRuntime: 1 ms\\nMemory Usage: 47.5 MB\\nAll test cases passed.\\n\\n<iframe src=\"https://leetcode.com/playground/WwrAMyK4/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2568798,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let binary = data.map(d => {\\n        let b = \"00000000\" + d.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n// current UTF8 length\\nlet current = 0; \\n\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            // skip the single byte char\\n            if (bytes==0) {\\n                continue;\\n            }  \\n            if (bytes > 4 || bytes < 2) {\\n              return false;  \\n            }\\n            // set the remaining length\\n            current = bytes;\\n        } else {\\n            if (bytes != 1) {\\n                return false\\n            } \\n        }\\n        current--;\\n    }\\n    return current==0;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let binary = data.map(d => {\\n        let b = \"00000000\" + d.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n// current UTF8 length\\nlet current = 0; \\n\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            // skip the single byte char\\n            if (bytes==0) {\\n                continue;\\n            }  \\n            if (bytes > 4 || bytes < 2) {\\n              return false;  \\n            }\\n            // set the remaining length\\n            current = bytes;\\n        } else {\\n            if (bytes != 1) {\\n                return false\\n            } \\n        }\\n        current--;\\n    }\\n    return current==0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1380903,
                "title": "python-faster-100",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        eighth_bit = 1 << 7\\n        seventh_bit = 1 << 6\\n        sixth_bit = 1 << 5\\n        fifth_bit = 1 << 4\\n        fourth_bit = 1 << 3\\n        \\n        trailing_byte_count = 0\\n        for byte in data:\\n            if trailing_byte_count > 0:\\n                if (byte & eighth_bit) and not (byte & seventh_bit): #10xx_xxxx\\n                    trailing_byte_count -= 1\\n                    if trailing_byte_count < 0:\\n                        return False\\n                    continue\\n                else:\\n                    return False\\n            else:\\n                if not (byte & eighth_bit): # 0xxx_xxxx\\n                    continue\\n                else: # 1xxx_xxxx\\n                    if not (byte & seventh_bit): #10xx_xxxx\\n                        return False\\n                    # 11xx_xxxx\\n                    if not (byte & sixth_bit): # 110x_xxxx\\n                        trailing_byte_count = 1\\n                        continue\\n                    # 111x_xxxx\\n                    if not (byte & fifth_bit): # 1110_xxxx\\n                        trailing_byte_count = 2\\n                        continue\\n                    # 1111_xxxx\\n                    if not (byte & fourth_bit): # 1111_0xxx\\n                        trailing_byte_count = 3\\n                        continue\\n                    return False\\n        if trailing_byte_count != 0:\\n            return False\\n        return True\\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        eighth_bit = 1 << 7\\n        seventh_bit = 1 << 6\\n        sixth_bit = 1 << 5\\n        fifth_bit = 1 << 4\\n        fourth_bit = 1 << 3\\n        \\n        trailing_byte_count = 0\\n        for byte in data:\\n            if trailing_byte_count > 0:\\n                if (byte & eighth_bit) and not (byte & seventh_bit): #10xx_xxxx\\n                    trailing_byte_count -= 1\\n                    if trailing_byte_count < 0:\\n                        return False\\n                    continue\\n                else:\\n                    return False\\n            else:\\n                if not (byte & eighth_bit): # 0xxx_xxxx\\n                    continue\\n                else: # 1xxx_xxxx\\n                    if not (byte & seventh_bit): #10xx_xxxx\\n                        return False\\n                    # 11xx_xxxx\\n                    if not (byte & sixth_bit): # 110x_xxxx\\n                        trailing_byte_count = 1\\n                        continue\\n                    # 111x_xxxx\\n                    if not (byte & fifth_bit): # 1110_xxxx\\n                        trailing_byte_count = 2\\n                        continue\\n                    # 1111_xxxx\\n                    if not (byte & fourth_bit): # 1111_0xxx\\n                        trailing_byte_count = 3\\n                        continue\\n                    return False\\n        if trailing_byte_count != 0:\\n            return False\\n        return True\\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019254,
                "title": "easy-c-solution-bit-manipulation",
                "content": "```\\npublic class Solution {\\n    public bool ValidUtf8(int[] data) {\\n        int bytesLeft = 0;\\n        foreach (int num in data) {\\n            if (bytesLeft == 0) {\\n                if (num >> 7 == 0b0)\\n                    bytesLeft = 0;\\n                else if (num >> 5 == 0b110)\\n                    bytesLeft = 1;\\n                else if (num >> 4 == 0b1110)\\n                    bytesLeft = 2;\\n                else if (num >> 3 == 0b11110)\\n                    bytesLeft = 3;\\n                else\\n                    return false;\\n            }\\n            else {\\n                if (num >> 6 == 0b10)\\n                    bytesLeft--;\\n                else return false;\\n            }\\n        }\\n        \\n        return bytesLeft == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ValidUtf8(int[] data) {\\n        int bytesLeft = 0;\\n        foreach (int num in data) {\\n            if (bytesLeft == 0) {\\n                if (num >> 7 == 0b0)\\n                    bytesLeft = 0;\\n                else if (num >> 5 == 0b110)\\n                    bytesLeft = 1;\\n                else if (num >> 4 == 0b1110)\\n                    bytesLeft = 2;\\n                else if (num >> 3 == 0b11110)\\n                    bytesLeft = 3;\\n                else\\n                    return false;\\n            }\\n            else {\\n                if (num >> 6 == 0b10)\\n                    bytesLeft--;\\n                else return false;\\n            }\\n        }\\n        \\n        return bytesLeft == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825305,
                "title": "python3-straightforward-solution",
                "content": "While scanning the array, two cases pop up. \\n1) in the middle of a multi-byte \\n2) at the beginning \\n\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        cnt = 0 \\n        for x in data:\\n            x = bin(x)[2:].zfill(8)\\n            if cnt: # in the middle of multi-byte \\n                if x.startswith(\"10\"): cnt -= 1\\n                else: return False \\n            else: # beginning \\n                cnt = x.find(\"0\")\\n                if cnt == -1 or cnt == 1 or cnt > 4: return False \\n                if cnt: cnt -= 1\\n        return cnt == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        cnt = 0 \\n        for x in data:\\n            x = bin(x)[2:].zfill(8)\\n            if cnt: # in the middle of multi-byte \\n                if x.startswith(\"10\"): cnt -= 1\\n                else: return False \\n            else: # beginning \\n                cnt = x.find(\"0\")\\n                if cnt == -1 or cnt == 1 or cnt > 4: return False \\n                if cnt: cnt -= 1\\n        return cnt == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318398,
                "title": "c-concise-solution",
                "content": "```\\nbool validUtf8(vector<int>& data) {\\n\\tint conts = 0;\\n\\tfor(int i = 0; i < data.size(); i++) {\\n\\t\\tif(conts--) { if ((data[i] & 0xC0) != 0x80) return false; }\\n\\t\\telse if((data[i] & 0xF8) == 0xF0) conts = 3;\\n\\t\\telse if((data[i] & 0xF0) == 0xE0) conts = 2;\\n\\t\\telse if((data[i] & 0xE0) == 0xC0) conts = 1;\\n\\t\\telse if((data[i] & 0x80) == 0x00) conts = 0;\\n\\t\\telse return false;\\n\\t}\\n\\treturn !conts;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool validUtf8(vector<int>& data) {\\n\\tint conts = 0;\\n\\tfor(int i = 0; i < data.size(); i++) {\\n\\t\\tif(conts--) { if ((data[i] & 0xC0) != 0x80) return false; }\\n\\t\\telse if((data[i] & 0xF8) == 0xF0) conts = 3;\\n\\t\\telse if((data[i] & 0xF0) == 0xE0) conts = 2;\\n\\t\\telse if((data[i] & 0xE0) == 0xC0) conts = 1;\\n\\t\\telse if((data[i] & 0x80) == 0x00) conts = 0;\\n\\t\\telse return false;\\n\\t}\\n\\treturn !conts;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87445,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var count = 0\\n        \\n        for byte in data {\\n            if count == 0 {\\n                if byte >> 5 == 0b110 {\\n                    count = 1\\n                } else if byte >> 4 == 0b1110 {\\n                    count = 2\\n                } else if byte >> 3 == 0b11110 {\\n                    count = 3\\n                } else if byte >> 7 != 0 {\\n                    return false\\n                }\\n            } else {\\n                if byte >> 6 != 0b10 {\\n                    return false\\n                }\\n                count -= 1\\n            }\\n        }\\n        \\n        return count == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var count = 0\\n        \\n        for byte in data {\\n            if count == 0 {\\n                if byte >> 5 == 0b110 {\\n                    count = 1\\n                } else if byte >> 4 == 0b1110 {\\n                    count = 2\\n                } else if byte >> 3 == 0b11110 {\\n                    count = 3\\n                } else if byte >> 7 != 0 {\\n                    return false\\n                }\\n            } else {\\n                if byte >> 6 != 0b10 {\\n                    return false\\n                }\\n                count -= 1\\n            }\\n        }\\n        \\n        return count == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87520,
                "title": "short-o-n-java-solution-scan-only-once",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n  int idx = 0;\\n  while(idx < data.length) {\\n    int utfIdx = idx++;\\n    if ((data[utfIdx] & (1<<7)) == 0) continue; //single byte\\n    for(int i = 6; i>=0; i--) {\\n      if ((data[utfIdx] & (1<<i)) > 0) { //find one more byte in multiple bytes\\n        if (idx >= data.length) return false; //not enough bytes\\n        if (((data[idx] & (1<<7)) == 0) || ((data[idx] & (1<<6))>0)) return false; //not starting with 10xxxxxx\\n        idx++;\\n      } else if (i==6) return false;  //for fist byte in multiple bytes is 10xxxxxx, at least 110xxxxx\\n      else break; //meet 0, remaining as utf content\\n    }\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n  int idx = 0;\\n  while(idx < data.length) {\\n    int utfIdx = idx++;\\n    if ((data[utfIdx] & (1<<7)) == 0) continue; //single byte\\n    for(int i = 6; i>=0; i--) {\\n      if ((data[utfIdx] & (1<<i)) > 0) { //find one more byte in multiple bytes\\n        if (idx >= data.length) return false; //not enough bytes\\n        if (((data[idx] & (1<<7)) == 0) || ((data[idx] & (1<<6))>0)) return false; //not starting with 10xxxxxx\\n        idx++;\\n      } else if (i==6) return false;  //for fist byte in multiple bytes is 10xxxxxx, at least 110xxxxx\\n      else break; //meet 0, remaining as utf content\\n    }\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2572697,
                "title": "clear-cpp-solution-with-separate-functions-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    //function to check whether an integer is a continuation integer or not.\\n    bool cont(int x){\\n        int mask1= (1<<7),mask2=(1<<6);\\n        if((x&mask1)!=0 && (x&mask2)==0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n    // function to calculate character classification (1-4).\\n    int byte(int x){\\n        if((x&(1<<7))==0){\\n            return 1;\\n        }\\n        int mask=(1<<8)-1,temp;\\n        x=(x^mask);\\n        for(int i=7;i>=0;i--){\\n            temp=(1<<i);\\n            if((temp&x)!=0){\\n                temp=i;\\n                break;\\n            }\\n        }\\n        if(7-temp>=2 && 7-temp<=4){\\n            return 7-temp;\\n        }\\n        else return -1;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int bytes,idx=0,n=data.size(),contInt=0;\\n        bool shCont=false;\\n        while(idx<n){\\n            if(shCont){\\n                if(cont(data[idx])==false){return false;}\\n                if(idx==contInt){\\n                    shCont=false;\\n                }\\n            }\\n            else{\\n            int ele = data[idx];\\n            bytes=byte(ele);\\n            if(bytes==-1){return false;}// A number is completely invalid,like 255 or 15 -> (2**k-1).\\n            if(bytes>1){\\n            contInt=idx+bytes-1;\\n            shCont=true;\\n                }\\n            }\\n            idx+=1;\\n        }\\n        return !shCont; //if program tells us that the loop should have continued, we return false.\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //function to check whether an integer is a continuation integer or not.\\n    bool cont(int x){\\n        int mask1= (1<<7),mask2=(1<<6);\\n        if((x&mask1)!=0 && (x&mask2)==0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n    // function to calculate character classification (1-4).\\n    int byte(int x){\\n        if((x&(1<<7))==0){\\n            return 1;\\n        }\\n        int mask=(1<<8)-1,temp;\\n        x=(x^mask);\\n        for(int i=7;i>=0;i--){\\n            temp=(1<<i);\\n            if((temp&x)!=0){\\n                temp=i;\\n                break;\\n            }\\n        }\\n        if(7-temp>=2 && 7-temp<=4){\\n            return 7-temp;\\n        }\\n        else return -1;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int bytes,idx=0,n=data.size(),contInt=0;\\n        bool shCont=false;\\n        while(idx<n){\\n            if(shCont){\\n                if(cont(data[idx])==false){return false;}\\n                if(idx==contInt){\\n                    shCont=false;\\n                }\\n            }\\n            else{\\n            int ele = data[idx];\\n            bytes=byte(ele);\\n            if(bytes==-1){return false;}// A number is completely invalid,like 255 or 15 -> (2**k-1).\\n            if(bytes>1){\\n            contInt=idx+bytes-1;\\n            shCont=true;\\n                }\\n            }\\n            idx+=1;\\n        }\\n        return !shCont; //if program tells us that the loop should have continued, we return false.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571800,
                "title": "java-soln-easiest-way",
                "content": "```\\nclass Solution {\\n    \\n    // return byte - 1\\n    public int Get_Bytes(int val){\\n\\n        int pos = 1;\\n        int res = 0;\\n        \\n        while(val > 0){\\n            if((val & 1) == 0){\\n                res = pos;\\n            }\\n            val >>= 1;\\n            pos++;\\n        }\\n        \\n        return 7 - res;\\n    }\\n    \\n    public boolean validUtf8(int[] data) {\\n        \\n        int byt = 0;\\n        \\n        for(int i = 0; i < data.length; i++){\\n            if(byt == 0){\\n                // if one byte number continue\\n                if(((data[i] >> 7) & 1) == 0)     continue;\\n                \\n                byt = Get_Bytes(data[i]);\\n\\n                 if(byt >= 4)  return false;\\n                \\n                // invaild no return false(10xxxxxx can\\'t be start of any sequence)\\n                if(byt == 0)    return false;\\n            }\\n            else{\\n                int x = data[i] >> 6;\\n                \\n                // if(first two bits are not 10)\\n                if(x != 2)  return false;\\n                byt--;\\n            }\\n        }\\n        \\n        return byt == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // return byte - 1\\n    public int Get_Bytes(int val){\\n\\n        int pos = 1;\\n        int res = 0;\\n        \\n        while(val > 0){\\n            if((val & 1) == 0){\\n                res = pos;\\n            }\\n            val >>= 1;\\n            pos++;\\n        }\\n        \\n        return 7 - res;\\n    }\\n    \\n    public boolean validUtf8(int[] data) {\\n        \\n        int byt = 0;\\n        \\n        for(int i = 0; i < data.length; i++){\\n            if(byt == 0){\\n                // if one byte number continue\\n                if(((data[i] >> 7) & 1) == 0)     continue;\\n                \\n                byt = Get_Bytes(data[i]);\\n\\n                 if(byt >= 4)  return false;\\n                \\n                // invaild no return false(10xxxxxx can\\'t be start of any sequence)\\n                if(byt == 0)    return false;\\n            }\\n            else{\\n                int x = data[i] >> 6;\\n                \\n                // if(first two bits are not 10)\\n                if(x != 2)  return false;\\n                byt--;\\n            }\\n        }\\n        \\n        return byt == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571743,
                "title": "question-explained-clearly-easy-solution-without-bit-manipulation-string-python",
                "content": "Hi All,\\n\\nThis question is vague and tricky, But let me explain question clearly and derive the problem statement conditions\\n\\nQuestion:\\n\\nGiven an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\\n\\nA character in UTF8 can be from 1 to 4 bytes long `[Explanation: Any UTF8 encoding should only contain at max 4 bytes]`, \\n\\nFor a 1-byte character, the first bit is a 0, followed by its Unicode code. `[Explanation: Looking at the below table, it mentions that it is valid to have a most significant bit as 0 if that is the starting byte]`\\nFor an n-bytes character, the first n bits are all one\\'s, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10. \\n```\\nExplanation: In the first sentence as mentioned, we can have at max 4 bytes, Based on the below table \\n1. 1 byte UTF8 encoding should start with 0 as most significant\\n2. 2 Bytes UTF8  encoding should start with 110XXX.. and 10XXX .. Example: Given a data [197,130,1] , here 197 after converting to binary will become 11000101, here we can see clearly its a 2 byte UTF8 encoding which means we need to check one more number after 197 that i.e, 130 in this example is having a binary value starting with 10XX.. or not, if it does not start with that value we can return. Once we have completed checking 130 number as well then we can once again check for next digit i.e., 1 in this example to find the how many byte encoding this number in UTF8\\n3. 3 Bytes UTF8 encoding will start with 1110XX.. , 10XX.. and 10XXX.. as mentioned in the table. In this case if the first number is belonging to 3 byte UTF8 encoding then we need to check the next two numbers are having 10 in their binary representation. after that we can process the next element\\n4. Same for the 4 byte encoding\\n\\nNote: we don\\'t have a UTF8 encoding starting byte with 10XX.. \\n```\\n\\n\\n\\nThis is how the UTF-8 encoding would work:\\n\\n ```\\nNumber of Bytes   |        UTF-8 Octet Sequence\\n\\t\\t\\t\\t   |              (binary)\\n--------------------+-----------------------------------------\\n\\t\\t1          |   0xxxxxxx\\n\\t\\t2          |   110xxxxx 10xxxxxx\\n\\t\\t3          |   1110xxxx 10xxxxxx 10xxxxxx\\n\\t\\t4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n```\\nx denotes a bit in the binary form of a byte that may be either 0 or 1.\\n\\nNote: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\\n\\n-------------\\n\\n\\nSummarizing all the things we understood till now:\\n1. UTF8 can be 1 to 4 bytes long [Return False if any starting byte with more than 4 most significant bits as 1]\\n2. For a one byte, first character can be zero\\n3. For 2,3,4 bytes most significant 1\\'s should be 2,3,4 count as show in the table\\n4. if the first byte starts with \\'10\\' return False\\n\\nUsing the above conditions, we can formulate the following algorithm\\n1. Iterate over the nums\\n2. For each num calculate the binary representation and calculate the number of most significant bits as 1\\n3. check if the next n-1 nums has the first two most significant bits as \\'10\\' else return False\\n4. Update the i from the nth num\\n\\nPython Solution:\\n\\n```\\ndef validUtf8(self, data: List[int]) -> bool:\\n        data_len = len(data)\\n        i = 0\\n        while i < data_len:\\n            num = data[i]\\n            num_binary = \\'{0:08b}\\'.format(num)\\n            \\n\\t\\t\\t# calculate the number of 1\\'s\\n            num_chars = 0\\n            for char in num_binary:\\n                if char == \\'1\\':\\n                    num_chars += 1\\n                    continue\\n                break\\n            \\n            if num_chars == 1 or num_chars > 4:\\n                # 10XXX condition doesn\\'t exist\\n                # only 1 to 4 bytes long\\n                return False\\n            \\n\\t\\t\\t# for 1 byte, num chars can be zero\\n            num_chars = num_chars - 1 if num_chars > 1 else 0\\n            \\n            check_till = i + num_chars\\n            if check_till >= data_len:\\n\\t\\t\\t\\t# if there are not many required elements to check\\n                return False\\n            \\n            for j in range(i + 1, check_till + 1):\\n                curr_num = data[j]\\n                curr_num_binary = \\'{0:08b}\\'.format(curr_num)\\n                if curr_num_binary[:2] != \\'10\\':\\n                    return False\\n            \\n            i = check_till + 1\\n            \\n        return True\\n```\\n\\nPlease upvote if you like the explanations and comment if there are any queries. Cheers!!",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nExplanation: In the first sentence as mentioned, we can have at max 4 bytes, Based on the below table \\n1. 1 byte UTF8 encoding should start with 0 as most significant\\n2. 2 Bytes UTF8  encoding should start with 110XXX.. and 10XXX .. Example: Given a data [197,130,1] , here 197 after converting to binary will become 11000101, here we can see clearly its a 2 byte UTF8 encoding which means we need to check one more number after 197 that i.e, 130 in this example is having a binary value starting with 10XX.. or not, if it does not start with that value we can return. Once we have completed checking 130 number as well then we can once again check for next digit i.e., 1 in this example to find the how many byte encoding this number in UTF8\\n3. 3 Bytes UTF8 encoding will start with 1110XX.. , 10XX.. and 10XXX.. as mentioned in the table. In this case if the first number is belonging to 3 byte UTF8 encoding then we need to check the next two numbers are having 10 in their binary representation. after that we can process the next element\\n4. Same for the 4 byte encoding\\n\\nNote: we don\\'t have a UTF8 encoding starting byte with 10XX.. \\n```\n```\\nNumber of Bytes   |        UTF-8 Octet Sequence\\n\\t\\t\\t\\t   |              (binary)\\n--------------------+-----------------------------------------\\n\\t\\t1          |   0xxxxxxx\\n\\t\\t2          |   110xxxxx 10xxxxxx\\n\\t\\t3          |   1110xxxx 10xxxxxx 10xxxxxx\\n\\t\\t4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n```\n```\\ndef validUtf8(self, data: List[int]) -> bool:\\n        data_len = len(data)\\n        i = 0\\n        while i < data_len:\\n            num = data[i]\\n            num_binary = \\'{0:08b}\\'.format(num)\\n            \\n\\t\\t\\t# calculate the number of 1\\'s\\n            num_chars = 0\\n            for char in num_binary:\\n                if char == \\'1\\':\\n                    num_chars += 1\\n                    continue\\n                break\\n            \\n            if num_chars == 1 or num_chars > 4:\\n                # 10XXX condition doesn\\'t exist\\n                # only 1 to 4 bytes long\\n                return False\\n            \\n\\t\\t\\t# for 1 byte, num chars can be zero\\n            num_chars = num_chars - 1 if num_chars > 1 else 0\\n            \\n            check_till = i + num_chars\\n            if check_till >= data_len:\\n\\t\\t\\t\\t# if there are not many required elements to check\\n                return False\\n            \\n            for j in range(i + 1, check_till + 1):\\n                curr_num = data[j]\\n                curr_num_binary = \\'{0:08b}\\'.format(curr_num)\\n                if curr_num_binary[:2] != \\'10\\':\\n                    return False\\n            \\n            i = check_till + 1\\n            \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2571241,
                "title": "java-soln",
                "content": "class Solution {\\n\\t public boolean validUtf8(int[] data) {\\n     int rem=0;\\n        for(int i :data)\\n            if(rem==0)\\n                if(i>>7 == 0b0)\\n                    rem =0;\\n                else if(i>>5 ==0b110)\\n                    rem=1;\\n                else if(i>>4 == 0b1110)\\n                    rem=2;\\n                else if(i>>3 == 0b11110)\\n                    rem=3;\\n                else\\n                    return false;\\n            else\\n                if(i>>6==0b10)\\n                    rem--;\\n                else\\n                    return false;\\n            if(rem==0)\\n                return true;\\n            else\\n                return false;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t public boolean validUtf8(int[] data) {\\n     int rem=0;\\n        for(int i :data)\\n            if(rem==0)\\n                if(i>>7 == 0b0)\\n                    rem =0;\\n                else if(i>>5 ==0b110)\\n                    rem=1;\\n                else if(i>>4 == 0b1110)\\n                    rem=2;\\n                else if(i>>3 == 0b11110)\\n                    rem=3;\\n                else\\n                    return false;\\n            else\\n                if(i>>6==0b10)\\n                    rem--;\\n                else\\n                    return false;\\n            if(rem==0)\\n                return true;\\n            else\\n                return false;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2571208,
                "title": "super-duper-easy-peasy-lemon-squeezy-solution",
                "content": "```\\n#include<bits/stdc++.h>\\n#define PB push_back\\n#define ll long long int\\n#define MP make_pair\\n#define loop(i, a, b) for (int i = a; i < b; i++)\\nusing namespace std;\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& d) \\n    {\\n        int n=d.size();\\n        int a[n];\\n        loop(i,0,n)\\n        {\\n            int x=0;\\n            int j=7;\\n            while(j>-1&&d[i]>=pow(2,j))\\n            {\\n                d[i]-=pow(2,j);\\n                j--;\\n                x++;\\n            }\\n            a[i]=x;\\n        }\\n        // loop(i,0,n)\\n        //     cout<<a[i]<<endl;\\n        //int d=1;\\n        loop(i,0,n)\\n        {\\n            if(a[i]>4)\\n            {\\n                return false;\\n            }\\n            else if(a[i]==4)\\n            {\\n                if(i+3>=n||(a[i+1]!=1||a[i+2]!=1||a[i+3]!=1))\\n                    return false;\\n                else\\n                    i+=3;\\n            }\\n            else if(a[i]==3)\\n            {\\n                if((i+2>=n)||(a[i+1]!=1||a[i+2]!=1))\\n                    return false;\\n                else\\n                    i+=2;\\n            }\\n            else if(a[i]==2)\\n            {\\n                if(i+1>=n||(a[i+1]!=1))\\n                    return false;\\n                else\\n                    i+=1;\\n            }\\n            else if(a[i]==1)\\n                return false;\\n            // else\\n            //     return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n#define PB push_back\\n#define ll long long int\\n#define MP make_pair\\n#define loop(i, a, b) for (int i = a; i < b; i++)\\nusing namespace std;\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& d) \\n    {\\n        int n=d.size();\\n        int a[n];\\n        loop(i,0,n)\\n        {\\n            int x=0;\\n            int j=7;\\n            while(j>-1&&d[i]>=pow(2,j))\\n            {\\n                d[i]-=pow(2,j);\\n                j--;\\n                x++;\\n            }\\n            a[i]=x;\\n        }\\n        // loop(i,0,n)\\n        //     cout<<a[i]<<endl;\\n        //int d=1;\\n        loop(i,0,n)\\n        {\\n            if(a[i]>4)\\n            {\\n                return false;\\n            }\\n            else if(a[i]==4)\\n            {\\n                if(i+3>=n||(a[i+1]!=1||a[i+2]!=1||a[i+3]!=1))\\n                    return false;\\n                else\\n                    i+=3;\\n            }\\n            else if(a[i]==3)\\n            {\\n                if((i+2>=n)||(a[i+1]!=1||a[i+2]!=1))\\n                    return false;\\n                else\\n                    i+=2;\\n            }\\n            else if(a[i]==2)\\n            {\\n                if(i+1>=n||(a[i+1]!=1))\\n                    return false;\\n                else\\n                    i+=1;\\n            }\\n            else if(a[i]==1)\\n                return false;\\n            // else\\n            //     return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2571114,
                "title": "i-am-not-crazy-right",
                "content": "#### The characters can be interpreted in decimal as:\\n* **1 byte** characters are:  **0xxxxxxx** -> ***00000000-01111111*** -> **[0,127]**\\n* **2 bytes** characters are: **110xxxxx** -> ***11000000-11011111*** -> **[192,223]**\\n* **3 bytes** characters are: **1110xxxx** -> ***11100000-11101111*** -> **[224,239]**\\n* **4 bytes** characters are: **11110xxx** -> ***11110000-11110111*** -> **[240,247]**\\n\\nThe **n bytes** characters are followed by **n-1 characters** of form : \\n**10xxxxxx** -> ***10000000-10111111*** -> **[128,191]**\\n\\n***C++ Code:***\\n```\\nbool validUtf8(vector<int>& data) {\\n        int len = data.size();\\n        int cur = -1,i=0;\\n        for(;i<len;i++){\\n            if (data[i]<=127&&data[i]>=0)continue; // if data[i] is 1 byte\\n            else if(data[i]<=223&&data[i]>=192)cur=1; // if data[i] is 2 bytes\\n            else if(data[i]<=239&&data[i]>=224)cur=2; // if data[i] is 3 bytes\\n            else if(data[i]<=247&&data[i]>=240)cur=3; // if data[i] is 4 bytes\\n            else return 0; \\n            if(i+cur>=len)return 0; // checking if n-1 characters exist\\n\\t\\t\\t// checking n-1 characters\\n            while(cur--){ \\n                i++;\\n\\t\\t\\t\\t // checking in [128,191]\\n                if(data[i]<128||data[i]>191)return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n```\\n***Time Complexity:*** `O(n)`\\n***Space Complexity:*** `O(1)`\\n\\n**Do tell me what you think of this approach and how can it be improved?**\\n***Writing this code doesn\\'t make me crazy, right?!***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool validUtf8(vector<int>& data) {\\n        int len = data.size();\\n        int cur = -1,i=0;\\n        for(;i<len;i++){\\n            if (data[i]<=127&&data[i]>=0)continue; // if data[i] is 1 byte\\n            else if(data[i]<=223&&data[i]>=192)cur=1; // if data[i] is 2 bytes\\n            else if(data[i]<=239&&data[i]>=224)cur=2; // if data[i] is 3 bytes\\n            else if(data[i]<=247&&data[i]>=240)cur=3; // if data[i] is 4 bytes\\n            else return 0; \\n            if(i+cur>=len)return 0; // checking if n-1 characters exist\\n\\t\\t\\t// checking n-1 characters\\n            while(cur--){ \\n                i++;\\n\\t\\t\\t\\t // checking in [128,191]\\n                if(data[i]<128||data[i]>191)return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570982,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        \\n        int n = data.size();\\n        vector<int> vec = {127, 191, 223, 239, 247};\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int pos = lower_bound(vec.begin(), vec.end(), data[i]) - vec.begin();        \\n            if(pos==5 || pos==1)\\n                return 0;\\n            \\n            if(pos==0)\\n                continue;\\n            \\n            pos--;\\n            i++;\\n            while(pos--)\\n            {\\n                if(i>=n)\\n                    return 0;\\n                \\n                int tmp = lower_bound(vec.begin(), vec.end(), data[i]) - vec.begin();\\n                \\n                if(tmp!=1)\\n                    return 0;\\n                \\n                i++;\\n            }\\n            i--;\\n        }\\n        \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        \\n        int n = data.size();\\n        vector<int> vec = {127, 191, 223, 239, 247};\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int pos = lower_bound(vec.begin(), vec.end(), data[i]) - vec.begin();        \\n            if(pos==5 || pos==1)\\n                return 0;\\n            \\n            if(pos==0)\\n                continue;\\n            \\n            pos--;\\n            i++;\\n            while(pos--)\\n            {\\n                if(i>=n)\\n                    return 0;\\n                \\n                int tmp = lower_bound(vec.begin(), vec.end(), data[i]) - vec.begin();\\n                \\n                if(tmp!=1)\\n                    return 0;\\n                \\n                i++;\\n            }\\n            i--;\\n        }\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570191,
                "title": "rust-functional-state-machine-with-comments",
                "content": "I use a functional state machine approach to scan the input. I map the input bytes to their number of leading bits set (`leading_ones`) and use `scan` to hold the state `(ok, n)`, where `ok` is true if the state machine is in a valid state, and `n` is the number of \"tail bytes\" with leading b10, i.e. one leading bit set, that we expect. The output of `scan` is wether `data` is valid UTF-8 if it would end at the current byte, i.e. if we are not expecting any tail bytes. Going through the match arms:\\n\\n1. If the state machine is in an invalid state, we signal that we are done by yielding `None`. We get here if the previous byte hit the sixth match arm, and we have signalled that it is bad UTF-8.\\n2. The state machine is in a valid state, we expect a header byte (`n == 0`), and the header byte has no leading bits set. This is a one-byte character, so we don\\'t expect any tail bytes, and up until the current byte, we have valid UTF-8.\\n3. The state machine is in a valid state, we expect a header byte (`n == 0`), and the current byte is a header byte with 2, 3 or 4 leading bits set. We expect 1, 2 and 3 tail bytes, respectively, and we don\\'t have valid UTF-8 if input would end here.\\n4. The state machine is in a valid state, we expect one tail byte, and the current byte is a tail byte (one leading bit set). We do not expect any more tail bytes, and we have valid UTF-8 if input would end here.\\n5. The state machine is in a valid state, we expect more than one tail byte, and the current byte is a tail byte (one leading bit set). We decrement the number of tail bytes that we expect. We do not have valid UTF-8 if input would end here.\\n6. Anything else violates the rules of valid UTF-8 input. We signal that the input is invalid.\\n\\n```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        data.into_iter().map(|i| (i as u8).leading_ones()).scan((true, 0), |(ok, n), lo| \\n            match (*ok, *n, lo) {\\n                (false, _, _) => None,\\n                (_, 0, 0) => Some(true),\\n                (_, 0, 2 | 3 | 4) => { *n = lo - 1; Some(false) },\\n                (_, 1, 1) => { *n = 0; Some(true) },\\n                (_, _, 1) => { *n -= 1; Some(false) },\\n                _ => {*ok = false; Some(false)},\\n            }\\n        ).last().unwrap()\\n    }\\n}\\n```\\n\\nI also made a less compact but more readable implementation of the state machine:\\n\\n```\\n#[derive(Clone, Copy, PartialEq)]\\nenum State {\\n    ExpectingHeader,\\n    ExpectingOne,\\n    ExpectingTwo,\\n    ExpectingThree,\\n    Error,\\n    Invalid,\\n}\\n\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        data.into_iter().map(|i| (i as u8).leading_ones()).scan(State::ExpectingHeader, |state, lo| {\\n            *state = match (*state, lo) {\\n                (State::ExpectingHeader, 0) => State::ExpectingHeader,\\n                (State::ExpectingHeader, 2) => State::ExpectingOne,\\n                (State::ExpectingHeader, 3) => State::ExpectingTwo,\\n                (State::ExpectingHeader, 4) => State::ExpectingThree,\\n                (State::ExpectingOne, 1) => State::ExpectingHeader,\\n                (State::ExpectingTwo, 1) => State::ExpectingOne,\\n                (State::ExpectingThree, 1) => State::ExpectingTwo,\\n                (State::Error, _) => State::Invalid,\\n                _ => State::Error,\\n\\n            };\\n            if *state == State::Invalid { None } else { Some(*state) }\\n        }).map(|state| state == State::ExpectingHeader).last().unwrap_or(true)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        data.into_iter().map(|i| (i as u8).leading_ones()).scan((true, 0), |(ok, n), lo| \\n            match (*ok, *n, lo) {\\n                (false, _, _) => None,\\n                (_, 0, 0) => Some(true),\\n                (_, 0, 2 | 3 | 4) => { *n = lo - 1; Some(false) },\\n                (_, 1, 1) => { *n = 0; Some(true) },\\n                (_, _, 1) => { *n -= 1; Some(false) },\\n                _ => {*ok = false; Some(false)},\\n            }\\n        ).last().unwrap()\\n    }\\n}\\n```\n```\\n#[derive(Clone, Copy, PartialEq)]\\nenum State {\\n    ExpectingHeader,\\n    ExpectingOne,\\n    ExpectingTwo,\\n    ExpectingThree,\\n    Error,\\n    Invalid,\\n}\\n\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        data.into_iter().map(|i| (i as u8).leading_ones()).scan(State::ExpectingHeader, |state, lo| {\\n            *state = match (*state, lo) {\\n                (State::ExpectingHeader, 0) => State::ExpectingHeader,\\n                (State::ExpectingHeader, 2) => State::ExpectingOne,\\n                (State::ExpectingHeader, 3) => State::ExpectingTwo,\\n                (State::ExpectingHeader, 4) => State::ExpectingThree,\\n                (State::ExpectingOne, 1) => State::ExpectingHeader,\\n                (State::ExpectingTwo, 1) => State::ExpectingOne,\\n                (State::ExpectingThree, 1) => State::ExpectingTwo,\\n                (State::Error, _) => State::Invalid,\\n                _ => State::Error,\\n\\n            };\\n            if *state == State::Invalid { None } else { Some(*state) }\\n        }).map(|state| state == State::ExpectingHeader).last().unwrap_or(true)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569826,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let mut next_bytes = 0;\\n        for ones in data.iter().map(|&x| (x as u8).leading_ones()) {\\n            match (next_bytes == 0, ones) {\\n                (false, 1) => next_bytes -= 1,\\n                (true, 0 | 2 | 3 | 4) => next_bytes = ones.saturating_sub(1),\\n                _ => return false,\\n            }\\n        }\\n        next_bytes == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let mut next_bytes = 0;\\n        for ones in data.iter().map(|&x| (x as u8).leading_ones()) {\\n            match (next_bytes == 0, ones) {\\n                (false, 1) => next_bytes -= 1,\\n                (true, 0 | 2 | 3 | 4) => next_bytes = ones.saturating_sub(1),\\n                _ => return false,\\n            }\\n        }\\n        next_bytes == 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569599,
                "title": "c-simple-short-easy-to-understand",
                "content": "We first iterate through the vector \\'data\\' and convert it to binary representations (8 least significant bits). Afterwards, we take a count variable to check for remaining integers for that byte encoding. For example: if we got an integer with 110xxxxx then, we need to have another integer with 10xxxxxx for the 2 byte encoding and so on. \\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        vector<string> v;\\n        for(int i=0;i<data.size();i++) {\\n            string s = bitset<8> (data[i]).to_string();\\n            v.push_back(s ); //binary representation\\n        }\\n        int count = 0;\\n        for(auto s: v) {\\n            if(count==0) {\\n                if( s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'0\\') count =1; // 2 byte encoding\\n                else if(s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'1\\' && s[3]==\\'0\\') count=2; //3 byte encoding\\n                else if(s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'1\\' && s[3]==\\'1\\' && s[4]==\\'0\\') count=3; // 4 byte encoding\\n                else if( s[0]!=\\'0\\') return false; //0 byte encoding\\n            } else {\\n                if(s[0]==\\'1\\' && s[1]==\\'0\\') count--;\\n                else return false;\\n            }\\n        }\\n        return count==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        vector<string> v;\\n        for(int i=0;i<data.size();i++) {\\n            string s = bitset<8> (data[i]).to_string();\\n            v.push_back(s ); //binary representation\\n        }\\n        int count = 0;\\n        for(auto s: v) {\\n            if(count==0) {\\n                if( s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'0\\') count =1; // 2 byte encoding\\n                else if(s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'1\\' && s[3]==\\'0\\') count=2; //3 byte encoding\\n                else if(s[0]==\\'1\\' && s[1]==\\'1\\' && s[2]==\\'1\\' && s[3]==\\'1\\' && s[4]==\\'0\\') count=3; // 4 byte encoding\\n                else if( s[0]!=\\'0\\') return false; //0 byte encoding\\n            } else {\\n                if(s[0]==\\'1\\' && s[1]==\\'0\\') count--;\\n                else return false;\\n            }\\n        }\\n        return count==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569173,
                "title": "javascript-solution-binary-two-approaches",
                "content": "**Approach 1)**\\n\\n```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    \\n    let binary = data.map(d => { // data to binary\\n        let b = \"00000000\" + d.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n    // current UTF8 length\\n    let current = 0; \\n\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            // skip the single byte char\\n            if (bytes==0) {\\n                continue;\\n            }  \\n            if (bytes > 4 || bytes < 2) {\\n              return false;  \\n            }\\n            // set the remaining length\\n            current = bytes;\\n        } else {\\n            if (bytes != 1) {\\n                return false\\n            } \\n        }\\n        current--;\\n    }\\n    return current==0;\\n};\\n```\\n\\n```\\nRuntime: 134 ms, faster than 27.78% of JavaScript online submissions for UTF-8 Validation.\\nMemory Usage: 48.3 MB, less than 25.00% of JavaScript online submissions for UTF-8 Validation.\\n```\\n\\n**Approach 2)**\\n\\n```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    for (let i = 0; i < data.length; i++) {\\n        if (count == 0) {\\n            if (data[i]>>>5 == 0b110) {\\n                count = 1;\\n            }\\n            else if (data[i]>>>4 == 0b1110) {\\n                count = 2;\\n            }\\n            else if (data[i]>>>3 == 0b11110) {\\n                count = 3;\\n            }\\n            else if (data[i]>>>7 == 1) {\\n                return false;\\n            }\\n        }\\n        else {\\n            if (data[i]>>>6 != 2) {\\n                return false;\\n            }\\n            count --;\\n        }\\n    }\\n    return count == 0;\\n};\\n```\\n\\n```\\nRuntime: 133 ms, faster than 27.78% of JavaScript online submissions for UTF-8 Validation.\\nMemory Usage: 42.2 MB, less than 97.22% of JavaScript online submissions for UTF-8 Validation.\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    \\n    let binary = data.map(d => { // data to binary\\n        let b = \"00000000\" + d.toString(2);\\n        return b.substring(b.length - 8);\\n    })\\n\\n    // current UTF8 length\\n    let current = 0; \\n\\n    for (let i=0;i<binary.length;i++) {\\n        let bytes = binary[i].indexOf(\\'0\\');\\n        if (current==0) {\\n            // skip the single byte char\\n            if (bytes==0) {\\n                continue;\\n            }  \\n            if (bytes > 4 || bytes < 2) {\\n              return false;  \\n            }\\n            // set the remaining length\\n            current = bytes;\\n        } else {\\n            if (bytes != 1) {\\n                return false\\n            } \\n        }\\n        current--;\\n    }\\n    return current==0;\\n};\\n```\n```\\nRuntime: 134 ms, faster than 27.78% of JavaScript online submissions for UTF-8 Validation.\\nMemory Usage: 48.3 MB, less than 25.00% of JavaScript online submissions for UTF-8 Validation.\\n```\n```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    for (let i = 0; i < data.length; i++) {\\n        if (count == 0) {\\n            if (data[i]>>>5 == 0b110) {\\n                count = 1;\\n            }\\n            else if (data[i]>>>4 == 0b1110) {\\n                count = 2;\\n            }\\n            else if (data[i]>>>3 == 0b11110) {\\n                count = 3;\\n            }\\n            else if (data[i]>>>7 == 1) {\\n                return false;\\n            }\\n        }\\n        else {\\n            if (data[i]>>>6 != 2) {\\n                return false;\\n            }\\n            count --;\\n        }\\n    }\\n    return count == 0;\\n};\\n```\n```\\nRuntime: 133 ms, faster than 27.78% of JavaScript online submissions for UTF-8 Validation.\\nMemory Usage: 42.2 MB, less than 97.22% of JavaScript online submissions for UTF-8 Validation.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569016,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string byte(int n){\\n        string s=\"\";\\n        \\n        for(int i=0;i<8;i++){\\n            s+=to_string(n%2);\\n            n=n>>1;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        \\n        return s;\\n    }\\n    \\n    int count(string s){\\n        int ct=0;\\n        for(int i=0;i<8;i++){\\n            if(s[i]==\\'0\\')break;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        \\n        for(int i=0;i<data.size();i++){\\n            int n=data[i];\\n            string s=byte(n);\\n            \\n            int ct=count(s);\\n           \\n            if(ct>4 || ct==1)return false;\\n            \\n            for(int j=0;j<ct-1;j++){\\n                if(i+j+1>=data.size())return false;\\n                \\n                string d=byte(data[i+j+1]);\\n                int ct1=count(d);\\n                if(ct1!=1)return false;\\n            }\\n            \\n            if(ct!=0)i+=ct-1;\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string byte(int n){\\n        string s=\"\";\\n        \\n        for(int i=0;i<8;i++){\\n            s+=to_string(n%2);\\n            n=n>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2568850,
                "title": "scala-with-readability-tricks",
                "content": "```scala\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  def validUtf8(data: Array[Int]): Boolean = validUtf8(data.toList)\\n\\n  @tailrec\\n  def validUtf8(data: List[Int]): Boolean = data match {\\n    case Nil => true\\n    case n1 :: ns                   if ASCII_SEQ(n1) =>             validUtf8(ns)\\n    case n1 :: n2 :: ns             if TWO_BYTE(n1, n2) =>          validUtf8(ns)\\n    case n1 :: n2 :: n3 :: ns       if THREE_BYTE(n1, n2, n3) =>    validUtf8(ns)\\n    case n1 :: n2 :: n3 :: n4 :: ns if FOUR_BYTE(n1, n2, n3, n4) => validUtf8(ns)\\n    case _ => false\\n  }\\n\\n  case class Pattern(p: String) {\\n    val mask = Integer.parseInt(p.replace(\\'0\\', \\'1\\').replace(\\'X\\', \\'0\\'), 2)\\n    val maskTarget = Integer.parseInt(p.replace(\\'X\\', \\'0\\'), 2)\\n\\n    def ~~(i: Int): Boolean = (mask & i) == maskTarget\\n  }\\n\\n  val ASCII_PATTERN  = Pattern(\"0XXXXXXX\")\\n  val TRAILING       = Pattern(\"10XXXXXX\")\\n  val FIRST_OF_TWO   = Pattern(\"110XXXXX\")\\n  val FIRST_OF_THREE = Pattern(\"1110XXXX\")\\n  val FIRST_OF_FOUR  = Pattern(\"11110XXX\")\\n\\n  class Sequence(patterns: Pattern*) {\\n    def apply(ns: Int*): Boolean = patterns zip ns forall { _ ~~ _ }\\n  }\\n\\n  val ASCII_SEQ  = Sequence(ASCII_PATTERN)\\n  val TWO_BYTE   = Sequence(FIRST_OF_TWO, TRAILING)\\n  val THREE_BYTE = Sequence(FIRST_OF_THREE, TRAILING, TRAILING)\\n  val FOUR_BYTE  = Sequence(FIRST_OF_FOUR, TRAILING, TRAILING, TRAILING)\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```scala\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  def validUtf8(data: Array[Int]): Boolean = validUtf8(data.toList)\\n\\n  @tailrec\\n  def validUtf8(data: List[Int]): Boolean = data match {\\n    case Nil => true\\n    case n1 :: ns                   if ASCII_SEQ(n1) =>             validUtf8(ns)\\n    case n1 :: n2 :: ns             if TWO_BYTE(n1, n2) =>          validUtf8(ns)\\n    case n1 :: n2 :: n3 :: ns       if THREE_BYTE(n1, n2, n3) =>    validUtf8(ns)\\n    case n1 :: n2 :: n3 :: n4 :: ns if FOUR_BYTE(n1, n2, n3, n4) => validUtf8(ns)\\n    case _ => false\\n  }\\n\\n  case class Pattern(p: String) {\\n    val mask = Integer.parseInt(p.replace(\\'0\\', \\'1\\').replace(\\'X\\', \\'0\\'), 2)\\n    val maskTarget = Integer.parseInt(p.replace(\\'X\\', \\'0\\'), 2)\\n\\n    def ~~(i: Int): Boolean = (mask & i) == maskTarget\\n  }\\n\\n  val ASCII_PATTERN  = Pattern(\"0XXXXXXX\")\\n  val TRAILING       = Pattern(\"10XXXXXX\")\\n  val FIRST_OF_TWO   = Pattern(\"110XXXXX\")\\n  val FIRST_OF_THREE = Pattern(\"1110XXXX\")\\n  val FIRST_OF_FOUR  = Pattern(\"11110XXX\")\\n\\n  class Sequence(patterns: Pattern*) {\\n    def apply(ns: Int*): Boolean = patterns zip ns forall { _ ~~ _ }\\n  }\\n\\n  val ASCII_SEQ  = Sequence(ASCII_PATTERN)\\n  val TWO_BYTE   = Sequence(FIRST_OF_TWO, TRAILING)\\n  val THREE_BYTE = Sequence(FIRST_OF_THREE, TRAILING, TRAILING)\\n  val FOUR_BYTE  = Sequence(FIRST_OF_FOUR, TRAILING, TRAILING, TRAILING)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568753,
                "title": "c-99-4ms-but-varies-95-memory-while-loop-bit-manipulation",
                "content": "My initial answer ran in 250ms time 5% . With bit manipulation you can reduce this quite alot. \\n\\nSo your number is a binary number with 8 bits. You want to record the number of ones from the left side without break\\n\\nThat is for example   111110000 has value 5.\\n\\nStep 1: Convert your array of integers call them D in this manner.\\n\\nNow you just need to follolw [the rather annoying in my opinion] rules of UT8C charachters\\n\\n1: If ANY value in D is GREATER than 4 you are automatically false.\\n2. If you are at the beginning of a NEW UT8C charachter you CANNOT be 1 [by the rules] so return false if this is so.\\n3. If your value is say x at position i in your array D, then the UT8C charachter at position i has x bytes in it. So you need to move ahead x bytes in your array D. ALSO by the RULES of UT8C [which again I think are annoying] each one of the values in D along these x positions must be equal to ONE. So return false if this is not so.\\n4. Finally the last condtion is that if you get EXACTLY to the end of the array following steps ONE through THREE then you return TRUE. If you go out of bounds by following steps ONE through THREE return FALSE.\\n\\nAnd so this is it.\\n\\nThe time constraints are simply linnear.  \\n\\nThe Code is Below:                  Thank You    =]\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int Make(int N)\\n    {\\n        int ret=0;    \\n        for(int i=7;i>=2;i--)\\n        {\\n            if(N>>i==1) \\n            {\\n                ret++;\\n                N-=1<<i;\\n            }\\n            else \\n            {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n        string s; char c;\\n        int i=0;\\n        int ret=0;\\n        for(;i<8;i++)\\n        {\\n            c=\\'0\\'+N%2;\\n            s=s+c;\\n            N=N/2;\\n        }\\n        \\n        for(int i=7;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\') ret++; else break;\\n        }*/\\n        \\n        return(ret);\\n    }\\n    \\n    bool validUtf8(vector<int>& D) {\\n        \\n        int n=D.size();\\n        \\n        for(int i=0;i<D.size();i++)\\n        {\\n            D[i]=Make(D[i]);\\n        }\\n        \\n        //for(int v:D) cout<<v<<\"::\";\\n        \\n        int i=0, cur;\\n        \\n        while(i<n)\\n        {\\n            cur=D[i];\\n            \\n            if(cur>4 || cur==1) return(false);\\n            \\n            i++; cur--;\\n            \\n            while(cur>0)\\n            {\\n                if(i>=n) return(false);\\n                if(D[i]!=1) return(false);\\n                i++;\\n                cur--;\\n            }\\n        }\\n        \\n        return(true);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int Make(int N)\\n    {\\n        int ret=0;    \\n        for(int i=7;i>=2;i--)\\n        {\\n            if(N>>i==1) \\n            {\\n                ret++;\\n                N-=1<<i;\\n            }\\n            else \\n            {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n        string s; char c;\\n        int i=0;\\n        int ret=0;\\n        for(;i<8;i++)\\n        {\\n            c=\\'0\\'+N%2;\\n            s=s+c;\\n            N=N/2;\\n        }\\n        \\n        for(int i=7;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\') ret++; else break;\\n        }*/\\n        \\n        return(ret);\\n    }\\n    \\n    bool validUtf8(vector<int>& D) {\\n        \\n        int n=D.size();\\n        \\n        for(int i=0;i<D.size();i++)\\n        {\\n            D[i]=Make(D[i]);\\n        }\\n        \\n        //for(int v:D) cout<<v<<\"::\";\\n        \\n        int i=0, cur;\\n        \\n        while(i<n)\\n        {\\n            cur=D[i];\\n            \\n            if(cur>4 || cur==1) return(false);\\n            \\n            i++; cur--;\\n            \\n            while(cur>0)\\n            {\\n                if(i>=n) return(false);\\n                if(D[i]!=1) return(false);\\n                i++;\\n                cur--;\\n            }\\n        }\\n        \\n        return(true);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2359170,
                "title": "cute-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int i=0;\\n        while (i<data.size()) {\\n            int n=0;\\n            if ((data[i]>>7)==0) n=1;\\n            else if ((data[i]>>5)==6) n=2;\\n            else if ((data[i]>>4)==14) n=3;\\n            else if ((data[i]>>3)==30) n=4;\\n            else return false;\\n            for (int j=i+1; j<i+n; j++)\\n                if (j>=data.size() || data[j]>>6!=2)\\n                    return false;\\n           i += n;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int i=0;\\n        while (i<data.size()) {\\n            int n=0;\\n            if ((data[i]>>7)==0) n=1;\\n            else if ((data[i]>>5)==6) n=2;\\n            else if ((data[i]>>4)==14) n=3;\\n            else if ((data[i]>>3)==30) n=4;\\n            else return false;\\n            for (int j=i+1; j<i+n; j++)\\n                if (j>=data.size() || data[j]>>6!=2)\\n                    return false;\\n           i += n;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204811,
                "title": "why-is-250-145-145-145-145-not-a-valid-utf-8-string",
                "content": "[250,145,145,145,145]\\n\\nfirst byte: 11111010\\nFound 5-byte character at index 0\\ncbecking at index 1\\nfollowing byte: 10010001\\nnext one\\ncbecking at index 2\\nfollowing byte: 10010001\\nnext one\\ncbecking at index 3\\nfollowing byte: 10010001\\nnext one\\ncbecking at index 4\\nfollowing byte: 10010001\\nnext one\\n\\nIt seems like a valid encoding to me, but the test case said it\\'s meant to be false. Can anyone help me understand why?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1330386,
                "title": "java-bit-manipulation-clear-easy-to-understand-with-comments-explained",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int prevN = 0;\\n        for (int i : data) {\\n            int n = getN(i);\\n            if (n > 4) return false;\\n\\n            //An integer can either represent the start of a UTF-8 character, or a part of an existing UTF-8 character.\\n            // There are two separate rules for these two scenarios in the problem.\\n            if (n == 1) {\\n                //scenario 1: If an integer is a part of an existing UTF-8 character, simply check the 2 most significant bits of in the binary representation string.\\n                // They should be 10.  ie. n==1\\n                if (prevN <= 0) return false;\\n            } else {\\n                //scenario 2: If the integer represents the start of a UTF-8 character,\\n                // then the first few bits would be 1 followed by a 0. The number of initial bits\\n                // (most significant) bits determines the length of the UTF-8 character. ie length  = n\\n                if (prevN > 0) return false;\\n                // The array can contain multiple valid UTF-8 characters. ie. start of new UTF-8 character\\n                prevN = n;\\n            }\\n            prevN--;\\n\\n        }\\n        if (prevN > 0) return false;\\n        return true;\\n    }\\n\\n    public static int getN(int num) {\\n        //We can use bit masking to check how many initial bits are set for a given number. \\n        // We only need to work with the 8 least significant bits as mentioned in the problem.\\n        int mask = 1 << 7;\\n        int count = 0;\\n        while ((mask & num) != 0) {\\n            count++;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nSame code without comments:\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int prevN = 0;\\n        for (int i : data) {\\n            int n = getN(i);\\n            if (n > 4) {\\n                return false;\\n            } else if (n == 1) {\\n                if (prevN <= 0) return false;\\n            } else {\\n                if (prevN > 0) return false;\\n                prevN = n;\\n            }\\n            prevN--;\\n\\n        }\\n        if (prevN > 0) return false;\\n        return true;\\n    }\\n\\n    public static int getN(int num) {\\n        int mask = 1 << 7;\\n        int count = 0;\\n        while ((mask & num) != 0) {\\n            count++;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int prevN = 0;\\n        for (int i : data) {\\n            int n = getN(i);\\n            if (n > 4) return false;\\n\\n            //An integer can either represent the start of a UTF-8 character, or a part of an existing UTF-8 character.\\n            // There are two separate rules for these two scenarios in the problem.\\n            if (n == 1) {\\n                //scenario 1: If an integer is a part of an existing UTF-8 character, simply check the 2 most significant bits of in the binary representation string.\\n                // They should be 10.  ie. n==1\\n                if (prevN <= 0) return false;\\n            } else {\\n                //scenario 2: If the integer represents the start of a UTF-8 character,\\n                // then the first few bits would be 1 followed by a 0. The number of initial bits\\n                // (most significant) bits determines the length of the UTF-8 character. ie length  = n\\n                if (prevN > 0) return false;\\n                // The array can contain multiple valid UTF-8 characters. ie. start of new UTF-8 character\\n                prevN = n;\\n            }\\n            prevN--;\\n\\n        }\\n        if (prevN > 0) return false;\\n        return true;\\n    }\\n\\n    public static int getN(int num) {\\n        //We can use bit masking to check how many initial bits are set for a given number. \\n        // We only need to work with the 8 least significant bits as mentioned in the problem.\\n        int mask = 1 << 7;\\n        int count = 0;\\n        while ((mask & num) != 0) {\\n            count++;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int prevN = 0;\\n        for (int i : data) {\\n            int n = getN(i);\\n            if (n > 4) {\\n                return false;\\n            } else if (n == 1) {\\n                if (prevN <= 0) return false;\\n            } else {\\n                if (prevN > 0) return false;\\n                prevN = n;\\n            }\\n            prevN--;\\n\\n        }\\n        if (prevN > 0) return false;\\n        return true;\\n    }\\n\\n    public static int getN(int num) {\\n        int mask = 1 << 7;\\n        int count = 0;\\n        while ((mask & num) != 0) {\\n            count++;\\n            mask >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976447,
                "title": "c-solution-with-explanation-in-comments-o-n-time-o-1-space",
                "content": "```cpp\\n  // Returs the expected number of bytes in the UTF8 character.\\n    int get_num_bytes(int data) {\\n        if (data >> 7 == 0) { // 0xxxxxxx >> 7 == 0\\n            return 1;\\n        }\\n        if (data >> 5 == 6) { // 110xxxxx >> 5 == 6\\n            return 2;\\n        }\\n        if (data >> 4 == 14) { // 1110xxxx >> 4 == 14\\n            return 3;\\n        }\\n        if (data >> 3 == 30) { // 11110xxx >> 3 == 30\\n            return 4;\\n        }\\n        return 0;\\n    }\\n    \\n    // Returns whether the following byte sequence is valid.\\n    bool is_valid_multibyte(int data) {\\n       return (data >> 6 == 2); // 10xxxxxx >> 6 == 2\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        for (int byte_index = 0; byte_index < data.size(); ++byte_index) {\\n            auto num_bytes = get_num_bytes(data[byte_index]);\\n            if (num_bytes == 0) {\\n                return false;\\n            }\\n            if (num_bytes == 1) { \\n                // We are not expecting any following bytes for single byte\\n                // UTF8 character.\\n                continue;\\n            }\\n            if (data.size() < num_bytes + byte_index) {\\n                // Make sure we have the expected number of bytes in the\\n                // data vector for this UTF8 character.\\n                return false;\\n            }\\n            // Make sure that all the byte sequences are valid.\\n            while(--num_bytes > 0) {\\n                ++byte_index;\\n                if (!is_valid_multibyte(data[byte_index])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```cpp\\n  // Returs the expected number of bytes in the UTF8 character.\\n    int get_num_bytes(int data) {\\n        if (data >> 7 == 0) { // 0xxxxxxx >> 7 == 0\\n            return 1;\\n        }\\n        if (data >> 5 == 6) { // 110xxxxx >> 5 == 6\\n            return 2;\\n        }\\n        if (data >> 4 == 14) { // 1110xxxx >> 4 == 14\\n            return 3;\\n        }\\n        if (data >> 3 == 30) { // 11110xxx >> 3 == 30\\n            return 4;\\n        }\\n        return 0;\\n    }\\n    \\n    // Returns whether the following byte sequence is valid.\\n    bool is_valid_multibyte(int data) {\\n       return (data >> 6 == 2); // 10xxxxxx >> 6 == 2\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        for (int byte_index = 0; byte_index < data.size(); ++byte_index) {\\n            auto num_bytes = get_num_bytes(data[byte_index]);\\n            if (num_bytes == 0) {\\n                return false;\\n            }\\n            if (num_bytes == 1) { \\n                // We are not expecting any following bytes for single byte\\n                // UTF8 character.\\n                continue;\\n            }\\n            if (data.size() < num_bytes + byte_index) {\\n                // Make sure we have the expected number of bytes in the\\n                // data vector for this UTF8 character.\\n                return false;\\n            }\\n            // Make sure that all the byte sequences are valid.\\n            while(--num_bytes > 0) {\\n                ++byte_index;\\n                if (!is_valid_multibyte(data[byte_index])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 644907,
                "title": "rust-12-lines-short-solution-0ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let mut left = 0; \\n        for d in data.iter() {\\n            if left == 0 {\\n                if d >> 3 == 0b11110 { left = 3 }\\n                else if d >> 4 == 0b1110 { left = 2 }\\n                else if d >> 5 == 0b110 { left = 1 }\\n                else if d >> 7 == 0b0 { left = 0 }\\n                else { return false }\\n            } else {\\n                if d >> 6 != 0b10 { return false }\\n                left -= 1;\\n            }\\n        }\\n        left == 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let mut left = 0; \\n        for d in data.iter() {\\n            if left == 0 {\\n                if d >> 3 == 0b11110 { left = 3 }\\n                else if d >> 4 == 0b1110 { left = 2 }\\n                else if d >> 5 == 0b110 { left = 1 }\\n                else if d >> 7 == 0b0 { left = 0 }\\n                else { return false }\\n            } else {\\n                if d >> 6 != 0b10 { return false }\\n                left -= 1;\\n            }\\n        }\\n        left == 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311973,
                "title": "3ms-straightforward-java-solution-with-customized-to-binary-string-method",
                "content": "The idea is:\\n1. Loop through the int array.\\n2. For current int, convert to 8 digits string with \\'0\\' prefix padding\\n3. If it starts with \\'0\\', continue;\\n4. If it starts with known patterns, setup the number of digits\\n5. Otherwise, return false since unknown pattern encountered.\\n6. Check following number of ints to see if they all are starts with \"10\", if not, return false;\\n\\npublic boolean validUtf8(int[] data) {\\n        if (data == null || data.length == 0) return false;\\n        \\n        int i = 0;\\n        while (i < data.length) {\\n            String strBinary = toBinaryString(data[i++]);\\n            \\n            if (strBinary.startsWith(\"0\")) {\\n                continue;\\n            }\\n            \\n            int numLeft = 0;\\n            \\n            if (strBinary.startsWith(\"110\")) {\\n                numLeft = 1;\\n            } else if (strBinary.startsWith(\"1110\")) {\\n                numLeft = 2;\\n            } else if (strBinary.startsWith(\"11110\")) {\\n                numLeft = 3;\\n            } else {\\n                return false;\\n            }\\n            \\n            if (i + numLeft > data.length) {\\n                return false;\\n            }\\n            \\n            while (numLeft > 0) {\\n                strBinary = toBinaryString(data[i++]);\\n                if (!strBinary.startsWith(\"10\")) {\\n                    return false;\\n                }\\n                numLeft--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private String toBinaryString(int input) {\\n        char[] out = new char[8];\\n        \\n        for (int j = 0; j < 8; j++) out[j] = \\'0\\';\\n        \\n        int i = 7;\\n        while(input > 0 && i >= 0) {\\n            out[i--] += input % 2;\\n            input /= 2;\\n        }\\n        \\n        return new String(out);\\n    }",
                "solutionTags": [],
                "code": "The idea is:\\n1. Loop through the int array.\\n2. For current int, convert to 8 digits string with \\'0\\' prefix padding\\n3. If it starts with \\'0\\', continue;\\n4. If it starts with known patterns, setup the number of digits\\n5. Otherwise, return false since unknown pattern encountered.\\n6. Check following number of ints to see if they all are starts with \"10\", if not, return false;\\n\\npublic boolean validUtf8(int[] data) {\\n        if (data == null || data.length == 0) return false;\\n        \\n        int i = 0;\\n        while (i < data.length) {\\n            String strBinary = toBinaryString(data[i++]);\\n            \\n            if (strBinary.startsWith(\"0\")) {\\n                continue;\\n            }\\n            \\n            int numLeft = 0;\\n            \\n            if (strBinary.startsWith(\"110\")) {\\n                numLeft = 1;\\n            } else if (strBinary.startsWith(\"1110\")) {\\n                numLeft = 2;\\n            } else if (strBinary.startsWith(\"11110\")) {\\n                numLeft = 3;\\n            } else {\\n                return false;\\n            }\\n            \\n            if (i + numLeft > data.length) {\\n                return false;\\n            }\\n            \\n            while (numLeft > 0) {\\n                strBinary = toBinaryString(data[i++]);\\n                if (!strBinary.startsWith(\"10\")) {\\n                    return false;\\n                }\\n                numLeft--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private String toBinaryString(int input) {\\n        char[] out = new char[8];\\n        \\n        for (int j = 0; j < 8; j++) out[j] = \\'0\\';\\n        \\n        int i = 7;\\n        while(input > 0 && i >= 0) {\\n            out[i--] += input % 2;\\n            input /= 2;\\n        }\\n        \\n        return new String(out);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 251054,
                "title": "easiest-java-solution-4ms",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for(int value : data) {\\n            if(count == 0) {\\n                if(value >> 5 == 0b110)\\n                    count = 1; //more 1 byte\\n                else if(value >> 4 == 0b1110)\\n                    count = 2; //more 2 bytes\\n                else if(value >> 3 == 0b11110)\\n                    count = 3; //more 3 bytes\\n                else if(value >> 7 != 0)\\n                    return false; //means just 1 byte data\\n            }\\n            else {\\n                if(value >> 6 != 0b10) //all bytes should start with 10\\n                    return false;\\n                count--;\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n        int count = 0;\\n        for(int value : data) {\\n            if(count == 0) {\\n                if(value >> 5 == 0b110)\\n                    count = 1; //more 1 byte\\n                else if(value >> 4 == 0b1110)\\n                    count = 2; //more 2 bytes\\n                else if(value >> 3 == 0b11110)\\n                    count = 3; //more 3 bytes\\n                else if(value >> 7 != 0)\\n                    return false; //means just 1 byte data\\n            }\\n            else {\\n                if(value >> 6 != 0b10) //all bytes should start with 10\\n                    return false;\\n                count--;\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87496,
                "title": "simple-one-pass-concise-java-solution-beating-99",
                "content": "So, I wrote a literal translation of the problem statement in Java. This works in O(n), obviously.\\n\\n```\\npublic class Solution {\\n\\tpublic boolean validUtf8(int[] data) {\\n\\t\\tint varCharLeft = 0;\\n\\t\\tfor (int b: data) {\\n\\t\\t\\tif (varCharLeft == 0) {\\n\\t\\t\\t\\tif ((b & 0b010000000) == 0)  varCharLeft = 0;\\n\\t\\t\\t\\telse if ((b & 0b011100000) == 0b11000000)  varCharLeft = 1;\\n\\t\\t\\t\\telse if ((b & 0b011110000) == 0b11100000)  varCharLeft = 2;\\n\\t\\t\\t\\telse if ((b & 0b011111000) == 0b11110000)  varCharLeft = 3;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ((b & 0b011000000) != 0b10000000)  return false;\\n\\t\\t\\t\\tvarCharLeft--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn varCharLeft==0;\\n\\t}\\n}\\n```\\n\\nJust bragging, this beats 99.86% submissions. But, seems like in leetcode, timing is very inconsistent nowadays. \\n![0_1475701198342_Capture.PNG](/uploads/files/1475701270757-capture.png)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic boolean validUtf8(int[] data) {\\n\\t\\tint varCharLeft = 0;\\n\\t\\tfor (int b: data) {\\n\\t\\t\\tif (varCharLeft == 0) {\\n\\t\\t\\t\\tif ((b & 0b010000000) == 0)  varCharLeft = 0;\\n\\t\\t\\t\\telse if ((b & 0b011100000) == 0b11000000)  varCharLeft = 1;\\n\\t\\t\\t\\telse if ((b & 0b011110000) == 0b11100000)  varCharLeft = 2;\\n\\t\\t\\t\\telse if ((b & 0b011111000) == 0b11110000)  varCharLeft = 3;\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ((b & 0b011000000) != 0b10000000)  return false;\\n\\t\\t\\t\\tvarCharLeft--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn varCharLeft==0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87533,
                "title": "python-o-n-scan",
                "content": "```\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(data) == 0:\\n            return True \\n        i = 0\\n        while i < len(data):\\n            if data[i] < 128:\\n                i += 1\\n            elif data[i] >= 192 and data[i] < 224 and len(data)-i>=2:\\n                if data[i+1] >= 128 and data[i+1] < 192:\\n                    i += 2\\n                else:\\n                    return False \\n            elif data[i] >= 224 and data[i] < 240 and len(data)-i>=3:\\n                if data[i+1] >= 128 and data[i+1] < 192 and data[i+2] >= 128 and data[i+2] < 192:\\n                    i += 3\\n                else:\\n                    return False  \\n            elif data[i] >= 240 and data[i] < 248 and len(data)-i>=4:\\n                if data[i+1] >= 128 and data[i+1] < 192 and data[i+2] >= 128 and data[i+2] < 192 and data[i+3] >= 128 and data[i+3] < 192:\\n                    i += 4\\n                else:\\n                    return False        \\n            else:\\n                return False\\n        return True \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(data) == 0:\\n            return True \\n        i = 0\\n        while i < len(data):\\n            if data[i] < 128:\\n                i += 1\\n            elif data[i] >= 192 and data[i] < 224 and len(data)-i>=2:\\n                if data[i+1] >= 128 and data[i+1] < 192:\\n                    i += 2\\n                else:\\n                    return False \\n            elif data[i] >= 224 and data[i] < 240 and len(data)-i>=3:\\n                if data[i+1] >= 128 and data[i+1] < 192 and data[i+2] >= 128 and data[i+2] < 192:\\n                    i += 3\\n                else:\\n                    return False  \\n            elif data[i] >= 240 and data[i] < 248 and len(data)-i>=4:\\n                if data[i+1] >= 128 and data[i+1] < 192 and data[i+2] >= 128 and data[i+2] < 192 and data[i+3] >= 128 and data[i+3] < 192:\\n                    i += 4\\n                else:\\n                    return False        \\n            else:\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726810,
                "title": "c-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// We will iterate through array. Let, we are at data[i]. So,count no. of 1 bits in its MSB position. For this, I have used count1Bits() function\\n// If no. of 1 bits in leftmost position=0 then it is 1 Byte character (& it should start from zero which it is starting as its leftmost position=0), so simply do i++.\\n// If no. of 1 bits in leftmost position=1 then it is not valid. Bcoz, leftmost 1\\'s should be zero or >=2 & <4\\n\\n//Once, we get count of 1\\'s in leftmost position at data[i], let these are 4, so next 3 numbers should start with 10. Now, to check if next 3 numbers are starting with 10 or not, I have called isCorrect() function\\n\\n    int count1Bits(int n){\\n        if(((1<<7)&n)==0)\\n            return 1;\\n        int x=7, count=0;\\n        while(x>=0){\\n            if(((1<<x)&n)>0){\\n                count++;\\n                x--;\\n            }\\n            else\\n                return count;\\n        }\\n        return count;\\n    }\\n    \\n    bool isCorrect(int n){\\n        if(((1<<7)&n)==0)\\n            return false;\\n        if(((1<<6)&n)==0)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int sz=data.size();\\n        int i=0;\\n        \\n        while(i<sz){\\n            int n=count1Bits(data[i]);\\n            cout<<n<<\" \";\\n            \\n            if(n==1){\\n                if(((1<<7)&data[i])==0)\\n                i++;\\n                else   //if no. of 1 in leftmost position=1, then it is invalid\\n                return false;\\n            }\\n            \\n        //since, a character in utf-8 can be from 1 to 4 bytes long. So, if n>4, return false\\n            else if(n>4)  \\n            return false;\\n\\n            else{\\n                int j=0;\\n\\n// If no. of 1\\'s in leftmost position=4 then we need to check next 3 numbers. So, that\\'s why I have done n--\\n                n--;  \\n            \\n                \\n                while((i+1)<sz && j<n){\\n                    if(isCorrect(data[i+1])==false)\\n                        return false;\\n                    i++;\\n                    j++;\\n                }\\n                if(j!=n)\\n                    return false;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// We will iterate through array. Let, we are at data[i]. So,count no. of 1 bits in its MSB position. For this, I have used count1Bits() function\\n// If no. of 1 bits in leftmost position=0 then it is 1 Byte character (& it should start from zero which it is starting as its leftmost position=0), so simply do i++.\\n// If no. of 1 bits in leftmost position=1 then it is not valid. Bcoz, leftmost 1\\'s should be zero or >=2 & <4\\n\\n//Once, we get count of 1\\'s in leftmost position at data[i], let these are 4, so next 3 numbers should start with 10. Now, to check if next 3 numbers are starting with 10 or not, I have called isCorrect() function\\n\\n    int count1Bits(int n){\\n        if(((1<<7)&n)==0)\\n            return 1;\\n        int x=7, count=0;\\n        while(x>=0){\\n            if(((1<<x)&n)>0){\\n                count++;\\n                x--;\\n            }\\n            else\\n                return count;\\n        }\\n        return count;\\n    }\\n    \\n    bool isCorrect(int n){\\n        if(((1<<7)&n)==0)\\n            return false;\\n        if(((1<<6)&n)==0)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int sz=data.size();\\n        int i=0;\\n        \\n        while(i<sz){\\n            int n=count1Bits(data[i]);\\n            cout<<n<<\" \";\\n            \\n            if(n==1){\\n                if(((1<<7)&data[i])==0)\\n                i++;\\n                else   //if no. of 1 in leftmost position=1, then it is invalid\\n                return false;\\n            }\\n            \\n        //since, a character in utf-8 can be from 1 to 4 bytes long. So, if n>4, return false\\n            else if(n>4)  \\n            return false;\\n\\n            else{\\n                int j=0;\\n\\n// If no. of 1\\'s in leftmost position=4 then we need to check next 3 numbers. So, that\\'s why I have done n--\\n                n--;  \\n            \\n                \\n                while((i+1)<sz && j<n){\\n                    if(isCorrect(data[i+1])==false)\\n                        return false;\\n                    i++;\\n                    j++;\\n                }\\n                if(j!=n)\\n                    return false;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2848437,
                "title": "java-simple-solution",
                "content": "This is simple and intuitive Java solution\\n\\n```\\npublic boolean validUtf8(int[] data) {\\n        int size = data.length;\\n        if (size == 0) {\\n            return false;\\n        }\\n\\n        for (int index = 0; index < size; index++) {\\n            int bitCount = getUnicodeBytesCount(data[index]);\\n            if (bitCount == -1 || size - index < bitCount) {\\n                return false;\\n            }\\n            \\n            for (int subIndex = 1; subIndex < bitCount; subIndex++) {\\n                if (getLastNBits(data[++index], 2) != 0b10) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public int getUnicodeBytesCount(int firstByte) {\\n        if (getLastNBits(firstByte, 1) == 0b0) {\\n            return 1;\\n        } else if (getLastNBits(firstByte, 3) == 0b110) {\\n            return 2;\\n        } else if (getLastNBits(firstByte, 4) == 0b1110) {\\n            return 3;\\n        } else if (getLastNBits(firstByte, 5) == 0b11110) {\\n            return 4;\\n        } else {\\n            return -1;\\n        }\\n    }\\n\\n    public int getLastNBits(int digit, int n) {\\n        int shift = 8 - (Math.max(n, 0));\\n\\n        return ((digit >> shift) & (0b11111111 >> shift));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n        int size = data.length;\\n        if (size == 0) {\\n            return false;\\n        }\\n\\n        for (int index = 0; index < size; index++) {\\n            int bitCount = getUnicodeBytesCount(data[index]);\\n            if (bitCount == -1 || size - index < bitCount) {\\n                return false;\\n            }\\n            \\n            for (int subIndex = 1; subIndex < bitCount; subIndex++) {\\n                if (getLastNBits(data[++index], 2) != 0b10) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public int getUnicodeBytesCount(int firstByte) {\\n        if (getLastNBits(firstByte, 1) == 0b0) {\\n            return 1;\\n        } else if (getLastNBits(firstByte, 3) == 0b110) {\\n            return 2;\\n        } else if (getLastNBits(firstByte, 4) == 0b1110) {\\n            return 3;\\n        } else if (getLastNBits(firstByte, 5) == 0b11110) {\\n            return 4;\\n        } else {\\n            return -1;\\n        }\\n    }\\n\\n    public int getLastNBits(int digit, int n) {\\n        int shift = 8 - (Math.max(n, 0));\\n\\n        return ((digit >> shift) & (0b11111111 >> shift));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582055,
                "title": "java-simplest-o-n-no-bit-manipulation",
                "content": "Using some knowledge about Binary numbers we can find that:\\n0xxxxxxx  can have min value of 0 and max value of127 to represent that i am using a simple mathematical notation [i,j]= interval including i and j where i is lower bound and j is upper bound.\\n\\nSo, we can modify our representation as:\\n0xxxxxxx[0,127]\\n110xxxxx[192,223] 10xxxxxx[128,191]\\n1110xxxx[224,239] 10xxxxxx[128,191] 10xxxxxx[128,191]\\n11110xxx[240,247] 10xxxxxx[128,191] 10xxxxxx[128,191] 10xxxxxx[128,191]\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int nextToCheck=0;\\n        for(int i=0;i<data.length;i++)\\n            if( nextToCheck>0 )\\n                if( data[i]>127 && data[i]<192 ) nextToCheck--;\\n                else return false;\\n            else\\n                if( data[i]<128 );\\n                else if( data[i]>191 && data[i]<224 ) nextToCheck=1;\\n                else if( data[i]>223 && data[i]<240 ) nextToCheck=2;\\n                else if( data[i]>239 && data[i]<248 ) nextToCheck=3;\\n                else return false;\\n        if(nextToCheck>0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int nextToCheck=0;\\n        for(int i=0;i<data.length;i++)\\n            if( nextToCheck>0 )\\n                if( data[i]>127 && data[i]<192 ) nextToCheck--;\\n                else return false;\\n            else\\n                if( data[i]<128 );\\n                else if( data[i]>191 && data[i]<224 ) nextToCheck=1;\\n                else if( data[i]>223 && data[i]<240 ) nextToCheck=2;\\n                else if( data[i]>239 && data[i]<248 ) nextToCheck=3;\\n                else return false;\\n        if(nextToCheck>0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575460,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        next = 0\\n        for i in data:\\n            if next == 0:\\n                if (i>>5)==0b110:#for 2 bytes\\n                    next = 1\\n                elif (i>>4)==0b1110:#for 3 bytes\\n                    next = 2\\n                elif (i>>3)==0b11110:#for 4 bytes\\n                    next = 3\\n                elif (i>>7)!= 0b0:\\n                    return False\\n            else:\\n                if (i>>6)!= 0b10:#checking next occurence\\n                    return False\\n                next -= 1\\n        if next == 0:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        n = len(data)\\n        next = 0\\n        for i in data:\\n            if next == 0:\\n                if (i>>5)==0b110:#for 2 bytes\\n                    next = 1\\n                elif (i>>4)==0b1110:#for 3 bytes\\n                    next = 2\\n                elif (i>>3)==0b11110:#for 4 bytes\\n                    next = 3\\n                elif (i>>7)!= 0b0:\\n                    return False\\n            else:\\n                if (i>>6)!= 0b10:#checking next occurence\\n                    return False\\n                next -= 1\\n        if next == 0:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572751,
                "title": "java-solution-right-shift-operator",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int bytesRemain = 0;\\n        for (int val : data)\\n        {\\n            if (bytesRemain==0)\\n            {\\n                if (val>>7 == 0b0)\\n                  bytesRemain = 0;\\n                else if (val>>5 == 0b110)\\n                    bytesRemain = 1;\\n                else if (val>>4 == 0b1110)\\n                  bytesRemain = 2;\\n                else if (val>>3 == 0b11110)\\n                    bytesRemain = 3;\\n                else \\n                    return false; // for TestCase [255] \\n            }\\n            else \\n            {\\n                if (val >> 6 == 0b10)\\n                    bytesRemain--;\\n                else \\n                    return false;\\n            }    \\n        }\\n        return bytesRemain == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int bytesRemain = 0;\\n        for (int val : data)\\n        {\\n            if (bytesRemain==0)\\n            {\\n                if (val>>7 == 0b0)\\n                  bytesRemain = 0;\\n                else if (val>>5 == 0b110)\\n                    bytesRemain = 1;\\n                else if (val>>4 == 0b1110)\\n                  bytesRemain = 2;\\n                else if (val>>3 == 0b11110)\\n                    bytesRemain = 3;\\n                else \\n                    return false; // for TestCase [255] \\n            }\\n            else \\n            {\\n                if (val >> 6 == 0b10)\\n                    bytesRemain--;\\n                else \\n                    return false;\\n            }    \\n        }\\n        return bytesRemain == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572673,
                "title": "c-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int val) {\\n        int res = 0, len = 8;\\n        while(val and len) {\\n            if(val&1) res++;\\n            else res = 0;\\n            val>>=1, len--;\\n        }\\n        if(len) return 0;\\n        return res;\\n    }\\n    bool notPossible(vector<int>& data, int idx, int ones, int n) {\\n        idx++, ones--;\\n        while(idx < n and ones and find(data[idx]) == 1) idx++, ones--;\\n        return ones;\\n        \\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int idx = 0, n = data.size();\\n        while(idx < n) {\\n            int val = find(data[idx]);\\n            if(val == 1 or val > 4) return 0;\\n            if(val) {\\n                if(notPossible(data, idx, val, n)) return 0;\\n                idx += val;\\n            }\\n            else idx++;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int val) {\\n        int res = 0, len = 8;\\n        while(val and len) {\\n            if(val&1) res++;\\n            else res = 0;\\n            val>>=1, len--;\\n        }\\n        if(len) return 0;\\n        return res;\\n    }\\n    bool notPossible(vector<int>& data, int idx, int ones, int n) {\\n        idx++, ones--;\\n        while(idx < n and ones and find(data[idx]) == 1) idx++, ones--;\\n        return ones;\\n        \\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int idx = 0, n = data.size();\\n        while(idx < n) {\\n            int val = find(data[idx]);\\n            if(val == 1 or val > 4) return 0;\\n            if(val) {\\n                if(notPossible(data, idx, val, n)) return 0;\\n                idx += val;\\n            }\\n            else idx++;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572204,
                "title": "golang-with-examples-and-cases-explanation",
                "content": "Test cases below the code.\\n\\n```go\\nfunc validUtf8(data []int) bool {\\n\\t\\t// represents how many bytes to be read for the character\\n        numberOfBytes := 0\\n        for i := 0; i < len(data); i++ {\\n                // expect starting of the new character\\n                if numberOfBytes == 0 {\\n                        switch {\\n\\t\\t\\t\\t\\t\\t// single byte character\\n                        case data[i]&0x80 == 0:\\n                                continue\\n\\t\\t\\t\\t\\t\\t// two bytes character\\n                        case (data[i]&0xC0 == 0xC0) && (data[i]&0x20 == 0):\\n                                numberOfBytes = 1\\n\\t\\t\\t\\t\\t\\t// three bytes character\\n                        case (data[i]&0xE0 == 0xE0) && (data[i]&0x10 == 0):\\n                                numberOfBytes = 2\\n\\t\\t\\t\\t\\t\\t// four bytes character\\n                        case (data[i]&0xF0 == 0xF0) && (data[i]&0x08 == 0):\\n                                numberOfBytes = 3\\n\\t\\t\\t\\t\\t\\t// if no match - invalid\\n                        default:\\n                                return false\\n                        }\\n                } else {\\n\\t\\t\\t\\t\\t\\t// if the first bit is not set or second bit is not zero\\n                        if !((data[i]&0x80 == 0x80) && (data[i]&0x40 == 0)) {\\n                                return false\\n                        }\\n                        numberOfBytes--\\n                }\\n        }\\n\\t\\t// there could be a case when not enough bytes existed in `data` for multibytes character\\n        return numberOfBytes == 0\\n}\\n```\\n\\nTests:\\n```go\\ntype test struct {\\n\\t\\tdata   []int\\n\\t\\texpect bool\\n}\\n\\ntests := []test{\\n\\t\\t{[]int{127}, true},                // 0b01111111 - single byte character\\n\\t\\t{[]int{128}, false},               // 0b10000000 - invalid, first bit is set\\n\\t\\t{[]int{170}, false},               // 0b10101010 - invalid, first bit is set\\n\\t\\t{[]int{200, 128}, true},           // 0b11001000 0b10000000 - two bytes\\n\\t\\t{[]int{200, 192}, false},          // 0b11001000 0b11000000 - invalid, second byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160, 127}, false},     // 0b11100000 0b10100000 0b01111111 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160}, false},          // 0b11100000 0b10100000 - invalid, expect one more byte for three bytes character\\n\\t\\t{[]int{224, 160, 192}, false},     // 0b11100000 0b10100000 0b11000000 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160, 191}, true},      // 0b11100000 0b10100000 0b10111111 - three bytes character\\n\\t\\t{[]int{248}, false},               // 0b11111000 - invalid, expect maximum 4 bits set, got 5\\n\\t\\t{[]int{224, 160, 193}, false},     // 0b11100000 0b10100000 0b11000001 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{244, 160, 191}, false},     // 0b11100000 0b10100000 0b10111111 - invalid, ecpect one more byte for four bytes character\\n\\t\\t{[]int{244, 160, 191, 178}, true}, // 0b11100000 0b10100000 0b10111111 0b10110010 - four bytes character\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc validUtf8(data []int) bool {\\n\\t\\t// represents how many bytes to be read for the character\\n        numberOfBytes := 0\\n        for i := 0; i < len(data); i++ {\\n                // expect starting of the new character\\n                if numberOfBytes == 0 {\\n                        switch {\\n\\t\\t\\t\\t\\t\\t// single byte character\\n                        case data[i]&0x80 == 0:\\n                                continue\\n\\t\\t\\t\\t\\t\\t// two bytes character\\n                        case (data[i]&0xC0 == 0xC0) && (data[i]&0x20 == 0):\\n                                numberOfBytes = 1\\n\\t\\t\\t\\t\\t\\t// three bytes character\\n                        case (data[i]&0xE0 == 0xE0) && (data[i]&0x10 == 0):\\n                                numberOfBytes = 2\\n\\t\\t\\t\\t\\t\\t// four bytes character\\n                        case (data[i]&0xF0 == 0xF0) && (data[i]&0x08 == 0):\\n                                numberOfBytes = 3\\n\\t\\t\\t\\t\\t\\t// if no match - invalid\\n                        default:\\n                                return false\\n                        }\\n                } else {\\n\\t\\t\\t\\t\\t\\t// if the first bit is not set or second bit is not zero\\n                        if !((data[i]&0x80 == 0x80) && (data[i]&0x40 == 0)) {\\n                                return false\\n                        }\\n                        numberOfBytes--\\n                }\\n        }\\n\\t\\t// there could be a case when not enough bytes existed in `data` for multibytes character\\n        return numberOfBytes == 0\\n}\\n```\n```go\\ntype test struct {\\n\\t\\tdata   []int\\n\\t\\texpect bool\\n}\\n\\ntests := []test{\\n\\t\\t{[]int{127}, true},                // 0b01111111 - single byte character\\n\\t\\t{[]int{128}, false},               // 0b10000000 - invalid, first bit is set\\n\\t\\t{[]int{170}, false},               // 0b10101010 - invalid, first bit is set\\n\\t\\t{[]int{200, 128}, true},           // 0b11001000 0b10000000 - two bytes\\n\\t\\t{[]int{200, 192}, false},          // 0b11001000 0b11000000 - invalid, second byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160, 127}, false},     // 0b11100000 0b10100000 0b01111111 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160}, false},          // 0b11100000 0b10100000 - invalid, expect one more byte for three bytes character\\n\\t\\t{[]int{224, 160, 192}, false},     // 0b11100000 0b10100000 0b11000000 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{224, 160, 191}, true},      // 0b11100000 0b10100000 0b10111111 - three bytes character\\n\\t\\t{[]int{248}, false},               // 0b11111000 - invalid, expect maximum 4 bits set, got 5\\n\\t\\t{[]int{224, 160, 193}, false},     // 0b11100000 0b10100000 0b11000001 - invalid, third byte must be 0b10xxxxxx\\n\\t\\t{[]int{244, 160, 191}, false},     // 0b11100000 0b10100000 0b10111111 - invalid, ecpect one more byte for four bytes character\\n\\t\\t{[]int{244, 160, 191, 178}, true}, // 0b11100000 0b10100000 0b10111111 0b10110010 - four bytes character\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571823,
                "title": "runtime-30-ms-memory-usage-6-8-mb-implemented-in-c",
                "content": "Runtime: 30 ms, Memory Usage: 6.8 MB implemented in C.\\n\\n```c\\nbool validUtf8(const int* data, const int len){\\n    unsigned char match;\\n    for(int i = 0; i < len; i += 1)\\n    {\\n        if((0x80 & data[i]) == 0x00)\\n            continue;\\n        else if((0xE0 & data[i]) == 0xC0)\\n            match = 1;\\n        else if((0xF0 & data[i]) == 0xE0)\\n            match = 2;\\n        else if((0xF8 & data[i]) == 0xF0)\\n            match = 3;\\n        else\\n            return false;\\n\\n        if(i + match >= len)\\n            return 0;\\n        for(; match > 0; match -= 1)\\n            if((0xC0 & data[++i]) != 0x80)\\n                return false;\\n    }\\n    \\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```c\\nbool validUtf8(const int* data, const int len){\\n    unsigned char match;\\n    for(int i = 0; i < len; i += 1)\\n    {\\n        if((0x80 & data[i]) == 0x00)\\n            continue;\\n        else if((0xE0 & data[i]) == 0xC0)\\n            match = 1;\\n        else if((0xF0 & data[i]) == 0xE0)\\n            match = 2;\\n        else if((0xF8 & data[i]) == 0xF0)\\n            match = 3;\\n        else\\n            return false;\\n\\n        if(i + match >= len)\\n            return 0;\\n        for(; match > 0; match -= 1)\\n            if((0xC0 & data[++i]) != 0x80)\\n                return false;\\n    }\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571819,
                "title": "o-n-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        \\n        int n = data.length, byt = 0;\\n        for( int i=0; i<n; i++ ){\\n            \\n            if( byt==0 ) {\\n\\t\\t\\t\\t// to check how many bytes number we currently have\\n\\t\\t\\t\\t// when the number is one byte -> directly checking left most bit\\n                if( ((data[i]>>7)&1)==0 ) continue;\\n\\t\\t\\t\\t// to get the number of left most 1\\'s -> n 1 -> leading to (n-1) terms starting with \"10\"\\n                else {\\n                    byt = encoding(data[i]);\\n\\t\\t\\t\\t\\t// if byt is 0 , it means number only has 1 left most bit which is not valid\\n                    if( byt==0 ) return false;\\n                }\\n            }\\n            else{\\n                int num = data[i];\\n                num = num>>6;\\n\\t\\t\\t\\t// to check whether the number starts with 10 or not \\n                if( num!=2 ) return false;\\n                byt--;\\n            }\\n            // the number of terms after the main byte cannot be greater than or equal to 4\\n            if( byt>=4 ) return false;\\n        }\\n        if( byt!=0 ) return false;\\n        return true;\\n    }\\n    \\n\\t// function to return left most 1\\'s of a number\\n    public int encoding( int num ){\\n        int pos = 1, res = 0;\\n        while( num>0 ){\\n            if( (num&1)==0 ) res = pos;\\n            pos++;\\n            num = num>>1;\\n        }\\n        \\n        return (8-res-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        \\n        int n = data.length, byt = 0;\\n        for( int i=0; i<n; i++ ){\\n            \\n            if( byt==0 ) {\\n\\t\\t\\t\\t// to check how many bytes number we currently have\\n\\t\\t\\t\\t// when the number is one byte -> directly checking left most bit\\n                if( ((data[i]>>7)&1)==0 ) continue;\\n\\t\\t\\t\\t// to get the number of left most 1\\'s -> n 1 -> leading to (n-1) terms starting with \"10\"\\n                else {\\n                    byt = encoding(data[i]);\\n\\t\\t\\t\\t\\t// if byt is 0 , it means number only has 1 left most bit which is not valid\\n                    if( byt==0 ) return false;\\n                }\\n            }\\n            else{\\n                int num = data[i];\\n                num = num>>6;\\n\\t\\t\\t\\t// to check whether the number starts with 10 or not \\n                if( num!=2 ) return false;\\n                byt--;\\n            }\\n            // the number of terms after the main byte cannot be greater than or equal to 4\\n            if( byt>=4 ) return false;\\n        }\\n        if( byt!=0 ) return false;\\n        return true;\\n    }\\n    \\n\\t// function to return left most 1\\'s of a number\\n    public int encoding( int num ){\\n        int pos = 1, res = 0;\\n        while( num>0 ){\\n            if( (num&1)==0 ) res = pos;\\n            pos++;\\n            num = num>>1;\\n        }\\n        \\n        return (8-res-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571588,
                "title": "python-bit-manipulation-with-state-machine",
                "content": "In embedded system\\n, we use state machine a lot since it would not \"hold\" the mcu compuation source too long\\nthat make the system stall in the for-loop or while-loop.\\n\\nMost commonly,  if there are some data protocol we need to parse, \\nstate machine is the first choice since we are not sure when the next data will received.\\nWe can polling the reciever to see whether the data goes in, but it\\'s not very source efficient.\\n\\n**For this problem, we can simplfy the state machine to Two-Step.**\\n1. Check if the data fit the first-byte of UTF-8 (start with 0, 110, 1110, 11110)\\n\\t, we set the count to how many 10-start byte we need to check(ex. 1110 means there should be two 10-start bytes follow up)\\n\\t, and go to state-1\\n2. Check if data start with 10 and minus the count.\\n   if count is 0, go back to state-0.\\n   \\n```\\nclass Solution:\\n\\tdef validUtf8(self, data: List[int]) -> bool:\\n\\t\\tindex = 0\\n\\t\\tstate = 0 #this is for state-machine\\n\\t\\tcount = 0 #this is counter for checking 10-start data\\n\\t\\t\\n\\t\\twhile index<len(data):\\n\\t\\t\\tmatch(state):\\n\\t\\t\\t\\tcase 0: #state-0 check leading byte\\n\\t\\t\\t\\t\\tif data[index]>>3==0x1E: #if data start with 11110\\n\\t\\t\\t\\t\\t\\tcount = 3\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>4==0x0E: #if data start with 1110\\n\\t\\t\\t\\t\\t\\tcount = 2\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>5==0x06: #if data start with 110\\n\\t\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>7==0x00: #if data start with 0\\n\\t\\t\\t\\t\\t\\tindex+=1 #no need to go to state-1 since there is no 10-start byte followed by\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False #data invalid\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase 1: #state-1 check 10-start byte\\n\\t\\t\\t\\t\\tif data[index]>>6==0x02:\\n\\t\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\t\\t\\tstate = 0 #there is no 10-start byte followed by, go back to state-0\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\n\\t\\t#data runs out\\n\\t\\tif state==0:\\n\\t\\t\\treturn True #if state back to 0, means data is complete\\n\\t\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n\\tdef validUtf8(self, data: List[int]) -> bool:\\n\\t\\tindex = 0\\n\\t\\tstate = 0 #this is for state-machine\\n\\t\\tcount = 0 #this is counter for checking 10-start data\\n\\t\\t\\n\\t\\twhile index<len(data):\\n\\t\\t\\tmatch(state):\\n\\t\\t\\t\\tcase 0: #state-0 check leading byte\\n\\t\\t\\t\\t\\tif data[index]>>3==0x1E: #if data start with 11110\\n\\t\\t\\t\\t\\t\\tcount = 3\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>4==0x0E: #if data start with 1110\\n\\t\\t\\t\\t\\t\\tcount = 2\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>5==0x06: #if data start with 110\\n\\t\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\t\\t\\tstate = 1\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telif data[index]>>7==0x00: #if data start with 0\\n\\t\\t\\t\\t\\t\\tindex+=1 #no need to go to state-1 since there is no 10-start byte followed by\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False #data invalid\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase 1: #state-1 check 10-start byte\\n\\t\\t\\t\\t\\tif data[index]>>6==0x02:\\n\\t\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\t\\t\\tstate = 0 #there is no 10-start byte followed by, go back to state-0\\n\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\n\\t\\t#data runs out\\n\\t\\tif state==0:\\n\\t\\t\\treturn True #if state back to 0, means data is complete\\n\\t\\treturn False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571448,
                "title": "easiest-explanation-nothing-complex-c",
                "content": "```\\n string binary(int data)\\n    {\\n        string ans=\"\";\\n        while(data>0)\\n        {\\n            ans=to_string(data%2)+ans;\\n            data/=2;\\n        }\\n        \\n        for(int i=ans.size();i<8;i++)\\n            ans=to_string(0)+ans;\\n        \\n        return ans;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        \\n        vector<string> arr;\\n        for(auto i:data)\\n            arr.push_back(binary(i));  //convert number into its binary string\\n        \\n        int i=0;\\n        while(i<arr.size())\\n        {\\n            if(arr[i].substr(0,1)==\"0\")  //1 byte\\n             i++;\\n            \\n            else if(arr[i].substr(0,3)==\"110\")  //2 byte\\n            {\\n                i++;\\n                int count=0;\\n                while(count<1)  //1  \\'10\\' aane chiye agar 2-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++; count++;\\n                }\\n                \\n            }\\n            \\n            else if(arr[i].substr(0,4)==\"1110\")  //3 byte\\n            {\\n                i++;\\n                int count=0;\\n                while(count<2) //2  \\'10\\' aane chiye agar 3-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++; count++;\\n                } \\n            }\\n            \\n            else if(arr[i].substr(0,5)==\"11110\") //4 byte \\n            {\\n                i++;\\n                int count=0;\\n                while(count<3)  //3  \\'10\\' aane chiye agar 4-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++;  count++;\\n                }  \\n            }\\n            else  //charo me se kisi se b match nahi kr rha fir to pkka se false hai\\n                return false;\\n        }\\n        return true;  //agar till now false nahi aya to true. We can represent array in UTF-8\\n    }",
                "solutionTags": [],
                "code": "```\\n string binary(int data)\\n    {\\n        string ans=\"\";\\n        while(data>0)\\n        {\\n            ans=to_string(data%2)+ans;\\n            data/=2;\\n        }\\n        \\n        for(int i=ans.size();i<8;i++)\\n            ans=to_string(0)+ans;\\n        \\n        return ans;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        \\n        vector<string> arr;\\n        for(auto i:data)\\n            arr.push_back(binary(i));  //convert number into its binary string\\n        \\n        int i=0;\\n        while(i<arr.size())\\n        {\\n            if(arr[i].substr(0,1)==\"0\")  //1 byte\\n             i++;\\n            \\n            else if(arr[i].substr(0,3)==\"110\")  //2 byte\\n            {\\n                i++;\\n                int count=0;\\n                while(count<1)  //1  \\'10\\' aane chiye agar 2-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++; count++;\\n                }\\n                \\n            }\\n            \\n            else if(arr[i].substr(0,4)==\"1110\")  //3 byte\\n            {\\n                i++;\\n                int count=0;\\n                while(count<2) //2  \\'10\\' aane chiye agar 3-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++; count++;\\n                } \\n            }\\n            \\n            else if(arr[i].substr(0,5)==\"11110\") //4 byte \\n            {\\n                i++;\\n                int count=0;\\n                while(count<3)  //3  \\'10\\' aane chiye agar 4-byte ka hai to\\n                {\\n                    if(i>=arr.size() or arr[i].substr(0,2)!=\"10\")\\n                        return false;\\n                    \\n                    i++;  count++;\\n                }  \\n            }\\n            else  //charo me se kisi se b match nahi kr rha fir to pkka se false hai\\n                return false;\\n        }\\n        return true;  //agar till now false nahi aya to true. We can represent array in UTF-8\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2571352,
                "title": "javascript-string-manipulation",
                "content": "```\\nconst myObj = {\\n    \"0\" : 1,\\n    \"110\" : 2,\\n    \"1110\" : 3,\\n    \"11110\" : 4,\\n    \"111110\" : 5,\\n    \"1111110\" : 6,\\n    \"11111110\" : 7,\\n    \"11111111\" : 8\\n}\\nvar validUtf8 = function(data) {\\n    let j = 0, count = 0;\\n    \\n    while(j < data.length){\\n        let ele = data[j].toString(2);\\n        ele = \"00000000\".substring(ele.length) + ele;\\n        if(ele.substring(0,2) === \"10\")\\n            return false;\\n    \\n        for(key in myObj){\\n            if(ele.startsWith(key))\\n                count = myObj[key];\\n        }\\n        if(count > 4)\\n            return false;\\n        \\n        for(var i = j+1;i<j+count;i++){\\n            let elem = data[i];\\n            if(elem === undefined) return false;\\n            let val = elem.toString(2);\\n            val = \"00000000\".substring(val.length) + val;\\n            if(val.substring(0,2) !== \"10\") return false;\\n        }\\n        j  =  i;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst myObj = {\\n    \"0\" : 1,\\n    \"110\" : 2,\\n    \"1110\" : 3,\\n    \"11110\" : 4,\\n    \"111110\" : 5,\\n    \"1111110\" : 6,\\n    \"11111110\" : 7,\\n    \"11111111\" : 8\\n}\\nvar validUtf8 = function(data) {\\n    let j = 0, count = 0;\\n    \\n    while(j < data.length){\\n        let ele = data[j].toString(2);\\n        ele = \"00000000\".substring(ele.length) + ele;\\n        if(ele.substring(0,2) === \"10\")\\n            return false;\\n    \\n        for(key in myObj){\\n            if(ele.startsWith(key))\\n                count = myObj[key];\\n        }\\n        if(count > 4)\\n            return false;\\n        \\n        for(var i = j+1;i<j+count;i++){\\n            let elem = data[i];\\n            if(elem === undefined) return false;\\n            let val = elem.toString(2);\\n            val = \"00000000\".substring(val.length) + val;\\n            if(val.substring(0,2) !== \"10\") return false;\\n        }\\n        j  =  i;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571260,
                "title": "easiest-explanation-without-bit-manipulation-in-o-n-time-and-o-1-space",
                "content": "First we have to Think about the range and Preprocess the data ,\\n Suppose If any number in the array is greater than 247 ,then it can never have its 4byte UTF-8\\n\\nSo lets find range ,So if first four bit is set ,then that number must be greater than or equal to 240.\\n If first three bits get set ,then that number must be greater than or equal to 224.\\nIf first two bits are set then the number must be greater than or equal to 192.\\nIf first one digit gets set ,then the number must be greater than 128 and these number must get followed by any of the above number ,otherwise we have to return false.\\nif number is less than 128 ,then it will be 1 byte number.\\nSo ,what we have to do ,if we encounter any number ,first we find range ,and then we take consceutive array elements and check whether it is greater than 128 and less than 192 or not ,if it is then we go in a loop ,otherwise we return false.\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {        \\n        for(int i = 0 ; i < data.length ; i++){\\n            if(data[i] > 247){\\n                return false;\\n            }\\n            int tillThisIndex = range(data[i]);\\n            if(tillThisIndex == -1){\\n                continue;\\n            }else if(tillThisIndex == 0){\\n                return false;\\n            }else if(tillThisIndex > 0){\\n                i++;\\n                int h = i+tillThisIndex;\\n                while(i<data.length && i<h){\\n                    if(range(data[i]) == 0){\\n                        i++;\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n                if(i < h){\\n                    return false;\\n                }\\n                i--;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public int range(int number){\\n        if(number >= 240){\\n            return 3;\\n        }else if(number >= 224){\\n            return 2;\\n        }else if(number >= 192){\\n            return 1;\\n        }else if(number >= 128){\\n            return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {        \\n        for(int i = 0 ; i < data.length ; i++){\\n            if(data[i] > 247){\\n                return false;\\n            }\\n            int tillThisIndex = range(data[i]);\\n            if(tillThisIndex == -1){\\n                continue;\\n            }else if(tillThisIndex == 0){\\n                return false;\\n            }else if(tillThisIndex > 0){\\n                i++;\\n                int h = i+tillThisIndex;\\n                while(i<data.length && i<h){\\n                    if(range(data[i]) == 0){\\n                        i++;\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n                if(i < h){\\n                    return false;\\n                }\\n                i--;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public int range(int number){\\n        if(number >= 240){\\n            return 3;\\n        }else if(number >= 224){\\n            return 2;\\n        }else if(number >= 192){\\n            return 1;\\n        }else if(number >= 128){\\n            return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571157,
                "title": "c-100-simple-solution",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n    bool validUtf8(vector<int>& data) {\\n         int rbytes = 0;\\n       for(int num : data)\\n       {\\n           if(rbytes==0){\\n                if(num>>7 == 0)\\n                rbytes = 0;\\n               else if(num >> 5 == 6)\\n                   rbytes = 1;\\n               else if(num >> 4 == 14)\\n                   rbytes = 2;\\n               else if(num >> 3 == 30)\\n                   rbytes = 3;\\n               else\\n                   return false;\\n                   \\n           }\\n           else{\\n               // cout<<num << \" \"<<(num&197)<<\" \";\\n               if(num >> 6 == 2)\\n                   rbytes-=1;\\n               else \\n                   return false;\\n           }\\n       \\n           \\n       }\\n        return rbytes == 0;\\n    }\\n    int bitCounter(int num)\\n    {\\n           int bitSize = 0;\\n           int diviser = 128;\\n           while(num&diviser){\\n               bitSize+=1;\\n               diviser=(diviser>>1);\\n           }\\n        return bitSize;\\n    }\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool validUtf8(vector<int>& data) {\\n         int rbytes = 0;\\n       for(int num : data)\\n       {\\n           if(rbytes==0){\\n                if(num>>7 == 0)\\n                rbytes = 0;\\n               else if(num >> 5 == 6)\\n                   rbytes = 1;\\n               else if(num >> 4 == 14)\\n                   rbytes = 2;\\n               else if(num >> 3 == 30)\\n                   rbytes = 3;\\n               else\\n                   return false;\\n                   \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2571105,
                "title": "without-using-bit-manipulation-c",
                "content": "It can be very easy , if we start thining from end.\\n\\n```\\nbool validUtf8(vector<int>& data) {\\n        \\n        int byte = 1;\\n        \\n        for(int i=data.size()-1;i>=0;i--){\\n            if(data[i]<128){\\n                \\n                if(byte!=1) return false;\\n                \\n            }else if(128<=data[i] && data[i]<=191){\\n                \\n                byte++;\\n                if(byte>4) return false;\\n                \\n            }else{\\n                string s = bitset<8> (data[i]).to_string();\\n            \\n                for(int b=0;b<byte;b++) if(s[b] != \\'1\\') return false;\\n                if(s[byte] != \\'0\\') return false;\\n                \\n                byte=1;\\n            }\\n        }\\n        if(byte==1) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool validUtf8(vector<int>& data) {\\n        \\n        int byte = 1;\\n        \\n        for(int i=data.size()-1;i>=0;i--){\\n            if(data[i]<128){\\n                \\n                if(byte!=1) return false;\\n                \\n            }else if(128<=data[i] && data[i]<=191){\\n                \\n                byte++;\\n                if(byte>4) return false;\\n                \\n            }else{\\n                string s = bitset<8> (data[i]).to_string();\\n            \\n                for(int b=0;b<byte;b++) if(s[b] != \\'1\\') return false;\\n                if(s[byte] != \\'0\\') return false;\\n                \\n                byte=1;\\n            }\\n        }\\n        if(byte==1) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571004,
                "title": "faster-than-98-c-very-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/7f508077-3517-4afc-b657-6bd518f4fce6_1663075059.7093277.png)\\n\\n# ***Code :***\\n\\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& arr) {\\n        \\n        int n = arr.size ();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if ((arr [i] >> 7) == 0) continue;\\n            else if ((arr [i] >> 5) == 6 and i + 1 < n and (arr [i + 1] >> 6) == 2) i++;\\n            else if ((arr [i] >> 4) == 14 and i + 2 < n and (arr [i + 1] >> 6) == 2 and (arr [i + 2] >> 6) == 2) i += 2;\\n            else if ((arr [i] >> 3) == 30 and i + 3 < n and (arr [i + 1] >> 6) == 2 and (arr [i + 2] >> 6) == 2 and (arr [i + 3] >> 6) == 2) i += 3;\\n            else return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& arr) {\\n        \\n        int n = arr.size ();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if ((arr [i] >> 7) == 0) continue;\\n            else if ((arr [i] >> 5) == 6 and i + 1 < n and (arr [i + 1] >> 6) == 2) i++;\\n            else if ((arr [i] >> 4) == 14 and i + 2 < n and (arr [i + 1] >> 6) == 2 and (arr [i + 2] >> 6) == 2) i += 2;\\n            else if ((arr [i] >> 3) == 30 and i + 3 < n and (arr [i + 1] >> 6) == 2 and (arr [i + 2] >> 6) == 2 and (arr [i + 3] >> 6) == 2) i += 3;\\n            else return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570682,
                "title": "utf-8-validation-bit-manipulation-java-solution",
                "content": "* Time Complexity: O(n)\\n* Space Complexity: O(1)\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int remainingBytes = 0;\\n        \\n        for(int val : data) {\\n            if(remainingBytes == 0) {\\n                if((val >> 7) == 0b0) {\\n                    remainingBytes = 0;    \\n                } else if((val >> 5) == 0b110) {\\n                    remainingBytes = 1;       \\n                } else if((val >> 4) == 0b1110) {\\n                    remainingBytes = 2;\\n                } else if((val >> 3) == 0b11110) {\\n                    remainingBytes = 3;   \\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                if((val >> 6) == 0b10) {\\n                    remainingBytes--;    \\n                } else {\\n                    return false;\\n                }\\n            }\\n        }     \\n        \\n        if(remainingBytes != 0) {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int remainingBytes = 0;\\n        \\n        for(int val : data) {\\n            if(remainingBytes == 0) {\\n                if((val >> 7) == 0b0) {\\n                    remainingBytes = 0;    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2570651,
                "title": "c-easy-solution",
                "content": "**C++ Code:**\\n\\n```\\n bool validUtf8(vector<int>& data) {\\n        int rbytes = 0;\\n        for(int i=0;i<data.size();i++){\\n            if(rbytes==0){\\n            if((data[i]>>5)==0b110) rbytes=1; // for 2 no of Bytes\\n            else if((data[i]>>4)==0b1110) rbytes=2; // For 3 no of Bytes\\n            else if((data[i]>>3)==0b11110) rbytes=3; // for 4 no of Bytes\\n            else if((data[i]>>7)) return false;      // for 1 no of Bytes\\n           }\\n           else{\\n              if((data[i]>>6)!=0b10) return false;\\n                  rbytes--;\\n           }\\n        }\\n     return rbytes==0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n bool validUtf8(vector<int>& data) {\\n        int rbytes = 0;\\n        for(int i=0;i<data.size();i++){\\n            if(rbytes==0){\\n            if((data[i]>>5)==0b110) rbytes=1; // for 2 no of Bytes\\n            else if((data[i]>>4)==0b1110) rbytes=2; // For 3 no of Bytes\\n            else if((data[i]>>3)==0b11110) rbytes=3; // for 4 no of Bytes\\n            else if((data[i]>>7)) return false;      // for 1 no of Bytes\\n           }\\n           else{\\n              if((data[i]>>6)!=0b10) return false;\\n                  rbytes--;\\n           }\\n        }\\n     return rbytes==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570596,
                "title": "c-use-bit-manipulation",
                "content": "class Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n     int rbyte=0;\\n    for(int val:data){\\n        if(rbyte==0) {\\n            if((val>>7)==0b0){rbyte=0; }\\n            else if((val>>5)==0b110) { rbyte=1;}\\n            else if((val>>4)==0b1110){ rbyte=2; }\\n            else if((val>>3)==0b11110){rbyte=3;}\\n            else {return false; }\\n        }\\n        else\\n        {\\n            if((val>>6)==0b10) {rbyte--;}\\n            else{  return false; }\\n        }\\n    }\\n       \\n       if(rbyte==0) {return true;}\\n        else { return false;}\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n     int rbyte=0;\\n    for(int val:data){\\n        if(rbyte==0) {\\n            if((val>>7)==0b0){rbyte=0; }",
                "codeTag": "Java"
            },
            {
                "id": 2570345,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\n\\n    bool validUtf8(vector<int>& data) { \\n        int i=0;\\n        int n= data.size();\\n        while (i<n){\\n            if (data[i] >=248) return false;\\n            if ( data[i]>=240 &&data[i]<=247 ) {\\n                if (i+3>n) return false;\\n                if ((data[i+1] <128 || data[i+1] >191)|| (data[i+2] <128 || data[i+2] >191)||(data[i+3] <128 || data[i+3] >191)) return false;\\n              i+=4;  \\n            }\\n            else if ( data[i]>=224 &&data[i]<=239 ) {\\n\\n                if (i+2>n) return false ;\\n                if ((data[i+1] <128 || data[i+1] >191)||(data[i+2] <128 || data[i+2] >191)) return false;\\n\\n              i+=3;  \\n\\n            }\\n            else if (( data[i]>=192 &&data[i]<=233 )) {\\n\\n                if (i+1>n) return false;\\n                if ((data[i+1] <128  || data[i+1] >191)) return false;\\n\\n              i+=2;  \\n\\n            }\\n           else if ( data[i]<=127 ) {\\n\\n                \\n\\n              i+=1;  \\n\\n            }\\n            else return false;\\n        \\n        }\\n\\n \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n\\n    bool validUtf8(vector<int>& data) { \\n        int i=0;\\n        int n= data.size();\\n        while (i<n){\\n            if (data[i] >=248) return false;\\n            if ( data[i]>=240 &&data[i]<=247 ) {\\n                if (i+3>n) return false;\\n                if ((data[i+1] <128 || data[i+1] >191)|| (data[i+2] <128 || data[i+2] >191)||(data[i+3] <128 || data[i+3] >191)) return false;\\n              i+=4;  \\n            }\\n            else if ( data[i]>=224 &&data[i]<=239 ) {\\n\\n                if (i+2>n) return false ;\\n                if ((data[i+1] <128 || data[i+1] >191)||(data[i+2] <128 || data[i+2] >191)) return false;\\n\\n              i+=3;  \\n\\n            }\\n            else if (( data[i]>=192 &&data[i]<=233 )) {\\n\\n                if (i+1>n) return false;\\n                if ((data[i+1] <128  || data[i+1] >191)) return false;\\n\\n              i+=2;  \\n\\n            }\\n           else if ( data[i]<=127 ) {\\n\\n                \\n\\n              i+=1;  \\n\\n            }\\n            else return false;\\n        \\n        }\\n\\n \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570329,
                "title": "cool-walkthrough-of-the-question-with-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findOnes(string &t){//1\\n        int cnt=0;\\n        for(int i=0;i<8 and t[i]!=\\'0\\';i++){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        vector<string> check; \\n        for(auto v: data){  //4\\n            string temp=\"\";\\n            for(int i=0;i<8;i++){\\n                if(v&(1<<i)){\\n                    temp.push_back(\\'1\\');\\n                }\\n                else temp.push_back(\\'0\\');\\n            }\\n            reverse(temp.begin(),temp.end());\\n            check.push_back(temp);\\n        }\\n        \\n        // for(auto v:  check) cout<<v<<\" \";\\n        //encoding done of 8-LSB\\n        \\n        int i=0, sz=check.size();\\n        while(i<sz){\\n            int cnt = findOnes(check[i]);\\n            if(cnt>=2 and cnt<=4){ //5\\n                int j=cnt-1;\\n                if(i+j>=sz) return false;  //6\\n                int k=1;\\n                while(k<=j){//8\\n                    int ones=findOnes(check[i+k]);\\n                    if(ones!=1) return false; //7\\n                    k++;\\n                }\\n                i+=cnt;\\n            }\\n            else if(cnt!=0) return false;  //2\\n            else i++; //3\\n        }\\n        \\n        return true;\\n    }\\n};\\n/*\\n\\na/q:- \\n\\nwe need to consider only the least significant 8 bits of each number. (8-LSB) (UTF-8 encoding)\\n\\nthere must be atmost 4 bytes numbers. \\n\\nno. of continous 1(s) from MSB in its UTF-8 encoding is the no. of bytes.\\n\\nso if cnt=2, its a 2 byte number. if cnt=3, its a 3 byte number and so on.\\n\\nfor cnt=0, its a 1 byte numbers a/q.\\n\\nif more than 4bytes then its not a valid encoding. \\n\\n\\nfor 1 byte: cnt will be 0. \\nfor 2 byte: cnt=2, and next numbers should be only containing cnt as 1.\\nfor 3 byte: cnt=3, and next 2 numbers should be only containing cnt as 1.\\nfor 4 byte: cnt=4, and next 3 numbers should be only containing cnt as 1.\\n\\n\\n//1: returns the cnt of continuous 1(s) starting from the MSB of the number.\\n\\n//2: for numbers > 4 bytes like: (255: 11111111 or any number with form as 11111000 or more value of cnt), we straight away return false.\\n\\n//3: when its a 1 byte no. we just do i++, and go to the next number. (cnt=0)\\n\\n//4: we make the 8-LSB of each number. On these numbers validation would be done.\\n\\n//5: for 2,3 and 4 bytes numbers. for 2 bytes number we check for the next 1 number (it should be 10xxxxxx (cnt=1) format). for 3 bytes number(cnt=3) , next 2 numbers must be of the 10xxxxxx (cnt=1) format. and for 4 bytes number (cnt=4) , next 3 numbers must be of the 10xxxxxx (cnt=1) format.\\n\\n//7: there isnt a number of the format 10xxxxxx after n-byte number.\\n\\n//8: checking next cnt-1 numbers. they must be of the form : 10xxxxxx (cnt=1)\\n\\n//6: there are not enough 10xxxxxx numbers after the n-byte number. so we return false.\\n\\n\\n*/\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findOnes(string &t){//1\\n        int cnt=0;\\n        for(int i=0;i<8 and t[i]!=\\'0\\';i++){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        vector<string> check; \\n        for(auto v: data){  //4\\n            string temp=\"\";\\n            for(int i=0;i<8;i++){\\n                if(v&(1<<i)){\\n                    temp.push_back(\\'1\\');\\n                }\\n                else temp.push_back(\\'0\\');\\n            }\\n            reverse(temp.begin(),temp.end());\\n            check.push_back(temp);\\n        }\\n        \\n        // for(auto v:  check) cout<<v<<\" \";\\n        //encoding done of 8-LSB\\n        \\n        int i=0, sz=check.size();\\n        while(i<sz){\\n            int cnt = findOnes(check[i]);\\n            if(cnt>=2 and cnt<=4){ //5\\n                int j=cnt-1;\\n                if(i+j>=sz) return false;  //6\\n                int k=1;\\n                while(k<=j){//8\\n                    int ones=findOnes(check[i+k]);\\n                    if(ones!=1) return false; //7\\n                    k++;\\n                }\\n                i+=cnt;\\n            }\\n            else if(cnt!=0) return false;  //2\\n            else i++; //3\\n        }\\n        \\n        return true;\\n    }\\n};\\n/*\\n\\na/q:- \\n\\nwe need to consider only the least significant 8 bits of each number. (8-LSB) (UTF-8 encoding)\\n\\nthere must be atmost 4 bytes numbers. \\n\\nno. of continous 1(s) from MSB in its UTF-8 encoding is the no. of bytes.\\n\\nso if cnt=2, its a 2 byte number. if cnt=3, its a 3 byte number and so on.\\n\\nfor cnt=0, its a 1 byte numbers a/q.\\n\\nif more than 4bytes then its not a valid encoding. \\n\\n\\nfor 1 byte: cnt will be 0. \\nfor 2 byte: cnt=2, and next numbers should be only containing cnt as 1.\\nfor 3 byte: cnt=3, and next 2 numbers should be only containing cnt as 1.\\nfor 4 byte: cnt=4, and next 3 numbers should be only containing cnt as 1.\\n\\n\\n//1: returns the cnt of continuous 1(s) starting from the MSB of the number.\\n\\n//2: for numbers > 4 bytes like: (255: 11111111 or any number with form as 11111000 or more value of cnt), we straight away return false.\\n\\n//3: when its a 1 byte no. we just do i++, and go to the next number. (cnt=0)\\n\\n//4: we make the 8-LSB of each number. On these numbers validation would be done.\\n\\n//5: for 2,3 and 4 bytes numbers. for 2 bytes number we check for the next 1 number (it should be 10xxxxxx (cnt=1) format). for 3 bytes number(cnt=3) , next 2 numbers must be of the 10xxxxxx (cnt=1) format. and for 4 bytes number (cnt=4) , next 3 numbers must be of the 10xxxxxx (cnt=1) format.\\n\\n//7: there isnt a number of the format 10xxxxxx after n-byte number.\\n\\n//8: checking next cnt-1 numbers. they must be of the form : 10xxxxxx (cnt=1)\\n\\n//6: there are not enough 10xxxxxx numbers after the n-byte number. so we return false.\\n\\n\\n*/\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2570318,
                "title": "javascript-dfs",
                "content": "```\\nvar validUtf8 = function(data) {\\n    const n = data.length;\\n\\n    const calculateSetMsbs = (num) => {\\n        let i = 7;\\n        let setMsbs = 0;\\n\\n        while(i >= 0) {\\n            if(((1 << i) & num) === 0) break;\\n            setMsbs += 1;\\n            i -= 1;\\n        }\\n\\n        return setMsbs;\\n    }\\n\\n    const msbs = [];\\n    for(let i = 0; i < n; i += 1) {\\n        const setMsbs = calculateSetMsbs(data[i]);\\n        msbs.push(setMsbs);\\n    }\\n\\n    const dfs = (i = 0) => {\\n        if(i === n) return true;\\n\\n        const setMsbs = msbs[i];\\n        if(setMsbs === 0) {\\n            return dfs(i + 1);\\n        }\\n        if(setMsbs === 2) {\\n            return i + 1 < n && msbs[i + 1] === 1 && dfs(i + 2);\\n        }\\n        if(setMsbs === 3) {\\n            return i + 2 < n && msbs[i + 1] === 1 && msbs[i + 2] === 1 && dfs(i + 3);\\n        }\\n        if(setMsbs === 4) {\\n            return i + 3 < n && msbs[i + 1] === 1 && msbs[i + 2] === 1 && msbs[i + 3] === 1 && dfs(i + 4);\\n        }\\n\\n        return false;\\n    }\\n\\n    return dfs();\\n};\\n```\\nRuntime: O(n)\\nSpace: O(n)",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar validUtf8 = function(data) {\\n    const n = data.length;\\n\\n    const calculateSetMsbs = (num) => {\\n        let i = 7;\\n        let setMsbs = 0;\\n\\n        while(i >= 0) {\\n            if(((1 << i) & num) === 0) break;\\n            setMsbs += 1;\\n            i -= 1;\\n        }\\n\\n        return setMsbs;\\n    }\\n\\n    const msbs = [];\\n    for(let i = 0; i < n; i += 1) {\\n        const setMsbs = calculateSetMsbs(data[i]);\\n        msbs.push(setMsbs);\\n    }\\n\\n    const dfs = (i = 0) => {\\n        if(i === n) return true;\\n\\n        const setMsbs = msbs[i];\\n        if(setMsbs === 0) {\\n            return dfs(i + 1);\\n        }\\n        if(setMsbs === 2) {\\n            return i + 1 < n && msbs[i + 1] === 1 && dfs(i + 2);\\n        }\\n        if(setMsbs === 3) {\\n            return i + 2 < n && msbs[i + 1] === 1 && msbs[i + 2] === 1 && dfs(i + 3);\\n        }\\n        if(setMsbs === 4) {\\n            return i + 3 < n && msbs[i + 1] === 1 && msbs[i + 2] === 1 && msbs[i + 3] === 1 && dfs(i + 4);\\n        }\\n\\n        return false;\\n    }\\n\\n    return dfs();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570272,
                "title": "python3-regular-expression",
                "content": "We can use the power of standard library here. Just convert input into a string and match with a regular expression. Each element of the list L represents one of 4 possible encodigs. Then we combine them and add \"+\" symbol as our input must contain at least one Unicode character. \\n\\n```\\nimport re\\nclass Solution:\\n    def __init__(self):\\n        L = [\"0b(0|1[01]{0,6})\",\\n            \"0b110.....(0b10......)\",\\n            \"0b1110....(0b10......){2}\",\\n            \"0b11110...(0b10......){3}\" ]\\n        regexp = \"(\" + \\\\\\n            (\"|\".join(L)) + \\\\\\n            \")+\" \\n        self.R = re.compile(regexp)\\n        \\n    def validUtf8(self, data: List[int]) -> bool:\\n        return bool(re.fullmatch(self.R, \"\".join(map(bin, data))))\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nclass Solution:\\n    def __init__(self):\\n        L = [\"0b(0|1[01]{0,6})\",\\n            \"0b110.....(0b10......)\",\\n            \"0b1110....(0b10......){2}\",\\n            \"0b11110...(0b10......){3}\" ]\\n        regexp = \"(\" + \\\\\\n            (\"|\".join(L)) + \\\\\\n            \")+\" \\n        self.R = re.compile(regexp)\\n        \\n    def validUtf8(self, data: List[int]) -> bool:\\n        return bool(re.fullmatch(self.R, \"\".join(map(bin, data))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570255,
                "title": "bit-manipulation-java",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbyte=0;\\n        for(int num:data)\\n        {\\n            if(rbyte==0){\\n                if(num >> 7 == 0b0) rbyte=0;\\n                else if(num >> 5 ==0b110) rbyte=1;\\n                else if(num >> 4 == 0b1110) rbyte=2;\\n                else if(num >> 3 == 0b11110) rbyte=3;\\n                else return false;\\n            }\\n            else {\\n                if(num >> 6 ==0b10) rbyte--;\\n                else return false;\\n            }\\n        }\\n        if(rbyte>0) return false;\\n        return true;\\n        \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbyte=0;\\n        for(int num:data)\\n        {\\n            if(rbyte==0){\\n                if(num >> 7 == 0b0) rbyte=0;\\n                else if(num >> 5 ==0b110) rbyte=1;\\n                else if(num >> 4 == 0b1110) rbyte=2;\\n                else if(num >> 3 == 0b11110) rbyte=3;\\n                else return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2570186,
                "title": "c-easy-solution-with-function-helper",
                "content": "```\\nclass Solution {\\npublic:\\n    // return number of bytes need to be proccesed (for example: for 4 bytes return 3), -1 on error;\\n    int parse_first_byte(int byte) {\\n        if ((byte >> 7) == 0) { // if mask is 0xxxxxxx\\n            return 0;\\n        } else if ((byte >> 5) == 6) { // if mask is 110xxxxx\\n            return 1;\\n        } else if ((byte >> 4) == 14) { // if mask is 1110xxxx\\n            return 2;\\n        } else if ((byte >> 3) == 30) { // if mask is 11110xxx\\n            return 3;\\n        } \\n        return -1;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int need_to_process{};\\n        for (int i = 0; i < data.size(); ++i) {\\n            if (need_to_process == 0) {\\n                need_to_process = parse_first_byte(data[i]);\\n                // Check how many bytes we need to process, if there are no available data or error: return false\\n                if ((need_to_process == -1) || (data.size() - i < need_to_process)) {\\n                    return false;\\n                }\\n            } else {\\n                // if we check n-bytes and it is doesn\\'t match 10xxxxxx mask, return error\\n                if ((data[i] >> 6) != 2) {\\n                    return false;\\n                } else {\\n                    --need_to_process;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // return number of bytes need to be proccesed (for example: for 4 bytes return 3), -1 on error;\\n    int parse_first_byte(int byte) {\\n        if ((byte >> 7) == 0) { // if mask is 0xxxxxxx\\n            return 0;\\n        } else if ((byte >> 5) == 6) { // if mask is 110xxxxx\\n            return 1;\\n        } else if ((byte >> 4) == 14) { // if mask is 1110xxxx\\n            return 2;\\n        } else if ((byte >> 3) == 30) { // if mask is 11110xxx\\n            return 3;\\n        } \\n        return -1;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int need_to_process{};\\n        for (int i = 0; i < data.size(); ++i) {\\n            if (need_to_process == 0) {\\n                need_to_process = parse_first_byte(data[i]);\\n                // Check how many bytes we need to process, if there are no available data or error: return false\\n                if ((need_to_process == -1) || (data.size() - i < need_to_process)) {\\n                    return false;\\n                }\\n            } else {\\n                // if we check n-bytes and it is doesn\\'t match 10xxxxxx mask, return error\\n                if ((data[i] >> 6) != 2) {\\n                    return false;\\n                } else {\\n                    --need_to_process;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569942,
                "title": "java-solution-bit-manipulation-easy",
                "content": "### Please Upvote !!!\\n```\\n/*\\n    1 byte = 8 bits\\n    ---------------\\n\\n     Number of Bytes   |        UTF-8 Octet Sequence\\n                       |              (binary)\\n     ------------------+-----------------------------------------\\n a)         1          |   0xxxxxxx\\n b)         2          |   110xxxxx 10xxxxxx\\n c)         3          |   1110xxxx 10xxxxxx 10xxxxxx\\n d)         4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n                           |______| |_______|________|________|\\n                           1st Byte       Remaining Bytes\\n*/\\n\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int remBytes = 0;   // Remaining bytes after the 1st byte\\n\\n        for (int n : data) {\\n\\n            if (remBytes == 0) {\\n                if (n >> 7 == 0b0) remBytes = 0;            // 1st byte of 1 length char (a)\\n                else if (n >> 5 == 0b110) remBytes = 1;     // 1st byte of 2 length char (b)\\n                else if (n >> 4 == 0b1110) remBytes = 2;    // 1st byte of 3 length char (c)\\n                else if (n >> 3 == 0b11110) remBytes = 3;   // 1st byte of 4 length char (d)\\n                else return false;                          // NOTA\\n\\n            } else {                                        // if more than 1 byte, we check if the rest start with 10\\n                if (n >> 6 == 0b10) remBytes--;             // if yes, we decrease remaining bytes\\n                else return false;                          // If not, sequence not valid\\n            }\\n        }\\n\\n        return remBytes == 0;       // At the end if there are no remening bytes, sequence is valid.\\n    }\\n}\\n\\n// TC: O(n) -> We iterate over the array\\n// SC: O(1) -> No extra space used\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n    1 byte = 8 bits\\n    ---------------\\n\\n     Number of Bytes   |        UTF-8 Octet Sequence\\n                       |              (binary)\\n     ------------------+-----------------------------------------\\n a)         1          |   0xxxxxxx\\n b)         2          |   110xxxxx 10xxxxxx\\n c)         3          |   1110xxxx 10xxxxxx 10xxxxxx\\n d)         4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n                           |______| |_______|________|________|\\n                           1st Byte       Remaining Bytes\\n*/\\n\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int remBytes = 0;   // Remaining bytes after the 1st byte\\n\\n        for (int n : data) {\\n\\n            if (remBytes == 0) {\\n                if (n >> 7 == 0b0) remBytes = 0;            // 1st byte of 1 length char (a)\\n                else if (n >> 5 == 0b110) remBytes = 1;     // 1st byte of 2 length char (b)\\n                else if (n >> 4 == 0b1110) remBytes = 2;    // 1st byte of 3 length char (c)\\n                else if (n >> 3 == 0b11110) remBytes = 3;   // 1st byte of 4 length char (d)\\n                else return false;                          // NOTA\\n\\n            } else {                                        // if more than 1 byte, we check if the rest start with 10\\n                if (n >> 6 == 0b10) remBytes--;             // if yes, we decrease remaining bytes\\n                else return false;                          // If not, sequence not valid\\n            }\\n        }\\n\\n        return remBytes == 0;       // At the end if there are no remening bytes, sequence is valid.\\n    }\\n}\\n\\n// TC: O(n) -> We iterate over the array\\n// SC: O(1) -> No extra space used\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569904,
                "title": "rust-finite-state-machine",
                "content": "```rust\\n#[derive(Copy, Clone, Eq, PartialEq)]\\nenum State {\\n    NoExpectation,\\n    ExpectOneMore,\\n    ExpectTwoMore,\\n    ExpectThreeMore,\\n    Error,\\n}\\n\\nimpl State {\\n    fn is_valid(self) -> bool {\\n        match self {\\n            State::NoExpectation => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn next(self, b: u8) -> Self {\\n        match self {\\n            State::NoExpectation => on_no_expectation(b),\\n            State::ExpectOneMore => on_one_more(b),\\n            State::ExpectTwoMore => on_two_more(b),\\n            State::ExpectThreeMore => on_three_more(b),\\n            State::Error => State::Error,\\n        }\\n    }\\n}\\nfn on_no_expectation(b: u8) -> State {\\n    if b & 0b1000_0000 == 0 {\\n        State::NoExpectation\\n    } else if b & 0b1110_0000 == 0b1100_0000 {\\n        State::ExpectOneMore\\n    } else if b & 0b1111_0000 == 0b1110_0000 {\\n        State::ExpectTwoMore\\n    } else if b & 0b1111_1000 == 0b1111_0000 {\\n        State::ExpectThreeMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_one_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::NoExpectation\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_two_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::ExpectOneMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_three_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::ExpectTwoMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\npub fn valid_utf8(data: impl AsRef<[i32]>) -> bool {\\n    let data = data.as_ref();\\n    let mut state = State::NoExpectation;\\n\\n    for b in data.iter().map(|&i| i as u8) {\\n        state = state.next(b);\\n        if state == State::Error {\\n            break;\\n        }\\n    }\\n\\n    state.is_valid()\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n#[derive(Copy, Clone, Eq, PartialEq)]\\nenum State {\\n    NoExpectation,\\n    ExpectOneMore,\\n    ExpectTwoMore,\\n    ExpectThreeMore,\\n    Error,\\n}\\n\\nimpl State {\\n    fn is_valid(self) -> bool {\\n        match self {\\n            State::NoExpectation => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn next(self, b: u8) -> Self {\\n        match self {\\n            State::NoExpectation => on_no_expectation(b),\\n            State::ExpectOneMore => on_one_more(b),\\n            State::ExpectTwoMore => on_two_more(b),\\n            State::ExpectThreeMore => on_three_more(b),\\n            State::Error => State::Error,\\n        }\\n    }\\n}\\nfn on_no_expectation(b: u8) -> State {\\n    if b & 0b1000_0000 == 0 {\\n        State::NoExpectation\\n    } else if b & 0b1110_0000 == 0b1100_0000 {\\n        State::ExpectOneMore\\n    } else if b & 0b1111_0000 == 0b1110_0000 {\\n        State::ExpectTwoMore\\n    } else if b & 0b1111_1000 == 0b1111_0000 {\\n        State::ExpectThreeMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_one_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::NoExpectation\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_two_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::ExpectOneMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\nfn on_three_more(b: u8) -> State {\\n    if b & 0b1100_0000 == 0b1000_0000 {\\n        State::ExpectTwoMore\\n    } else {\\n        State::Error\\n    }\\n}\\n\\npub fn valid_utf8(data: impl AsRef<[i32]>) -> bool {\\n    let data = data.as_ref();\\n    let mut state = State::NoExpectation;\\n\\n    for b in data.iter().map(|&i| i as u8) {\\n        state = state.next(b);\\n        if state == State::Error {\\n            break;\\n        }\\n    }\\n\\n    state.is_valid()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569828,
                "title": "bit-manipulation-java",
                "content": "```\\n public boolean validUtf8(int[] data) {\\n        if(data==null || data.length==0) return false;\\n\\tboolean isValid = true;\\n\\tfor(int i=0;i<data.length;i++) {\\n\\t\\tif(data[i]>255) return false; // 1 after 8th digit, 100000000\\n\\t\\tint numberOfBytes = 0;\\n\\t\\tif((data[i] & 128) == 0) { // 0xxxxxxx, 1 byte, 128(10000000)\\n\\t\\t\\tnumberOfBytes = 1;\\n\\t\\t} else if((data[i] & 224) == 192) { // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\\n\\t\\t\\tnumberOfBytes = 2;\\n\\t\\t} else if((data[i] & 240) == 224) { // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\\n\\t\\t\\tnumberOfBytes = 3;\\n\\t\\t} else if((data[i] & 248) == 240) { // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\\n\\t\\t\\tnumberOfBytes = 4;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int j=1;j<numberOfBytes;j++) { // check that the next n bytes start with 10xxxxxx\\n\\t\\t\\tif(i+j>=data.length) return false;\\n\\t\\t\\tif((data[i+j] & 192) != 128) return false; // 192(11000000), 128(10000000)\\n\\t\\t}\\n\\t\\ti=i+numberOfBytes-1;\\n\\t}\\n\\treturn isValid;\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n public boolean validUtf8(int[] data) {\\n        if(data==null || data.length==0) return false;\\n\\tboolean isValid = true;\\n\\tfor(int i=0;i<data.length;i++) {\\n\\t\\tif(data[i]>255) return false; // 1 after 8th digit, 100000000\\n\\t\\tint numberOfBytes = 0;\\n\\t\\tif((data[i] & 128) == 0) { // 0xxxxxxx, 1 byte, 128(10000000)\\n\\t\\t\\tnumberOfBytes = 1;\\n\\t\\t} else if((data[i] & 224) == 192) { // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\\n\\t\\t\\tnumberOfBytes = 2;\\n\\t\\t} else if((data[i] & 240) == 224) { // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\\n\\t\\t\\tnumberOfBytes = 3;\\n\\t\\t} else if((data[i] & 248) == 240) { // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\\n\\t\\t\\tnumberOfBytes = 4;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int j=1;j<numberOfBytes;j++) { // check that the next n bytes start with 10xxxxxx\\n\\t\\t\\tif(i+j>=data.length) return false;\\n\\t\\t\\tif((data[i+j] & 192) != 128) return false; // 192(11000000), 128(10000000)\\n\\t\\t}\\n\\t\\ti=i+numberOfBytes-1;\\n\\t}\\n\\treturn isValid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569769,
                "title": "simple-python-solution-o-n-complexity",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        l = []\\n        \\n        for i in range(len(data)):\\n            l.append(bin(data[i])[2:])\\n            if(len(l[i]) < 8):\\n                l[i] = \\'0\\'*(8-len(l[i]))+l[i]\\n        curr = 0\\n        byte = 0\\n        flag = True\\n        for i in range(len(l)):\\n            if(byte == 0):\\n                j = 0\\n                while(j < len(l[i]) and l[i][j] == \\'1\\'):\\n                    byte +=1\\n                    j += 1\\n                flag = True\\n            elif(byte > 0):\\n                if(flag):\\n                    byte -= 1\\n                    flag = False\\n                if l[i][:2] != \\'10\\':\\n                    return False\\n                byte -= 1\\n            if byte > 4:\\n                return False\\n        if(byte > 0 and len(l) == 1):\\n            return False\\n        if(byte > 0):\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        l = []\\n        \\n        for i in range(len(data)):\\n            l.append(bin(data[i])[2:])\\n            if(len(l[i]) < 8):\\n                l[i] = \\'0\\'*(8-len(l[i]))+l[i]\\n        curr = 0\\n        byte = 0\\n        flag = True\\n        for i in range(len(l)):\\n            if(byte == 0):\\n                j = 0\\n                while(j < len(l[i]) and l[i][j] == \\'1\\'):\\n                    byte +=1\\n                    j += 1\\n                flag = True\\n            elif(byte > 0):\\n                if(flag):\\n                    byte -= 1\\n                    flag = False\\n                if l[i][:2] != \\'10\\':\\n                    return False\\n                byte -= 1\\n            if byte > 4:\\n                return False\\n        if(byte > 0 and len(l) == 1):\\n            return False\\n        if(byte > 0):\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569712,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int remaining = 0;\\n        for (auto& x : data) {\\n            if (remaining == 0) {\\n                if ((x >> 5) == 0b110) {\\n                    remaining = 1;\\n                } \\n                else if ((x >> 4) == 0b1110) {\\n                     remaining = 2;\\n                } \\n                else if ((x >> 3) == 0b11110) {\\n                    remaining = 3;\\n                } \\n                else if ((x >> 7) != 0) {\\n                    return false;\\n                }\\n            } \\n            else {\\n                if ((x >> 6) != 0b10) {\\n                    return false;\\n                }\\n                else {\\n                    remaining--;\\n                }\\n            }\\n        }\\n        return remaining == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int remaining = 0;\\n        for (auto& x : data) {\\n            if (remaining == 0) {\\n                if ((x >> 5) == 0b110) {\\n                    remaining = 1;\\n                } \\n                else if ((x >> 4) == 0b1110) {\\n                     remaining = 2;\\n                } \\n                else if ((x >> 3) == 0b11110) {\\n                    remaining = 3;\\n                } \\n                else if ((x >> 7) != 0) {\\n                    return false;\\n                }\\n            } \\n            else {\\n                if ((x >> 6) != 0b10) {\\n                    return false;\\n                }\\n                else {\\n                    remaining--;\\n                }\\n            }\\n        }\\n        return remaining == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569685,
                "title": "this-is-a-problem-where-c-language-shines-c-o-n",
                "content": "Lets check UTF8 encoding character by character. The steps are simple.\\n1. Find how many bytes does current character contain\\n2. Check character content (continuation marks 0x10xxxxxx)\\n\\n```\\n#define UPPER_1BIT  0x80\\n#define UPPER_2BITS 0xC0\\n#define UPPER_3BITS 0xE0\\n#define UPPER_4BITS 0xF0\\n#define UPPER_5BITS 0xF8\\n\\n#define UTF8_1BYTE_MASK         0x00\\n#define UTF8_2BYTE_MASK         0xC0\\n#define UTF8_3BYTE_MASK         0xE0\\n#define UTF8_4BYTE_MASK         0xF0\\n#define UTF8_CONTINUATION_MASK  0x80\\n\\n#define CHECK_MASK(val, bitmask, target) (((val) & (bitmask)) == (target))\\n\\n\\nbool validUtf8(int* data, int dataSize)\\n{\\n    while(dataSize > 0) {\\n        if(CHECK_MASK(data[0], UPPER_1BIT, UTF8_1BYTE_MASK)) {\\n            data++, dataSize--;\\n        } else if(CHECK_MASK(data[0], UPPER_3BITS, UTF8_2BYTE_MASK)) {\\n            if(dataSize < 2)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 2, dataSize -= 2;\\n        } else if(CHECK_MASK(data[0], UPPER_4BITS, UTF8_3BYTE_MASK)) {\\n            if(dataSize < 3)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[2], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 3, dataSize -= 3;\\n        } else if(CHECK_MASK(data[0], UPPER_5BITS, UTF8_4BYTE_MASK)) {\\n            if(dataSize < 4)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[2], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[3], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 4, dataSize -= 4;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define UPPER_1BIT  0x80\\n#define UPPER_2BITS 0xC0\\n#define UPPER_3BITS 0xE0\\n#define UPPER_4BITS 0xF0\\n#define UPPER_5BITS 0xF8\\n\\n#define UTF8_1BYTE_MASK         0x00\\n#define UTF8_2BYTE_MASK         0xC0\\n#define UTF8_3BYTE_MASK         0xE0\\n#define UTF8_4BYTE_MASK         0xF0\\n#define UTF8_CONTINUATION_MASK  0x80\\n\\n#define CHECK_MASK(val, bitmask, target) (((val) & (bitmask)) == (target))\\n\\n\\nbool validUtf8(int* data, int dataSize)\\n{\\n    while(dataSize > 0) {\\n        if(CHECK_MASK(data[0], UPPER_1BIT, UTF8_1BYTE_MASK)) {\\n            data++, dataSize--;\\n        } else if(CHECK_MASK(data[0], UPPER_3BITS, UTF8_2BYTE_MASK)) {\\n            if(dataSize < 2)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 2, dataSize -= 2;\\n        } else if(CHECK_MASK(data[0], UPPER_4BITS, UTF8_3BYTE_MASK)) {\\n            if(dataSize < 3)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[2], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 3, dataSize -= 3;\\n        } else if(CHECK_MASK(data[0], UPPER_5BITS, UTF8_4BYTE_MASK)) {\\n            if(dataSize < 4)\\n                return false;\\n            if(!CHECK_MASK(data[1], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[2], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            if(!CHECK_MASK(data[3], UPPER_2BITS, UTF8_CONTINUATION_MASK))\\n                return false;\\n            data += 4, dataSize -= 4;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569684,
                "title": "easy-explained-for-beginners-binary-conversion-java",
                "content": "class Solution {\\n\\n    public boolean validUtf8(int[] data) {\\n        int type=0,i=0;         \\n        boolean isValid = false;\\n        \\n        while(i<data.length){                                   //traverse whole given data array        \\n            if(!isValid){\\n                String s = convertToBinary(data[i]);            //function call for conversion\\n                if(s.charAt(0) == \\'0\\')                          //if OCTET seq. begin with \\'0\\' then it is type 1 (given)\\n                    type = 1;\\n                else if(s.substring(0,5).equals(\"11110\"))       //similarly check for all other types (type 4)\\n                    type = 4;\\n                else if(s.substring(0,4).equals(\"1110\"))        //Type 3\\n                    type = 3;\\n                else if(s.substring(0,3).equals(\"110\"))         //Type 2         \\n                    type = 2;\\n                else\\n                    return false;                               //if other then given respective types, return false\\n                \\n                isValid = true;                                 //if false does not return, it means beginning isValid\\n                i++;\\n                type--;\\n            }\\n            else{\\n                while(type>0){                                \\n                    String s = convertToBinary(data[i]).substring(0,2);         //check for rest of the sequence\\n                    if(!s.equals(\"10\"))                                         //if not equals to \"10\" (as given in Question)\\n                        return false;                                           //return false\\n                    \\n                    type--;\\n                    i++;\\n                }\\n                isValid = false;\\n            }\\n        }\\n        \\n        if(type != 0)               //if type is not zero, all sequence are not according to the rule & loop is not run till end.\\n            return false;           \\n        \\n        return true;            \\n    }\\n    \\n    public String convertToBinary(int x)                    //Here, we convert an int into a binary string\\n    {\\n        final char[] binary = new char[8];                  //Given OCTECT Sequence that\\'s why size = 8\\n        for (int i = 7; i >= 0 ; i--){\\n            int mask = 1 << i;\\n            binary[7 - i] = (x & mask) != 0 ? \\'1\\' : \\'0\\';\\n        }\\n \\n        return new String(binary);\\n    }\\n}\\n\\n**Feel Free to ask any doubt...!**\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean validUtf8(int[] data) {\\n        int type=0,i=0;         \\n        boolean isValid = false;\\n        \\n        while(i<data.length){                                   //traverse whole given data array        \\n            if(!isValid){\\n                String s = convertToBinary(data[i]);            //function call for conversion\\n                if(s.charAt(0) == \\'0\\')                          //if OCTET seq. begin with \\'0\\' then it is type 1 (given)\\n                    type = 1;\\n                else if(s.substring(0,5).equals(\"11110\"))       //similarly check for all other types (type 4)\\n                    type = 4;\\n                else if(s.substring(0,4).equals(\"1110\"))        //Type 3\\n                    type = 3;\\n                else if(s.substring(0,3).equals(\"110\"))         //Type 2         \\n                    type = 2;\\n                else\\n                    return false;                               //if other then given respective types, return false\\n                \\n                isValid = true;                                 //if false does not return, it means beginning isValid\\n                i++;\\n                type--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2569568,
                "title": "c-solution-time-o-n-memory-o-1-easy-to-understand-bit-manipulation",
                "content": "```C#\\npublic class Solution {\\n    public bool ValidUtf8(int[] data) {\\n        int remainingBytes = 0;\\n        for (int i = 0; i < data.Length; i++) {            \\n            int ones = 0;\\n            for (int j = 7; j >= 0; j--) {\\n                if ((data[i] & (1 << j)) == 0) break;\\n                ones++;\\n            }\\n            \\n            if (remainingBytes > 0) {\\n                if (ones != 1) return false;\\n            } else if (ones != 0) {\\n                if (ones == 1 || ones > 4) return false;\\n                remainingBytes = ones;\\n            }\\n            \\n            if (remainingBytes > 0) remainingBytes--;\\n        }\\n        \\n        return remainingBytes == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```C#\\npublic class Solution {\\n    public bool ValidUtf8(int[] data) {\\n        int remainingBytes = 0;\\n        for (int i = 0; i < data.Length; i++) {            \\n            int ones = 0;\\n            for (int j = 7; j >= 0; j--) {\\n                if ((data[i] & (1 << j)) == 0) break;\\n                ones++;\\n            }\\n            \\n            if (remainingBytes > 0) {\\n                if (ones != 1) return false;\\n            } else if (ones != 0) {\\n                if (ones == 1 || ones > 4) return false;\\n                remainingBytes = ones;\\n            }\\n            \\n            if (remainingBytes > 0) remainingBytes--;\\n        }\\n        \\n        return remainingBytes == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569556,
                "title": "c-c-intuitive-implmentation",
                "content": "```c++\\n// the limit given by the problem description\\nconst int MAX_BYTES_UTF8_CHARACTER = 4;\\n\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int> &data) {\\n        const int n = data.size();\\n        \\n        int i = 0;\\n        while (i < n) {\\n            // gets the utf-8 header\\n            // clz: count leading zeros, using as count leading ones with bitwise negate\\n            int header = __builtin_clz(~(data[i] << 24));\\n            // continuation header should not appear here\\n            if (header == 1)\\n                return false;\\n            \\n            // make header 0 (ascii characters) to be 1 byte\\n            int bytes = std::max(1, header);\\n            if (bytes > MAX_BYTES_UTF8_CHARACTER || i + bytes > n)\\n                return false;\\n            \\n            // ensure there are (bytes - 1) continuation bytes\\n            for (int j = 1; j < bytes; ++j)\\n                if ((data[i + j] >> 6) != 0b10)\\n                    return false;\\n            \\n            i += bytes;\\n        }\\n        return i == n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n// the limit given by the problem description\\nconst int MAX_BYTES_UTF8_CHARACTER = 4;\\n\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int> &data) {\\n        const int n = data.size();\\n        \\n        int i = 0;\\n        while (i < n) {\\n            // gets the utf-8 header\\n            // clz: count leading zeros, using as count leading ones with bitwise negate\\n            int header = __builtin_clz(~(data[i] << 24));\\n            // continuation header should not appear here\\n            if (header == 1)\\n                return false;\\n            \\n            // make header 0 (ascii characters) to be 1 byte\\n            int bytes = std::max(1, header);\\n            if (bytes > MAX_BYTES_UTF8_CHARACTER || i + bytes > n)\\n                return false;\\n            \\n            // ensure there are (bytes - 1) continuation bytes\\n            for (int j = 1; j < bytes; ++j)\\n                if ((data[i + j] >> 6) != 0b10)\\n                    return false;\\n            \\n            i += bytes;\\n        }\\n        return i == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569417,
                "title": "easiest-solution-without-bit-manipulation-intuition-explained-java",
                "content": "If we find binary of the decimals from 0-255 we will observe that **first MSB bits** will be **1** for **some range of values**-\\n0-127 - **0 bits**\\n127-191 -**1 bit** \\n192-223- **2 bits**\\n224-239- **3 bits**\\n240-247- **4 bits** \\n\\nAs we require till first 4 bits as 1, **any number greater than 247 will be invalid**.\\nNow if we observe, if the **starting of any utf-8 has single 1 then it is invalid i.e between 128-191**.\\n\\nSo, for 4 cases-\\n**Case 1 - 1 Byte:**\\nIf the number is **between 0-127** then it has **first bit as 0** and it is valid.\\n\\n**Case 2 - 2 Byte:**\\nIf the number is between **192-223 then it has first 2 bits as 1**. Now we need to check if *next number exists and should have 10 as MSB*. That means the next number should be between **128- 191**. If not then it is invalid string.\\n\\n**Case 3 - 3 Byte:**\\nIf the number is between **223-239 then it has first 3 bits as 1**. Now we need to check if next *2 numbers exist and  should have 10 as MSB*. That means they should be between **128-191**.\\n\\n**Case 4- 4 Byte:**\\nIf the number is between **240-247 then it has first 4 bits as 1**. Now we need to check if next *3 numbers exist and  should have 10 as MSB*. That means they should be between **128-191**.\\n\\nIf any of the case becomes false then it is not invalid otherwise it is valid UTF-8\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int i=0;\\n        while(i < data.length)\\n        {\\n            int cnt = 0;\\n            if(data[i] >= 0 && data[i] <= 127)\\n                cnt = 1;\\n            else if(data[i] >= 192 && data[i] <= 223)\\n                cnt = 2;\\n            else if(data[i] >= 223 && data[i] <= 239)\\n                cnt = 3;\\n            else if(data[i] >= 240 && data[i] <= 247)\\n                cnt = 4;\\n            else\\n                cnt = 5;\\n            if(cnt == 5) return false;\\n            if(data.length - i < cnt - 1) return false;\\n            i++;\\n            while(i < data.length && cnt - 1 > 0)\\n            {\\n                if(data[i] <= 127 || data[i] >= 192)\\n                    return false;\\n                cnt--;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int i=0;\\n        while(i < data.length)\\n        {\\n            int cnt = 0;\\n            if(data[i] >= 0 && data[i] <= 127)\\n                cnt = 1;\\n            else if(data[i] >= 192 && data[i] <= 223)\\n                cnt = 2;\\n            else if(data[i] >= 223 && data[i] <= 239)\\n                cnt = 3;\\n            else if(data[i] >= 240 && data[i] <= 247)\\n                cnt = 4;\\n            else\\n                cnt = 5;\\n            if(cnt == 5) return false;\\n            if(data.length - i < cnt - 1) return false;\\n            i++;\\n            while(i < data.length && cnt - 1 > 0)\\n            {\\n                if(data[i] <= 127 || data[i] >= 192)\\n                    return false;\\n                cnt--;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569361,
                "title": "easy-sol-using-simple-math",
                "content": "bool validUtf8(vector<int>& data) {\\n        \\n        int n=data.size();\\n        int flag=0;\\n        for(int i=0;i<n;i++)\\n        { \\n            if(flag)\\n            { \\n                if(data[i]>=128 and data[i]<=191)\\n                {\\n                    flag--;\\n                    continue;\\n                }\\n                return false;\\n            }\\n            else if(data[i]<=127)\\n            {\\n                continue;\\n            }\\n            else if(data[i]>=192 and data[i]<=223)\\n            {\\n                flag=1;\\n            }\\n            else if(data[i]>=224 and data[i]<=239)\\n            {\\n                flag=2;\\n            }\\n             else if(data[i]>=240 and data[i]<=247)\\n            {\\n                flag=3;\\n            }\\n            else\\n            {\\n            return false;\\n            }\\n        }\\n        if(flag){return false;}\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "bool validUtf8(vector<int>& data) {\\n        \\n        int n=data.size();\\n        int flag=0;\\n        for(int i=0;i<n;i++)\\n        { \\n            if(flag)\\n            { \\n                if(data[i]>=128 and data[i]<=191)\\n                {\\n                    flag--;\\n                    continue;\\n                }\\n                return false;\\n            }\\n            else if(data[i]<=127)\\n            {\\n                continue;\\n            }\\n            else if(data[i]>=192 and data[i]<=223)\\n            {\\n                flag=1;\\n            }\\n            else if(data[i]>=224 and data[i]<=239)\\n            {\\n                flag=2;\\n            }\\n             else if(data[i]>=240 and data[i]<=247)\\n            {\\n                flag=3;\\n            }\\n            else\\n            {\\n            return false;\\n            }\\n        }\\n        if(flag){return false;}\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2569330,
                "title": "c-easy-to-understand-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string toBinary(int& num){\\n        string s = \"\";\\n        while(num){\\n            s += to_string(num%2);\\n            num /= 2;\\n        }\\n        while(s.size()<8){\\n            s.push_back(\\'0\\');\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        vector<string> bin;\\n        for(auto it : data){\\n            bin.push_back(toBinary(it));\\n        }\\n        bool flag = true;\\n        for(int i = 0;i<bin.size();){\\n            if(bin[i].substr(0,3)==\"110\" && i+1<bin.size() && bin[i+1].substr(0,2)==\"10\"){\\n                i += 2;\\n            }\\n            else if(bin[i].substr(0,4)==\"1110\" && i+2<bin.size() && bin[i+1].substr(0,2)==\"10\" && bin[i+2].substr(0,2)==\"10\"){\\n                i += 3;\\n            }\\n            else if(bin[i].substr(0,5)==\"11110\" && i+3<bin.size() && bin[i+1].substr(0,2)==\"10\" && bin[i+2].substr(0,2)==\"10\" && bin[i+3].substr(0,2)==\"10\"){\\n                i += 4;\\n            }\\n            else if(bin[i][0]==\\'0\\'){\\n                i++;\\n            }\\n            else{\\n                flag = false;\\n                break;\\n            }\\n        }        \\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string toBinary(int& num){\\n        string s = \"\";\\n        while(num){\\n            s += to_string(num%2);\\n            num /= 2;\\n        }\\n        while(s.size()<8){\\n            s.push_back(\\'0\\');\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        vector<string> bin;\\n        for(auto it : data){\\n            bin.push_back(toBinary(it));\\n        }\\n        bool flag = true;\\n        for(int i = 0;i<bin.size();){\\n            if(bin[i].substr(0,3)==\"110\" && i+1<bin.size() && bin[i+1].substr(0,2)==\"10\"){\\n                i += 2;\\n            }\\n            else if(bin[i].substr(0,4)==\"1110\" && i+2<bin.size() && bin[i+1].substr(0,2)==\"10\" && bin[i+2].substr(0,2)==\"10\"){\\n                i += 3;\\n            }\\n            else if(bin[i].substr(0,5)==\"11110\" && i+3<bin.size() && bin[i+1].substr(0,2)==\"10\" && bin[i+2].substr(0,2)==\"10\" && bin[i+3].substr(0,2)==\"10\"){\\n                i += 4;\\n            }\\n            else if(bin[i][0]==\\'0\\'){\\n                i++;\\n            }\\n            else{\\n                flag = false;\\n                break;\\n            }\\n        }        \\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569325,
                "title": "100-faster-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int start = 0;\\n        int hold = 0;\\n        int len = data.length;\\n        while(start<len){\\n            hold = 0;\\n            int curr = data[start];\\n            while((curr & 128)>0){\\n                hold++;\\n                curr = curr<<1;\\n            }\\n            start++;\\n            hold--;\\n            if(hold==0 || hold>3) return false;\\n            while(hold>0 && start<len){\\n                int temp = data[start];\\n                if((temp&128)==0) return false;\\n                temp = temp<<1;\\n                if((temp&128)>0) return false;\\n                hold--;\\n                start++;\\n            }\\n        }\\n        return hold<=0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int start = 0;\\n        int hold = 0;\\n        int len = data.length;\\n        while(start<len){\\n            hold = 0;\\n            int curr = data[start];\\n            while((curr & 128)>0){\\n                hold++;\\n                curr = curr<<1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2569292,
                "title": "simple-and-readable-solution-c-bitset-and-switch-case",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int getNumberOfBytes(int num) {\\n        bitset<8> b(num);\\n        //cout<<b<<endl;\\n        int count=0;\\n        for(int i=7;i>=0; i--) {\\n            if(b[i] == 0) break;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    bool validMSB(int start, int end, vector<int>& data) {\\n        // all bytes shuld have MBS 10\\n        //cout<<start<<\" \"<<end<<endl;\\n        if(end >= data.size()) return false;\\n        for(int i=start; i<=end; i++) {\\n            bitset<8> b(data[i]);\\n            if(b[7]==1 && b[6]==0)\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int nBytes;\\n        for(int i=0; i<data.size(); i++) {\\n            //cout<<i<<endl;\\n            nBytes = getNumberOfBytes(data[i]);\\n            \\n            switch(nBytes) {\\n                case 1: return false;\\n                case 5: return false;\\n                case 6: return false;\\n                case 7: return false;\\n                case 8: return false;\\n                case 0: continue;\\n                default: \\n                    if(validMSB(i+1, i+nBytes-1, data )) {\\n                        i = i+nBytes-1;\\n                        continue;\\n                    } else {\\n                        return false;\\n                    }           \\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int getNumberOfBytes(int num) {\\n        bitset<8> b(num);\\n        //cout<<b<<endl;\\n        int count=0;\\n        for(int i=7;i>=0; i--) {\\n            if(b[i] == 0) break;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    bool validMSB(int start, int end, vector<int>& data) {\\n        // all bytes shuld have MBS 10\\n        //cout<<start<<\" \"<<end<<endl;\\n        if(end >= data.size()) return false;\\n        for(int i=start; i<=end; i++) {\\n            bitset<8> b(data[i]);\\n            if(b[7]==1 && b[6]==0)\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int nBytes;\\n        for(int i=0; i<data.size(); i++) {\\n            //cout<<i<<endl;\\n            nBytes = getNumberOfBytes(data[i]);\\n            \\n            switch(nBytes) {\\n                case 1: return false;\\n                case 5: return false;\\n                case 6: return false;\\n                case 7: return false;\\n                case 8: return false;\\n                case 0: continue;\\n                default: \\n                    if(validMSB(i+1, i+nBytes-1, data )) {\\n                        i = i+nBytes-1;\\n                        continue;\\n                    } else {\\n                        return false;\\n                    }           \\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2569290,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isoneB(int val){\\n        int res = val & 128;\\n        \\n        if(res != 128)\\n            return true;\\n        return false;\\n    }\\n    \\n    \\n    bool istwoB(int val){\\n        int res = val & 192;\\n        if(res == 192 && val < 224)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool isthreeB(int val){\\n        int res = val & 224;\\n        \\n        if(res == 224 && val < 240)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool isfourB(int val){\\n        int res = val & 240;\\n        \\n        if(res == 240 && val < 248)\\n            return true;\\n        return false;\\n    }\\n    \\n    int findByte(int val){\\n        if(isoneB(val))\\n            return 1;\\n        if(istwoB(val))\\n            return 2;\\n        if(isthreeB(val))\\n            return 3;\\n        if(isfourB(val))\\n            return 4;\\n        return -1;   \\n    }\\n    \\n    bool tensig(int val){\\n        int res = val & 128;\\n        if(res == 128 && val < 192)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            int b = findByte(data[i]); // Finding whether the number is 1/2/3/4 byte\\n            \\n            if(b == -1) // If it is not in 1 to 4 bytes\\n                return false;\\n            \\n            int j;  // Checking whether b-1 bytes are having 10 as significant bits\\n            for(j=i+1; j<n && j<i+b; j++){\\n                if(tensig(data[j]))\\n                    continue;\\n                return false;\\n            }\\n            \\n            if(j != i+b)    // If we failed to check some bytes of b-1 bytes\\n                return false;\\n            \\n            i = j-1; // Going for next sequence\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isoneB(int val){\\n        int res = val & 128;\\n        \\n        if(res != 128)\\n            return true;\\n        return false;\\n    }\\n    \\n    \\n    bool istwoB(int val){\\n        int res = val & 192;\\n        if(res == 192 && val < 224)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool isthreeB(int val){\\n        int res = val & 224;\\n        \\n        if(res == 224 && val < 240)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    bool isfourB(int val){\\n        int res = val & 240;\\n        \\n        if(res == 240 && val < 248)\\n            return true;\\n        return false;\\n    }\\n    \\n    int findByte(int val){\\n        if(isoneB(val))\\n            return 1;\\n        if(istwoB(val))\\n            return 2;\\n        if(isthreeB(val))\\n            return 3;\\n        if(isfourB(val))\\n            return 4;\\n        return -1;   \\n    }\\n    \\n    bool tensig(int val){\\n        int res = val & 128;\\n        if(res == 128 && val < 192)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            int b = findByte(data[i]); // Finding whether the number is 1/2/3/4 byte\\n            \\n            if(b == -1) // If it is not in 1 to 4 bytes\\n                return false;\\n            \\n            int j;  // Checking whether b-1 bytes are having 10 as significant bits\\n            for(j=i+1; j<n && j<i+b; j++){\\n                if(tensig(data[j]))\\n                    continue;\\n                return false;\\n            }\\n            \\n            if(j != i+b)    // If we failed to check some bytes of b-1 bytes\\n                return false;\\n            \\n            i = j-1; // Going for next sequence\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569190,
                "title": "c-easy-to-understand-with-explaination-straight-and-forward-solution",
                "content": "**If you really found my solution helpful please upvote it\\nClick this same icon \\u25B2 on left side pannel of display to upvote**\\n\\n* Convert  decimal to binary\\n* check if start index i=0 in string of binary is 0 so continue\\n* else if front index 1 check count of continous 1 in string \\n* if count is 1 then check next 1 string if it starting id \"10\" so continue else \"false\"\\n* if count is 2 then check same process for next 2 and so on...\\n* other wise return true.\\n\\n```\\nclass Solution\\n{\\n    public: \\n\\t\\n\\t// Converting deci to binary and store in vector;\\n\\t\\n        string decToBinary(int n)\\n        {\\n            string s;\\n            for (int i = 7; i >= 0; i--)\\n            {\\n                int k = n >> i;\\n                if (k & 1)\\n                    s += \"1\";\\n                else\\n                    s += \"0\";\\n            }\\n            return s;\\n        }\\n\\n    bool validUtf8(vector<int> &data)\\n    {\\n        vector<string> vs;\\n        for (int i = 0; i < data.size(); i++)\\n        {\\n            string str = decToBinary(data[i]);\\n            vs.push_back(str);\\n           \\t// cout<<str<<\" \";\\n        }\\n        for (int i = 0; i < vs.size(); i++)       //iterate in vector and check the given condition\\n        {\\n            string s = vs[i];\\n            cout << s << \"\\\\n\";\\n            int cnt = 0;\\n            if (s[0] == \\'0\\')\\n            {\\n                continue;            // if start index 0 is 0 , so continue.\\n            }\\n            for (int j = 1; j < s.size(); j++)\\n            {\\n                if (s[j] == \\'1\\')\\n                {\\n                    cnt++;      // counting 1 \\n                    if (cnt >= 4)\\n                    {\\n                        return false; \\n                    }\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            if (cnt > 0)   //if count is greater the 1 then check next count elements in vecotor otherwise false\\n            {\\n                int j = i + 1;\\n                if (j > vs.size() - 1)        // if element is not present so return false;\\n                {\\n                    return false;\\n                }\\n                while (cnt > 0)\\n                {\\n                    string str1 = vs[j];\\n                    if (str1[0] == \\'0\\' || str1[1] == \\'1\\')\\n                    {\\n                        return false;\\n                    }\\n                    cout << str1 << \" \";\\n                    j++;\\n                    cnt--;\\n                }\\n                cout << \"\\\\n\";\\n                i = j - 1;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public: \\n\\t\\n\\t// Converting deci to binary and store in vector;\\n\\t\\n        string decToBinary(int n)\\n        {\\n            string s;\\n            for (int i = 7; i >= 0; i--)\\n            {\\n                int k = n >> i;\\n                if (k & 1)\\n                    s += \"1\";\\n                else\\n                    s += \"0\";\\n            }\\n            return s;\\n        }\\n\\n    bool validUtf8(vector<int> &data)\\n    {\\n        vector<string> vs;\\n        for (int i = 0; i < data.size(); i++)\\n        {\\n            string str = decToBinary(data[i]);\\n            vs.push_back(str);\\n           \\t// cout<<str<<\" \";\\n        }\\n        for (int i = 0; i < vs.size(); i++)       //iterate in vector and check the given condition\\n        {\\n            string s = vs[i];\\n            cout << s << \"\\\\n\";\\n            int cnt = 0;\\n            if (s[0] == \\'0\\')\\n            {\\n                continue;            // if start index 0 is 0 , so continue.\\n            }\\n            for (int j = 1; j < s.size(); j++)\\n            {\\n                if (s[j] == \\'1\\')\\n                {\\n                    cnt++;      // counting 1 \\n                    if (cnt >= 4)\\n                    {\\n                        return false; \\n                    }\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            if (cnt > 0)   //if count is greater the 1 then check next count elements in vecotor otherwise false\\n            {\\n                int j = i + 1;\\n                if (j > vs.size() - 1)        // if element is not present so return false;\\n                {\\n                    return false;\\n                }\\n                while (cnt > 0)\\n                {\\n                    string str1 = vs[j];\\n                    if (str1[0] == \\'0\\' || str1[1] == \\'1\\')\\n                    {\\n                        return false;\\n                    }\\n                    cout << str1 << \" \";\\n                    j++;\\n                    cnt--;\\n                }\\n                cout << \"\\\\n\";\\n                i = j - 1;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2569098,
                "title": "c-easy-solution-clean-code",
                "content": "**Please UpVote if it helps you**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring dTB(int n)\\n\\t\\t{\\n\\t\\t\\t// decimal to binary\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor (int i = 7; i >= 0; i--) {\\n\\t\\t\\t\\tint k = n >> i;\\n\\t\\t\\t\\tif (k & 1)\\n\\t\\t\\t\\t\\ts += \\'1\\';\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t   s += \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t\\tbool validUtf8(vector<int>& data) {\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(i<data.size()){\\n\\t\\t\\t\\tstring s = dTB(data[i]);\\n\\t\\t\\t\\tint t=0;\\n\\t\\t\\t\\tfor(auto x:s){\\n\\t\\t\\t\\t\\tif(x==\\'1\\')t+=1;\\n\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(t==1 || t>=5)return 0;\\n\\t\\t\\t\\tif(t==0){\\n\\t\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tt-=1;\\n\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\twhile(i<data.size() && t--){\\n\\t\\t\\t\\t\\ts = dTB(data[i]);\\n\\t\\t\\t\\t\\tif(s.substr(0,2)!=\"10\")return 0;\\n\\t\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(t>0)return 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring dTB(int n)\\n\\t\\t{\\n\\t\\t\\t// decimal to binary\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor (int i = 7; i >= 0; i--) {\\n\\t\\t\\t\\tint k = n >> i;\\n\\t\\t\\t\\tif (k & 1)\\n\\t\\t\\t\\t\\ts += \\'1\\';\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t   s += \\'0\\';\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2569083,
                "title": "c-code-duplication-but-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string to_string(int num){\\n        string res;\\n        \\n        for(int i = 7 ; i >= 0 ; i--){\\n            char c = ((num>>i)&1) + \\'0\\';\\n            res.push_back(c);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        int i = 0;\\n        \\n        while(i < n){\\n            string num = to_string(data[i]);\\n            \\n            int cnt = 0, j = 0;\\n            \\n            while(j < num.length() && num[j] == \\'1\\'){\\n                cnt++;\\n                j++;\\n            }\\n            if(cnt > 4 || cnt == 1) return false;\\n            \\n            if(cnt == 0){\\n                i++;\\n                continue;\\n            }\\n            \\n            if(cnt == 2){\\n                if(i+1 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 2;\\n                continue;\\n            }\\n            \\n            if(cnt == 3){\\n                if(i+1 == n || i+2 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+2]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 3;\\n                continue;\\n            }\\n            \\n            if(cnt == 4){\\n                if(i+1 == n || i+2 == n || i+3 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+2]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+3]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 4;\\n                continue;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string to_string(int num){\\n        string res;\\n        \\n        for(int i = 7 ; i >= 0 ; i--){\\n            char c = ((num>>i)&1) + \\'0\\';\\n            res.push_back(c);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        int i = 0;\\n        \\n        while(i < n){\\n            string num = to_string(data[i]);\\n            \\n            int cnt = 0, j = 0;\\n            \\n            while(j < num.length() && num[j] == \\'1\\'){\\n                cnt++;\\n                j++;\\n            }\\n            if(cnt > 4 || cnt == 1) return false;\\n            \\n            if(cnt == 0){\\n                i++;\\n                continue;\\n            }\\n            \\n            if(cnt == 2){\\n                if(i+1 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 2;\\n                continue;\\n            }\\n            \\n            if(cnt == 3){\\n                if(i+1 == n || i+2 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+2]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 3;\\n                continue;\\n            }\\n            \\n            if(cnt == 4){\\n                if(i+1 == n || i+2 == n || i+3 == n) return false;\\n                string temp = to_string(data[i+1]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+2]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                temp = to_string(data[i+3]);\\n                if(!(temp[0] == \\'1\\' && temp[1] == \\'0\\')) return false;\\n                i += 4;\\n                continue;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568974,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        unicode=[]\\n        for i in range(len(data)):\\n            x=bin(data[i]).replace(\"0b\", \"\")\\n            if len(x)<8:\\n                x=\\'0\\'*(8-len(x))+x\\n            unicode.append(x)\\n        curr=None\\n        cont=0\\n        for i in range(len(unicode)):\\n            if cont>0:\\n                if unicode[i][:2]!=\\'10\\':\\n                    return False\\n                cont-=1\\n            elif cont==0 and unicode[i][:2]==\\'10\\':\\n                return False\\n            else:\\n                for j in range(5):\\n                    if unicode[i][j]==\\'0\\':\\n                        if j==0:\\n                            curr=1\\n                        else:\\n                            curr=j\\n                            cont=j-1\\n                        break\\n                else:\\n                    print(\"ok2\")\\n                    return False\\n        if cont>0:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        unicode=[]\\n        for i in range(len(data)):\\n            x=bin(data[i]).replace(\"0b\", \"\")\\n            if len(x)<8:\\n                x=\\'0\\'*(8-len(x))+x\\n            unicode.append(x)\\n        curr=None\\n        cont=0\\n        for i in range(len(unicode)):\\n            if cont>0:\\n                if unicode[i][:2]!=\\'10\\':\\n                    return False\\n                cont-=1\\n            elif cont==0 and unicode[i][:2]==\\'10\\':\\n                return False\\n            else:\\n                for j in range(5):\\n                    if unicode[i][j]==\\'0\\':\\n                        if j==0:\\n                            curr=1\\n                        else:\\n                            curr=j\\n                            cont=j-1\\n                        break\\n                else:\\n                    print(\"ok2\")\\n                    return False\\n        if cont>0:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568939,
                "title": "c-straight-solution-beginner-friendly",
                "content": "# **If you really liked my solution then please upvote it as it motivates me to regularly post solution**\\n```\\nclass Solution {\\npublic:\\n    string binString(int val){\\n        string s=\"\";\\n        for(int i=0;i<8;i++)\\n        {\\n            s+=(\\'0\\'+val%2);\\n            val/=2;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int n=data.size();\\n        for(int i=0;i<n;i++){\\n            \\n            string s=binString(data[i]);\\n            cout<<s<<endl;\\n            if(s[0]==\\'0\\'){\\n                continue;\\n            }\\n            else{\\n                if(s[1]==\\'1\\'&&s[2]==\\'0\\'){\\n                    i++;\\n                    if(i>=n){\\n                        return false;\\n                    }\\n                    string t=binString(data[i]);\\n                    if(t[0]!=\\'1\\'&&t[1]!=\\'0\\'){\\n                        return false;\\n                    }\\n                }\\n                else if(s[1]==\\'1\\'&&s[2]==\\'1\\'&&s[3]==\\'0\\'){\\n                    for(int j=0;j<2;j++){\\n                        i++;\\n                        if(i>=n){\\n                            return false;\\n                        }\\n                        string t=binString(data[i]);\\n                        cout<<s<<endl;\\n                        if(t[0]!=\\'1\\'||t[1]!=\\'0\\'){\\n                            return false;\\n                        }\\n                    }\\n                }\\n                else if(s[1]==\\'1\\'&&s[2]==\\'1\\'&&s[3]==\\'1\\'&&s[4]==\\'0\\'){\\n                    for(int j=0;j<3;j++){\\n                        i++;\\n                        if(i>=n){\\n                            return false;\\n                        }\\n                        string t=binString(data[i]);\\n                        if(t[0]!=\\'1\\'||t[1]!=\\'0\\'){\\n                            return false;\\n                        }\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string binString(int val){\\n        string s=\"\";\\n        for(int i=0;i<8;i++)\\n        {\\n            s+=(\\'0\\'+val%2);\\n            val/=2;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        int n=data.size();\\n        for(int i=0;i<n;i++){\\n            \\n            string s=binString(data[i]);\\n            cout<<s<<endl;\\n            if(s[0]==\\'0\\'){\\n                continue;\\n            }\\n            else{\\n                if(s[1]==\\'1\\'&&s[2]==\\'0\\'){\\n                    i++;\\n                    if(i>=n){\\n                        return false;\\n                    }\\n                    string t=binString(data[i]);\\n                    if(t[0]!=\\'1\\'&&t[1]!=\\'0\\'){\\n                        return false;\\n                    }\\n                }\\n                else if(s[1]==\\'1\\'&&s[2]==\\'1\\'&&s[3]==\\'0\\'){\\n                    for(int j=0;j<2;j++){\\n                        i++;\\n                        if(i>=n){\\n                            return false;\\n                        }\\n                        string t=binString(data[i]);\\n                        cout<<s<<endl;\\n                        if(t[0]!=\\'1\\'||t[1]!=\\'0\\'){\\n                            return false;\\n                        }\\n                    }\\n                }\\n                else if(s[1]==\\'1\\'&&s[2]==\\'1\\'&&s[3]==\\'1\\'&&s[4]==\\'0\\'){\\n                    for(int j=0;j<3;j++){\\n                        i++;\\n                        if(i>=n){\\n                            return false;\\n                        }\\n                        string t=binString(data[i]);\\n                        if(t[0]!=\\'1\\'||t[1]!=\\'0\\'){\\n                            return false;\\n                        }\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2568928,
                "title": "2-c-bit-manupulation-approach-dajulal",
                "content": "```\\n  bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        int remainingByte=0;\\n        for(int i=0;i<n;i++){\\n            if(remainingByte==0){\\n                if((data[i]>>7)==0b0){//1st Byte of 1 length char\\n                  continue;\\n                }\\n               else if((data[i]>>5)==0b110){//1st Byte of 2 length char\\n                    remainingByte=1;\\n               }\\n                else if((data[i]>>4)==0b1110){//1st Byte of 3 length char\\n                    remainingByte=2;\\n               }\\n               else if((data[i]>>3)==0b11110){//1st Byte of 4 length char\\n                    remainingByte=3;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }else{\\n                if((data[i]>>6)==0b10){\\n                    remainingByte--;\\n                }else{\\n                    return false;\\n                }\\n            }         \\n        }\\n        if(remainingByte==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n  bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        int remainingByte=0;\\n        for(int i=0;i<n;i++){\\n            if(remainingByte==0){\\n                if((data[i]>>7)==0b0){//1st Byte of 1 length char\\n                  continue;\\n                }\\n               else if((data[i]>>5)==0b110){//1st Byte of 2 length char\\n                    remainingByte=1;\\n               }\\n                else if((data[i]>>4)==0b1110){//1st Byte of 3 length char\\n                    remainingByte=2;\\n               }\\n               else if((data[i]>>3)==0b11110){//1st Byte of 4 length char\\n                    remainingByte=3;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }else{\\n                if((data[i]>>6)==0b10){\\n                    remainingByte--;\\n                }else{\\n                    return false;\\n                }\\n            }         \\n        }\\n        if(remainingByte==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568856,
                "title": "swift-one-liner-plus-easy-13-line-solution-beats-100-0",
                "content": "**One-Liner, DO NOT USE THIS APPROACH IN AN INTERVIEW! (accepted answer)**\\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        String(bytes: data.map { UInt8(exactly: $0)! }, encoding: .utf8) != nil\\n    }\\n}\\n```\\n\\n---\\n\\n**Fast Approach with Bitwise Analysis (accepted answer)**\\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var i = 0\\n        while i < data.count {\\n            let num = data[i]\\n            i += 1\\n            guard num & 0x80 != 0 else { continue }\\n            let charactersLeft = Int8(num ^ 0xff).leadingZeroBitCount - 1\\n            guard 1...3 ~= charactersLeft, data.count - charactersLeft >= i else { return false }\\n            for j in 0 ..< charactersLeft where data[i+j] & 0xc0 != 0x80 {\\n                return false \\n            }\\n            i += charactersLeft\\n        } \\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n**Fast Approach, but replacing `leadingZeroBitCount` with hand-coded loop (accepted answer)**\\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var i = 0\\n        while i < data.count {\\n            var num = data[i]\\n            i += 1\\n            guard num & 0x80 != 0 else { continue }\\n            var charactersLeft = -1 \\n            while num & 0x80 != 0 {\\n                guard num != 0 else { return false }\\n                charactersLeft += 1\\n                num <<= 1\\n            }\\n            guard 1...3 ~= charactersLeft, data.count - charactersLeft >= i else { return false }\\n            for j in 0 ..< charactersLeft where data[i+j] & 0xc0 != 0x80 {\\n                return false \\n            }\\n            i += charactersLeft\\n        } \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        String(bytes: data.map { UInt8(exactly: $0)! }, encoding: .utf8) != nil\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var i = 0\\n        while i < data.count {\\n            let num = data[i]\\n            i += 1\\n            guard num & 0x80 != 0 else { continue }\\n            let charactersLeft = Int8(num ^ 0xff).leadingZeroBitCount - 1\\n            guard 1...3 ~= charactersLeft, data.count - charactersLeft >= i else { return false }\\n            for j in 0 ..< charactersLeft where data[i+j] & 0xc0 != 0x80 {\\n                return false \\n            }\\n            i += charactersLeft\\n        } \\n        return true\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func validUtf8(_ data: [Int]) -> Bool {\\n        var i = 0\\n        while i < data.count {\\n            var num = data[i]\\n            i += 1\\n            guard num & 0x80 != 0 else { continue }\\n            var charactersLeft = -1 \\n            while num & 0x80 != 0 {\\n                guard num != 0 else { return false }\\n                charactersLeft += 1\\n                num <<= 1\\n            }\\n            guard 1...3 ~= charactersLeft, data.count - charactersLeft >= i else { return false }\\n            for j in 0 ..< charactersLeft where data[i+j] & 0xc0 != 0x80 {\\n                return false \\n            }\\n            i += charactersLeft\\n        } \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568843,
                "title": "bit-manipulation-o-n-java-1-ms-beat-100",
                "content": "```\\n    public boolean validUtf8(int[] data) {\\n        int[] pattern = new int[] {0x00, 0xc0, 0xe0, 0xf0};\\n        int[] maskFirst = new int[] {0x80, 0xe0, 0xf0, 0xf8};\\n        int maskFollow = 0xc0;\\n        int i = 0;\\n        while (i < data.length) {\\n            int match = -1;\\n            for (int j = 3; j >= 0; j--) {\\n                if ((data[i] & maskFirst[j]) == pattern[j]) {\\n                    match = j;\\n                    break;\\n                }\\n            }\\n            if (match == -1) return false;\\n            for (int j = i+1; j <= i+match; j++) {\\n                if (j >= data.length || (data[j] & maskFollow) != 0x80) {\\n                    return false;\\n                }\\n            }\\n            i += (match + 1);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public boolean validUtf8(int[] data) {\\n        int[] pattern = new int[] {0x00, 0xc0, 0xe0, 0xf0};\\n        int[] maskFirst = new int[] {0x80, 0xe0, 0xf0, 0xf8};\\n        int maskFollow = 0xc0;\\n        int i = 0;\\n        while (i < data.length) {\\n            int match = -1;\\n            for (int j = 3; j >= 0; j--) {\\n                if ((data[i] & maskFirst[j]) == pattern[j]) {\\n                    match = j;\\n                    break;\\n                }\\n            }\\n            if (match == -1) return false;\\n            for (int j = i+1; j <= i+match; j++) {\\n                if (j >= data.length || (data[j] & maskFollow) != 0x80) {\\n                    return false;\\n                }\\n            }\\n            i += (match + 1);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568817,
                "title": "python3-self-explanatory-example-string-manipulation",
                "content": "I hope the following code can help you understand the algorithm\\'s big picture.\\n\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:       \\n        # Runtime: 122 ms, faster than 89.33% of Python3 online submissions for UTF-8 Validation.\\n        # Memory Usage: 14.1 MB, less than 70.76% of Python3 online submissions for UTF-8 Validation.\\n        \\n        # Define helpers.\\n        def to_string(num):\\n            # Remove first 0b, then fill zeros if the number was small or it will cause false negative.\\n            return bin(num)[2:].zfill(8)\\n        \\n        def get_char_size(num):\\n            s = to_string(num)\\n            \\n            if s.startswith(\"0\"):\\n                return 1\\n            if s.startswith(\"110\"):\\n                return 2\\n            if s.startswith(\"1110\"):\\n                return 3\\n            if s.startswith(\"11110\"):\\n                return 4\\n            \\n            return None # This means Invalid Encoding.\\n\\n        def is_valid_second_or_lator(num):\\n            s = to_string(num)\\n            return s.startswith(\"10\")\\n        \\n        \\n        # Main\\n        remaining = 0 # Represents the number of remaining integer of the current character.\\n        for number in data:\\n            if remaining == 0: # Start a new character.\\n                remaining = get_char_size(number)\\n                if remaining is None:\\n                    return False\\n            else:\\n                if not is_valid_second_or_lator(number):\\n                    return False\\n            remaining -= 1\\n        \\n        # The final character\\'s end need to match the end of the whole data.\\n        return remaining == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:       \\n        # Runtime: 122 ms, faster than 89.33% of Python3 online submissions for UTF-8 Validation.\\n        # Memory Usage: 14.1 MB, less than 70.76% of Python3 online submissions for UTF-8 Validation.\\n        \\n        # Define helpers.\\n        def to_string(num):\\n            # Remove first 0b, then fill zeros if the number was small or it will cause false negative.\\n            return bin(num)[2:].zfill(8)\\n        \\n        def get_char_size(num):\\n            s = to_string(num)\\n            \\n            if s.startswith(\"0\"):\\n                return 1\\n            if s.startswith(\"110\"):\\n                return 2\\n            if s.startswith(\"1110\"):\\n                return 3\\n            if s.startswith(\"11110\"):\\n                return 4\\n            \\n            return None # This means Invalid Encoding.\\n\\n        def is_valid_second_or_lator(num):\\n            s = to_string(num)\\n            return s.startswith(\"10\")\\n        \\n        \\n        # Main\\n        remaining = 0 # Represents the number of remaining integer of the current character.\\n        for number in data:\\n            if remaining == 0: # Start a new character.\\n                remaining = get_char_size(number)\\n                if remaining is None:\\n                    return False\\n            else:\\n                if not is_valid_second_or_lator(number):\\n                    return False\\n            remaining -= 1\\n        \\n        # The final character\\'s end need to match the end of the whole data.\\n        return remaining == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568764,
                "title": "java-simple-bit-manipulation-and-masking",
                "content": "I am using masking and matching to check the prefixes. It is similar to how IP subnet masks work.\\n\\nFor the maks, we only set bit to 1 at positions that we want to track and leave the rest at 0. Then, we can match the resulting values with the prefix values. The prefix value is just the header bits with the rest bits filled with 0s.\\n\\nLet\\'s takes a look at 110xxxxx as an example.\\nWe only need to check the first three bits and ignore the others so the mask is 11100000 and the prefix value is 11000000.\\n\\nLet\\'s test 10100110, 11011110, and 11010101 with our mask and prefixes.\\nFirst, filter out all other bits with the mask and AND operator.\\n\\n10100110 & 11100000 = 10100000 <- Not equal to 11000000\\n11011110 & 11100000 = 11000000 <- Equal to 11000000\\n11010101 & 11100000 = 11000000 <- Equal to 11000000 \\n\\nAs you can see, the first test will return false since the headers do not match. In the latter two cases, the five least significant bits are removed by the mask so they both return the same prefix value.\\n\\nNow, I just expanded this to all the headers and tails with precomputed values.\\n\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n\\t\\t// Create precomputed arrays with the mask and prefixes.\\n\\t\\t// Bitwise representation: [ [10000000,00000000],\\n\\t\\t//                           [11100000,11000000],\\n\\t\\t//                           [11110000,11100000],\\n\\t\\t//                           [11111000,11110000]]\\n        int[][] headers = new int[][]{{128,0},{224,192},{240,224},{248,240}};\\n\\t\\t\\n\\t\\t// Bitwise representation: [11000000,10000000]\\n        int[] tail = new int[]{192,128};\\n        \\n        for(int i = 0; i < data.length; ++i){\\n\\t\\t\\t// Find which header matches\\n            int num = -1;\\n            for(int j = 0; j < 4; ++j){\\n                if((data[i]&headers[j][0])==headers[j][1]){\\n                    num=j;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// No match or there isn\\'t enough data left\\n            if(num==-1 || i+num>=data.length)\\n                return false;\\n            \\n\\t\\t\\t// Check the remaining tail bytes\\n            for(int j = 0; j < num; ++j){\\n                if((data[++i]&tail[0])!=tail[1])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n\\t\\t// Create precomputed arrays with the mask and prefixes.\\n\\t\\t// Bitwise representation: [ [10000000,00000000],\\n\\t\\t//                           [11100000,11000000],\\n\\t\\t//                           [11110000,11100000],\\n\\t\\t//                           [11111000,11110000]]\\n        int[][] headers = new int[][]{{128,0},{224,192},{240,224},{248,240}};\\n\\t\\t\\n\\t\\t// Bitwise representation: [11000000,10000000]\\n        int[] tail = new int[]{192,128};\\n        \\n        for(int i = 0; i < data.length; ++i){\\n\\t\\t\\t// Find which header matches\\n            int num = -1;\\n            for(int j = 0; j < 4; ++j){\\n                if((data[i]&headers[j][0])==headers[j][1]){\\n                    num=j;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// No match or there isn\\'t enough data left\\n            if(num==-1 || i+num>=data.length)\\n                return false;\\n            \\n\\t\\t\\t// Check the remaining tail bytes\\n            for(int j = 0; j < num; ++j){\\n                if((data[++i]&tail[0])!=tail[1])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507306,
                "title": "java-easy-solution",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n        for(int i=0; i<data.length; i++){\\n            int numOfBytes = 0;\\n            int val = data[i];\\n            if(val >= 255 ) return false;  //if value is greator or equal to 255 \\n            else if((val & 128) == 0) numOfBytes=1; //starting with 0\\n            else if((val & 224) == 192) numOfBytes=2; //starting with 110\\n            else if((val & 240)== 224) numOfBytes=3; //starting with 1110\\n            else if((val & 248)==240) numOfBytes=4; //starting with 11110\\n            else return false;\\n            \\n\\t\\t\\t//this loop check 1110 ......, 10...., 10...,\\n            for(int j=1; j<numOfBytes; j++){\\n                if(j+i >= data.length) return false;\\n                else if((data[i+j] & 192)!= 128 ) return false;\\n            }\\n            \\n            i = i + numOfBytes-1; //we have changed the i so we have to update the i \\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n        for(int i=0; i<data.length; i++){\\n            int numOfBytes = 0;\\n            int val = data[i];\\n            if(val >= 255 ) return false;  //if value is greator or equal to 255 \\n            else if((val & 128) == 0) numOfBytes=1; //starting with 0\\n            else if((val & 224) == 192) numOfBytes=2; //starting with 110\\n            else if((val & 240)== 224) numOfBytes=3; //starting with 1110\\n            else if((val & 248)==240) numOfBytes=4; //starting with 11110\\n            else return false;\\n            \\n\\t\\t\\t//this loop check 1110 ......, 10...., 10...,\\n            for(int j=1; j<numOfBytes; j++){\\n                if(j+i >= data.length) return false;\\n                else if((data[i+j] & 192)!= 128 ) return false;\\n            }\\n            \\n            i = i + numOfBytes-1; //we have changed the i so we have to update the i \\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700528,
                "title": "c-8ms-93-easy-to-understand-bit-manipulation",
                "content": "\\nRuntime: 8 ms, faster than 92.78% of C++ online submissions for UTF-8 Validation.\\nMemory Usage: 13.9 MB, less than 75.28% of C++ online submissions for UTF-8 Validation.\\n```\\nclass Solution {\\npublic:\\n  bool validUtf8(vector<int>& data) {\\n    data.push_back(1); \\n    data.push_back(1); \\n    data.push_back(1);\\n    \\n    int mask1 = 0b10000000, \\n      mask2 = 0b11111,  val2 = 0b11011111, \\n      mask3 = 0b1111,   val3 = 0b11101111,  \\n      mask4 = 0b111,    val4 = 0b11110111, \\n      mask  = 0b111111, val  = 0b10111111;\\n    \\n    for(int id = 0; id != data.size(); id++)\\n      if( (data[id] & mask1) == 0);\\n      else\\n        if((data[id] | mask2) == val2){\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else if((data[id] | mask3) == val3){\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else if((data[id] | mask4) == val4){\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else return false;\\n      \\n    \\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool validUtf8(vector<int>& data) {\\n    data.push_back(1); \\n    data.push_back(1); \\n    data.push_back(1);\\n    \\n    int mask1 = 0b10000000, \\n      mask2 = 0b11111,  val2 = 0b11011111, \\n      mask3 = 0b1111,   val3 = 0b11101111,  \\n      mask4 = 0b111,    val4 = 0b11110111, \\n      mask  = 0b111111, val  = 0b10111111;\\n    \\n    for(int id = 0; id != data.size(); id++)\\n      if( (data[id] & mask1) == 0);\\n      else\\n        if((data[id] | mask2) == val2){\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else if((data[id] | mask3) == val3){\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else if((data[id] | mask4) == val4){\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n          if((data[++id] | mask) != val) return false;\\n        }\\n        else return false;\\n      \\n    \\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672809,
                "title": "python-masks-solution-using-hexadecimal",
                "content": "``` python\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        data.reverse()\\n        \\n        def check_n_byte_elem(data, n):\\n            if len(data) < n-1: return False\\n            bytes_to_check = [data.pop() for _ in range(n-1)]\\n            for elem in bytes_to_check:\\n                if not (elem & 0xC0) == 0x80:\\n                    return False\\n                \\n            return True\\n            \\n        while data:\\n            elem = data.pop()\\n            if (elem & 0xF8) == 0xF0:\\n                check = check_n_byte_elem(data, 4)\\n            elif (elem & 0xF0) == 0xE0:\\n                check = check_n_byte_elem(data, 3)\\n            elif (elem & 0xE0) == 0xC0:\\n                check = check_n_byte_elem(data, 2)\\n            elif (elem & 0x80) == 0x00:\\n                check = True\\n            else:\\n                check = False\\n            if not check: return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        data.reverse()\\n        \\n        def check_n_byte_elem(data, n):\\n            if len(data) < n-1: return False\\n            bytes_to_check = [data.pop() for _ in range(n-1)]\\n            for elem in bytes_to_check:\\n                if not (elem & 0xC0) == 0x80:\\n                    return False\\n                \\n            return True\\n            \\n        while data:\\n            elem = data.pop()\\n            if (elem & 0xF8) == 0xF0:\\n                check = check_n_byte_elem(data, 4)\\n            elif (elem & 0xF0) == 0xE0:\\n                check = check_n_byte_elem(data, 3)\\n            elif (elem & 0xE0) == 0xC0:\\n                check = check_n_byte_elem(data, 2)\\n            elif (elem & 0x80) == 0x00:\\n                check = True\\n            else:\\n                check = False\\n            if not check: return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490778,
                "title": "java-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes = 0;\\n        for(int i:data)\\n        {\\n            if(rbytes==0)\\n            {\\n                if(i>>7 == 0)\\n                    rbytes = 0;\\n                else if(i>>5 == 6)\\n                    rbytes = 1;\\n                else if(i>>4 == 14)\\n                    rbytes = 2;\\n                else if(i>>3 == 30)\\n                    rbytes = 3;\\n                else \\n                    return false;\\n            }\\n            else\\n            {\\n                if(i>>6 != 2)\\n                    return false;\\n                else\\n                {\\n                    rbytes--;\\n                }\\n            }\\n        }\\n        if(rbytes==0)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes = 0;\\n        for(int i:data)\\n        {\\n            if(rbytes==0)\\n            {\\n                if(i>>7 == 0)\\n                    rbytes = 0;\\n                else if(i>>5 == 6)\\n                    rbytes = 1;\\n                else if(i>>4 == 14)\\n                    rbytes = 2;\\n                else if(i>>3 == 30)\\n                    rbytes = 3;\\n                else \\n                    return false;\\n            }\\n            else\\n            {\\n                if(i>>6 != 2)\\n                    return false;\\n                else\\n                {\\n                    rbytes--;\\n                }\\n            }\\n        }\\n        if(rbytes==0)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301838,
                "title": "simple-readable-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean validUtf8(int[] data) {\\n\\t\\t\\tint remaining=0;\\n\\t\\t\\tfor(int i:data){\\n\\t\\t\\t\\tif(remaining==0){\\n\\t\\t\\t\\t\\tif(i>>7==0b0){\\n\\t\\t\\t\\t\\t\\tremaining = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(i>>5==0b110){\\n\\t\\t\\t\\t\\t\\tremaining = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(i>>4==0b1110){\\n\\t\\t\\t\\t\\t\\tremaining = 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(i>>3==0b11110){\\n\\t\\t\\t\\t\\t\\tremaining = 3;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(i>>6==0b10){\\n\\t\\t\\t\\t\\t\\tremaining--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn remaining==0?true:false;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean validUtf8(int[] data) {\\n\\t\\t\\tint remaining=0;\\n\\t\\t\\tfor(int i:data){\\n\\t\\t\\t\\tif(remaining==0){\\n\\t\\t\\t\\t\\tif(i>>7==0b0){\\n\\t\\t\\t\\t\\t\\tremaining = 0;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1237114,
                "title": "easy-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool bitcheck(vector<string> &bin, int &i){\\n        int byte=0;\\n        for(auto &c:bin[i]){\\n            if(c==\\'1\\')byte++;\\n            else break;\\n        }\\n        if(byte>4 || byte==1)return false;\\n        if(byte==0)return bin[i++][0]==\\'0\\';\\n        if(bin.size()-i<byte)return false;\\n        int j=i;\\n        i++;\\n        for(;i<=j+byte-1;i++){\\n            if(bin[i].substr(0,2)!=\"10\")return false;\\n        }\\n        return true;\\n        \\n    }\\n    string binary(int a){\\n        string s=\"\";\\n        while(a){\\n            s+=to_string(a%2);\\n            a/=2;\\n        }\\n        reverse(s.begin(),s.end());\\n        s=string(8-s.length(),\\'0\\')+s;\\n        return s;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        vector<string> bin;\\n        for(auto &i:data){\\n            bin.push_back(binary(i));\\n        }\\n        cout<<bin[0]<<\" \";\\n        int i=0;\\n        while(i<data.size()){\\n            if(!bitcheck(bin,i))return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bitcheck(vector<string> &bin, int &i){\\n        int byte=0;\\n        for(auto &c:bin[i]){\\n            if(c==\\'1\\')byte++;\\n            else break;\\n        }\\n        if(byte>4 || byte==1)return false;\\n        if(byte==0)return bin[i++][0]==\\'0\\';\\n        if(bin.size()-i<byte)return false;\\n        int j=i;\\n        i++;\\n        for(;i<=j+byte-1;i++){\\n            if(bin[i].substr(0,2)!=\"10\")return false;\\n        }\\n        return true;\\n        \\n    }\\n    string binary(int a){\\n        string s=\"\";\\n        while(a){\\n            s+=to_string(a%2);\\n            a/=2;\\n        }\\n        reverse(s.begin(),s.end());\\n        s=string(8-s.length(),\\'0\\')+s;\\n        return s;\\n    }\\n    bool validUtf8(vector<int>& data) {\\n        vector<string> bin;\\n        for(auto &i:data){\\n            bin.push_back(binary(i));\\n        }\\n        cout<<bin[0]<<\" \";\\n        int i=0;\\n        while(i<data.size()){\\n            if(!bitcheck(bin,i))return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1222380,
                "title": "c-c-lookup-table-faster-than-100",
                "content": "The last 8 values in the following lookup table correspond to these bytes:\\n\\n11000xxx - 1 continuation byte\\n11001xxx - 1 continuation byte\\n11010xxx - 1 continuation byte\\n11011xxx - 1 continuation byte\\n11100xxx - 2 continuation bytes\\n11101xxx - 2 continuation bytes\\n11110xxx - 3 continuation bytes\\n11111xxx - 0, not legal\\n\\nWith a simple right-shift of 3 we only need to test 32 combinations for a valid leading byte.\\n```\\nstatic int num_continuation_bytes[32] =\\n{\\n    0,0,0,0,0,0,0,0,\\n\\t0,0,0,0,0,0,0,0,\\n\\t0,0,0,0,0,0,0,0,\\n\\t1,1,1,1,2,2,3,0\\n};\\n\\nbool validUtf8(int* data, int size)\\n{\\n    while (size--)\\n    {\\n        int d = *data++;\\n        if (d < 0x80) continue;\\n\\n        int c = num_continuation_bytes[d >> 3];\\n        if (c < 1 || size < c) return false;\\n\\t\\t\\n        size -= c;\\n        while (c--)\\n        {\\n\\t\\t    d = *data++;\\n            if ((d & 0xC0) != 0x80) return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int num_continuation_bytes[32] =\\n{\\n    0,0,0,0,0,0,0,0,\\n\\t0,0,0,0,0,0,0,0,\\n\\t0,0,0,0,0,0,0,0,\\n\\t1,1,1,1,2,2,3,0\\n};\\n\\nbool validUtf8(int* data, int size)\\n{\\n    while (size--)\\n    {\\n        int d = *data++;\\n        if (d < 0x80) continue;\\n\\n        int c = num_continuation_bytes[d >> 3];\\n        if (c < 1 || size < c) return false;\\n\\t\\t\\n        size -= c;\\n        while (c--)\\n        {\\n\\t\\t    d = *data++;\\n            if ((d & 0xC0) != 0x80) return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110925,
                "title": "java-1ms-bit-manipulation",
                "content": "```\\nclass Solution {\\n    \\n    public boolean validUtf8(int[] data) {\\n        for (int i = 0; i < data.length;) {\\n            int b = data[i];\\n            \\n            int charLen;\\n            if ((b & 0x80) == 0) {\\n                charLen = 1;\\n            } else if ((b & 0xE0) == 0xC0) {\\n                charLen = 2;\\n            } else if ((b & 0xF0) == 0xE0) {\\n                charLen = 3;\\n            } else if ((b & 0xF8) == 0xF0) {\\n                charLen = 4;\\n            } else {\\n                return false;\\n            }\\n            \\n            int charEnd = i + charLen;\\n            if (charEnd > data.length) {\\n                return false;\\n            }\\n            for (int j = i+1; j < charEnd; ++j) {\\n                if ((data[j] & 0xC0) != 0x80) {\\n                    return false;\\n                }\\n            }\\n            i = charEnd;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean validUtf8(int[] data) {\\n        for (int i = 0; i < data.length;) {\\n            int b = data[i];\\n            \\n            int charLen;\\n            if ((b & 0x80) == 0) {\\n                charLen = 1;\\n            } else if ((b & 0xE0) == 0xC0) {\\n                charLen = 2;\\n            } else if ((b & 0xF0) == 0xE0) {\\n                charLen = 3;\\n            } else if ((b & 0xF8) == 0xF0) {\\n                charLen = 4;\\n            } else {\\n                return false;\\n            }\\n            \\n            int charEnd = i + charLen;\\n            if (charEnd > data.length) {\\n                return false;\\n            }\\n            for (int j = i+1; j < charEnd; ++j) {\\n                if ((data[j] & 0xC0) != 0x80) {\\n                    return false;\\n                }\\n            }\\n            i = charEnd;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039996,
                "title": "simple-solution-of-utf-8-validation-using-bit-manipulation-in-java-1ms-runtime",
                "content": "```\\npublic static boolean validUtf8(int[] data) {\\n        int bts=0;\\n        for (int val: data) {\\n            if(bts==0){\\n                if((val>>7)==0b0){\\n                    bts=0;\\n                }else if((val>>5)==0b110){\\n                    bts=1;\\n                }else if((val>>4)==0b1110){\\n                    bts=2;\\n                }else if((val>>3)==0b11110){\\n                    bts=3;\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                if((val>>6)==0b10){\\n                    bts--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(bts==0){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic static boolean validUtf8(int[] data) {\\n        int bts=0;\\n        for (int val: data) {\\n            if(bts==0){\\n                if((val>>7)==0b0){\\n                    bts=0;\\n                }else if((val>>5)==0b110){\\n                    bts=1;\\n                }else if((val>>4)==0b1110){\\n                    bts=2;\\n                }else if((val>>3)==0b11110){\\n                    bts=3;\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                if((val>>6)==0b10){\\n                    bts--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(bts==0){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865864,
                "title": "python-hella-comments-solution",
                "content": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        \\n        # Convert to strings of bins\\n        data = [str(bin(x))[2:] for x in data]\\n                \\n        # Loop until we\\'ve popped all from data\\n        while True:\\n            \\n            # Get the prefix (tells us how many bytes we expect)\\n            try:\\n                prefix = data.pop(0)\\n            except:\\n                break\\n                \\n            # If less than eight, we don\\'t expect any more, we can get next prefix\\n            if len(prefix) < 8:\\n                continue\\n                \\n            # Otherwise read the number of 1\\'s on the prefix\\n            num_tens = len(prefix.split(\\'0\\')[0])-1\\n            \\n            # If greater than three, it\\'s an error\\n            if num_tens > 3:\\n                return False\\n            # If less than zero, it\\'s also an error\\n            elif num_tens < 0:                \\n                continue            \\n            # If zero exaclty, also an error\\n            elif num_tens == 0:\\n                return False\\n            # Else, num_tens tells us how many bytes we expect to read\\n            else:\\n                # We pop the num bytes we expect\\n                for _ in range(num_tens):\\n                    \\n                    # If we fail to pop, its invalid string\\n                    try:\\n                        char = data.pop(0)\\n                    except:\\n                        return False\\n                    \\n                    # Make sure its prefixed by 10 and at least eight char, else invalid\\n                    if char[:2] == \\'10\\' and len(char) == 8:\\n                        num_tens -= 1\\n                    else:\\n                        return False\\n                    \\n                # If we didn\\'t reach exactly num_tens bytes, it\\'s error\\n                if num_tens != 0:\\n                    return False\\n        \\n        # If we made it this far, its valid\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        \\n        # Convert to strings of bins\\n        data = [str(bin(x))[2:] for x in data]\\n                \\n        # Loop until we\\'ve popped all from data\\n        while True:\\n            \\n            # Get the prefix (tells us how many bytes we expect)\\n            try:\\n                prefix = data.pop(0)\\n            except:\\n                break\\n                \\n            # If less than eight, we don\\'t expect any more, we can get next prefix\\n            if len(prefix) < 8:\\n                continue\\n                \\n            # Otherwise read the number of 1\\'s on the prefix\\n            num_tens = len(prefix.split(\\'0\\')[0])-1\\n            \\n            # If greater than three, it\\'s an error\\n            if num_tens > 3:\\n                return False\\n            # If less than zero, it\\'s also an error\\n            elif num_tens < 0:                \\n                continue            \\n            # If zero exaclty, also an error\\n            elif num_tens == 0:\\n                return False\\n            # Else, num_tens tells us how many bytes we expect to read\\n            else:\\n                # We pop the num bytes we expect\\n                for _ in range(num_tens):\\n                    \\n                    # If we fail to pop, its invalid string\\n                    try:\\n                        char = data.pop(0)\\n                    except:\\n                        return False\\n                    \\n                    # Make sure its prefixed by 10 and at least eight char, else invalid\\n                    if char[:2] == \\'10\\' and len(char) == 8:\\n                        num_tens -= 1\\n                    else:\\n                        return False\\n                    \\n                # If we didn\\'t reach exactly num_tens bytes, it\\'s error\\n                if num_tens != 0:\\n                    return False\\n        \\n        # If we made it this far, its valid\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736306,
                "title": "java-solution-runtime-1-ms-faster-than-99-37-of-java-online-submissions",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean validUtf8(int[] arr) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\t\\tint val = arr[i];\\n\\t\\t\\t\\tif(count != 0){\\n\\t\\t\\t\\t\\tif((val >> 6) == 0b10){\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}   \\n\\n\\t\\t\\t\\t} else if(count == 0){ \\n\\t\\t\\t\\t\\tif((val >> 7) == 0b0){\\n\\t\\t\\t\\t\\t//1 byte...    \\n\\t\\t\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t\\t\\t}else if((val >> 5) == 0b110){\\n\\t\\t\\t\\t\\t//2 byte...\\n\\t\\t\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\t\\t}else if((val >> 4) == 0b1110){\\n\\t\\t\\t\\t\\t//3 byte...\\n\\t\\t\\t\\t\\t\\tcount = 2;\\n\\t\\t\\t\\t\\t}else if((val >> 3) == 0b11110){\\n\\t\\t\\t\\t\\t//4 byte...\\n\\t\\t\\t\\t\\t\\tcount =3;\\n\\t\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(count != 0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean validUtf8(int[] arr) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\t\\tint val = arr[i];\\n\\t\\t\\t\\tif(count != 0){\\n\\t\\t\\t\\t\\tif((val >> 6) == 0b10){\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 654771,
                "title": "python3-easy-to-understand-store-valid-sequences",
                "content": "For each starting point, try all possible 1 to 4 character sequences. If anyone matches, just update the starting point of your initial data. Also create a simple valid function for all possible 1 to 4 string sequences.\\n```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        data = [(\"{0:b}\".format(a)).zfill(8) for a in data]\\n        valid_map = {\\n            1: [\"0\"],\\n            2: [\"110\", \"10\"],\\n            3: [\"1110\", \"10\", \"10\"],\\n            4: [\"11110\", \"10\", \"10\", \"10\"],\\n        }\\n        def valid(trunc_data):\\n            valid_list = valid_map[len(trunc_data)]\\n            for i, a in enumerate(valid_list):\\n                if not trunc_data[i].startswith(a):\\n                    return False\\n            return True\\n        i = 0\\n        while i < len(data):\\n            isValid = False\\n            for j in range(4):\\n                if valid(data[i: i+j+1]):\\n                    isValid = True\\n                    i = i+j+1\\n                    break\\n            if isValid == False:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data: List[int]) -> bool:\\n        data = [(\"{0:b}\".format(a)).zfill(8) for a in data]\\n        valid_map = {\\n            1: [\"0\"],\\n            2: [\"110\", \"10\"],\\n            3: [\"1110\", \"10\", \"10\"],\\n            4: [\"11110\", \"10\", \"10\", \"10\"],\\n        }\\n        def valid(trunc_data):\\n            valid_list = valid_map[len(trunc_data)]\\n            for i, a in enumerate(valid_list):\\n                if not trunc_data[i].startswith(a):\\n                    return False\\n            return True\\n        i = 0\\n        while i < len(data):\\n            isValid = False\\n            for j in range(4):\\n                if valid(data[i: i+j+1]):\\n                    isValid = True\\n                    i = i+j+1\\n                    break\\n            if isValid == False:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603424,
                "title": "straightforward-python-solution",
                "content": "Using higher level Python functions, but keeping the implementation close to the description will help solve this problem.\\n\\n```\\nclass Solution:\\n\\n    def count_ones(self, binary):\\n        ones = 0\\n        for char in binary:\\n            if char == \\'1\\':\\n                ones +=1\\n            else:\\n                break\\n        return ones\\n\\n    def validUtf8(self, data: List[int]):\\n        binary_array = [bin(num).lstrip(\\'0b\\').zfill(8) for num in data]\\n        while binary_array:\\n            num_digits = self.count_ones(binary_array[0])\\n            # 1 byte character. first bit is 0 followed by unicode character\\n            if num_digits == 0:\\n                binary_array.pop(0)\\n            elif num_digits == 1 or num_digits > 4:\\n                # Rules of the problem? The num_digits cannot 1 or > 4\\n                return False\\n            else:\\n                # n byte character. For n-bytes character, the first n-bits are all one\\'s\\n                # num_digits digit popped off\\n                binary_array.pop(0)\\n                remaining_bits = num_digits - 1\\n                # Followed by n-1 bytes with most significant 2 bits being 10.\\n                for digit in range(remaining_bits):\\n                    if binary_array and binary_array[0][:2] == \\'10\\':\\n                        binary_array.pop(0)\\n                    else:\\n                        return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def count_ones(self, binary):\\n        ones = 0\\n        for char in binary:\\n            if char == \\'1\\':\\n                ones +=1\\n            else:\\n                break\\n        return ones\\n\\n    def validUtf8(self, data: List[int]):\\n        binary_array = [bin(num).lstrip(\\'0b\\').zfill(8) for num in data]\\n        while binary_array:\\n            num_digits = self.count_ones(binary_array[0])\\n            # 1 byte character. first bit is 0 followed by unicode character\\n            if num_digits == 0:\\n                binary_array.pop(0)\\n            elif num_digits == 1 or num_digits > 4:\\n                # Rules of the problem? The num_digits cannot 1 or > 4\\n                return False\\n            else:\\n                # n byte character. For n-bytes character, the first n-bits are all one\\'s\\n                # num_digits digit popped off\\n                binary_array.pop(0)\\n                remaining_bits = num_digits - 1\\n                # Followed by n-1 bytes with most significant 2 bits being 10.\\n                for digit in range(remaining_bits):\\n                    if binary_array and binary_array[0][:2] == \\'10\\':\\n                        binary_array.pop(0)\\n                    else:\\n                        return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396843,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        \\n        int b=0,i=0;\\n        while(i < data.size() )\\n        {\\n            std::string binary = std::bitset<8>(data[i]).to_string(); //to binary\\n            cout<<binary<<endl;\\n            b=0;\\n            int j = 0;\\n            while(binary[j++]==\\'1\\') b++;\\n            if(b==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n            else if(b==1 || b>4) return false;\\n            else\\n                for(int k = 1 ; k < b ; k++)\\n                {\\n                \\n                    \\n                    if(i+k >= data.size())\\n                        return false;\\n                    \\n                    if(std::bitset<8>(data[i+k]).to_string()[0]==\\'1\\' && \\n                       std::bitset<8>(data[i+k]).to_string()[1]==\\'0\\')\\n                        continue;\\n                    else\\n                        return false;\\n                }\\n            \\n            i+=b;\\n           cout<<i<<endl;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        \\n        int b=0,i=0;\\n        while(i < data.size() )\\n        {\\n            std::string binary = std::bitset<8>(data[i]).to_string(); //to binary\\n            cout<<binary<<endl;\\n            b=0;\\n            int j = 0;\\n            while(binary[j++]==\\'1\\') b++;\\n            if(b==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n            else if(b==1 || b>4) return false;\\n            else\\n                for(int k = 1 ; k < b ; k++)\\n                {\\n                \\n                    \\n                    if(i+k >= data.size())\\n                        return false;\\n                    \\n                    if(std::bitset<8>(data[i+k]).to_string()[0]==\\'1\\' && \\n                       std::bitset<8>(data[i+k]).to_string()[1]==\\'0\\')\\n                        continue;\\n                    else\\n                        return false;\\n                }\\n            \\n            i+=b;\\n           cout<<i<<endl;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 362651,
                "title": "naive-bit-manipulation-solution-in-python",
                "content": "```\\ndef validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        i, N = 0, len(data)\\n        \\n        while i < N:\\n            if data[i] >> 3 == 0b11110:\\n                for j in range(i+1,i+4):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 4\\n            elif data[i] >> 4 == 0b1110:\\n                for j in range(i+1,i+3):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 3\\n            elif data[i] >> 5 == 0b110:\\n                for j in range(i+1,i+2):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 2\\n            elif data[i] >> 7 == 0:\\n                i += 1\\n            else:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef validUtf8(self, data):\\n        \"\"\"\\n        :type data: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        i, N = 0, len(data)\\n        \\n        while i < N:\\n            if data[i] >> 3 == 0b11110:\\n                for j in range(i+1,i+4):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 4\\n            elif data[i] >> 4 == 0b1110:\\n                for j in range(i+1,i+3):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 3\\n            elif data[i] >> 5 == 0b110:\\n                for j in range(i+1,i+2):\\n                    if j >= N or data[j] >> 6 != 0b10:\\n                        return False\\n                i += 2\\n            elif data[i] >> 7 == 0:\\n                i += 1\\n            else:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 307478,
                "title": "a-simple-c-solution-nothing-fancy",
                "content": "A solution that is not fancy, not exciting at all, but for this particular problem, I think it works well and its logic is really simple.\\n\\nBeats 97.28% C++ submissions.\\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        for (int i = 0; i < n; ++i) {\\n            int firstByte = data[i] & 0x000000FF;\\n            if (firstByte >> 7 == 0) {\\n                continue;\\n            } else if (firstByte >> 5 == 0x06) {\\n                if (i >= n - 1 || (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else if (firstByte >> 4 == 0x0E) {\\n                if (i >= n - 2 || (data[++i] & 0x000000C0) != 0x80 || (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else if (firstByte >> 3 == 0x1E) {\\n                if (i >= n - 3 || (data[++i] & 0x000000C0) != 0x80 || (data[++i] & 0x000000C0) != 0x80 ||\\n                    (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int n = data.size();\\n        for (int i = 0; i < n; ++i) {\\n            int firstByte = data[i] & 0x000000FF;\\n            if (firstByte >> 7 == 0) {\\n                continue;\\n            } else if (firstByte >> 5 == 0x06) {\\n                if (i >= n - 1 || (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else if (firstByte >> 4 == 0x0E) {\\n                if (i >= n - 2 || (data[++i] & 0x000000C0) != 0x80 || (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else if (firstByte >> 3 == 0x1E) {\\n                if (i >= n - 3 || (data[++i] & 0x000000C0) != 0x80 || (data[++i] & 0x000000C0) != 0x80 ||\\n                    (data[++i] & 0x000000C0) != 0x80) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278113,
                "title": "java-0ms-only-using-bit-manipulation-well-commented",
                "content": "```\\npublic boolean validUtf8(int[] data) {\\n\\tif(data == null || data.length == 0)\\n\\t\\treturn true;\\n\\n\\tint i = 0;\\n\\twhile(i < data.length) {\\n\\t\\t// check is most significant bit is 0\\n\\t\\tif((data[i] & (1 << 7)) == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// count the no of ones for bytes\\n\\t\\tint j = 8;\\n\\t\\twhile(--j >= 1 && (data[i] & (1 << j)) >= 1) {}\\n\\n\\t\\t// calcs the end of bytes\\n\\t\\tint end = i + (8 - (j + 1) - 1);\\n\\n\\t\\t// returns false if numbytes = 1 or >= 5 or array doesn\\'t have enough bytes\\n\\t\\t// checks if the next bit is 0 ot not\\n\\t\\tif((data[i] & (1 << j)) >= 1 || end >= data.length || end == i || (end - i + 1) >= 5)  {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// checks if all the bytes starts with 10 or not\\n\\t\\tfor(int k = i + 1; k <= end; k++) {\\n\\t\\t\\tif(((data[k] & (1 << 7)) == 0) || ((data[k] & (1 << 6)) == 1))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// updates the i to begin with integer after end\\n\\t\\ti = end + 1;\\n\\t}\\n\\treturn true;\\n}",
                "solutionTags": [],
                "code": "```\\npublic boolean validUtf8(int[] data) {\\n\\tif(data == null || data.length == 0)\\n\\t\\treturn true;\\n\\n\\tint i = 0;\\n\\twhile(i < data.length) {\\n\\t\\t// check is most significant bit is 0\\n\\t\\tif((data[i] & (1 << 7)) == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// count the no of ones for bytes\\n\\t\\tint j = 8;\\n\\t\\twhile(--j >= 1 && (data[i] & (1 << j)) >= 1) {}\\n\\n\\t\\t// calcs the end of bytes\\n\\t\\tint end = i + (8 - (j + 1) - 1);\\n\\n\\t\\t// returns false if numbytes = 1 or >= 5 or array doesn\\'t have enough bytes\\n\\t\\t// checks if the next bit is 0 ot not\\n\\t\\tif((data[i] & (1 << j)) >= 1 || end >= data.length || end == i || (end - i + 1) >= 5)  {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// checks if all the bytes starts with 10 or not\\n\\t\\tfor(int k = i + 1; k <= end; k++) {\\n\\t\\t\\tif(((data[k] & (1 << 7)) == 0) || ((data[k] & (1 << 6)) == 1))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// updates the i to begin with integer after end\\n\\t\\ti = end + 1;\\n\\t}\\n\\treturn true;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 167817,
                "title": "self-documenting-bitwise-operation-java",
                "content": "\\n```java\\nclass Solution {\\n    \\n    private int mask1 = 0x80; // 1000 0000\\n    private int mask2 = 0xc0; // 1100 0000\\n    private int mask3 = 0xe0; // 1110 0000\\n    private int mask4 = 0xf0; // 1111 0000\\n    private int mask5 = 0xf8; // 1111 1000\\n    \\n    public boolean validUtf8(int[] data) {\\n        for (int i = 0; i < data.length; i++) {\\n            int head = data[i];\\n            int len = 0;\\n            if ((head & mask1) == 0) { // 0xxx xxxx\\n                continue;\\n            } else if ((head & mask3) == mask2) { // 110xx xxxx\\n                len = 1;\\n            } else if ((head & mask4) == mask3) { // 1110 xxxx\\n                len = 2;\\n            } else if ((head & mask5) == mask4) { // 1111 0xxx\\n                len = 3;\\n            } else {\\n                return false;\\n            }\\n            for (int j = 0; j < len; j++) {\\n                if (++i == data.length) { // need more byte\\n                    return false;\\n                } \\n                if ((data[i] & mask2) != mask1) { // not fllowed by 10xx xxxx\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    private int mask1 = 0x80; // 1000 0000\\n    private int mask2 = 0xc0; // 1100 0000\\n    private int mask3 = 0xe0; // 1110 0000\\n    private int mask4 = 0xf0; // 1111 0000\\n    private int mask5 = 0xf8; // 1111 1000\\n    \\n    public boolean validUtf8(int[] data) {\\n        for (int i = 0; i < data.length; i++) {\\n            int head = data[i];\\n            int len = 0;\\n            if ((head & mask1) == 0) { // 0xxx xxxx\\n                continue;\\n            } else if ((head & mask3) == mask2) { // 110xx xxxx\\n                len = 1;\\n            } else if ((head & mask4) == mask3) { // 1110 xxxx\\n                len = 2;\\n            } else if ((head & mask5) == mask4) { // 1111 0xxx\\n                len = 3;\\n            } else {\\n                return false;\\n            }\\n            for (int j = 0; j < len; j++) {\\n                if (++i == data.length) { // need more byte\\n                    return false;\\n                } \\n                if ((data[i] & mask2) != mask1) { // not fllowed by 10xx xxxx\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138023,
                "title": "logical-thinking-using-clear-java-code",
                "content": "According to the problem description, we have to decide how many bytes count towards a single character. \\nFor `data[i]`, \\n`numOnes = cntBytes(data[i]);` indicates that the first `numOnes` bits are all 1\\'s, i.e., `numOnes` bytes count towards a single character. \\nThere are several possibilities:\\n\\n* If `numOnes = 0`, `data[i]` is a valid 1-byte character, so we go further check for the next character.\\n* If `numOnes = 1`, `data[i]` is invalid.\\n* If `1 < numOnes <= 4`, \\n\\tif all `data[j]`, `for  i + 1 <= j <= i + numOnes - 1`,  are with most significant 2 bits being 10, `data[i]` is valid. \\n\\tAnd we start from `j + 1` to go further check for the next character.\\n* If `numOnes > 4`, `data[i]` is invalid.\\n\\n\\nThe clear code in Java is as below:\\n```\\n    public boolean validUtf8(int[] data) {\\n        if (data == null || data.length == 0) {\\n            return true;\\n        }\\n        int i = 0;\\n        int numOnes = 0;\\n        while (i < data.length) {\\n            numOnes = cntBytes(data[i]);\\n            if (numOnes == 0) {\\n                i++;\\n                continue;\\n            }\\n            if (numOnes == 1 || numOnes > 4) {\\n                return false;\\n            }\\n            if (i + numOnes - 1 >= data.length) {\\n                return false;\\n            }\\n            int j = i + 1;\\n            for (; j < i + numOnes; j++) {\\n                if (!isFirstTwoDigitValid(data[j])) {\\n                    return false;\\n                }\\n            }\\n            i = j;\\n        }\\n        return true;\\n    }\\n\\n    private static int cntBytes(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        if (binary.length() < 8) {\\n            return 0;\\n        }\\n        int numOnes = 0;\\n        for (char c : binary.toCharArray()) {\\n            if (c - \\'0\\' != 1) {\\n                break;\\n            }\\n            numOnes++;\\n        }\\n        return numOnes;\\n    }\\n\\n    private static boolean isFirstTwoDigitValid(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        if (binary.length() < 8) {\\n            return false;\\n        }\\n        return binary.startsWith(\"10\");\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean validUtf8(int[] data) {\\n        if (data == null || data.length == 0) {\\n            return true;\\n        }\\n        int i = 0;\\n        int numOnes = 0;\\n        while (i < data.length) {\\n            numOnes = cntBytes(data[i]);\\n            if (numOnes == 0) {\\n                i++;\\n                continue;\\n            }\\n            if (numOnes == 1 || numOnes > 4) {\\n                return false;\\n            }\\n            if (i + numOnes - 1 >= data.length) {\\n                return false;\\n            }\\n            int j = i + 1;\\n            for (; j < i + numOnes; j++) {\\n                if (!isFirstTwoDigitValid(data[j])) {\\n                    return false;\\n                }\\n            }\\n            i = j;\\n        }\\n        return true;\\n    }\\n\\n    private static int cntBytes(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        if (binary.length() < 8) {\\n            return 0;\\n        }\\n        int numOnes = 0;\\n        for (char c : binary.toCharArray()) {\\n            if (c - \\'0\\' != 1) {\\n                break;\\n            }\\n            numOnes++;\\n        }\\n        return numOnes;\\n    }\\n\\n    private static boolean isFirstTwoDigitValid(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        if (binary.length() < 8) {\\n            return false;\\n        }\\n        return binary.startsWith(\"10\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87469,
                "title": "test-case-with-more-than-4-bytes",
                "content": "There is a test case with: \\n```\\n[240,162,138,147,17]\\n# ^ true\\n```\\n\\nHowever since there are more than 4-bytes isn't this automatically an invalid utf-8 encoding?\\n```\\nA character in UTF8 can be from 1 to 4 bytes long\\n```",
                "solutionTags": [],
                "code": "```\\n[240,162,138,147,17]\\n# ^ true\\n```\n```\\nA character in UTF8 can be from 1 to 4 bytes long\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87502,
                "title": "python-self-explanatory-and-easy-to-understand-solution-using-bit-manipulation",
                "content": "```\\nclass Solution(object):\\n    def countOne(self, num):\\n        count = 0\\n        for i in xrange(8):\\n            if num >> (7-i) & 1 == 1: count += 1\\n            else: break\\n        return count\\n        \\n    def validUtf8(self, data):\\n        n = len(data); ind = 0\\n        while ind < n:\\n            m = self.countOne(data[ind])\\n            if ind + m > n: return False\\n            if m == 0:\\n                if (data[ind] >> 7) & 1 != 0: return False\\n            elif m == 1 or m > 4: return False\\n            else:\\n                for i in xrange(m):\\n                    if (data[ind] >> (7-i)) & 1 != 1: return False\\n                if (data[ind] >> (7-i-1)) & 1 != 0: return False\\n                for i in xrange(ind+1, ind+m):\\n                    if (data[i] >> 7) & 1 != 1: return False\\n                    if (data[i] >> 6) & 1 != 0: return False\\n            ind += m\\n            if m == 0: ind += 1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countOne(self, num):\\n        count = 0\\n        for i in xrange(8):\\n            if num >> (7-i) & 1 == 1: count += 1\\n            else: break\\n        return count\\n        \\n    def validUtf8(self, data):\\n        n = len(data); ind = 0\\n        while ind < n:\\n            m = self.countOne(data[ind])\\n            if ind + m > n: return False\\n            if m == 0:\\n                if (data[ind] >> 7) & 1 != 0: return False\\n            elif m == 1 or m > 4: return False\\n            else:\\n                for i in xrange(m):\\n                    if (data[ind] >> (7-i)) & 1 != 1: return False\\n                if (data[ind] >> (7-i-1)) & 1 != 0: return False\\n                for i in xrange(ind+1, ind+m):\\n                    if (data[i] >> 7) & 1 != 1: return False\\n                    if (data[i] >> 6) & 1 != 0: return False\\n            ind += m\\n            if m == 0: ind += 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87514,
                "title": "java-7ms-o-n-solution-using-bit-manipulation-with-explanation",
                "content": "Thanks to the idea from http://bookshadow.com/weblog/2016/09/04/leetcode-utf-8-validation/\\n\\nI wrote the Java version.\\n\\nThe basic idea is:\\n\\n1. First determine if a n-bytes character start with '0', '110', '1110' or '11110' and find out *n*.\\n2. Check if the following *n-1* bytes start with '10'.\\n3. Do the same thing to next character until the end of the array *data*.\\n\\n```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int[] masks = new int[]{0x0, 0x80, 0xE0, 0xF0, 0xF8};\\n        int[] bits = new int[]{0x0, 0x0, 0xC0, 0xE0, 0xF0};\\n        int start = 0;\\n        while(start < data.length) {\\n            int n;\\n            // start from a character\\n            // determine its number of bytes (n-bytes) \\n            for(n = 4; n >= 0; n--) {\\n                if((data[start] & masks[n]) == bits[n]) break;\\n            }\\n            // if not beginning with '0', '110', '1110', '11110'\\n            // or not have enough length\\n            // return false\\n            if(n == 0 || start + n > data.length ) return false;\\n            for(int j = 1; j < n; j++) {\\n                // check if followed by n-1 bytes beginning with '10'.\\n                if((data[start+j] & 0xC0) != 0x80) return false;\\n            }\\n            // continue with next character\\n            start += n;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int[] masks = new int[]{0x0, 0x80, 0xE0, 0xF0, 0xF8};\\n        int[] bits = new int[]{0x0, 0x0, 0xC0, 0xE0, 0xF0};\\n        int start = 0;\\n        while(start < data.length) {\\n            int n;\\n            // start from a character\\n            // determine its number of bytes (n-bytes) \\n            for(n = 4; n >= 0; n--) {\\n                if((data[start] & masks[n]) == bits[n]) break;\\n            }\\n            // if not beginning with '0', '110', '1110', '11110'\\n            // or not have enough length\\n            // return false\\n            if(n == 0 || start + n > data.length ) return false;\\n            for(int j = 1; j < n; j++) {\\n                // check if followed by n-1 bytes beginning with '10'.\\n                if((data[start+j] & 0xC0) != 0x80) return false;\\n            }\\n            // continue with next character\\n            start += n;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87527,
                "title": "clean-c-code",
                "content": "```\\nstatic int  mask1      = 0x80, pattern1      = 0x00, \\n            mask2      = 0xe0, pattern2      = 0xc0,\\n            mask3      = 0xf0, pattern3      = 0xe0,\\n            mask4      = 0xf8, pattern4      = 0xf0,\\n            maskOther  = 0xc0, patternOther  = 0x80;\\n\\nstatic int validContByte(int c) {\\n    return (c & maskOther) == patternOther;\\n}\\n\\nstatic int valid1(int c) {\\n    return (c & mask1) == pattern1;\\n}\\n\\nstatic int valid2(int c) {\\n    return (c & mask2) == pattern2;\\n}\\n\\nstatic int valid3(int c) {\\n    return (c & mask3) == pattern3;\\n}\\n\\nstatic int valid4(int c) {\\n    return (c & mask4) == pattern4;\\n}\\n\\nbool validUtf8(int* data, int dataSize) {\\n    int i, c, contBytes;\\n    \\n    for (i = 0; i < dataSize; i++) {\\n        c = data[i];\\n        if (valid1(c))\\n            continue;\\n        else if (valid2(c))\\n            contBytes = 1;\\n        else if (valid3(c))\\n            contBytes = 2;\\n        else if (valid4(c))\\n            contBytes = 3;\\n        else\\n            return false;\\n            \\n        while (contBytes-- > 0)\\n            if (++i >= dataSize || !validContByte(data[i]))\\n                return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int  mask1      = 0x80, pattern1      = 0x00, \\n            mask2      = 0xe0, pattern2      = 0xc0,\\n            mask3      = 0xf0, pattern3      = 0xe0,\\n            mask4      = 0xf8, pattern4      = 0xf0,\\n            maskOther  = 0xc0, patternOther  = 0x80;\\n\\nstatic int validContByte(int c) {\\n    return (c & maskOther) == patternOther;\\n}\\n\\nstatic int valid1(int c) {\\n    return (c & mask1) == pattern1;\\n}\\n\\nstatic int valid2(int c) {\\n    return (c & mask2) == pattern2;\\n}\\n\\nstatic int valid3(int c) {\\n    return (c & mask3) == pattern3;\\n}\\n\\nstatic int valid4(int c) {\\n    return (c & mask4) == pattern4;\\n}\\n\\nbool validUtf8(int* data, int dataSize) {\\n    int i, c, contBytes;\\n    \\n    for (i = 0; i < dataSize; i++) {\\n        c = data[i];\\n        if (valid1(c))\\n            continue;\\n        else if (valid2(c))\\n            contBytes = 1;\\n        else if (valid3(c))\\n            contBytes = 2;\\n        else if (valid4(c))\\n            contBytes = 3;\\n        else\\n            return false;\\n            \\n        while (contBytes-- > 0)\\n            if (++i >= dataSize || !validContByte(data[i]))\\n                return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87459,
                "title": "java-solution",
                "content": "Followings are the rules:\\n1-byte: ```[0, 127]```\\n2-byte: ```[192, 223], [128, 191]```\\n3-byte: ```[224, 239], [128, 191], [128, 191]```\\n4-byte: ```[240, 247], [128, 191], [128, 191], [128, 191]```\\n5-byte: ```[248, 251], [128, 191], [128, 191], [128, 191], [128, 191]```\\n6-byte: ```[252, 254], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191]```\\n7-byte: ```[255, 255], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191]```\\n```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int index = 0, tailLen = 0;\\n        while(index < data.length) {\\n            tailLen = getTailLen(data[index]);\\n            \\n            // it is 1-byte character\\n            if(tailLen == 0) {\\n                index++;\\n                continue;\\n            }\\n            \\n            // the first 8-bit is invalid, or the tail is invalid\\n            if(tailLen == -1 || !isTailValid(data, index + 1, index + tailLen)) return false;\\n            index += tailLen + 1;\\n        }\\n        return true;\\n    }\\n    \\n    private int getTailLen(int num) {\\n        if(num <= 127) return 0;\\n        else if(num <= 191) return -1;\\n        else if(num <= 223) return 1;\\n        else if(num <= 239) return 2;\\n        else if(num <= 247) return 3;\\n        else if(num <= 251) return 4;\\n        else if(num <= 254) return 5;\\n        else return 6;\\n    }\\n    \\n    private boolean isTailValid(int[] data, int start, int end) {\\n        if(start >= data.length || end >= data.length) return false;\\n        for(int i = start; i <= end; i++) {\\n            if(data[i] < 128 || data[i] > 191) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```[0, 127]```\n```[192, 223], [128, 191]```\n```[224, 239], [128, 191], [128, 191]```\n```[240, 247], [128, 191], [128, 191], [128, 191]```\n```[248, 251], [128, 191], [128, 191], [128, 191], [128, 191]```\n```[252, 254], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191]```\n```[255, 255], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191], [128, 191]```\n```\\npublic class Solution {\\n    public boolean validUtf8(int[] data) {\\n        int index = 0, tailLen = 0;\\n        while(index < data.length) {\\n            tailLen = getTailLen(data[index]);\\n            \\n            // it is 1-byte character\\n            if(tailLen == 0) {\\n                index++;\\n                continue;\\n            }\\n            \\n            // the first 8-bit is invalid, or the tail is invalid\\n            if(tailLen == -1 || !isTailValid(data, index + 1, index + tailLen)) return false;\\n            index += tailLen + 1;\\n        }\\n        return true;\\n    }\\n    \\n    private int getTailLen(int num) {\\n        if(num <= 127) return 0;\\n        else if(num <= 191) return -1;\\n        else if(num <= 223) return 1;\\n        else if(num <= 239) return 2;\\n        else if(num <= 247) return 3;\\n        else if(num <= 251) return 4;\\n        else if(num <= 254) return 5;\\n        else return 6;\\n    }\\n    \\n    private boolean isTailValid(int[] data, int start, int end) {\\n        if(start >= data.length || end >= data.length) return false;\\n        for(int i = start; i <= end; i++) {\\n            if(data[i] < 128 || data[i] > 191) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098708,
                "title": "bit-manipulation-java-kotlin-hyder-nabi",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int nextRemainingBytes = 0;\\n\\n        for(int d : data) {\\n          if(nextRemainingBytes == 0) {\\n            if(d>>3 == 0b11110) nextRemainingBytes = 3;\\n            else if(d>>4 == 0b1110) nextRemainingBytes = 2;\\n            else if(d>>5 == 0b110) nextRemainingBytes = 1;\\n            else if(d>>7 != 0b0) return false;\\n          } else {\\n            if(d>>6 == 0b10)\\n              nextRemainingBytes--;\\n            else \\n              return false;\\n          }\\n        }\\n        if(nextRemainingBytes == 0)\\n          return true;\\n        else \\n          return false;\\n    }\\n}\\n```\\n\\n# Kotlin Code\\n```\\nclass Solution {\\n    fun validUtf8(data: IntArray): Boolean {\\n        var nextRemainingBytes : Int = 0\\n        \\n        for(d in data) {\\n            if(nextRemainingBytes == 0) {\\n                if(d shr 3 == 0b11110)  nextRemainingBytes = 3 \\n            \\telse if(d shr 4 == 0b1110) nextRemainingBytes = 2\\n            \\telse if(d shr 5 == 0b110) nextRemainingBytes = 1\\n            \\telse if(d shr 7 != 0b0) return false\\n            } else {\\n                if(d shr 6 == 0b10)\\n                \\tnextRemainingBytes--\\n                else \\n                \\treturn false\\n            }\\n        }\\n        return if(nextRemainingBytes == 0) true else false \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int nextRemainingBytes = 0;\\n\\n        for(int d : data) {\\n          if(nextRemainingBytes == 0) {\\n            if(d>>3 == 0b11110) nextRemainingBytes = 3;\\n            else if(d>>4 == 0b1110) nextRemainingBytes = 2;\\n            else if(d>>5 == 0b110) nextRemainingBytes = 1;\\n            else if(d>>7 != 0b0) return false;\\n          } else {\\n            if(d>>6 == 0b10)\\n              nextRemainingBytes--;\\n            else \\n              return false;\\n          }\\n        }\\n        if(nextRemainingBytes == 0)\\n          return true;\\n        else \\n          return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun validUtf8(data: IntArray): Boolean {\\n        var nextRemainingBytes : Int = 0\\n        \\n        for(d in data) {\\n            if(nextRemainingBytes == 0) {\\n                if(d shr 3 == 0b11110)  nextRemainingBytes = 3 \\n            \\telse if(d shr 4 == 0b1110) nextRemainingBytes = 2\\n            \\telse if(d shr 5 == 0b110) nextRemainingBytes = 1\\n            \\telse if(d shr 7 != 0b0) return false\\n            } else {\\n                if(d shr 6 == 0b10)\\n                \\tnextRemainingBytes--\\n                else \\n                \\treturn false\\n            }\\n        }\\n        return if(nextRemainingBytes == 0) true else false \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009640,
                "title": "python-simple-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validUtf8(self, data):\\n        count = 0\\n        \\n        for byte in data:\\n            if count:\\n                if byte >> 6 == 0b10:\\n                    count -= 1\\n                else:\\n                    return False\\n            else:\\n                if byte >> 7 == 0:\\n                    count = 0\\n                elif byte >> 5 == 0b110:\\n                    count = 1\\n                elif byte >> 4 == 0b1110:\\n                    count = 2\\n                elif byte >> 3 == 0b11110:\\n                    count = 3\\n                else:\\n                    return False\\n                \\n        return count == 0\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validUtf8(self, data):\\n        count = 0\\n        \\n        for byte in data:\\n            if count:\\n                if byte >> 6 == 0b10:\\n                    count -= 1\\n                else:\\n                    return False\\n            else:\\n                if byte >> 7 == 0:\\n                    count = 0\\n                elif byte >> 5 == 0b110:\\n                    count = 1\\n                elif byte >> 4 == 0b1110:\\n                    count = 2\\n                elif byte >> 3 == 0b11110:\\n                    count = 3\\n                else:\\n                    return False\\n                \\n        return count == 0\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003871,
                "title": "1ms-in-rust-beats-90",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let n: usize = data.len();\\n        let mut i: usize = 0;\\n\\n        while i < n {\\n            let byte: i32 = data[i];\\n            let offset: usize = if byte & 0x80 == 0x0 {\\n                    0\\n                } else if byte & 0xe0 == 0xc0 {\\n                    1\\n                } else if byte & 0xf0 == 0xe0 {\\n                    2\\n                } else if byte & 0xf8 == 0xf0 {\\n                    3\\n                } else {\\n                    return false;\\n                };\\n\\n            if offset == 0 {\\n                i += 1;\\n                continue;\\n            }\\n\\n            let mut j: usize = 1;\\n\\n            while i + j < n && j <= offset {\\n                match data[i + j] & 0xc0 == 0x80 {\\n                    true => j += 1,\\n                    false => return false,\\n                }\\n            }\\n\\n            match j == offset + 1 {\\n                true => i += offset + 1,\\n                false => return false,\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_utf8(data: Vec<i32>) -> bool {\\n        let n: usize = data.len();\\n        let mut i: usize = 0;\\n\\n        while i < n {\\n            let byte: i32 = data[i];\\n            let offset: usize = if byte & 0x80 == 0x0 {\\n                    0\\n                } else if byte & 0xe0 == 0xc0 {\\n                    1\\n                } else if byte & 0xf0 == 0xe0 {\\n                    2\\n                } else if byte & 0xf8 == 0xf0 {\\n                    3\\n                } else {\\n                    return false;\\n                };\\n\\n            if offset == 0 {\\n                i += 1;\\n                continue;\\n            }\\n\\n            let mut j: usize = 1;\\n\\n            while i + j < n && j <= offset {\\n                match data[i + j] & 0xc0 == 0x80 {\\n                    true => j += 1,\\n                    false => return false,\\n                }\\n            }\\n\\n            match j == offset + 1 {\\n                true => i += offset + 1,\\n                false => return false,\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003307,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    let mostSig = 1<<7;\\n    let secSig = 1<<6\\n    for (let n of data) {\\n        if (count == 0) {\\n            let mask = 1<<7;\\n            while (n & mask) {\\n                mask = mask>>1;\\n                count++;\\n            }\\n            if (count == 0) continue;\\n            if (count == 1 || count > 4) return false;\\n        } else {\\n            if (!(n&mostSig && !(n&secSig))) return false;\\n        }\\n        count--;\\n    }\\n    return count == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} data\\n * @return {boolean}\\n */\\nvar validUtf8 = function(data) {\\n    let count = 0;\\n    let mostSig = 1<<7;\\n    let secSig = 1<<6\\n    for (let n of data) {\\n        if (count == 0) {\\n            let mask = 1<<7;\\n            while (n & mask) {\\n                mask = mask>>1;\\n                count++;\\n            }\\n            if (count == 0) continue;\\n            if (count == 1 || count > 4) return false;\\n        } else {\\n            if (!(n&mostSig && !(n&secSig))) return false;\\n        }\\n        count--;\\n    }\\n    return count == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830916,
                "title": "c-bit-manipulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int cur=0,sz=data.size();\\n        int cntBytes=0;\\n        int multiByteStartIndex=0;\\n        while (cur<sz){\\n            if ((data[cur] & 1<<7)==0) {\\n                cur++;\\n            }\\n            else {\\n                cntBytes =0;\\n                while (cntBytes < 4 && (data[cur] & (1<<(7-cntBytes-1))) >0) {\\n                    //cout << cntBytes << \" - \" << (data[cur] & (1<<(7-cntBytes-1))) << endl;\\n                    cntBytes++;\\n                }\\n                \\n                if (cntBytes ==4 || cntBytes==0) return false;\\n                \\n                multiByteStartIndex = cur+1;\\n\\n                while (multiByteStartIndex<sz && cntBytes>0 && (data[multiByteStartIndex]>>6) ==2) {\\n                    cntBytes--;\\n                    multiByteStartIndex++;\\n\\n                }\\n                if (cntBytes>0) return false;\\n                cur =multiByteStartIndex;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int cur=0,sz=data.size();\\n        int cntBytes=0;\\n        int multiByteStartIndex=0;\\n        while (cur<sz){\\n            if ((data[cur] & 1<<7)==0) {\\n                cur++;\\n            }\\n            else {\\n                cntBytes =0;\\n                while (cntBytes < 4 && (data[cur] & (1<<(7-cntBytes-1))) >0) {\\n                    //cout << cntBytes << \" - \" << (data[cur] & (1<<(7-cntBytes-1))) << endl;\\n                    cntBytes++;\\n                }\\n                \\n                if (cntBytes ==4 || cntBytes==0) return false;\\n                \\n                multiByteStartIndex = cur+1;\\n\\n                while (multiByteStartIndex<sz && cntBytes>0 && (data[multiByteStartIndex]>>6) ==2) {\\n                    cntBytes--;\\n                    multiByteStartIndex++;\\n\\n                }\\n                if (cntBytes>0) return false;\\n                cur =multiByteStartIndex;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3811773,
                "title": "very-straightforward-bit-manipulation-solution",
                "content": "# Intuition\\nIterate over ints, take lowest byte, check prefixes and check needed amount of bytes afert that.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    bool byteStartsWith10(int d) {\\n        const unsigned char byte = (d & 0x000000FF);\\n        return (byte >> 6) == 0b00000010;\\n    }\\n\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int i = 0;\\n        while (i < data.size()) {\\n            const unsigned char byte = (data[i] & 0x000000FF);\\n            \\n            int s = 0;\\n\\n            // check prefix of current byte\\n            // make sure that is it among correct prefixes\\n            if ((byte >> 3) == 0b00011110) {\\n                s = 3;\\n            } else if ((byte >> 4) == 0b00001110) {\\n                s = 2;\\n            } else if ((byte >> 5) == 0b00000110) {\\n                s = 1;\\n            } else if ((byte >> 7) == 0) {\\n                s = 0;\\n            } else {\\n                return false;\\n            }\\n\\n            i += 1;\\n            // check that we have s bytes in input and all of those bytes do start from 10\\n            for (int j = 0;j < s;j ++) {\\n                if ((i + j) >= data.size() || !byteStartsWith10(data[i + j])) {\\n                    return false;\\n                }\\n            }\\n            i += s;\\n        }\\n\\n        return true;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool byteStartsWith10(int d) {\\n        const unsigned char byte = (d & 0x000000FF);\\n        return (byte >> 6) == 0b00000010;\\n    }\\n\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        int i = 0;\\n        while (i < data.size()) {\\n            const unsigned char byte = (data[i] & 0x000000FF);\\n            \\n            int s = 0;\\n\\n            // check prefix of current byte\\n            // make sure that is it among correct prefixes\\n            if ((byte >> 3) == 0b00011110) {\\n                s = 3;\\n            } else if ((byte >> 4) == 0b00001110) {\\n                s = 2;\\n            } else if ((byte >> 5) == 0b00000110) {\\n                s = 1;\\n            } else if ((byte >> 7) == 0) {\\n                s = 0;\\n            } else {\\n                return false;\\n            }\\n\\n            i += 1;\\n            // check that we have s bytes in input and all of those bytes do start from 10\\n            for (int j = 0;j < s;j ++) {\\n                if ((i + j) >= data.size() || !byteStartsWith10(data[i + j])) {\\n                    return false;\\n                }\\n            }\\n            i += s;\\n        }\\n\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793455,
                "title": "java-fastest-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    int leftToCheck = 0;\\n\\n    for (final int d : data)\\n      if (leftToCheck == 0) {\\n        if ((d >> 3) == 0b11110)\\n          leftToCheck = 3;\\n        else if ((d >> 4) == 0b1110)\\n          leftToCheck = 2;\\n        else if ((d >> 5) == 0b110)\\n          leftToCheck = 1;\\n        else if ((d >> 7) == 0b0)\\n          leftToCheck = 0;\\n        else\\n          return false;\\n      } else {\\n        if ((d >> 6) != 0b10)\\n          return false;\\n        --leftToCheck;\\n      }\\n\\n    return leftToCheck == 0;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    int leftToCheck = 0;\\n\\n    for (final int d : data)\\n      if (leftToCheck == 0) {\\n        if ((d >> 3) == 0b11110)\\n          leftToCheck = 3;\\n        else if ((d >> 4) == 0b1110)\\n          leftToCheck = 2;\\n        else if ((d >> 5) == 0b110)\\n          leftToCheck = 1;\\n        else if ((d >> 7) == 0b0)\\n          leftToCheck = 0;\\n        else\\n          return false;\\n      } else {\\n        if ((d >> 6) != 0b10)\\n          return false;\\n        --leftToCheck;\\n      }\\n\\n    return leftToCheck == 0;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793454,
                "title": "java-fastest-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    int leftToCheck = 0;\\n\\n    for (final int d : data)\\n      if (leftToCheck == 0) {\\n        if ((d >> 3) == 0b11110)\\n          leftToCheck = 3;\\n        else if ((d >> 4) == 0b1110)\\n          leftToCheck = 2;\\n        else if ((d >> 5) == 0b110)\\n          leftToCheck = 1;\\n        else if ((d >> 7) == 0b0)\\n          leftToCheck = 0;\\n        else\\n          return false;\\n      } else {\\n        if ((d >> 6) != 0b10)\\n          return false;\\n        --leftToCheck;\\n      }\\n\\n    return leftToCheck == 0;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean validUtf8(int[] data) {\\n    int leftToCheck = 0;\\n\\n    for (final int d : data)\\n      if (leftToCheck == 0) {\\n        if ((d >> 3) == 0b11110)\\n          leftToCheck = 3;\\n        else if ((d >> 4) == 0b1110)\\n          leftToCheck = 2;\\n        else if ((d >> 5) == 0b110)\\n          leftToCheck = 1;\\n        else if ((d >> 7) == 0b0)\\n          leftToCheck = 0;\\n        else\\n          return false;\\n      } else {\\n        if ((d >> 6) != 0b10)\\n          return false;\\n        --leftToCheck;\\n      }\\n\\n    return leftToCheck == 0;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761726,
                "title": "c-concise",
                "content": "# Approach\\nBit Operation\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        auto f = [](int a, int i) {\\n            return a >> i == (0xff >> i) - 1;\\n        };\\n\\n        int cnt = 0;\\n        for (int a : data)\\n            if (!cnt) {\\n                if (f(a, 5))\\n                    cnt = 1;\\n                else if (f(a, 4))\\n                    cnt = 2;\\n                else if (f(a, 3))\\n                    cnt = 3;\\n                else if (!f(a, 7))\\n                    return false;\\n            }\\n            else {\\n                if (!f(a, 6))\\n                    return false;\\n\\n                cnt--;\\n            }\\n\\n        return !cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validUtf8(vector<int>& data) {\\n        auto f = [](int a, int i) {\\n            return a >> i == (0xff >> i) - 1;\\n        };\\n\\n        int cnt = 0;\\n        for (int a : data)\\n            if (!cnt) {\\n                if (f(a, 5))\\n                    cnt = 1;\\n                else if (f(a, 4))\\n                    cnt = 2;\\n                else if (f(a, 3))\\n                    cnt = 3;\\n                else if (!f(a, 7))\\n                    return false;\\n            }\\n            else {\\n                if (!f(a, 6))\\n                    return false;\\n\\n                cnt--;\\n            }\\n\\n        return !cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744780,
                "title": "java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes=0;\\n        for(int value : data){\\n            if(rbytes==0){\\n                    if((value>>7)==0b0){\\n                        rbytes=0;\\n                    }else if((value>>5)==0b110){\\n                        rbytes=1;\\n                    }else if((value>>4)==0b1110){\\n                        rbytes=2;\\n                    }else if((value>>3)==0b11110){\\n                        rbytes=3;\\n                     } else{\\n                        return false;\\n                    }\\n            }\\n            else{\\n                if((value>> 6) ==0b10){\\n                    rbytes--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(rbytes==0)return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes=0;\\n        for(int value : data){\\n            if(rbytes==0){\\n                    if((value>>7)==0b0){\\n                        rbytes=0;\\n                    }else if((value>>5)==0b110){\\n                        rbytes=1;\\n                    }else if((value>>4)==0b1110){\\n                        rbytes=2;\\n                    }else if((value>>3)==0b11110){\\n                        rbytes=3;\\n                     } else{\\n                        return false;\\n                    }\\n            }\\n            else{\\n                if((value>> 6) ==0b10){\\n                    rbytes--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(rbytes==0)return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744779,
                "title": "java-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes=0;\\n        for(int value : data){\\n            if(rbytes==0){\\n                    if((value>>7)==0b0){\\n                        rbytes=0;\\n                    }else if((value>>5)==0b110){\\n                        rbytes=1;\\n                    }else if((value>>4)==0b1110){\\n                        rbytes=2;\\n                    }else if((value>>3)==0b11110){\\n                        rbytes=3;\\n                     } else{\\n                        return false;\\n                    }\\n            }\\n            else{\\n                if((value>> 6) ==0b10){\\n                    rbytes--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(rbytes==0)return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validUtf8(int[] data) {\\n        int rbytes=0;\\n        for(int value : data){\\n            if(rbytes==0){\\n                    if((value>>7)==0b0){\\n                        rbytes=0;\\n                    }else if((value>>5)==0b110){\\n                        rbytes=1;\\n                    }else if((value>>4)==0b1110){\\n                        rbytes=2;\\n                    }else if((value>>3)==0b11110){\\n                        rbytes=3;\\n                     } else{\\n                        return false;\\n                    }\\n            }\\n            else{\\n                if((value>> 6) ==0b10){\\n                    rbytes--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(rbytes==0)return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564610,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1565196,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1565750,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1569250,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1572662,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1566787,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1572602,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1566544,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1576439,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1568017,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1564610,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1565196,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1565750,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1569250,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1572662,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1566787,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1572602,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1566544,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1576439,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            },
            {
                "id": 1568017,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char.\\nI feel more likely working on an English reading comprehension problem rather than algorithm.\\nSigh."
                    },
                    {
                        "username": "athmao",
                        "content": "Maybe I\\'m just illiterate but I can\\'t for the life of me understand what the problem is asking of me, even after reading through their examples. I don\\'t want to look through people\\'s answers just to understand the problem since I want to give it a try tackling it myself. Does anyone care to explain wtf this question is asking?"
                    },
                    {
                        "username": "whglamrock",
                        "content": "For those who are not familiar with UTF-8, the two examples given didn't tell us what should we do if the number like 11110xxx shows up more than once.\\n\\nIt appears to me that once we found out one complete sequence like 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx, we can disregard the rest. But the truth is until lots of 'wrong answer's I couldn't figure out that we needa repeat the sequence cycle after cycle till finishing the list data."
                    },
                    {
                        "username": "sjanarth",
                        "content": "Could someone explain why [250,145,145,145,145] is considered invalid?\\n\\nMaps to:\\n[11111010][10010001][10010001][10010001][10010001]\\n\\nThe first byte is valid and requires the four following bytes to begin with 10 which they do."
                    },
                    {
                        "username": "minchaej",
                        "content": "[@mhryshyn](/mhryshyn) woah thank you so much! this was so helpful!"
                    },
                    {
                        "username": "mhryshyn",
                        "content": "I might be wrong, but it states: \"A character in UTF8 can be from 1 to 4 bytes long\". And this sequence has length 5"
                    },
                    {
                        "username": "rajachakraborti",
                        "content": "[240,162,138,147,145]\\nI wonder if this is a wrong test case. Till 147 the tail has 10xxxxxxx.. pattern."
                    },
                    {
                        "username": "isaacphiri315",
                        "content": "A character in UTF8 can be from 1 to 4 bytes long, [240,162,138,147,145] <== This is 5 bytes. It would be valid if it were [240,162,138,147] => \\uD848\\uDE93 .  Or if the 5th byte was a 1 byte character."
                    },
                    {
                        "username": "henoktsegaye",
                        "content": "I have the same issue it should return true for this one according to the problem description"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "My solution gets \"Wrong Answer\" because it returns `false` for this test case: `[240,130,138,147]`. But the bit strings are `[11110000, 10000010, 10001010, 10010011]`, meaning the actual character number (the 'x' parts) is `000000010001010010011`, which in hexadecimal is `0x2293`, which is outside the range `0x10000-0x10FFFF` for 4-byte characters. So it's invalid and the expected answer `true` is wrong."
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "This is a stupid question, especailly the test cases.\\nAccording to the description, it looks like the UTF8 value cannot be larger than 4 bytes. \\nHowever, the result of test case [240,162,138,147,17] is \"TRUE\"!????\\nWell, let\\'s allow larger than 4 bytes values, BOOM!!!!!!!!!! Test case [250, 145, 145, 145, 145] returns \"FALSE\"!?????\\n\\n250 = 11111010\\n145 = 10010001"
                    },
                    {
                        "username": "sue-may",
                        "content": "Anyone could help with this question? What does it mean?"
                    },
                    {
                        "username": "adi_pulekar",
                        "content": "Hi guys,\\nCan anyone explain why following test case should have false as it is answer?\\n\\n[250,145,145,145,145]... this is case #47/49\\n\\nShouldn\\'t the answer be true?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "None of the patterns can match 250 which is 0b11111010."
                    },
                    {
                        "username": "astrogg",
                        "content": "For example, [193, 156] will be considered true, but the number is out of range for n=2 (0x80-0x7FF)."
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Pairs",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the number of <strong>reverse pairs</strong> in the array</em>.</p>\n\n<p>A <strong>reverse pair</strong> is a pair <code>(i, j)</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; nums.length</code> and</li>\n\t<li><code>nums[i] &gt; 2 * nums[j]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The reverse pairs are:\n(1, 4) --&gt; nums[1] = 3, nums[4] = 1, 3 &gt; 2 * 1\n(3, 4) --&gt; nums[3] = 3, nums[4] = 1, 3 &gt; 2 * 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,3,5,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The reverse pairs are:\n(1, 4) --&gt; nums[1] = 4, nums[4] = 1, 4 &gt; 2 * 1\n(2, 4) --&gt; nums[2] = 3, nums[4] = 1, 3 &gt; 2 * 1\n(3, 4) --&gt; nums[3] = 5, nums[4] = 1, 5 &gt; 2 * 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 97268,
                "title": "general-principles-behind-problems-similar-to-reverse-pairs",
                "content": "It looks like a host of solutions are out there (`BST`-based, `BIT`-based, `Merge-sort`-based). Here I\\'d like to focus on the general principles behind these solutions and its possible application to a number of similar problems.\\n\\nThe fundamental idea is very simple: **break down the array and solve for the subproblems**.\\n\\nA breakdown of an array naturally reminds us of subarrays. To smoothen our following discussion, let\\'s assume the input array is `nums`, with a total of `n` elements. Let `nums[i, j]` denote the subarray starting from index `i` to index `j` (both inclusive), `T(i, j)` as the same problem applied to this subarray (for example, for [**Reverse Pairs**](https://leetcode.com/problems/reverse-pairs/?tab=Description),  `T(i, j)` will represent the total number of important reverse pairs for subarray `nums[i, j]`). \\n\\nWith the definition above, it\\'s straightforward to identify our original problem as `T(0, n - 1)`. Now the key point is how to construct solutions to the original problem from its subproblems. This is essentially equivalent to building recurrence relations for `T(i, j)`. Since if we can find solutions to `T(i, j)` from its subproblems, we surely can build solutions to larger subarrays until eventually the whole array is spanned.\\n\\nWhile there may be many ways for establishing recurrence relations for `T(i, j)`, here I will only introduce the following two common ones:\\n\\n1. `T(i, j) = T(i, j - 1) + C`, i.e., elements will be processed sequentially and `C` denotes the subproblem for processing the last element of subarray `nums[i, j]`. We will call this sequential recurrence relation.\\n\\n2. `T(i, j) = T(i, m) + T(m + 1, j) + C` where `m = (i+j)/2`, i.e., subarray `nums[i, j]` will be further partitioned into two parts and `C` denotes the subproblem for combining the two parts. We will call this partition recurrence relation.\\n\\nFor either case, the nature of the subproblem `C` will depend on the problem under consideration, and it will determine the overall time complexity of the original problem. So usually it\\'s crucial to find efficient algorithm for solving this subproblem in order to have better time performance. Also pay attention to possibilities of overlapping subproblems, in which case a dynamic programming (DP) approach would be preferred.\\n\\nNext, I will apply these two recurrence relations to this problem \"Reverse Pairs\" and list some solutions for your reference.\\n\\n---\\n**`I -- Sequential recurrence relation`**\\n\\nAgain we assume the input array is `nums` with `n` elements and `T(i, j)` denotes the total number of important reverse pairs for subarray `nums[i, j]`. For sequential recurrence relation, we can set `i = 0`, i.e., the subarray always starts from the beginning. Therefore we end up with:\\n\\n`T(0, j) = T(0, j - 1) + C`\\n\\nwhere the subproblem `C` now becomes **\"find the number of important reverse pairs with the first element of the pair coming from subarray `nums[0, j - 1]`  while the second element of the pair being `nums[j]`\"**.\\n\\nNote that for a pair `(p, q)` to be an important reverse pair, it has to satisfy the following two conditions:\\n1. `p < q`: the first element must come before the second element;\\n2. `nums[p] > 2 * nums[q]`: the first element has to be greater than twice of the second element.\\n\\nFor subproblem `C`, the first condition is met automatically; so we only need to consider the second condition, which is equivalent to searching for all elements within subarray `nums[0, j - 1]` that are greater than twice of `nums[j]`.\\n\\nThe straightforward way of searching would be a linear scan of the subarray, which runs at the order of `O(j)`. From the sequential recurrence relation, this leads to the naive `O(n^2)` solution.\\n\\nTo improve the searching efficiency, a key observation is that the order of elements in the subarray does not matter, since we are only interested in the total number of important reverse pairs. This suggests we may sort those elements and do a binary search instead of a plain linear scan.\\n\\nIf the searching space (formed by elements over which the search will be done) is \"static\" (it does not vary from run to run), placing the elements into an array would be perfect for us to do the binary search. However, this is not the case here. After the `j-th` element is processed, we need to add it to the searching space so that it becomes searchable for later elements, which renders the searching space expanding as more and more elements are processed.\\n\\nTherefore we\\'d like to strike a balance between searching and insertion operations. This is where data structures like binary search tree (`BST`) or binary indexed tree (`BIT`) prevail, which offers relatively fast performance for both operations.\\n\\n**1. `BST`-based solution**\\n\\nwe will define the tree node as follows, where `val` is the node value and `cnt` is the total number of elements in the subtree rooted at current node that are greater than or equal to `val`:\\n```\\nclass Node {\\n    int val, cnt;\\n    Node left, right;\\n        \\n    Node(int val) {\\n        this.val = val;\\n        this.cnt = 1;\\n    }\\n}\\n```\\nThe searching and insertion operations can be done as follows:\\n```\\nprivate int search(Node root, long val) {\\n    if (root == null) {\\n    \\treturn 0;\\n    } else if (val == root.val) {\\n    \\treturn root.cnt;\\n    } else if (val < root.val) {\\n    \\treturn root.cnt + search(root.left, val);\\n    } else {\\n    \\treturn search(root.right, val);\\n    }\\n}\\n\\nprivate Node insert(Node root, int val) {\\n    if (root == null) {\\n        root = new Node(val);\\n    } else if (val == root.val) {\\n        root.cnt++;\\n    } else if (val < root.val) {\\n        root.left = insert(root.left, val);\\n    } else {\\n        root.cnt++;\\n        root.right = insert(root.right, val);\\n    }\\n    \\n    return root;\\n}\\n```\\nAnd finally the main program, in which we will search for all elements no less than twice of current element plus `1` (converted to `long` type to avoid overflow) while insert the element itself into the BST. \\n\\n**Note:** this homemade BST is not self-balanced and the time complexity can go as bad as `O(n^2)` (in fact you will get `TLE` if you copy and paste the solution here). To guarantee `O(nlogn)` performance, use one of the self-balanced BST\\'s (e.g. `Red-black` tree, `AVL` tree, etc.).\\n```\\npublic int reversePairs(int[] nums) {\\n    int res = 0;\\n    Node root = null;\\n    \\t\\n    for (int ele : nums) {\\n        res += search(root, 2L * ele + 1);\\n        root = insert(root, ele);\\n    }\\n    \\n    return res;\\n}\\n```\\n\\n**2. `BIT`-based solution**\\n\\nFor `BIT`, the searching and insertion operations are:\\n```\\nprivate int search(int[] bit, int i) {\\n    int sum = 0;\\n    \\n    while (i < bit.length) {\\n        sum += bit[i];\\n        i += i & -i;\\n    }\\n\\n    return sum;\\n}\\n\\nprivate void insert(int[] bit, int i) {\\n    while (i > 0) {\\n        bit[i] += 1;\\n        i -= i & -i;\\n    }\\n}\\n```\\nAnd the main program, where again we will search for all elements greater than twice of current element while insert the element itself into the BIT. For each element, the `\"index\"` function will return its index in the `BIT`. Unlike the BST-based solution, this is guaranteed to run at `O(nlogn)`.\\n```\\npublic int reversePairs(int[] nums) {\\n    int res = 0;\\n    int[] copy = Arrays.copyOf(nums, nums.length);\\n    int[] bit = new int[copy.length + 1];\\n    \\n    Arrays.sort(copy);\\n    \\n    for (int ele : nums) {\\n        res += search(bit, index(copy, 2L * ele + 1));\\n        insert(bit, index(copy, ele));\\n    }\\n    \\n    return res;\\n}\\n\\nprivate int index(int[] arr, long val) {\\n    int l = 0, r = arr.length - 1, m = 0;\\n    \\t\\n    while (l <= r) {\\n    \\tm = l + ((r - l) >> 1);\\n    \\t\\t\\n    \\tif (arr[m] >= val) {\\n    \\t    r = m - 1;\\n    \\t} else {\\n    \\t    l = m + 1;\\n    \\t}\\n    }\\n    \\n    return l + 1;\\n}\\n```\\n\\nMore explanation for the BIT-based solution:\\n1. We want the elements to be sorted so there is a sorted version of the input array which is `copy`.\\n\\n2. The `bit` is built upon this sorted array. Its length is one greater than that of the `copy` array to account for the root.\\n\\n3. Initially the `bit` is empty and we start doing a sequential scan of the input array. For each element being scanned, we first search the `bit` to find all elements greater than twice of it and add the result to `res`. We then insert the element itself into the `bit` for future search.\\n\\n4. Note that conventionally searching of the `bit` involves traversing towards the root from some index of the `bit`, which will yield a predefined running total of the `copy` array up to the corresponding index. For insertion, the traversing direction will be opposite and go from some index towards the end of the `bit` array.\\n\\n5. For each scanned element of the input array, its searching index will be given by the index of the first element in the `copy` array that is greater than twice of it (shifted up by `1` to account for the root), while its insertion index will be the index of the first element in the `copy` array that is no less than itself (again shifted up by `1`). This is what the `index` function is for.\\n\\n6. For our case, the running total is simply the number of elements encountered during the traversal process. If we stick to the convention above, the running total will be the number of elements smaller than the one at the given index, since the `copy` array is sorted in ascending order. However, we\\'d actually like to find the number of elements greater than some value (i.e., twice of the element being scanned), therefore we need to flip the convention. This is what you see inside the `search` and `insert` functions: the former traversing towards the end of the `bit` while the latter towards the root.\\n\\n---\\n**`II -- Partition recurrence relation`**\\n\\nFor partition recurrence relation, setting `i = 0, j = n - 1, m = (n-1)/2`, we have:\\n\\n`T(0, n - 1) = T(0, m) + T(m + 1, n - 1) + C`\\n\\nwhere the subproblem `C` now reads **\"find the number of important reverse pairs with the first element of the pair coming from the left subarray `nums[0, m]`  while the second element of the pair coming from the right subarray `nums[m + 1, n - 1]`\"**.\\n\\nAgain for this subproblem, the first of the two aforementioned conditions is met automatically. As for the second condition, we have as usual this plain linear scan algorithm, applied for each element in the left (or right) subarray. This, to no surprise, leads to the `O(n^2)` naive solution.\\n\\nFortunately the observation holds true here that the order of elements in the left or right subarray does not matter, which prompts sorting of elements in both subarrays. With both subarrays sorted, the number of important reverse pairs can be found in linear time by employing the so-called two-pointer technique: one pointing to elements in the left subarray while the other to those in the right subarray and both pointers will go only in one direction due to the ordering of the elements.\\n\\nThe last question is which algorithm is best here to sort the subarrays. Since we need to partition the array into halves anyway, it is most natural to adapt it into a `Merge-sort`. Another point in favor of `Merge-sort` is that the searching process above can be embedded seamlessly into its merging stage.\\n\\nSo here is the `Merge-sort`-based solution, where the function `\"reversePairsSub\"` will return the total number of important reverse pairs within subarray `nums[l, r]`. The two-pointer searching process is represented by the nested `while` loop involving variable `p`, while the rest is the standard merging algorithm.\\n```\\npublic int reversePairs(int[] nums) {\\n    return reversePairsSub(nums, 0, nums.length - 1);\\n}\\n    \\nprivate int reversePairsSub(int[] nums, int l, int r) {\\n    if (l >= r) return 0;\\n        \\n    int m = l + ((r - l) >> 1);\\n    int res = reversePairsSub(nums, l, m) + reversePairsSub(nums, m + 1, r);\\n        \\n    int i = l, j = m + 1, k = 0, p = m + 1;\\n    int[] merge = new int[r - l + 1];\\n        \\n    while (i <= m) {\\n        while (p <= r && nums[i] > 2 L * nums[p]) p++;\\n        res += p - (m + 1);\\n\\t\\t\\t\\t\\n        while (j <= r && nums[i] >= nums[j]) merge[k++] = nums[j++];\\n        merge[k++] = nums[i++];\\n    }\\n        \\n    while (j <= r) merge[k++] = nums[j++];\\n        \\n    System.arraycopy(merge, 0, nums, l, merge.length);\\n        \\n    return res;\\n}\\n```\\n\\n---\\n**`III -- Summary`**\\n\\nMany problems involving arrays can be solved by breaking down the problem into subproblems applied on subarrays and then link the solution to the original problem with those of the subproblems, to which we have sequential recurrence relation and partition recurrence relation. For either case, it\\'s crucial to identify the subproblem `C` and find efficient algorithm for approaching it.\\n\\nIf the subproblem `C` involves searching on \"dynamic searching space\", try to consider data structures that support relatively fast operations on both searching and updating (such as `self-balanced BST`, `BIT`, `Segment tree`, `...`).\\n\\nIf the subproblem `C` of partition recurrence relation involves sorting, `Merge-sort` would be a nice sorting algorithm to use. Also, the code could be made more elegant if the solution to the subproblem can be embedded into the merging process.\\n\\nIf there are overlapping among the subproblems `T(i, j)`, it\\'s preferable to cache the intermediate results for future lookup.\\n\\nLastly let me name a few leetcode problems that fall into the patterns described above and thus can be solved with similar ideas.\\n\\n[315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)\\n[327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/)\\n\\nFor `leetcode 315`, applying the sequential recurrence relation (with `j` fixed), the subproblem `C` reads: **find the number of elements out of visited ones that are smaller than current element**, which involves searching on \"dynamic searching space\"; applying the partition recurrence relation, we have a subproblem `C`: **for each element in the left half, find the number of elements in the right half that are smaller than it**, which can be embedded into the merging process by noting that these elements are exactly those swapped to its left during the merging process.\\n\\nFor `leetcode 327`, applying the sequential recurrence relation (with `j` fixed) on the pre-sum array, the subproblem `C` reads: **find the number of elements out of visited ones that are within the given range**, which again involves searching on \"dynamic searching space\"; applying the partition recurrence relation, we have a subproblem `C`: **for each element in the left half, find the number of elements in the right half that are within the given range**, which can be embedded into the merging process using the two-pointer technique.\\n\\nAnyway, hope these ideas can sharpen your skills for solving array-related problems.",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    int val, cnt;\\n    Node left, right;\\n        \\n    Node(int val) {\\n        this.val = val;\\n        this.cnt = 1;\\n    }\\n}\\n```\n```\\nprivate int search(Node root, long val) {\\n    if (root == null) {\\n    \\treturn 0;\\n    } else if (val == root.val) {\\n    \\treturn root.cnt;\\n    } else if (val < root.val) {\\n    \\treturn root.cnt + search(root.left, val);\\n    } else {\\n    \\treturn search(root.right, val);\\n    }\\n}\\n\\nprivate Node insert(Node root, int val) {\\n    if (root == null) {\\n        root = new Node(val);\\n    } else if (val == root.val) {\\n        root.cnt++;\\n    } else if (val < root.val) {\\n        root.left = insert(root.left, val);\\n    } else {\\n        root.cnt++;\\n        root.right = insert(root.right, val);\\n    }\\n    \\n    return root;\\n}\\n```\n```\\npublic int reversePairs(int[] nums) {\\n    int res = 0;\\n    Node root = null;\\n    \\t\\n    for (int ele : nums) {\\n        res += search(root, 2L * ele + 1);\\n        root = insert(root, ele);\\n    }\\n    \\n    return res;\\n}\\n```\n```\\nprivate int search(int[] bit, int i) {\\n    int sum = 0;\\n    \\n    while (i < bit.length) {\\n        sum += bit[i];\\n        i += i & -i;\\n    }\\n\\n    return sum;\\n}\\n\\nprivate void insert(int[] bit, int i) {\\n    while (i > 0) {\\n        bit[i] += 1;\\n        i -= i & -i;\\n    }\\n}\\n```\n```\\npublic int reversePairs(int[] nums) {\\n    int res = 0;\\n    int[] copy = Arrays.copyOf(nums, nums.length);\\n    int[] bit = new int[copy.length + 1];\\n    \\n    Arrays.sort(copy);\\n    \\n    for (int ele : nums) {\\n        res += search(bit, index(copy, 2L * ele + 1));\\n        insert(bit, index(copy, ele));\\n    }\\n    \\n    return res;\\n}\\n\\nprivate int index(int[] arr, long val) {\\n    int l = 0, r = arr.length - 1, m = 0;\\n    \\t\\n    while (l <= r) {\\n    \\tm = l + ((r - l) >> 1);\\n    \\t\\t\\n    \\tif (arr[m] >= val) {\\n    \\t    r = m - 1;\\n    \\t} else {\\n    \\t    l = m + 1;\\n    \\t}\\n    }\\n    \\n    return l + 1;\\n}\\n```\n```\\npublic int reversePairs(int[] nums) {\\n    return reversePairsSub(nums, 0, nums.length - 1);\\n}\\n    \\nprivate int reversePairsSub(int[] nums, int l, int r) {\\n    if (l >= r) return 0;\\n        \\n    int m = l + ((r - l) >> 1);\\n    int res = reversePairsSub(nums, l, m) + reversePairsSub(nums, m + 1, r);\\n        \\n    int i = l, j = m + 1, k = 0, p = m + 1;\\n    int[] merge = new int[r - l + 1];\\n        \\n    while (i <= m) {\\n        while (p <= r && nums[i] > 2 L * nums[p]) p++;\\n        res += p - (m + 1);\\n\\t\\t\\t\\t\\n        while (j <= r && nums[i] >= nums[j]) merge[k++] = nums[j++];\\n        merge[k++] = nums[i++];\\n    }\\n        \\n    while (j <= r) merge[k++] = nums[j++];\\n        \\n    System.arraycopy(merge, 0, nums, l, merge.length);\\n        \\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97280,
                "title": "very-short-and-clear-mergesort-bst-java-solutions",
                "content": "**MergeSort**\\n\\n**Explanation:**  In each round, we divide our array into two parts and sort them. So after \"int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); \", the left part and the right part are sorted and now our only job is to count how many pairs of number (leftPart[i], rightPart[j]) satisfies leftPart[i] <= 2*rightPart[j]. \\nFor example, \\nleft: 4 6 8   right: 1 2 3\\nso we use two pointers to travel left and right parts. For each leftPart[i], if j<=e && nums[i]/2.0 > nums[j], we just continue to move j to the end, to increase rightPart[j], until it is valid. Like in our example, left's 4 can match 1 and 2; left's 6 can match 1, 2, 3, and left's 8 can match 1, 2, 3. So in this particular round, there are 8 pairs found, so we increases our total by 8. \\n\\n```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length-1);\\n    }\\n    private int mergeSort(int[] nums, int s, int e){\\n        if(s>=e) return 0; \\n        int mid = s + (e-s)/2; \\n        int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); \\n        for(int i = s, j = mid+1; i<=mid; i++){\\n            while(j<=e && nums[i]/2.0 > nums[j]) j++; \\n            cnt += j-(mid+1); \\n        }\\n        Arrays.sort(nums, s, e+1); \\n        return cnt; \\n    }\\n}\\n```\\n**Or:** \\nBecause left part and right part are sorted, you can replace the Arrays.sort() part with a actual merge sort process. The previous version is easy to write, while this one is faster. \\n\\n```\\npublic class Solution {\\n    int[] helper;\\n    public int reversePairs(int[] nums) {\\n        this.helper = new int[nums.length];\\n        return mergeSort(nums, 0, nums.length-1);\\n    }\\n    private int mergeSort(int[] nums, int s, int e){\\n        if(s>=e) return 0; \\n        int mid = s + (e-s)/2; \\n        int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); \\n        for(int i = s, j = mid+1; i<=mid; i++){\\n            while(j<=e && nums[i]/2.0 > nums[j]) j++; \\n            cnt += j-(mid+1); \\n        }\\n        //Arrays.sort(nums, s, e+1); \\n        myMerge(nums, s, mid, e);\\n        return cnt; \\n    }\\n    \\n    private void myMerge(int[] nums, int s, int mid, int e){\\n        for(int i = s; i<=e; i++) helper[i] = nums[i];\\n        int p1 = s;//pointer for left part\\n        int p2 = mid+1;//pointer for rigth part\\n        int i = s;//pointer for sorted array\\n        while(p1<=mid || p2<=e){\\n            if(p1>mid || (p2<=e && helper[p1] >= helper[p2])){\\n                nums[i++] = helper[p2++];\\n            }else{\\n                nums[i++] = helper[p1++];\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n------------------------------------------------------------------------\\n\\n**BST**\\nBST solution is no longer acceptable, because it's performance can be very bad, O(n^2) actually, for extreme cases like [1,2,3,4......49999], due to the its unbalance, but I am still providing it below just FYI. \\nWe build the Binary Search Tree from right to left, and at the same time, search the partially built tree with nums[i]/2.0. The code below should be clear enough. \\n```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        Node root = null;\\n        int[] cnt = new int[1];\\n        for(int i = nums.length-1; i>=0; i--){\\n            search(cnt, root, nums[i]/2.0);//search and count the partially built tree\\n            root = build(nums[i], root);//add nums[i] to BST\\n        }\\n        return cnt[0];\\n    }\\n    \\n    private void search(int[] cnt, Node node, double target){\\n        if(node==null) return; \\n        else if(target == node.val) cnt[0] += node.less;\\n        else if(target < node.val) search(cnt, node.left, target);\\n        else{\\n            cnt[0]+=node.less + node.same; \\n            search(cnt, node.right, target);\\n        }\\n    }\\n    \\n    private Node build(int val, Node n){\\n        if(n==null) return new Node(val);\\n        else if(val == n.val) n.same+=1;\\n        else if(val > n.val) n.right = build(val, n.right);\\n        else{\\n            n.less += 1;\\n            n.left = build(val, n.left);\\n        }\\n        return n;\\n    }\\n    \\n    class Node{\\n        int val, less = 0, same = 1;//less: number of nodes that less than this node.val\\n        Node left, right;\\n        public Node(int v){\\n            this.val = v;\\n        }\\n    }\\n}\\n```\\nSimilar to this https://leetcode.com/problems/count-of-smaller-numbers-after-self/. But the main difference is: here, the number to add and the number to search are different (add nums[i], but search nums[i]/2.0), so not a good idea to combine build and search together.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length-1);\\n    }\\n    private int mergeSort(int[] nums, int s, int e){\\n        if(s>=e) return 0; \\n        int mid = s + (e-s)/2; \\n        int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); \\n        for(int i = s, j = mid+1; i<=mid; i++){\\n            while(j<=e && nums[i]/2.0 > nums[j]) j++; \\n            cnt += j-(mid+1); \\n        }\\n        Arrays.sort(nums, s, e+1); \\n        return cnt; \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    int[] helper;\\n    public int reversePairs(int[] nums) {\\n        this.helper = new int[nums.length];\\n        return mergeSort(nums, 0, nums.length-1);\\n    }\\n    private int mergeSort(int[] nums, int s, int e){\\n        if(s>=e) return 0; \\n        int mid = s + (e-s)/2; \\n        int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); \\n        for(int i = s, j = mid+1; i<=mid; i++){\\n            while(j<=e && nums[i]/2.0 > nums[j]) j++; \\n            cnt += j-(mid+1); \\n        }\\n        //Arrays.sort(nums, s, e+1); \\n        myMerge(nums, s, mid, e);\\n        return cnt; \\n    }\\n    \\n    private void myMerge(int[] nums, int s, int mid, int e){\\n        for(int i = s; i<=e; i++) helper[i] = nums[i];\\n        int p1 = s;//pointer for left part\\n        int p2 = mid+1;//pointer for rigth part\\n        int i = s;//pointer for sorted array\\n        while(p1<=mid || p2<=e){\\n            if(p1>mid || (p2<=e && helper[p1] >= helper[p2])){\\n                nums[i++] = helper[p2++];\\n            }else{\\n                nums[i++] = helper[p1++];\\n            }\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        Node root = null;\\n        int[] cnt = new int[1];\\n        for(int i = nums.length-1; i>=0; i--){\\n            search(cnt, root, nums[i]/2.0);//search and count the partially built tree\\n            root = build(nums[i], root);//add nums[i] to BST\\n        }\\n        return cnt[0];\\n    }\\n    \\n    private void search(int[] cnt, Node node, double target){\\n        if(node==null) return; \\n        else if(target == node.val) cnt[0] += node.less;\\n        else if(target < node.val) search(cnt, node.left, target);\\n        else{\\n            cnt[0]+=node.less + node.same; \\n            search(cnt, node.right, target);\\n        }\\n    }\\n    \\n    private Node build(int val, Node n){\\n        if(n==null) return new Node(val);\\n        else if(val == n.val) n.same+=1;\\n        else if(val > n.val) n.right = build(val, n.right);\\n        else{\\n            n.less += 1;\\n            n.left = build(val, n.left);\\n        }\\n        return n;\\n    }\\n    \\n    class Node{\\n        int val, less = 0, same = 1;//less: number of nodes that less than this node.val\\n        Node left, right;\\n        public Node(int v){\\n            this.val = v;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185939,
                "title": "best-c-2-solution-divide-and-conquer-merge-sort-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have solve this question using Two Approaches.\\n1. Solved Using Array(Two Nested Loop). Brute Force Approach.\\n2. Solved using Array + Divide and Conquer + Merge Sort. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), where N is the size of the array. As we check for possible pair which can satisfy\\n    the given condition, and the total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This approach is Giving TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        long long reversePairsCount = 0;\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(nums[i] > 2*(long long)nums[j]){\\n                    reversePairsCount++;\\n                }\\n            }\\n        }\\n        return reversePairsCount;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Each recursive call to performs two recursive calls on subslices of size N/2 and\\n    One linear scans of length <= N. Therefore, the time complexity of the divide & conquer approach can be\\n    represented by the following recurrence relation: T(N)=2T(N/2)+N. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(N), Recursion Stack Space O(logN) + Array(temp) space O(N). \\n\\n    Solved using Array + Divide and Conquer + Merge Sort. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void merge(vector<int>& nums, int low, int mid, int high, int& reversePairsCount){\\n        int j = mid+1;\\n        for(int i=low; i<=mid; i++){\\n            while(j<=high && nums[i] > 2*(long long)nums[j]){\\n                j++;\\n            }\\n            reversePairsCount += j-(mid+1);\\n        }\\n        int size = high-low+1;\\n        vector<int> temp(size, 0);\\n        int left = low, right = mid+1, k=0;\\n        while(left<=mid && right<=high){\\n            if(nums[left] < nums[right]){\\n                temp[k++] = nums[left++];\\n            }\\n            else{\\n                temp[k++] = nums[right++];\\n            }\\n        }\\n        while(left<=mid){\\n            temp[k++] = nums[left++]; \\n        }\\n        while(right<=high){\\n            temp[k++] = nums[right++]; \\n        }\\n        int m=0;\\n        for(int i=low; i<=high; i++){\\n            nums[i] = temp[m++];\\n        }\\n    }\\n\\n    void mergeSort(vector<int>& nums, int low, int high, int& reversePairsCount){\\n        if(low >= high){\\n            return;\\n        }\\n        int mid = (low + high) >> 1;\\n        mergeSort(nums, low, mid, reversePairsCount);\\n        mergeSort(nums, mid+1, high, reversePairsCount);\\n        merge(nums, low, mid, high, reversePairsCount);\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int reversePairsCount = 0;\\n        mergeSort(nums, 0, nums.size()-1, reversePairsCount);\\n        return reversePairsCount;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), where N is the size of the array. As we check for possible pair which can satisfy\\n    the given condition, and the total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This approach is Giving TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        long long reversePairsCount = 0;\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(nums[i] > 2*(long long)nums[j]){\\n                    reversePairsCount++;\\n                }\\n            }\\n        }\\n        return reversePairsCount;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Each recursive call to performs two recursive calls on subslices of size N/2 and\\n    One linear scans of length <= N. Therefore, the time complexity of the divide & conquer approach can be\\n    represented by the following recurrence relation: T(N)=2T(N/2)+N. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(N), Recursion Stack Space O(logN) + Array(temp) space O(N). \\n\\n    Solved using Array + Divide and Conquer + Merge Sort. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void merge(vector<int>& nums, int low, int mid, int high, int& reversePairsCount){\\n        int j = mid+1;\\n        for(int i=low; i<=mid; i++){\\n            while(j<=high && nums[i] > 2*(long long)nums[j]){\\n                j++;\\n            }\\n            reversePairsCount += j-(mid+1);\\n        }\\n        int size = high-low+1;\\n        vector<int> temp(size, 0);\\n        int left = low, right = mid+1, k=0;\\n        while(left<=mid && right<=high){\\n            if(nums[left] < nums[right]){\\n                temp[k++] = nums[left++];\\n            }\\n            else{\\n                temp[k++] = nums[right++];\\n            }\\n        }\\n        while(left<=mid){\\n            temp[k++] = nums[left++]; \\n        }\\n        while(right<=high){\\n            temp[k++] = nums[right++]; \\n        }\\n        int m=0;\\n        for(int i=low; i<=high; i++){\\n            nums[i] = temp[m++];\\n        }\\n    }\\n\\n    void mergeSort(vector<int>& nums, int low, int high, int& reversePairsCount){\\n        if(low >= high){\\n            return;\\n        }\\n        int mid = (low + high) >> 1;\\n        mergeSort(nums, low, mid, reversePairsCount);\\n        mergeSort(nums, mid+1, high, reversePairsCount);\\n        merge(nums, low, mid, high, reversePairsCount);\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int reversePairsCount = 0;\\n        mergeSort(nums, 0, nums.size()-1, reversePairsCount);\\n        return reversePairsCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97287,
                "title": "c-with-iterators",
                "content": "Just a mergesort solution, but using iterators (instead of indexes) and `inplace_merge`.\\n\\n```\\nclass Solution {\\npublic:\\n    int sort_and_count(vector<int>::iterator begin, vector<int>::iterator end) {\\n        if (end - begin <= 1)\\n            return 0;\\n        auto mid = begin + (end - begin) / 2;\\n        int count = sort_and_count(begin, mid) + sort_and_count(mid, end);\\n        for (auto i = begin, j = mid; i != mid; ++i) {\\n            while (j != end and *i > 2L * *j)\\n                ++j;\\n            count += j - mid;\\n        }\\n        inplace_merge(begin, mid, end);\\n        return count;\\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        return sort_and_count(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sort_and_count(vector<int>::iterator begin, vector<int>::iterator end) {\\n        if (end - begin <= 1)\\n            return 0;\\n        auto mid = begin + (end - begin) / 2;\\n        int count = sort_and_count(begin, mid) + sort_and_count(mid, end);\\n        for (auto i = begin, j = mid; i != mid; ++i) {\\n            while (j != end and *i > 2L * *j)\\n                ++j;\\n            count += j - mid;\\n        }\\n        inplace_merge(begin, mid, end);\\n        return count;\\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        return sort_and_count(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97319,
                "title": "c-solution-using-merge-sort",
                "content": "\\n```\\nclass Solution {\\nprivate:\\n    int count;\\n   \\n    void checkCount(vector<int>& nums, int start, int mid, int end){\\n\\n        // two pointers;\\n        int l = start, r = mid + 1;\\n        while(l <= mid && r <= end){\\n            if((long)nums[l] > (long) 2 * nums[r]){\\n                count += (mid - l + 1);\\n                r++;\\n            }else{\\n                l++;\\n            }\\n        }\\n       // worst case might be nlog(n) \\n        sort(nums.begin() + start, nums.begin() + end + 1);\\n        return;\\n        \\n        \\n        \\n        //every step sort\\n    }\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start == end) return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid);\\n        mergeSort(nums,mid+1,end);\\n        \\n        checkCount(nums,start,mid,end);\\n        return;\\n        \\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if(!nums.size())return 0;\\n        count = 0;\\n        mergeSort(nums,0,nums.size()-1);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int count;\\n   \\n    void checkCount(vector<int>& nums, int start, int mid, int end){\\n\\n        // two pointers;\\n        int l = start, r = mid + 1;\\n        while(l <= mid && r <= end){\\n            if((long)nums[l] > (long) 2 * nums[r]){\\n                count += (mid - l + 1);\\n                r++;\\n            }else{\\n                l++;\\n            }\\n        }\\n       // worst case might be nlog(n) \\n        sort(nums.begin() + start, nums.begin() + end + 1);\\n        return;\\n        \\n        \\n        \\n        //every step sort\\n    }\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start == end) return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid);\\n        mergeSort(nums,mid+1,end);\\n        \\n        checkCount(nums,start,mid,end);\\n        return;\\n        \\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if(!nums.size())return 0;\\n        count = 0;\\n        mergeSort(nums,0,nums.size()-1);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162757,
                "title": "python-bit-using-ranks-clear-o-nlog-n",
                "content": "\\n    class BIT:\\n        def __init__(self, n):\\n            self.n = n + 1\\n            self.sums = [0] * self.n\\n        \\n        def update(self, i, delta):\\n            while i < self.n:\\n                self.sums[i] += delta\\n                i += i & (-i)\\n        \\n        def query(self, i):\\n            res = 0\\n            while i > 0:\\n                res += self.sums[i]\\n                i -= i & (-i)\\n            return res\\n    \\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # BIT O(nlogn)\\n        new_nums = nums + [x * 2 for x in nums]\\n        sorted_set = sorted(list(set(new_nums)))\\n        tree = self.BIT(len(sorted_set))\\n        res = 0\\n        ranks = {}\\n        for i, n in enumerate(sorted_set):\\n            ranks[n] = i + 1\\n            \\n        for n in nums[::-1]:\\n            res += tree.query(ranks[n] - 1)\\n            tree.update(ranks[n * 2], 1)\\n        \\n        return res",
                "solutionTags": [],
                "code": "\\n    class BIT:\\n        def __init__(self, n):\\n            self.n = n + 1\\n            self.sums = [0] * self.n\\n        \\n        def update(self, i, delta):\\n            while i < self.n:\\n                self.sums[i] += delta\\n                i += i & (-i)\\n        \\n        def query(self, i):\\n            res = 0\\n            while i > 0:\\n                res += self.sums[i]\\n                i -= i & (-i)\\n            return res\\n    \\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # BIT O(nlogn)\\n        new_nums = nums + [x * 2 for x in nums]\\n        sorted_set = sorted(list(set(new_nums)))\\n        tree = self.BIT(len(sorted_set))\\n        res = 0\\n        ranks = {}\\n        for i, n in enumerate(sorted_set):\\n            ranks[n] = i + 1\\n            \\n        for n in nums[::-1]:\\n            res += tree.query(ranks[n] - 1)\\n            tree.update(ranks[n * 2], 1)\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1201949,
                "title": "easy-merge-sort-based-solution-c-o-nlogn-time-complexity",
                "content": "**Brute force solution:**\\nFor each value in given sample, we\\u2019ll check all other front values to see if, the value is greater than double of the front value.\\n```\\nint reversePairCount = 0;\\nfor(int i=0; i<nums.size(); i++) {\\n\\tfor(int j=i+1; j<nums.size(); j++) {\\n\\t\\tif( nums[i] > 2*nums[j]) reversePairCount++;\\n\\t}\\n}\\nreturn reversePairCount;\\n```\\n***Time complexity:*** O(N^2)\\n***Space complexity:*** O(1)\\nWhere N is the size of array \\u201Cnums\\u201D.\\nAs the size of size of array \\u201Cnums\\u201D can be max 5*10^4, this brute force approach will give **TLE** as verdict.\\n\\n**Merge Sort based solution:**\\nThis problem can be solved very easily using merge sort.\\nLet\\u2019s consider the common top-down approach of merge sort.\\nAssume, there\\u2019re 2 functions.\\n1. _mergeSort : Divides the array.\\n2. _merge: Compares elements of 2 sub-array, then merge them into 1 array.\\n\\nFor this problem, we\\u2019ll modify the \\u201C_merge\\u201D function to get the required output.\\n```\\nvoid _merge(int ar[], int low, int mid, int high) {\\n    int leftInd=low, rightInd=mid+1, temp[high-low+1], tempInd = 0;\\n\\n    while(leftInd<=mid && rightInd<=high) {\\n        if(ar[leftInd] <= ar[rightInd]) temp[tempInd++] = ar[leftInd++];\\n        else temp[tempInd++] = ar[rightInd++];\\n    }\\n\\n    while(leftInd <= mid) temp[tempInd++] = ar[leftInd++];\\n\\n    while(rightInd<=high) temp[tempInd++] = ar[rightInd++];\\n\\n    for(int i=0; i<tempInd; i++) ar[low++] = temp[i];\\n}\\n```\\nThis is a sample code of typical \\u201C_merge\\u201D function. Here we check which part between 2 sub-array has the smaller element. Then we keep it into the additional array (in the code \\u201Ctemp\\u201D).\\n\\nFor this problem, instead of checking whether current value of left sub-array is less than or equal to current value of right sub-array, we\\u2019ll check whether current value of left sub-array is greater than double of current value of right sub-array.\\nThat means, current value of left sub-array > 2 * current value of right sub-array.\\nThis is the main idea for solving the problem.\\n\\nSolution Code:\\n```\\nvoid _merge(vector<int>& nums, int low, int mid, int high, int &reversePairCount) {\\n    int leftInd = low, rightInd = mid+1, r = rightInd, temp[high-low+1], tempInd = 0, counter = 0;\\n    // 4 6 8,  1 2 3\\n    while(leftInd<=mid) {\\n        while( r<=high && (nums[leftInd] > (long)2*nums[r]) ) counter++, r++;\\n        reversePairCount+= counter;\\n        while( rightInd<=high && nums[rightInd]<=nums[leftInd] ) {\\n            temp[tempInd++] = nums[rightInd++];\\n        }\\n        temp[tempInd++] = nums[leftInd++];\\n    }\\n    while(rightInd<=high) {\\n        temp[tempInd++] = nums[rightInd++];\\n    }\\n    for(int i=0; i<tempInd; i++) nums[low++] = temp[i];\\n}\\n\\nvoid _mergeSort(vector<int>& nums, int low, int high, int &reversePairCount) {\\n    if(low < high) {\\n        int mid = low + (high-low)/2;\\n        _mergeSort(nums, low, mid, reversePairCount);\\n        _mergeSort(nums, mid+1, high, reversePairCount);\\n        _merge(nums, low, mid, high, reversePairCount);\\n    }\\n}\\n\\nint reversePairs(vector<int>& nums) {\\n    int reversePairCount = 0;\\n    int sz = nums.size();\\n    if(sz<=1) return reversePairCount;\\n    _mergeSort(nums, 0, sz-1, reversePairCount);\\n    return reversePairCount;\\n}\\n```\\n***Time complexity:*** O(N * logN)\\n***Space complexity:*** O(N)\\n\\nExplanation with example:\\nLet\\u2019s consider 2 sub-array [4, 6, 8] and [1, 2, 3].\\n\\nindex:\\t 0\\t1\\t2\\t3\\t4\\t5\\nvalue:\\t 4\\t6\\t8\\t1\\t2\\t3\\ncount:\\t1\\t2\\t3\\t0\\t0\\t0\\n\\nFor value 4, there\\'s only 1 value in right sub-array, **1** (4 > 2x1).\\nFor value 6, there\\'re 2 values in right sub-array, **1** (4 > 2x1), **2** (6 > 2x2).\\nFor value 8, there\\'re 3 values in right sub-array, **1** (4 > 2x1), **2** (8 > 2x2), **3** (8 > 2x3).\\n\\nSo output will be 1+2+3 = 6.\\n\\nHope this helps. Happy coding!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nint reversePairCount = 0;\\nfor(int i=0; i<nums.size(); i++) {\\n\\tfor(int j=i+1; j<nums.size(); j++) {\\n\\t\\tif( nums[i] > 2*nums[j]) reversePairCount++;\\n\\t}\\n}\\nreturn reversePairCount;\\n```\n```\\nvoid _merge(int ar[], int low, int mid, int high) {\\n    int leftInd=low, rightInd=mid+1, temp[high-low+1], tempInd = 0;\\n\\n    while(leftInd<=mid && rightInd<=high) {\\n        if(ar[leftInd] <= ar[rightInd]) temp[tempInd++] = ar[leftInd++];\\n        else temp[tempInd++] = ar[rightInd++];\\n    }\\n\\n    while(leftInd <= mid) temp[tempInd++] = ar[leftInd++];\\n\\n    while(rightInd<=high) temp[tempInd++] = ar[rightInd++];\\n\\n    for(int i=0; i<tempInd; i++) ar[low++] = temp[i];\\n}\\n```\n```\\nvoid _merge(vector<int>& nums, int low, int mid, int high, int &reversePairCount) {\\n    int leftInd = low, rightInd = mid+1, r = rightInd, temp[high-low+1], tempInd = 0, counter = 0;\\n    // 4 6 8,  1 2 3\\n    while(leftInd<=mid) {\\n        while( r<=high && (nums[leftInd] > (long)2*nums[r]) ) counter++, r++;\\n        reversePairCount+= counter;\\n        while( rightInd<=high && nums[rightInd]<=nums[leftInd] ) {\\n            temp[tempInd++] = nums[rightInd++];\\n        }\\n        temp[tempInd++] = nums[leftInd++];\\n    }\\n    while(rightInd<=high) {\\n        temp[tempInd++] = nums[rightInd++];\\n    }\\n    for(int i=0; i<tempInd; i++) nums[low++] = temp[i];\\n}\\n\\nvoid _mergeSort(vector<int>& nums, int low, int high, int &reversePairCount) {\\n    if(low < high) {\\n        int mid = low + (high-low)/2;\\n        _mergeSort(nums, low, mid, reversePairCount);\\n        _mergeSort(nums, mid+1, high, reversePairCount);\\n        _merge(nums, low, mid, high, reversePairCount);\\n    }\\n}\\n\\nint reversePairs(vector<int>& nums) {\\n    int reversePairCount = 0;\\n    int sz = nums.size();\\n    if(sz<=1) return reversePairCount;\\n    _mergeSort(nums, 0, sz-1, reversePairCount);\\n    return reversePairCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97323,
                "title": "well-explained-o-nlogn-python-solution-based-on-mergesort",
                "content": "Count \"important reverse pairs\" while doing mergesort:\\nWhen we\\'re doing mergesort, original index of elements in left part (smaller side), i, must less than those in right part, j.\\nSimply compare nums[i] and 2*nums[j] and sum them up.\\n\\nEdit: (wrote this long time ago, and there must be some new test case made it TLE. make the code cleaner but its same idea)\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.cnt = 0\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def msort(A):\\n            # merge sort body\\n            L = len(A)\\n            if L <= 1:                          # base case\\n                return A\\n            else:                               # recursive case\\n                return merger(msort(A[:int(L/2)]), msort(A[int(L/2):]))\\n        def merger(left, right):\\n            l, r = 0, 0                         # increase l and r iteratively\\n            while l < len(left) and r < len(right):\\n                if left[l] <= 2*right[r]:\\n                    l += 1\\n                else:\\n                    self.cnt += len(left)-l     # COUNT here\\n                    r += 1\\n            \\n            res = []                            # merger\\n            i, j = 0, 0\\n            while i < len(left) and j < len(right):\\n                if left[i] < right[j]:\\n                    res += left[i],\\n                    i += 1\\n                else:\\n                    res += right[j],\\n                    j += 1\\n            \\n            while i != len(left):\\n                res += left[i],\\n                i += 1\\n            while j != len(right):\\n                res += right[j],\\n                j += 1\\n            \\n            return res\\n\\n        msort(nums)\\n        return self.cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.cnt = 0\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def msort(A):\\n            # merge sort body\\n            L = len(A)\\n            if L <= 1:                          # base case\\n                return A\\n            else:                               # recursive case\\n                return merger(msort(A[:int(L/2)]), msort(A[int(L/2):]))\\n        def merger(left, right):\\n            l, r = 0, 0                         # increase l and r iteratively\\n            while l < len(left) and r < len(right):\\n                if left[l] <= 2*right[r]:\\n                    l += 1\\n                else:\\n                    self.cnt += len(left)-l     # COUNT here\\n                    r += 1\\n            \\n            res = []                            # merger\\n            i, j = 0, 0\\n            while i < len(left) and j < len(right):\\n                if left[i] < right[j]:\\n                    res += left[i],\\n                    i += 1\\n                else:\\n                    res += right[j],\\n                    j += 1\\n            \\n            while i != len(left):\\n                res += left[i],\\n                i += 1\\n            while j != len(right):\\n                res += right[j],\\n                j += 1\\n            \\n            return res\\n\\n        msort(nums)\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97277,
                "title": "bst-no-tle",
                "content": "After digging into some other questions, I came back and found we can avoid \\n worst case by construct the BST with the sorted arrays. Then we assign the `geCount` in update stage.\\n```\\nclass Solution {\\n    class TreeNode {\\n        int val;\\n        int geCount;\\n        TreeNode left;\\n        TreeNode right;\\n\\n        TreeNode(int val) {\\n            this.val = val;\\n            geCount = 0; // NOTE\\n        }\\n    }\\n\\n    int search(TreeNode root, long val) {\\n        if (root == null) return 0;\\n        if (root.val > val) {  // go left:[val, root.val>, and add root.geCount:[root.val, ..]\\n            return root.geCount + search(root.left, val);\\n        } else if (root.val == val) { // find the exact number\\n            return root.geCount;\\n        } else {\\n            return search(root.right, val);\\n        }\\n    }\\n    \\n    TreeNode construct(int[] nums, int left, int right) {\\n        if (left > right) return null;\\n        int m = left + (right - left) / 2;\\n        TreeNode root = new TreeNode(nums[m]);\\n        root.left = construct(nums, left, m - 1);\\n        root.right = construct(nums, m+1, right);\\n        return root;\\n    }\\n\\n    TreeNode update(TreeNode root, int val) {\\n        if (root.val == val) {\\n            root.geCount++;\\n            return root;\\n        } else if (root.val < val) { // go right side;\\n            root.geCount++;\\n            update(root.right, val);\\n        } else {\\n            update(root.left, val);\\n        }\\n        return root;\\n    }\\n\\n    public int reversePairs(int[] nums) {\\n        int count = 0;\\n        int[] cp_nums = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(cp_nums);\\n        TreeNode head = construct(cp_nums, 0, nums.length - 1);\\n\\n        for (int num : nums) {                                    \\n            count += search(head, 2L * num + 1);            \\n            head = update(head, num);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TreeNode {\\n        int val;\\n        int geCount;\\n        TreeNode left;\\n        TreeNode right;\\n\\n        TreeNode(int val) {\\n            this.val = val;\\n            geCount = 0; // NOTE\\n        }\\n    }\\n\\n    int search(TreeNode root, long val) {\\n        if (root == null) return 0;\\n        if (root.val > val) {  // go left:[val, root.val>, and add root.geCount:[root.val, ..]\\n            return root.geCount + search(root.left, val);\\n        } else if (root.val == val) { // find the exact number\\n            return root.geCount;\\n        } else {\\n            return search(root.right, val);\\n        }\\n    }\\n    \\n    TreeNode construct(int[] nums, int left, int right) {\\n        if (left > right) return null;\\n        int m = left + (right - left) / 2;\\n        TreeNode root = new TreeNode(nums[m]);\\n        root.left = construct(nums, left, m - 1);\\n        root.right = construct(nums, m+1, right);\\n        return root;\\n    }\\n\\n    TreeNode update(TreeNode root, int val) {\\n        if (root.val == val) {\\n            root.geCount++;\\n            return root;\\n        } else if (root.val < val) { // go right side;\\n            root.geCount++;\\n            update(root.right, val);\\n        } else {\\n            update(root.left, val);\\n        }\\n        return root;\\n    }\\n\\n    public int reversePairs(int[] nums) {\\n        int count = 0;\\n        int[] cp_nums = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(cp_nums);\\n        TreeNode head = construct(cp_nums, 0, nums.length - 1);\\n\\n        for (int num : nums) {                                    \\n            count += search(head, 2L * num + 1);            \\n            head = update(head, num);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394210,
                "title": "bit-thinking-process",
                "content": "Binary Index Tree (BIT) is usually used in the following situation: given a segment, return some statistics over all elements on the segment, such as the sum() of the elements, or the count() of elements that meet some defined criteria. The key point of BIT (what it was designed for) is to query the statistics quickly when some elements over the  segment can be frequently updated. For this question, what is segment, and what is statistics? What is queried, and what is updated? Think about it for a second. \\n\\nConsider a moment we start processing nums[j]. The crux is how many already-prcessed elements (nums[0], nums[1], ..., nums[j-1]) are greater than 2 * nums[j]. This question can be broken down to 2 smaller questions: i) how many elements in nums are greater than 2 * nums[j], followed by ii) how many out of them have already been processed up to j-1. As a result, following things are needed:\\n\\ni) A sorted version of nums array, called \\'sorted\\'\\nii) For each index of \\'sorted\\', flagging whether the number on the index has been seen so far.\\niii) A mechanism to quickly retrieve how many flags there are, given an index range. \\n\\nYou may reliaze the ii) and iii) is a typical BIT use case, where ii) is update, and iii) is query. The underlying data structure to support both is BIT. \\n\\n```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException();\\n        }\\n        int[] sorted = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(sorted); // the sorted version\\n        int[] bit = new int[sorted.length + 1]; // the BIT\\n        /**\\n         * Process starts. \\n         **/\\n        int ret = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            // step #1: get (2 * nums[i])\\'s position in the sorted version of nums. Since nums may contain duplicates, so get the last position of the same number in a row. \\n            int index = getLastSmallerEqualPos(sorted, 2L * nums[i]);\\n\\t\\t\\t// step #2: compute. Adding 1 on index due to the BIT is 1-indexed. getSumBIT returns the number of visited elements that are smaller or equal to (2 * nums[i]). i - getSumBIT returns what we need\\n            ret += i - getSumBIT(bit, index + 1);\\n\\t\\t\\t// step #3: find out the index in the sorted version where nums[i] should reside. \\n            index = getLastSmallerEqualPos(sorted, nums[i]);\\n            // step #4:  as the func name says\\n            updateBIT(bit, index + 1);\\n        }\\n        return ret;\\n    }\\n    \\n    private void updateBIT(int[] bit, int index) {\\n        while (index < bit.length) {\\n            ++bit[index];\\n            index += index & (-index);\\n        }\\n    }\\n    \\n    private int getSumBIT(int[] bit, int index) {\\n        int sub = 0;\\n        while (index > 0) {\\n            sub += bit[index];\\n            index -= index & (-index);\\n        }\\n        return sub;\\n    }\\n    \\n    private int getLastSmallerEqualPos(int[] sorted, double searched) {\\n        int l = 0;\\n        int r = sorted.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (sorted[mid] <= searched) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            } \\n        }\\n        return sorted[l] <= searched ? l : l - 1;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException();\\n        }\\n        int[] sorted = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(sorted); // the sorted version\\n        int[] bit = new int[sorted.length + 1]; // the BIT\\n        /**\\n         * Process starts. \\n         **/\\n        int ret = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            // step #1: get (2 * nums[i])\\'s position in the sorted version of nums. Since nums may contain duplicates, so get the last position of the same number in a row. \\n            int index = getLastSmallerEqualPos(sorted, 2L * nums[i]);\\n\\t\\t\\t// step #2: compute. Adding 1 on index due to the BIT is 1-indexed. getSumBIT returns the number of visited elements that are smaller or equal to (2 * nums[i]). i - getSumBIT returns what we need\\n            ret += i - getSumBIT(bit, index + 1);\\n\\t\\t\\t// step #3: find out the index in the sorted version where nums[i] should reside. \\n            index = getLastSmallerEqualPos(sorted, nums[i]);\\n            // step #4:  as the func name says\\n            updateBIT(bit, index + 1);\\n        }\\n        return ret;\\n    }\\n    \\n    private void updateBIT(int[] bit, int index) {\\n        while (index < bit.length) {\\n            ++bit[index];\\n            index += index & (-index);\\n        }\\n    }\\n    \\n    private int getSumBIT(int[] bit, int index) {\\n        int sub = 0;\\n        while (index > 0) {\\n            sub += bit[index];\\n            index -= index & (-index);\\n        }\\n        return sub;\\n    }\\n    \\n    private int getLastSmallerEqualPos(int[] sorted, double searched) {\\n        int l = 0;\\n        int r = sorted.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (sorted[mid] <= searched) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            } \\n        }\\n        return sorted[l] <= searched ? l : l - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112146,
                "title": "java-mergesort-o-n-long-n-templater-solution-for-reverse-pairs-327-and-315",
                "content": "Reverse Pairs\\n```\\n\\tpublic int reversePairs(int[] nums) {\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        return mergesort(nums, 0, nums.length-1);\\n    }\\n\\t\\n\\tprivate int mergesort(int[] nums, int low, int high){\\n\\t\\tif (low >= high) return 0;\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint count = mergesort(nums, low, mid) + mergesort(nums, mid+1, high);\\n\\t\\tfor (int i = low, j = mid+1; i <= mid && j <= high;){\\n\\t\\t\\tif (nums[i] > (long) nums[j] * 2){\\n                count += mid - i + 1;\\n                j++;\\n            }\\n            else i++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tmerge(nums, low, high);\\n\\t\\treturn count;\\n\\t}\\n\\t\\n\\tprivate void merge(int[] nums, int low, int high){\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint[] arr = new int[high - low + 1];\\n\\t\\t\\n\\t\\tint i = low, j = mid + 1, k = 0;\\n\\t\\twhile (k < arr.length){\\n\\t\\t\\tint num1 = i > mid ? Integer.MAX_VALUE : nums[i];\\n\\t\\t\\tint num2 = j > high ? Integer.MAX_VALUE : nums[j];\\n\\t\\t\\t\\n\\t\\t\\tarr[k++] = num1 <= num2 ? nums[i++] : nums[j++];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int p = 0; p < arr.length; p++) nums[p+low] = arr[p];\\n\\t}\\n```\\n\\nCount of Smaller after self\\n```\\npublic List<Integer> countSmaller(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] count = new int[nums.length];\\n        int[] index = new int[nums.length];\\n        for (int i = 0; i < index.length; i++) index[i] = i;\\n        \\n        mergeSortCountSmaller(nums, index, count, 0, nums.length-1);\\n        \\n        for (int i : count) res.add(i);\\n        return res;\\n    }\\n\\t\\n\\tprivate void mergeSortCountSmaller(int[] nums, int[] index, int[] count, int low, int high){\\n\\t\\tif (low >= high) return;\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tmergeSortCountSmaller(nums, index, count, low, mid);\\n\\t\\tmergeSortCountSmaller(nums, index, count, mid+1, high);\\n\\t\\tint rightCount = 0, i = low;\\n\\t\\tfor (int j = mid + 1; i <= mid && j <= high; ){\\n\\t\\t\\tif (nums[index[j]] < nums[index[i]]){\\n\\t\\t\\t\\trightCount++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\telse count[index[i++]] += rightCount;\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (i <= mid) count[index[i++]] += rightCount;\\n\\t\\t\\n\\t\\tmergeCountSmaller(nums, index, low, high);\\n\\t}\\n\\t\\n\\tprivate void mergeCountSmaller(int[] nums, int[] index, int low, int high){\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint[] arr = new int[high - low + 1];\\n\\t\\tint i = low, j = mid + 1, k = 0;\\n\\t\\t\\n\\t\\twhile (k < arr.length){\\n\\t\\t\\tint num1 = i <= mid ? nums[index[i]] : Integer.MAX_VALUE;\\n\\t\\t\\tint num2 = j <= high ? nums[index[j]] : Integer.MAX_VALUE;\\n\\t\\t\\t\\n\\t\\t\\tarr[k++] = num1 <= num2 ? index[i++] : index[j++];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int p = 0; p < arr.length; p++) index[p+low] = arr[p];\\n\\t}\\n```\\nCount of Range Sum\\n```\\n\\tpublic int countRangeSum(int[] nums, int lower, int upper) {\\n        if (nums == null || nums.length == 0) return 0;\\n        \\n        long[] sums = new long[nums.length+1];\\n        for (int i = 1; i < sums.length; i++){\\n            sums[i] = nums[i-1] + sums[i-1];\\n        }\\n        \\n        return mergesortCountRangeSum(sums, lower, upper, 0, sums.length-1);\\n    }\\n\\t\\n\\tprivate int mergesortCountRangeSum(long[] sums, int lower, int upper, int low, int high){\\n\\t\\tif (low >= high) return 0;\\n\\t\\t\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint res = mergesortCountRangeSum(sums, lower, upper, low, mid) + \\n\\t\\t\\t\\t\\tmergesortCountRangeSum(sums, lower, upper, mid+1, high);\\n\\t\\tint i = mid+1, j = mid+1;\\n\\t\\t\\n\\t\\t// Time complexity: for i or j, it could only be moved from mid+1 to high,\\n\\t\\t// so this is a two pointer problem, not 2 loops\\n\\t\\tfor (int k = low; k <= mid; k++){\\n\\t\\t\\twhile (i <= high && sums[i] - sums[k] < lower) i++;\\n\\t\\t\\twhile (j <= high && sums[j] - sums[k] <= upper) j++;\\n\\t\\t\\tres += j - i;\\n\\t\\t}\\n\\t\\t\\n\\t\\tmergeCountRangeSum(sums, low, high);\\n\\t\\treturn res;\\n\\t}\\n\\t\\n\\tprivate void mergeCountRangeSum(long[] sums, int low, int high){\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint i = low, j = mid+1, k = 0;\\n\\t\\tlong[] arr = new long[high-low+1];\\n\\t\\t\\n\\t\\twhile (k < arr.length){\\n\\t\\t\\tlong num1 = i <= mid ? sums[i] : Long.MAX_VALUE;\\n\\t\\t\\tlong num2 = j <= high ? sums[j] : Long.MAX_VALUE;\\n\\t\\t\\t\\n\\t\\t\\tarr[k++] = num1 <= num2 ? sums[i++] : sums[j++];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int p = 0; p < arr.length; p++) sums[p+low] = arr[p];\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\n\\tpublic int reversePairs(int[] nums) {\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        return mergesort(nums, 0, nums.length-1);\\n    }\\n\\t\\n\\tprivate int mergesort(int[] nums, int low, int high){\\n\\t\\tif (low >= high) return 0;\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint count = mergesort(nums, low, mid) + mergesort(nums, mid+1, high);\\n\\t\\tfor (int i = low, j = mid+1; i <= mid && j <= high;){\\n\\t\\t\\tif (nums[i] > (long) nums[j] * 2){\\n                count += mid - i + 1;\\n                j++;\\n            }\\n            else i++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tmerge(nums, low, high);\\n\\t\\treturn count;\\n\\t}\\n\\t\\n\\tprivate void merge(int[] nums, int low, int high){\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint[] arr = new int[high - low + 1];\\n\\t\\t\\n\\t\\tint i = low, j = mid + 1, k = 0;\\n\\t\\twhile (k < arr.length){\\n\\t\\t\\tint num1 = i > mid ? Integer.MAX_VALUE : nums[i];\\n\\t\\t\\tint num2 = j > high ? Integer.MAX_VALUE : nums[j];\\n\\t\\t\\t\\n\\t\\t\\tarr[k++] = num1 <= num2 ? nums[i++] : nums[j++];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int p = 0; p < arr.length; p++) nums[p+low] = arr[p];\\n\\t}\\n```\n```\\npublic List<Integer> countSmaller(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] count = new int[nums.length];\\n        int[] index = new int[nums.length];\\n        for (int i = 0; i < index.length; i++) index[i] = i;\\n        \\n        mergeSortCountSmaller(nums, index, count, 0, nums.length-1);\\n        \\n        for (int i : count) res.add(i);\\n        return res;\\n    }\\n\\t\\n\\tprivate void mergeSortCountSmaller(int[] nums, int[] index, int[] count, int low, int high){\\n\\t\\tif (low >= high) return;\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tmergeSortCountSmaller(nums, index, count, low, mid);\\n\\t\\tmergeSortCountSmaller(nums, index, count, mid+1, high);\\n\\t\\tint rightCount = 0, i = low;\\n\\t\\tfor (int j = mid + 1; i <= mid && j <= high; ){\\n\\t\\t\\tif (nums[index[j]] < nums[index[i]]){\\n\\t\\t\\t\\trightCount++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\telse count[index[i++]] += rightCount;\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (i <= mid) count[index[i++]] += rightCount;\\n\\t\\t\\n\\t\\tmergeCountSmaller(nums, index, low, high);\\n\\t}\\n\\t\\n\\tprivate void mergeCountSmaller(int[] nums, int[] index, int low, int high){\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint[] arr = new int[high - low + 1];\\n\\t\\tint i = low, j = mid + 1, k = 0;\\n\\t\\t\\n\\t\\twhile (k < arr.length){\\n\\t\\t\\tint num1 = i <= mid ? nums[index[i]] : Integer.MAX_VALUE;\\n\\t\\t\\tint num2 = j <= high ? nums[index[j]] : Integer.MAX_VALUE;\\n\\t\\t\\t\\n\\t\\t\\tarr[k++] = num1 <= num2 ? index[i++] : index[j++];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int p = 0; p < arr.length; p++) index[p+low] = arr[p];\\n\\t}\\n```\n```\\n\\tpublic int countRangeSum(int[] nums, int lower, int upper) {\\n        if (nums == null || nums.length == 0) return 0;\\n        \\n        long[] sums = new long[nums.length+1];\\n        for (int i = 1; i < sums.length; i++){\\n            sums[i] = nums[i-1] + sums[i-1];\\n        }\\n        \\n        return mergesortCountRangeSum(sums, lower, upper, 0, sums.length-1);\\n    }\\n\\t\\n\\tprivate int mergesortCountRangeSum(long[] sums, int lower, int upper, int low, int high){\\n\\t\\tif (low >= high) return 0;\\n\\t\\t\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint res = mergesortCountRangeSum(sums, lower, upper, low, mid) + \\n\\t\\t\\t\\t\\tmergesortCountRangeSum(sums, lower, upper, mid+1, high);\\n\\t\\tint i = mid+1, j = mid+1;\\n\\t\\t\\n\\t\\t// Time complexity: for i or j, it could only be moved from mid+1 to high,\\n\\t\\t// so this is a two pointer problem, not 2 loops\\n\\t\\tfor (int k = low; k <= mid; k++){\\n\\t\\t\\twhile (i <= high && sums[i] - sums[k] < lower) i++;\\n\\t\\t\\twhile (j <= high && sums[j] - sums[k] <= upper) j++;\\n\\t\\t\\tres += j - i;\\n\\t\\t}\\n\\t\\t\\n\\t\\tmergeCountRangeSum(sums, low, high);\\n\\t\\treturn res;\\n\\t}\\n\\t\\n\\tprivate void mergeCountRangeSum(long[] sums, int low, int high){\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint i = low, j = mid+1, k = 0;\\n\\t\\tlong[] arr = new long[high-low+1];\\n\\t\\t\\n\\t\\twhile (k < arr.length){\\n\\t\\t\\tlong num1 = i <= mid ? sums[i] : Long.MAX_VALUE;\\n\\t\\t\\tlong num2 = j <= high ? sums[j] : Long.MAX_VALUE;\\n\\t\\t\\t\\n\\t\\t\\tarr[k++] = num1 <= num2 ? sums[i++] : sums[j++];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int p = 0; p < arr.length; p++) sums[p+low] = arr[p];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97315,
                "title": "java-merge-sort-solution-o-nlog-n",
                "content": "Similar with count smaller after self, just scan the array before merge\\n```\\npublic class Solution {\\n        \\n    public int ret;\\n    public int reversePairs(int[] nums) {\\n        ret = 0;\\n        mergeSort(nums, 0, nums.length-1);\\n        return ret;\\n    }\\n\\n    public void mergeSort(int[] nums, int left, int right) {\\n        if (right <= left) {\\n            return;\\n        }\\n        int middle = left + (right - left)/2;\\n        mergeSort(nums, left, middle);\\n        mergeSort(nums,middle+1, right);\\n\\n        //count elements\\n        int count = 0;\\n        for (int l = left, r = middle+1; l <= middle;) {\\n            if (r > right || (long)nums[l] <= 2*(long)nums[r]) {\\n                l++;\\n                ret += count;\\n            } else {\\n                r++;\\n                count++;\\n            }\\n        }\\n        \\n        //merge sort\\n        int[] temp = new int[right - left + 1];\\n        for (int l = left, r = middle+1, k = 0; l <= middle || r <= right;) {\\n            if (l <= middle && ((r > right) || nums[l] < nums[r])) {\\n                temp[k++] = nums[l++];\\n            } else {\\n                temp[k++] = nums[r++];\\n            }\\n        }\\n        for (int i = 0; i < temp.length; i++) {\\n            nums[left + i] = temp[i];\\n        }\\n    }\\n}\\n```\\nClearer and simpler version, but slower, got the idea by [another solution](https://discuss.leetcode.com/topic/78953/c-solution-using-merge-sort) \\n\\n```\\npublic class Solution {\\n        \\n    public int ret;\\n    public int reversePairs(int[] nums) {\\n        ret = 0;\\n        mergeSort(nums, 0, nums.length-1);\\n        return ret;\\n    }\\n\\n    public void mergeSort(int[] nums, int left, int right) {\\n        if (right <= left) {\\n            return;\\n        }\\n        int middle = left + (right - left)/2;\\n        mergeSort(nums, left, middle);\\n        mergeSort(nums,middle+1, right);\\n\\n        //count elements\\n        int count = 0;\\n        for (int l = left, r = middle+1; l <= middle;) {\\n            if (r > right || (long)nums[l] <= 2*(long)nums[r]) {\\n                l++;\\n                ret += count;\\n            } else {\\n                r++;\\n                count++;\\n            }\\n        }\\n        \\n        //sort\\n        Arrays.sort(nums, left, right + 1);   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n        \\n    public int ret;\\n    public int reversePairs(int[] nums) {\\n        ret = 0;\\n        mergeSort(nums, 0, nums.length-1);\\n        return ret;\\n    }\\n\\n    public void mergeSort(int[] nums, int left, int right) {\\n        if (right <= left) {\\n            return;\\n        }\\n        int middle = left + (right - left)/2;\\n        mergeSort(nums, left, middle);\\n        mergeSort(nums,middle+1, right);\\n\\n        //count elements\\n        int count = 0;\\n        for (int l = left, r = middle+1; l <= middle;) {\\n            if (r > right || (long)nums[l] <= 2*(long)nums[r]) {\\n                l++;\\n                ret += count;\\n            } else {\\n                r++;\\n                count++;\\n            }\\n        }\\n        \\n        //merge sort\\n        int[] temp = new int[right - left + 1];\\n        for (int l = left, r = middle+1, k = 0; l <= middle || r <= right;) {\\n            if (l <= middle && ((r > right) || nums[l] < nums[r])) {\\n                temp[k++] = nums[l++];\\n            } else {\\n                temp[k++] = nums[r++];\\n            }\\n        }\\n        for (int i = 0; i < temp.length; i++) {\\n            nums[left + i] = temp[i];\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n        \\n    public int ret;\\n    public int reversePairs(int[] nums) {\\n        ret = 0;\\n        mergeSort(nums, 0, nums.length-1);\\n        return ret;\\n    }\\n\\n    public void mergeSort(int[] nums, int left, int right) {\\n        if (right <= left) {\\n            return;\\n        }\\n        int middle = left + (right - left)/2;\\n        mergeSort(nums, left, middle);\\n        mergeSort(nums,middle+1, right);\\n\\n        //count elements\\n        int count = 0;\\n        for (int l = left, r = middle+1; l <= middle;) {\\n            if (r > right || (long)nums[l] <= 2*(long)nums[r]) {\\n                l++;\\n                ret += count;\\n            } else {\\n                r++;\\n                count++;\\n            }\\n        }\\n        \\n        //sort\\n        Arrays.sort(nums, left, right + 1);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298986,
                "title": "java-segment-tree",
                "content": "With the segment tree we can ask, \"how many elements in the tree have value >= X?\"\\nThe segment tree contains all values that could be used as `i`.\\n\\nIt is worth noting that this is NOT `O(n log(n))`. The height of the segment tree is not based on nums.length. This is more like `O(n log(Integer.MAX_VALUE))`.\\n\\n```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        int res=0;\\n        int n=nums.length;\\n        Seg tree = new Seg(Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        for (int j = 1; j < n; j++) {\\n            tree.add(nums[j-1]);\\n            res += tree.count(nums[j]*2L+1L);\\n        }\\n        return res;\\n    }\\n    \\n    class Seg {\\n        private long min, max;\\n        private int count;\\n        private Seg L, R;\\n        \\n        public Seg(long min, long max) {\\n            this.min = min;\\n            this.max = max;\\n            count = 0;\\n            L = R = null;\\n        }\\n        \\n        public void add(long n) {\\n            count++;\\n            if (min==max)return;\\n            long mid = (max-min)/2+min;\\n            if (n <= mid) {\\n                // left\\n                if (L==null) L = new Seg(min, mid);\\n                L.add(n);\\n            } else {\\n                // right\\n                if (R==null) R = new Seg(mid+1,max);\\n                R.add(n);\\n            }\\n        }\\n        \\n        public int count(long n) {\\n            if (min>=n) return count;\\n            if (max<n) return 0;\\n            return\\n                (L==null?0:L.count(n))+\\n                (R==null?0:R.count(n));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        int res=0;\\n        int n=nums.length;\\n        Seg tree = new Seg(Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        for (int j = 1; j < n; j++) {\\n            tree.add(nums[j-1]);\\n            res += tree.count(nums[j]*2L+1L);\\n        }\\n        return res;\\n    }\\n    \\n    class Seg {\\n        private long min, max;\\n        private int count;\\n        private Seg L, R;\\n        \\n        public Seg(long min, long max) {\\n            this.min = min;\\n            this.max = max;\\n            count = 0;\\n            L = R = null;\\n        }\\n        \\n        public void add(long n) {\\n            count++;\\n            if (min==max)return;\\n            long mid = (max-min)/2+min;\\n            if (n <= mid) {\\n                // left\\n                if (L==null) L = new Seg(min, mid);\\n                L.add(n);\\n            } else {\\n                // right\\n                if (R==null) R = new Seg(mid+1,max);\\n                R.add(n);\\n            }\\n        }\\n        \\n        public int count(long n) {\\n            if (min>=n) return count;\\n            if (max<n) return 0;\\n            return\\n                (L==null?0:L.count(n))+\\n                (R==null?0:R.count(n));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97272,
                "title": "clean-java-solution-using-enhanced-binary-search-tree",
                "content": "This is literally the same problem with [315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/).\\nThe only difference is to find count of numbers smaller than ```half``` of the current number after itself. \\nTo efficiently search for count of numbers smaller than a target, we can use a Binary Search Tree. There is a little change of the TreeNode to include count of numbers ```smaller or equal``` to it. This will make the query even faster because we don't need to traverse all its left sub-tree to get the count.\\n\\nOverall Algorithm:\\n1. Scan the numbers from right to left.\\n2. First search the tree to get ```count``` of numbers smaller than ```nums[i] / 2.0```, sum to the final result.\\n3. Insert ```nums[i]``` to the tree.\\n\\nInsert logic:\\n1. Recursively try to find a place to insert this number. When root is ```null```, its time to create a new node. If meet the ```same``` number, just increase the ```count```.\\n2. When try to insert the number to left sub-tree, increase ```count``` of current node.\\n\\nQuery logic:\\n1. If target value is greater than the current value, meaning current node and all left sub-tree are ```smaller``` than target, return ```count``` (remember it stands for count of numbers ```smaller or equal``` to current number) of current node ```plus``` any possible smaller number than target in ```right``` sub-tree.\\n2. Otherwise, only search ```left``` sub-tree.\\n\\n```\\npublic class Solution {\\n    class Node {\\n\\tint value, count;\\n\\tNode left, right;\\n\\tNode (int v) {\\n\\t    value = v; count = 1;\\n\\t}\\n    }\\n\\t\\n    public int reversePairs(int[] nums) {\\n        int result = 0;\\n        if (nums == null || nums.length <= 1) return result;\\n        \\n        int len = nums.length;\\n\\tNode root = new Node(nums[len - 1]);\\n\\t    \\n\\tfor(int i = len - 2; i >= 0; i--) {\\n\\t    result += query(root, nums[i] / 2.0);\\n\\t    insert(root, nums[i]);\\n\\t}\\n\\n\\treturn result;\\n    }\\n    \\n    private Node insert(Node root, int value) {\\n\\tif (root == null) return new Node(value);\\n\\t\\t\\n\\tif (root.value == value) {\\n\\t    root.count++;\\n\\t}\\n\\telse if (root.value > value) {\\n\\t    root.count++;\\n\\t    root.left = insert(root.left, value);\\n\\t}\\n\\telse {\\n\\t    root.right = insert(root.right, value);\\n\\t}\\n\\t\\t\\n\\treturn root;\\n    }\\n\\t\\n    private int query(Node root, double value) {\\n\\tif (root == null) return 0;\\n\\t\\t\\n\\tif (value > root.value) {\\n\\t    return root.count + query(root.right, value);\\n\\t}\\n\\telse {\\n\\t    return query(root.left, value);\\n\\t}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```half```\n```smaller or equal```\n```count```\n```nums[i] / 2.0```\n```nums[i]```\n```null```\n```same```\n```count```\n```count```\n```smaller```\n```count```\n```smaller or equal```\n```plus```\n```right```\n```left```\n```\\npublic class Solution {\\n    class Node {\\n\\tint value, count;\\n\\tNode left, right;\\n\\tNode (int v) {\\n\\t    value = v; count = 1;\\n\\t}\\n    }\\n\\t\\n    public int reversePairs(int[] nums) {\\n        int result = 0;\\n        if (nums == null || nums.length <= 1) return result;\\n        \\n        int len = nums.length;\\n\\tNode root = new Node(nums[len - 1]);\\n\\t    \\n\\tfor(int i = len - 2; i >= 0; i--) {\\n\\t    result += query(root, nums[i] / 2.0);\\n\\t    insert(root, nums[i]);\\n\\t}\\n\\n\\treturn result;\\n    }\\n    \\n    private Node insert(Node root, int value) {\\n\\tif (root == null) return new Node(value);\\n\\t\\t\\n\\tif (root.value == value) {\\n\\t    root.count++;\\n\\t}\\n\\telse if (root.value > value) {\\n\\t    root.count++;\\n\\t    root.left = insert(root.left, value);\\n\\t}\\n\\telse {\\n\\t    root.right = insert(root.right, value);\\n\\t}\\n\\t\\t\\n\\treturn root;\\n    }\\n\\t\\n    private int query(Node root, double value) {\\n\\tif (root == null) return 0;\\n\\t\\t\\n\\tif (value > root.value) {\\n\\t    return root.count + query(root.right, value);\\n\\t}\\n\\telse {\\n\\t    return query(root.left, value);\\n\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332070,
                "title": "c-easy-explanation-and-pattern-for-future-questions",
                "content": "\\uD83D\\uDD25 Please **Upvote** for the Contribution, It is **FREE** from your side.\\n\\n***Pattern***:- Whenever you face a question in which You want to compare the element to its right array You can do it by Merge Sort Algorithm. It is itself a Comparison algorithm from Divide and Conquer. Two pointers makes our task easy in which we want something to pick from right after choosing or fixing or left elment.\\n\\nGenerally to find pairs and do something with the pairs will take O(n^2) time because of generating all pairs or including two nested loops. But to make it to O(nlogn) in which you want to do some calculation on the pairs, You can use Merge Sort Divide and Conquer Algorithm.\\n\\n\\uD83D\\uDE07 **Similar Pattern Questions are:- Nut and Bolt, Lock and Key etc.**\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &nums, int si, int ei, int mid, int &count){\\n        int j = mid+1;\\n        int i = si;\\n        // Main Crux of the Problem Lies Here\\n        for(; i<=mid; i++){\\n            while(j<=ei && nums[i]>(2*(long)nums[j])){\\n                j++;\\n            }\\n            count+=(j-(mid+1));\\n        }\\n        i = si;\\n        j = mid+1;\\n        int index = 0;\\n        vector<int> result(ei-si+1);\\n        while(i<=mid && j<=ei){\\n            if(nums[i]<=nums[j]){\\n                result[index] = nums[i];\\n                i++;\\n            }else if(nums[i]>nums[j]){\\n                result[index] = nums[j];\\n                j++;\\n            }\\n            index++;\\n        }\\n        while(i<=mid){\\n            result[index++] = nums[i++];\\n        }\\n        while(j<=ei){\\n            result[index++] = nums[j++];\\n        }\\n        index = 0;\\n        for(i = si; i<=ei; i++){\\n            nums[i] = result[index++];\\n        }\\n        return;\\n    }\\n    \\n    \\n    void mergeSort(vector<int> &nums, int si, int ei, int &count){\\n        if(si>=ei){\\n            return;\\n        }\\n        int mid = si+(ei-si)/2;\\n        mergeSort(nums, si, mid, count);\\n        mergeSort(nums, mid+1, ei, count);\\n        merge(nums, si, ei, mid, count);\\n        return;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = 0;\\n        mergeSort(nums, 0, n-1, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &nums, int si, int ei, int mid, int &count){\\n        int j = mid+1;\\n        int i = si;\\n        // Main Crux of the Problem Lies Here\\n        for(; i<=mid; i++){\\n            while(j<=ei && nums[i]>(2*(long)nums[j])){\\n                j++;\\n            }\\n            count+=(j-(mid+1));\\n        }\\n        i = si;\\n        j = mid+1;\\n        int index = 0;\\n        vector<int> result(ei-si+1);\\n        while(i<=mid && j<=ei){\\n            if(nums[i]<=nums[j]){\\n                result[index] = nums[i];\\n                i++;\\n            }else if(nums[i]>nums[j]){\\n                result[index] = nums[j];\\n                j++;\\n            }\\n            index++;\\n        }\\n        while(i<=mid){\\n            result[index++] = nums[i++];\\n        }\\n        while(j<=ei){\\n            result[index++] = nums[j++];\\n        }\\n        index = 0;\\n        for(i = si; i<=ei; i++){\\n            nums[i] = result[index++];\\n        }\\n        return;\\n    }\\n    \\n    \\n    void mergeSort(vector<int> &nums, int si, int ei, int &count){\\n        if(si>=ei){\\n            return;\\n        }\\n        int mid = si+(ei-si)/2;\\n        mergeSort(nums, si, mid, count);\\n        mergeSort(nums, mid+1, ei, count);\\n        merge(nums, si, ei, mid, count);\\n        return;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = 0;\\n        mergeSort(nums, 0, n-1, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411724,
                "title": "bit-segment-tree-faster-than-99",
                "content": "* BIT\\n```cpp\\n#pragma GCC optimise (\"Ofast\")\\nstatic auto x= []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL;}();\\n\\nclass Solution {\\nprivate:\\n    int getSum(int *bit, int idx) {\\n        int s = 0;\\n        for(; idx; idx -= idx & -idx) s += bit[idx];\\n        return s;\\n    }\\n    void update(int *bit, int n, int idx, int val) {\\n        for (; idx <= n; idx += idx & -idx) bit[idx] += val;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (!nums.size()) return 0;\\n        int n = nums.size(), inversions = 0;\\n        int temp[n];\\n        for (int i=0; i<n; i++) temp[i] = nums[i];\\n        sort(temp, temp+n);\\n        int bit[n+1] = {0};\\n        for (int i=0; i<n; i++) {\\n            int index = upper_bound(temp, temp+n, 2L * nums[i]) - temp;\\n            inversions += i - getSum(bit, index);\\n            index = upper_bound(temp, temp+n, nums[i]) - temp;\\n            update(bit, n, index, 1);\\n        }\\n        return inversions;\\n    }\\n};\\n```\\n* Segment Tree\\n```cpp\\ntypedef long long int lli;\\n\\nclass Solution {\\nprivate:\\n    void update(int *tree, int n, int idx, int val) {\\n        idx += n;\\n        tree[idx] += val;\\n        for (int i=idx; i>1; i>>=1) tree[i>>1] = tree[i] + tree[i^1];\\n    }\\n    int query(int *tree, int n, int pos) {\\n        int l = pos + n, r = 2 * n, sum = 0;\\n        for (; l<r; l>>=1, r>>=1) {\\n            if (l & 1) sum += tree[l++];\\n            if (r & 1) sum += tree[--r];\\n        }\\n        return sum;\\n    }\\n    int getIndex(int *a, int n, lli val) {\\n        return lower_bound(a, a+n, val) - a;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int n = nums.size(), inversions = 0, tree[n<<1] = {0}, temp[n];\\n        for (int i=0; i<n; i++) temp[i] = nums[i];\\n        sort(temp, temp+n);\\n        for (lli num : nums) {\\n            inversions += query(tree, n, getIndex(temp, n, num*2+1));\\n            update(tree, n, getIndex(temp, n, num), 1);\\n        }\\n        return inversions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\n#pragma GCC optimise (\"Ofast\")\\nstatic auto x= []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL;}();\\n\\nclass Solution {\\nprivate:\\n    int getSum(int *bit, int idx) {\\n        int s = 0;\\n        for(; idx; idx -= idx & -idx) s += bit[idx];\\n        return s;\\n    }\\n    void update(int *bit, int n, int idx, int val) {\\n        for (; idx <= n; idx += idx & -idx) bit[idx] += val;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (!nums.size()) return 0;\\n        int n = nums.size(), inversions = 0;\\n        int temp[n];\\n        for (int i=0; i<n; i++) temp[i] = nums[i];\\n        sort(temp, temp+n);\\n        int bit[n+1] = {0};\\n        for (int i=0; i<n; i++) {\\n            int index = upper_bound(temp, temp+n, 2L * nums[i]) - temp;\\n            inversions += i - getSum(bit, index);\\n            index = upper_bound(temp, temp+n, nums[i]) - temp;\\n            update(bit, n, index, 1);\\n        }\\n        return inversions;\\n    }\\n};\\n```\n```cpp\\ntypedef long long int lli;\\n\\nclass Solution {\\nprivate:\\n    void update(int *tree, int n, int idx, int val) {\\n        idx += n;\\n        tree[idx] += val;\\n        for (int i=idx; i>1; i>>=1) tree[i>>1] = tree[i] + tree[i^1];\\n    }\\n    int query(int *tree, int n, int pos) {\\n        int l = pos + n, r = 2 * n, sum = 0;\\n        for (; l<r; l>>=1, r>>=1) {\\n            if (l & 1) sum += tree[l++];\\n            if (r & 1) sum += tree[--r];\\n        }\\n        return sum;\\n    }\\n    int getIndex(int *a, int n, lli val) {\\n        return lower_bound(a, a+n, val) - a;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int n = nums.size(), inversions = 0, tree[n<<1] = {0}, temp[n];\\n        for (int i=0; i<n; i++) temp[i] = nums[i];\\n        sort(temp, temp+n);\\n        for (lli num : nums) {\\n            inversions += query(tree, n, getIndex(temp, n, num*2+1));\\n            update(tree, n, getIndex(temp, n, num), 1);\\n        }\\n        return inversions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385371,
                "title": "python-solutions",
                "content": "Binary Search Tree Solution\\n\\n```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        \\n        root = None\\n        ans = 0\\n        \\n        for n in nums:\\n            ans += self.bst_search(root,2*n)\\n            if root:\\n                self.bst(root,n)\\n            else:\\n                root = tree(n)\\n        \\n        return ans\\n    \\n    def bst_search(self, root, val):\\n        if not root:\\n            return 0\\n        \\n        if root.val <= val:\\n            ans = self.bst_search(root.right, val)\\n        else:\\n            l = self.bst_search(root.left, val)\\n            r = self.bst_search(root.right, val)\\n            ans = l+r+1\\n        \\n        return ans\\n        \\n    \\n    \\n    def bst(self,root, val):\\n        if val > root.val:\\n            if not root.right:\\n                root.right = tree(val)\\n                return\\n            else:\\n                return self.bst(root.right,val)\\n        else:\\n            if not root.left:\\n                root.left = tree(val)\\n                return\\n            else:\\n                return self.bst(root.left, val)\\n\\nclass tree():\\n    def __init__(self,val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n```\\n\\nBinary Indexed Tree Solution\\n\\n```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        \\n        if not nums:\\n            return 0\\n        \\n        nnums = list(set(nums+[2*n for n in nums]))\\n        nnums.sort()\\n        tree = BIT(len(nnums))\\n        d = {}\\n        for i, n in enumerate(nnums):\\n            d[n] = i+1\\n        \\n        ans = 0\\n        for n in nums[::-1]:\\n            ans += tree.getsum(d[n]-1)\\n            tree.update(d[2*n],1)\\n        \\n        return ans\\n    \\nclass BIT():\\n    def __init__(self, N):\\n        self.tree = [0]*(N+1)\\n        self.n = N+1\\n    \\n    def update(self, ind, val):\\n        while ind < self.n:\\n            self.tree[ind] += val\\n            ind += (ind & (-ind))\\n        return\\n    \\n    def getsum(self, ind):\\n        s = 0\\n        while ind > 0:\\n            s += self.tree[ind]\\n            ind -= (ind & (-ind))\\n        return s\\n\\n```\\n\\nMergeSort solution\\n\\n```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        return self.mergesort(nums)[1]\\n    \\n    \\n    def mergesort(self, nums):\\n        if len(nums) <= 1:\\n            return nums, 0\\n        m = len(nums)//2\\n        left, countl = self.mergesort(nums[:m])\\n        right, countr = self.mergesort(nums[m:])\\n        count = countl + countr\\n        for r in right:\\n            temp = len(left) - bisect.bisect(left, 2*r)\\n            if temp == 0:\\n                break\\n            count += temp\\n        \\n        return sorted(left+right), count    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        \\n        root = None\\n        ans = 0\\n        \\n        for n in nums:\\n            ans += self.bst_search(root,2*n)\\n            if root:\\n                self.bst(root,n)\\n            else:\\n                root = tree(n)\\n        \\n        return ans\\n    \\n    def bst_search(self, root, val):\\n        if not root:\\n            return 0\\n        \\n        if root.val <= val:\\n            ans = self.bst_search(root.right, val)\\n        else:\\n            l = self.bst_search(root.left, val)\\n            r = self.bst_search(root.right, val)\\n            ans = l+r+1\\n        \\n        return ans\\n        \\n    \\n    \\n    def bst(self,root, val):\\n        if val > root.val:\\n            if not root.right:\\n                root.right = tree(val)\\n                return\\n            else:\\n                return self.bst(root.right,val)\\n        else:\\n            if not root.left:\\n                root.left = tree(val)\\n                return\\n            else:\\n                return self.bst(root.left, val)\\n\\nclass tree():\\n    def __init__(self,val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n```\n```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        \\n        if not nums:\\n            return 0\\n        \\n        nnums = list(set(nums+[2*n for n in nums]))\\n        nnums.sort()\\n        tree = BIT(len(nnums))\\n        d = {}\\n        for i, n in enumerate(nnums):\\n            d[n] = i+1\\n        \\n        ans = 0\\n        for n in nums[::-1]:\\n            ans += tree.getsum(d[n]-1)\\n            tree.update(d[2*n],1)\\n        \\n        return ans\\n    \\nclass BIT():\\n    def __init__(self, N):\\n        self.tree = [0]*(N+1)\\n        self.n = N+1\\n    \\n    def update(self, ind, val):\\n        while ind < self.n:\\n            self.tree[ind] += val\\n            ind += (ind & (-ind))\\n        return\\n    \\n    def getsum(self, ind):\\n        s = 0\\n        while ind > 0:\\n            s += self.tree[ind]\\n            ind -= (ind & (-ind))\\n        return s\\n\\n```\n```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        return self.mergesort(nums)[1]\\n    \\n    \\n    def mergesort(self, nums):\\n        if len(nums) <= 1:\\n            return nums, 0\\n        m = len(nums)//2\\n        left, countl = self.mergesort(nums[:m])\\n        right, countr = self.mergesort(nums[m:])\\n        count = countl + countr\\n        for r in right:\\n            temp = len(left) - bisect.bisect(left, 2*r)\\n            if temp == 0:\\n                break\\n            count += temp\\n        \\n        return sorted(left+right), count    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 283504,
                "title": "c-o-nlgn-solution-using-fenwick-tree-binary-indexed-tree-with-discretization",
                "content": "Admittedly, I suggest using mergesort solution in real interviews. But this question is a good practice for fenwick tree.\\n```\\nclass FenwickTree {\\npublic:\\n    FenwickTree(int n): sums(n+1, 0) {}\\n    \\n    void update(int i, int delta) {\\n        while (i < sums.size()) {\\n            sums[i] += delta;\\n            i += lowbit(i);\\n        }\\n    }\\n    \\n    int query(int i) {\\n        int sum = 0;\\n        while (i > 0) {\\n            sum += sums[i];\\n            i -= lowbit(i);\\n        }\\n        return sum;\\n    }\\n    \\nprivate:\\n    vector<int> sums;\\n    static inline int lowbit(int x) {\\n        return x & (-x);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        \\n        vector<long> nums2;\\n        for (long num : nums) {\\n            nums2.push_back(2*num);\\n        }\\n        \\n\\t\\t// combine nums and nums2, remove duplicates, then sort\\n        set<long> sorted;\\n        sorted.insert(nums.begin(), nums.end());\\n        sorted.insert(nums2.begin(), nums2.end());\\n        \\n\\t\\t// map original nums to range [1, sorted.size()]\\n        int rank = 0;\\n        unordered_map<long, int> ranks;\\n        for (long num : sorted) {\\n            ranks[num] = ++rank;\\n        }\\n        \\n        FenwickTree tree(ranks.size());\\n        \\n        int res = 0;\\n        \\n\\t\\t// from right to left, because we want to find how many nums are smaller than 1/2 of current num on the right\\n        for (int i = static_cast<int>(nums2.size())-1; i >= 0; --i) {\\n            res += tree.query(ranks[nums2[i] / 2] - 1);\\n            tree.update(ranks[nums2[i]], 1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nbtw: Does any one know what the term is for \"\\u79BB\\u6563\\u5316\" in English? I tried \"discretization\", but only find Chinese blogs using this word.",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass FenwickTree {\\npublic:\\n    FenwickTree(int n): sums(n+1, 0) {}\\n    \\n    void update(int i, int delta) {\\n        while (i < sums.size()) {\\n            sums[i] += delta;\\n            i += lowbit(i);\\n        }\\n    }\\n    \\n    int query(int i) {\\n        int sum = 0;\\n        while (i > 0) {\\n            sum += sums[i];\\n            i -= lowbit(i);\\n        }\\n        return sum;\\n    }\\n    \\nprivate:\\n    vector<int> sums;\\n    static inline int lowbit(int x) {\\n        return x & (-x);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        \\n        vector<long> nums2;\\n        for (long num : nums) {\\n            nums2.push_back(2*num);\\n        }\\n        \\n\\t\\t// combine nums and nums2, remove duplicates, then sort\\n        set<long> sorted;\\n        sorted.insert(nums.begin(), nums.end());\\n        sorted.insert(nums2.begin(), nums2.end());\\n        \\n\\t\\t// map original nums to range [1, sorted.size()]\\n        int rank = 0;\\n        unordered_map<long, int> ranks;\\n        for (long num : sorted) {\\n            ranks[num] = ++rank;\\n        }\\n        \\n        FenwickTree tree(ranks.size());\\n        \\n        int res = 0;\\n        \\n\\t\\t// from right to left, because we want to find how many nums are smaller than 1/2 of current num on the right\\n        for (int i = static_cast<int>(nums2.size())-1; i >= 0; --i) {\\n            res += tree.query(ranks[nums2[i] / 2] - 1);\\n            tree.update(ranks[nums2[i]], 1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806004,
                "title": "c-merge-sort-approach-clean-code",
                "content": "**1. Merge Sort + Sorting ( Quick Sort C++ STL )** \\n\\n**Time Complexity : O ( n * n * log n ) \\nSpace Complexity : O ( 1 )**\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>&nums,int low,int mid,int high,int &c)\\n    {\\n        int i=low;\\n        int j=mid+1;\\n        \\n       \\n        \\n        while(i<=mid and j<=high)\\n        {\\n            if(nums[i]>2*1ll*nums[j])\\n            {\\n                c+=(mid-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\t\\t// This may take upto nlogn time in worst case\\n        sort(nums.begin()+low,nums.begin()+high+1);\\n    }\\n    void mergeSort(vector<int>&nums,int low,int high,int &c)\\n    {\\n        if(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            mergeSort(nums,low,mid,c);\\n            mergeSort(nums,mid+1,high,c);\\n            \\n            merge(nums,low,mid,high,c);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        int c=0;\\n        mergeSort(nums,0,n-1,c);\\n        return c;\\n    }\\n};\\n```\\n\\n\\n**2. Merge Sort + Sorting ( Using Merge Sort Technique )** \\n\\n**Time Complexity : O ( n * log n ) \\nSpace Complexity : O ( n )**\\n\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>&nums,int low,int mid,int high,int &c)\\n    {\\n        int i=low;\\n        int j=mid+1;\\n        \\n        vector<int>temp(high-low+1);\\n        \\n        while(i<=mid and j<=high)\\n        {\\n            if(nums[i]>2*1ll*nums[j])\\n            {\\n                c+=(mid-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        i=low;\\n        j=mid+1;\\n        int k=0;\\n        while(i<=mid and j<=high)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                temp[k++]=nums[i++];\\n            }\\n            else\\n            {\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid)\\n            temp[k++]=nums[i++];\\n        while(j<=high)\\n            temp[k++]=nums[j++];\\n        \\n        for(i=low;i<=high;i++)\\n            nums[i]=temp[i-low];\\n        //sort(nums.begin()+low,nums.begin()+high+1);\\n    }\\n    void mergeSort(vector<int>&nums,int low,int high,int &c)\\n    {\\n        if(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            mergeSort(nums,low,mid,c);\\n            mergeSort(nums,mid+1,high,c);\\n            \\n            merge(nums,low,mid,high,c);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        int c=0;\\n        mergeSort(nums,0,n-1,c);\\n        return c;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>&nums,int low,int mid,int high,int &c)\\n    {\\n        int i=low;\\n        int j=mid+1;\\n        \\n       \\n        \\n        while(i<=mid and j<=high)\\n        {\\n            if(nums[i]>2*1ll*nums[j])\\n            {\\n                c+=(mid-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\t\\t// This may take upto nlogn time in worst case\\n        sort(nums.begin()+low,nums.begin()+high+1);\\n    }\\n    void mergeSort(vector<int>&nums,int low,int high,int &c)\\n    {\\n        if(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            mergeSort(nums,low,mid,c);\\n            mergeSort(nums,mid+1,high,c);\\n            \\n            merge(nums,low,mid,high,c);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        int c=0;\\n        mergeSort(nums,0,n-1,c);\\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>&nums,int low,int mid,int high,int &c)\\n    {\\n        int i=low;\\n        int j=mid+1;\\n        \\n        vector<int>temp(high-low+1);\\n        \\n        while(i<=mid and j<=high)\\n        {\\n            if(nums[i]>2*1ll*nums[j])\\n            {\\n                c+=(mid-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        i=low;\\n        j=mid+1;\\n        int k=0;\\n        while(i<=mid and j<=high)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                temp[k++]=nums[i++];\\n            }\\n            else\\n            {\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid)\\n            temp[k++]=nums[i++];\\n        while(j<=high)\\n            temp[k++]=nums[j++];\\n        \\n        for(i=low;i<=high;i++)\\n            nums[i]=temp[i-low];\\n        //sort(nums.begin()+low,nums.begin()+high+1);\\n    }\\n    void mergeSort(vector<int>&nums,int low,int high,int &c)\\n    {\\n        if(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            mergeSort(nums,low,mid,c);\\n            mergeSort(nums,mid+1,high,c);\\n            \\n            merge(nums,low,mid,high,c);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        int c=0;\\n        mergeSort(nums,0,n-1,c);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97306,
                "title": "20-lines-java-code-beats-100",
                "content": "Thanks to @Pepsi's solution of [327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/?tab=Description). My code below is so similar with the one Pepsi posted [here](https://discuss.leetcode.com/topic/33738/share-my-solution). \\n\\n@Chidong's solution with BST is really impressive, but I think because it *may not be a balanced tree*, his solution maybe not *strictly* O(nlogn), but **merge sort** can do it with **worst case time complexity** in **O(nlogn)**, so that my solution could beat 100%. That's just my guess. please let me know if I am wrong.\\n\\n```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        return mergeSort(nums, 0, nums.length - 1);\\n    }\\n    private int mergeSort(int[] nums, int l, int r) {\\n        if (l >= r) return 0;\\n        int mid = l + (r - l)/2;\\n        int count = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r);\\n        int[] cache = new int[r - l + 1];\\n        int i = l, t = l, c = 0;\\n        for (int j = mid + 1; j <= r; j++, c++) {\\n            while (i <= mid && nums[i] <= 2 * (long)nums[j]) i++;\\n            while (t <= mid && nums[t] < nums[j]) cache[c++] = nums[t++];\\n            cache[c] = nums[j];\\n            count += mid - i + 1;\\n        }\\n        while (t <= mid) cache[c++] = nums[t++];\\n        System.arraycopy(cache, 0, nums, l, r - l + 1);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        return mergeSort(nums, 0, nums.length - 1);\\n    }\\n    private int mergeSort(int[] nums, int l, int r) {\\n        if (l >= r) return 0;\\n        int mid = l + (r - l)/2;\\n        int count = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r);\\n        int[] cache = new int[r - l + 1];\\n        int i = l, t = l, c = 0;\\n        for (int j = mid + 1; j <= r; j++, c++) {\\n            while (i <= mid && nums[i] <= 2 * (long)nums[j]) i++;\\n            while (t <= mid && nums[t] < nums[j]) cache[c++] = nums[t++];\\n            cache[c] = nums[j];\\n            count += mid - i + 1;\\n        }\\n        while (t <= mid) cache[c++] = nums[t++];\\n        System.arraycopy(cache, 0, nums, l, r - l + 1);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845952,
                "title": "c-using-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int merge(vector<int> &nums, int l, int m, int h) {\\n        int count=0;\\n        int j=m+1;\\n        for(int i=l;i<=m;++i) {\\n            while(j<=h && nums[i] > 2LL*nums[j]) ++j;\\n            count += (j - (m+1));\\n        }\\n        // merge of two sorted array\\n        vector<int> temp;\\n        int left=l,right=m+1;\\n        // loop till on of them execuested\\n        while(left<=m && right<=h) {\\n            if(nums[left]<=nums[right]) temp.push_back(nums[left++]);\\n            else temp.push_back(nums[right++]);\\n        }\\n        // remaining elements of left side\\n        while(left<=m) temp.push_back(nums[left++]);\\n        // remaining elements of right side\\n        while(right<=h) temp.push_back(nums[right++]);\\n        // assingn in main vector after merging\\n        for(int i=l;i<=h;++i) {\\n            nums[i]=temp[i-l];\\n        }\\n        return count;\\n    }\\n    int mergeSort(vector<int> &nums, int l, int h) {\\n        if(l>=h) return 0; // A single element does not contain any pair \\n        int m=(l+h)/2;\\n        int count=0;\\n        count += mergeSort(nums,l,m);    // count from left side of vector\\n        count += mergeSort(nums,m+1,h);  // count from right side of vector\\n        count += merge(nums,l,m,h);      // count merge \\n        return count;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums, 0, nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int merge(vector<int> &nums, int l, int m, int h) {\\n        int count=0;\\n        int j=m+1;\\n        for(int i=l;i<=m;++i) {\\n            while(j<=h && nums[i] > 2LL*nums[j]) ++j;\\n            count += (j - (m+1));\\n        }\\n        // merge of two sorted array\\n        vector<int> temp;\\n        int left=l,right=m+1;\\n        // loop till on of them execuested\\n        while(left<=m && right<=h) {\\n            if(nums[left]<=nums[right]) temp.push_back(nums[left++]);\\n            else temp.push_back(nums[right++]);\\n        }\\n        // remaining elements of left side\\n        while(left<=m) temp.push_back(nums[left++]);\\n        // remaining elements of right side\\n        while(right<=h) temp.push_back(nums[right++]);\\n        // assingn in main vector after merging\\n        for(int i=l;i<=h;++i) {\\n            nums[i]=temp[i-l];\\n        }\\n        return count;\\n    }\\n    int mergeSort(vector<int> &nums, int l, int h) {\\n        if(l>=h) return 0; // A single element does not contain any pair \\n        int m=(l+h)/2;\\n        int count=0;\\n        count += mergeSort(nums,l,m);    // count from left side of vector\\n        count += mergeSort(nums,m+1,h);  // count from right side of vector\\n        count += merge(nums,l,m,h);      // count merge \\n        return count;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums, 0, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97302,
                "title": "share-my-avl-tree-solution-o-nlgn-time",
                "content": "Ref:\\n(1) http://www.geeksforgeeks.org/avl-tree-set-1-insertion/\\n\\npublic class Solution {\\n    \\n\\n\\n    public int reversePairs(int[] nums) {\\n        \\n        // Algo thinking: building a BST, go left when node.val <= 2 * root.val, right otherwise\\n        // But need to keep it balanced -> AVL Tree or Red-Black Tree\\n        // time = O(NlgN), space = O(N)\\n        \\n        if (nums == null || nums.length == 0) return 0;\\n        \\n        int n = nums.length;\\n        \\n        TreeNode root = new TreeNode(nums[0]);\\n        int ans = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            ans += search(root, (long) nums[i] * 2);\\n            root = insert(root, (long) nums[i]);\\n\\n            // preOrder(root);\\n            // System.out.println();\\n        }\\n        \\n        return ans;\\n            \\n    }\\n    \\n    private int search(TreeNode root, long key) {\\n        \\n        if (root == null) return 0;\\n        \\n        if (key < root.val) {       // key < root.val:  go left\\n            return root.rightCount + search(root.left, key);\\n        } else {                    // key >= root.val: go right\\n            return search(root.right, key);\\n        }\\n    }\\n    \\n    private TreeNode insert(TreeNode root, long key) {\\n        \\n        if (root == null) return new TreeNode(key);\\n        \\n        if (key < root.val) {   // key < root.val:  go left\\n            root.left = insert(root.left, key);\\n        } else if (key == root.val){\\n            root.rightCount++;\\n            return root;\\n        } else {\\n            root.rightCount++;\\n            root.right = insert(root.right, key);\\n        }\\n        \\n        root.height = Math.max(getHeight(root.left), getHeight(root.right)) + 1;\\n        \\n        int balance = getBalance(root);\\n        \\n        // System.out.println(root.val + \" balance \" + balance);\\n        \\n        // case 1 left left \\n        if (balance > 1 && getHeight(root.left.left) > getHeight(root.left.right)) {\\n            return rightRotate(root);\\n        }\\n        \\n        // case 2 left right \\n        if (balance > 1 && getHeight(root.left.left) < getHeight(root.left.right)) {\\n            root.left = leftRotate(root.left);\\n            return  rightRotate(root);\\n        }\\n        \\n        // case 3 right right\\n        if (balance < -1 && getHeight(root.right.left) < getHeight(root.right.right)) {\\n            return leftRotate(root);\\n        }\\n        \\n        // case 4 right left \\n        if (balance < -1 && getHeight(root.right.left) > getHeight(root.right.right)) {\\n            root.right = rightRotate(root.right);\\n            return leftRotate(root);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private TreeNode leftRotate(TreeNode root) {\\n        \\n        // setp 1: take care of nodes\\n        TreeNode newRoot = root.right;\\n        TreeNode b = newRoot.left;\\n        \\n        newRoot.left = root;\\n        root.right = b;\\n        \\n        // step 2: take care of height\\n        root.height = Math.max(getHeight(root.left), getHeight(root.right)) + 1;\\n        newRoot.height = Math.max(getHeight(newRoot.left), getHeight(newRoot.right)) + 1;\\n        \\n        // step 3: take care of rightCount\\n        root.rightCount -= getRightCount(newRoot);\\n    \\n        return newRoot;\\n    }\\n    \\n    private TreeNode rightRotate(TreeNode root) {\\n        \\n        // setp 1: take care of nodes\\n        TreeNode newRoot = root.left;\\n        TreeNode b = newRoot.right;\\n        \\n        newRoot.right = root;\\n        root.left = b;\\n        \\n        // step 2: take care of height\\n        root.height = Math.max(getHeight(root.left), getHeight(root.right)) + 1;\\n        newRoot.height = Math.max(getHeight(newRoot.left), getHeight(newRoot.right)) + 1;\\n        \\n        // step 3: take care of rightCount\\n        newRoot.rightCount += getRightCount(root);\\n        \\n        return newRoot;\\n    }\\n    \\n    \\n    private int getHeight(TreeNode node) {\\n        return node == null ? 0 : node.height;\\n    }\\n    \\n    private int getBalance(TreeNode node) {\\n        return node == null ? 0 : getHeight(node.left) - getHeight(node.right);\\n    }\\n    \\n    private int getRightCount(TreeNode node) {\\n        return node == null ? 0 : node.rightCount;\\n    }\\n    \\n    private void preOrder(TreeNode root) {\\n        \\n        if (root == null) {\\n            System.out.print(\"NIL \");\\n            return;\\n        }\\n        \\n        System.out.print(root.val + \" \");\\n        preOrder(root.left);\\n        preOrder(root.right);\\n    }\\n    \\n    class TreeNode {\\n        \\n        long val;\\n        int rightCount;\\n        int height;\\n        TreeNode left;\\n        TreeNode right;\\n        public TreeNode(long val) {\\n            this.val = val;\\n            height = 1;\\n            rightCount = 1;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\n\\n    public int reversePairs(int[] nums) {\\n        \\n        // Algo thinking: building a BST, go left when node.val <= 2 * root.val, right otherwise\\n        // But need to keep it balanced -> AVL Tree or Red-Black Tree\\n        // time = O(NlgN), space = O(N)\\n        \\n        if (nums == null || nums.length == 0) return 0;\\n        \\n        int n = nums.length;\\n        \\n        TreeNode root = new TreeNode(nums[0]);\\n        int ans = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            ans += search(root, (long) nums[i] * 2);\\n            root = insert(root, (long) nums[i]);\\n\\n            // preOrder(root);\\n            // System.out.println();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3282992,
                "title": "493-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a class Solution with a method reversePairs.\\n2. Within the reversePairs method, define a function merge_sort which takes in the starting and ending indices of a subarray and returns the count of reverse pairs within that subarray.\\n3. If the start index is greater than or equal to the end index, return 0 as there are no reverse pairs in a subarray of length 0 or 1.\\n4. Find the middle index of the subarray and recursively call merge_sort on the left and right halves of the subarray. Add the results of these recursive calls to count.\\n5. Initialize two pointers i and j to the start of the left and right halves, respectively. While both pointers are within their respective halves, compare the values at i and j. If the value at i is greater than twice the value at j, then increment count by the number of remaining elements in the left half (from i to mid). Increment j to move to the next element in the right half. Otherwise, increment i to move to the next element in the left half.\\n6. After counting the reverse pairs, merge the left and right halves of the subarray in sorted order.\\n7. Return count after all recursive calls have completed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        def merge_sort(start: int, end: int) -> int:\\n            if start >= end:\\n                return 0\\n            mid = (start + end) // 2\\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\\n\\n            # Count the number of reverse pairs between two sorted halves\\n            i = start\\n            j = mid + 1\\n            while i <= mid and j <= end:\\n                if nums[i] > 2 * nums[j]:\\n                    count += mid - i + 1\\n                    j += 1\\n                else:\\n                    i += 1\\n\\n            # Merge two sorted halves\\n            nums[start:end + 1] = sorted(nums[start:end + 1])\\n\\n            return count\\n\\n        return merge_sort(0, len(nums) - 1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        def merge_sort(start: int, end: int) -> int:\\n            if start >= end:\\n                return 0\\n            mid = (start + end) // 2\\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\\n\\n            # Count the number of reverse pairs between two sorted halves\\n            i = start\\n            j = mid + 1\\n            while i <= mid and j <= end:\\n                if nums[i] > 2 * nums[j]:\\n                    count += mid - i + 1\\n                    j += 1\\n                else:\\n                    i += 1\\n\\n            # Merge two sorted halves\\n            nums[start:end + 1] = sorted(nums[start:end + 1])\\n\\n            return count\\n\\n        return merge_sort(0, len(nums) - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832839,
                "title": "python-divide-and-conquer-faster-than-98-o-nlogn",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        def recursiveFunction(lowerIndex = 0, upperIndex = len(nums) - 1):\\n            \\n            if lowerIndex >= upperIndex:\\n                return 0\\n            \\n            midIndex = (lowerIndex + upperIndex) // 2\\n            count = recursiveFunction(lowerIndex, midIndex) + recursiveFunction(midIndex + 1, upperIndex)\\n            \\n            index_i = lowerIndex\\n            for rightNumber in nums[midIndex + 1: upperIndex + 1]:\\n                while index_i <= midIndex and nums[index_i] <= rightNumber * 2:\\n                    index_i += 1\\n                count += midIndex + 1 - index_i\\n                if index_i > midIndex:\\n                    break\\n            \\n            nums[lowerIndex: upperIndex + 1] = sorted(nums[lowerIndex: upperIndex + 1])\\n\\t\\t\\t\\n            return count\\n        \\n        return recursiveFunction()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        def recursiveFunction(lowerIndex = 0, upperIndex = len(nums) - 1):\\n            \\n            if lowerIndex >= upperIndex:\\n                return 0\\n            \\n            midIndex = (lowerIndex + upperIndex) // 2\\n            count = recursiveFunction(lowerIndex, midIndex) + recursiveFunction(midIndex + 1, upperIndex)\\n            \\n            index_i = lowerIndex\\n            for rightNumber in nums[midIndex + 1: upperIndex + 1]:\\n                while index_i <= midIndex and nums[index_i] <= rightNumber * 2:\\n                    index_i += 1\\n                count += midIndex + 1 - index_i\\n                if index_i > midIndex:\\n                    break\\n            \\n            nums[lowerIndex: upperIndex + 1] = sorted(nums[lowerIndex: upperIndex + 1])\\n\\t\\t\\t\\n            return count\\n        \\n        return recursiveFunction()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97311,
                "title": "evolve-from-brute-force-to-optimal-a-review-of-all-solutions",
                "content": "This is similar to [Count of Smaller Numbers After Self](https://discuss.leetcode.com/topic/79783/evolve-from-brute-force-to-optimal-a-review-of-all-solutions). Solutions are very similar.\\n1. O(n^2) brute force\\n```\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size(), res=0;\\n        for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(nums[i]/2.0>nums[j]) res++;\\n        return res;    \\n    }\\n```\\n2. O(n^2) Brute force with binary search. Visit the numbers from end to begin. Store the visited numbers in a sorted array. For each number, binary search the visited numbers array to figure out the number of reverse pairs between the number and the numbers after it. Note that lower_bound returns the first number if there are multiple results. This is essential for this approach to avoid counting invalid pairs. Java Collections.binarySearch does not ganrantee to return the first number on multiple hits so there is no easy Java version for this approach.\\n```\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size(), res=0;\\n        if(!n) return 0;\\n        vector<int> vstd(1,nums.back());\\n        for(int i=n-2;i>=0;i--) {\\n            res += lower_bound(vstd.begin(),vstd.end(),(double)nums[i]/2) - vstd.begin();\\n            vstd.insert(lower_bound(vstd.begin(),vstd.end(),nums[i]), nums[i]);\\n        }\\n        return res;    \\n    }\\n```\\n3. Average O(nlogn), worst O(n^2) binary search tree.\\nc++\\n```\\n    class Node {\\n        public:\\n        Node (int val):val_(val),left_(NULL),right_(NULL),lt_(0){}\\n        Node *left_,*right_;\\n        int lt_,val_;\\n    };\\n    void insert(int val, Node *rt) {\\n        Node **r = &rt; \\n        while(*r)\\n            if(val<(*r)->val_) {\\n                (*r)->lt_++;\\n                r=&(*r)->left_;\\n            } else r=&(*r)->right_;\\n        *r= new Node(val);\\n    }\\n    int countSmaller(double val, Node* r) {\\n        int ct = 0;\\n        while(r)\\n            if(val<r->val_) r = r->left_;\\n            else {\\n                ct += r->lt_+(val>r->val_);\\n                r=r->right_;\\n            }\\n        return ct;  \\n    }\\n    void dlt(Node *r) {\\n        if(!r) return;\\n        dlt(r->left_);\\n        dlt(r->right_);\\n        delete r;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        if(nums.empty()) return 0;\\n        int n=nums.size(), res=0;\\n        Node *r=new Node(nums.back());\\n        for(int i=n-2;i>=0;i--) {\\n            res+=countSmaller(nums[i]/2.0,r);\\n            insert(nums[i],r);\\n        }\\n        dlt(r);\\n        return res;\\n    }\\n```\\nJava\\n```\\nclass Node {\\n        int val, lt; \\n        Node left, right;\\n        Node(int val) {\\n            this.val=val;\\n            lt=0;\\n        }\\n    }\\n    private int search(Node p, double num) {\\n        int cnt=0;\\n        while(p!=null) {\\n            if(num<p.val) p=p.left;\\n            else {\\n                cnt+=p.lt+(num>p.val?1:0);\\n                p=p.right;\\n            }\\n        }\\n        return cnt;\\n    }\\n    private Node insert(Node root, int num) {\\n        if(root==null) {\\n            return new Node(num);\\n        }\\n        if(num<root.val) {\\n            root.lt++;\\n            root.left=insert(root.left,num);\\n        } else {\\n            root.right=insert(root.right,num);\\n        }\\n        return root;\\n    }\\n    public int reversePairs(int[] nums) {\\n        int cnt=0;\\n        Node bst=null;\\n        for(int i=nums.length-1;i>=0;i--) {\\n            cnt+=search(bst,nums[i]/2.0);\\n            bst=insert(bst,nums[i]);\\n        }          \\n        return cnt;\\n    }\\n```\\n4. O(nlogn) binary index tree.\\n```\\n    int reversePairs(vector<int>& nums) {\\n        vector<int> sorted=nums;\\n        sort(sorted.begin(),sorted.end());\\n        int n = nums.size(), res = 0;\\n        vector<int> bit(n+1);\\n        unordered_map<int,int> index;\\n        for(int i=0;i<n;i++) index[sorted[i]]=i+1;\\n        for(int i=n-1;i>=0;i--) {\\n            res+=getSum(lower_bound(sorted.begin(),sorted.end(),nums[i]/2.0)-sorted.begin(),bit);\\n            update(index[nums[i]],bit);\\n        }\\n        return res;\\n    }\\n    int getSum(int i, vector<int>& bit) {\\n        int sum = 0;\\n        while(i) {\\n            sum+=bit[i];\\n            i&=i-1;\\n        }\\n        return sum;\\n    }\\n    void update(int i, vector<int>& bit) {\\n        while(i<bit.size()) {\\n            bit[i]++;\\n            i+=i&-i;\\n        }    \\n    }\\n```\\n5. O(nlogn) merge sort. In the merge part, for each number in the left, count how many reverse pairs formed by it and number in the right. Process the first number is easy to understand. For the 2nd number in the left, we dont need to start scanning the right array from beginning becasue the 2nd number is no less than the 1st. It forms at least the same number of reverse pairs.\\nc++\\n```\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(0,nums.size()-1,nums);\\n    }\\n   int mergeSort(int l, int r, vector<int>& nums) {\\n        if(l>=r) return 0;\\n        int mid=(r-l)/2+l, count = mergeSort(l,mid,nums) + mergeSort(mid+1,r,nums);\\n        for(int i=l,j=mid+1;i<=mid;i++) {\\n            while(j<=r && nums[i]/2.0>nums[j]) j++;\\n            count+=j-mid-1;\\n        }\\n        int i=l,j=mid+1,k=0;\\n        vector<int> merge(r-l+1);\\n        while(i<=mid || j<=r)\\n            if(j>r || (i<=mid && nums[i]<=nums[j])) merge[k++]=nums[i++];\\n            else merge[k++]=nums[j++];\\n        copy(merge.begin(),merge.end(),nums.begin()+l);\\n        return count;\\n    }\\n```\\nJava\\n```\\npublic int reversePairs(int[] nums) {\\n        return mergeSort(0,nums.length-1,nums);  \\n    }\\n    private int mergeSort(int l, int r, int[] nums) {\\n        if(l>=r) return 0;\\n        int mid=(l+r)/2, count=mergeSort(l,mid,nums)+mergeSort(mid+1,r,nums);\\n        for(int i=l,j=mid+1;i<=mid;i++) {\\n            while(j<=r&&nums[i]/2.0>nums[j]) j++;\\n            count+=j-mid-1;\\n        }\\n        int[] merge=new int[r-l+1];\\n        int i=l,j=mid+1,k=0;\\n        while(i<=mid&&j<=r)\\n            if(nums[i]<nums[j]) merge[k++]=nums[i++];\\n            else merge[k++] =nums[j++];\\n        while(i<=mid) merge[k++]=nums[i++];\\n        while(j<=r) merge[k++]=nums[j++];\\n        System.arraycopy(merge,0,nums,l,merge.length);\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size(), res=0;\\n        for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(nums[i]/2.0>nums[j]) res++;\\n        return res;    \\n    }\\n```\n```\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size(), res=0;\\n        if(!n) return 0;\\n        vector<int> vstd(1,nums.back());\\n        for(int i=n-2;i>=0;i--) {\\n            res += lower_bound(vstd.begin(),vstd.end(),(double)nums[i]/2) - vstd.begin();\\n            vstd.insert(lower_bound(vstd.begin(),vstd.end(),nums[i]), nums[i]);\\n        }\\n        return res;    \\n    }\\n```\n```\\n    class Node {\\n        public:\\n        Node (int val):val_(val),left_(NULL),right_(NULL),lt_(0){}\\n        Node *left_,*right_;\\n        int lt_,val_;\\n    };\\n    void insert(int val, Node *rt) {\\n        Node **r = &rt; \\n        while(*r)\\n            if(val<(*r)->val_) {\\n                (*r)->lt_++;\\n                r=&(*r)->left_;\\n            } else r=&(*r)->right_;\\n        *r= new Node(val);\\n    }\\n    int countSmaller(double val, Node* r) {\\n        int ct = 0;\\n        while(r)\\n            if(val<r->val_) r = r->left_;\\n            else {\\n                ct += r->lt_+(val>r->val_);\\n                r=r->right_;\\n            }\\n        return ct;  \\n    }\\n    void dlt(Node *r) {\\n        if(!r) return;\\n        dlt(r->left_);\\n        dlt(r->right_);\\n        delete r;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        if(nums.empty()) return 0;\\n        int n=nums.size(), res=0;\\n        Node *r=new Node(nums.back());\\n        for(int i=n-2;i>=0;i--) {\\n            res+=countSmaller(nums[i]/2.0,r);\\n            insert(nums[i],r);\\n        }\\n        dlt(r);\\n        return res;\\n    }\\n```\n```\\nclass Node {\\n        int val, lt; \\n        Node left, right;\\n        Node(int val) {\\n            this.val=val;\\n            lt=0;\\n        }\\n    }\\n    private int search(Node p, double num) {\\n        int cnt=0;\\n        while(p!=null) {\\n            if(num<p.val) p=p.left;\\n            else {\\n                cnt+=p.lt+(num>p.val?1:0);\\n                p=p.right;\\n            }\\n        }\\n        return cnt;\\n    }\\n    private Node insert(Node root, int num) {\\n        if(root==null) {\\n            return new Node(num);\\n        }\\n        if(num<root.val) {\\n            root.lt++;\\n            root.left=insert(root.left,num);\\n        } else {\\n            root.right=insert(root.right,num);\\n        }\\n        return root;\\n    }\\n    public int reversePairs(int[] nums) {\\n        int cnt=0;\\n        Node bst=null;\\n        for(int i=nums.length-1;i>=0;i--) {\\n            cnt+=search(bst,nums[i]/2.0);\\n            bst=insert(bst,nums[i]);\\n        }          \\n        return cnt;\\n    }\\n```\n```\\n    int reversePairs(vector<int>& nums) {\\n        vector<int> sorted=nums;\\n        sort(sorted.begin(),sorted.end());\\n        int n = nums.size(), res = 0;\\n        vector<int> bit(n+1);\\n        unordered_map<int,int> index;\\n        for(int i=0;i<n;i++) index[sorted[i]]=i+1;\\n        for(int i=n-1;i>=0;i--) {\\n            res+=getSum(lower_bound(sorted.begin(),sorted.end(),nums[i]/2.0)-sorted.begin(),bit);\\n            update(index[nums[i]],bit);\\n        }\\n        return res;\\n    }\\n    int getSum(int i, vector<int>& bit) {\\n        int sum = 0;\\n        while(i) {\\n            sum+=bit[i];\\n            i&=i-1;\\n        }\\n        return sum;\\n    }\\n    void update(int i, vector<int>& bit) {\\n        while(i<bit.size()) {\\n            bit[i]++;\\n            i+=i&-i;\\n        }    \\n    }\\n```\n```\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(0,nums.size()-1,nums);\\n    }\\n   int mergeSort(int l, int r, vector<int>& nums) {\\n        if(l>=r) return 0;\\n        int mid=(r-l)/2+l, count = mergeSort(l,mid,nums) + mergeSort(mid+1,r,nums);\\n        for(int i=l,j=mid+1;i<=mid;i++) {\\n            while(j<=r && nums[i]/2.0>nums[j]) j++;\\n            count+=j-mid-1;\\n        }\\n        int i=l,j=mid+1,k=0;\\n        vector<int> merge(r-l+1);\\n        while(i<=mid || j<=r)\\n            if(j>r || (i<=mid && nums[i]<=nums[j])) merge[k++]=nums[i++];\\n            else merge[k++]=nums[j++];\\n        copy(merge.begin(),merge.end(),nums.begin()+l);\\n        return count;\\n    }\\n```\n```\\npublic int reversePairs(int[] nums) {\\n        return mergeSort(0,nums.length-1,nums);  \\n    }\\n    private int mergeSort(int l, int r, int[] nums) {\\n        if(l>=r) return 0;\\n        int mid=(l+r)/2, count=mergeSort(l,mid,nums)+mergeSort(mid+1,r,nums);\\n        for(int i=l,j=mid+1;i<=mid;i++) {\\n            while(j<=r&&nums[i]/2.0>nums[j]) j++;\\n            count+=j-mid-1;\\n        }\\n        int[] merge=new int[r-l+1];\\n        int i=l,j=mid+1,k=0;\\n        while(i<=mid&&j<=r)\\n            if(nums[i]<nums[j]) merge[k++]=nums[i++];\\n            else merge[k++] =nums[j++];\\n        while(i<=mid) merge[k++]=nums[i++];\\n        while(j<=r) merge[k++]=nums[j++];\\n        System.arraycopy(merge,0,nums,l,merge.length);\\n        return count;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970009,
                "title": "python-merge-sort-approach-with-visual-explanation",
                "content": "**Python Merge Sort Approach with Visual Explanation** \\n![image](https://assets.leetcode.com/users/images/4141c400-27b4-4bc8-9a50-c2f28c51bc80_1650555947.6025648.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/c3f2a5ad-b46b-448a-aee2-e3eb2645d3c2_1650555897.476324.jpeg)\\n```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count=0\\n        if len(nums)>1:\\n            # calculate mid\\n            mid=len(nums)//2\\n            # divide the input array in to right and left\\n            left=nums[:mid]\\n            right=nums[mid:]\\n            count+=self.reversePairs(left)\\n            count+=self.reversePairs(right)\\n            i=0\\n            j=0\\n            # the tricky part - updating the count of number of possible pairs\\n            for i in range(len(left)):\\n                while j<len(right) and left[i]>right[j]*2:\\n                    j+=1\\n                count+=j\\n            # merge two sorted array\\n            i=j=k=0        \\n            while i<len(left) and j<len(right):\\n                if left[i]>right[j]:\\n                    nums[k]=right[j]\\n                    j+=1\\n                    k+=1\\n                else:\\n                    nums[k]=left[i]\\n                    i+=1\\n                    k+=1\\n            while j<len(right):\\n                nums[k]=right[j]\\n                j,k=j+1,k+1\\n            while i<len(left):\\n                nums[k]=left[i]\\n                i,k=i+1,k+1     \\n        return count       \\n                    \\n            \\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count=0\\n        if len(nums)>1:\\n            # calculate mid\\n            mid=len(nums)//2\\n            # divide the input array in to right and left\\n            left=nums[:mid]\\n            right=nums[mid:]\\n            count+=self.reversePairs(left)\\n            count+=self.reversePairs(right)\\n            i=0\\n            j=0\\n            # the tricky part - updating the count of number of possible pairs\\n            for i in range(len(left)):\\n                while j<len(right) and left[i]>right[j]*2:\\n                    j+=1\\n                count+=j\\n            # merge two sorted array\\n            i=j=k=0        \\n            while i<len(left) and j<len(right):\\n                if left[i]>right[j]:\\n                    nums[k]=right[j]\\n                    j+=1\\n                    k+=1\\n                else:\\n                    nums[k]=left[i]\\n                    i+=1\\n                    k+=1\\n            while j<len(right):\\n                nums[k]=right[j]\\n                j,k=j+1,k+1\\n            while i<len(left):\\n                nums[k]=left[i]\\n                i,k=i+1,k+1     \\n        return count       \\n                    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 355494,
                "title": "simple-python-bisect-solution",
                "content": "Please see and vote for my solutions for these similar problems.\\n[315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/355490/Simple-Python-bisect-solution)\\n[327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/discuss/355486/Python-bisect-solution-(160-ms-beat-95.12))\\n[493. Reverse Pairs](https://leetcode.com/problems/reverse-pairs/discuss/355494/Simple-Python-bisect-solution)\\n\\n```\\n    def reversePairs(self, nums: List[int]) -> int:\\n        res = 0\\n        sorted_values = []\\n        for j in range(len(nums)):\\n            i = bisect.bisect_right(sorted_values, 2 * nums[j])\\n            res += (j - i)\\n            bisect.insort(sorted_values, nums[j])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def reversePairs(self, nums: List[int]) -> int:\\n        res = 0\\n        sorted_values = []\\n        for j in range(len(nums)):\\n            i = bisect.bisect_right(sorted_values, 2 * nums[j])\\n            res += (j - i)\\n            bisect.insort(sorted_values, nums[j])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1878623,
                "title": "easy-and-simple-code-in-java-and-c",
                "content": "**Java Code**\\n```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        return mergeSort(nums,0,nums.length-1,temp);\\n    }\\n    \\n    public int mergeSort(int[] nums, int low, int high, int[] temp) {\\n        int count = 0;\\n        if(low<high)\\n        {\\n            int mid = (low+high)/2;\\n            count += mergeSort(nums,low,mid,temp);\\n            count += mergeSort(nums,mid+1,high,temp);\\n            count += merge(nums,low,mid+1,high,temp);\\n        }\\n        return count;\\n    }\\n    \\n    public int merge(int[] nums, int low, int mid, int high, int[] temp) {\\n        int count = 0, x = mid;\\n        for(int i=low; i<mid; i++)\\n        {\\n            while((x<=high) && (nums[i]>2*(long)nums[x]))\\n                x++;\\n            \\n            count += x-mid;\\n        }\\n        \\n        int i = low, j = mid, k = low;\\n        while((i<=mid-1) && (j<=high))\\n        {\\n            if(nums[i]<=nums[j])\\n                temp[k++] = nums[i++];\\n            else\\n                temp[k++] = nums[j++];\\n        }\\n        \\n        while(i<=mid-1)\\n            temp[k++] = nums[i++];\\n        \\n        while(j<=high)\\n            temp[k++] = nums[j++];\\n        \\n        for(i = low; i<=high; i++)\\n            nums[i] = temp[i];\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        return mergeSort(nums,0,nums.length-1,temp);\\n    }\\n    \\n    public int mergeSort(int[] nums, int low, int high, int[] temp) {\\n        int count = 0;\\n        if(low<high)\\n        {\\n            int mid = (low+high)/2;\\n            count += mergeSort(nums,low,mid,temp);\\n            count += mergeSort(nums,mid+1,high,temp);\\n            count += merge(nums,low,mid+1,high,temp);\\n        }\\n        return count;\\n    }\\n    \\n    public int merge(int[] nums, int low, int mid, int high, int[] temp) {\\n        int count = 0, x = mid;\\n        for(int i=low; i<mid; i++)\\n        {\\n            while((x<=high) && (nums[i]>2*(long)nums[x]))\\n                x++;\\n            \\n            count += x-mid;\\n        }\\n        \\n        int i = low, j = mid, k = low;\\n        while((i<=mid-1) && (j<=high))\\n        {\\n            if(nums[i]<=nums[j])\\n                temp[k++] = nums[i++];\\n            else\\n                temp[k++] = nums[j++];\\n        }\\n        \\n        while(i<=mid-1)\\n            temp[k++] = nums[i++];\\n        \\n        while(j<=high)\\n            temp[k++] = nums[j++];\\n        \\n        for(i = low; i<=high; i++)\\n            nums[i] = temp[i];\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821776,
                "title": "python-simple-solution-based-on-merge-sort-time-o-n-logn",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        cnt = 0\\n\\n        def merge(left, right):\\n            nonlocal cnt\\n            i = j = 0\\n            while i < len(left) and j < len(right):\\n                if left[i] <= 2*right[j]:\\n                    i += 1\\n                else:\\n                    cnt += len(left)-i\\n                    j += 1\\n\\n            return sorted(left+right)\\n\\n\\n        def mergeSort(A):\\n            if len(A) <= 1:\\n                return A\\n            return merge(mergeSort(A[:(len(A) + 1) // 2]), mergeSort(A[(len(A) + 1) // 2:]))\\n\\n        mergeSort(nums)\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        cnt = 0\\n\\n        def merge(left, right):\\n            nonlocal cnt\\n            i = j = 0\\n            while i < len(left) and j < len(right):\\n                if left[i] <= 2*right[j]:\\n                    i += 1\\n                else:\\n                    cnt += len(left)-i\\n                    j += 1\\n\\n            return sorted(left+right)\\n\\n\\n        def mergeSort(A):\\n            if len(A) <= 1:\\n                return A\\n            return merge(mergeSort(A[:(len(A) + 1) // 2]), mergeSort(A[(len(A) + 1) // 2:]))\\n\\n        mergeSort(nums)\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704218,
                "title": "brute-optimal-java-solution",
                "content": "Method 1: Brute force\\nTime complexity: O(n^2)\\nSpace complexity: O(1)\\n```\\nclass Solution {\\n    public int reversePairs(int[] arr) {\\n        int count = 0;\\n        for (int i = 0; i < arr.length; i++)\\n            for (int j = i+1; j < arr.length; j++)\\n                if ((long)arr[i] > (long)2 * arr[j])    // 21,47,483,647, which is max value of int, was given in some test cases\\n                    count++;\\n        return count;\\n    }\\n}\\n```\\n**Method 2a:** Optimal (Using modified merge sort)\\nTime complexity: O(nlogn) + O(n) {for counting reverse pairs}\\nSpace complexity: O(n)\\n\\n**Using global variable**\\n```\\nclass Solution {\\n    int count = 0;\\n    void merge(int[] arr, int l, int mid, int r) {\\n        // First subarray is arr[l..m]\\n        // Second subarray is arr[m+1..r]\\n        int n1 = (int)(mid - l + 1);\\n        int n2 = (int)(r - mid);    // r - (mid + 1) + 1\\n        \\n        // create temp arrays\\n        int[] L = new int[n1];\\n        int[] R = new int[n2];\\n        \\n        // copy data to temp arrays\\n        for (int i = 0; i < n1; i++)\\n            L[i] = arr[l+i];\\n        for (int j = 0; j < n2; j++)\\n            R[j] = arr[mid+1+j];\\n            \\n        /* Code to count reverse pairs */\\n        int j = 0;\\n        for (int i = 0; i < n1; i++) {\\n            while (j < n2 && L[i] > (2 * (long)R[j]))\\n                j++;\\n            count += j;\\n        }\\n        \\n        // Merge temp arrays\\n        int i = 0, k = (int)l; j = 0;\\n        \\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j])\\n                arr[k++] = L[i++];\\n\\n            else\\n                arr[k++] = R[j++];\\n        }\\n        \\n        while (i < n1)\\n            arr[k++] = L[i++];\\n\\n        while (j < n2)\\n            arr[k++] = R[j++];\\n\\n    }\\n    void mergeSort(int[] arr, int l, int r) {\\n        if (l < r) {\\n            int mid = l + (r-l)/2;\\n            \\n            mergeSort(arr, l, mid);\\n            mergeSort(arr, mid+1, r);\\n            \\n            merge(arr, l, mid, r);\\n        }\\n    }\\n    public int reversePairs(int[] arr) {\\n        mergeSort(arr, 0, arr.length-1);\\n        return count;\\n    }\\n}\\n```\\n**Method 2b:** Optimal (Using modified merge sort)\\nTime complexity: O(nlogn) + O(n) {for counting reverse pairs}\\nSpace complexity: O(n)\\n\\n**Without using global variable**\\n```\\nclass Solution {\\n    int merge(int[] arr, int l, int mid, int r) {\\n        int count = 0;\\n        // First subarray is arr[l..m]\\n        // Second subarray is arr[m+1..r]\\n        int n1 = mid - l + 1;\\n        int n2 = r - mid;    // r - (mid + 1) + 1\\n        \\n        // create temp arrays\\n        int[] L = new int[n1];\\n        int[] R = new int[n2];\\n        \\n        // copy data to temp arrays\\n        for (int i = 0; i < n1; i++)\\n            L[i] = arr[l+i];\\n        for (int j = 0; j < n2; j++)\\n            R[j] = arr[mid+1+j];\\n            \\n        /* Code to count reverse pairs */\\n        int j = 0;\\n        for (int i = 0; i < n1; i++) {\\n            while (j < n2 && L[i] > (2 * (long)R[j]))\\n                j++;\\n            count += j;\\n        }\\n        \\n        // Merge temp arrays\\n        int i = 0, k = (int)l; j = 0;\\n        \\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j])\\n                arr[k++] = L[i++];\\n\\n            else\\n                arr[k++] = R[j++];\\n        }\\n        \\n        while (i < n1)\\n            arr[k++] = L[i++];\\n\\n        while (j < n2)\\n            arr[k++] = R[j++];\\n        \\n        return count;\\n    }\\n    int mergeSort(int[] arr, int l, int r) {\\n        if (l >= r) return 0;\\n        \\n        int mid = l + (r-l)/2;\\n\\n        int count = mergeSort(arr, l, mid);\\n        count += mergeSort(arr, mid+1, r);\\n\\n        count += merge(arr, l, mid, r);\\n        \\n        return count;\\n    }\\n    public int reversePairs(int[] arr) {\\n        return mergeSort(arr, 0, arr.length-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] arr) {\\n        int count = 0;\\n        for (int i = 0; i < arr.length; i++)\\n            for (int j = i+1; j < arr.length; j++)\\n                if ((long)arr[i] > (long)2 * arr[j])    // 21,47,483,647, which is max value of int, was given in some test cases\\n                    count++;\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int count = 0;\\n    void merge(int[] arr, int l, int mid, int r) {\\n        // First subarray is arr[l..m]\\n        // Second subarray is arr[m+1..r]\\n        int n1 = (int)(mid - l + 1);\\n        int n2 = (int)(r - mid);    // r - (mid + 1) + 1\\n        \\n        // create temp arrays\\n        int[] L = new int[n1];\\n        int[] R = new int[n2];\\n        \\n        // copy data to temp arrays\\n        for (int i = 0; i < n1; i++)\\n            L[i] = arr[l+i];\\n        for (int j = 0; j < n2; j++)\\n            R[j] = arr[mid+1+j];\\n            \\n        /* Code to count reverse pairs */\\n        int j = 0;\\n        for (int i = 0; i < n1; i++) {\\n            while (j < n2 && L[i] > (2 * (long)R[j]))\\n                j++;\\n            count += j;\\n        }\\n        \\n        // Merge temp arrays\\n        int i = 0, k = (int)l; j = 0;\\n        \\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j])\\n                arr[k++] = L[i++];\\n\\n            else\\n                arr[k++] = R[j++];\\n        }\\n        \\n        while (i < n1)\\n            arr[k++] = L[i++];\\n\\n        while (j < n2)\\n            arr[k++] = R[j++];\\n\\n    }\\n    void mergeSort(int[] arr, int l, int r) {\\n        if (l < r) {\\n            int mid = l + (r-l)/2;\\n            \\n            mergeSort(arr, l, mid);\\n            mergeSort(arr, mid+1, r);\\n            \\n            merge(arr, l, mid, r);\\n        }\\n    }\\n    public int reversePairs(int[] arr) {\\n        mergeSort(arr, 0, arr.length-1);\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int merge(int[] arr, int l, int mid, int r) {\\n        int count = 0;\\n        // First subarray is arr[l..m]\\n        // Second subarray is arr[m+1..r]\\n        int n1 = mid - l + 1;\\n        int n2 = r - mid;    // r - (mid + 1) + 1\\n        \\n        // create temp arrays\\n        int[] L = new int[n1];\\n        int[] R = new int[n2];\\n        \\n        // copy data to temp arrays\\n        for (int i = 0; i < n1; i++)\\n            L[i] = arr[l+i];\\n        for (int j = 0; j < n2; j++)\\n            R[j] = arr[mid+1+j];\\n            \\n        /* Code to count reverse pairs */\\n        int j = 0;\\n        for (int i = 0; i < n1; i++) {\\n            while (j < n2 && L[i] > (2 * (long)R[j]))\\n                j++;\\n            count += j;\\n        }\\n        \\n        // Merge temp arrays\\n        int i = 0, k = (int)l; j = 0;\\n        \\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j])\\n                arr[k++] = L[i++];\\n\\n            else\\n                arr[k++] = R[j++];\\n        }\\n        \\n        while (i < n1)\\n            arr[k++] = L[i++];\\n\\n        while (j < n2)\\n            arr[k++] = R[j++];\\n        \\n        return count;\\n    }\\n    int mergeSort(int[] arr, int l, int r) {\\n        if (l >= r) return 0;\\n        \\n        int mid = l + (r-l)/2;\\n\\n        int count = mergeSort(arr, l, mid);\\n        count += mergeSort(arr, mid+1, r);\\n\\n        count += merge(arr, l, mid, r);\\n        \\n        return count;\\n    }\\n    public int reversePairs(int[] arr) {\\n        return mergeSort(arr, 0, arr.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647228,
                "title": "python3-o-nlogn-template-for-these-questions",
                "content": "If you need to find a `C[i] > C[j] * 2, i < j`\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        l = SortedList(key=lambda x: -x) # descending\\n        ans = 0\\n        for n in nums:\\n            ans += l.bisect_left(2*n) # your constraint\\n            l.add(n)\\n        return ans\\n```\\n\\nFor the same kind of questions such as \\n`2426. Number of Pairs Satisfying Inequality`\\nThe equation is `C[i] <= C[j] + diff` then the solution will be\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        l = SortedList() # accending\\n        ans = 0\\n        for n in nums:\\n            ans += l.bisect_left(n + diff) # your constraint\\n            l.add(n)\\n        return ans\\n```\\n\\n`315. Count of Smaller Numbers After Self`\\nThe equation is `C[i] > C[j]` and you need the count then the solution will be\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countSmaller(self, nums: List[int]) -> List[int]:\\n        l = SortedList()\\n        ans = []\\n        for n in nums[::-1]:\\n            ans.append(l.bisect_left(n))\\n            l.add(n)\\n        return ans[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        l = SortedList(key=lambda x: -x) # descending\\n        ans = 0\\n        for n in nums:\\n            ans += l.bisect_left(2*n) # your constraint\\n            l.add(n)\\n        return ans\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        l = SortedList() # accending\\n        ans = 0\\n        for n in nums:\\n            ans += l.bisect_left(n + diff) # your constraint\\n            l.add(n)\\n        return ans\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countSmaller(self, nums: List[int]) -> List[int]:\\n        l = SortedList()\\n        ans = []\\n        for n in nums[::-1]:\\n            ans.append(l.bisect_left(n))\\n            l.add(n)\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205560,
                "title": "python3-summarizing-4-solutions",
                "content": "\\n**Approach 1** - insort (`O(N^2)` but passes all tests)\\n```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        seen = []\\n        for x in nums: \\n            k = bisect_right(seen, 2*x)\\n            ans += len(seen) - k\\n            insort(seen, x)\\n        return ans \\n```\\n\\n**Approach 2** - Fenwick tree\\n```\\nclass Fenwick:\\n    def __init__(self, n):\\n        self.data = [0]*(n+1)\\n    \\n    def add(self, k, x):\\n        k += 1\\n        while k < len(self.data): \\n            self.data[k] += x\\n            k += k & -k \\n        \\n    def sum(self, k): \\n        k += 1\\n        ans = 0\\n        while k: \\n            ans += self.data[k]\\n            k -= k & -k \\n        return ans \\n            \\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        vals = sorted(set(nums))\\n        fen = Fenwick(len(vals))\\n        mp = {x: i for i, x in enumerate(vals)}\\n        for i, x in enumerate(nums): \\n            k = bisect_right(vals, 2*x)-1\\n            ans += i\\n            if k >= 0: ans -= fen.sum(mp[vals[k]])\\n            fen.add(mp[x], 1)\\n        return ans \\n```\\n\\n**Approach 3** - divide & conquer \\n```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\n        def fn(nums, aux, lo, hi): \\n            \"\"\"Return number of reverse pairs in nums[lo:hi].\"\"\"\\n            if lo + 1 == hi: return 0 \\n            mid = lo + hi >> 1\\n            left = fn(aux, nums, lo, mid)\\n            right = fn(aux, nums, mid, hi)\\n            split = 0 \\n            i, j = lo, mid\\n            for _ in range(lo, hi): \\n                if i == mid or j < hi and aux[i] > 2*aux[j]: \\n                    split += mid - i \\n                    j += 1\\n                else: i += 1\\n            i, j = lo, mid\\n            for k in range(lo, hi): \\n                if j == hi or i < mid and aux[i] < aux[j]: \\n                    nums[k] = aux[i]\\n                    i += 1\\n                else: \\n                    nums[k] = aux[j]\\n                    j += 1\\n            return left + split + right \\n                \\n        return fn(nums, nums.copy(), 0, len(nums))\\n```\\n\\n**Approach 4** - segment tree \\n```\\nclass SegTree: \\n    def __init__(self, arr: List[int]): \\n        self.n = len(arr)\\n        self.data = [0]*(4*self.n)\\n        self._build(arr, 0, 0, self.n)\\n\\n    def _build(self, arr: List[int], k: int, lo: int, hi: int) -> None: \\n        if lo+1 == hi: \\n            self.data[k] = arr[lo]\\n            return \\n        mid = lo + hi >> 1\\n        self._build(arr, 2*k+1, lo, mid)\\n        self._build(arr, 2*k+2, mid, hi)\\n        self.data[k] = self.data[2*k+1] + self.data[2*k+2]\\n\\n    def update(self, idx: int, val: int, k: int = 0, lo: int = 0, hi: int = 0) -> None:\\n        if not hi: hi = self.n\\n        if lo+1 == hi: \\n            self.data[k] += val \\n            return \\n        mid = lo + hi >> 1\\n        if idx < mid: self.update(idx, val, 2*k+1, lo, mid) \\n        else: self.update(idx, val, 2*k+2, mid, hi)\\n        self.data[k] = self.data[2*k+1] + self.data[2*k+2]\\n\\n    def query(self, qlo: int, qhi: int, k: int = 0, lo: int = 0, hi: int = 0) -> int: \\n        if not hi: hi = self.n\\n        if qlo <= lo and hi <= qhi: return self.data[k] # total overlap \\n        if qhi <= lo or  hi <= qlo: return 0 # no overlap \\n        mid = lo + hi >> 1 # partial overlap \\n        return self.query(qlo, qhi, 2*k+1, lo, mid) + self.query(qlo, qhi, 2*k+2, mid, hi)\\n\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        vals = sorted(set(nums))\\n        mp = {x: i for i, x in enumerate(vals)}\\n        ans = 0 \\n        tree = SegTree([0]*len(vals))\\n        \\n        for i, x in enumerate(nums): \\n            k = bisect_right(vals, 2*x)-1\\n            ans += i\\n            if k >= 0: ans -= tree.query(0, k+1)\\n            tree.update(mp[x], 1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        seen = []\\n        for x in nums: \\n            k = bisect_right(seen, 2*x)\\n            ans += len(seen) - k\\n            insort(seen, x)\\n        return ans \\n```\n```\\nclass Fenwick:\\n    def __init__(self, n):\\n        self.data = [0]*(n+1)\\n    \\n    def add(self, k, x):\\n        k += 1\\n        while k < len(self.data): \\n            self.data[k] += x\\n            k += k & -k \\n        \\n    def sum(self, k): \\n        k += 1\\n        ans = 0\\n        while k: \\n            ans += self.data[k]\\n            k -= k & -k \\n        return ans \\n            \\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ans = 0\\n        vals = sorted(set(nums))\\n        fen = Fenwick(len(vals))\\n        mp = {x: i for i, x in enumerate(vals)}\\n        for i, x in enumerate(nums): \\n            k = bisect_right(vals, 2*x)-1\\n            ans += i\\n            if k >= 0: ans -= fen.sum(mp[vals[k]])\\n            fen.add(mp[x], 1)\\n        return ans \\n```\n```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\n        def fn(nums, aux, lo, hi): \\n            \"\"\"Return number of reverse pairs in nums[lo:hi].\"\"\"\\n            if lo + 1 == hi: return 0 \\n            mid = lo + hi >> 1\\n            left = fn(aux, nums, lo, mid)\\n            right = fn(aux, nums, mid, hi)\\n            split = 0 \\n            i, j = lo, mid\\n            for _ in range(lo, hi): \\n                if i == mid or j < hi and aux[i] > 2*aux[j]: \\n                    split += mid - i \\n                    j += 1\\n                else: i += 1\\n            i, j = lo, mid\\n            for k in range(lo, hi): \\n                if j == hi or i < mid and aux[i] < aux[j]: \\n                    nums[k] = aux[i]\\n                    i += 1\\n                else: \\n                    nums[k] = aux[j]\\n                    j += 1\\n            return left + split + right \\n                \\n        return fn(nums, nums.copy(), 0, len(nums))\\n```\n```\\nclass SegTree: \\n    def __init__(self, arr: List[int]): \\n        self.n = len(arr)\\n        self.data = [0]*(4*self.n)\\n        self._build(arr, 0, 0, self.n)\\n\\n    def _build(self, arr: List[int], k: int, lo: int, hi: int) -> None: \\n        if lo+1 == hi: \\n            self.data[k] = arr[lo]\\n            return \\n        mid = lo + hi >> 1\\n        self._build(arr, 2*k+1, lo, mid)\\n        self._build(arr, 2*k+2, mid, hi)\\n        self.data[k] = self.data[2*k+1] + self.data[2*k+2]\\n\\n    def update(self, idx: int, val: int, k: int = 0, lo: int = 0, hi: int = 0) -> None:\\n        if not hi: hi = self.n\\n        if lo+1 == hi: \\n            self.data[k] += val \\n            return \\n        mid = lo + hi >> 1\\n        if idx < mid: self.update(idx, val, 2*k+1, lo, mid) \\n        else: self.update(idx, val, 2*k+2, mid, hi)\\n        self.data[k] = self.data[2*k+1] + self.data[2*k+2]\\n\\n    def query(self, qlo: int, qhi: int, k: int = 0, lo: int = 0, hi: int = 0) -> int: \\n        if not hi: hi = self.n\\n        if qlo <= lo and hi <= qhi: return self.data[k] # total overlap \\n        if qhi <= lo or  hi <= qlo: return 0 # no overlap \\n        mid = lo + hi >> 1 # partial overlap \\n        return self.query(qlo, qhi, 2*k+1, lo, mid) + self.query(qlo, qhi, 2*k+2, mid, hi)\\n\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        vals = sorted(set(nums))\\n        mp = {x: i for i, x in enumerate(vals)}\\n        ans = 0 \\n        tree = SegTree([0]*len(vals))\\n        \\n        for i, x in enumerate(nums): \\n            k = bisect_right(vals, 2*x)-1\\n            ans += i\\n            if k >= 0: ans -= tree.query(0, k+1)\\n            tree.update(mp[x], 1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178187,
                "title": "java-clean-merge-sort-o-n-logn-solution-with-detailed-explanation",
                "content": "This solution has similar structure to classic Merge-Sort Algorithm, which itself is very smart. It is very important and neccessary to understand what the algorithm is doing before trying this problem. I put my analogous Merge-Sort Algorithm here for comparison. \\n\\nAlso feel free to try and compare these similar question. You then will realize how the format of this solution works kind of universally. \\n* [327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation)\\n* [493. Reverse Pairs](https://leetcode.com/problems/reverse-pairs/discuss/1178187/Java-clean-Merge-Sort-O(N-logN)-Solution-oror-with-Detailed-Explanation)\\n* [315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/1177108/Java-clean-Merge-Sort-O(N-logN)-Solution-oror-with-comments)\\n* [1885. Count Pairs in Two Arrays](https://leetcode.com/problems/count-pairs-in-two-arrays/discuss/1253601/Java-clean-Merge-Sort-O(N-logN)-Solution-oror-with-comments)\\n\\nThe Merge-Sort Algorithm has two steps: recursive mergeSort step and merge step. The code below also provides a solution for [912. Sort an Array](https://leetcode.com/problems/sort-an-array/):\\n\\n```\\nclass Solution {\\n    private int[] nums;\\n    public int[] sortArray(int[] nums) {\\n        this.nums = nums;\\n        mergeSort(0, nums.length - 1);\\n        return(nums);     \\n    }\\n    \\n    private void mergeSort(int low, int high) {\\n        if (low >= high) return;\\n        int mid = low + (high - low) / 2;\\n        \\n        mergeSort(low, mid);\\n        mergeSort(mid + 1, high);\\n        merge(low, mid, high);\\n    }\\n    \\n    private void merge(int low, int mid, int high) {\\n        int[] helper = new int[high - low + 1];\\n        for (int i = low; i <= high; i++) helper[i - low] = nums[i];\\n        \\n        int i = low, j = mid + 1;\\n        int idx = low;\\n        \\n        while (i <= mid && j <= high) {\\n            if (helper[i - low] < helper[j - low]) {\\n                nums[idx++] = helper[i++ - low];\\n            } else {\\n                nums[idx++] = helper[j++ - low];\\n            }\\n        }\\n        \\n        while (i <= mid) {\\n            nums[idx++] = helper[i++ - low];\\n        }\\n    }\\n    \\n}\\n```\\n\\nIn this question, the sort step is identical to that of Merge-Sort. The only variant happens in the mergeSort recursive step. During the mergeSort step, we count the pairs with:\\n\\n1. starting points in [low, mid]\\n2. ending points in [mid+1, high]\\n\\nAfter the recursive steps, nums[low, mid] & nums[mid+1, high] are sorted. And we already count the range with starting point & ending points both in [low, mid] or both in [mid+1, high] in recursive steps.\\n\\nThus we only need to count the pairs (i, j) with i in [low, mid] & j in [mid+1, high]. \\n\\nFor each i, we find the last j with nums[i] <= 2 * nums[j]. Then for every ending point e within [mid+1, j], (i, e) forms a pair with nums[i] > 2 * nums[e]. Thus we may add (j - (mid + 1) + 1) to final result. \\n\\nIn the code below, for each i, we find the first j with nums[i] <= 2 * nums[j]; Then every number in [mid+1, j-1] correspond to a proper ending point. Thus we add (j-1 - (mid + 1) + 1) = j - mid - 1 to final result;\\n\\n```\\n// Solution for 493. Reverse Pairs\\nclass Solution {\\n    private int count = 0;\\n    private int[] nums;\\n    \\n    public int reversePairs(int[] nums) {\\n\\t\\tthis.nums = nums;\\n        mergeSort(0, nums.length - 1);\\n        \\n        return count;\\n    }\\n\\t\\n\\tprivate void mergeSort(int low, int high){\\n\\t\\tif (low >= high) return;\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\n        mergeSort(low, mid);\\n        mergeSort(mid+1, high);\\n        \\n        int j = mid + 1;\\n        for (int i = low; i <= mid; i++) {\\n            while (j <= high && nums[i] > (long) nums[j] * 2) j++;\\n            count += (j - mid - 1);\\n        }\\n        \\n        merge(low, mid, high);\\n\\t}\\n\\t\\n\\tprivate void merge(int low, int mid, int high) {\\n\\t\\tint[] helper = new int[high - low + 1];\\n        for (int i = low; i <= high; i++) {\\n            helper[i - low] = nums[i];\\n        }\\n\\t\\t\\n\\t\\tint i = low, j = mid + 1;\\n        int idx = low;\\n\\t\\t\\n        while (i <= mid && j <= high) {\\n            if (helper[i - low] < helper[j - low]) {\\n                nums[idx++] = helper[i++ - low];\\n            } else {\\n                nums[idx++] = helper[j++ - low];\\n            }\\n        }\\n        \\n        while (i <= mid) {\\n            nums[idx++] = helper[i++ - low];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] nums;\\n    public int[] sortArray(int[] nums) {\\n        this.nums = nums;\\n        mergeSort(0, nums.length - 1);\\n        return(nums);     \\n    }\\n    \\n    private void mergeSort(int low, int high) {\\n        if (low >= high) return;\\n        int mid = low + (high - low) / 2;\\n        \\n        mergeSort(low, mid);\\n        mergeSort(mid + 1, high);\\n        merge(low, mid, high);\\n    }\\n    \\n    private void merge(int low, int mid, int high) {\\n        int[] helper = new int[high - low + 1];\\n        for (int i = low; i <= high; i++) helper[i - low] = nums[i];\\n        \\n        int i = low, j = mid + 1;\\n        int idx = low;\\n        \\n        while (i <= mid && j <= high) {\\n            if (helper[i - low] < helper[j - low]) {\\n                nums[idx++] = helper[i++ - low];\\n            } else {\\n                nums[idx++] = helper[j++ - low];\\n            }\\n        }\\n        \\n        while (i <= mid) {\\n            nums[idx++] = helper[i++ - low];\\n        }\\n    }\\n    \\n}\\n```\n```\\n// Solution for 493. Reverse Pairs\\nclass Solution {\\n    private int count = 0;\\n    private int[] nums;\\n    \\n    public int reversePairs(int[] nums) {\\n\\t\\tthis.nums = nums;\\n        mergeSort(0, nums.length - 1);\\n        \\n        return count;\\n    }\\n\\t\\n\\tprivate void mergeSort(int low, int high){\\n\\t\\tif (low >= high) return;\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\n        mergeSort(low, mid);\\n        mergeSort(mid+1, high);\\n        \\n        int j = mid + 1;\\n        for (int i = low; i <= mid; i++) {\\n            while (j <= high && nums[i] > (long) nums[j] * 2) j++;\\n            count += (j - mid - 1);\\n        }\\n        \\n        merge(low, mid, high);\\n\\t}\\n\\t\\n\\tprivate void merge(int low, int mid, int high) {\\n\\t\\tint[] helper = new int[high - low + 1];\\n        for (int i = low; i <= high; i++) {\\n            helper[i - low] = nums[i];\\n        }\\n\\t\\t\\n\\t\\tint i = low, j = mid + 1;\\n        int idx = low;\\n\\t\\t\\n        while (i <= mid && j <= high) {\\n            if (helper[i - low] < helper[j - low]) {\\n                nums[idx++] = helper[i++ - low];\\n            } else {\\n                nums[idx++] = helper[j++ - low];\\n            }\\n        }\\n        \\n        while (i <= mid) {\\n            nums[idx++] = helper[i++ - low];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843769,
                "title": "java-bit-9",
                "content": "```\\nclass Solution {\\n        public int reversePairs(int[] nums) {\\n            int n = nums.length;\\n            int[] nums_copy = Arrays.copyOf(nums, nums.length);\\n            Arrays.sort(nums_copy);\\n            int[] BITS = new int[nums.length + 1];\\n            int count = 0;\\n            for (int i = 0; i < n; i++) {\\n                count += query(BITS, getIndex(nums_copy, 2 * (long)nums[i] + 1) + 1);\\n                update(BITS, getIndex(nums_copy,nums[i])+1,1);\\n            }\\n            return count;\\n        }\\n\\n        private void update(int[] BIT, int index, int val) {\\n            while (index > 0) {\\n                BIT[index] += val;\\n                index -= index & (-index);\\n            }\\n        }\\n\\n        private int query(int[] BIT, int index) {\\n            int sum = 0;\\n            while (index < BIT.length) {\\n                sum += BIT[index];\\n                index += index & (-index);\\n            }\\n            return sum;\\n        }\\n\\n        private int getIndex(int[] nums_copy, long l) {\\n            int left = 0;\\n            int right = nums_copy.length - 1;\\n            while (left < right) {\\n                int mid = left + (right - left) / 2;\\n                if (nums_copy[mid] < l) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n            if(right == nums_copy.length-1 && l>nums_copy[right]) return right+1;\\n            return right;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n        public int reversePairs(int[] nums) {\\n            int n = nums.length;\\n            int[] nums_copy = Arrays.copyOf(nums, nums.length);\\n            Arrays.sort(nums_copy);\\n            int[] BITS = new int[nums.length + 1];\\n            int count = 0;\\n            for (int i = 0; i < n; i++) {\\n                count += query(BITS, getIndex(nums_copy, 2 * (long)nums[i] + 1) + 1);\\n                update(BITS, getIndex(nums_copy,nums[i])+1,1);\\n            }\\n            return count;\\n        }\\n\\n        private void update(int[] BIT, int index, int val) {\\n            while (index > 0) {\\n                BIT[index] += val;\\n                index -= index & (-index);\\n            }\\n        }\\n\\n        private int query(int[] BIT, int index) {\\n            int sum = 0;\\n            while (index < BIT.length) {\\n                sum += BIT[index];\\n                index += index & (-index);\\n            }\\n            return sum;\\n        }\\n\\n        private int getIndex(int[] nums_copy, long l) {\\n            int left = 0;\\n            int right = nums_copy.length - 1;\\n            while (left < right) {\\n                int mid = left + (right - left) / 2;\\n                if (nums_copy[mid] < l) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n            if(right == nums_copy.length-1 && l>nums_copy[right]) return right+1;\\n            return right;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571969,
                "title": "super-clean-and-concise-python-3-binary-indexed-tree-reverse-pairs",
                "content": "Conceptually this is the same as https://leetcode.com/problems/count-of-smaller-numbers-after-self (my solution https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/567251/super-clean-and-concise-python-3-binary-indexed-tree), with the following differences:\\n\\n1. The Fenwick Tree has double the size of the original array.\\n2. Add the original number\\'s double to the Fenwick Tree, sum at the original number.\\n```\\nclass FenwickTree:\\n    def __init__(self, n: int) -> None:\\n        self.BIT = [0] * (n+1)\\n        \\n    def sum(self, x: int) -> int:\\n        rv = 0\\n        while x > 0:\\n            rv += self.BIT[x]\\n            x -= x&-x\\n        return rv\\n    \\n    def add(self, x: int, delta: int) -> None:\\n        while x < len(self.BIT):\\n            self.BIT[x] += delta\\n            x += x&-x\\n            \\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        doubleNums = [n * 2 for n in nums]\\n        m = {n: i+1 for i, n in enumerate(sorted(set(nums + doubleNums)))}\\n        numsRanks = [m[n] for n in nums]\\n        doubleNumsRanks = [m[n] for n in doubleNums]\\n        ft = FenwickTree(len(nums * 2))\\n        rv = 0\\n        for i in range(len(nums)-1, -1, -1):\\n            rv += ft.sum(numsRanks[i]-1)\\n            ft.add(doubleNumsRanks[i], 1)\\n        return rv\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass FenwickTree:\\n    def __init__(self, n: int) -> None:\\n        self.BIT = [0] * (n+1)\\n        \\n    def sum(self, x: int) -> int:\\n        rv = 0\\n        while x > 0:\\n            rv += self.BIT[x]\\n            x -= x&-x\\n        return rv\\n    \\n    def add(self, x: int, delta: int) -> None:\\n        while x < len(self.BIT):\\n            self.BIT[x] += delta\\n            x += x&-x\\n            \\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        doubleNums = [n * 2 for n in nums]\\n        m = {n: i+1 for i, n in enumerate(sorted(set(nums + doubleNums)))}\\n        numsRanks = [m[n] for n in nums]\\n        doubleNumsRanks = [m[n] for n in doubleNums]\\n        ft = FenwickTree(len(nums * 2))\\n        rv = 0\\n        for i in range(len(nums)-1, -1, -1):\\n            rv += ft.sum(numsRanks[i]-1)\\n            ft.add(doubleNumsRanks[i], 1)\\n        return rv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97310,
                "title": "java-segment-tree-solution",
                "content": "Inspired by binary index tree solution, I just wrote a segment tree version. \\n\\n```java\\npublic class Solution {\\n\\tint n;\\n\\tint[] nums;\\n\\tint[] numsSorted;\\n\\tint[] segmentTree;\\n\\tpublic int reversePairs(int[] nums) {\\n\\t\\tn = nums.length;\\n\\t\\tnums = nums;\\n\\t\\tnumsSorted = Arrays.copyOf(nums, n);\\n\\t\\tArrays.sort(numsSorted);\\n\\t\\tsegmentTree = new int[n * 2];\\n\\n\\t\\tint res = 0;\\n\\t\\tfor (int val : nums) {\\n\\t\\t\\tres += search(findIndex(2L * val + 1));\\n\\t\\t\\tupdate(findIndex(val));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate int findIndex(long val) {\\n\\t\\tint l = 0, r = n - 1;\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = l + (r - l) / 2;\\n\\t\\t\\tif (numsSorted[mid] >= val) {\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn l;\\n\\t}\\n\\n\\tprivate int search(int pos) {\\n\\t\\tint l = pos + n;\\n\\t\\tint r = n * 2 - 1;\\n\\t\\tint sum = 0;\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tif (l % 2 == 1) {\\n\\t\\t\\t\\tsum += segmentTree[l];\\n\\t\\t\\t\\tl++;\\n\\t\\t\\t}\\n\\t\\t\\tif (r % 2 == 0) {\\n\\t\\t\\t\\tsum += segmentTree[r];\\n\\t\\t\\t\\tr--;\\n\\t\\t\\t}\\n\\t\\t\\tl /= 2;\\n\\t\\t\\tr /= 2;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tprivate void update(int pos) {\\n\\t\\tpos += n;\\n\\t\\tsegmentTree[pos] += 1;\\n\\t\\twhile (pos > 0) {\\n\\t\\t\\tint l = pos;\\n\\t\\t\\tint r = pos;\\n\\t\\t\\tif (pos % 2 == 0) {\\n\\t\\t\\t\\tr = pos + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tl = pos - 1;\\n\\t\\t\\t}\\n\\t\\t\\tsegmentTree[pos / 2] = segmentTree[l] + segmentTree[r];\\n\\t\\t\\tpos /= 2;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n\\tint n;\\n\\tint[] nums;\\n\\tint[] numsSorted;\\n\\tint[] segmentTree;\\n\\tpublic int reversePairs(int[] nums) {\\n\\t\\tn = nums.length;\\n\\t\\tnums = nums;\\n\\t\\tnumsSorted = Arrays.copyOf(nums, n);\\n\\t\\tArrays.sort(numsSorted);\\n\\t\\tsegmentTree = new int[n * 2];\\n\\n\\t\\tint res = 0;\\n\\t\\tfor (int val : nums) {\\n\\t\\t\\tres += search(findIndex(2L * val + 1));\\n\\t\\t\\tupdate(findIndex(val));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate int findIndex(long val) {\\n\\t\\tint l = 0, r = n - 1;\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tint mid = l + (r - l) / 2;\\n\\t\\t\\tif (numsSorted[mid] >= val) {\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn l;\\n\\t}\\n\\n\\tprivate int search(int pos) {\\n\\t\\tint l = pos + n;\\n\\t\\tint r = n * 2 - 1;\\n\\t\\tint sum = 0;\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tif (l % 2 == 1) {\\n\\t\\t\\t\\tsum += segmentTree[l];\\n\\t\\t\\t\\tl++;\\n\\t\\t\\t}\\n\\t\\t\\tif (r % 2 == 0) {\\n\\t\\t\\t\\tsum += segmentTree[r];\\n\\t\\t\\t\\tr--;\\n\\t\\t\\t}\\n\\t\\t\\tl /= 2;\\n\\t\\t\\tr /= 2;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tprivate void update(int pos) {\\n\\t\\tpos += n;\\n\\t\\tsegmentTree[pos] += 1;\\n\\t\\twhile (pos > 0) {\\n\\t\\t\\tint l = pos;\\n\\t\\t\\tint r = pos;\\n\\t\\t\\tif (pos % 2 == 0) {\\n\\t\\t\\t\\tr = pos + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tl = pos - 1;\\n\\t\\t\\t}\\n\\t\\t\\tsegmentTree[pos / 2] = segmentTree[l] + segmentTree[r];\\n\\t\\t\\tpos /= 2;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394290,
                "title": "binary-search-merge-sort-in-o-n-logn-2",
                "content": "# Intuition\\nHaving Solved Count Inversions Problem where we find the Pairs i<j and a[i]>a[j] we used Merge Sort to count them by the Logic that the element in first half in merging having greater value than any element in second half is going to add inversion pairs accordingly.\\nHaving Said That We need to Find The Pairs with exact same Logic BUT This Time The Condition Switches to a[i]>(2*a[j]).\\nThus We Need to Find The Very Last Index in Second Half where The Condition satisfies for any element in first half. \\n\\n# Approach\\nWe Do Divide The Array into Subparts and Conquer Them Using Merge Sort and The Very Fact that Element in First Half has to be greater than twice of the element in second array.\\nSo taking advantage that first and second halves are sorted, we apply Binary Search Instead of Linear To Optimize and avoid TLE.\\nWhile Merging itself we find the index for that required condition and apply math accordingly as to how many pairs will be added in the count.\\nI Suggest to Solve The Count Inversions Problem and then come back and apply the given algorithm on the given sample input, You will surely Understand once you use pen and paper.\\n :)\\n\\n# Complexity\\n- Time complexity:O(N*(logN)^2)\\n\\n- Space complexity:O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int inversions=0;\\n    int find_index_where_just_greater(int left,int right,vector<int>&arr,int target)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            long long x=arr[mid];\\n            x*=2;\\n            if(x>=target)\\n            {\\n                right=mid-1;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return (left-1);\\n    }\\n    void merge(vector<int>&arr,int l,int m,int r)\\n    {\\n        vector<int>Arr(r-l+1);\\n        int ptr1=l,ptr2=m+1,ptr3=0;\\n        while(ptr3<=(r-l))\\n        {\\n            if(ptr1==(m+1))\\n            {\\n                Arr[ptr3]=arr[ptr2];\\n                ptr2++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(ptr2==(r+1))\\n            {\\n                int idx=find_index_where_just_greater(m+1,r,arr,arr[ptr1]);\\n                inversions+=idx-m;\\n                Arr[ptr3]=arr[ptr1];\\n                ptr1++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(arr[ptr1]<=arr[ptr2])\\n            {\\n                int idx=find_index_where_just_greater(m+1,r,arr,arr[ptr1]);\\n                inversions+=idx-m;\\n                Arr[ptr3]=arr[ptr1];\\n                ptr1++;\\n                ptr3++;\\n            }\\n            else\\n            {\\n                Arr[ptr3]=arr[ptr2];\\n                ptr2++;\\n                ptr3++;\\n            }\\n        }\\n        for(int i=l;i<=r;i++)\\n        {\\n            arr[i]=Arr[i-l];\\n        }\\n        return;\\n    }\\n    void mergeSort(vector<int>&arr,int l,int r)\\n    {\\n        if(l==r)\\n        {\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        mergeSort(arr,l,mid);\\n        mergeSort(arr,mid+1,r);\\n        merge(arr,l,mid,r);\\n        return;\\n    }\\n    int reversePairs(vector<int>&nums) \\n    {\\n        mergeSort(nums,0,nums.size()-1);\\n        return inversions;\\n    }\\n};\\n```\\nAlso Another Solution I Found :-\\n# Using Two Pointer:\\n```\\nclass Solution {\\npublic:\\n    int inversions=0;\\n    void merge(vector<int>&arr,int l,int m,int r)\\n    {\\n        vector<int>Arr(r-l+1);\\n        int ptr1=l,ptr2=m+1,ptr3=0,idx=m+1;\\n        while(ptr3<=(r-l))\\n        {\\n            if(ptr1==(m+1))\\n            {\\n                Arr[ptr3]=arr[ptr2];\\n                ptr2++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(ptr2==(r+1))\\n            {\\n                while(idx<=r && arr[ptr1]>(2*((long long)arr[idx])))\\n                {\\n                    idx++;\\n                }\\n                inversions+=idx-m-1;\\n                Arr[ptr3]=arr[ptr1];\\n                ptr1++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(arr[ptr1]<=arr[ptr2])\\n            {\\n                while(idx<=r && arr[ptr1]>(2*((long long)arr[idx])))\\n                {\\n                    idx++;\\n                }\\n                inversions+=idx-m-1;\\n                Arr[ptr3]=arr[ptr1];\\n                ptr1++;\\n                ptr3++;\\n            }\\n            else\\n            {\\n                Arr[ptr3]=arr[ptr2];\\n                ptr2++;\\n                ptr3++;\\n            }\\n        }\\n        for(int i=l;i<=r;i++)\\n        {\\n            arr[i]=Arr[i-l];\\n        }\\n        return;\\n    }\\n    void mergeSort(vector<int>&arr,int l,int r)\\n    {\\n        if(l==r)\\n        {\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        mergeSort(arr,l,mid);\\n        mergeSort(arr,mid+1,r);\\n        merge(arr,l,mid,r);\\n        return;\\n    }\\n    int reversePairs(vector<int>&nums) \\n    {\\n        mergeSort(nums,0,nums.size()-1);\\n        return inversions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int inversions=0;\\n    int find_index_where_just_greater(int left,int right,vector<int>&arr,int target)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            long long x=arr[mid];\\n            x*=2;\\n            if(x>=target)\\n            {\\n                right=mid-1;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return (left-1);\\n    }\\n    void merge(vector<int>&arr,int l,int m,int r)\\n    {\\n        vector<int>Arr(r-l+1);\\n        int ptr1=l,ptr2=m+1,ptr3=0;\\n        while(ptr3<=(r-l))\\n        {\\n            if(ptr1==(m+1))\\n            {\\n                Arr[ptr3]=arr[ptr2];\\n                ptr2++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(ptr2==(r+1))\\n            {\\n                int idx=find_index_where_just_greater(m+1,r,arr,arr[ptr1]);\\n                inversions+=idx-m;\\n                Arr[ptr3]=arr[ptr1];\\n                ptr1++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(arr[ptr1]<=arr[ptr2])\\n            {\\n                int idx=find_index_where_just_greater(m+1,r,arr,arr[ptr1]);\\n                inversions+=idx-m;\\n                Arr[ptr3]=arr[ptr1];\\n                ptr1++;\\n                ptr3++;\\n            }\\n            else\\n            {\\n                Arr[ptr3]=arr[ptr2];\\n                ptr2++;\\n                ptr3++;\\n            }\\n        }\\n        for(int i=l;i<=r;i++)\\n        {\\n            arr[i]=Arr[i-l];\\n        }\\n        return;\\n    }\\n    void mergeSort(vector<int>&arr,int l,int r)\\n    {\\n        if(l==r)\\n        {\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        mergeSort(arr,l,mid);\\n        mergeSort(arr,mid+1,r);\\n        merge(arr,l,mid,r);\\n        return;\\n    }\\n    int reversePairs(vector<int>&nums) \\n    {\\n        mergeSort(nums,0,nums.size()-1);\\n        return inversions;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int inversions=0;\\n    void merge(vector<int>&arr,int l,int m,int r)\\n    {\\n        vector<int>Arr(r-l+1);\\n        int ptr1=l,ptr2=m+1,ptr3=0,idx=m+1;\\n        while(ptr3<=(r-l))\\n        {\\n            if(ptr1==(m+1))\\n            {\\n                Arr[ptr3]=arr[ptr2];\\n                ptr2++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(ptr2==(r+1))\\n            {\\n                while(idx<=r && arr[ptr1]>(2*((long long)arr[idx])))\\n                {\\n                    idx++;\\n                }\\n                inversions+=idx-m-1;\\n                Arr[ptr3]=arr[ptr1];\\n                ptr1++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(arr[ptr1]<=arr[ptr2])\\n            {\\n                while(idx<=r && arr[ptr1]>(2*((long long)arr[idx])))\\n                {\\n                    idx++;\\n                }\\n                inversions+=idx-m-1;\\n                Arr[ptr3]=arr[ptr1];\\n                ptr1++;\\n                ptr3++;\\n            }\\n            else\\n            {\\n                Arr[ptr3]=arr[ptr2];\\n                ptr2++;\\n                ptr3++;\\n            }\\n        }\\n        for(int i=l;i<=r;i++)\\n        {\\n            arr[i]=Arr[i-l];\\n        }\\n        return;\\n    }\\n    void mergeSort(vector<int>&arr,int l,int r)\\n    {\\n        if(l==r)\\n        {\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        mergeSort(arr,l,mid);\\n        mergeSort(arr,mid+1,r);\\n        merge(arr,l,mid,r);\\n        return;\\n    }\\n    int reversePairs(vector<int>&nums) \\n    {\\n        mergeSort(nums,0,nums.size()-1);\\n        return inversions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025887,
                "title": "c-merge-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo get an intuition of merge sort u think basically we have to check how many elements are greater as per some condtion like inversions SO in these kind of problems merge sort can be used beacuase we comapre left subarray which is sorted to right subarray through that we can minimize time complexity beacuse we don\\'t need to chekc all combinations .. That is key thing about merge sort just like it makes  sorting in nlogn \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust Modified Merge sort only a change in merge function count as per condition rest is same\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\\n    int i=low,j=mid+1;\\n    int r=j;\\n    int c=0;\\n    vector<int>v;\\n     while(i<=mid){\\n        while(r<=high and arr[i]>(long long)2*arr[r]){\\n            c++;\\n            r++;\\n        }\\n        cnt+=c;\\n        \\n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\\n          v.push_back(arr[i++]);\\n     }\\n     while(j<=high)v.push_back(arr[j++]);\\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\\n}\\n\\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\\n       if(low<high){\\n      int mid=low+(high-low)/2;\\n      mergesort(arr,low,mid,cnt);\\n      mergesort(arr,mid+1,high,cnt);\\n      merge(arr,low,mid,high,cnt);\\n       }\\n   }\\n    int reversePairs(vector<int>& arr) {\\n      // merge sort -> modified merge function \\n    int cnt=0;\\n    int n=arr.size();\\n    mergesort(arr,0,n-1,cnt);\\n    if(n<=1 or cnt==0)return 0;\\n    return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\\n    int i=low,j=mid+1;\\n    int r=j;\\n    int c=0;\\n    vector<int>v;\\n     while(i<=mid){\\n        while(r<=high and arr[i]>(long long)2*arr[r]){\\n            c++;\\n            r++;\\n        }\\n        cnt+=c;\\n        \\n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\\n          v.push_back(arr[i++]);\\n     }\\n     while(j<=high)v.push_back(arr[j++]);\\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\\n}\\n\\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\\n       if(low<high){\\n      int mid=low+(high-low)/2;\\n      mergesort(arr,low,mid,cnt);\\n      mergesort(arr,mid+1,high,cnt);\\n      merge(arr,low,mid,high,cnt);\\n       }\\n   }\\n    int reversePairs(vector<int>& arr) {\\n      // merge sort -> modified merge function \\n    int cnt=0;\\n    int n=arr.size();\\n    mergesort(arr,0,n-1,cnt);\\n    if(n<=1 or cnt==0)return 0;\\n    return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585746,
                "title": "100-best-solution-explained-for-interview-purpose",
                "content": "\\u2714\\uFE0F 100% Best Solution Explained For Interview Purpose\\n\\nPLEASE UPVOTE !!! if you think it is benificial\\n```\\nclass Solution {\\n    int res = 0;\\n\\n   int Merge(vector < int > & nums, int low, int mid, int high) {\\n  int total = 0;\\n  int j = mid + 1;\\n  for (int i = low; i <= mid; i++) {\\n    while (j <= high && nums[i] > 2ll  * nums[j]) {\\n      j++;\\n    }\\n    total += (j - (mid + 1));\\n  }\\n\\n  vector < int > t;\\n  int left = low, right = mid + 1;\\n\\n  while (left <= mid && right <= high) {\\n\\n    if (nums[left] <= nums[right]) {\\n      t.push_back(nums[left++]);\\n    } else {\\n      t.push_back(nums[right++]);\\n    }\\n  }\\n\\n  while (left <= mid) {\\n    t.push_back(nums[left++]);\\n  }\\n  while (right <= high) {\\n    t.push_back(nums[right++]);\\n  }\\n\\n  for (int i = low; i <= high; i++) {\\n    nums[i] = t[i - low];\\n  }\\n  return total;\\n}\\nint MergeSort(vector < int > & nums, int low, int high) {\\n\\n  if (low >= high) return 0;\\n  int mid = (low + high) / 2;\\n  int inv = MergeSort(nums, low, mid);\\n  inv += MergeSort(nums, mid + 1, high);\\n  inv += Merge(nums, low, mid, high);\\n  return inv;\\n}\\n\\npublic:\\n    int reversePairs(vector<int> &nums) {\\n        return MergeSort(nums, 0, nums.size() - 1);\\n        \\n    }\\n};\\n```\\nHope you like the solution\\n",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n\\n   int Merge(vector < int > & nums, int low, int mid, int high) {\\n  int total = 0;\\n  int j = mid + 1;\\n  for (int i = low; i <= mid; i++) {\\n    while (j <= high && nums[i] > 2ll  * nums[j]) {\\n      j++;\\n    }\\n    total += (j - (mid + 1));\\n  }\\n\\n  vector < int > t;\\n  int left = low, right = mid + 1;\\n\\n  while (left <= mid && right <= high) {\\n\\n    if (nums[left] <= nums[right]) {\\n      t.push_back(nums[left++]);\\n    } else {\\n      t.push_back(nums[right++]);\\n    }\\n  }\\n\\n  while (left <= mid) {\\n    t.push_back(nums[left++]);\\n  }\\n  while (right <= high) {\\n    t.push_back(nums[right++]);\\n  }\\n\\n  for (int i = low; i <= high; i++) {\\n    nums[i] = t[i - low];\\n  }\\n  return total;\\n}\\nint MergeSort(vector < int > & nums, int low, int high) {\\n\\n  if (low >= high) return 0;\\n  int mid = (low + high) / 2;\\n  int inv = MergeSort(nums, low, mid);\\n  inv += MergeSort(nums, mid + 1, high);\\n  inv += Merge(nums, low, mid, high);\\n  return inv;\\n}\\n\\npublic:\\n    int reversePairs(vector<int> &nums) {\\n        return MergeSort(nums, 0, nums.size() - 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857557,
                "title": "java-solution-with-comments-optimal",
                "content": "<b>TC</b> = O(NlogN) +O(N) + O(N)\\n<b>SC</b> = O(N) \\n\\n```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length-1);  // calling merge sort with low, high params\\n    }\\n    static int mergesort(int[] nums, int low, int high){\\n        if(low>=high){   // if it is a single element we will return 0 as it won\\'t be contributing to the ans\\n            return 0;\\n        }\\n        int mid = (low+high)/2;    // computing the mid for the merge sort\\n        int inv = mergesort(nums,low,mid);   // calling the left half via recursion i.e low to mid\\n        inv += mergesort(nums,mid+1, high); // calling the right half via recursion i.e mid+1 to high\\n        inv += merge(nums,low,mid,high);  // merging the 2 sorted arrays and returning the inverted pairs in int form\\n        \\n        return inv;  // returing the inversion pairs for every recursive call\\n    }\\n    static int merge(int[] nums, int low, int mid, int high){\\n        int cnt = 0;\\n        int j = mid + 1;  // initializing j at the starting position of the right half of the array\\n        for(int i= low;i<=mid;i++){    // iterate i in the left half of the array\\n            while(j<=high && nums[i]> (2 * (long) nums[j])){ // either right half is exausted or if condition in question turns out as false, keep incrementing the j pointer\\n                j++;\\n            }\\n            cnt+= (j-(mid+1));  // counting the number of left elements (how much j has moved from initial mid+1)\\n        }\\n\\t\\t\\n\\t\\t// now we simply perform the merge function \\n\\t\\t\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        int left = low;\\n        int right = mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){ // adding the smaller to the temp arraylist\\n                temp.add(nums[left++]);  // incrementing the index of the added element\\n            }\\n            else{\\n                temp.add(nums[right++]); // adding and incrementing right if right is smaller\\n            }\\n        }\\n        while(left<=mid){    // if left part is left to be copied, we add it to the arraylist and increment index left\\n            temp.add(nums[left++]);\\n        }\\n        while(right<=high){   // if right part is left to be copied, we add it to the arraylist and increment index right\\n            temp.add(nums[right++]);\\n        }\\n        for(int i =low;i<=high;i++){\\n            nums[i] = temp.get(i-low);  // copying the sorted arraylist to the original nums array\\n        }\\n        return cnt;  // returing the total number of pairs\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length-1);  // calling merge sort with low, high params\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1456451,
                "title": "c-variation-of-inversion-count-merge-sort",
                "content": "```\\nclass Solution {\\npublic: vector<int>t;\\n    int merge(vector<int>& nums,int l,int m,int h){\\n        int c=0,j=m+1;\\n        for(int i=l;i<=m;i++){\\n            while(j<=h && nums[i]>2*(long)nums[j]) j++;\\n            c+=j-(m+1);\\n        }\\n        int i=l,k=l;\\n        j=m+1;\\n        while(i<=m && j<=h){\\n            if(nums[i]<=nums[j])t[k++]=nums[i++];\\n            else t[k++]=nums[j++];\\n        }\\n        while(i<=m)t[k++]=nums[i++];\\n        while(j<=h)t[k++]=nums[j++];\\n        for(int i=l;i<=h;i++)nums[i]=t[i];\\n        return c;\\n    }\\n    int mergesort(vector<int>& nums,int l,int h){\\n        int inv=0;\\n        if(h>l){\\n            int m=l+(h-l)/2;\\n            inv+=mergesort(nums,l,m);\\n            inv+=mergesort(nums,m+1,h);\\n            inv+=merge(nums,l,m,h);\\n        }\\n        return inv;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        t=vector<int>(nums.size());\\n        return mergesort(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic: vector<int>t;\\n    int merge(vector<int>& nums,int l,int m,int h){\\n        int c=0,j=m+1;\\n        for(int i=l;i<=m;i++){\\n            while(j<=h && nums[i]>2*(long)nums[j]) j++;\\n            c+=j-(m+1);\\n        }\\n        int i=l,k=l;\\n        j=m+1;\\n        while(i<=m && j<=h){\\n            if(nums[i]<=nums[j])t[k++]=nums[i++];\\n            else t[k++]=nums[j++];\\n        }\\n        while(i<=m)t[k++]=nums[i++];\\n        while(j<=h)t[k++]=nums[j++];\\n        for(int i=l;i<=h;i++)nums[i]=t[i];\\n        return c;\\n    }\\n    int mergesort(vector<int>& nums,int l,int h){\\n        int inv=0;\\n        if(h>l){\\n            int m=l+(h-l)/2;\\n            inv+=mergesort(nums,l,m);\\n            inv+=mergesort(nums,m+1,h);\\n            inv+=merge(nums,l,m,h);\\n        }\\n        return inv;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        t=vector<int>(nums.size());\\n        return mergesort(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892433,
                "title": "explained-easy-c-inversion-count-using-merge-sort-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long merge(vector<int> &arr , int left , int mid , int right , int temp[]){\\n        // here mid = mid + 1(we passed mid + 1 when we were calling merge function)\\n        int i = left , j = mid , k = left;\\n        long long inv = 0 ;\\n        \\n        // counting number of inversions alag se while doing merge\\n\\t\\t//because we were not able to merge the elements in sorted \\n\\t\\t//oreder with the given condition arr[i] > 2*arr[j] unlike the counting inversion question\\n\\t\\t//on geeks in which the conditon was arr[i] > arr[j]. and we were able to merge and count inversions simoultaniously(EK SATH)\\n        \\n        while(i < mid && j <=right ){\\n            if((long long)arr[i] > 2*(long long)arr[j]){\\n                inv += mid - i;\\n                j++;\\n            }\\n            else \\n                i++;\\n        }\\n        \\n        i = left ; j = mid;\\n        \\n\\t\\t// merging and storing in temp array\\n        while(i < mid && j <= right){\\n            if(arr[i] <= arr[j])\\n                temp[k++] = arr[i++];\\n            else\\n                temp[k++] = arr[j++];\\n        }\\n        \\n        while(i < mid)\\n            temp[k++] = arr[i++];\\n        \\n        while(j <= right)\\n            temp[k++] = arr[j++];\\n        \\n\\t\\t//storing in the main array(NUMS array) \\n        for(; left <= right ; left++)\\n            arr[left] = temp[left];\\n        \\n        return inv;\\n    }\\n    \\n   int solve(vector<int> &arr , int left , int right ,int temp[]){\\n        if(left == right)\\n            return 0;\\n        \\n       long long inv  = 0;\\n        int mid = left + (right - left)/2;\\n        \\n        inv+=solve(arr , left , mid , temp);        // left part inversion count \\n        inv+=solve(arr , mid + 1 , right , temp);   // right part inversion count\\n        inv+=merge(arr , left , mid + 1 , right , temp);    \\n        \\n        return inv;\\n    }\\n\\nlong long reversePairs(vector<int>& nums)\\n{\\n    int n = nums.size();\\n   if(n == 0 )\\n        return 0;\\n    \\n    int temp[n];\\n   \\n    return solve(nums , 0 , n - 1 , temp);\\n    \\n    // if we print the nums array after calling the solve function then our nums array will be sorted as we are using merge sort to find the inversion count (in this case the condition is nums[i] > 2*nums[j])\\n    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    long long merge(vector<int> &arr , int left , int mid , int right , int temp[]){\\n        // here mid = mid + 1(we passed mid + 1 when we were calling merge function)\\n        int i = left , j = mid , k = left;\\n        long long inv = 0 ;\\n        \\n        // counting number of inversions alag se while doing merge\\n\\t\\t//because we were not able to merge the elements in sorted \\n\\t\\t//oreder with the given condition arr[i] > 2*arr[j] unlike the counting inversion question\\n\\t\\t//on geeks in which the conditon was arr[i] > arr[j]. and we were able to merge and count inversions simoultaniously(EK SATH)\\n        \\n        while(i < mid && j <=right ){\\n            if((long long)arr[i] > 2*(long long)arr[j]){\\n                inv += mid - i;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 384566,
                "title": "detailed-analysis-of-merge-sort-solution-and-binary-index-tree-solution-for-similar-problems",
                "content": "**This problem is very similar to 315, Similar problems are 315, 493, 327, (303, 304), 307, 363. I spent one to two days on this and finally completely understood it. This is post on 315. Please be patient and read it first**\\n[https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/384514/Detailed-Analysis-of-Merge-Sort-Solution-and-Binary-Index-Tree-Solution-for-similar-problems](http://)\\n\\nHere, just to sum up. Merge Sort is quite easy.\\n\\n```\\npublic int reversePairs4(int[] A) {\\n        return reversePairsSub(A, 0, A.length - 1);\\n    }\\n        \\n    private int reversePairsSub(int[] A, int left, int r) {\\n        if (left >= r) return 0;\\n            \\n        int m = left + ((r - left) >> 1);\\n        int res = reversePairsSub(A, left, m) + reversePairsSub(A, m + 1, r);\\n            \\n        int i = left, j = m + 1, k = 0, p = m + 1;\\n        int[] merge = new int[r - left + 1];\\n            \\n        while (i <= m) {\\n            while (p <= r && A[i] * 1.0 / 2 > A[p]) p++;// avoid overflow, or A[i] > 2 L * A[p]\\n            res += p - (m + 1);\\n    \\t\\t\\t\\t\\n            while (j <= r && A[j] < A[i]) merge[k++] = A[j++];\\n            merge[k++] = A[i++];\\n        }\\n            \\n        //while (j <= r) merge[k++] = A[j++];\\n            \\n        System.arraycopy(merge, 0, A, left, j - left);\\n            \\n        return res;\\n    }\\n```\\n\\nThis problem ask for *A[i] > 2A[j] with i < j*. \\n**1. Fix j, that is to find the number of elements > 2A[j] to its left. With Binary Index Tree, we scan from left.\\n2. Or fix i, *A[i] / 2 > A[j] with i < j*, find the number of elements < A[i] / 2 to its right. With Binary Index Tree, we scan from right.**\\n\\nThis is scanning from left becase we are looking for numbers that is > 2A[j] to its left.\\n```\\npublic int reversePairs(int[] A) {\\n        int res = 0;\\n        int n = A.length;\\n        int[] copy = Arrays.copyOf(A, n);\\n        int[] bit = new int[n + 1];\\n        Arrays.sort(copy);\\n        \\n        for (int x: A) {\\n            res += getSum(bit, index2(copy, 2L * x)  + 1);// A[i] > 2 x for any i > index2(copy, 2L * x) in BIT\\n            update(bit, index2(copy, x), 1);\\n        }\\n        return res;\\n    }\\n    \\n // helper function\\n    // binary search to find the last element that <= val in input array\\n    // input A should be sorted\\n    private int index2(int[] A, long val) {\\n        int left = 0, r = A.length;\\n        \\t\\n        while (left < r) {\\n        \\tint m = left + ((r - left) >> 1);\\n        \\t\\t\\n        \\tif (A[m] > val) {\\n        \\t    r = m; // m - 1 must be the position, since BIT starts from 1, return r\\n        \\t} else {\\n        \\t    left = m + 1;\\n        \\t}\\n        }\\n        return r;// r is the final index in BIT\\n    }\\n\\t\\n\\t// Binary Index Tree\\n    // O(logn)\\n    // @bit : binary index tree array\\n    // @i : from start index to index i in bit (inclusively)\\n    // return : the prefix sum from start index to index i\\n    private int getSum(int[] bit, int i) {\\n        int sum = 0;\\n        while (i < bit.length) {\\n            sum += bit[i];\\n            i = i + (i & -i);\\n        }\\n        return sum;\\n    }\\n    \\n    // O(logn)\\n    // update the value in index i by diff\\n    private void update(int[] bit, int i, int diff) {\\n        // need to update all of its affected nodes as well\\n        while (i > 0) {\\n            bit[i] += diff;\\n            i = i - (i & -i);\\n        }\\n    }\\n```\\n\\nThis is scanning from right becase we are looking for numbers that is > A[i] / 2to its right.\\n```\\npublic int reversePairs2(int[] A) {\\n        int n = A.length;\\n        if (A == null || n <= 1) return 0;\\n        int[] BIT = new int[n + 1];\\n        int[] copy = A.clone();\\n        Arrays.sort(copy);\\n        int res = 0;\\n  \\n        for (int i = n - 1; i >= 0; i--) {\\n            res += search(BIT, index(copy, 1.0 * A[i] / 2) - 1);//going down \\n            insert(BIT, index(copy, A[i]));// going up\\n        } \\n        return res;\\n    }\\n    \\n    private int search(int[] BIT, int i) {\\n        int cnt = 0;\\n        while (i > 0) {\\n            cnt += BIT[i];\\n            i -= (i & -i);\\n        }\\n        return cnt;\\n    }\\n    \\n    private void insert(int[] BIT, int i){\\n        while (i < BIT.length) {\\n            BIT[i]++;\\n            i += (i & -i);\\n        }\\n    }          \\n    \\n    //first position in BIT that has A[i] >= val\\n    private int index(int[] A, double val) {\\n        int left = 0, r = A.length;\\n        while (left < r) {\\n        \\tint m = left + ((r - left) >> 1);\\n        \\tif (A[m] >= val) {\\n        \\t    r = m;\\n        \\t} else {\\n        \\t    left = m + 1;//A[m] < val, so left must be the position \\n        \\t}\\n        }\\n        return left + 1;\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\npublic int reversePairs4(int[] A) {\\n        return reversePairsSub(A, 0, A.length - 1);\\n    }\\n        \\n    private int reversePairsSub(int[] A, int left, int r) {\\n        if (left >= r) return 0;\\n            \\n        int m = left + ((r - left) >> 1);\\n        int res = reversePairsSub(A, left, m) + reversePairsSub(A, m + 1, r);\\n            \\n        int i = left, j = m + 1, k = 0, p = m + 1;\\n        int[] merge = new int[r - left + 1];\\n            \\n        while (i <= m) {\\n            while (p <= r && A[i] * 1.0 / 2 > A[p]) p++;// avoid overflow, or A[i] > 2 L * A[p]\\n            res += p - (m + 1);\\n    \\t\\t\\t\\t\\n            while (j <= r && A[j] < A[i]) merge[k++] = A[j++];\\n            merge[k++] = A[i++];\\n        }\\n            \\n        //while (j <= r) merge[k++] = A[j++];\\n            \\n        System.arraycopy(merge, 0, A, left, j - left);\\n            \\n        return res;\\n    }\\n```\n```\\npublic int reversePairs(int[] A) {\\n        int res = 0;\\n        int n = A.length;\\n        int[] copy = Arrays.copyOf(A, n);\\n        int[] bit = new int[n + 1];\\n        Arrays.sort(copy);\\n        \\n        for (int x: A) {\\n            res += getSum(bit, index2(copy, 2L * x)  + 1);// A[i] > 2 x for any i > index2(copy, 2L * x) in BIT\\n            update(bit, index2(copy, x), 1);\\n        }\\n        return res;\\n    }\\n    \\n // helper function\\n    // binary search to find the last element that <= val in input array\\n    // input A should be sorted\\n    private int index2(int[] A, long val) {\\n        int left = 0, r = A.length;\\n        \\t\\n        while (left < r) {\\n        \\tint m = left + ((r - left) >> 1);\\n        \\t\\t\\n        \\tif (A[m] > val) {\\n        \\t    r = m; // m - 1 must be the position, since BIT starts from 1, return r\\n        \\t} else {\\n        \\t    left = m + 1;\\n        \\t}\\n        }\\n        return r;// r is the final index in BIT\\n    }\\n\\t\\n\\t// Binary Index Tree\\n    // O(logn)\\n    // @bit : binary index tree array\\n    // @i : from start index to index i in bit (inclusively)\\n    // return : the prefix sum from start index to index i\\n    private int getSum(int[] bit, int i) {\\n        int sum = 0;\\n        while (i < bit.length) {\\n            sum += bit[i];\\n            i = i + (i & -i);\\n        }\\n        return sum;\\n    }\\n    \\n    // O(logn)\\n    // update the value in index i by diff\\n    private void update(int[] bit, int i, int diff) {\\n        // need to update all of its affected nodes as well\\n        while (i > 0) {\\n            bit[i] += diff;\\n            i = i - (i & -i);\\n        }\\n    }\\n```\n```\\npublic int reversePairs2(int[] A) {\\n        int n = A.length;\\n        if (A == null || n <= 1) return 0;\\n        int[] BIT = new int[n + 1];\\n        int[] copy = A.clone();\\n        Arrays.sort(copy);\\n        int res = 0;\\n  \\n        for (int i = n - 1; i >= 0; i--) {\\n            res += search(BIT, index(copy, 1.0 * A[i] / 2) - 1);//going down \\n            insert(BIT, index(copy, A[i]));// going up\\n        } \\n        return res;\\n    }\\n    \\n    private int search(int[] BIT, int i) {\\n        int cnt = 0;\\n        while (i > 0) {\\n            cnt += BIT[i];\\n            i -= (i & -i);\\n        }\\n        return cnt;\\n    }\\n    \\n    private void insert(int[] BIT, int i){\\n        while (i < BIT.length) {\\n            BIT[i]++;\\n            i += (i & -i);\\n        }\\n    }          \\n    \\n    //first position in BIT that has A[i] >= val\\n    private int index(int[] A, double val) {\\n        int left = 0, r = A.length;\\n        while (left < r) {\\n        \\tint m = left + ((r - left) >> 1);\\n        \\tif (A[m] >= val) {\\n        \\t    r = m;\\n        \\t} else {\\n        \\t    left = m + 1;//A[m] < val, so left must be the position \\n        \\t}\\n        }\\n        return left + 1;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128071,
                "title": "python-segment-tree-and-binary-index-tree-solution",
                "content": "```\\nclass SegmentTreeNode(object):\\n    def __init__(self, val, start, end):\\n        self.val = val\\n        self.start, self.end = start, end\\n        self.left, self.right = None, None\\n\\nclass SegmentTree(object):\\n    def __init__(self, n):\\n        self.root = self.buildTree(0, n-1)\\n\\n    def buildTree(self, start, end):\\n        if start > end:\\n            return None\\n        root = SegmentTreeNode(0, start, end)\\n        if start == end:\\n            return root\\n        mid = (start+end) / 2\\n        root.left, root.right = self.buildTree(start, mid), self.buildTree(mid+1, end)\\n        return root\\n\\n    def update(self, i, diff, root=None):\\n        root = root or self.root\\n        if i < root.start or i > root.end:\\n            return\\n        root.val += diff\\n        if i == root.start == root.end:\\n            return\\n        self.update(i, diff, root.left)\\n        self.update(i, diff, root.right)\\n\\n    def sum(self, start, end, root=None):\\n        root = root or self.root\\n        if end < root.start or start > root.end:\\n            return 0\\n        if start <= root.start and end >= root.end:\\n            return root.val\\n        return self.sum(start, end, root.left) + self.sum(start, end, root.right)\\n\\nclass BinaryIndexTree(object):\\n    def __init__(self, n):\\n        self.sums = [0] * (n+1)\\n\\n    def update(self, i, val):\\n        while i < len(self.sums):\\n            self.sums[i] += val\\n            i += i & -i\\n\\n    def sum(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & -i\\n        return res\\n\\nclass Solution(object):\\n\\n    # The number we search may not be in the array\\n    def greater_than(self, nums, x):\\n        return bisect.bisect_right(nums, x)\\n\\n    # The number we search is in the array\\n    def index(self, nums, x):\\n        return bisect.bisect_left(nums, x)\\n\\n    def reversePairsSegmentTree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        seg_tree, res = SegmentTree(len(nums)), 0\\n        sorted_nums = sorted(nums)\\n        n = len(nums)\\n        for i in xrange(0, n):\\n            gt = self.greater_than(sorted_nums, 2*nums[i])\\n            res += seg_tree.sum(gt, n-1)\\n            idx = self.index(sorted_nums, nums[i])\\n            seg_tree.update(idx, 1)\\n        return res\\n\\n    def reversePairsBinaryIndexTree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        bi_tree, res = BinaryIndexTree(len(nums)), 0\\n        sorted_nums = sorted(nums)\\n        n = len(nums)\\n        for i in xrange(0, len(nums)):\\n            gt = self.greater_than(sorted_nums, 2*nums[i])\\n            res += bi_tree.sum(n) - bi_tree.sum(gt)\\n            idx = self.index(sorted_nums, nums[i])\\n            bi_tree.update(idx+1, 1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTreeNode(object):\\n    def __init__(self, val, start, end):\\n        self.val = val\\n        self.start, self.end = start, end\\n        self.left, self.right = None, None\\n\\nclass SegmentTree(object):\\n    def __init__(self, n):\\n        self.root = self.buildTree(0, n-1)\\n\\n    def buildTree(self, start, end):\\n        if start > end:\\n            return None\\n        root = SegmentTreeNode(0, start, end)\\n        if start == end:\\n            return root\\n        mid = (start+end) / 2\\n        root.left, root.right = self.buildTree(start, mid), self.buildTree(mid+1, end)\\n        return root\\n\\n    def update(self, i, diff, root=None):\\n        root = root or self.root\\n        if i < root.start or i > root.end:\\n            return\\n        root.val += diff\\n        if i == root.start == root.end:\\n            return\\n        self.update(i, diff, root.left)\\n        self.update(i, diff, root.right)\\n\\n    def sum(self, start, end, root=None):\\n        root = root or self.root\\n        if end < root.start or start > root.end:\\n            return 0\\n        if start <= root.start and end >= root.end:\\n            return root.val\\n        return self.sum(start, end, root.left) + self.sum(start, end, root.right)\\n\\nclass BinaryIndexTree(object):\\n    def __init__(self, n):\\n        self.sums = [0] * (n+1)\\n\\n    def update(self, i, val):\\n        while i < len(self.sums):\\n            self.sums[i] += val\\n            i += i & -i\\n\\n    def sum(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & -i\\n        return res\\n\\nclass Solution(object):\\n\\n    # The number we search may not be in the array\\n    def greater_than(self, nums, x):\\n        return bisect.bisect_right(nums, x)\\n\\n    # The number we search is in the array\\n    def index(self, nums, x):\\n        return bisect.bisect_left(nums, x)\\n\\n    def reversePairsSegmentTree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        seg_tree, res = SegmentTree(len(nums)), 0\\n        sorted_nums = sorted(nums)\\n        n = len(nums)\\n        for i in xrange(0, n):\\n            gt = self.greater_than(sorted_nums, 2*nums[i])\\n            res += seg_tree.sum(gt, n-1)\\n            idx = self.index(sorted_nums, nums[i])\\n            seg_tree.update(idx, 1)\\n        return res\\n\\n    def reversePairsBinaryIndexTree(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        bi_tree, res = BinaryIndexTree(len(nums)), 0\\n        sorted_nums = sorted(nums)\\n        n = len(nums)\\n        for i in xrange(0, len(nums)):\\n            gt = self.greater_than(sorted_nums, 2*nums[i])\\n            res += bi_tree.sum(n) - bi_tree.sum(gt)\\n            idx = self.index(sorted_nums, nums[i])\\n            bi_tree.update(idx+1, 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800593,
                "title": "using-merge-sort-easy-to-understand",
                "content": "# Intuition\\nWe can use merge sort with additional functionality to get reversePairs.\\n\\n# Complexity\\n- Time complexity:\\nN*(log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    void merge(int l,int mid,int r,vector<int> &arr) {\\n        int j=mid+1;\\n        // Additional for loop to count number of reversePairs\\n        for(int i=l; i<=mid; i++){\\n            while(j<=r && arr[i] > 2*(long long)arr[j]){\\n                j++;\\n            }\\n            cnt+=j-(mid+1);\\n        }\\n        vector<int> tmp;\\n        int left=l,right=mid+1;\\n        while(left<=mid && right<=r) {\\n            if(arr[left]<=arr[right]) {\\n                tmp.push_back(arr[left++]);\\n            }\\n            else {\\n                tmp.push_back(arr[right++]);\\n            }\\n        }\\n        while(left<=mid) {\\n            tmp.push_back(arr[left++]);\\n        }\\n        while(right<=r) {\\n            tmp.push_back(arr[right++]);\\n        }\\n        for(int i=l;i<=r;i++) {\\n            arr[i]=tmp[i-l];\\n        }\\n    }\\n\\n    void ms(int l,int r,vector<int> &arr) {\\n        if(l==r) return;\\n        int mid=(l+r)>>1;\\n        ms(l,mid,arr);\\n        ms(mid+1,r,arr);\\n        merge(l,mid,r,arr);\\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        ms(0,nums.size()-1,nums);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    void merge(int l,int mid,int r,vector<int> &arr) {\\n        int j=mid+1;\\n        // Additional for loop to count number of reversePairs\\n        for(int i=l; i<=mid; i++){\\n            while(j<=r && arr[i] > 2*(long long)arr[j]){\\n                j++;\\n            }\\n            cnt+=j-(mid+1);\\n        }\\n        vector<int> tmp;\\n        int left=l,right=mid+1;\\n        while(left<=mid && right<=r) {\\n            if(arr[left]<=arr[right]) {\\n                tmp.push_back(arr[left++]);\\n            }\\n            else {\\n                tmp.push_back(arr[right++]);\\n            }\\n        }\\n        while(left<=mid) {\\n            tmp.push_back(arr[left++]);\\n        }\\n        while(right<=r) {\\n            tmp.push_back(arr[right++]);\\n        }\\n        for(int i=l;i<=r;i++) {\\n            arr[i]=tmp[i-l];\\n        }\\n    }\\n\\n    void ms(int l,int r,vector<int> &arr) {\\n        if(l==r) return;\\n        int mid=(l+r)>>1;\\n        ms(l,mid,arr);\\n        ms(mid+1,r,arr);\\n        merge(l,mid,r,arr);\\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        ms(0,nums.size()-1,nums);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025885,
                "title": "c-merge-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo get an intuition of merge sort u think basically we have to check how many elements are greater as per some condtion like inversions SO in these kind of problems merge sort can be used beacuase we comapre left subarray which is sorted to right subarray through that we can minimize time complexity beacuse we don\\'t need to chekc all combinations .. That is key thing about merge sort just like it makes  sorting in nlogn \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust Modified Merge sort only a change in merge function count as per condition rest is same\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\\n    int i=low,j=mid+1;\\n    int r=j;\\n    int c=0;\\n    vector<int>v;\\n     while(i<=mid){\\n        while(r<=high and arr[i]>(long long)2*arr[r]){\\n            c++;\\n            r++;\\n        }\\n        cnt+=c;\\n        \\n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\\n          v.push_back(arr[i++]);\\n     }\\n     while(j<=high)v.push_back(arr[j++]);\\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\\n}\\n\\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\\n       if(low<high){\\n      int mid=low+(high-low)/2;\\n      mergesort(arr,low,mid,cnt);\\n      mergesort(arr,mid+1,high,cnt);\\n      merge(arr,low,mid,high,cnt);\\n       }\\n   }\\n    int reversePairs(vector<int>& arr) {\\n      // merge sort -> modified merge function \\n    int cnt=0;\\n    int n=arr.size();\\n    mergesort(arr,0,n-1,cnt);\\n    if(n<=1 or cnt==0)return 0;\\n    return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\\n    int i=low,j=mid+1;\\n    int r=j;\\n    int c=0;\\n    vector<int>v;\\n     while(i<=mid){\\n        while(r<=high and arr[i]>(long long)2*arr[r]){\\n            c++;\\n            r++;\\n        }\\n        cnt+=c;\\n        \\n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\\n          v.push_back(arr[i++]);\\n     }\\n     while(j<=high)v.push_back(arr[j++]);\\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\\n}\\n\\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\\n       if(low<high){\\n      int mid=low+(high-low)/2;\\n      mergesort(arr,low,mid,cnt);\\n      mergesort(arr,mid+1,high,cnt);\\n      merge(arr,low,mid,high,cnt);\\n       }\\n   }\\n    int reversePairs(vector<int>& arr) {\\n      // merge sort -> modified merge function \\n    int cnt=0;\\n    int n=arr.size();\\n    mergesort(arr,0,n-1,cnt);\\n    if(n<=1 or cnt==0)return 0;\\n    return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695444,
                "title": "segment-tree-set-c-easy-implementation",
                "content": "```\\nint seg[1000006];\\nvoid update(int ind, int st, int en, int index) {\\n    if(st == en) {\\n        seg[ind]++;\\n        return;\\n    }\\n    int mid = (st + en) >> 1;\\n    if(index <= mid) {\\n        update(2 * ind + 1, st, mid, index);\\n    }\\n    else {\\n        update(2 * ind + 2, mid + 1, en, index);\\n    }\\n    seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\\n} \\nint query(int ind, int st, int en, int l, int r) {\\n    if(en < l || st > r || st > en) {\\n        return 0;\\n    }\\n    if(l <= st && en <= r) {\\n        return seg[ind];\\n    }\\n    int mid = (st + en) >> 1;\\n    return query(2 * ind + 1, st, mid, l, r) + query(2 * ind + 2, mid + 1, en, l, r);\\n}\\nint reversePairs(vector<int>& nums) {\\n    int n = nums.size();\\n    set<long long> st(nums.begin(), nums.end());\\n    int cnt = 0;\\n    unordered_map<int, int> mp;\\n    for(int i : st) {\\n        mp[i] = cnt++;\\n    }\\n    int ans = 0;\\n    for(int i = 0; i < n; i++) {\\n        long long rq = nums[i] * 2ll + 1;\\n        if(st.find(rq) != st.end()) {\\n            int l = mp[rq], r = n - 1;\\n            ans += query(0, 0, n - 1, l, r);\\n        }\\n        else {\\n            auto it = st.lower_bound(rq);\\n            if(it != st.end()) {\\n                int l = mp[*it], r = n - 1;\\n                ans += query(0, 0, n - 1, l, r);\\n            }\\n        }\\n        update(0, 0, n - 1, mp[nums[i]]);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nint seg[1000006];\\nvoid update(int ind, int st, int en, int index) {\\n    if(st == en) {\\n        seg[ind]++;\\n        return;\\n    }\\n    int mid = (st + en) >> 1;\\n    if(index <= mid) {\\n        update(2 * ind + 1, st, mid, index);\\n    }\\n    else {\\n        update(2 * ind + 2, mid + 1, en, index);\\n    }\\n    seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\\n} \\nint query(int ind, int st, int en, int l, int r) {\\n    if(en < l || st > r || st > en) {\\n        return 0;\\n    }\\n    if(l <= st && en <= r) {\\n        return seg[ind];\\n    }\\n    int mid = (st + en) >> 1;\\n    return query(2 * ind + 1, st, mid, l, r) + query(2 * ind + 2, mid + 1, en, l, r);\\n}\\nint reversePairs(vector<int>& nums) {\\n    int n = nums.size();\\n    set<long long> st(nums.begin(), nums.end());\\n    int cnt = 0;\\n    unordered_map<int, int> mp;\\n    for(int i : st) {\\n        mp[i] = cnt++;\\n    }\\n    int ans = 0;\\n    for(int i = 0; i < n; i++) {\\n        long long rq = nums[i] * 2ll + 1;\\n        if(st.find(rq) != st.end()) {\\n            int l = mp[rq], r = n - 1;\\n            ans += query(0, 0, n - 1, l, r);\\n        }\\n        else {\\n            auto it = st.lower_bound(rq);\\n            if(it != st.end()) {\\n                int l = mp[*it], r = n - 1;\\n                ans += query(0, 0, n - 1, l, r);\\n            }\\n        }\\n        update(0, 0, n - 1, mp[nums[i]]);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641687,
                "title": "modified-merge-sort",
                "content": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        count = 0;\\n        mergeSort(nums, 0, nums.length - 1);\\n        return count;\\n    }\\n    public int[] mergeSort(int[] nums, int lo, int hi) {\\n        if (lo == hi) {\\n            int[] bres = new int[1];\\n            bres[0] = nums[lo];\\n            return bres;\\n        }\\n        int mid = (lo + hi) / 2;\\n        int[] lsh = mergeSort(nums, lo, mid);\\n        int[] rsh = mergeSort(nums, mid + 1, hi);\\n        return merge(lsh, rsh);\\n    }\\n    int count;\\n    public int[] merge(int[] lsh, int[] rsh) {\\n        int i = 0;\\n        int j = 0;\\n        while (i < lsh.length && j < rsh.length) {\\n            if ((long)lsh[i] > (long)rsh[j] * 2) {\\n                count += lsh.length - i;\\n                j++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        j = 0;\\n        int k = 0;\\n        int[] mergedArr = new int[lsh.length + rsh.length];\\n        while (i < lsh.length && j < rsh.length) {\\n            if (lsh[i] < rsh[j]) {\\n                mergedArr[k] = lsh[i];\\n                i++;\\n                k++;\\n            } else {\\n                mergedArr[k] = rsh[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        \\n        while (i < lsh.length) {\\n            mergedArr[k] = lsh[i];\\n            i++;\\n            k++;\\n        }\\n        \\n        while (j < rsh.length) {\\n            mergedArr[k] = rsh[j];\\n            j++;\\n            k++;\\n        }\\n        return mergedArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        count = 0;\\n        mergeSort(nums, 0, nums.length - 1);\\n        return count;\\n    }\\n    public int[] mergeSort(int[] nums, int lo, int hi) {\\n        if (lo == hi) {\\n            int[] bres = new int[1];\\n            bres[0] = nums[lo];\\n            return bres;\\n        }\\n        int mid = (lo + hi) / 2;\\n        int[] lsh = mergeSort(nums, lo, mid);\\n        int[] rsh = mergeSort(nums, mid + 1, hi);\\n        return merge(lsh, rsh);\\n    }\\n    int count;\\n    public int[] merge(int[] lsh, int[] rsh) {\\n        int i = 0;\\n        int j = 0;\\n        while (i < lsh.length && j < rsh.length) {\\n            if ((long)lsh[i] > (long)rsh[j] * 2) {\\n                count += lsh.length - i;\\n                j++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        j = 0;\\n        int k = 0;\\n        int[] mergedArr = new int[lsh.length + rsh.length];\\n        while (i < lsh.length && j < rsh.length) {\\n            if (lsh[i] < rsh[j]) {\\n                mergedArr[k] = lsh[i];\\n                i++;\\n                k++;\\n            } else {\\n                mergedArr[k] = rsh[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        \\n        while (i < lsh.length) {\\n            mergedArr[k] = lsh[i];\\n            i++;\\n            k++;\\n        }\\n        \\n        while (j < rsh.length) {\\n            mergedArr[k] = rsh[j];\\n            j++;\\n            k++;\\n        }\\n        return mergedArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223250,
                "title": "simple-merge-sort-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void merge(vector<int>& nums,int l,int m,int h){\\n        vector<int>v;\\n        int i=l,j=m+1;\\n\\t\\t\\n        //counting reverse pairs\\n        while(i<=m && j<=h){\\n            long long t=2*(long(nums[j]));\\n            while(i<=m && nums[i]<=t)i++;\\n            ans+=(m-i+1);\\n            j++;\\n        }\\n\\t\\t\\n\\t\\t//sorting array\\n        i=l,j=m+1;\\n        while(i<=m && j<=h){\\n            if(nums[i]<=nums[j])v.push_back(nums[i++]);\\n            else v.push_back(nums[j++]);\\n        }\\n        while(i<=m)v.push_back(nums[i++]);\\n        while(j<=h)v.push_back(nums[j++]);\\n        for(int x=l,k=0;x<=h;x++,k++){\\n            nums[x]=v[k];\\n        }\\n        \\n    }\\n    \\n    void mergeSort(vector<int>& nums,int l,int h){\\n        if(l>=h)return;\\n        int m=(l+h)/2;\\n        mergeSort(nums,l,m);\\n        mergeSort(nums,m+1,h);\\n        merge(nums,l,m,h);\\n        \\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void merge(vector<int>& nums,int l,int m,int h){\\n        vector<int>v;\\n        int i=l,j=m+1;\\n\\t\\t\\n        //counting reverse pairs\\n        while(i<=m && j<=h){\\n            long long t=2*(long(nums[j]));\\n            while(i<=m && nums[i]<=t)i++;\\n            ans+=(m-i+1);\\n            j++;\\n        }\\n\\t\\t\\n\\t\\t//sorting array\\n        i=l,j=m+1;\\n        while(i<=m && j<=h){\\n            if(nums[i]<=nums[j])v.push_back(nums[i++]);\\n            else v.push_back(nums[j++]);\\n        }\\n        while(i<=m)v.push_back(nums[i++]);\\n        while(j<=h)v.push_back(nums[j++]);\\n        for(int x=l,k=0;x<=h;x++,k++){\\n            nums[x]=v[k];\\n        }\\n        \\n    }\\n    \\n    void mergeSort(vector<int>& nums,int l,int h){\\n        if(l>=h)return;\\n        int m=(l+h)/2;\\n        mergeSort(nums,l,m);\\n        mergeSort(nums,m+1,h);\\n        merge(nums,l,m,h);\\n        \\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195228,
                "title": "c-fastest-solution-striver-best-approach",
                "content": "class Solution {\\npublic: \\n    int res =0 ;\\n    void mergesort(vector<int>& nums, int l, int mid, int h){\\n        int i= l;\\n        int j= mid+1;\\n        while(i<=mid && j<=h){\\n            long long temp = nums[j];\\n            if(nums[i]>2*temp) {\\n                res+=mid-i+1;\\n                j++;\\n            }\\n            else i++;\\n        }\\n        sort(nums.begin()+l, nums.begin()+h+1);\\n    }\\n    \\n    void merge(vector<int>& nums, int l, int h){\\n        if(l>=h) return;\\n        int mid = (l+h)/2;\\n        merge(nums, l, mid);\\n        merge(nums, mid+1, h);\\n        mergesort(nums, l, mid, h);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        \\n        merge(nums, 0, nums.size()-1);\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "class Solution {\\npublic: \\n    int res =0 ;\\n    void mergesort(vector<int>& nums, int l, int mid, int h){\\n        int i= l;\\n        int j= mid+1;\\n        while(i<=mid && j<=h){\\n            long long temp = nums[j];\\n            if(nums[i]>2*temp) {\\n                res+=mid-i+1;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2125831,
                "title": "c-merge-sort-explanation",
                "content": "# **Idea Explanation**:\\n**TC-> O(nlogn) + O(n) + O(n)\\nSC-> O(n)**\\n\\n![image](https://assets.leetcode.com/users/images/50f4da4f-d873-4f19-9878-492fcb4847ed_1654677000.132809.png)\\n![image](https://assets.leetcode.com/users/images/b360433a-86e3-41c6-8dc4-cc550fd2dc4b_1654676951.0544033.png)\\n![image](https://assets.leetcode.com/users/images/dfbce976-ea67-4448-9058-7adb33eb7c41_1654677030.4085531.png)\\n\\n\\n# **Implementation**:\\n\\n```\\nclass Solution {\\npublic:\\n    int merge(vector<int> &nums, int low, int mid, int high)\\n    {\\n        int count = 0;\\n        int j = mid+1;\\n        for(int i = low; i <= mid; i++)\\n        {\\n            while(j <= high && nums[i] > 2L * nums[j])\\n                j++;\\n            count += (j-(mid+1));\\n        }\\n        \\n    \\n        // perform merge\\n        vector<int> temp;\\n        int left = low, right = mid+1;\\n        while(left <= mid && right <= high)\\n        {\\n            if(nums[left] <= nums[right])\\n                temp.push_back(nums[left++]);\\n            else\\n                temp.push_back(nums[right++]);\\n        }\\n\\n        while(left <= mid)\\n            temp.push_back(nums[left++]);\\n\\n        while(right <= high)\\n            temp.push_back(nums[right++]);\\n        \\n        for(int i = low; i <= high; i++)\\n            nums[i] = temp[i-low];\\n        \\n        return count;\\n    }\\n    \\n    int mergeSort(vector<int> &nums, int low, int high)\\n    {\\n        if(low >= high) return 0;\\n        int mid = (low + high)/2;\\n        int val = mergeSort(nums, low, mid);\\n        val += mergeSort(nums, mid+1, high);\\n        val += merge(nums, low, mid, high);\\n        return val;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums, 0, nums.size()-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int merge(vector<int> &nums, int low, int mid, int high)\\n    {\\n        int count = 0;\\n        int j = mid+1;\\n        for(int i = low; i <= mid; i++)\\n        {\\n            while(j <= high && nums[i] > 2L * nums[j])\\n                j++;\\n            count += (j-(mid+1));\\n        }\\n        \\n    \\n        // perform merge\\n        vector<int> temp;\\n        int left = low, right = mid+1;\\n        while(left <= mid && right <= high)\\n        {\\n            if(nums[left] <= nums[right])\\n                temp.push_back(nums[left++]);\\n            else\\n                temp.push_back(nums[right++]);\\n        }\\n\\n        while(left <= mid)\\n            temp.push_back(nums[left++]);\\n\\n        while(right <= high)\\n            temp.push_back(nums[right++]);\\n        \\n        for(int i = low; i <= high; i++)\\n            nums[i] = temp[i-low];\\n        \\n        return count;\\n    }\\n    \\n    int mergeSort(vector<int> &nums, int low, int high)\\n    {\\n        if(low >= high) return 0;\\n        int mid = (low + high)/2;\\n        int val = mergeSort(nums, low, mid);\\n        val += mergeSort(nums, mid+1, high);\\n        val += merge(nums, low, mid, high);\\n        return val;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums, 0, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759707,
                "title": "python-solution-using-bisect-faster-than-80",
                "content": "```\\nimport bisect\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\n        temp = []\\n        count = 0\\n        \\n        for i in range(len(nums)) :\\n            \\n            count += len(temp)-bisect.bisect_right(temp, 2*nums[i])\\n            bisect.insort(temp, nums[i])\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\n        temp = []\\n        count = 0\\n        \\n        for i in range(len(nums)) :\\n            \\n            count += len(temp)-bisect.bisect_right(temp, 2*nums[i])\\n            bisect.insort(temp, nums[i])\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400821,
                "title": "python-easy-merge-sort-binary-search-inversion-count-idea-sr",
                "content": "**PLEASE DO UPVOTE**\\n```\\nimport math\\nclass Solution:\\n    # TIME n*(logn)*(logn)\\n    def floor(self, li, key):\\n        i,j = 0, len(li)-1\\n        pos = -1\\n        while i <= j:\\n            mid = (i+j)//2\\n            if li[mid] < key:\\n                pos = mid\\n                i = mid+1\\n            else:\\n                j = mid-1\\n        return pos\\n    \\n    def merge(self, li, l, m, r):\\n        L, R,n1,n2 = [],[], m-l+1, r-m\\n        for i in range(n1):\\n            L.append(li[l+i])\\n        for i in range(n2):\\n            R.append(li[m+1+i])\\n        \\n\\t\\t######ANSWER LOGIC#######\\n        for i in range(n1):\\n            key = math.ceil(L[i]/2)\\n            j = self.floor(R, key)\\n            if j!=-1:\\n                self.count += j+1\\n                \\n        ######MERGE LOGIC########\\n        i,j,k=0,0,l        \\n        while i<n1 and j<n2:\\n            if L[i] <= R[j]:\\n                li[k] = L[i]\\n                i+=1\\n            else:\\n                li[k] = R[j]\\n                j+=1\\n            k+=1\\n        while i<n1:\\n            li[k] = L[i]\\n            i+=1\\n            k+=1\\n        while j<n2:\\n            li[k] = R[j]\\n            j+=1\\n            k+=1\\n    \\n    def merge_sort(self, li, i, j):\\n        if i < j:\\n            m = (i+j)//2\\n            self.merge_sort(li,i, m)\\n            self.merge_sort(li,m+1,j)\\n            self.merge(li, i, m, j)\\n              \\n    \\n    def reversePairs(self, nums: List[int]) -> int:\\n        #couting inversion logic\\n        self.count = 0\\n        self.merge_sort(nums, 0, len(nums)-1)\\n        return self.count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    # TIME n*(logn)*(logn)\\n    def floor(self, li, key):\\n        i,j = 0, len(li)-1\\n        pos = -1\\n        while i <= j:\\n            mid = (i+j)//2\\n            if li[mid] < key:\\n                pos = mid\\n                i = mid+1\\n            else:\\n                j = mid-1\\n        return pos\\n    \\n    def merge(self, li, l, m, r):\\n        L, R,n1,n2 = [],[], m-l+1, r-m\\n        for i in range(n1):\\n            L.append(li[l+i])\\n        for i in range(n2):\\n            R.append(li[m+1+i])\\n        \\n\\t\\t######ANSWER LOGIC#######\\n        for i in range(n1):\\n            key = math.ceil(L[i]/2)\\n            j = self.floor(R, key)\\n            if j!=-1:\\n                self.count += j+1\\n                \\n        ######MERGE LOGIC########\\n        i,j,k=0,0,l        \\n        while i<n1 and j<n2:\\n            if L[i] <= R[j]:\\n                li[k] = L[i]\\n                i+=1\\n            else:\\n                li[k] = R[j]\\n                j+=1\\n            k+=1\\n        while i<n1:\\n            li[k] = L[i]\\n            i+=1\\n            k+=1\\n        while j<n2:\\n            li[k] = R[j]\\n            j+=1\\n            k+=1\\n    \\n    def merge_sort(self, li, i, j):\\n        if i < j:\\n            m = (i+j)//2\\n            self.merge_sort(li,i, m)\\n            self.merge_sort(li,m+1,j)\\n            self.merge(li, i, m, j)\\n              \\n    \\n    def reversePairs(self, nums: List[int]) -> int:\\n        #couting inversion logic\\n        self.count = 0\\n        self.merge_sort(nums, 0, len(nums)-1)\\n        return self.count\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1053253,
                "title": "javascript-merge-sort-and-count",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar reversePairs = function(nums) {\\n  let numReversePairs = 0; \\n  helper(nums);\\n  return numReversePairs;\\n  \\n  function helper(nums) {\\n    if (nums.length <= 1) return nums;   \\n    const length = nums.length;\\n    const left = helper(nums.slice(0, Math.floor(length/2)));\\n    const right = helper(nums.slice(Math.floor(length/2)));    \\n    return merge(left, right);    \\n  }\\n  \\n  function merge(left, right) {\\n    const nums_sorted = [];\\n    let leftIndex = 0;\\n    let rightIndex = 0;  \\n    while(leftIndex < left.length && rightIndex < right.length) {\\n      if (left[leftIndex] > 2 * right[rightIndex]) {\\n        numReversePairs += (left.length - leftIndex);\\n        rightIndex++;\\n      } else {\\n        leftIndex++;\\n      }\\n    }    \\n    leftIndex = 0;\\n    rightIndex = 0;\\n    while (leftIndex < left.length && rightIndex < right.length) {\\n      if (left[leftIndex] < right[rightIndex]) {\\n        nums_sorted.push(left[leftIndex]);\\n        leftIndex++;\\n      } else {\\n        let cur = leftIndex;\\n        nums_sorted.push(right[rightIndex]);\\n        rightIndex++;\\n      }\\n    }\\n    while (leftIndex < left.length) {\\n      nums_sorted.push(left[leftIndex]);\\n      leftIndex++;\\n    }\\n    while (rightIndex < right.length) {\\n      nums_sorted.push(right[rightIndex]);\\n      rightIndex++;\\n    }\\n    return nums_sorted;\\n  }\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar reversePairs = function(nums) {\\n  let numReversePairs = 0; \\n  helper(nums);\\n  return numReversePairs;\\n  \\n  function helper(nums) {\\n    if (nums.length <= 1) return nums;   \\n    const length = nums.length;\\n    const left = helper(nums.slice(0, Math.floor(length/2)));\\n    const right = helper(nums.slice(Math.floor(length/2)));    \\n    return merge(left, right);    \\n  }\\n  \\n  function merge(left, right) {\\n    const nums_sorted = [];\\n    let leftIndex = 0;\\n    let rightIndex = 0;  \\n    while(leftIndex < left.length && rightIndex < right.length) {\\n      if (left[leftIndex] > 2 * right[rightIndex]) {\\n        numReversePairs += (left.length - leftIndex);\\n        rightIndex++;\\n      } else {\\n        leftIndex++;\\n      }\\n    }    \\n    leftIndex = 0;\\n    rightIndex = 0;\\n    while (leftIndex < left.length && rightIndex < right.length) {\\n      if (left[leftIndex] < right[rightIndex]) {\\n        nums_sorted.push(left[leftIndex]);\\n        leftIndex++;\\n      } else {\\n        let cur = leftIndex;\\n        nums_sorted.push(right[rightIndex]);\\n        rightIndex++;\\n      }\\n    }\\n    while (leftIndex < left.length) {\\n      nums_sorted.push(left[leftIndex]);\\n      leftIndex++;\\n    }\\n    while (rightIndex < right.length) {\\n      nums_sorted.push(right[rightIndex]);\\n      rightIndex++;\\n    }\\n    return nums_sorted;\\n  }\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441562,
                "title": "python-solution-based-on-divide-and-conquer-with-merge-sort",
                "content": "```\\n#Python feature: type hint\\nfrom typing import List\\n\\n#for python built-in library, bisect   \\nimport bisect\\n\\nclass Solution:\\n\\n    def _merge( self, left_part, right_part ):\\n\\n\\n        merge_list = sorted( left_part + right_part )\\n\\n        return merge_list\\n\\n\\n    def merge_sort_with_rev_pair_count( self, nums: List[int]) -> (List[int], int):\\n        \\n\\n        \\n        if len( nums) <= 1:\\n        # Base case:\\n\\n            return nums, 0\\n\\n        else:\\n        # General case\\n            mid = len(nums) // 2\\n\\n            # Divide-and-conquer with the merge-sort framework\\n\\n            # Divide:\\n            left_part, left_rev_pair_count = self.merge_sort_with_rev_pair_count( nums[ : mid] )\\n            right_part, right_rev_pair_count = self.merge_sort_with_rev_pair_count( nums[ mid: ] )\\n\\n\\n            # Conquer:\\n            # collect the reverse pair count from left part and right part\\n            rev_pair_count = left_rev_pair_count + right_rev_pair_count\\n\\n            cur_rev_pair_count = 0\\n\\n            for r in right_part:\\n                \\n                # for every r in right_part, calculate the reverse pairs\\n                cur_rev_pair_count = len( left_part ) - bisect.bisect( left_part, 2*r)\\n\\n                # if there exist one r has no reverse pairs,\\n                # then any r\\' after r must have no reverse pairs, either.\\n                if cur_rev_pair_count == 0:\\n                    break\\n\\n                # update total reverse pair count from current reverse pair count\\n                rev_pair_count += cur_rev_pair_count\\n\\n            # Conquer:\\n            # Merge left_part and right into a sorted list with ascending order\\n            merged_list = self._merge( left_part, right_part)\\n\\n        return merged_list, rev_pair_count\\n\\n\\n\\n    def is_strictly_increasing_by_one( self, nums :List[int]) -> bool:\\n\\n        result = all( ( i < j and (j-1) == 1 ) for i, j in zip(nums, nums[1:]) ) \\n\\n        return result\\n\\n\\n    def reversePairs( self, nums: List[int]) -> int:\\n\\n        # corner case handling\\n        if self.is_strictly_increasing_by_one( nums ) or len(nums) <= 1:\\n            return 0\\n\\n        sorted_list, count_of_reverse_pair = self.merge_sort_with_rev_pair_count( nums )\\n\\n        return count_of_reverse_pair\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\n#Python feature: type hint\\nfrom typing import List\\n\\n#for python built-in library, bisect   \\nimport bisect\\n\\nclass Solution:\\n\\n    def _merge( self, left_part, right_part ):\\n\\n\\n        merge_list = sorted( left_part + right_part )\\n\\n        return merge_list\\n\\n\\n    def merge_sort_with_rev_pair_count( self, nums: List[int]) -> (List[int], int):\\n        \\n\\n        \\n        if len( nums) <= 1:\\n        # Base case:\\n\\n            return nums, 0\\n\\n        else:\\n        # General case\\n            mid = len(nums) // 2\\n\\n            # Divide-and-conquer with the merge-sort framework\\n\\n            # Divide:\\n            left_part, left_rev_pair_count = self.merge_sort_with_rev_pair_count( nums[ : mid] )\\n            right_part, right_rev_pair_count = self.merge_sort_with_rev_pair_count( nums[ mid: ] )\\n\\n\\n            # Conquer:\\n            # collect the reverse pair count from left part and right part\\n            rev_pair_count = left_rev_pair_count + right_rev_pair_count\\n\\n            cur_rev_pair_count = 0\\n\\n            for r in right_part:\\n                \\n                # for every r in right_part, calculate the reverse pairs\\n                cur_rev_pair_count = len( left_part ) - bisect.bisect( left_part, 2*r)\\n\\n                # if there exist one r has no reverse pairs,\\n                # then any r\\' after r must have no reverse pairs, either.\\n                if cur_rev_pair_count == 0:\\n                    break\\n\\n                # update total reverse pair count from current reverse pair count\\n                rev_pair_count += cur_rev_pair_count\\n\\n            # Conquer:\\n            # Merge left_part and right into a sorted list with ascending order\\n            merged_list = self._merge( left_part, right_part)\\n\\n        return merged_list, rev_pair_count\\n\\n\\n\\n    def is_strictly_increasing_by_one( self, nums :List[int]) -> bool:\\n\\n        result = all( ( i < j and (j-1) == 1 ) for i, j in zip(nums, nums[1:]) ) \\n\\n        return result\\n\\n\\n    def reversePairs( self, nums: List[int]) -> int:\\n\\n        # corner case handling\\n        if self.is_strictly_increasing_by_one( nums ) or len(nums) <= 1:\\n            return 0\\n\\n        sorted_list, count_of_reverse_pair = self.merge_sort_with_rev_pair_count( nums )\\n\\n        return count_of_reverse_pair\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147853,
                "title": "help-there-must-be-something-wrong-with-the-test-case",
                "content": "if I use int type:\\n```\\nint reversePairs(vector<int>& nums) \\n{\\n\\tint len = nums.size();\\n\\tint count = 0;\\n\\tmultiset<int> container;\\n\\tfor(int i=0;i<len;i++)\\n\\t{\\n\\t\\tif(container.size())\\n\\t\\t{\\n\\t\\t\\tif(2*nums[i] >= *(--container.end()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontainer.insert(nums[i]);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} \\n\\t\\t\\tmultiset<int>::iterator it = container.upper_bound(2*nums[i]);\\n\\t\\t\\twhile(it++ != container.end()) count++;\\n\\t\\t}\\n\\t\\tcontainer.insert(nums[i]);\\n\\t}\\n\\treturn count;\\n}\\n```\\nWA:\\n[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]\\nOutput:\\n15\\nExpected:\\n0\\n\\nbut if I use long long type:\\n```\\nint reversePairs(vector<int>& nums) \\n{\\n\\tint len = nums.size();\\n\\tint count = 0;\\n\\tmultiset<long long> container;\\n\\tfor(int i=0;i<len;i++)\\n\\t{\\n\\t\\tif(container.size())\\n\\t\\t{\\n\\t\\t\\tif(2*(long long)nums[i] >= *(--container.end()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontainer.insert(nums[i]);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} \\n\\t\\t\\tmultiset<long long>::iterator it = container.upper_bound(2*nums[i]);\\n\\t\\t\\twhile(it++ != container.end()) count++;\\n\\t\\t}\\n\\t\\tcontainer.insert(nums[i]);\\n\\t}\\n\\treturn count;\\n}\\n```\\nWA:\\n[2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]\\nOutput:\\n6\\nExpected:\\n9\\n\\nWhether the situation that nums overstep the boundary is legal or not is ambigious, what should I do? Please help me  ( >\\uFE4F<\\u3002)\\n",
                "solutionTags": [],
                "code": "```\\nint reversePairs(vector<int>& nums) \\n{\\n\\tint len = nums.size();\\n\\tint count = 0;\\n\\tmultiset<int> container;\\n\\tfor(int i=0;i<len;i++)\\n\\t{\\n\\t\\tif(container.size())\\n\\t\\t{\\n\\t\\t\\tif(2*nums[i] >= *(--container.end()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontainer.insert(nums[i]);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} \\n\\t\\t\\tmultiset<int>::iterator it = container.upper_bound(2*nums[i]);\\n\\t\\t\\twhile(it++ != container.end()) count++;\\n\\t\\t}\\n\\t\\tcontainer.insert(nums[i]);\\n\\t}\\n\\treturn count;\\n}\\n```\n```\\nint reversePairs(vector<int>& nums) \\n{\\n\\tint len = nums.size();\\n\\tint count = 0;\\n\\tmultiset<long long> container;\\n\\tfor(int i=0;i<len;i++)\\n\\t{\\n\\t\\tif(container.size())\\n\\t\\t{\\n\\t\\t\\tif(2*(long long)nums[i] >= *(--container.end()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontainer.insert(nums[i]);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} \\n\\t\\t\\tmultiset<long long>::iterator it = container.upper_bound(2*nums[i]);\\n\\t\\t\\twhile(it++ != container.end()) count++;\\n\\t\\t}\\n\\t\\tcontainer.insert(nums[i]);\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97312,
                "title": "c-solution-using-balanced-binary-search-tree-o-nlgn",
                "content": "Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].\\n\\nScanning the number from left to right, for each number nums[j]\\n1. Search the  tree to find all the numbers nums[i] where nums[i] > 2*nums[j].\\n2. Insert nums[j] to the tree and balance the tree.\\n\\nReference: https://www.cpp.edu/~ftang/courses/CS241/notes/self%20balance%20bst.htm\\n\\n```\\nclass Solution {\\npublic:\\n    struct node{\\n        //count:number of nodes from root itself;  \\n        //self:number of nodes sharing the same val;\\n        //height: tree height\\n        int val,count,height,self;\\n        node* left;\\n        node* right;\\n        node(int k):val(k),count(1),self(1),height(1),left(0),right(0){};\\n        void fix_count_height() { //update count and height\\n            count = self + (left?left->count:0) + (right?right->count:0);\\n            height = 1 + max((left?left->height:0),(right?right->height:0));\\n        }\\n    };\\n    \\n    /*           p                              q            node: p,q\\n               /   \\\\     right rotation       /   \\\\          Tree: A,B,C\\n              q     C    -------------->     A     p\\n            /   \\\\        <--------------         /   \\\\\\n           A     B       left rotation          B     C\\n    */\\n    node* right_rotation(node* p){ // O(1) time complexity\\n        node* q = p->left;       \\n        p->left = q->right;    \\n        q->right = p;          \\n        p->fix_count_height();\\n        q->fix_count_height();\\n        return q; //return new root q after rotation\\n    }\\n    node* left_rotation(node* q){ // O(1) time complexity\\n        node* p = q->right;\\n        q->right = p->left;\\n        p->left = q;\\n        q->fix_count_height();\\n        p->fix_count_height(); \\n        return p; //return new root p after rotation\\n    }\\n    \\n    int bfactor(node* p){ //balance factor = 1,0,-1 are considered balanced from root p \\n        int hr = (p->right) ? p->right->height : 0;\\n        int hl = (p->left) ? p->left->height : 0;\\n        return hr-hl;\\n    }\\n    \\n    //insert k key in a tree from root r, return the new root after insertion\\n    node* insert(node* r, int k){ // O(log(n)) time complexity\\n        if(!r) return new node(k);\\n        if(k < r->val)\\n            r->left = insert(r->left,k);\\n        else if(k > r->val)\\n            r->right = insert(r->right,k);\\n        else{\\n            r->self++;\\n            r->count++;\\n            return r;\\n        }\\n        \\n        //balance the tree if one child's height is greater by 2 than the other child\\n        if(bfactor(r) >= 2){\\n            if(bfactor(r->right) < 0)\\n                r->right = right_rotation(r->right);\\n            return left_rotation(r);\\n        }\\n        else if(bfactor(r) <= -2){\\n            if(bfactor(r->left) > 0)\\n                r->left = left_rotation(r->left);\\n            return right_rotation(r);\\n        }\\n        else{ //no need to rotate the tree, just update the node's count and height \\n            r->fix_count_height();\\n            return r;\\n        }\\n    }\\n    \\n    //search the tree from root, count the nodes n where n->val > key .\\n    int search(const long long key, node* root){ // O(lg(n)) time complexity\\n        if(!root) return 0;\\n        if(root->val < key)\\n            return search(key,root->right);\\n        else if(root->val > key)\\n            return ( root->self + (root->right ? root->right->count : 0) ) + search(key,root->left);\\n        else //root->val == key\\n            return (root->right) ? root->right->count : 0;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size<2)  return 0;\\n        \\n        //Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].\\n        node* root = 0;\\n        root = insert(root,nums[0]);\\n        int count = 0;\\n        for(int j=1; j<size; j++){\\n            int numsj = nums[j];\\n            count += search(2*(long long)numsj,root);\\n            root = insert(root, numsj);\\n        }\\n        return count;\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node{\\n        //count:number of nodes from root itself;  \\n        //self:number of nodes sharing the same val;\\n        //height: tree height\\n        int val,count,height,self;\\n        node* left;\\n        node* right;\\n        node(int k):val(k),count(1),self(1),height(1),left(0),right(0){};\\n        void fix_count_height() { //update count and height\\n            count = self + (left?left->count:0) + (right?right->count:0);\\n            height = 1 + max((left?left->height:0),(right?right->height:0));\\n        }\\n    };\\n    \\n    /*           p                              q            node: p,q\\n               /   \\\\     right rotation       /   \\\\          Tree: A,B,C\\n              q     C    -------------->     A     p\\n            /   \\\\        <--------------         /   \\\\\\n           A     B       left rotation          B     C\\n    */\\n    node* right_rotation(node* p){ // O(1) time complexity\\n        node* q = p->left;       \\n        p->left = q->right;    \\n        q->right = p;          \\n        p->fix_count_height();\\n        q->fix_count_height();\\n        return q; //return new root q after rotation\\n    }\\n    node* left_rotation(node* q){ // O(1) time complexity\\n        node* p = q->right;\\n        q->right = p->left;\\n        p->left = q;\\n        q->fix_count_height();\\n        p->fix_count_height(); \\n        return p; //return new root p after rotation\\n    }\\n    \\n    int bfactor(node* p){ //balance factor = 1,0,-1 are considered balanced from root p \\n        int hr = (p->right) ? p->right->height : 0;\\n        int hl = (p->left) ? p->left->height : 0;\\n        return hr-hl;\\n    }\\n    \\n    //insert k key in a tree from root r, return the new root after insertion\\n    node* insert(node* r, int k){ // O(log(n)) time complexity\\n        if(!r) return new node(k);\\n        if(k < r->val)\\n            r->left = insert(r->left,k);\\n        else if(k > r->val)\\n            r->right = insert(r->right,k);\\n        else{\\n            r->self++;\\n            r->count++;\\n            return r;\\n        }\\n        \\n        //balance the tree if one child's height is greater by 2 than the other child\\n        if(bfactor(r) >= 2){\\n            if(bfactor(r->right) < 0)\\n                r->right = right_rotation(r->right);\\n            return left_rotation(r);\\n        }\\n        else if(bfactor(r) <= -2){\\n            if(bfactor(r->left) > 0)\\n                r->left = left_rotation(r->left);\\n            return right_rotation(r);\\n        }\\n        else{ //no need to rotate the tree, just update the node's count and height \\n            r->fix_count_height();\\n            return r;\\n        }\\n    }\\n    \\n    //search the tree from root, count the nodes n where n->val > key .\\n    int search(const long long key, node* root){ // O(lg(n)) time complexity\\n        if(!root) return 0;\\n        if(root->val < key)\\n            return search(key,root->right);\\n        else if(root->val > key)\\n            return ( root->self + (root->right ? root->right->count : 0) ) + search(key,root->left);\\n        else //root->val == key\\n            return (root->right) ? root->right->count : 0;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size<2)  return 0;\\n        \\n        //Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].\\n        node* root = 0;\\n        root = insert(root,nums[0]);\\n        int count = 0;\\n        for(int j=1; j<size; j++){\\n            int numsj = nums[j];\\n            count += search(2*(long long)numsj,root);\\n            root = insert(root, numsj);\\n        }\\n        return count;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018747,
                "title": "easy-fenwicktree-for-newbie",
                "content": "Example:\\n```cpp\\nvector<int> nums = {2, 4, 3, 5, 1};\\n```\\n\\nHere\\'s a step-by-step explanation of how the code processes this input:\\n\\n1. **Initialization**:\\n   - `nums2` is created by doubling each element in `nums`:\\n     ```\\n     nums2 = {4, 8, 6, 10, 2}\\n     ```\\n   - The `sorted` set is created by combining `nums` and `nums2`, removing duplicates, and sorting it:\\n     ```\\n     sorted = {1, 2, 3, 4, 5, 6, 8, 10}\\n     ```\\n   - The `ranks` map is created to map each element in `sorted` to its rank:\\n     ```\\n     ranks = {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 8: 7, 10: 8}\\n     ```\\n\\n2. **FenwickTree Initialization**:\\n   - A `FenwickTree` is created with a size equal to the number of distinct elements in `sorted`, which is 8.\\n\\n3. **Iterating Over `nums2` (from right to left)**:\\n   - Starting with the last element in `nums2`:\\n     - For `nums2[4]` which is 2, we find how many elements in `nums` are smaller than half of it (1):\\n       - `tree.query(ranks[1/2] - 1)`: This is equivalent to `tree.query(0)` because ranks[1/2] is 1, so we query the FenwickTree up to index 0, which returns 0.\\n       - `tree.update(ranks[2], 1)`: We update the FenwickTree at index 2 by adding 1.\\n\\n   - Moving to the next element:\\n     - For `nums2[3]` which is 10, we find how many elements in `nums` are smaller than half of it (5):\\n       - `tree.query(ranks[5/2] - 1)`: This is equivalent to `tree.query(1)` because ranks[5/2] is 2, so we query the FenwickTree up to index 1, which returns 1.\\n       - `tree.update(ranks[10], 1)`: We update the FenwickTree at index 8 by adding 1.\\n\\n   - Continuing this process for the remaining elements in `nums2`:\\n\\n4. **Calculating the Result**:\\n   - The total count of reverse pairs is the cumulative sum of the results obtained in step 3:\\n     - `0 + 1 + 1 + 1 + 2 = 5`\\n\\n5. **Return**:\\n   - The function returns 5, which is the count of reverse pairs in the input array `{2, 4, 3, 5, 1}`.\\n\\nSo, in this example, there are 5 reverse pairs in the input array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n#include<vector>\\nusing namespace std;\\n\\n\\nclass FenwickTree{\\n    public:\\n    FenwickTree(int n): sums(n+1,0){};\\n\\n    void update(int i , int del){\\n        while(i < sums.size()){\\n            sums[i] += del;\\n            i += lowbit(i); // this means we are going to the child node\\n        }\\n    }\\n\\n    int query(int i){\\n        int sum = 0;\\n        while(i > 0){\\n            sum += sums[i];\\n            i -= lowbit(i); // this means we are going to the parent node \\n        }\\n        return sum;\\n    }\\n    private:\\n        vector<int>sums;\\n        static inline int lowbit(int x){\\n            return x & (-x); // 2^k\\n        }   \\n};\\n\\nclass Solution\\n{\\npublic:\\n    int reversePairs(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        if(!n) return 0;\\n        vector<long>temp;\\n        for(long num : nums){\\n            temp.push_back(2*num);\\n        }\\n        set<long>sorted;\\n        sorted.insert(nums.begin() , nums.end());\\n        sorted.insert(temp.begin(),temp.end());\\n\\n\\n        int rank=0;\\n        unordered_map<long,int>ranks;\\n\\n        for (long num : sorted){\\n            ranks[num] = ++rank;\\n        }\\n\\n        FenwickTree Fn(ranks.size());\\n\\n        int ans = 0;\\n        int k = temp.size();\\n        for(int i = static_cast<int>(k)-1; i>=0;i--){\\n            ans+=Fn.query(ranks[temp[i] / 2] -1);\\n            Fn.update(ranks[temp[i]],1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n```python []\\nclass FenwickTree:\\n    def __init__(self, n):\\n        self.sums = [0] * (n + 1)\\n\\n    def update(self, i, delta):\\n        while i < len(self.sums):\\n            self.sums[i] += delta\\n            i += self.lowbit(i)  # Move to the child node\\n\\n    def query(self, i):\\n        total = 0\\n        while i > 0:\\n            total += self.sums[i]\\n            i -= self.lowbit(i)  # Move to the parent node\\n        return total\\n\\n    @staticmethod\\n    def lowbit(x):\\n        return x & (-x)  # Equivalent to 2^k, where k is the position of the lowest set bit\\n\\n\\nclass Solution:\\n    def reversePairs(self, nums):\\n        n = len(nums)\\n        if n == 0:\\n            return 0\\n\\n        doubled_nums = [2 * num for num in nums]\\n        sorted_set = sorted(set(nums).union(set(doubled_nums)))\\n\\n        rank = 0\\n        ranks = {}\\n\\n        for num in sorted_set:\\n            rank += 1\\n            ranks[num] = rank\\n\\n        tree = FenwickTree(len(ranks))\\n\\n        reverse_pairs_count = 0\\n        k = len(doubled_nums)\\n        for i in range(k - 1, -1, -1):\\n            reverse_pairs_count += tree.query(ranks[doubled_nums[i] // 2] - 1)\\n            tree.update(ranks[doubled_nums[i]], 1)\\n\\n        return reverse_pairs_count\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Indexed Tree"
                ],
                "code": "```cpp\\nvector<int> nums = {2, 4, 3, 5, 1};\\n```\n```\\n     nums2 = {4, 8, 6, 10, 2}\\n     ```\n```\\n     sorted = {1, 2, 3, 4, 5, 6, 8, 10}\\n     ```\n```\\n     ranks = {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 8: 7, 10: 8}\\n     ```\n```\\n#include <bits/stdc++.h>\\n#include<vector>\\nusing namespace std;\\n\\n\\nclass FenwickTree{\\n    public:\\n    FenwickTree(int n): sums(n+1,0){};\\n\\n    void update(int i , int del){\\n        while(i < sums.size()){\\n            sums[i] += del;\\n            i += lowbit(i); // this means we are going to the child node\\n        }\\n    }\\n\\n    int query(int i){\\n        int sum = 0;\\n        while(i > 0){\\n            sum += sums[i];\\n            i -= lowbit(i); // this means we are going to the parent node \\n        }\\n        return sum;\\n    }\\n    private:\\n        vector<int>sums;\\n        static inline int lowbit(int x){\\n            return x & (-x); // 2^k\\n        }   \\n};\\n\\nclass Solution\\n{\\npublic:\\n    int reversePairs(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        if(!n) return 0;\\n        vector<long>temp;\\n        for(long num : nums){\\n            temp.push_back(2*num);\\n        }\\n        set<long>sorted;\\n        sorted.insert(nums.begin() , nums.end());\\n        sorted.insert(temp.begin(),temp.end());\\n\\n\\n        int rank=0;\\n        unordered_map<long,int>ranks;\\n\\n        for (long num : sorted){\\n            ranks[num] = ++rank;\\n        }\\n\\n        FenwickTree Fn(ranks.size());\\n\\n        int ans = 0;\\n        int k = temp.size();\\n        for(int i = static_cast<int>(k)-1; i>=0;i--){\\n            ans+=Fn.query(ranks[temp[i] / 2] -1);\\n            Fn.update(ranks[temp[i]],1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass FenwickTree:\\n    def __init__(self, n):\\n        self.sums = [0] * (n + 1)\\n\\n    def update(self, i, delta):\\n        while i < len(self.sums):\\n            self.sums[i] += delta\\n            i += self.lowbit(i)  # Move to the child node\\n\\n    def query(self, i):\\n        total = 0\\n        while i > 0:\\n            total += self.sums[i]\\n            i -= self.lowbit(i)  # Move to the parent node\\n        return total\\n\\n    @staticmethod\\n    def lowbit(x):\\n        return x & (-x)  # Equivalent to 2^k, where k is the position of the lowest set bit\\n\\n\\nclass Solution:\\n    def reversePairs(self, nums):\\n        n = len(nums)\\n        if n == 0:\\n            return 0\\n\\n        doubled_nums = [2 * num for num in nums]\\n        sorted_set = sorted(set(nums).union(set(doubled_nums)))\\n\\n        rank = 0\\n        ranks = {}\\n\\n        for num in sorted_set:\\n            rank += 1\\n            ranks[num] = rank\\n\\n        tree = FenwickTree(len(ranks))\\n\\n        reverse_pairs_count = 0\\n        k = len(doubled_nums)\\n        for i in range(k - 1, -1, -1):\\n            reverse_pairs_count += tree.query(ranks[doubled_nums[i] // 2] - 1)\\n            tree.update(ranks[doubled_nums[i]], 1)\\n\\n        return reverse_pairs_count\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3841817,
                "title": "most-optimal-solution-using-merge-sort-c-and-java-code",
                "content": "\\n\\n# Approach\\nThis solution uses the merge sort algorithm to efficiently count the number of reverse pairs in an integer array nums. A reverse pair is defined as a pair (i, j) where i < j and nums[i] > 2 * nums[j].\\n\\nThe mergeSort function recursively divides the array into smaller subarrays, sorts them using the merge function, and counts the number of reverse pairs using the countPairs function. The countPairs function efficiently calculates the reverse pairs in the merged subarrays using a two-pointer technique.\\n\\nTo handle potential overflow when comparing 2 * nums[j] with nums[i], the code uses a long long data type for the comparison, ensuring that larger integer values are correctly handled.\\n\\nBy employing merge sort and efficiently counting the reverse pairs during the merging process, the algorithm achieves a time complexity of O(n log n) to find the total number of reverse pairs in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(2nlog(n))\\n\\n- Space complexity:\\nO(n) (Distorting the array)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &arr, int low, int mid, int high) {\\n        vector<int> temp; \\n        int left = low;      \\n        int right = mid + 1;  \\n        while (left <= mid && right <= high) {\\n            if (arr[left] <= arr[right]) {\\n                temp.push_back(arr[left]);\\n                left++;\\n            }\\n            else {\\n                temp.push_back(arr[right]);\\n                right++;\\n            }\\n        }\\n        while (left <= mid) {\\n            temp.push_back(arr[left]);\\n            left++;\\n        }\\n        while (right <= high) {\\n            temp.push_back(arr[right]);\\n            right++;\\n        }\\n        for (int i = low; i <= high; i++) {\\n            arr[i] = temp[i - low];\\n        }\\n    }\\n\\n    int countPairs(vector<int> &arr, int low, int mid, int high) {\\n        int right = mid + 1;\\n        int cnt = 0;\\n        for (int i = low; i <= mid; i++) {\\n            while (right <= high && arr[i] > 2LL * arr[right]) \\n                right++;\\n            cnt += (right - (mid + 1));\\n        }\\n        return cnt;\\n    }\\n\\n    int mergeSort(vector<int> &arr, int low, int high) {\\n        int cnt = 0;\\n        if (low >= high) return cnt;\\n        int mid = (low + high) / 2 ;\\n        cnt += mergeSort(arr, low, mid);  \\n        cnt += mergeSort(arr, mid + 1, high); \\n        cnt += countPairs(arr, low, mid, high);\\n        merge(arr, low, mid, high);  \\n        return cnt;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        return mergeSort(nums, 0, n - 1);\\n    }\\n};\\n\\n```\\n# JAVA Code\\n```\\npublic class Solution {\\n\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length - 1);\\n    }\\n\\n    private int mergeSort(int[] arr, int low, int high) {\\n        int cnt = 0;\\n        if (low >= high) return cnt;\\n        int mid = (low + high) / 2;\\n        cnt += mergeSort(arr, low, mid);\\n        cnt += mergeSort(arr, mid + 1, high);\\n        cnt += countPairs(arr, low, mid, high);\\n        merge(arr, low, mid, high);\\n        return cnt;\\n    }\\n\\n    private void merge(int[] arr, int low, int mid, int high) {\\n        int[] temp = new int[high - low + 1];\\n        int left = low;\\n        int right = mid + 1;\\n        int index = 0;\\n\\n        while (left <= mid && right <= high) {\\n            if (arr[left] <= arr[right]) {\\n                temp[index++] = arr[left++];\\n            } else {\\n                temp[index++] = arr[right++];\\n            }\\n        }\\n\\n        while (left <= mid) {\\n            temp[index++] = arr[left++];\\n        }\\n\\n        while (right <= high) {\\n            temp[index++] = arr[right++];\\n        }\\n\\n        System.arraycopy(temp, 0, arr, low, temp.length);\\n    }\\n\\n    private int countPairs(int[] arr, int low, int mid, int high) {\\n        int right = mid + 1;\\n        int cnt = 0;\\n        for (int i = low; i <= mid; i++) {\\n            while (right <= high && (long) arr[i] > 2L * arr[right]) {\\n                right++;\\n            }\\n            cnt += (right - (mid + 1));\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Divide and Conquer",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &arr, int low, int mid, int high) {\\n        vector<int> temp; \\n        int left = low;      \\n        int right = mid + 1;  \\n        while (left <= mid && right <= high) {\\n            if (arr[left] <= arr[right]) {\\n                temp.push_back(arr[left]);\\n                left++;\\n            }\\n            else {\\n                temp.push_back(arr[right]);\\n                right++;\\n            }\\n        }\\n        while (left <= mid) {\\n            temp.push_back(arr[left]);\\n            left++;\\n        }\\n        while (right <= high) {\\n            temp.push_back(arr[right]);\\n            right++;\\n        }\\n        for (int i = low; i <= high; i++) {\\n            arr[i] = temp[i - low];\\n        }\\n    }\\n\\n    int countPairs(vector<int> &arr, int low, int mid, int high) {\\n        int right = mid + 1;\\n        int cnt = 0;\\n        for (int i = low; i <= mid; i++) {\\n            while (right <= high && arr[i] > 2LL * arr[right]) \\n                right++;\\n            cnt += (right - (mid + 1));\\n        }\\n        return cnt;\\n    }\\n\\n    int mergeSort(vector<int> &arr, int low, int high) {\\n        int cnt = 0;\\n        if (low >= high) return cnt;\\n        int mid = (low + high) / 2 ;\\n        cnt += mergeSort(arr, low, mid);  \\n        cnt += mergeSort(arr, mid + 1, high); \\n        cnt += countPairs(arr, low, mid, high);\\n        merge(arr, low, mid, high);  \\n        return cnt;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        return mergeSort(nums, 0, n - 1);\\n    }\\n};\\n\\n```\n```\\npublic class Solution {\\n\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length - 1);\\n    }\\n\\n    private int mergeSort(int[] arr, int low, int high) {\\n        int cnt = 0;\\n        if (low >= high) return cnt;\\n        int mid = (low + high) / 2;\\n        cnt += mergeSort(arr, low, mid);\\n        cnt += mergeSort(arr, mid + 1, high);\\n        cnt += countPairs(arr, low, mid, high);\\n        merge(arr, low, mid, high);\\n        return cnt;\\n    }\\n\\n    private void merge(int[] arr, int low, int mid, int high) {\\n        int[] temp = new int[high - low + 1];\\n        int left = low;\\n        int right = mid + 1;\\n        int index = 0;\\n\\n        while (left <= mid && right <= high) {\\n            if (arr[left] <= arr[right]) {\\n                temp[index++] = arr[left++];\\n            } else {\\n                temp[index++] = arr[right++];\\n            }\\n        }\\n\\n        while (left <= mid) {\\n            temp[index++] = arr[left++];\\n        }\\n\\n        while (right <= high) {\\n            temp[index++] = arr[right++];\\n        }\\n\\n        System.arraycopy(temp, 0, arr, low, temp.length);\\n    }\\n\\n    private int countPairs(int[] arr, int low, int mid, int high) {\\n        int right = mid + 1;\\n        int cnt = 0;\\n        for (int i = low; i <= mid; i++) {\\n            while (right <= high && (long) arr[i] > 2L * arr[right]) {\\n                right++;\\n            }\\n            cnt += (right - (mid + 1));\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834181,
                "title": "easy-cpp-detailed-solution-explained-stepwise-merge-sort",
                "content": "\\n# Approach\\n1. Initialize a global variable `answer` to keep track of the number of reverse pairs.\\n\\n2. Define a function `merge` that takes in a vector `a`, and three integer parameters `low`, `mid`, and `high`. This function is responsible for merging two sorted subarrays and counting the number of reverse pairs.\\n\\n3. Inside the `merge` function, initialize two pointers `i` and `j` to `low` and `mid+1` respectively, representing the start of the two subarrays.\\n\\n4. Iterate through the two subarrays using the pointers `i` and `j` while comparing elements to find the reverse pairs. If `(a[i] > 2 * a[j])`, it means there\\'s a reverse pair, and we update the `answer` by adding `(mid - i + 1)` to it. Then, increment `j`.\\n\\n5. Merge the two sorted subarrays into a temporary vector `b` by comparing elements and pushing them in ascending order.\\n\\n6. Copy the elements from `b` back to the original vector `a` to complete the merge step.\\n\\n7. Define another function `mergeSort` that takes in a vector `a`, and two integer parameters `low` and `high`. This function is responsible for dividing the array into smaller subarrays and sorting them.\\n\\n8. Inside the `mergeSort` function, check if `low` is equal to `high`, which indicates a single element subarray, and return if it is.\\n\\n9. Calculate the middle index `mid` as `(low + high) / 2`.\\n\\n10. Recursively call `mergeSort` on the left and right subarrays by passing `low`, `mid`, and `mid+1`, `high` respectively.\\n\\n11. After the recursive calls, call the `merge` function to merge and sort the two subarrays.\\n\\n12. Finally, define the `reversePairs` function that takes in a vector `nums` as input.\\n\\n13. Call the `mergeSort` function with the initial values `low = 0` and `high = nums.size() - 1` to sort the vector and count the reverse pairs.\\n\\n14. Return the value of `answer`, which represents the total number of reverse pairs in the vector.\\n\\n# Complexity\\n- Time complexity:\\n   - O(n logn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint answer=0;\\n    void merge(vector<int>&a,int low,int mid,int high)\\n    {\\n        int i=low,j=mid+1;\\n        while(i<=mid && j<=high)\\n        {\\n            if((long long int)a[i]>(long long int)2*a[j])\\n            {\\n                answer+=mid-i+1;\\n                j++;\\n            }  \\n            else i++;\\n        }\\n       i=low,j=mid+1;\\n       vector<int>b;\\n       while(i<=mid && j<=high)\\n       {\\n            if(a[i]<a[j])b.push_back(a[i++]);\\n            else b.push_back(a[j++]);           \\n       }\\n       while(i<=mid)b.push_back(a[i++]);\\n       while(j<=high)b.push_back(a[j++]);\\n       for(int i=low;i<=high;i++)a[i]=b[i-low];\\n    }\\n    void mergeSort(vector<int>&a,int low,int high)\\n    {\\n        if(low==high) return ;\\n        int mid=(low+high)/2;\\n\\n        mergeSort(a,low,mid);\\n        mergeSort(a,mid+1,high);\\n        merge(a,low,mid,high);\\n\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n    mergeSort(nums,0,nums.size()-1);\\n    return answer;\\n    }\\n};\\n```\\n# Please upvote and feel free to ask doubts",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint answer=0;\\n    void merge(vector<int>&a,int low,int mid,int high)\\n    {\\n        int i=low,j=mid+1;\\n        while(i<=mid && j<=high)\\n        {\\n            if((long long int)a[i]>(long long int)2*a[j])\\n            {\\n                answer+=mid-i+1;\\n                j++;\\n            }  \\n            else i++;\\n        }\\n       i=low,j=mid+1;\\n       vector<int>b;\\n       while(i<=mid && j<=high)\\n       {\\n            if(a[i]<a[j])b.push_back(a[i++]);\\n            else b.push_back(a[j++]);           \\n       }\\n       while(i<=mid)b.push_back(a[i++]);\\n       while(j<=high)b.push_back(a[j++]);\\n       for(int i=low;i<=high;i++)a[i]=b[i-low];\\n    }\\n    void mergeSort(vector<int>&a,int low,int high)\\n    {\\n        if(low==high) return ;\\n        int mid=(low+high)/2;\\n\\n        mergeSort(a,low,mid);\\n        mergeSort(a,mid+1,high);\\n        merge(a,low,mid,high);\\n\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n    mergeSort(nums,0,nums.size()-1);\\n    return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050684,
                "title": "easily-understandable-java-sol-using-merge-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile running merge sort keep count of number of times the given condition is being met.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Merge Sort\\n\\n# Complexity\\n- Time complexity:O(n logn) + O(n) + O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int merge(int[] nums,int low,int mid, int high){\\n        int count=0;\\n        int j = mid+1;\\n        for(int i=low;i<=mid;i++){\\n            while(j<=high && nums[i]>(2*(long)nums[j])){\\n                j++;\\n            }count+=j-(mid+1);\\n        }\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        int left = low,right = mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                temp.add(nums[left++]);\\n            }\\n            else{\\n                temp.add(nums[right++]);\\n            }\\n        }\\n            while(left<=mid){\\n                temp.add(nums[left++]);\\n            }\\n            while(right<=high){\\n                temp.add(nums[right++]);\\n            }\\n            for(int i=low;i<=high;i++){\\n                nums[i] = temp.get(i-low);\\n            }\\n         return count;\\n    }\\n\\n    int mergeSort(int[] nums,int low,int high){\\n        if(low>=high)  return 0;\\n        int mid = (low+high)/2;\\n        int inv = mergeSort(nums,low,mid);\\n        inv+= mergeSort(nums,mid+1,high);\\n        inv+= merge(nums,low,mid,high);\\n        return inv;\\n    }\\n    \\n    public int reversePairs(int[] nums) {\\n       return mergeSort(nums,0,nums.length-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int merge(int[] nums,int low,int mid, int high){\\n        int count=0;\\n        int j = mid+1;\\n        for(int i=low;i<=mid;i++){\\n            while(j<=high && nums[i]>(2*(long)nums[j])){\\n                j++;\\n            }count+=j-(mid+1);\\n        }\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        int left = low,right = mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                temp.add(nums[left++]);\\n            }\\n            else{\\n                temp.add(nums[right++]);\\n            }\\n        }\\n            while(left<=mid){\\n                temp.add(nums[left++]);\\n            }\\n            while(right<=high){\\n                temp.add(nums[right++]);\\n            }\\n            for(int i=low;i<=high;i++){\\n                nums[i] = temp.get(i-low);\\n            }\\n         return count;\\n    }\\n\\n    int mergeSort(int[] nums,int low,int high){\\n        if(low>=high)  return 0;\\n        int mid = (low+high)/2;\\n        int inv = mergeSort(nums,low,mid);\\n        inv+= mergeSort(nums,mid+1,high);\\n        inv+= merge(nums,low,mid,high);\\n        return inv;\\n    }\\n    \\n    public int reversePairs(int[] nums) {\\n       return mergeSort(nums,0,nums.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954910,
                "title": "merge-sort-simple-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n   int merge(vector<int>& arr, int lo, int mid, int hi)\\n    {\\n        vector<int> temp(hi-lo+1);\\n        int i=lo,j=mid+1,k=0;\\n        int count=0;\\n        \\n        while(i<=mid&&j<=hi)\\n        {\\n            if(arr[i]<= 2LL*arr[j])\\n            {\\n                temp[k++] = arr[i++];\\n            }\\n            else\\n            {\\n                temp[k++] = arr[j++];\\n                count+=(mid-i+1);\\n            }\\n        }\\n        \\n        while(i<=mid)\\n        temp[k++] = arr[i++];\\n        \\n        while(j<=hi)\\n        temp[k++] = arr[j++];\\n        \\n        sort(temp.begin(), temp.end());\\n        for(int i=lo;i<=hi;i++)\\n        {\\n            arr[i] = temp[i-lo];\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    int  mergeSort(vector<int>& arr, int low, int high)\\n    {\\n        int count=0;\\n        if(low<high)\\n        {\\n            int mid = (low+high)/2;\\n            count += mergeSort(arr, low, mid);\\n            count += mergeSort(arr, mid+1, high);\\n            count += merge(arr, low, mid, high);\\n        }\\n        return count;\\n    }\\n     int reversePairs(vector<int>& arr)\\n    {\\n        // Your Code Here\\n        return mergeSort(arr, 0, arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int merge(vector<int>& arr, int lo, int mid, int hi)\\n    {\\n        vector<int> temp(hi-lo+1);\\n        int i=lo,j=mid+1,k=0;\\n        int count=0;\\n        \\n        while(i<=mid&&j<=hi)\\n        {\\n            if(arr[i]<= 2LL*arr[j])\\n            {\\n                temp[k++] = arr[i++];\\n            }\\n            else\\n            {\\n                temp[k++] = arr[j++];\\n                count+=(mid-i+1);\\n            }\\n        }\\n        \\n        while(i<=mid)\\n        temp[k++] = arr[i++];\\n        \\n        while(j<=hi)\\n        temp[k++] = arr[j++];\\n        \\n        sort(temp.begin(), temp.end());\\n        for(int i=lo;i<=hi;i++)\\n        {\\n            arr[i] = temp[i-lo];\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    int  mergeSort(vector<int>& arr, int low, int high)\\n    {\\n        int count=0;\\n        if(low<high)\\n        {\\n            int mid = (low+high)/2;\\n            count += mergeSort(arr, low, mid);\\n            count += mergeSort(arr, mid+1, high);\\n            count += merge(arr, low, mid, high);\\n        }\\n        return count;\\n    }\\n     int reversePairs(vector<int>& arr)\\n    {\\n        // Your Code Here\\n        return mergeSort(arr, 0, arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941318,
                "title": "segment-tree-nlogn-faster-than-69",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> A;\\n    long long tree[20*10001],huy,ans=0,n;\\n    long long BinarySearch(int low,int high,long long  target)\\n    {\\n        int mid;\\n        if(A[high].first<=target) return -1;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(A[mid].first>target&&(mid==0||A[mid-1].first<=target))\\n            {\\n                return mid;\\n            }\\n            if(A[mid].first>target) high=mid-1;\\n            if(A[mid].first<=target) low=mid+1;\\n        }\\n        return -1;\\n    }\\n    void Update(int id,int l,int r,int x)\\n    {\\n        if(l>x||r<x) return;\\n        if(l==r)\\n        {\\n            tree[id]++;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        Update(id*2,l,mid,x);\\n        Update(id*2+1,mid+1,r,x);\\n        tree[id]=tree[id*2]+tree[id*2+1];\\n    }\\n    int Query(int id,int l,int r,int x,int y)\\n    {\\n        if(l>y||r<x) return 0;\\n        if(l>=x&&r<=y) return tree[id];\\n        int mid=(l+r)/2;\\n        return Query(id*2,l,mid,x,y)+Query(id*2+1,mid+1,r,x,y);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        vector<int> picaro(nums.size());\\n        for(int i=0;i<=nums.size()-1;i++)\\n            A.push_back(make_pair(nums[i],i));\\n        sort(A.begin(),A.end());\\n        for(int i=0;i<=A.size()-1;i++)\\n            picaro[A[i].second]=i;\\n        for(int i=0;i<=nums.size()-1;i++)\\n        {\\n            if(i==0) Update(1,0,A.size()-1,picaro[i]);\\n            else\\n            {\\n                n=nums[i];\\n                n=n*2;\\n                huy=BinarySearch(0,A.size()-1,n);\\n                if(huy!=-1)\\n                {\\n                    ans=ans+Query(1,0,A.size()-1,huy,A.size()-1);\\n                }\\n                Update(1,0,A.size()-1,picaro[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> A;\\n    long long tree[20*10001],huy,ans=0,n;\\n    long long BinarySearch(int low,int high,long long  target)\\n    {\\n        int mid;\\n        if(A[high].first<=target) return -1;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(A[mid].first>target&&(mid==0||A[mid-1].first<=target))\\n            {\\n                return mid;\\n            }\\n            if(A[mid].first>target) high=mid-1;\\n            if(A[mid].first<=target) low=mid+1;\\n        }\\n        return -1;\\n    }\\n    void Update(int id,int l,int r,int x)\\n    {\\n        if(l>x||r<x) return;\\n        if(l==r)\\n        {\\n            tree[id]++;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        Update(id*2,l,mid,x);\\n        Update(id*2+1,mid+1,r,x);\\n        tree[id]=tree[id*2]+tree[id*2+1];\\n    }\\n    int Query(int id,int l,int r,int x,int y)\\n    {\\n        if(l>y||r<x) return 0;\\n        if(l>=x&&r<=y) return tree[id];\\n        int mid=(l+r)/2;\\n        return Query(id*2,l,mid,x,y)+Query(id*2+1,mid+1,r,x,y);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        vector<int> picaro(nums.size());\\n        for(int i=0;i<=nums.size()-1;i++)\\n            A.push_back(make_pair(nums[i],i));\\n        sort(A.begin(),A.end());\\n        for(int i=0;i<=A.size()-1;i++)\\n            picaro[A[i].second]=i;\\n        for(int i=0;i<=nums.size()-1;i++)\\n        {\\n            if(i==0) Update(1,0,A.size()-1,picaro[i]);\\n            else\\n            {\\n                n=nums[i];\\n                n=n*2;\\n                huy=BinarySearch(0,A.size()-1,n);\\n                if(huy!=-1)\\n                {\\n                    ans=ans+Query(1,0,A.size()-1,huy,A.size()-1);\\n                }\\n                Update(1,0,A.size()-1,picaro[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399301,
                "title": "c-accepted-merge-sort-best-approach-with-steps-explanation-easy-to-understand",
                "content": "**Approach : Merge Sort**\\n1. We first of all call a Merge Sort function, in that we recursively call Left Recursion and Right Recursion after that we call Merge function in order to merge both Left and Right Calls we initially made and compute the final answer.\\n\\n2. In the Merge function, we will be using low, mid, high values to count the total number of inversion pairs for the Left half and Right half of the Array.\\n\\t1. Now, after the above task, we need to Merge the both Left and Right sub-arrays using a temporary vector.\\n\\t2. After this, we need to copy back the temporary vector to the Original Array. \\n3. Then finally we return the number of pairs we counted.\\n\\n**~Time Complexity : O( N log N ) + O (N) + O (N)**  \\n- **Reason :** O(N) \\u2013 Merge operation , O(N) \\u2013 counting operation ( at each iteration of i , j doesn\\u2019t start from 0 . Both of them move linearly ) \\n\\n**~Space Complexity : O(N)** \\n- **Reason :** O(N) \\u2013 Temporary vector\\n\\n```\\npublic: \\n    int pairCount=0;\\n    void merge(vector<int>& nums,int low,int mid,int high){\\n        int total=0;\\n        int i=low;\\n        int j=mid+1;\\n        \\n        //main Logic\\n        //Basically here we are counting the total number of inversion pairs for the Left half and Right half of the Array.\\n        while(i<=mid){\\n            while(j<=high && nums[i]>(long long)2*nums[j]){\\n                j++;\\n            }\\n            total+=(j-(mid+1));\\n            i++;\\n        }\\n        \\n        vector<int> temp;\\n        i=low;\\n        j=mid+1;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<nums[j]){\\n                temp.push_back(nums[i++]);\\n            }else{\\n                temp.push_back(nums[j++]);\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i++]);\\n        }\\n        \\n        while(j<=high){\\n            temp.push_back(nums[j++]);\\n        }\\n        \\n        for(int it=low;it<=high;it++){\\n            nums[it]=temp[it-low];\\n        }\\n        pairCount+=total;\\n    }\\n    void mergeSort(vector<int>& nums,int low,int high){\\n        if(low<high){\\n            int mid=low+(high-low)/2;\\n            mergeSort(nums,low,mid);\\n            mergeSort(nums,mid+1,high);\\n            merge(nums,low,mid,high);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return pairCount;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\npublic: \\n    int pairCount=0;\\n    void merge(vector<int>& nums,int low,int mid,int high){\\n        int total=0;\\n        int i=low;\\n        int j=mid+1;\\n        \\n        //main Logic\\n        //Basically here we are counting the total number of inversion pairs for the Left half and Right half of the Array.\\n        while(i<=mid){\\n            while(j<=high && nums[i]>(long long)2*nums[j]){\\n                j++;\\n            }\\n            total+=(j-(mid+1));\\n            i++;\\n        }\\n        \\n        vector<int> temp;\\n        i=low;\\n        j=mid+1;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<nums[j]){\\n                temp.push_back(nums[i++]);\\n            }else{\\n                temp.push_back(nums[j++]);\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i++]);\\n        }\\n        \\n        while(j<=high){\\n            temp.push_back(nums[j++]);\\n        }\\n        \\n        for(int it=low;it<=high;it++){\\n            nums[it]=temp[it-low];\\n        }\\n        pairCount+=total;\\n    }\\n    void mergeSort(vector<int>& nums,int low,int high){\\n        if(low<high){\\n            int mid=low+(high-low)/2;\\n            mergeSort(nums,low,mid);\\n            mergeSort(nums,mid+1,high);\\n            merge(nums,low,mid,high);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return pairCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2358562,
                "title": "easy-to-understand-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    int merge(vector<int> &nums,int low,int mid,int high)\\n    {\\n        int j=mid+1 ;\\n        int count=0;\\n        vector<int> temp;\\n        \\n        for(int i=low;i<=mid;i++){\\n            while(j<=high && nums[i]>2LL*nums[j]){\\n                j++;\\n            }\\n            count+= (j-(mid+1));\\n        }\\n        \\n        int i=low;j=mid+1;\\n        \\n        while(i<=mid && j<=high)\\n        {\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i++]);\\n            }\\n            else\\n                temp.push_back(nums[j++]);\\n        }\\n        \\n        while(i<=mid)\\n            temp.push_back(nums[i++]);\\n        \\n        \\n        while(j<=high)\\n            temp.push_back(nums[j++]);\\n        \\n        \\n        int k=0;\\n        for(int i=low;i<=high;i++)\\n        {\\n            nums[i]=temp[k++];\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int mergeSort(vector<int> &nums ,int low,int high)\\n    {\\n        int count=0;\\n        if(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            count+=mergeSort(nums,low,mid);\\n            count+=mergeSort(nums,mid+1,high);\\n            count+=merge(nums,low,mid,high);\\n        }\\n        return count;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=mergeSort(nums,0,n-1);\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int merge(vector<int> &nums,int low,int mid,int high)\\n    {\\n        int j=mid+1 ;\\n        int count=0;\\n        vector<int> temp;\\n        \\n        for(int i=low;i<=mid;i++){\\n            while(j<=high && nums[i]>2LL*nums[j]){\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2303796,
                "title": "c-segment-tree-easy-to-understand",
                "content": "Here is my easy to read code implement segment tree to solve this problem. If you find it helpful, please upvote. Thank you for reading. \\n```\\nclass Solution {\\npublic:\\n    int seg[10000005];\\n    void update(int node, int start, int end, int pos){\\n        if(start > pos || end < pos){\\n            return;\\n        }\\n        if(start == end){\\n         \\n            seg[node] += 1;\\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        update(node*2+1, start, mid, pos);\\n        update(node*2+2, mid+1, end, pos);\\n        seg[node] = seg[node*2+1] + seg[node*2+2];\\n    }\\n    int get(int node, int start, int end, int left, int right){\\n        if(start>right || end<left){\\n            return 0;\\n        }\\n        if(left<=start && end<=right){\\n            return seg[node];\\n        }\\n        int mid = (start+end)/2;\\n        return get(node*2+1, start, mid, left, right) + get(node*2+2, mid+1, end, left, right);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size()*2;\\n        \\n        vector<long long> contain;\\n        for(auto num: nums){\\n            contain.push_back(num);\\n            contain.push_back(1LL*2*num);\\n        }\\n        sort(contain.begin(), contain.end());\\n        \\n        map<long long, long long> pos;\\n        for(int i=0; i<contain.size(); i++){\\n            pos[contain[i]] = i;\\n        }\\n        int res = 0;\\n        \\n        for(int i=nums.size()-1; i>=0; i--){\\n            res += get(0, 0, n, 0, pos[nums[i]]-1);\\n            update(0, 0, n, pos[1LL*nums[i]*2]);\\n        }\\n        \\n       \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int seg[10000005];\\n    void update(int node, int start, int end, int pos){\\n        if(start > pos || end < pos){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2102486,
                "title": "c-merge-sort",
                "content": "```\\nint merge(vector<int> &nums,int &s,int &mid,int &e)\\n{\\n    int ans=0;\\n    int i=s,j=mid+1,k=0;\\n\\n    for(i=s;i<=mid;i++)\\n    {\\n        while(j<=e&&2LL*nums[j]<nums[i])\\n        {\\n            j++;\\n        }\\n        ans+=j-(mid+1);\\n    }\\n\\n    i=s;j=mid+1;\\n    vector<int> v(e-s+1);\\n\\n\\n\\n    while(i<=mid&&j<=e)\\n    {\\n        if(nums[i]<nums[j])\\n        {\\n            v[k]=nums[i];\\n            i++;\\n        }\\n        else\\n        {\\n            v[k]=nums[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n\\n    while(i<=mid)\\n    {\\n        v[k]=nums[i];\\n        i++;k++;\\n    }\\n    while(j<=e)\\n    {\\n        v[k]=nums[j];\\n        k++;j++;\\n    }\\n\\n    for(int z=0;z<e-s+1;z++)\\n    {\\n        nums[z+s]=v[z];\\n    }\\n    return ans;\\n\\n\\n}\\n\\nvoid divide(vector<int> &nums,int s,int e,int &ans)\\n{\\n\\n    if(s<e)\\n    {\\n        int mid=(s+e)/2;\\n\\n        divide(nums,s,mid,ans);\\n        divide(nums,mid+1,e,ans);\\n        ans+=merge(nums,s,mid,e);\\n\\n    }\\n}\\n\\nint reversePairs(vector<int>& nums) {\\n    int ans=0;\\n    divide(nums,0,nums.size()-1,ans);\\n\\n    return ans;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint merge(vector<int> &nums,int &s,int &mid,int &e)\\n{\\n    int ans=0;\\n    int i=s,j=mid+1,k=0;\\n\\n    for(i=s;i<=mid;i++)\\n    {\\n        while(j<=e&&2LL*nums[j]<nums[i])\\n        {\\n            j++;\\n        }\\n        ans+=j-(mid+1);\\n    }\\n\\n    i=s;j=mid+1;\\n    vector<int> v(e-s+1);\\n\\n\\n\\n    while(i<=mid&&j<=e)\\n    {\\n        if(nums[i]<nums[j])\\n        {\\n            v[k]=nums[i];\\n            i++;\\n        }\\n        else\\n        {\\n            v[k]=nums[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n\\n    while(i<=mid)\\n    {\\n        v[k]=nums[i];\\n        i++;k++;\\n    }\\n    while(j<=e)\\n    {\\n        v[k]=nums[j];\\n        k++;j++;\\n    }\\n\\n    for(int z=0;z<e-s+1;z++)\\n    {\\n        nums[z+s]=v[z];\\n    }\\n    return ans;\\n\\n\\n}\\n\\nvoid divide(vector<int> &nums,int s,int e,int &ans)\\n{\\n\\n    if(s<e)\\n    {\\n        int mid=(s+e)/2;\\n\\n        divide(nums,s,mid,ans);\\n        divide(nums,mid+1,e,ans);\\n        ans+=merge(nums,s,mid,e);\\n\\n    }\\n}\\n\\nint reversePairs(vector<int>& nums) {\\n    int ans=0;\\n    divide(nums,0,nums.size()-1,ans);\\n\\n    return ans;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032773,
                "title": "two-approaches-merge-sort-binary-search-and-merge-sort-with-optimization",
                "content": "```\\n// Merge sort + Binary search\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void func(vector<ll> & vec,ll l,ll r)\\n    {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        if(l==r)\\n            return;\\n        ll m=(l+r)/2;\\n        func(vec,l,m);\\n        func(vec,m+1,r);\\n        for(int i=m+1;i<=r;i++)\\n        {\\n            int j = upper_bound(vec.begin()+l,vec.begin()+m+1,1LL*2*vec[i])-vec.begin();\\n            if(j<=m)\\n                ans += m-j+1;\\n        }\\n        int i=l,j=m+1;\\n        vector<ll> f;\\n        while(i<=m && j<=r)\\n        {\\n            if(vec[i]>vec[j])\\n                f.push_back(vec[j]),j++;\\n            else\\n                f.push_back(vec[i]),i++;\\n        }\\n        while(i<=m)\\n            f.push_back(vec[i++]);\\n        while(j<=r)\\n            f.push_back(vec[j++]);\\n        for(i=l,m=0;i<=r;i++,m++)\\n            vec[i]=f[m];\\n        return ;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        vector<ll> vec(nums.begin(),nums.end());\\n        func(vec,0,nums.size()-1);\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\n\\n// Merge sort + optimization\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void func(vector<ll> & vec,ll l,ll r)\\n    {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        if(l==r)\\n            return;\\n        ll m=(l+r)/2;\\n        func(vec,l,m);\\n        func(vec,m+1,r);\\n        int mid=m+1;\\n        for(int i=l;i<=m;i++)\\n        {\\n            while(mid<=r && vec[i]>2*vec[mid])\\n                mid++;\\n            ans+= (mid-m-1);\\n        }\\n        int i=l,j=m+1,k=0;\\n        int f[m-l+1 + r-m];\\n        while(i<=m && j<=r)\\n        {\\n            if(vec[i]>vec[j])\\n                f[k]=vec[j],j++;\\n            else\\n                f[k]=vec[i],i++;\\n            k++;\\n        }\\n        while(i<=m)\\n            f[k++]=vec[i++];\\n        while(j<=r)\\n            f[k++]=vec[j++];\\n        for(i=l,m=0;i<=r;i++,m++)\\n            vec[i]=f[m];\\n        return ;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        vector<ll> vec(nums.begin(),nums.end());\\n        func(vec,0,nums.size()-1);\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\n// Merge sort + Binary search\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void func(vector<ll> & vec,ll l,ll r)\\n    {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        if(l==r)\\n            return;\\n        ll m=(l+r)/2;\\n        func(vec,l,m);\\n        func(vec,m+1,r);\\n        for(int i=m+1;i<=r;i++)\\n        {\\n            int j = upper_bound(vec.begin()+l,vec.begin()+m+1,1LL*2*vec[i])-vec.begin();\\n            if(j<=m)\\n                ans += m-j+1;\\n        }\\n        int i=l,j=m+1;\\n        vector<ll> f;\\n        while(i<=m && j<=r)\\n        {\\n            if(vec[i]>vec[j])\\n                f.push_back(vec[j]),j++;\\n            else\\n                f.push_back(vec[i]),i++;\\n        }\\n        while(i<=m)\\n            f.push_back(vec[i++]);\\n        while(j<=r)\\n            f.push_back(vec[j++]);\\n        for(i=l,m=0;i<=r;i++,m++)\\n            vec[i]=f[m];\\n        return ;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        vector<ll> vec(nums.begin(),nums.end());\\n        func(vec,0,nums.size()-1);\\n        return ans;\\n    }\\n}\\n```\n```\\n\\n// Merge sort + optimization\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void func(vector<ll> & vec,ll l,ll r)\\n    {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        if(l==r)\\n            return;\\n        ll m=(l+r)/2;\\n        func(vec,l,m);\\n        func(vec,m+1,r);\\n        int mid=m+1;\\n        for(int i=l;i<=m;i++)\\n        {\\n            while(mid<=r && vec[i]>2*vec[mid])\\n                mid++;\\n            ans+= (mid-m-1);\\n        }\\n        int i=l,j=m+1,k=0;\\n        int f[m-l+1 + r-m];\\n        while(i<=m && j<=r)\\n        {\\n            if(vec[i]>vec[j])\\n                f[k]=vec[j],j++;\\n            else\\n                f[k]=vec[i],i++;\\n            k++;\\n        }\\n        while(i<=m)\\n            f[k++]=vec[i++];\\n        while(j<=r)\\n            f[k++]=vec[j++];\\n        for(i=l,m=0;i<=r;i++,m++)\\n            vec[i]=f[m];\\n        return ;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        vector<ll> vec(nums.begin(),nums.end());\\n        func(vec,0,nums.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1878594,
                "title": "trie-o-32-logn-time-c-explanation",
                "content": "You can solve this problem with BST. But i am trying this problem to solve with a different way. I use trie to solve this problem. From reverse oder, 1st i search that how many number available in the trie which is less than `nums[i] /2`; \\nApporach: \\n* \\t For every number from `nums[n-1]` .. `nums[0]` \\n* \\tCheck How many number available in trie which are smaller than `num/2` except negative number.\\n\\t* \\t If `nums[i]` is odd then check number is smaller or equal else check only smaller \\n\\t* \\t If `nums[i]` is positive, then all negative number is smaller.\\n\\n**Example**\\n*`Case1: `* `[1, 7, 2, 3, 1] `\\n\\tI am using 4 bit (with sign) for this explanation\\n* Insert 1:\\n* \\n\\t\\t\\t\\troot\\n\\t\\t\\t\\t/ \\n\\t\\t\\t  0(1)\\n\\t\\t\\t/\\n\\t     0(1)\\n\\t    /\\n\\t  0(1)\\n\\t  /\\n\\t  1(1)\\n\\n* Find less than or equal `3/2 = 1(0001)` and we found 1 from the tree.\\n* Insert 3: \\n* \\n\\t\\t\\t         root\\n\\t\\t\\t\\t      / \\n\\t\\t\\t         /\\n\\t\\t\\t       0(2)\\n\\t\\t\\t       /\\n\\t\\t        /\\n\\t\\t       0(2)\\n\\t\\t      /  \\\\\\n\\t    \\t   /    \\\\\\n\\t        0(1)  1(1)\\n\\t       /\\t      \\\\\\n\\t      /          \\\\\\n\\t     1(1)         1(1)\\n\\t\\t \\n* Find Less than `2/1 = 1(0001)` and found 0 from the tree\\n* Insert 2:\\n* \\n\\t\\t\\t\\t\\t\\troot\\n\\t\\t\\t\\t\\t\\t/ \\n\\t\\t\\t\\t\\t   /\\n\\t\\t\\t\\t\\t  0(3)\\n\\t\\t\\t\\t\\t /\\n\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t   0(3)\\n\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t0(1)  1(2)\\n\\t\\t\\t   /\\t  / \\\\\\n\\t\\t\\t  /      /   \\\\\\n\\t\\t\\t 1(1)   0(1)  1(1)\\n\\t\\t\\t \\n* Find less than or equal `7/2 = 3(0011)\\' and found 2 from the tree.\\n* Insert 7\\n* \\n\\t\\t\\t\\t\\t\\troot\\n\\t\\t\\t\\t\\t\\t/  \\n\\t\\t\\t\\t\\t   /    \\n\\t\\t\\t\\t\\t  0(4)   \\n\\t\\t\\t\\t\\t /  \\\\\\n\\t\\t\\t\\t\\t/    \\\\\\n\\t\\t\\t\\t   0(3)   1(1)\\n\\t\\t\\t\\t  /  \\\\     \\\\\\n\\t\\t\\t\\t /    \\\\     \\\\\\n\\t\\t\\t\\t0(1)  1(2)   1(1)\\n\\t\\t\\t   /\\t  / \\\\     \\\\\\n\\t\\t\\t  /      /   \\\\     \\\\\\n\\t\\t\\t 1(1)   0(1)  1(1)  1(1)\\n\\t\\t\\t \\n* Find  less than or equal `1/2 = 0(0000) ` and found 0\\n\\n*`Case2: `* `[3, 3, -3, -3, -3, 3] `\\n\\n* Insert 3 \\n* Insert -3: \\n* insert 3, -3\\n* \\n\\t\\t\\t\\t\\troot\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t\\t  0(2)   1(1)\\n\\t\\t\\t\\t /        \\\\\\n\\t\\t\\t\\t/          \\\\\\n\\t\\t\\t   0(2)         1(1}\\n\\t\\t\\t\\t \\\\          /\\n\\t\\t\\t\\t  \\\\        /\\n\\t\\t\\t\\t  1(1)    0(1)\\n\\t\\t\\t\\t\\t\\\\     \\\\\\n\\t\\t\\t\\t\\t \\\\     \\\\\\n\\t\\t\\t\\t\\t 1(1)   1(1)\\n\\t\\t\\t\\t\\t \\n* Now when insert, count will increase, and we can find the count for every search. \\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    struct Trie{\\n        int cnt;\\n        Trie* next[2];\\n        Trie(){\\n            for(int i=0; i<2; i++)\\n                next[i] = NULL;\\n            cnt = 0;\\n        }\\n    };\\n    void insert(Trie* root, long num){\\n        if(root == NULL)\\n            root = new Trie();\\n        root->cnt++;\\n        for(long i=32; i>=0; i--){\\n            int p = (num & (long)1<<i) == 0 ? 0 : 1;\\n            if(root->next[p] == NULL)\\n                root->next[p] = new Trie();\\n            root = root->next[p];\\n            root->cnt++;\\n        }\\n    }\\n    \\n    int findLessThan(Trie* root, long num, bool needCheckEqual){\\n        int ans = 0;\\n        if(num>=0){\\n            if(root->next[1])\\n                ans += root->next[1]->cnt;\\n            root = root->next[0];\\n        } else root = root->next[1];\\n        for(int i=31; i>=0; i--){\\n            if(root == NULL)\\n                return ans;\\n            int p = (num & 1<<i) == 0 ? 0 : 1;\\n            if(p == 1){\\n                if(root->next[0])\\n                    ans += root->next[0]->cnt;\\n            }\\n            root = root->next[p];\\n        }\\n        if(needCheckEqual && root != NULL)\\n            ans += root->cnt;\\n        return ans;\\n        \\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        Trie* head = new Trie();\\n        int ans = 0;\\n        for(int i=nums.size()-1; i>=0; i--){\\n            bool needCheckEqual = (nums[i] >=0 && nums[i] %2 ==1) ? true : false;\\n            ans += findLessThan(head, nums[i]/2 , needCheckEqual);\\n            insert(head, nums[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Trie{\\n        int cnt;\\n        Trie* next[2];\\n        Trie(){\\n            for(int i=0; i<2; i++)\\n                next[i] = NULL;\\n            cnt = 0;\\n        }\\n    };\\n    void insert(Trie* root, long num){\\n        if(root == NULL)\\n            root = new Trie();\\n        root->cnt++;\\n        for(long i=32; i>=0; i--){\\n            int p = (num & (long)1<<i) == 0 ? 0 : 1;\\n            if(root->next[p] == NULL)\\n                root->next[p] = new Trie();\\n            root = root->next[p];\\n            root->cnt++;\\n        }\\n    }\\n    \\n    int findLessThan(Trie* root, long num, bool needCheckEqual){\\n        int ans = 0;\\n        if(num>=0){\\n            if(root->next[1])\\n                ans += root->next[1]->cnt;\\n            root = root->next[0];\\n        } else root = root->next[1];\\n        for(int i=31; i>=0; i--){\\n            if(root == NULL)\\n                return ans;\\n            int p = (num & 1<<i) == 0 ? 0 : 1;\\n            if(p == 1){\\n                if(root->next[0])\\n                    ans += root->next[0]->cnt;\\n            }\\n            root = root->next[p];\\n        }\\n        if(needCheckEqual && root != NULL)\\n            ans += root->cnt;\\n        return ans;\\n        \\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        Trie* head = new Trie();\\n        int ans = 0;\\n        for(int i=nums.size()-1; i>=0; i--){\\n            bool needCheckEqual = (nums[i] >=0 && nums[i] %2 ==1) ? true : false;\\n            ans += findLessThan(head, nums[i]/2 , needCheckEqual);\\n            insert(head, nums[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585193,
                "title": "python-easy-nlogn",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        self.count = 0\\n        \\n        def mergeSort(nums):\\n            if len(nums) < 2: return nums\\n            mid = len(nums) // 2\\n            left = mergeSort(nums[:mid])\\n            right = mergeSort(nums[mid:])\\n            \\n            # finding pair\\n            a = b = 0\\n            while a < len(left) and b < len(right):\\n                if left[a] > 2 * right[b]:\\n                    self.count += (len(left) - a)\\n                    b += 1\\n                else: a += 1\\n                    \\n            a = b = 0\\n            arr = []\\n            # merging the sorted arrays\\n            while a < len(left) or b < len(right):\\n                if a < len(left) and (b >= len(right) or left[a] < right[b]):\\n                    arr.append(left[a])\\n                    a += 1\\n                else:\\n                    arr.append(right[b])\\n                    b += 1\\n            return arr\\n        \\n        arr = mergeSort(nums)\\n        return self.count\\n            \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        self.count = 0\\n        \\n        def mergeSort(nums):\\n            if len(nums) < 2: return nums\\n            mid = len(nums) // 2\\n            left = mergeSort(nums[:mid])\\n            right = mergeSort(nums[mid:])\\n            \\n            # finding pair\\n            a = b = 0\\n            while a < len(left) and b < len(right):\\n                if left[a] > 2 * right[b]:\\n                    self.count += (len(left) - a)\\n                    b += 1\\n                else: a += 1\\n                    \\n            a = b = 0\\n            arr = []\\n            # merging the sorted arrays\\n            while a < len(left) or b < len(right):\\n                if a < len(left) and (b >= len(right) or left[a] < right[b]):\\n                    arr.append(left[a])\\n                    a += 1\\n                else:\\n                    arr.append(right[b])\\n                    b += 1\\n            return arr\\n        \\n        arr = mergeSort(nums)\\n        return self.count\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474359,
                "title": "concise-c-mergesort-o-nlogn",
                "content": "Easy to understand.\\nThe most important part is counting pairs with first val in left part of partition and second val in right part of partition in O(n). That makes time complexity of whole algorithm O(nlogn).\\n```\\nclass Solution {\\npublic:\\n    int countAndSort(vector<int> &nums, int l, int r) {\\n        if(l>=r) return 0;\\n        int m = (l+r)/2;\\n        int ans = countAndSort(nums, l, m) + countAndSort(nums, m+1, r);\\n        int i=l, j=m+1;\\n        while(i<=m && j<=r) {\\n            while(i<=m && nums[i] <= 2*(long long)nums[j]) i++;\\n            ans += (m-i+1);\\n            j++;\\n        }\\n        inplace_merge(nums.begin()+l, nums.begin()+m+1, nums.begin()+r+1);\\n        return ans;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        return countAndSort(nums, 0, (int)nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAndSort(vector<int> &nums, int l, int r) {\\n        if(l>=r) return 0;\\n        int m = (l+r)/2;\\n        int ans = countAndSort(nums, l, m) + countAndSort(nums, m+1, r);\\n        int i=l, j=m+1;\\n        while(i<=m && j<=r) {\\n            while(i<=m && nums[i] <= 2*(long long)nums[j]) i++;\\n            ans += (m-i+1);\\n            j++;\\n        }\\n        inplace_merge(nums.begin()+l, nums.begin()+m+1, nums.begin()+r+1);\\n        return ans;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        return countAndSort(nums, 0, (int)nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333675,
                "title": "c-2-approaches-brute-force-to-merge-sort",
                "content": "**1. Brute force** (gives TLE)\\n```\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                if((nums[i]/2.0)>nums[j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**2. Merge sort** \\n```\\nclass Solution {\\npublic:\\n    int merge(vector<int> &nums, int low, int mid, int high){\\n        int j = mid+1;\\n        int cnt = 0;\\n        for(int i=low; i<=mid; i++){\\n            while(j<=high && nums[i]>nums[j]*2LL){\\n                j++;\\n            }\\n            cnt = cnt + (j - (mid +1));\\n        }\\n        \\n        vector <int> temp;\\n        int left=low, right=mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left++]);\\n            }\\n            else{\\n                temp.push_back(nums[right++]);\\n            }\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right<=high){\\n            temp.push_back(nums[right++]);\\n        }\\n        for(int i=low; i<=high; i++){\\n            nums[i] = temp[i-low];\\n        }\\n        return cnt;\\n    }\\n    \\n    int mergesort(vector<int> &nums, int low, int high){\\n        if(low==high) return 0;\\n        int mid = (low + high)/2;\\n        int inv = mergesort(nums, low, mid);\\n        inv += mergesort(nums, mid+1, high);\\n        inv += merge(nums, low, mid, high);\\n        return inv;\\n    }\\n   int reversePairs(vector<int>& nums) {\\n        return mergesort(nums, 0, nums.size()-1);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                if((nums[i]/2.0)>nums[j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int merge(vector<int> &nums, int low, int mid, int high){\\n        int j = mid+1;\\n        int cnt = 0;\\n        for(int i=low; i<=mid; i++){\\n            while(j<=high && nums[i]>nums[j]*2LL){\\n                j++;\\n            }\\n            cnt = cnt + (j - (mid +1));\\n        }\\n        \\n        vector <int> temp;\\n        int left=low, right=mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left++]);\\n            }\\n            else{\\n                temp.push_back(nums[right++]);\\n            }\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right<=high){\\n            temp.push_back(nums[right++]);\\n        }\\n        for(int i=low; i<=high; i++){\\n            nums[i] = temp[i-low];\\n        }\\n        return cnt;\\n    }\\n    \\n    int mergesort(vector<int> &nums, int low, int high){\\n        if(low==high) return 0;\\n        int mid = (low + high)/2;\\n        int inv = mergesort(nums, low, mid);\\n        inv += mergesort(nums, mid+1, high);\\n        inv += merge(nums, low, mid, high);\\n        return inv;\\n    }\\n   int reversePairs(vector<int>& nums) {\\n        return mergesort(nums, 0, nums.size()-1);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326309,
                "title": "c-solution-using-just-gnu-pbds-library",
                "content": "I first tried using a multiset but to get the index it takes O(n) time using distance(key) function thus i used gnu_pbds ordered set but it can store only unique numbers so to store duplicates i used pair thus every number has unique id. Below is the code. Open to suggestions, thanks for reading!\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\ntypedef tree<\\npair<long long, long long>,\\nnull_type,\\nless<pair<long long, long long>>,\\nrb_tree_tag,\\ntree_order_statistics_node_update> ordered_set;\\n  \\n\\nclass Solution {\\npublic:\\n    int t;\\n    Solution(){\\n        t = 0;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int ans = 0;\\n        ordered_set s;\\n        for(auto& i : nums){\\n            s.insert({(long long)i, t++});\\n            int dist = s.order_of_key({(long long)2*i+1, 0});\\n            if(i<0) dist++;\\n            ans += s.size() - dist;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\ntypedef tree<\\npair<long long, long long>,\\nnull_type,\\nless<pair<long long, long long>>,\\nrb_tree_tag,\\ntree_order_statistics_node_update> ordered_set;\\n  \\n\\nclass Solution {\\npublic:\\n    int t;\\n    Solution(){\\n        t = 0;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int ans = 0;\\n        ordered_set s;\\n        for(auto& i : nums){\\n            s.insert({(long long)i, t++});\\n            int dist = s.order_of_key({(long long)2*i+1, 0});\\n            if(i<0) dist++;\\n            ans += s.size() - dist;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1266862,
                "title": "solution-by-merge-sort-with-step-by-step-comments",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        cnt = 0\\n\\n        def merge(left, right):\\n            nonlocal cnt              #work with variables inside nested function\\n            i = j = 0\\n            while i < len(left) and j < len(right):\\n                if left[i] <= 2*right[j]:               #this i can not make reverse pair\\n                    i += 1                              #so move the i pointer\\n                else:\\n                    cnt += len(left)-i                 #reverse pair exist so increase count\\n                    j += 1                             #(i,j) exist so we increase the j pointer\\n\\n            return sorted(left+right)                  #returns sorted reverse pair\\n\\n\\n        def mergeSort(A):\\n            if len(A) == 1:                             #if there is only one element in the array\\n                return A\\n            mid=(len(A)) // 2\\n            return merge(mergeSort(A[:mid]), mergeSort(A[mid:]))      #check the left sub array and then the right sub array respectively\\n\\n        mergeSort(nums)\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        cnt = 0\\n\\n        def merge(left, right):\\n            nonlocal cnt              #work with variables inside nested function\\n            i = j = 0\\n            while i < len(left) and j < len(right):\\n                if left[i] <= 2*right[j]:               #this i can not make reverse pair\\n                    i += 1                              #so move the i pointer\\n                else:\\n                    cnt += len(left)-i                 #reverse pair exist so increase count\\n                    j += 1                             #(i,j) exist so we increase the j pointer\\n\\n            return sorted(left+right)                  #returns sorted reverse pair\\n\\n\\n        def mergeSort(A):\\n            if len(A) == 1:                             #if there is only one element in the array\\n                return A\\n            mid=(len(A)) // 2\\n            return merge(mergeSort(A[:mid]), mergeSort(A[mid:]))      #check the left sub array and then the right sub array respectively\\n\\n        mergeSort(nums)\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132647,
                "title": "modified-merge-sort",
                "content": "```\\n\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort_and_count(nums,0,nums.length-1);\\n    }\\n    int mergesort_and_count(int[] nums,int start,int end){\\n        if(start<end){\\n            int mid=(start+end)/2;\\n            int count=mergesort_and_count(nums,start,mid)+mergesort_and_count(nums,mid+1,end);\\n            \\n            int j=mid+1;\\n            for(int i=start;i<=mid;i++){\\n                while(j<=end && (long)nums[i]>(long)nums[j]*2){\\n                    j++;\\n                }\\n                count+=j-(mid+1);\\n            }\\n            \\n            merge(nums,start,mid,end);\\n            return count;\\n        }else{\\n            return 0;\\n        }\\n        \\n        \\n    }\\n    void merge(int[] nums,int start,int mid,int end){\\n        int n1=(mid-start+1);\\n        int n2=(end-mid);\\n        int[] L=new int[n1];\\n        int[] R=new int[n2];\\n        \\n        for(int i=0;i<n1;i++){\\n            L[i]=nums[start+i];\\n        }\\n        \\n        for(int j=0;j<n2;j++){\\n            R[j]=nums[mid+1+j];\\n        }\\n        \\n        int i=0;\\n        int j=0;\\n        for(int k=start;k<=end;k++){\\n            if(j>=n2 || i< n1 && L[i]<=R[j]){\\n                nums[k]=L[i++];\\n            }else{\\n                nums[k]=R[j++];\\n            }\\n        }\\n    }\\n}\\n\\n//\\nhere long is used to remain in the integer range  after multiplication with 2\\ne.g. \\ntest case like this will fail without long\\n[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]\\n//\\n\\n**PLZ -upvote if you like it**\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort_and_count(nums,0,nums.length-1);\\n    }\\n    int mergesort_and_count(int[] nums,int start,int end){\\n        if(start<end){\\n            int mid=(start+end)/2;\\n            int count=mergesort_and_count(nums,start,mid)+mergesort_and_count(nums,mid+1,end);\\n            \\n            int j=mid+1;\\n            for(int i=start;i<=mid;i++){\\n                while(j<=end && (long)nums[i]>(long)nums[j]*2){\\n                    j++;\\n                }\\n                count+=j-(mid+1);\\n            }\\n            \\n            merge(nums,start,mid,end);\\n            return count;\\n        }else{\\n            return 0;\\n        }\\n        \\n        \\n    }\\n    void merge(int[] nums,int start,int mid,int end){\\n        int n1=(mid-start+1);\\n        int n2=(end-mid);\\n        int[] L=new int[n1];\\n        int[] R=new int[n2];\\n        \\n        for(int i=0;i<n1;i++){\\n            L[i]=nums[start+i];\\n        }\\n        \\n        for(int j=0;j<n2;j++){\\n            R[j]=nums[mid+1+j];\\n        }\\n        \\n        int i=0;\\n        int j=0;\\n        for(int k=start;k<=end;k++){\\n            if(j>=n2 || i< n1 && L[i]<=R[j]){\\n                nums[k]=L[i++];\\n            }else{\\n                nums[k]=R[j++];\\n            }\\n        }\\n    }\\n}\\n\\n//\\nhere long is used to remain in the integer range  after multiplication with 2\\ne.g. \\ntest case like this will fail without long\\n[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]\\n//\\n\\n**PLZ -upvote if you like it**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976105,
                "title": "python3-segment-tree-solusion",
                "content": "Python3 segment tree solusion\\n\\n```\\nclass TreeNode:\\n    def __init__(self, minv, maxv):\\n        self.minv = minv\\n        self.maxv = maxv\\n        self.left = self.right = None\\n        self.count = 0\\n        \\n    def add(self, n):\\n        self.count += 1\\n        if self.minv == self.maxv:\\n            return\\n            \\n        mid = (self.minv + self.maxv) // 2\\n        if not self.left:\\n            self.left = TreeNode(self.minv, mid)\\n        if not self.right:\\n            self.right = TreeNode(mid + 1, self.maxv)\\n        if n <= mid:\\n            self.left.add(n)\\n        else:\\n            self.right.add(n)\\n    \\n    def countGreaterThan(self, n):\\n        mid = (self.minv + self.maxv) // 2\\n        if n > mid:\\n            return self.right.countGreaterThan(n) if self.right else 0\\n        else:\\n            return (self.right.count if self.right else 0) + (self.left.countGreaterThan(n) if self.left else 0)\\n        \\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        \\n        cnt = 0\\n        root = TreeNode(min(nums) - 1, max(nums))\\n        for n in nums:\\n            cnt += root.countGreaterThan(n * 2)\\n            root.add(n)\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass TreeNode:\\n    def __init__(self, minv, maxv):\\n        self.minv = minv\\n        self.maxv = maxv\\n        self.left = self.right = None\\n        self.count = 0\\n        \\n    def add(self, n):\\n        self.count += 1\\n        if self.minv == self.maxv:\\n            return\\n            \\n        mid = (self.minv + self.maxv) // 2\\n        if not self.left:\\n            self.left = TreeNode(self.minv, mid)\\n        if not self.right:\\n            self.right = TreeNode(mid + 1, self.maxv)\\n        if n <= mid:\\n            self.left.add(n)\\n        else:\\n            self.right.add(n)\\n    \\n    def countGreaterThan(self, n):\\n        mid = (self.minv + self.maxv) // 2\\n        if n > mid:\\n            return self.right.countGreaterThan(n) if self.right else 0\\n        else:\\n            return (self.right.count if self.right else 0) + (self.left.countGreaterThan(n) if self.left else 0)\\n        \\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        \\n        cnt = 0\\n        root = TreeNode(min(nums) - 1, max(nums))\\n        for n in nums:\\n            cnt += root.countGreaterThan(n * 2)\\n            root.add(n)\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965143,
                "title": "java-short-and-clean-code-beats-99-58",
                "content": "**Approach:** Count inversions during Merge Sort. Here the definition of an inversion is slightly changed but core idea remains the same.\\n\\n```\\nclass Solution {\\n    private int merge(int[] A, int l, int m, int r, int[] M) {\\n        int i = l, t = l, k = 0, res = 0;\\n        for(int j = m + 1; j <= r; j++) {\\n            while(t <= m && A[t] <= 2L * A[j]) t++;\\n            res += m - t + 1;\\n            while(i <= m && A[i] <= A[j]) M[k++] = A[i++];\\n            M[k++] = A[j];\\n        }\\n        while(i <= m) M[k++] = A[i++];\\n        for(i = l; i <= r; i++) A[i] = M[i - l];\\n        return res;\\n    }\\n    private int mergeSort(int[] A, int l, int r, int[] M) {\\n        if(l >= r) return 0;\\n        int m = l + ((r-l) >> 1);\\n        return mergeSort(A, l, m, M) + mergeSort(A, m + 1, r, M) + merge(A, l, m, r, M);\\n    }\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    private int merge(int[] A, int l, int m, int r, int[] M) {\\n        int i = l, t = l, k = 0, res = 0;\\n        for(int j = m + 1; j <= r; j++) {\\n            while(t <= m && A[t] <= 2L * A[j]) t++;\\n            res += m - t + 1;\\n            while(i <= m && A[i] <= A[j]) M[k++] = A[i++];\\n            M[k++] = A[j];\\n        }\\n        while(i <= m) M[k++] = A[i++];\\n        for(i = l; i <= r; i++) A[i] = M[i - l];\\n        return res;\\n    }\\n    private int mergeSort(int[] A, int l, int r, int[] M) {\\n        if(l >= r) return 0;\\n        int m = l + ((r-l) >> 1);\\n        return mergeSort(A, l, m, M) + mergeSort(A, m + 1, r, M) + merge(A, l, m, r, M);\\n    }\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209725,
                "title": "python2-merge-sort-beat-98",
                "content": "\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        tmp = [0]*len(nums)\\n        res = self.merge_sort_count(nums, 0, len(nums)-1)\\n        return res\\n    \\n    def merge_sort_count(self, nums, st, end):\\n        if st == end:\\n            return 0\\n        mid = (end+st)/2\\n        cnt = 0\\n        cnt += self.merge_sort_count(nums, st, mid)\\n        cnt += self.merge_sort_count(nums, mid+1, end)\\n\\n        i, j = st, mid+1\\n        while i <= mid and j <= end:\\n            if nums[i] > nums[j]*2:\\n                cnt += mid+1-i\\n                j += 1\\n            else:\\n                i += 1\\n        nums[st:end+1] = sorted(nums[st:end+1])\\n        return cnt",
                "solutionTags": [],
                "code": "\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        tmp = [0]*len(nums)\\n        res = self.merge_sort_count(nums, 0, len(nums)-1)\\n        return res\\n    \\n    def merge_sort_count(self, nums, st, end):\\n        if st == end:\\n            return 0\\n        mid = (end+st)/2\\n        cnt = 0\\n        cnt += self.merge_sort_count(nums, st, mid)\\n        cnt += self.merge_sort_count(nums, mid+1, end)\\n\\n        i, j = st, mid+1\\n        while i <= mid and j <= end:\\n            if nums[i] > nums[j]*2:\\n                cnt += mid+1-i\\n                j += 1\\n            else:\\n                i += 1\\n        nums[st:end+1] = sorted(nums[st:end+1])\\n        return cnt",
                "codeTag": "Python3"
            },
            {
                "id": 144026,
                "title": "clear-python-bit-solution",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Similar to https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\\n        # Use BIT to keep frequency count when reverse iterating\\n        # answer for each num is prefix sum of freq for 0 to i where i is rank of num//2\\n        class BinaryIndexedTree:\\n            def __init__(self, n):\\n                self._sums = [0] * (n+1)\\n            def update(self, i, delta):\\n                while i < len(self._sums):\\n                    self._sums[i] += delta\\n                    i += i & -i\\n            def query(self, i):\\n                s = 0\\n                while i > 0:  \\n                    s += self._sums[i]\\n                    i -= i & -i\\n                return s    \\n            \\n        if not nums: return 0\\n        rank_mapping = {v: i for i, v in enumerate(sorted(set(nums)))}\\n        ranks = list(sorted(rank_mapping.keys()))\\n        bit_tree = BinaryIndexedTree(len(rank_mapping))\\n        ret = 0\\n        for val in reversed(nums):\\n            rank = rank_mapping[val]\\n            idx = bisect.bisect_left(ranks, val/2)\\n            ret += bit_tree.query(idx)\\n            bit_tree.update(rank+1, 1)\\n        return ret    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Similar to https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\\n        # Use BIT to keep frequency count when reverse iterating\\n        # answer for each num is prefix sum of freq for 0 to i where i is rank of num//2\\n        class BinaryIndexedTree:\\n            def __init__(self, n):\\n                self._sums = [0] * (n+1)\\n            def update(self, i, delta):\\n                while i < len(self._sums):\\n                    self._sums[i] += delta\\n                    i += i & -i\\n            def query(self, i):\\n                s = 0\\n                while i > 0:  \\n                    s += self._sums[i]\\n                    i -= i & -i\\n                return s    \\n            \\n        if not nums: return 0\\n        rank_mapping = {v: i for i, v in enumerate(sorted(set(nums)))}\\n        ranks = list(sorted(rank_mapping.keys()))\\n        bit_tree = BinaryIndexedTree(len(rank_mapping))\\n        ret = 0\\n        for val in reversed(nums):\\n            rank = rank_mapping[val]\\n            idx = bisect.bisect_left(ranks, val/2)\\n            ret += bit_tree.query(idx)\\n            bit_tree.update(rank+1, 1)\\n        return ret    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 97303,
                "title": "c-solution-using-binary-search-fenwick-tree",
                "content": "\\n\\nThis is obviously not a fast or short solution at all. But if you want to review the usage of Fenwick tree I wish this could be helpful. The basic idea is similar to LC315, but binary search is used to maintain another map so we know where to \"count\" the numbers. A detailed implementation of Fenwick tree is also given for the purpose of reviewing old knowledge...\\n\\n      class Fenwick {\\n      private:\\n      \\t// tree is one unit shiftd from a virtual vector arr[]\\n      \\tvector<long> tree;\\n      \\tlong lsb(long i) { return i & (-i); }\\n      public:\\n      \\tFenwick(long size) {\\n      \\t\\ttree = vector<long>(size + 1, 0);\\n      \\t}\\n      \\n      \\t// the following function sums up arr[0..id]\\n      \\tlong sum(long id) {\\n      \\t\\tid++;\\n      \\t\\tlong ret = 0;\\n      \\t\\twhile(id > 0) {\\n      \\t\\t\\tret += tree[id];\\n      \\t\\t\\tid -= lsb(id);\\n      \\t\\t}\\n      \\t\\treturn ret;\\n      \\t}\\n      \\n      \\t// the following function increases arr[id]\\n      \\tvoid add(long id, long val) {\\n      \\t\\tlong n = tree.size();\\n      \\t\\tid++;\\n      \\t\\twhile(id < n) {\\n      \\t\\t\\ttree[id] += val;\\n      \\t\\t\\tid += lsb(id);\\n      \\t\\t}\\n      \\t}\\n      \\n      };\\n      \\n      \\n      \\n      class Solution {\\n      public:\\n      \\tlong reversePairs(vector<int>& nums) {\\n      \\t\\tvector<long> nums2;\\n      \\t\\tfor(long i : nums) {\\n      \\t\\t\\tnums2.push_back(2*i);\\n      \\t\\t}\\n      \\n      \\t\\tsort(nums2.begin(), nums2.end());\\n      \\t\\t// order maps the original order to sorted order, it doesn't matter if duplicated is present\\n      \\t\\tunordered_map<long, long> order;\\n      \\t\\t\\n      \\t\\t// binary search result, notice that this is index<->index map \\n      \\t\\tunordered_map<long, long> biorder;\\n      \\t\\tlong ret = 0;\\n      \\t\\tlong n = nums.size();\\n      \\t\\tfor(long i = 0; i < n; ++i) {\\n      \\t\\t\\tbiorder[i] = lower_bound(nums2.begin(), nums2.end(), nums[i]) - nums2.begin();\\n      \\t\\t\\torder[nums2[i]/2] = i;\\n      \\t\\t}\\n      \\n      \\t\\tFenwick fw(n);\\n      \\t\\tfor(long i = n-1; i>=0; --i) {\\n      \\t\\t\\tret += fw.sum(biorder[i]-1);\\n      \\t\\t\\tfw.add(order[nums[i]], 1);\\n      \\t\\t}\\n      \\t\\treturn ret;\\n      \\t}\\n      };",
                "solutionTags": [],
                "code": "class Solution {\\n      public:\\n      \\tlong reversePairs(vector<int>& nums) {\\n      \\t\\tvector<long> nums2;\\n      \\t\\tfor(long i : nums) {\\n      \\t\\t\\tnums2.push_back(2*i);\\n      \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3971221,
                "title": "using-merge-sort-with-just-small-modification-in-code-c-code-easy-approach",
                "content": "# Intuition\\nProblem is similar to https://leetcode.com/problems/count-of-smaller-numbers-after-self/ . If not solved then can check out this one also\\n\\n# Approach\\nWhile merging two sorted array in merge sorting just check for the given condition $2*nums[j]<nums[i]$ and incerse the answer while is globally defined by $i-mid+1$.\\nFinally return the answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    void mergevec(int lo,int mid,int hi, vector<int>&nums){\\n        int i=lo,j=mid+1,k=0;\\n        vector<int> temp(hi-lo+1,0);\\n        //merging two sorted vwctors using two pointers \\n        while(i<=mid and j<=hi){\\n            if(nums[i]>nums[j]){\\n                temp[k]=nums[j];\\n                j++;\\n            }\\n            else {\\n                temp[k]=nums[i];\\n                i++;\\n            }\\n            k++;\\n        }\\n        // merging if j reach to hi and still some i remains to merge\\n        while(i<=mid){\\n            temp[k]=nums[i];\\n            i++;\\n            k++;\\n        }\\n        // merging if i reach to mid and still some j remains to merge\\n        while(j<=hi){\\n            temp[k]=nums[j];\\n            j++;\\n            k++;\\n        }\\n        i=lo,j=mid+1;\\n        // calculating for 2*nums[j]>nums[i]....Iterating wrt to j cuz j should have higher values\\n        while(i<=mid and j<=hi){\\n            if(2ll*nums[j]<1ll*nums[i]){\\n                ans+=mid-i+1;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        // merged temp array transferring to original array\\n        for(int x=lo;x<=hi;x++){\\n            nums[x]=temp[x-lo];\\n        }\\n    }\\n\\n    void merge(int lo,int hi, vector<int>& nums){\\n        if(lo>=hi){\\n            return;\\n        }\\n        //take mid and sort lo-->mid and mid+1-->hi\\n        int mid=lo+hi >> 1;\\n        //call for lo-->mid\\n        merge(lo,mid,nums);\\n        //call for mid+1-->hi\\n        merge(mid+1,hi,nums);\\n        // merge the two sorted vectors\\n        mergevec(lo,mid,hi,nums);\\n\\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n        //Use Mergesort Algo\\n        merge(0,n-1,nums);\\n        // for(int i=0;i<n;i++)cout<<nums[i]<<\" \";\\n        // cout<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void mergevec(int lo,int mid,int hi, vector<int>&nums){\\n        int i=lo,j=mid+1,k=0;\\n        vector<int> temp(hi-lo+1,0);\\n        //merging two sorted vwctors using two pointers \\n        while(i<=mid and j<=hi){\\n            if(nums[i]>nums[j]){\\n                temp[k]=nums[j];\\n                j++;\\n            }\\n            else {\\n                temp[k]=nums[i];\\n                i++;\\n            }\\n            k++;\\n        }\\n        // merging if j reach to hi and still some i remains to merge\\n        while(i<=mid){\\n            temp[k]=nums[i];\\n            i++;\\n            k++;\\n        }\\n        // merging if i reach to mid and still some j remains to merge\\n        while(j<=hi){\\n            temp[k]=nums[j];\\n            j++;\\n            k++;\\n        }\\n        i=lo,j=mid+1;\\n        // calculating for 2*nums[j]>nums[i]....Iterating wrt to j cuz j should have higher values\\n        while(i<=mid and j<=hi){\\n            if(2ll*nums[j]<1ll*nums[i]){\\n                ans+=mid-i+1;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        // merged temp array transferring to original array\\n        for(int x=lo;x<=hi;x++){\\n            nums[x]=temp[x-lo];\\n        }\\n    }\\n\\n    void merge(int lo,int hi, vector<int>& nums){\\n        if(lo>=hi){\\n            return;\\n        }\\n        //take mid and sort lo-->mid and mid+1-->hi\\n        int mid=lo+hi >> 1;\\n        //call for lo-->mid\\n        merge(lo,mid,nums);\\n        //call for mid+1-->hi\\n        merge(mid+1,hi,nums);\\n        // merge the two sorted vectors\\n        mergevec(lo,mid,hi,nums);\\n\\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n        //Use Mergesort Algo\\n        merge(0,n-1,nums);\\n        // for(int i=0;i<n;i++)cout<<nums[i]<<\" \";\\n        // cout<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3920333,
                "title": "simple-c-solution",
                "content": "# Brute Force\\n```\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]>2*nums[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Merge Sort\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &nums,int start,int mid,int end,int &res){\\n        int l=start,r=mid+1;\\n        while(l<=mid && r<=end){\\n            long long p=nums[l];\\n            long long q=(long long) 2*nums[r];\\n            if(p>q){\\n                res+=mid-l+1;\\n                r++;\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n        sort(nums.begin()+start,nums.begin()+end+1);\\n    }\\n    void mergeSort(vector<int> &nums,int start,int end,int &res){\\n        if(start==end){\\n            return ;\\n        }\\n        int mid=start+(end-start)/2;\\n        mergeSort(nums,start,mid,res);\\n        mergeSort(nums,mid+1,end,res);\\n        merge(nums,start,mid,end,res);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int res=0;\\n        mergeSort(nums,0,nums.size()-1,res);\\n        for(auto n:nums){\\n            cout<<n<<\" \";\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]>2*nums[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &nums,int start,int mid,int end,int &res){\\n        int l=start,r=mid+1;\\n        while(l<=mid && r<=end){\\n            long long p=nums[l];\\n            long long q=(long long) 2*nums[r];\\n            if(p>q){\\n                res+=mid-l+1;\\n                r++;\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n        sort(nums.begin()+start,nums.begin()+end+1);\\n    }\\n    void mergeSort(vector<int> &nums,int start,int end,int &res){\\n        if(start==end){\\n            return ;\\n        }\\n        int mid=start+(end-start)/2;\\n        mergeSort(nums,start,mid,res);\\n        mergeSort(nums,mid+1,end,res);\\n        merge(nums,start,mid,end,res);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int res=0;\\n        mergeSort(nums,0,nums.size()-1,res);\\n        for(auto n:nums){\\n            cout<<n<<\" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3335048,
                "title": "c-97",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void merge(vector<int>&arr, int p, int q, int r) {\\n        int n1 = q - p + 1;\\n        int n2 = r - q;\\n        int L[n1], M[n2];\\n        for (int i = 0; i < n1; i++)\\n            L[i] = arr[p + i];\\n        for (int j = 0; j < n2; j++)\\n            M[j] = arr[q + 1 + j];\\n        int i=0, j=0, k=p,x=0;\\n        while (i < n1 && j < n2) {\\n            while(x<n2 && L[i]>(long)2*M[x]) {\\n                x++;\\n                count+=n1-i;\\n            }\\n            if (L[i] <= M[j])\\n                arr[k++] = L[i++];\\n            else\\n                arr[k++] = M[j++];\\n        }\\n        while (i < n1) {\\n            while(x<n2 && L[i]>(long)2*M[x]) {\\n                x++;\\n                count+=n1-i;\\n            }\\n            arr[k++] = L[i++];\\n        }\\n        while (j < n2) arr[k++] = M[j++];\\n    }\\n\\n    void mergeSort(vector<int>& arr, int l, int r) {\\n        if (l < r) {\\n            int m =( l + r) / 2;\\n            mergeSort(arr, l, m);\\n            mergeSort(arr, m + 1, r);\\n            merge(arr, l, m, r);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size() - 1);\\n        return count;\\n    }\\n# };\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void merge(vector<int>&arr, int p, int q, int r) {\\n        int n1 = q - p + 1;\\n        int n2 = r - q;\\n        int L[n1], M[n2];\\n        for (int i = 0; i < n1; i++)\\n            L[i] = arr[p + i];\\n        for (int j = 0; j < n2; j++)\\n            M[j] = arr[q + 1 + j];\\n        int i=0, j=0, k=p,x=0;\\n        while (i < n1 && j < n2) {\\n            while(x<n2 && L[i]>(long)2*M[x]) {\\n                x++;\\n                count+=n1-i;\\n            }\\n            if (L[i] <= M[j])\\n                arr[k++] = L[i++];\\n            else\\n                arr[k++] = M[j++];\\n        }\\n        while (i < n1) {\\n            while(x<n2 && L[i]>(long)2*M[x]) {\\n                x++;\\n                count+=n1-i;\\n            }\\n            arr[k++] = L[i++];\\n        }\\n        while (j < n2) arr[k++] = M[j++];\\n    }\\n\\n    void mergeSort(vector<int>& arr, int l, int r) {\\n        if (l < r) {\\n            int m =( l + r) / 2;\\n            mergeSort(arr, l, m);\\n            mergeSort(arr, m + 1, r);\\n            merge(arr, l, m, r);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size() - 1);\\n        return count;\\n    }\\n# };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192204,
                "title": "using-merge-sort-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(NlogN)+O(N)+O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    int merge(int[] nums,int low,int mid, int high){\\n        int count=0;\\n        int j = mid+1;\\n        for(int i=low;i<=mid;i++){\\n            while(j<=high && nums[i]>(2*(long)nums[j])){\\n                j++;\\n            }count+=j-(mid+1);\\n        }\\n        ArrayList<Integer>arr=new ArrayList<>();\\n        int left=low,right=mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                arr.add(nums[left++]);\\n            }else{\\n                arr.add(nums[right++]);\\n            }\\n        }\\n        while(left<=mid){\\n                arr.add(nums[left++]);\\n            }\\n        while(right<=high){\\n                arr.add(nums[right++]);\\n            }\\n        for(int i=low;i<=high;i++){\\n            nums[i]=arr.get(i-low);\\n        }\\n        return count;\\n    }\\n    public int mergeSort(int []nums,int low,int high){\\n        if(low>=high){\\n            return 0;\\n        }\\n        int mid=(low+high)/2;\\n        int inv=mergeSort(nums,low,mid);\\n        inv+=mergeSort(nums,mid+1,high);\\n        inv+=merge(nums,low,mid,high);\\n        return inv;\\n    }\\n    public int reversePairs(int[]nums){\\n        return mergeSort(nums,0,nums.length-1);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int merge(int[] nums,int low,int mid, int high){\\n        int count=0;\\n        int j = mid+1;\\n        for(int i=low;i<=mid;i++){\\n            while(j<=high && nums[i]>(2*(long)nums[j])){\\n                j++;\\n            }count+=j-(mid+1);\\n        }\\n        ArrayList<Integer>arr=new ArrayList<>();\\n        int left=low,right=mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                arr.add(nums[left++]);\\n            }else{\\n                arr.add(nums[right++]);\\n            }\\n        }\\n        while(left<=mid){\\n                arr.add(nums[left++]);\\n            }\\n        while(right<=high){\\n                arr.add(nums[right++]);\\n            }\\n        for(int i=low;i<=high;i++){\\n            nums[i]=arr.get(i-low);\\n        }\\n        return count;\\n    }\\n    public int mergeSort(int []nums,int low,int high){\\n        if(low>=high){\\n            return 0;\\n        }\\n        int mid=(low+high)/2;\\n        int inv=mergeSort(nums,low,mid);\\n        inv+=mergeSort(nums,mid+1,high);\\n        inv+=merge(nums,low,mid,high);\\n        return inv;\\n    }\\n    public int reversePairs(int[]nums){\\n        return mergeSort(nums,0,nums.length-1);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616335,
                "title": "python-solution-with-explanation-nlong-n",
                "content": "```\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # divide and conquer\\n        def helper(arr):\\n\\t\\t\\t# stopping criteria\\n            if len(arr) == 1:\\n                return 0\\n            # split array\\n            res= 0 \\n            n = len(arr)\\n            l1 = sorted(arr[:n//2], reverse=True)\\n            l2 = sorted(arr[n//2:], reverse=True)\\n            #find what is the pairs between arr1 and arr2\\n            i = 0\\n            j = 0\\n            # basic case here, get the reverse pairs between first and second half.\\n\\t\\t\\t# since the arrays are sorted, two pointers are enough\\n            while j<len(l2) and i< len(l1):\\n                if l1[i]>2*l2[j]:\\n                    res+= len(l2)-j\\n                    i = i+1\\n                else:\\n                    j = j+1\\n                    \\n            res+= helper(arr[:n//2]) # recurisively for the first half\\n            res+= helper(arr[n//2:])  # recurisively for the second half\\n            \\n            return res\\n            \\n        return helper(nums)\\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # divide and conquer\\n        def helper(arr):\\n\\t\\t\\t# stopping criteria\\n            if len(arr) == 1:\\n                return 0\\n            # split array\\n            res= 0 \\n            n = len(arr)\\n            l1 = sorted(arr[:n//2], reverse=True)\\n            l2 = sorted(arr[n//2:], reverse=True)\\n            #find what is the pairs between arr1 and arr2\\n            i = 0\\n            j = 0\\n            # basic case here, get the reverse pairs between first and second half.\\n\\t\\t\\t# since the arrays are sorted, two pointers are enough\\n            while j<len(l2) and i< len(l1):\\n                if l1[i]>2*l2[j]:\\n                    res+= len(l2)-j\\n                    i = i+1\\n                else:\\n                    j = j+1\\n                    \\n            res+= helper(arr[:n//2]) # recurisively for the first half\\n            res+= helper(arr[n//2:])  # recurisively for the second half\\n            \\n            return res\\n            \\n        return helper(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2480289,
                "title": "simple-java-solution-easy-to-understand-merge-sort-approach",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int reversePairs(int[] nums) {\\n        mergeSort(nums,0,nums.length-1);\\n        return res;\\n    }\\n    void mergeSort(int nums[], int l, int r){\\n        if(l == r) return;\\n        int mid = (l + r)/2;\\n        mergeSort(nums,l,mid);\\n        mergeSort(nums,mid+1,r);\\n        merge(nums,l,mid,r);\\n    }\\n    void merge(int nums[], int l, int mid, int r){\\n        int temp[] = new int[r - l + 1];\\n        int i = l, j = mid + 1, k = 0;\\n        while(i <= mid && j <= r){\\n            while(i <= mid && (long)nums[i] <= 2*(long)nums[j]){\\n                i++;\\n            }\\n            res += mid - i + 1;\\n            j++;\\n        }\\n        i = l;\\n        j = mid + 1;\\n        while(i <= mid && j <= r){\\n            if(nums[i] <= nums[j]){\\n                temp[k++] = nums[i++];\\n            }\\n            else{\\n                temp[k++] =  nums[j++];\\n            }\\n        }\\n        while(i <= mid){\\n            temp[k++] = nums[i++];\\n        }\\n        while(j <= r){\\n            temp[k++] = nums[j++];\\n        }\\n        k = 0;\\n        for(k = 0; k < temp.length; k++){\\n            nums[l + k] = temp[k];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int reversePairs(int[] nums) {\\n        mergeSort(nums,0,nums.length-1);\\n        return res;\\n    }\\n    void mergeSort(int nums[], int l, int r){\\n        if(l == r) return;\\n        int mid = (l + r)/2;\\n        mergeSort(nums,l,mid);\\n        mergeSort(nums,mid+1,r);\\n        merge(nums,l,mid,r);\\n    }\\n    void merge(int nums[], int l, int mid, int r){\\n        int temp[] = new int[r - l + 1];\\n        int i = l, j = mid + 1, k = 0;\\n        while(i <= mid && j <= r){\\n            while(i <= mid && (long)nums[i] <= 2*(long)nums[j]){\\n                i++;\\n            }\\n            res += mid - i + 1;\\n            j++;\\n        }\\n        i = l;\\n        j = mid + 1;\\n        while(i <= mid && j <= r){\\n            if(nums[i] <= nums[j]){\\n                temp[k++] = nums[i++];\\n            }\\n            else{\\n                temp[k++] =  nums[j++];\\n            }\\n        }\\n        while(i <= mid){\\n            temp[k++] = nums[i++];\\n        }\\n        while(j <= r){\\n            temp[k++] = nums[j++];\\n        }\\n        k = 0;\\n        for(k = 0; k < temp.length; k++){\\n            nums[l + k] = temp[k];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460603,
                "title": "java-using-merge-sort-template",
                "content": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return merge(nums, 0, nums.length - 1);\\n    }\\n    \\n    private int merge(int[] arr, int l, int r) {\\n        if( l >= r ) return 0;\\n        int count = 0;\\n        int mid = l + (r - l) / 2;\\n        count += merge(arr, l, mid);\\n        count += merge(arr, mid+1, r);\\n        count += sort(arr, l, mid, r);\\n        \\n        return count;\\n    }\\n    \\n    private int sort(int[] arr, int l, int m, int r) {\\n        int count = 0;\\n        int[] left = Arrays.copyOfRange(arr, l, m+1);\\n        int[] right = Arrays.copyOfRange(arr, m+1, r+1);\\n        \\n        int i = 0, j = 0, k = l;\\n        \\n        while( i < left.length && j < right.length ) {\\n            if(left[i] > 2L * right[j]) {\\n                count += left.length - i;\\n                j++;\\n            } else i++;\\n        }\\n        \\n        i = 0; j = 0;\\n        \\n        while( i < left.length && j < right.length ) {\\n            if(left[i] <= right[j]) arr[k++] = left[i++];\\n            else arr[k++] = right[j++];\\n        }\\n        \\n        while( i < left.length ) arr[k++] = left[i++];\\n        while( j < right.length ) arr[k++] = right[j++];\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return merge(nums, 0, nums.length - 1);\\n    }\\n    \\n    private int merge(int[] arr, int l, int r) {\\n        if( l >= r ) return 0;\\n        int count = 0;\\n        int mid = l + (r - l) / 2;\\n        count += merge(arr, l, mid);\\n        count += merge(arr, mid+1, r);\\n        count += sort(arr, l, mid, r);\\n        \\n        return count;\\n    }\\n    \\n    private int sort(int[] arr, int l, int m, int r) {\\n        int count = 0;\\n        int[] left = Arrays.copyOfRange(arr, l, m+1);\\n        int[] right = Arrays.copyOfRange(arr, m+1, r+1);\\n        \\n        int i = 0, j = 0, k = l;\\n        \\n        while( i < left.length && j < right.length ) {\\n            if(left[i] > 2L * right[j]) {\\n                count += left.length - i;\\n                j++;\\n            } else i++;\\n        }\\n        \\n        i = 0; j = 0;\\n        \\n        while( i < left.length && j < right.length ) {\\n            if(left[i] <= right[j]) arr[k++] = left[i++];\\n            else arr[k++] = right[j++];\\n        }\\n        \\n        while( i < left.length ) arr[k++] = left[i++];\\n        while( j < right.length ) arr[k++] = right[j++];\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399960,
                "title": "if-you-know-merge-sort-just-add-these-5-lines-loop-in-merge-function",
                "content": "**Lines to add**\\n```\\nint count=0;\\n        int i=0, j=0;\\n        for(i=0; i<n1; i++){\\n            while(j<n2 && nums1[i]>(2*nums2[j])){\\n                j++;\\n            }\\n            count += j;\\n        }\\n```\\n\\n\\n**Whole Code**\\n```\\n\\n// Approach2\\n// Merge Sort\\n// TC: O(nlogn){mergeSort} + O(n){merge} + O(n){counting}\\n// SC: O(n){temporary array}\\n\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0 , nums.length-1);\\n    }\\n    \\n    // merge sort modified\\n    private int mergeSort(int[] nums, int start, int end){\\n        if(start>=end)\\n            return 0;\\n        int mid = start + (end-start)/2;\\n        int reversePairs = 0;\\n        reversePairs += mergeSort(nums, start, mid);\\n        reversePairs += mergeSort(nums, mid+1, end);\\n        reversePairs += merge(nums, start, mid, end);\\n        return reversePairs;\\n    }\\n    \\n    private int merge(int[] nums, int start, int mid, int end){\\n        int n1 = mid - start + 1;\\n        int n2 = end - mid;\\n        long nums1[] = new long[n1+1];\\n        nums1[n1] = Long.MAX_VALUE;\\n        long nums2[] = new long[n2+1];\\n        nums2[n2] = Integer.MAX_VALUE;\\n        for(int i=0; i<n1; i++)\\n            nums1[i] = nums[i+start];\\n        for(int j=0; j<n2; j++)\\n            nums2[j] = nums[mid+1+j];\\n        \\n        // System.out.println(\"******************\");\\n        // System.out.println(Arrays.toString(nums1));\\n        // System.out.println(Arrays.toString(nums2));\\n        \\n        // Here comes our logic to count pairs\\n        int count=0;\\n        int i=0, j=0;\\n        for(i=0; i<n1; i++){\\n            while(j<n2 && nums1[i]>(2*nums2[j])){\\n                j++;\\n            }\\n            count += j;\\n        }\\n        // Logic Ends\\n        \\n        i=0;\\n        j=0;\\n        // now, putting element in sorted array in original array\\n        for(int k=start; k<=end; k++){\\n            if(nums1[i]<=nums2[j]){\\n                nums[k] = (int)nums1[i++];\\n            } else {\\n                nums[k] = (int)nums2[j++];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nint count=0;\\n        int i=0, j=0;\\n        for(i=0; i<n1; i++){\\n            while(j<n2 && nums1[i]>(2*nums2[j])){\\n                j++;\\n            }\\n            count += j;\\n        }\\n```\n```\\n\\n// Approach2\\n// Merge Sort\\n// TC: O(nlogn){mergeSort} + O(n){merge} + O(n){counting}\\n// SC: O(n){temporary array}\\n\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0 , nums.length-1);\\n    }\\n    \\n    // merge sort modified\\n    private int mergeSort(int[] nums, int start, int end){\\n        if(start>=end)\\n            return 0;\\n        int mid = start + (end-start)/2;\\n        int reversePairs = 0;\\n        reversePairs += mergeSort(nums, start, mid);\\n        reversePairs += mergeSort(nums, mid+1, end);\\n        reversePairs += merge(nums, start, mid, end);\\n        return reversePairs;\\n    }\\n    \\n    private int merge(int[] nums, int start, int mid, int end){\\n        int n1 = mid - start + 1;\\n        int n2 = end - mid;\\n        long nums1[] = new long[n1+1];\\n        nums1[n1] = Long.MAX_VALUE;\\n        long nums2[] = new long[n2+1];\\n        nums2[n2] = Integer.MAX_VALUE;\\n        for(int i=0; i<n1; i++)\\n            nums1[i] = nums[i+start];\\n        for(int j=0; j<n2; j++)\\n            nums2[j] = nums[mid+1+j];\\n        \\n        // System.out.println(\"******************\");\\n        // System.out.println(Arrays.toString(nums1));\\n        // System.out.println(Arrays.toString(nums2));\\n        \\n        // Here comes our logic to count pairs\\n        int count=0;\\n        int i=0, j=0;\\n        for(i=0; i<n1; i++){\\n            while(j<n2 && nums1[i]>(2*nums2[j])){\\n                j++;\\n            }\\n            count += j;\\n        }\\n        // Logic Ends\\n        \\n        i=0;\\n        j=0;\\n        // now, putting element in sorted array in original array\\n        for(int k=start; k<=end; k++){\\n            if(nums1[i]<=nums2[j]){\\n                nums[k] = (int)nums1[i++];\\n            } else {\\n                nums[k] = (int)nums2[j++];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322876,
                "title": "python-merge-sort-solution",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        def mergeSort(nums):\\n            count=0\\n            if len(nums)>1:\\n                mid=len(nums)//2\\n                L=nums[:mid]\\n                R=nums[mid:]\\n                count+=mergeSort(L)\\n                count+=mergeSort(R)\\n                j=0\\n                for i in range(len(L)):\\n                    while j<len(R) and L[i]>R[j]*2:\\n                        j+=1\\n                    count+=j\\n                \\n                # Merging Starts\\n                i,j,k=0,0,0\\n                while(i<len(L) and j<len(R)):\\n                    if L[i]>R[j]:\\n                        nums[k]=R[j]\\n                        j+=1\\n                    else:\\n                        nums[k]=L[i]\\n                        i+=1\\n                    k+=1\\n                while(i<len(L)):\\n                    nums[k]=L[i]\\n                    k+=1\\n                    i+=1\\n                while(j<len(R)):\\n                    nums[k]=R[j]\\n                    j+=1\\n                    k+=1\\n            return count\\n        return mergeSort(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        def mergeSort(nums):\\n            count=0\\n            if len(nums)>1:\\n                mid=len(nums)//2\\n                L=nums[:mid]\\n                R=nums[mid:]\\n                count+=mergeSort(L)\\n                count+=mergeSort(R)\\n                j=0\\n                for i in range(len(L)):\\n                    while j<len(R) and L[i]>R[j]*2:\\n                        j+=1\\n                    count+=j\\n                \\n                # Merging Starts\\n                i,j,k=0,0,0\\n                while(i<len(L) and j<len(R)):\\n                    if L[i]>R[j]:\\n                        nums[k]=R[j]\\n                        j+=1\\n                    else:\\n                        nums[k]=L[i]\\n                        i+=1\\n                    k+=1\\n                while(i<len(L)):\\n                    nums[k]=L[i]\\n                    k+=1\\n                    i+=1\\n                while(j<len(R)):\\n                    nums[k]=R[j]\\n                    j+=1\\n                    k+=1\\n            return count\\n        return mergeSort(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321653,
                "title": "count-inversion-format-o-nlgn-merge-sort-solution",
                "content": "**This is an extended version of inversion count\\nHere we will merge the two arrays but before we will count the inversions as per the given condition**\\n\\nPlease upvote if it helps!!!\\n```\\nclass Solution {\\npublic:\\n    int inversions;\\n    void merge(vector<int>& nums, int left, int mid, int right) {\\n        int m = mid-left+1;\\n        int n = right - mid;\\n        vector<int> l(m), r(n);\\n        \\n        for(int i=0; i<m; i++) l[i] = nums[left+i];\\n        for(int i=0; i<n; i++) r[i] = nums[mid+i+1];\\n        \\n        long long p;\\n        int i = 0, j = 0, k = left;\\n\\t\\t// in this loop we will check our condition nums[i] > 2*nums[j]\\n        while(i<m and j<n) {\\n            p = (long long)r[j]*2;\\n            if(l[i]>p) {\\n                inversions += m-i;\\n                j++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        i = 0, j = 0;\\n        // here in this loop we will actually merge the array\\n        while(i<m and j<n) {\\n            if(l[i]>r[j]) {\\n                nums[k++] = r[j++];\\n            } else {\\n                nums[k++] = l[i++];\\n            }\\n        }\\n        \\n        while(i<m) nums[k++] = l[i++];\\n        while(j<n) nums[k++] = r[j++];\\n    }\\n    void util(vector<int>& nums, int left, int right) {\\n        if(left>=right) return;\\n        \\n        int mid = left + (right-left)/2;\\n        \\n        util(nums, left, mid);\\n        util(nums, mid+1, right);\\n        merge(nums, left, mid, right);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        inversions = 0;\\n        util(nums, 0, n-1);\\n        \\n        return inversions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int inversions;\\n    void merge(vector<int>& nums, int left, int mid, int right) {\\n        int m = mid-left+1;\\n        int n = right - mid;\\n        vector<int> l(m), r(n);\\n        \\n        for(int i=0; i<m; i++) l[i] = nums[left+i];\\n        for(int i=0; i<n; i++) r[i] = nums[mid+i+1];\\n        \\n        long long p;\\n        int i = 0, j = 0, k = left;\\n\\t\\t// in this loop we will check our condition nums[i] > 2*nums[j]\\n        while(i<m and j<n) {\\n            p = (long long)r[j]*2;\\n            if(l[i]>p) {\\n                inversions += m-i;\\n                j++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        i = 0, j = 0;\\n        // here in this loop we will actually merge the array\\n        while(i<m and j<n) {\\n            if(l[i]>r[j]) {\\n                nums[k++] = r[j++];\\n            } else {\\n                nums[k++] = l[i++];\\n            }\\n        }\\n        \\n        while(i<m) nums[k++] = l[i++];\\n        while(j<n) nums[k++] = r[j++];\\n    }\\n    void util(vector<int>& nums, int left, int right) {\\n        if(left>=right) return;\\n        \\n        int mid = left + (right-left)/2;\\n        \\n        util(nums, left, mid);\\n        util(nums, mid+1, right);\\n        merge(nums, left, mid, right);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        inversions = 0;\\n        util(nums, 0, n-1);\\n        \\n        return inversions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297135,
                "title": "python-recursive-merge-sort-o-nlogn-time-o-n-space-80-time-42-space",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        output = 0\\n        \\n        def merge(left, right):\\n            nonlocal output\\n            l, r = 0, 0\\n            while l < len(left) and r < len(right):\\n                if left[l] > 2 * right[r]:\\n                    output += len(left) - l\\n                    r += 1\\n                else: l += 1\\n            return sorted(left + right)\\n\\n        def merge_sort(arr):\\n            if len(arr) <= 1: return arr\\n            mid = len(arr) // 2\\n            return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:]))\\n        \\n        merge_sort(nums)\\n        return output",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        output = 0\\n        \\n        def merge(left, right):\\n            nonlocal output\\n            l, r = 0, 0\\n            while l < len(left) and r < len(right):\\n                if left[l] > 2 * right[r]:\\n                    output += len(left) - l\\n                    r += 1\\n                else: l += 1\\n            return sorted(left + right)\\n\\n        def merge_sort(arr):\\n            if len(arr) <= 1: return arr\\n            mid = len(arr) // 2\\n            return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:]))\\n        \\n        merge_sort(nums)\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 2183513,
                "title": "merge-sort-striver-s-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int merge(vector<int>& nums, int l, int mid, int h) {\\n        \\n        int total = 0;\\n        int j = mid+1 ;\\n        for(int i = l; i<=mid; i++) {\\n            while(j<=h && nums[i] > 2ll*nums[j]) {\\n                j++;\\n            }\\n            total += (j-(mid+1));\\n        }\\n        vector<int> temp;\\n        int left = l, right = mid+1;\\n        while(left<=mid && right<=h) {\\n            if(nums[left] <= nums[right]) {\\n                temp.push_back(nums[left++]);\\n            } else {\\n                temp.push_back(nums[right++]);\\n            }\\n        }\\n        while(left<=mid) {\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right<=h) {\\n            temp.push_back(nums[right++]);\\n        }\\n        for(int i=l; i<=h; i++) {\\n            nums[i] = temp[i-l];\\n        }\\n        return total;\\n    }\\n    \\n    int mergeSort(vector<int>& nums, int l, int h) {\\n        \\n        if(l >= h) return 0;\\n        int mid = (l+h)/2;\\n        int p = mergeSort(nums, l, mid);\\n        p += mergeSort(nums, mid+1, h);\\n        p += merge(nums, l, mid, h);\\n        return p;\\n        \\n    } \\n    \\n    int reversePairs(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        return mergeSort(nums, 0, n-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int merge(vector<int>& nums, int l, int mid, int h) {\\n        \\n        int total = 0;\\n        int j = mid+1 ;\\n        for(int i = l; i<=mid; i++) {\\n            while(j<=h && nums[i] > 2ll*nums[j]) {\\n                j++;\\n            }\\n            total += (j-(mid+1));\\n        }\\n        vector<int> temp;\\n        int left = l, right = mid+1;\\n        while(left<=mid && right<=h) {\\n            if(nums[left] <= nums[right]) {\\n                temp.push_back(nums[left++]);\\n            } else {\\n                temp.push_back(nums[right++]);\\n            }\\n        }\\n        while(left<=mid) {\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right<=h) {\\n            temp.push_back(nums[right++]);\\n        }\\n        for(int i=l; i<=h; i++) {\\n            nums[i] = temp[i-l];\\n        }\\n        return total;\\n    }\\n    \\n    int mergeSort(vector<int>& nums, int l, int h) {\\n        \\n        if(l >= h) return 0;\\n        int mid = (l+h)/2;\\n        int p = mergeSort(nums, l, mid);\\n        p += mergeSort(nums, mid+1, h);\\n        p += merge(nums, l, mid, h);\\n        return p;\\n        \\n    } \\n    \\n    int reversePairs(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        return mergeSort(nums, 0, n-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161400,
                "title": "similar-to-inverse-count",
                "content": "# This is similar to classic question of Inversion Count\\n\\n## *How do we solve the innversion count problem?*\\n\\n### Please click here to view : [Inversion Count Problem](https://www.codingninjas.com/codestudio/problems/615?topList=striver-sde-sheet-problems&utm_source=striver&utm_medium=website)\\n\\nWe basically split the array using mergeSort technique. We keep on dividing until there is single element. Now, we will compare the two arrays (as we do in merge sort), we keep on combining the sorted array and keep the count of Array A, Array B and from the intersection of Array A and B.\\n\\nThe solution code for inversion sort!\\n```\\n#include <bits/stdc++.h> \\nlong long inversion(long long *arr,int s, int m,int e)\\n    {\\n        long *temp = new long[e-s+1];\\n        int k=0;\\n        long long count=0;\\n        int i=s,j=m+1;\\n        while(i<=m and j<=e)\\n        {\\n            if(arr[i]>arr[j])\\n            {\\n                count+=(m-i+1);\\n                temp[k++]=arr[j++];\\n            }\\n            else\\n                temp[k++]=arr[i++];\\n                \\n        }\\n        \\n        while(i<=m)\\n            temp[k++]=arr[i++];\\n        while(j<=e)\\n            temp[k++]=arr[j++];\\n         k=0;\\n        for(int i=s;i<=e;i++)\\n            arr[i]=temp[k++];\\n        \\n        delete []temp;\\n    return count;\\n    }\\n    long long merge(long long *arr, int s, int e)\\n    {\\n        if(s>=e)\\n            return 0;\\n        \\n        int m=s+(e-s)/2;\\n        long long x= merge(arr,s,m);\\n        long long y= merge(arr,m+1,e);\\n        long long z=inversion(arr,s,m,e);\\n        return x+y+z;\\n    }\\nlong long getInversions(long long *arr, int n)\\n{\\n    return merge(arr,0,n-1);\\n    // Write your code here.\\n}\\n```\\nYou can view [this](https://www.youtube.com/watch?v=owZhw-A0yWE) for better understanding\\n\\n\\n## Now this is a similar question\\nThe only difference here is we sort the arrays at the end and not during the count.\\n```\\nclass Solution {\\npublic:\\n    \\n    int inverse(vector<int>& nums, int s, int e, int m)\\n    {\\n        int c=0;\\n        vector<int> temp;\\n        int i=s,j=m+1;\\n        while(i<=m and j<=e)\\n        {\\n            long long a=nums[i];\\n            long long b= nums[j];\\n            b*=2;\\n            if(a>b)\\n            {\\n                //cout<<nums[i]<<\"at \"<<i<<\" , and \"<<nums[j]<<\" at \"<<j<<endl;\\n                c+=(m-i+1);\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        i=s,j=m+1;\\n        while(i<=m and j<=e)\\n        {\\n            if(nums[i]>nums[j])\\n                temp.push_back(nums[j++]);\\n            else\\n                temp.push_back(nums[i++]);\\n        }\\n        \\n        while(i<=m)\\n            temp.push_back(nums[i++]);\\n        while(j<=e)\\n            temp.push_back(nums[j++]);\\n        \\n        int k=0;\\n        for(int i=s;i<=e;i++)\\n            nums[i]=temp[k++];\\n            \\n        //cout<<c<<endl;\\n        return c;\\n        \\n    }\\n    \\n    int merge(vector<int>& nums, int s, int e)\\n    {\\n        if(s>=e)\\n            return 0;\\n        int m=s+(e-s)/2;\\n        int x= merge(nums,s,m);\\n        int y=merge(nums,m+1,e);\\n        int z=inverse(nums,s,e,m);\\n        \\n        return x+y+z;\\n    }\\n              \\n              \\n              \\n    int reversePairs(vector<int>& nums) \\n    {\\n        return merge(nums,0,nums.size()-1);\\n        \\n    }\\n};\\n```\\n\\nYou can view [this](https://www.youtube.com/watch?v=bAPRYelGrdM) for better understanding\\n",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h> \\nlong long inversion(long long *arr,int s, int m,int e)\\n    {\\n        long *temp = new long[e-s+1];\\n        int k=0;\\n        long long count=0;\\n        int i=s,j=m+1;\\n        while(i<=m and j<=e)\\n        {\\n            if(arr[i]>arr[j])\\n            {\\n                count+=(m-i+1);\\n                temp[k++]=arr[j++];\\n            }\\n            else\\n                temp[k++]=arr[i++];\\n                \\n        }\\n        \\n        while(i<=m)\\n            temp[k++]=arr[i++];\\n        while(j<=e)\\n            temp[k++]=arr[j++];\\n         k=0;\\n        for(int i=s;i<=e;i++)\\n            arr[i]=temp[k++];\\n        \\n        delete []temp;\\n    return count;\\n    }\\n    long long merge(long long *arr, int s, int e)\\n    {\\n        if(s>=e)\\n            return 0;\\n        \\n        int m=s+(e-s)/2;\\n        long long x= merge(arr,s,m);\\n        long long y= merge(arr,m+1,e);\\n        long long z=inversion(arr,s,m,e);\\n        return x+y+z;\\n    }\\nlong long getInversions(long long *arr, int n)\\n{\\n    return merge(arr,0,n-1);\\n    // Write your code here.\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int inverse(vector<int>& nums, int s, int e, int m)\\n    {\\n        int c=0;\\n        vector<int> temp;\\n        int i=s,j=m+1;\\n        while(i<=m and j<=e)\\n        {\\n            long long a=nums[i];\\n            long long b= nums[j];\\n            b*=2;\\n            if(a>b)\\n            {\\n                //cout<<nums[i]<<\"at \"<<i<<\" , and \"<<nums[j]<<\" at \"<<j<<endl;\\n                c+=(m-i+1);\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        i=s,j=m+1;\\n        while(i<=m and j<=e)\\n        {\\n            if(nums[i]>nums[j])\\n                temp.push_back(nums[j++]);\\n            else\\n                temp.push_back(nums[i++]);\\n        }\\n        \\n        while(i<=m)\\n            temp.push_back(nums[i++]);\\n        while(j<=e)\\n            temp.push_back(nums[j++]);\\n        \\n        int k=0;\\n        for(int i=s;i<=e;i++)\\n            nums[i]=temp[k++];\\n            \\n        //cout<<c<<endl;\\n        return c;\\n        \\n    }\\n    \\n    int merge(vector<int>& nums, int s, int e)\\n    {\\n        if(s>=e)\\n            return 0;\\n        int m=s+(e-s)/2;\\n        int x= merge(nums,s,m);\\n        int y=merge(nums,m+1,e);\\n        int z=inverse(nums,s,e,m);\\n        \\n        return x+y+z;\\n    }\\n              \\n              \\n              \\n    int reversePairs(vector<int>& nums) \\n    {\\n        return merge(nums,0,nums.size()-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2154576,
                "title": "python-merge-sort-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\n        def mergesort(l, r):\\n            if l>=r: return 0\\n            \\n            mid = (l+r)//2\\n            count = mergesort(l,mid) + mergesort(mid+1,r)\\n            j = mid + 1\\n            \\n            for i in range(l, mid+1):\\n                while j<=r and nums[i] > 2 * nums[j]:\\n                    j+=1\\n                count += j - mid - 1\\n            \\n            nums[l:r+1] = sorted(nums[l:r+1])\\n            return count\\n        \\n        return mergesort(0, len(nums)-1)\\n```\\nFor example,\\ncalling: xyz --> \\nreturning: --> xyz\\nLet **nums = [1, 3, 2, 3, 1]**  and len = 5\\nreturn mergesort(0, len(nums) - 1 = 4) -->\\n\\n1. if l>=r = 0>=4 = False\\n1. mid = 0+4 / 2 = 2\\n1. `count = mergesort(0, 2) + mergesort(3, 4)`  --> \\n\\n* mergesort(0, 2)\\nif: 0>=2 = False\\nmid = 0+2 / 2 = 1 \\n`count = mergesort(0, 1) + mergesort(2, 2)`   --> \\n\\n* mergesort(0, 1)\\nif: 0>=1 = False\\nmid = 0+1 / 2 = 0 \\n`count = mergesort(0, 0) + mergesort(1, 1)` = 0 i.e.\\n[ mergesort(0, 0) -->\\nif: 0>=0 = True, return 0\\n--> mergesort(0, 1) -->\\nmergesort(1, 1) -->\\nif: 1>=1 = True, return 0\\n--> mergesort(0, 1) ]\\nj = mid + 1 = 1\\nfor: i = 0(included), 0 + 1(excluded)\\ni=0: while j <= r and nums[0] > 2  nums[1] = 1<=1 and 1 > 23 = True and False = False\\ncount = count + j - mid - 1 = 0 + 1 - 0 - 1 = 0\\nnums[0:2] = sorted(nums[0:2]) = **[1, 3, 2, 3, 1]** --> return count=0\\n\\n* --> mergesort(0, 2) -->\\nmergesort(2, 2) -->\\nif: 2>=2 = True, return 0\\n--> mergesort(0, 2)\\nj = mid + 1 = 2\\nfor: i = 0(included), 1 + 1(excluded) = 0,1\\ni=0: while: 2<=2 and 1 > 2  2 = True and False = False\\ncount = count + j - mid - 1 = 0 + 2 - 1 - 1 = 0\\ni=1: while: 2<=2 and 3 > 2  2 = True and False = False\\ncount = count + j - mid - 1 = 0 + 2 - 1 - 1 = 0\\nnums[0:3] = sorted(nums[0:3]) = **[1, 2, 3, 3, 1]** --> return count = 0\\n\\n* --> mergesort(0, 4) -->\\nmergesort(3, 4) -->\\nif: 3>=4 = False\\nmid = 3+4 / 2 = 3 \\n`count = mergesort(3, 3) + mergesort(4, 4)` = 1 i.e.\\n[ mergesort(3, 3)\\nif: 3>=3 = True, return 0\\n--> mergesort(3, 4) -->\\nmergesort(4, 4) \\nif: 4>=4 = True, return 0\\n--> mergesort(3, 4) ]\\nj = mid + 1 = 4\\nfor: i = 3(included), 4 + 1(excluded) = 3,4\\ni=3: while 4 <= 4 and nums[3] > 2  nums[4] = 4<=4 and 3 > 21 = True and True = True, j = j + 1 = 5\\nwhile 5 <= 4 and nums[3] > 2  nums[5] = False and out of range, exit while loop\\ni=4: while 5 <= 4 and nums[4] > 2  nums[4] = 4<=4 and 3 > 21 = False and True = False\\ncount = count + j - mid - 1 = 0 + 5 - 3 - 1 = 1\\nnums[3:4] = sorted(nums[0:2]) = **[1, 2, 3, 1, 3]** --> return **count=1**\\n\\n* --> mergesort(0, 4)   \\nj = mid + 1 = 3\\nfor: i = 0(included), 4 + 1(excluded) = 0,1,2\\ni=0: while: 3<=4 and 1 > 2  1 = True and False = False\\ncount = count + j - mid - 1 = 0 + 3 - 2 - 1 = 0\\ni=1: while: 3<=4 and 2 > 2  1 = True and False = False\\ncount = count + j - mid - 1 = 0 + 3 - 2 - 1 = 0\\ni=2: while: 3<=4 and 3 > 2  1 = True and True = True, j = j + 1 = 4\\nwhile: 4<=4 and 3 > 2  3 = True and False = False\\ncount = count + j - mid - 1 = 1 + 4 - 2 - 1 = 2\\nnums[0:4] = sorted(nums[0:4]) = **[1, 1, 2, 3, 3]** --> return **count = 2**",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\n        def mergesort(l, r):\\n            if l>=r: return 0\\n            \\n            mid = (l+r)//2\\n            count = mergesort(l,mid) + mergesort(mid+1,r)\\n            j = mid + 1\\n            \\n            for i in range(l, mid+1):\\n                while j<=r and nums[i] > 2 * nums[j]:\\n                    j+=1\\n                count += j - mid - 1\\n            \\n            nums[l:r+1] = sorted(nums[l:r+1])\\n            return count\\n        \\n        return mergesort(0, len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116539,
                "title": "easy-merge-sort-solution-o-nlogn",
                "content": "Step1: Perform Merge Sort\\nStep2: At the conquer step , before merging count no. of reverse pairs.\\n```\\nclass Solution {\\n    int count = 0;\\n    public void merge(int[] arr, int l, int m, int h){\\n        int lSize = m-l+1;\\n        int rSize = h-m;\\n        int[] left = new int[lSize];\\n        int[] right = new int[rSize];\\n        for(int i=0;i<lSize;i++){\\n            left[i] = arr[l+i];\\n        }\\n        for(int i=0;i<rSize;i++){\\n            right[i] = arr[m+1+i];\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while(i<lSize && j<rSize){\\n            long lN = (long)left[i];\\n            long rN = (long)2*right[j];\\n            if(lN > rN){\\n                count+=(lSize-i);\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        int k = l;\\n        i = 0;\\n        j = 0;\\n        while(i<lSize && j<rSize){\\n            if(left[i]<=right[j]){\\n                arr[k++] = left[i++];\\n            }else{\\n                arr[k++] = right[j++];\\n            }\\n            \\n        }\\n        while(i<lSize){\\n            arr[k++] = left[i++];\\n        }\\n        while(j<rSize){\\n            arr[k++] = right[j++];\\n        }\\n    }\\n    public void mergeSortUtil(int[] nums, int low, int high){\\n        if(low<high){\\n            int mid = low+(high-low)/2;\\n            mergeSortUtil(nums, low, mid);\\n            mergeSortUtil(nums, mid+1, high);\\n            merge(nums, low, mid, high);\\n        }\\n    }\\n    public int reversePairs(int[] nums) {\\n        mergeSortUtil(nums, 0, nums.length-1);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public void merge(int[] arr, int l, int m, int h){\\n        int lSize = m-l+1;\\n        int rSize = h-m;\\n        int[] left = new int[lSize];\\n        int[] right = new int[rSize];\\n        for(int i=0;i<lSize;i++){\\n            left[i] = arr[l+i];\\n        }\\n        for(int i=0;i<rSize;i++){\\n            right[i] = arr[m+1+i];\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while(i<lSize && j<rSize){\\n            long lN = (long)left[i];\\n            long rN = (long)2*right[j];\\n            if(lN > rN){\\n                count+=(lSize-i);\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        int k = l;\\n        i = 0;\\n        j = 0;\\n        while(i<lSize && j<rSize){\\n            if(left[i]<=right[j]){\\n                arr[k++] = left[i++];\\n            }else{\\n                arr[k++] = right[j++];\\n            }\\n            \\n        }\\n        while(i<lSize){\\n            arr[k++] = left[i++];\\n        }\\n        while(j<rSize){\\n            arr[k++] = right[j++];\\n        }\\n    }\\n    public void mergeSortUtil(int[] nums, int low, int high){\\n        if(low<high){\\n            int mid = low+(high-low)/2;\\n            mergeSortUtil(nums, low, mid);\\n            mergeSortUtil(nums, mid+1, high);\\n            merge(nums, low, mid, high);\\n        }\\n    }\\n    public int reversePairs(int[] nums) {\\n        mergeSortUtil(nums, 0, nums.length-1);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099609,
                "title": "c-mergesort-very-easy-tc-o-n-logn",
                "content": "```\\nclass Solution {\\nprivate:\\n    int merge(vector<int>& nums, int low, int mid, int high){\\n        int count = 0;\\n        int j = mid + 1;\\n        for(int i=low;i<mid+1;i++){\\n            while(j<=high and nums[i]>2LL*nums[j]){\\n                j++;\\n            }\\n            count += j - (mid+1);\\n        }\\n        \\n        vector<int> temp;\\n        int s = low, e = mid+1;\\n        while(s<=mid and e<=high){\\n            if(nums[s]<nums[e]) temp.push_back(nums[s++]);\\n            else temp.push_back(nums[e++]);\\n        }\\n        while(s<=mid) temp.push_back(nums[s++]);\\n        while(e<=high) temp.push_back(nums[e++]);\\n        \\n        int k=0;\\n        for(int i=low;i<=high;i++){\\n            nums[i] = temp[k++];\\n        }\\n        return count;\\n    }\\n    \\n    int mergeSort(vector<int>& nums, int low, int high){\\n        if(low>=high) return 0;\\n        int mid = low + (high-low)/2;\\n        int inv = mergeSort(nums, low, mid);\\n        inv += mergeSort(nums, mid+1, high);\\n        inv += merge(nums, low, mid, high);\\n        return inv;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums, 0, nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int merge(vector<int>& nums, int low, int mid, int high){\\n        int count = 0;\\n        int j = mid + 1;\\n        for(int i=low;i<mid+1;i++){\\n            while(j<=high and nums[i]>2LL*nums[j]){\\n                j++;\\n            }\\n            count += j - (mid+1);\\n        }\\n        \\n        vector<int> temp;\\n        int s = low, e = mid+1;\\n        while(s<=mid and e<=high){\\n            if(nums[s]<nums[e]) temp.push_back(nums[s++]);\\n            else temp.push_back(nums[e++]);\\n        }\\n        while(s<=mid) temp.push_back(nums[s++]);\\n        while(e<=high) temp.push_back(nums[e++]);\\n        \\n        int k=0;\\n        for(int i=low;i<=high;i++){\\n            nums[i] = temp[k++];\\n        }\\n        return count;\\n    }\\n    \\n    int mergeSort(vector<int>& nums, int low, int high){\\n        if(low>=high) return 0;\\n        int mid = low + (high-low)/2;\\n        int inv = mergeSort(nums, low, mid);\\n        inv += mergeSort(nums, mid+1, high);\\n        inv += merge(nums, low, mid, high);\\n        return inv;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums, 0, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065642,
                "title": "merge-sort-binary-search-c-sc-o-n-tc-o-nlogn",
                "content": "```\\nclass Solution {\\nprivate:\\n    int mergeSort(vector<int> &nums, int low, int high)\\n    {\\n        if(low>=high)   return 0;\\n        \\n        int mid=(low+high)/2;\\n        \\n        int cnt=mergeSort(nums,low,mid);\\n        cnt+=mergeSort(nums,mid+1,high);\\n        cnt+=merge(nums,low,mid,high);\\n        return cnt;\\n    }\\n    \\n    int merge(vector<int> &nums, int low, int mid, int high)\\n    {\\n        int total=0;\\n        int left = low;\\n        int right = mid+1;\\n        for(int i=right;i<=high;i++){\\n            long long val = 2LL*nums[i];\\n            long long ind = upper_bound(nums.begin()+left,nums.begin()+right,val)-nums.begin();\\n            if(ind<right){\\n                total+=(right-ind);\\n            }\\n        }\\n        vector<int> temp;\\n        while(left<=mid && right<=high){\\n           \\n            if(nums[left]>nums[right]){\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n            else{\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n        }\\n        \\n        while(left<=mid)\\n            temp.push_back(nums[left++]);\\n        while(right<=high)\\n            temp.push_back(nums[right++]);\\n        \\n        for(int i=low;i<=high;i++)\\n            nums[i]=temp[i-low];\\n        \\n        return total;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mergeSort(vector<int> &nums, int low, int high)\\n    {\\n        if(low>=high)   return 0;\\n        \\n        int mid=(low+high)/2;\\n        \\n        int cnt=mergeSort(nums,low,mid);\\n        cnt+=mergeSort(nums,mid+1,high);\\n        cnt+=merge(nums,low,mid,high);\\n        return cnt;\\n    }\\n    \\n    int merge(vector<int> &nums, int low, int mid, int high)\\n    {\\n        int total=0;\\n        int left = low;\\n        int right = mid+1;\\n        for(int i=right;i<=high;i++){\\n            long long val = 2LL*nums[i];\\n            long long ind = upper_bound(nums.begin()+left,nums.begin()+right,val)-nums.begin();\\n            if(ind<right){\\n                total+=(right-ind);\\n            }\\n        }\\n        vector<int> temp;\\n        while(left<=mid && right<=high){\\n           \\n            if(nums[left]>nums[right]){\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n            else{\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n        }\\n        \\n        while(left<=mid)\\n            temp.push_back(nums[left++]);\\n        while(right<=high)\\n            temp.push_back(nums[right++]);\\n        \\n        for(int i=low;i<=high;i++)\\n            nums[i]=temp[i-low];\\n        \\n        return total;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985870,
                "title": "java-solution-binary-search-with-explanation",
                "content": "# Approach\\n*   Make a List for storing all values of nums and sort it in ascending order\\n*   And traverse from start of nums\\n*   for start value of nums, delete start value of nums from list using binary search\\n*   find atmost index in list for given reverse condition in qestion eg. nums[i] > 2*nums[j] using second binary search\\n*   And finally  add this atmost index in ans and never forget for adding 1 ( because index start from 0)\\n*   this trversal is happen for all nums value;\\n*   Time Complexity :- **nlog(n)**\\n\\n\\nIf you like this solution please upvote it.\\n```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        int ans = 0 , n = nums.length;\\n        List<Integer>list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            list.add(nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// sorting list\\n        Collections.sort(list);\\n\\t\\t\\n        for(int i = 0; i < n; i++){\\n\\t\\t\\n            int start = 0 , end = list.size() -1;\\n\\t\\t\\t// find nums[i] in list and remove from list using binary search in log(n) time .\\n            while(start <= end){\\n                int mid = start + (end - start)/2;\\n                if(nums[i]  == list.get(mid)){\\n                    list.remove(mid);\\n                    break;\\n                }else if(nums[i] < list.get(mid))end = mid - 1;\\n                else start = mid + 1;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// here  using one more times binary search for finding atmost index\\n\\t\\t\\t//to correct for reverse condition(given in question) in log(n) time .\\n\\t\\t\\t\\n            start = 0; end = list.size() - 1;\\n            int val = 0;\\n            while(start <= end){\\n                int mid = start + (end - start)/2;\\n                if(nums[i] > (long)2*list.get(mid)){\\n                    if((mid + 1) > val) val = mid + 1; // add atmost index in ans + 1\\n                    start = mid + 1;\\n                }else end = mid - 1;\\n            }\\n\\t\\t\\t\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        int ans = 0 , n = nums.length;\\n        List<Integer>list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            list.add(nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// sorting list\\n        Collections.sort(list);\\n\\t\\t\\n        for(int i = 0; i < n; i++){\\n\\t\\t\\n            int start = 0 , end = list.size() -1;\\n\\t\\t\\t// find nums[i] in list and remove from list using binary search in log(n) time .\\n            while(start <= end){\\n                int mid = start + (end - start)/2;\\n                if(nums[i]  == list.get(mid)){\\n                    list.remove(mid);\\n                    break;\\n                }else if(nums[i] < list.get(mid))end = mid - 1;\\n                else start = mid + 1;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// here  using one more times binary search for finding atmost index\\n\\t\\t\\t//to correct for reverse condition(given in question) in log(n) time .\\n\\t\\t\\t\\n            start = 0; end = list.size() - 1;\\n            int val = 0;\\n            while(start <= end){\\n                int mid = start + (end - start)/2;\\n                if(nums[i] > (long)2*list.get(mid)){\\n                    if((mid + 1) > val) val = mid + 1; // add atmost index in ans + 1\\n                    start = mid + 1;\\n                }else end = mid - 1;\\n            }\\n\\t\\t\\t\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903144,
                "title": "c-mergsort-concept-made-easy-this-question",
                "content": "if you like please upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int merge(vector<int>& nums, int low, int mid, int high){\\n        int count=0;\\n        int j=mid+1;\\n        \\n        for(int i=low; i<=mid; i++){\\n            while(j<=high and nums[i] > 2LL * nums[j]){\\n                j++;\\n            }\\n            count += j-(mid+1);\\n        }\\n        \\n        vector<int> temp;\\n        int left =low, right= mid+1;\\n        \\n        while(left<=mid and right<=high){\\n            if(nums[left] > nums[right]){\\n                temp.push_back(nums[right]);\\n                right++;\\n            }else{\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n        }\\n        \\n        while(left<=mid){\\n            temp.push_back(nums[left]);\\n            left++;\\n            }\\n          \\n        while(right<=high){\\n            temp.push_back(nums[right]);\\n            right++;\\n            }\\n        \\n        for(int i=low; i<=high; i++){\\n            nums[i] = temp[i-low];\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    int mergesort(vector<int>& nums, int low , int high){\\n        if(low>=high) return 0;\\n        int mid = low+(high-low)/2;\\n        int inv = mergesort(nums,low, mid);\\n        inv += mergesort(nums,mid+1,high);\\n        inv += merge(nums,low,mid,high);\\n        return inv;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        return mergesort(nums,0, nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int merge(vector<int>& nums, int low, int mid, int high){\\n        int count=0;\\n        int j=mid+1;\\n        \\n        for(int i=low; i<=mid; i++){\\n            while(j<=high and nums[i] > 2LL * nums[j]){\\n                j++;\\n            }\\n            count += j-(mid+1);\\n        }\\n        \\n        vector<int> temp;\\n        int left =low, right= mid+1;\\n        \\n        while(left<=mid and right<=high){\\n            if(nums[left] > nums[right]){\\n                temp.push_back(nums[right]);\\n                right++;\\n            }else{\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n        }\\n        \\n        while(left<=mid){\\n            temp.push_back(nums[left]);\\n            left++;\\n            }\\n          \\n        while(right<=high){\\n            temp.push_back(nums[right]);\\n            right++;\\n            }\\n        \\n        for(int i=low; i<=high; i++){\\n            nums[i] = temp[i-low];\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    int mergesort(vector<int>& nums, int low , int high){\\n        if(low>=high) return 0;\\n        int mid = low+(high-low)/2;\\n        int inv = mergesort(nums,low, mid);\\n        inv += mergesort(nums,mid+1,high);\\n        inv += merge(nums,low,mid,high);\\n        return inv;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        return mergesort(nums,0, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794755,
                "title": "typescript-o-nlog-n-time-o-n-space",
                "content": "```\\n// THE APPROACH BEHIND THIS IS \\n\\n// 1. WE KEEP DEVIDING THE ARRAY IN TWO JUST LIKE WE DO IN MERGE SORT\\n\\n// 2. NOW AT SOME POINT WE GET TWO SUBARRAYS AFTER DIVIDING THE CURRENT SUBARRAY. LETS CALL THEM LEFT SUB ARRAY AND RIGHT SUBARRAY.\\n\\n// 3. WE HAVE POINTERS TO THE START INDICES OF BOTH SUBARRAYS.\\n\\n// 4. NOW WE START COMPARING THEM AND SINCE WE KNOW BOTH SUBARRAYS ARE SORTED WE CAN SAY THAT ALL THE INTEGERS TO THE LEFT OF AN INTEGER ARE SMALLER THAN IT AND ALL THE NUMBERS TO THE RIGHT ARE BIGGER THAN THAT INTEGER.\\n\\n// 5. NOW USING THIS WE KEEP CHECKING THE GIVEN CONDITION OF NUMS[I] > 2NUMS[J] AND MOVE OUR POINTERS ACCORDINGLY.\\n\\n// 6. NOW TO MAINTAIN THE FACT THAT BOTH LEFT SUBARRAAY AND RIGHT SUBARRAY ARE SORTED FOR FURTHER REFERENCE, WE MERGE THE CURRENT SUBARRAYS WHILE SORTING THEM JUST LIKE MERGE SORT.\\n\\n//PS: the code just seems bigger because of most of merge sort logic but actual logic code is not that much. So please don\\'t get frustrated by the length of the code just like me.\\n\\nfunction reversePairs(nums: number[]): number {\\n    return mergeSort(nums,0,nums.length-1);\\n};\\n\\nfunction merge(nums: number[],left: number,mid: number,right: number): number {\\n    let i = left;\\n    let j = mid;\\n    let k = 0;\\n    let temp = new Array(right - left + 1).fill(0);\\n    let pairCount = 0;\\n    \\n    // HERE WE ARE COUNTING THE REVERSED PAIRS \\n    while(i < mid && j <= right) {\\n        if(nums[i] > 2*nums[j]) {\\n            pairCount += (mid - i);     \\n            j++;\\n        } else {\\n            i++;\\n        }\\n    }\\n    // ALL THE CODE BELOW IS JUST TO SORT THE ARRAY JUST LIKE WE DO IN MERGE SORT\\n    i = left;\\n    j = mid;\\n    k = 0;\\n    while(i < mid && j <= right) {\\n        if(nums[i] > nums[j]) {\\n            temp[k] = nums[j];\\n            j++;\\n            k++;\\n        } else {\\n            temp[k] = nums[i];\\n            i++;\\n            k++;\\n        }\\n    }\\n    while(i < mid) {\\n        temp[k] = nums[i];\\n        i++;\\n        k++;\\n    }\\n    while(j <= right) {\\n        temp[k] = nums[j];\\n        j++;\\n        k++;\\n    }\\n    k = 0;\\n    while(left <= right ) {\\n        nums[left] = temp[k];\\n        k++;\\n        left++;\\n    }\\n    return pairCount;\\n}\\n\\nfunction mergeSort(nums: number[],left: number,right: number): number {\\n    let pairCount = 0;\\n    if(left < right) {\\n        let mid = Math.floor((right + left)/2)\\n        pairCount = mergeSort(nums,left,mid);\\n        pairCount += mergeSort(nums,mid+1,right);\\n        pairCount += merge(nums,left,mid+1,right);\\n    }\\n    return pairCount;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Merge Sort"
                ],
                "code": "```\\n// THE APPROACH BEHIND THIS IS \\n\\n// 1. WE KEEP DEVIDING THE ARRAY IN TWO JUST LIKE WE DO IN MERGE SORT\\n\\n// 2. NOW AT SOME POINT WE GET TWO SUBARRAYS AFTER DIVIDING THE CURRENT SUBARRAY. LETS CALL THEM LEFT SUB ARRAY AND RIGHT SUBARRAY.\\n\\n// 3. WE HAVE POINTERS TO THE START INDICES OF BOTH SUBARRAYS.\\n\\n// 4. NOW WE START COMPARING THEM AND SINCE WE KNOW BOTH SUBARRAYS ARE SORTED WE CAN SAY THAT ALL THE INTEGERS TO THE LEFT OF AN INTEGER ARE SMALLER THAN IT AND ALL THE NUMBERS TO THE RIGHT ARE BIGGER THAN THAT INTEGER.\\n\\n// 5. NOW USING THIS WE KEEP CHECKING THE GIVEN CONDITION OF NUMS[I] > 2NUMS[J] AND MOVE OUR POINTERS ACCORDINGLY.\\n\\n// 6. NOW TO MAINTAIN THE FACT THAT BOTH LEFT SUBARRAAY AND RIGHT SUBARRAY ARE SORTED FOR FURTHER REFERENCE, WE MERGE THE CURRENT SUBARRAYS WHILE SORTING THEM JUST LIKE MERGE SORT.\\n\\n//PS: the code just seems bigger because of most of merge sort logic but actual logic code is not that much. So please don\\'t get frustrated by the length of the code just like me.\\n\\nfunction reversePairs(nums: number[]): number {\\n    return mergeSort(nums,0,nums.length-1);\\n};\\n\\nfunction merge(nums: number[],left: number,mid: number,right: number): number {\\n    let i = left;\\n    let j = mid;\\n    let k = 0;\\n    let temp = new Array(right - left + 1).fill(0);\\n    let pairCount = 0;\\n    \\n    // HERE WE ARE COUNTING THE REVERSED PAIRS \\n    while(i < mid && j <= right) {\\n        if(nums[i] > 2*nums[j]) {\\n            pairCount += (mid - i);     \\n            j++;\\n        } else {\\n            i++;\\n        }\\n    }\\n    // ALL THE CODE BELOW IS JUST TO SORT THE ARRAY JUST LIKE WE DO IN MERGE SORT\\n    i = left;\\n    j = mid;\\n    k = 0;\\n    while(i < mid && j <= right) {\\n        if(nums[i] > nums[j]) {\\n            temp[k] = nums[j];\\n            j++;\\n            k++;\\n        } else {\\n            temp[k] = nums[i];\\n            i++;\\n            k++;\\n        }\\n    }\\n    while(i < mid) {\\n        temp[k] = nums[i];\\n        i++;\\n        k++;\\n    }\\n    while(j <= right) {\\n        temp[k] = nums[j];\\n        j++;\\n        k++;\\n    }\\n    k = 0;\\n    while(left <= right ) {\\n        nums[left] = temp[k];\\n        k++;\\n        left++;\\n    }\\n    return pairCount;\\n}\\n\\nfunction mergeSort(nums: number[],left: number,right: number): number {\\n    let pairCount = 0;\\n    if(left < right) {\\n        let mid = Math.floor((right + left)/2)\\n        pairCount = mergeSort(nums,left,mid);\\n        pairCount += mergeSort(nums,mid+1,right);\\n        pairCount += merge(nums,left,mid+1,right);\\n    }\\n    return pairCount;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1793423,
                "title": "c-mergesort",
                "content": "```\\npublic class Solution {\\n    public int ReversePairs(int[] nums) {\\n        int n = nums.Length - 1;\\n        return this.MergeSort(nums, 0, n);\\n    }\\n    \\n    private int MergeSort(int[] nums, int left, int right)\\n    {\\n        if (left >= right)\\n        {\\n            return 0;\\n        }\\n        \\n        int mid = left + (right - left) / 2;\\n        int res = 0;\\n        res += this.MergeSort(nums, left, mid);\\n        res += this.MergeSort(nums, mid + 1, right);\\n        res += this.Merge(nums, left, mid, right);\\n        \\n        return res;\\n    }\\n    \\n    private int Merge(int[] nums, int left, int mid, int right)\\n    {\\n        int count = 0;\\n        int[] sortedArray = new int[right - left + 1];\\n        int leftPartP = left;\\n        int rightPartP = mid + 1;\\n        \\n        while(leftPartP <= mid && rightPartP <= right)\\n        {\\n            if ((long)nums[leftPartP] > (long)2 * nums[rightPartP])\\n            {\\n                //\\u8FD9\\u91CC\\u56E0\\u4E3A\\u5DE6\\u53F3\\u4E24\\u4E2A\\u90E8\\u5206\\u662F\\u5206\\u5F00\\u7684\\uFF0C\\u800C\\u4E14\\u5DE6\\u53F3\\u90FD\\u662F\\u6392\\u5E8F\\u8FC7\\u5F97\\u6240\\u4EE5\\u53EA\\u9700\\u8981\\u627E\\u5DE6\\u8FB9\\u6BD4\\u53F3\\u8FB9\\u5927\\u7684\\u5C31\\u884C\\n                //1,3,4\\n                //1,2\\n                //\\u8FD9\\u91CC\\u4E0A\\u9762\\u5982\\u679CleftParP\\u6307\\u54113\\uFF0CrightPartP\\u6307\\u54111\\uFF0C\\u90A3\\u90A3\\u4E2A\\u65F6\\u50193\\u540E\\u9762\\u76844\\u4E5F\\u662F\\u7B26\\u5408\\u8981\\u6C42\\u7684\\n                //\\u6240\\u4EE5\\u53EA\\u9700\\u8981\\u8BA1\\u7B97\\u628A3\\u548C4\\u7B97\\u8FDB\\u53BB\\u5C31\\u884C\\u4E86\\uFF0C\\u4E5F\\u5C31\\u662F\\u4ECEmid - leftPartP + 1\\n                //\\u6CE8\\u610F\\u8FD9\\u91CCmid\\u4E0D\\u662FrightPartP\\n                count += mid - leftPartP + 1;\\n                //\\u56E0\\u4E3A\\u662Frightpart\\u90E8\\u5206\\u5C0F\\u6240\\u4EE5rightPartP\\u79FB\\u52A8\\uFF0C\\u8FD9\\u6837rightPartP\\u6307\\u5411\\u7684\\u6570\\u5B57\\u624D\\u4F1A\\u8D8A\\u6765\\u8D8A\\u5927\\n                rightPartP++;\\n            }\\n            else\\n            {\\n                leftPartP++;\\n            }\\n        }\\n        \\n        //\\u8FD9\\u91CC\\u5C31\\u662F\\u7ECF\\u5178\\u7684merge\\u90E8\\u5206\\n        leftPartP = left;\\n        rightPartP = mid + 1;\\n        int curIndex = 0;\\n        while (leftPartP <= mid && rightPartP <= right)\\n        {\\n            if (nums[leftPartP] > nums[rightPartP])\\n            {\\n                sortedArray[curIndex++] = nums[rightPartP++];\\n            }\\n            else\\n            {\\n                sortedArray[curIndex++] = nums[leftPartP++];\\n            }\\n        }\\n        \\n        while(leftPartP <= mid)\\n        {\\n            sortedArray[curIndex++] = nums[leftPartP++];\\n        }\\n        \\n        while(rightPartP <= right)\\n        {\\n            sortedArray[curIndex++] = nums[rightPartP++];\\n        }\\n        \\n        Array.Copy(sortedArray, 0, nums, left, right - left + 1);\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public int ReversePairs(int[] nums) {\\n        int n = nums.Length - 1;\\n        return this.MergeSort(nums, 0, n);\\n    }\\n    \\n    private int MergeSort(int[] nums, int left, int right)\\n    {\\n        if (left >= right)\\n        {\\n            return 0;\\n        }\\n        \\n        int mid = left + (right - left) / 2;\\n        int res = 0;\\n        res += this.MergeSort(nums, left, mid);\\n        res += this.MergeSort(nums, mid + 1, right);\\n        res += this.Merge(nums, left, mid, right);\\n        \\n        return res;\\n    }\\n    \\n    private int Merge(int[] nums, int left, int mid, int right)\\n    {\\n        int count = 0;\\n        int[] sortedArray = new int[right - left + 1];\\n        int leftPartP = left;\\n        int rightPartP = mid + 1;\\n        \\n        while(leftPartP <= mid && rightPartP <= right)\\n        {\\n            if ((long)nums[leftPartP] > (long)2 * nums[rightPartP])\\n            {\\n                //\\u8FD9\\u91CC\\u56E0\\u4E3A\\u5DE6\\u53F3\\u4E24\\u4E2A\\u90E8\\u5206\\u662F\\u5206\\u5F00\\u7684\\uFF0C\\u800C\\u4E14\\u5DE6\\u53F3\\u90FD\\u662F\\u6392\\u5E8F\\u8FC7\\u5F97\\u6240\\u4EE5\\u53EA\\u9700\\u8981\\u627E\\u5DE6\\u8FB9\\u6BD4\\u53F3\\u8FB9\\u5927\\u7684\\u5C31\\u884C\\n                //1,3,4\\n                //1,2\\n                //\\u8FD9\\u91CC\\u4E0A\\u9762\\u5982\\u679CleftParP\\u6307\\u54113\\uFF0CrightPartP\\u6307\\u54111\\uFF0C\\u90A3\\u90A3\\u4E2A\\u65F6\\u50193\\u540E\\u9762\\u76844\\u4E5F\\u662F\\u7B26\\u5408\\u8981\\u6C42\\u7684\\n                //\\u6240\\u4EE5\\u53EA\\u9700\\u8981\\u8BA1\\u7B97\\u628A3\\u548C4\\u7B97\\u8FDB\\u53BB\\u5C31\\u884C\\u4E86\\uFF0C\\u4E5F\\u5C31\\u662F\\u4ECEmid - leftPartP + 1\\n                //\\u6CE8\\u610F\\u8FD9\\u91CCmid\\u4E0D\\u662FrightPartP\\n                count += mid - leftPartP + 1;\\n                //\\u56E0\\u4E3A\\u662Frightpart\\u90E8\\u5206\\u5C0F\\u6240\\u4EE5rightPartP\\u79FB\\u52A8\\uFF0C\\u8FD9\\u6837rightPartP\\u6307\\u5411\\u7684\\u6570\\u5B57\\u624D\\u4F1A\\u8D8A\\u6765\\u8D8A\\u5927\\n                rightPartP++;\\n            }\\n            else\\n            {\\n                leftPartP++;\\n            }\\n        }\\n        \\n        //\\u8FD9\\u91CC\\u5C31\\u662F\\u7ECF\\u5178\\u7684merge\\u90E8\\u5206\\n        leftPartP = left;\\n        rightPartP = mid + 1;\\n        int curIndex = 0;\\n        while (leftPartP <= mid && rightPartP <= right)\\n        {\\n            if (nums[leftPartP] > nums[rightPartP])\\n            {\\n                sortedArray[curIndex++] = nums[rightPartP++];\\n            }\\n            else\\n            {\\n                sortedArray[curIndex++] = nums[leftPartP++];\\n            }\\n        }\\n        \\n        while(leftPartP <= mid)\\n        {\\n            sortedArray[curIndex++] = nums[leftPartP++];\\n        }\\n        \\n        while(rightPartP <= right)\\n        {\\n            sortedArray[curIndex++] = nums[rightPartP++];\\n        }\\n        \\n        Array.Copy(sortedArray, 0, nums, left, right - left + 1);\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718898,
                "title": "c-merge-sort-easy-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void merge(vector<int>& left, vector<int>& right, vector<int>& nums) {\\n        int i = 0, j = 0, k = 0;\\n        \\n        for (i = 0; i < left.size(); i++) {            \\n            while (j < right.size() && left[i] > right[j]*2LL)\\n                j++;\\n            count += j;\\n        }\\n        \\n        i = 0, j = 0;        \\n        while (i < left.size() && j < right.size()) {\\n            if (left[i] < right[j])\\n                nums[k++] = left[i++];\\n            else \\n                nums[k++] = right[j++];\\n        }\\n        \\n        while (i < left.size())\\n            nums[k++] = left[i++];\\n        \\n        while (j < right.size())\\n            nums[k++] = right[j++];\\n    }\\n    \\n    void mergeSort(vector<int>& nums) {\\n        if (nums.size() < 2)\\n            return;\\n        \\n        int mid = nums.size() / 2;\\n        vector <int> left;\\n        vector <int> right;\\n        \\n        for (int i = 0; i < mid; i++)\\n            left.push_back(nums[i]);\\n        \\n        for (int i = mid; i < nums.size(); i++)\\n            right.push_back(nums[i]);\\n        \\n        mergeSort(left);\\n        mergeSort(right);        \\n        \\n        merge(left, right, nums);\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void merge(vector<int>& left, vector<int>& right, vector<int>& nums) {\\n        int i = 0, j = 0, k = 0;\\n        \\n        for (i = 0; i < left.size(); i++) {            \\n            while (j < right.size() && left[i] > right[j]*2LL)\\n                j++;\\n            count += j;\\n        }\\n        \\n        i = 0, j = 0;        \\n        while (i < left.size() && j < right.size()) {\\n            if (left[i] < right[j])\\n                nums[k++] = left[i++];\\n            else \\n                nums[k++] = right[j++];\\n        }\\n        \\n        while (i < left.size())\\n            nums[k++] = left[i++];\\n        \\n        while (j < right.size())\\n            nums[k++] = right[j++];\\n    }\\n    \\n    void mergeSort(vector<int>& nums) {\\n        if (nums.size() < 2)\\n            return;\\n        \\n        int mid = nums.size() / 2;\\n        vector <int> left;\\n        vector <int> right;\\n        \\n        for (int i = 0; i < mid; i++)\\n            left.push_back(nums[i]);\\n        \\n        for (int i = mid; i < nums.size(); i++)\\n            right.push_back(nums[i]);\\n        \\n        mergeSort(left);\\n        mergeSort(right);        \\n        \\n        merge(left, right, nums);\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712321,
                "title": "adding-few-lines-in-merge-sort-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n\\nint merge(vector<int>&nums,int l,int mid ,int r)\\n{\\n\\tint n1=mid-l+1;\\n\\tint n2=r-mid;\\n\\tint a[n1];\\n\\tint b[n2];\\n\\tint pair=0;\\n\\tfor(int i=0;i<n1;i++)\\n\\t{\\n\\t\\ta[i]=nums[l+i];\\n\\t}\\n\\tfor(int j=0;j<n2;j++)\\n\\t{\\n\\t\\tb[j]=nums[mid+1+j];\\n\\t}\\n\\tint p=0;\\n\\tint m=0;\\n**Adding Some lines to check the pairs** \\n\\twhile(p<n1 and m<n2 )\\n\\t\\t{\\n\\t\\t\\t\\t\\tif((long)a[p]<=(long)2*b[m])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tp++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t m++;\\n\\t\\t\\t\\t\\t\\tpair+=n1-p;\\n\\n                        }\\n            }\\n                   \\n        int k=l,i=0,j=0;\\n        while(i<n1 and j<n2)\\n        {\\n            if(a[i]<=b[j])\\n            {\\n                nums[k]=a[i];\\n                i++;\\n                k++;\\n            }\\n            else \\n            {\\n                nums[k]=b[j];\\n\\t\\t\\t    k++;\\n                j++;\\n            }\\n        }\\n        while(i<n1)\\n        {\\n            nums[k]=a[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n2)\\n        {\\n            nums[k]=b[j];\\n            j++;\\n            k++;\\n        }\\n        return pair;\\n    }\\n \\t**Normal Merge Sort **\\n   int  mergesort(vector<int>&nums,int l,int r)\\n   {\\n       int pair=0;\\n       if(l>=r)\\n\\t   {\\n\\t   return 0;\\n\\t   }\\n\\t\\telse{\\n           int mid=(l+r)/2;\\n           pair+=mergesort(nums,l,mid);\\n           pair+=mergesort(nums,mid+1,r);\\n           pair+=merge(nums,l,mid,r);\\n       return pair;\\n\\t   }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n       return  mergesort(nums,0,n-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint merge(vector<int>&nums,int l,int mid ,int r)\\n{\\n\\tint n1=mid-l+1;\\n\\tint n2=r-mid;\\n\\tint a[n1];\\n\\tint b[n2];\\n\\tint pair=0;\\n\\tfor(int i=0;i<n1;i++)\\n\\t{\\n\\t\\ta[i]=nums[l+i];\\n\\t}\\n\\tfor(int j=0;j<n2;j++)\\n\\t{\\n\\t\\tb[j]=nums[mid+1+j];\\n\\t}\\n\\tint p=0;\\n\\tint m=0;\\n**Adding Some lines to check the pairs** \\n\\twhile(p<n1 and m<n2 )\\n\\t\\t{\\n\\t\\t\\t\\t\\tif((long)a[p]<=(long)2*b[m])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tp++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t m++;\\n\\t\\t\\t\\t\\t\\tpair+=n1-p;\\n\\n                        }\\n            }\\n                   \\n        int k=l,i=0,j=0;\\n        while(i<n1 and j<n2)\\n        {\\n            if(a[i]<=b[j])\\n            {\\n                nums[k]=a[i];\\n                i++;\\n                k++;\\n            }\\n            else \\n            {\\n                nums[k]=b[j];\\n\\t\\t\\t    k++;\\n                j++;\\n            }\\n        }\\n        while(i<n1)\\n        {\\n            nums[k]=a[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<n2)\\n        {\\n            nums[k]=b[j];\\n            j++;\\n            k++;\\n        }\\n        return pair;\\n    }\\n \\t**Normal Merge Sort **\\n   int  mergesort(vector<int>&nums,int l,int r)\\n   {\\n       int pair=0;\\n       if(l>=r)\\n\\t   {\\n\\t   return 0;\\n\\t   }\\n\\t\\telse{\\n           int mid=(l+r)/2;\\n           pair+=mergesort(nums,l,mid);\\n           pair+=mergesort(nums,mid+1,r);\\n           pair+=merge(nums,l,mid,r);\\n       return pair;\\n\\t   }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n       return  mergesort(nums,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666489,
                "title": "merge-sort-easy",
                "content": "```\\nclass Solution {\\nprivate:\\n    int count;\\n    void checkCount(vector<int>& nums, int start, int mid, int end) {\\n        int l = start, r = mid + 1;\\n        while (l <= mid && r <= end){\\n            if ((long) nums[l] > (long) 2 * nums[r]){\\n                count += (mid - l + 1);\\n                r++;\\n            }else {\\n                l++;\\n            }\\n        }\\n        int a[end - start + 1], t = 0;\\n        l = start, r = mid + 1;\\n        while (l <= mid and r <= end) {\\n            if (l <= mid and nums[l] < nums[r]) {\\n                a[t++] = nums[l++];\\n            } else {\\n                a[t++] = nums[r++];\\n            }\\n        }\\n        while (l <= mid) {\\n            a[t++] = nums[l++];\\n        }\\n        while (r <= end) {\\n            a[t++] = nums[r++];\\n        }\\n        for (int i = 0; i < end - start + 1; i++) {\\n            nums[start + i] = a[i];\\n        }\\n        return;\\n    }\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start == end) return;\\n        int mid = (start + end)/2;\\n        mergeSort(nums, start, mid);\\n        mergeSort(nums, mid + 1,end);\\n        checkCount(nums, start, mid, end);\\n        return;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (!nums.size()) return 0;\\n        count = 0;\\n        mergeSort(nums, 0, nums.size()-1);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int count;\\n    void checkCount(vector<int>& nums, int start, int mid, int end) {\\n        int l = start, r = mid + 1;\\n        while (l <= mid && r <= end){\\n            if ((long) nums[l] > (long) 2 * nums[r]){\\n                count += (mid - l + 1);\\n                r++;\\n            }else {\\n                l++;\\n            }\\n        }\\n        int a[end - start + 1], t = 0;\\n        l = start, r = mid + 1;\\n        while (l <= mid and r <= end) {\\n            if (l <= mid and nums[l] < nums[r]) {\\n                a[t++] = nums[l++];\\n            } else {\\n                a[t++] = nums[r++];\\n            }\\n        }\\n        while (l <= mid) {\\n            a[t++] = nums[l++];\\n        }\\n        while (r <= end) {\\n            a[t++] = nums[r++];\\n        }\\n        for (int i = 0; i < end - start + 1; i++) {\\n            nums[start + i] = a[i];\\n        }\\n        return;\\n    }\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start == end) return;\\n        int mid = (start + end)/2;\\n        mergeSort(nums, start, mid);\\n        mergeSort(nums, mid + 1,end);\\n        checkCount(nums, start, mid, end);\\n        return;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (!nums.size()) return 0;\\n        count = 0;\\n        mergeSort(nums, 0, nums.size()-1);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665325,
                "title": "java-explained-in-detail-merge-sort",
                "content": "// In each round, we divide our array into two parts and SORT them. So, the left part and the right part are sorted and now our only job is to count how many pairs of number (leftPart[i], rightPart[j]) satisfies leftPart[i] > 2 * rightPart[j].\\n\\n// TC : O(NlogN * logN) -> NlogN (from sort but it could be reduced to N by using myMerge())\\n// SC : O(1) -> no extra space is used other than stack of recursion (in case of using myMerge() func for sort, we would use O(N) space extra)\\n\\n```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length-1);\\n    }\\n    \\n    private int mergeSort(int[] nums, int start, int end){\\n        // next three lines are to split the array into half (each recursion until we get start >= end)\\n        if(start >= end) return 0; \\n        int mid = start + (end - start)/2; \\n        int cnt = mergeSort(nums, start, mid) + mergeSort(nums, mid+1, end); \\n         \\n        // \\'i\\' needs to be traversed for left half of array and every \\'j\\' (index of right half) will be compared with each \\'i\\'\\n        for(int i = start, j = mid+1; i <= mid; i++){\\n            while(j <= end && nums[i]/2.0 > nums[j]) j++; \\n            cnt += j-(mid+1); // since j starts from mid + 1 so we need to remove it from \\'j\\' to get actual count\\n        }\\n        Arrays.sort(nums, start, end + 1); \\n        return cnt; \\n    }\\n    \\n    // int[] helper;\\n    // private void myMerge(int[] nums, int start, int mid, int end){\\n    //     for(int i = start; i <= end; i++) helper[i] = nums[i];\\n    //     int p1 = start;     //pointer for left part\\n    //     int p2 = mid+1;     //pointer for rigth part\\n    //     int i = start;      //pointer for sorted array\\n    //     while(p1 <= mid || p2 <= end){\\n    //         if(p1 > mid || (p2 <= end && helper[p1] >= helper[p2])){\\n    //             nums[i++] = helper[p2++];\\n    //         }else{\\n    //             nums[i++] = helper[p1++];\\n    //         }\\n    //     }\\n    // }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length-1);\\n    }\\n    \\n    private int mergeSort(int[] nums, int start, int end){\\n        // next three lines are to split the array into half (each recursion until we get start >= end)\\n        if(start >= end) return 0; \\n        int mid = start + (end - start)/2; \\n        int cnt = mergeSort(nums, start, mid) + mergeSort(nums, mid+1, end); \\n         \\n        // \\'i\\' needs to be traversed for left half of array and every \\'j\\' (index of right half) will be compared with each \\'i\\'\\n        for(int i = start, j = mid+1; i <= mid; i++){\\n            while(j <= end && nums[i]/2.0 > nums[j]) j++; \\n            cnt += j-(mid+1); // since j starts from mid + 1 so we need to remove it from \\'j\\' to get actual count\\n        }\\n        Arrays.sort(nums, start, end + 1); \\n        return cnt; \\n    }\\n    \\n    // int[] helper;\\n    // private void myMerge(int[] nums, int start, int mid, int end){\\n    //     for(int i = start; i <= end; i++) helper[i] = nums[i];\\n    //     int p1 = start;     //pointer for left part\\n    //     int p2 = mid+1;     //pointer for rigth part\\n    //     int i = start;      //pointer for sorted array\\n    //     while(p1 <= mid || p2 <= end){\\n    //         if(p1 > mid || (p2 <= end && helper[p1] >= helper[p2])){\\n    //             nums[i++] = helper[p2++];\\n    //         }else{\\n    //             nums[i++] = helper[p1++];\\n    //         }\\n    //     }\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618110,
                "title": "c-solution-using-merge-sort",
                "content": "class Solution {\\n    private:\\n    int ans=0;\\n    \\n    void merge(vector<int>& arr,int l,int m,int r)\\n    {\\n        int i=l,j=m+1;\\n        vector<int> temp;\\n        \\n        while(i<=m && j<=r)\\n        {\\n            if(arr[i]<arr[j])\\n                temp.push_back(arr[i++]);\\n            else\\n                temp.push_back(arr[j++]);\\n        }\\n        \\n        while(i<=m)\\n            temp.push_back(arr[i++]);\\n        \\n        while(j<=r)\\n            temp.push_back(arr[j++]);\\n        \\n        i=0;\\n        for(int x=l;x<=r;x++)\\n            arr[x]=temp[i++];\\n    }\\n    \\n    \\n    void merge_sort(vector<int>& arr,int l,int r)\\n    {\\n        if(l<r)\\n        {\\n            //dividing array in two parts recursively\\n            int i,j;\\n            int mid=(l+r)/2;\\n            \\n            merge_sort(arr,l,mid);\\n            merge_sort(arr,mid+1,r);\\n            \\n            j=mid+1;\\n            long long temp;\\n            // counting pairs\\n            for(int i=l;i<=mid;i++)\\n            {\\n                while(j<=r && (long)arr[i]>(long)2*arr[j])\\n                    j++;\\n\\n                ans+=(j-(mid+1));\\n            }\\n            \\n            // merging sorted arrays\\n            merge(arr,l,mid,r);\\n        }\\n    }\\n    \\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        \\n        merge_sort(nums,0,nums.size()-1);\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n    private:\\n    int ans=0;\\n    \\n    void merge(vector<int>& arr,int l,int m,int r)\\n    {\\n        int i=l,j=m+1;\\n        vector<int> temp;\\n        \\n        while(i<=m && j<=r)\\n        {\\n            if(arr[i]<arr[j])\\n                temp.push_back(arr[i++]);\\n            else\\n                temp.push_back(arr[j++]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1550278,
                "title": "c-solution-using-bit-no-auxiliary-rank-array",
                "content": "The other solutions specifically added a ranks array for nums which I found pretty unintuitive to think about. \\nIn the solution I simply added the already seen elements and used a two pointer approach to \\ncount all ```j < i``` for which ```nums[j] > 2*nums[i]``` for each i \\n\\nTime Complexity: ```O(NlogN)```\\nRuntime: 148ms (better than 99.84%)\\n\\nSpace Complexity: ```O(N)```\\nMemory Usage: 53.5 MB (better than 67.41%)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void update(int i, vector<int> &arr) {\\n        int n = arr.size();\\n        while(i < n) {\\n            arr[i]++;\\n            i += i&-i;\\n        }\\n    }\\n    \\n    int val(int i, vector<int> &arr) {\\n        int res = 0;\\n        while(i > 0) {\\n            res += arr[i];\\n            i &= i-1;\\n        } \\n        \\n        return res;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> fen(n+1, 0);\\n        vector<pair<long long, int>> arr(n);\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            arr[i] = {(long long)nums[i], i};\\n        }\\n        \\n        sort(arr.begin(), arr.end(), greater<pair<long long, int>>());\\n        int j = 0;\\n        int res = 0;\\n        \\n        for(int i=0;i<n;i++) {\\n            while(j < n && arr[j].first > arr[i].first*2) {\\n                update(arr[j].second+1, fen);\\n                j++;\\n            }\\n            res += val(arr[i].second+1, fen) - (arr[i].first < 0 && j >= i);            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```j < i```\n```nums[j] > 2*nums[i]```\n```O(NlogN)```\n```O(N)```\n```\\nclass Solution {\\npublic:\\n    \\n    void update(int i, vector<int> &arr) {\\n        int n = arr.size();\\n        while(i < n) {\\n            arr[i]++;\\n            i += i&-i;\\n        }\\n    }\\n    \\n    int val(int i, vector<int> &arr) {\\n        int res = 0;\\n        while(i > 0) {\\n            res += arr[i];\\n            i &= i-1;\\n        } \\n        \\n        return res;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> fen(n+1, 0);\\n        vector<pair<long long, int>> arr(n);\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            arr[i] = {(long long)nums[i], i};\\n        }\\n        \\n        sort(arr.begin(), arr.end(), greater<pair<long long, int>>());\\n        int j = 0;\\n        int res = 0;\\n        \\n        for(int i=0;i<n;i++) {\\n            while(j < n && arr[j].first > arr[i].first*2) {\\n                update(arr[j].second+1, fen);\\n                j++;\\n            }\\n            res += val(arr[i].second+1, fen) - (arr[i].first < 0 && j >= i);            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464715,
                "title": "c-solution-faster-than-97-merge-sort-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int invcount;\\n    void mergeSort(vector<int>&nums,int l,int r)\\n    {\\n        if(r>l){\\n            int mid=l+(r-l)/2;\\n            mergeSort(nums,l,mid);\\n            mergeSort(nums,mid+1,r);\\n            merge(nums,l,mid,r);\\n            \\n        }\\n    }\\n    void merge(vector<int>&nums,int l,int m,int r)\\n    {\\n        int n1=m-l+1;int n2=r-m;\\n        int left[n1];int right[n2];\\n        \\n        for(int i=0;i<n1;i++)\\n        left[i]=nums[l+i];\\n        for(int i=0;i<n2;i++)\\n        right[i]=nums[m+1+i];\\n          \\n        int i=0,j=0;\\n         while(i<n1 && j<n2){\\n            if(left[i]/(2.0)>right[j]){\\n           \\n                invcount+=n1-i;\\n                j++;\\n            }\\n            else\\n                i++;\\n         }\\n         \\n         i=0,j=0;int k=l;\\n        while(i<n1 && j<n2)\\n        {\\n            if(left[i]<=right[j])\\n                nums[k++]=left[i++];\\n            else \\n                nums[k++]=right[j++];\\n        }    \\n        while(i<n1)\\n            nums[k++]=left[i++];\\n         while(j<n2)\\n            nums[k++]=right[j++];\\n        \\n    }\\n    int reversePairs(vector<int>&nums) {\\n         invcount=0;\\n        int n=nums.size();\\n        mergeSort(nums,0,n-1);\\n        \\n        return invcount;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int invcount;\\n    void mergeSort(vector<int>&nums,int l,int r)\\n    {\\n        if(r>l){\\n            int mid=l+(r-l)/2;\\n            mergeSort(nums,l,mid);\\n            mergeSort(nums,mid+1,r);\\n            merge(nums,l,mid,r);\\n            \\n        }\\n    }\\n    void merge(vector<int>&nums,int l,int m,int r)\\n    {\\n        int n1=m-l+1;int n2=r-m;\\n        int left[n1];int right[n2];\\n        \\n        for(int i=0;i<n1;i++)\\n        left[i]=nums[l+i];\\n        for(int i=0;i<n2;i++)\\n        right[i]=nums[m+1+i];\\n          \\n        int i=0,j=0;\\n         while(i<n1 && j<n2){\\n            if(left[i]/(2.0)>right[j]){\\n           \\n                invcount+=n1-i;\\n                j++;\\n            }\\n            else\\n                i++;\\n         }\\n         \\n         i=0,j=0;int k=l;\\n        while(i<n1 && j<n2)\\n        {\\n            if(left[i]<=right[j])\\n                nums[k++]=left[i++];\\n            else \\n                nums[k++]=right[j++];\\n        }    \\n        while(i<n1)\\n            nums[k++]=left[i++];\\n         while(j<n2)\\n            nums[k++]=right[j++];\\n        \\n    }\\n    int reversePairs(vector<int>&nums) {\\n         invcount=0;\\n        int n=nums.size();\\n        mergeSort(nums,0,n-1);\\n        \\n        return invcount;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403613,
                "title": "merge-sort-java-easy",
                "content": "```\\npublic class Solution {\\n    int Rp=0;\\n    \\n    void merge(int [] res,int [] A,int B[])\\n    {\\n        int n = A.length;\\n        int m = B.length;\\n  \\n \\n        int i = 0;\\n        int j = 0;\\n        int k = 0;\\n        while(i<n && j<m)\\n        {\\n            if((long)A[i]>2*(long)B[j])\\n            {\\n                j++;\\n                Rp = Rp+(n-i);\\n                \\n            }\\n            else\\n                i++;\\n        }\\n        i= 0;j=0;\\n        while(i<n&&j<m)\\n        {\\n        \\n            if(A[i]<=B[j])\\n                res[k++] = A[i++];\\n            else\\n                {\\n                res[k++] = B[j++];\\n                }\\n        }\\n        while(i<n)\\n            res[k++] = A[i++];\\n        while(j<m)\\n            res[k++] = B[j++];\\n\\n        \\n    }\\n    void mergeSort(int [] A)\\n    {\\n        \\n        int n = A.length;\\n        if(n<2)\\n        {\\n            return;\\n        }\\n        int mid = n/2;\\n        int n1 = mid;\\n        int n2 = n-mid;\\n        int [] left = new int [n1];\\n        int [] right = new int [n2];\\n        for(int i = 0;i<n1;i++)\\n            left[i] = A[i];\\n        int j = 0;\\n        for(int i = (int)mid;i<n;i++)\\n            right[j++] = A[i];\\n        mergeSort(right);\\n        mergeSort(left);\\n        merge(A,left,right);\\n    }\\n    public int reversePairs(int[] A) {\\n        \\n        mergeSort(A);\\n\\n        return Rp;\\n    }\\n}\\n\\n```\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\npublic class Solution {\\n    int Rp=0;\\n    \\n    void merge(int [] res,int [] A,int B[])\\n    {\\n        int n = A.length;\\n        int m = B.length;\\n  \\n \\n        int i = 0;\\n        int j = 0;\\n        int k = 0;\\n        while(i<n && j<m)\\n        {\\n            if((long)A[i]>2*(long)B[j])\\n            {\\n                j++;\\n                Rp = Rp+(n-i);\\n                \\n            }\\n            else\\n                i++;\\n        }\\n        i= 0;j=0;\\n        while(i<n&&j<m)\\n        {\\n        \\n            if(A[i]<=B[j])\\n                res[k++] = A[i++];\\n            else\\n                {\\n                res[k++] = B[j++];\\n                }\\n        }\\n        while(i<n)\\n            res[k++] = A[i++];\\n        while(j<m)\\n            res[k++] = B[j++];\\n\\n        \\n    }\\n    void mergeSort(int [] A)\\n    {\\n        \\n        int n = A.length;\\n        if(n<2)\\n        {\\n            return;\\n        }\\n        int mid = n/2;\\n        int n1 = mid;\\n        int n2 = n-mid;\\n        int [] left = new int [n1];\\n        int [] right = new int [n2];\\n        for(int i = 0;i<n1;i++)\\n            left[i] = A[i];\\n        int j = 0;\\n        for(int i = (int)mid;i<n;i++)\\n            right[j++] = A[i];\\n        mergeSort(right);\\n        mergeSort(left);\\n        merge(A,left,right);\\n    }\\n    public int reversePairs(int[] A) {\\n        \\n        mergeSort(A);\\n\\n        return Rp;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371757,
                "title": "mergesort-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int merge(vector<int>& nums, vector<int>& temp, int l, int mid, int r){\\n        int i=l,j=mid,k=l;\\n        long long int ans=0;\\n        while(i<mid)\\n        {\\n            while(j<=r && (2LL*nums[j])<nums[i])\\n                j++;\\n            ans+=j-mid;\\n            i++;\\n        }\\n        i=l;\\n        j=mid;\\n        while(i<mid && j<=r){\\n            if(nums[i]<=nums[j]){\\n                temp[k]=nums[i];\\n                k++;\\n                i++;\\n            }\\n            else{\\n                temp[k]=nums[j];\\n                k++;\\n                j++;\\n            }\\n        }\\n        while(i<mid){\\n            temp[k]=nums[i];\\n            k++;\\n            i++;\\n        }\\n        while(j<=r){\\n            temp[k]=nums[j];\\n            k++;\\n            j++;\\n        }\\n        for(int i=l;i<=r;i++)\\n            nums[i]=temp[i];\\n        return ans;\\n    }\\n    long long int mergeSort(vector<int>& nums, vector<int>& temp, int st, int end){\\n        if(st>=end)\\n            return 0;\\n        int mid=st+(end-st)/2;\\n        long long int ans=0;\\n        ans+=mergeSort(nums, temp, st, mid);\\n        ans+=mergeSort(nums, temp, mid+1, end);\\n        \\n        ans+=merge(nums, temp, st, mid+1, end);\\n        return ans;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp(n);\\n        return mergeSort(nums, temp, 0, n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int merge(vector<int>& nums, vector<int>& temp, int l, int mid, int r){\\n        int i=l,j=mid,k=l;\\n        long long int ans=0;\\n        while(i<mid)\\n        {\\n            while(j<=r && (2LL*nums[j])<nums[i])\\n                j++;\\n            ans+=j-mid;\\n            i++;\\n        }\\n        i=l;\\n        j=mid;\\n        while(i<mid && j<=r){\\n            if(nums[i]<=nums[j]){\\n                temp[k]=nums[i];\\n                k++;\\n                i++;\\n            }\\n            else{\\n                temp[k]=nums[j];\\n                k++;\\n                j++;\\n            }\\n        }\\n        while(i<mid){\\n            temp[k]=nums[i];\\n            k++;\\n            i++;\\n        }\\n        while(j<=r){\\n            temp[k]=nums[j];\\n            k++;\\n            j++;\\n        }\\n        for(int i=l;i<=r;i++)\\n            nums[i]=temp[i];\\n        return ans;\\n    }\\n    long long int mergeSort(vector<int>& nums, vector<int>& temp, int st, int end){\\n        if(st>=end)\\n            return 0;\\n        int mid=st+(end-st)/2;\\n        long long int ans=0;\\n        ans+=mergeSort(nums, temp, st, mid);\\n        ans+=mergeSort(nums, temp, mid+1, end);\\n        \\n        ans+=merge(nums, temp, st, mid+1, end);\\n        return ans;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp(n);\\n        return mergeSort(nums, temp, 0, n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341053,
                "title": "c-mergesort-approach-runtime-216-ms-faster-than-84-75-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int mergesort(int l, int r, vector<int>&arr, vector<int>&temp)\\n    {\\n        if(l>=r)\\n        {\\n            return 0;\\n        }\\n        int mid = l+((r-l)/2);\\n        int ans = mergesort(l, mid, arr, temp);\\n        ans += mergesort(mid+1, r, arr, temp);\\n        ans += merge(l, r, arr, temp);\\n        return ans;\\n    }\\n    int merge(int l, int r, vector<int>&arr, vector<int>&temp)\\n    {\\n        int mid = l+((r-l)/2);\\n        int i=l, j=mid+1, k=l;\\n        int ans=0;\\n        while(i<=mid && j<=r)\\n        {\\n            if(arr[i]/2+max(0,arr[i]%2)<=arr[j])\\n            {\\n                i++;\\n            }\\n            else{\\n                ans+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        i=l;\\n        j=mid+1;\\n        while(i<=mid && j<=r)\\n        {\\n            if(arr[i]<arr[j])\\n            {\\n                temp[k++]=arr[i++];\\n            }\\n            else{\\n                temp[k++]=arr[j++];\\n            }\\n        }\\n        while(i<=mid)\\n            temp[k++]=arr[i++];\\n        while(j<=r)\\n            temp[k++]=arr[j++];\\n        for(int idx=l; idx<=r; idx++)\\n            arr[idx]=temp[idx];\\n        return ans;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>temp(n);\\n        return mergesort(0, n-1, nums, temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mergesort(int l, int r, vector<int>&arr, vector<int>&temp)\\n    {\\n        if(l>=r)\\n        {\\n            return 0;\\n        }\\n        int mid = l+((r-l)/2);\\n        int ans = mergesort(l, mid, arr, temp);\\n        ans += mergesort(mid+1, r, arr, temp);\\n        ans += merge(l, r, arr, temp);\\n        return ans;\\n    }\\n    int merge(int l, int r, vector<int>&arr, vector<int>&temp)\\n    {\\n        int mid = l+((r-l)/2);\\n        int i=l, j=mid+1, k=l;\\n        int ans=0;\\n        while(i<=mid && j<=r)\\n        {\\n            if(arr[i]/2+max(0,arr[i]%2)<=arr[j])\\n            {\\n                i++;\\n            }\\n            else{\\n                ans+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        i=l;\\n        j=mid+1;\\n        while(i<=mid && j<=r)\\n        {\\n            if(arr[i]<arr[j])\\n            {\\n                temp[k++]=arr[i++];\\n            }\\n            else{\\n                temp[k++]=arr[j++];\\n            }\\n        }\\n        while(i<=mid)\\n            temp[k++]=arr[i++];\\n        while(j<=r)\\n            temp[k++]=arr[j++];\\n        for(int idx=l; idx<=r; idx++)\\n            arr[idx]=temp[idx];\\n        return ans;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>temp(n);\\n        return mergesort(0, n-1, nums, temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254996,
                "title": "java-merge-sort-82",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int reversePairs(int[] nums) {\\n        long n[] = new long[nums.length];\\n        int z =0 ;\\n        for(int i : nums){\\n            n[z++] = i;\\n        }\\n        mSort(n,0,nums.length-1);\\n        return count;\\n    }\\n    long[] mSort(long n[],int s, int e) {\\n        if(s == e) {\\n            return new long[]{n[s]};\\n        }\\n        int mid = (s+e)/2;\\n        long b[] = mSort(n,s,mid);\\n        long c[] = mSort(n,mid+1,e);\\n        int i=0,j=0;\\n        while(j<c.length) {\\n            while(i<b.length && b[i] <= 2*c[j]){\\n                i++;\\n            }\\n            count+=(b.length - i);\\n            j++;\\n        }\\n        \\n        n = merge(b,c);\\n        return n;\\n    }\\n    long [] merge(long b[],long c[]){\\n        long t[]= new long[b.length+c.length];\\n        int i=0;\\n        int j=0;\\n        int z = 0;\\n        while(i<b.length && j<c.length){\\n            if(b[i] <= c[j]){\\n                t[z++] = b[i++];\\n            } else if(b[i] > c[j]) {\\n                t[z++] = c[j++];\\n            }\\n        }\\n        while(i<b.length){\\n            t[z++] = b[i++];\\n        }\\n        while(j<c.length) {\\n            t[z++] = c[j++];\\n        }\\n        return t;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int reversePairs(int[] nums) {\\n        long n[] = new long[nums.length];\\n        int z =0 ;\\n        for(int i : nums){\\n            n[z++] = i;\\n        }\\n        mSort(n,0,nums.length-1);\\n        return count;\\n    }\\n    long[] mSort(long n[],int s, int e) {\\n        if(s == e) {\\n            return new long[]{n[s]};\\n        }\\n        int mid = (s+e)/2;\\n        long b[] = mSort(n,s,mid);\\n        long c[] = mSort(n,mid+1,e);\\n        int i=0,j=0;\\n        while(j<c.length) {\\n            while(i<b.length && b[i] <= 2*c[j]){\\n                i++;\\n            }\\n            count+=(b.length - i);\\n            j++;\\n        }\\n        \\n        n = merge(b,c);\\n        return n;\\n    }\\n    long [] merge(long b[],long c[]){\\n        long t[]= new long[b.length+c.length];\\n        int i=0;\\n        int j=0;\\n        int z = 0;\\n        while(i<b.length && j<c.length){\\n            if(b[i] <= c[j]){\\n                t[z++] = b[i++];\\n            } else if(b[i] > c[j]) {\\n                t[z++] = c[j++];\\n            }\\n        }\\n        while(i<b.length){\\n            t[z++] = b[i++];\\n        }\\n        while(j<c.length) {\\n            t[z++] = c[j++];\\n        }\\n        return t;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178951,
                "title": "python-fenwick-tree-o-nlogn-easy-to-understand",
                "content": "```\\nfrom bisect import bisect, bisect_left\\nclass Solution:\\n    def Sum(self, i):\\n        res = 0\\n        while i>0:\\n            res += self.tree[i]\\n            i -= (i & (-i))\\n        return res\\n    \\n    def add(self, i):\\n        while i < len(self.tree):\\n            self.tree[i] += 1\\n            i += (i & (-i))\\n            \\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n        * Use Fenwick tree\\n        * This question equals to finding number of elements larger than nums[j] * 2  -> total nof_elements - (nof_elements <= 2*nums[j])\\n        * Let Sum(i) denotes the number of elements <= sorted_nums[i]\\n        \\'\\'\\'\\n        sorted_nums = sorted(nums)\\n        \\n        # Construct Fenwcik tree\\n        self.tree = [0 for i in range(len(nums)+1)]\\n        \\n        # sorted_num:[1, 1, 2, 3, 3]\\n        res = 0\\n        for i, num in enumerate(nums):\\n            # Find the index of 2*nums\\n            res += (i - self.Sum(bisect(sorted_nums, 2*num)))\\n            \\n            # Add this number into the tree\\n            self.add(bisect(sorted_nums, num))\\n        return res",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect, bisect_left\\nclass Solution:\\n    def Sum(self, i):\\n        res = 0\\n        while i>0:\\n            res += self.tree[i]\\n            i -= (i & (-i))\\n        return res\\n    \\n    def add(self, i):\\n        while i < len(self.tree):\\n            self.tree[i] += 1\\n            i += (i & (-i))\\n            \\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n        * Use Fenwick tree\\n        * This question equals to finding number of elements larger than nums[j] * 2  -> total nof_elements - (nof_elements <= 2*nums[j])\\n        * Let Sum(i) denotes the number of elements <= sorted_nums[i]\\n        \\'\\'\\'\\n        sorted_nums = sorted(nums)\\n        \\n        # Construct Fenwcik tree\\n        self.tree = [0 for i in range(len(nums)+1)]\\n        \\n        # sorted_num:[1, 1, 2, 3, 3]\\n        res = 0\\n        for i, num in enumerate(nums):\\n            # Find the index of 2*nums\\n            res += (i - self.Sum(bisect(sorted_nums, 2*num)))\\n            \\n            # Add this number into the tree\\n            self.add(bisect(sorted_nums, num))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1121674,
                "title": "java-solution-using-bit-fenwick-tree",
                "content": "```\\nclass Solution {\\n    static int ft[];\\n    public int reversePairs(int[] nums) {\\n        int length_of_array=nums.length;\\n        //Calculating Size Of Fenwick (BIT) Tree\\n        int size=(int)Math.pow(2,(Math.ceil(Math.log(length_of_array)/Math.log(2.0))));\\n        ft=new int[size+1];\\n        return solve_using_Bit(nums);\\n    }\\n    public static int solve_using_Bit(int arr[])\\n    {\\n        int answer=0;\\n        int n= arr.length;;\\n        int sorted_Array[]=new int[n];\\n        for(int i=0;i<n;i++)\\n            sorted_Array[i]=arr[i];\\n        Arrays.sort(sorted_Array);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            //Search for half of current value and get its index from sorted array \\n            int index=binary_search(arr[i]/2.0,sorted_Array);\\n            if(index!=-1) {\\n                index = sorted_Array[index] >= arr[i] / 2.0 ? index - 1 : index;\\n                if (index >= 0) {\\n                    int sum = sum_ft(index+1);\\n                    answer += sum;\\n                }\\n            }\\n            index=binary_search(arr[i],sorted_Array);\\n            update(index+1);\\n        }\\n        return answer;\\n    }\\n    public static int binary_search(double key1,int array[])\\n    {\\n        int low=0,high=array.length-1;\\n        int mid;\\n        int key=(int) key1;\\n        int pos=-1;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(array[mid]<=key)\\n            {\\n                pos=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return pos;\\n    }\\n    public static void update(int index)\\n    {\\n        int value=1;\\n        if (index!=0)\\n        while(index<ft.length)\\n        {\\n            ft[index]+=value;\\n            index+=Integer.lowestOneBit(index);\\n        }\\n    }\\n    public static int sum_ft(int index)\\n    {\\n        int sum=0;\\n        while(index>0)\\n        {\\n            sum+=ft[index];\\n            index-=Integer.lowestOneBit(index);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int ft[];\\n    public int reversePairs(int[] nums) {\\n        int length_of_array=nums.length;\\n        //Calculating Size Of Fenwick (BIT) Tree\\n        int size=(int)Math.pow(2,(Math.ceil(Math.log(length_of_array)/Math.log(2.0))));\\n        ft=new int[size+1];\\n        return solve_using_Bit(nums);\\n    }\\n    public static int solve_using_Bit(int arr[])\\n    {\\n        int answer=0;\\n        int n= arr.length;;\\n        int sorted_Array[]=new int[n];\\n        for(int i=0;i<n;i++)\\n            sorted_Array[i]=arr[i];\\n        Arrays.sort(sorted_Array);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            //Search for half of current value and get its index from sorted array \\n            int index=binary_search(arr[i]/2.0,sorted_Array);\\n            if(index!=-1) {\\n                index = sorted_Array[index] >= arr[i] / 2.0 ? index - 1 : index;\\n                if (index >= 0) {\\n                    int sum = sum_ft(index+1);\\n                    answer += sum;\\n                }\\n            }\\n            index=binary_search(arr[i],sorted_Array);\\n            update(index+1);\\n        }\\n        return answer;\\n    }\\n    public static int binary_search(double key1,int array[])\\n    {\\n        int low=0,high=array.length-1;\\n        int mid;\\n        int key=(int) key1;\\n        int pos=-1;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(array[mid]<=key)\\n            {\\n                pos=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return pos;\\n    }\\n    public static void update(int index)\\n    {\\n        int value=1;\\n        if (index!=0)\\n        while(index<ft.length)\\n        {\\n            ft[index]+=value;\\n            index+=Integer.lowestOneBit(index);\\n        }\\n    }\\n    public static int sum_ft(int index)\\n    {\\n        int sum=0;\\n        while(index>0)\\n        {\\n            sum+=ft[index];\\n            index-=Integer.lowestOneBit(index);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006479,
                "title": "c-14-faster-than-97-based-on-merge-sort-divide-and-conquer",
                "content": "```\\nclass Solution {\\npublic:\\n         int Merge(vector<int> &v,int low,int mid,int high)\\n    { \\n        int c{0},n1{mid-low+1},n2{high-mid};\\n       int l[n1],r[n2];\\n        int i=0,j=0,k=low;\\n        for(int itr=low;itr<=mid;itr=itr+1)\\n        {\\n            l[i]=v[itr];\\n            i=i+1;\\n\\n        }\\n        for(int itr =mid+1;itr<=high;itr=itr+1)\\n        {\\n\\n            r[j]=v[itr];\\n            j=j+1;\\n        }\\n        i=0,j=0;\\n        while(i<n1 && j<n2)\\n        {\\n            if((l[i]/2.0)>r[j])\\n            {\\n                c=c+ ((n1-i));\\n                j=j+1;\\n            }\\n            else i=i+1;\\n        }\\n        i=0,j=0;\\n        while(i<n1 && j<n2)\\n        {\\n            if(l[i]<=r[j])\\n            {\\n                v[k]=l[i];\\n                i=i+1;\\n            }\\n            else\\n            {\\n                v[k]=r[j];\\n                j=j+1;\\n            }\\n            k=k+1;\\n        }\\n        while(i<n1)\\n        {\\n            v[k]=l[i];\\n            k=k+1;\\n            i=i+1;\\n\\n        }\\n        while(j<n2)\\n        {\\n            v[k]=r[j];\\n            k=k+1;\\n            j=j+1;\\n        }\\n        return c;\\n    }\\n    void merge_sort(vector<int> &v,int low,int high,int &c)\\n    {\\n        if(low<high)\\n        {   //cout<<low<<\"  \" <<high<<endl;\\n            int mid= low+((high-low)/2);\\n            merge_sort(v,low,mid,c);\\n            merge_sort(v,mid+1,high,c);\\n            c+=Merge(v,low,mid,high);\\n        }\\n    }\\n    int reversePairs(vector<int> &v) {\\n        int c{0};\\n        merge_sort(v,0,v.size()-1,c);\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n         int Merge(vector<int> &v,int low,int mid,int high)\\n    { \\n        int c{0},n1{mid-low+1},n2{high-mid};\\n       int l[n1],r[n2];\\n        int i=0,j=0,k=low;\\n        for(int itr=low;itr<=mid;itr=itr+1)\\n        {\\n            l[i]=v[itr];\\n            i=i+1;\\n\\n        }\\n        for(int itr =mid+1;itr<=high;itr=itr+1)\\n        {\\n\\n            r[j]=v[itr];\\n            j=j+1;\\n        }\\n        i=0,j=0;\\n        while(i<n1 && j<n2)\\n        {\\n            if((l[i]/2.0)>r[j])\\n            {\\n                c=c+ ((n1-i));\\n                j=j+1;\\n            }\\n            else i=i+1;\\n        }\\n        i=0,j=0;\\n        while(i<n1 && j<n2)\\n        {\\n            if(l[i]<=r[j])\\n            {\\n                v[k]=l[i];\\n                i=i+1;\\n            }\\n            else\\n            {\\n                v[k]=r[j];\\n                j=j+1;\\n            }\\n            k=k+1;\\n        }\\n        while(i<n1)\\n        {\\n            v[k]=l[i];\\n            k=k+1;\\n            i=i+1;\\n\\n        }\\n        while(j<n2)\\n        {\\n            v[k]=r[j];\\n            k=k+1;\\n            j=j+1;\\n        }\\n        return c;\\n    }\\n    void merge_sort(vector<int> &v,int low,int high,int &c)\\n    {\\n        if(low<high)\\n        {   //cout<<low<<\"  \" <<high<<endl;\\n            int mid= low+((high-low)/2);\\n            merge_sort(v,low,mid,c);\\n            merge_sort(v,mid+1,high,c);\\n            c+=Merge(v,low,mid,high);\\n        }\\n    }\\n    int reversePairs(vector<int> &v) {\\n        int c{0};\\n        merge_sort(v,0,v.size()-1,c);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 859305,
                "title": "modification-of-mergesort-optimized-solution-in-java",
                "content": "class Solution {\\n    public int reversePairs(int[] nums) {\\n        \\n        int ans[]=new int[1];\\n        partition(nums,0,nums.length-1,ans);\\n        \\n        return ans[0];\\n    }\\n    \\n    public void partition(int arr[],int low,int high,int[] ans){\\n        \\n        if(low<high){\\n            int mid=(low+high)/2;\\n            \\n            partition(arr,low,mid,ans);\\n            partition(arr,mid+1,high,ans);\\n            merge(arr,low,mid,high,ans);\\n        }\\n        \\n    }\\n    \\n    public void merge(int[] arr,int low,int mid,int high,int[] ans){\\n        \\n        int i=low,j=mid+1;\\n        \\n        while(i<=mid){\\n            \\n            while(j<=high && arr[i]>2*(long)arr[j])\\n                j +=1;\\n            \\n            ans[0] +=j-(mid+1);\\n            \\n            i +=1;\\n        }\\n        \\n        i=low;\\n        j=mid+1;\\n        int k=0;\\n        int temp[]=new int[high-low+1];\\n        \\n        while(i<=mid && j<=high){\\n            \\n            if(arr[i]<arr[j]){\\n                temp[k]=arr[i];\\n                i +=1;\\n                k +=1;\\n            }else{\\n                temp[k]=arr[j];\\n                j +=1;\\n                k +=1;\\n            }\\n                \\n        }\\n        \\n        while(i<=mid){\\n            temp[k]=arr[i];\\n            i +=1;\\n            k +=1;\\n        }\\n        \\n        while(j<=high){\\n            temp[k]=arr[j];\\n            j +=1;\\n            k +=1;\\n        }\\n        \\n        k=low;\\n        for(i=0;i<temp.length;i++){\\n            arr[k]=temp[i];\\n            k +=1;\\n        }\\n            \\n        \\n        \\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int reversePairs(int[] nums) {\\n        \\n        int ans[]=new int[1];\\n        partition(nums,0,nums.length-1,ans);\\n        \\n        return ans[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 830287,
                "title": "go-92ms-merge-sort-approach",
                "content": "```\\nfunc reversePairs(nums []int) int {\\n    // a shared buffer for intermediate sorted numbers\\n    var sorted = make([]int, len(nums))\\n    return divide(nums, sorted)\\n}\\n\\n// the idea is to build two sorted subarrays recursively, and find the reverse pairs between two subarrays\\nfunc divide(nums []int, sorted []int) int {\\n    if len(nums) <= 1 {\\n        return 0\\n    }\\n    \\n    var l = 0\\n    var p = l + (len(nums)-1-l)/2 // the pivot(middle) point\\n    \\n    // the result should be the sum from the two subarrays, and the pairs across the two\\n    var ret = divide(nums[l:p+1], sorted) + divide(nums[p+1:], sorted)\\n    \\n    // index to check numbers in nums[p+1:] withg nums[l]\\n    var j = p+1\\n    var w = 0 // write index in `sorted`\\n    var r = p+1 // read index in the right half\\n    \\n    for ; l <= p; l++ {\\n        for j < len(nums) && nums[l] > nums[j] * 2 {\\n            j++\\n        }\\n        \\n        // As nums[0,p] and nums[p+1,] are both sorted, we know `nums[l] <= nums[l+1]`\\n        // - for the loop with l, we get nums[l] > any number in [p+1, p+1+j), and the number of pairs is `j-(p+1)`\\n        // - for the next loop with l+1, even j doesn\\'t move, nums[l+1] >= nums[l] > any number in [p+1, p+1+j), we should count `j-(p+1)` for another time\\n        ret += j-(p+1)\\n        \\n        // put numbers that\\'s not greater than nums[i] to the merge array\\n        for ;r < len(nums) && nums[l] >= nums[r];r++ {\\n            sorted[w] = nums[r]\\n            w++\\n        }\\n        \\n        sorted[w] = nums[l] // put nums[l] too\\n        w++\\n    }\\n    \\n    // there might be numbers left in the right half\\n    for ; r < len(nums); r++ {\\n        sorted[w] = nums[r]\\n        w++\\n    }\\n    \\n    copy(nums, sorted)\\n    \\n    return ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reversePairs(nums []int) int {\\n    // a shared buffer for intermediate sorted numbers\\n    var sorted = make([]int, len(nums))\\n    return divide(nums, sorted)\\n}\\n\\n// the idea is to build two sorted subarrays recursively, and find the reverse pairs between two subarrays\\nfunc divide(nums []int, sorted []int) int {\\n    if len(nums) <= 1 {\\n        return 0\\n    }\\n    \\n    var l = 0\\n    var p = l + (len(nums)-1-l)/2 // the pivot(middle) point\\n    \\n    // the result should be the sum from the two subarrays, and the pairs across the two\\n    var ret = divide(nums[l:p+1], sorted) + divide(nums[p+1:], sorted)\\n    \\n    // index to check numbers in nums[p+1:] withg nums[l]\\n    var j = p+1\\n    var w = 0 // write index in `sorted`\\n    var r = p+1 // read index in the right half\\n    \\n    for ; l <= p; l++ {\\n        for j < len(nums) && nums[l] > nums[j] * 2 {\\n            j++\\n        }\\n        \\n        // As nums[0,p] and nums[p+1,] are both sorted, we know `nums[l] <= nums[l+1]`\\n        // - for the loop with l, we get nums[l] > any number in [p+1, p+1+j), and the number of pairs is `j-(p+1)`\\n        // - for the next loop with l+1, even j doesn\\'t move, nums[l+1] >= nums[l] > any number in [p+1, p+1+j), we should count `j-(p+1)` for another time\\n        ret += j-(p+1)\\n        \\n        // put numbers that\\'s not greater than nums[i] to the merge array\\n        for ;r < len(nums) && nums[l] >= nums[r];r++ {\\n            sorted[w] = nums[r]\\n            w++\\n        }\\n        \\n        sorted[w] = nums[l] // put nums[l] too\\n        w++\\n    }\\n    \\n    // there might be numbers left in the right half\\n    for ; r < len(nums); r++ {\\n        sorted[w] = nums[r]\\n        w++\\n    }\\n    \\n    copy(nums, sorted)\\n    \\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 590540,
                "title": "tle-using-java-treeset-nlogn",
                "content": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        long val;\\n        int idx;\\n        Pair(long val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair obj){\\n            if(this.val == obj.val)return this.idx - obj.idx;\\n            if (this.val > obj.val) return 1;\\n            else if (this.val < obj.val) return -1;\\n            return 0;\\n        }\\n    }\\n\\t\\n    public int reversePairs(int[] nums) {\\n        TreeSet<Pair> set = new TreeSet<>();\\n        int ans = 0;\\n        for(int i = nums.length - 1; i>= 0; i--){\\n            int v = set.headSet(new Pair(nums[i],-1)).size();\\n            ans += v;\\n            set.add(new Pair(nums[i]*2L,i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        long val;\\n        int idx;\\n        Pair(long val, int idx){\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair obj){\\n            if(this.val == obj.val)return this.idx - obj.idx;\\n            if (this.val > obj.val) return 1;\\n            else if (this.val < obj.val) return -1;\\n            return 0;\\n        }\\n    }\\n\\t\\n    public int reversePairs(int[] nums) {\\n        TreeSet<Pair> set = new TreeSet<>();\\n        int ans = 0;\\n        for(int i = nums.length - 1; i>= 0; i--){\\n            int v = set.headSet(new Pair(nums[i],-1)).size();\\n            ans += v;\\n            set.add(new Pair(nums[i]*2L,i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574279,
                "title": "c-merge-sort-tree-time-o-nlg-2-n-space-o-nlgn",
                "content": "```\\nstruct ST {\\n    vector<vector<int>> T;\\n    vector<int> A;\\n\\n    ST(vector<int>& A) {\\n        this->A = A;\\n        T = vector<vector<int>>(A.size() * 5);\\n        build(1, 0, A.size() - 1);\\n    }\\n\\n    void build(int v, int tl, int tr) {\\n        if (tl == tr) {\\n            T[v].push_back(A[tl]);\\n        } else {\\n            int tm = (tl + tr) >> 1;\\n            build(v*2, tl, tm);\\n            build(v*2+1, tm+1, tr);\\n            merge(T[v*2].begin(), T[v*2].end(), T[v*2+1].begin(), T[v*2+1].end(), back_inserter(T[v]));\\n        }\\n    }\\n\\n    int query(int v, int tl, int tr, int l, int r, int x) {\\n        if (l > r) return 0;\\n        if (tl == l && tr == r) return distance(T[v].begin(), lower_bound(T[v].begin(), T[v].end(), x));\\n        int tm = (tl + tr) >> 1;\\n        return query(v*2, tl, tm, l, min(r, tm), x) + query(v*2+1, tm+1, tr, max(l, tm+1), r, x);\\n    }\\n};\\n\\n//Time complexity: O(nlg^2(n))\\n//Space complexity: O(nlgn)\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        \\n        ST st(nums);\\n        \\n        int count = 0;\\n        for (int i = 0; i < nums.size() - 1; ++i) count += st.query(1, 0, nums.size()-1, i+1, nums.size() - 1, ceil(nums[i] / 2.f));\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ST {\\n    vector<vector<int>> T;\\n    vector<int> A;\\n\\n    ST(vector<int>& A) {\\n        this->A = A;\\n        T = vector<vector<int>>(A.size() * 5);\\n        build(1, 0, A.size() - 1);\\n    }\\n\\n    void build(int v, int tl, int tr) {\\n        if (tl == tr) {\\n            T[v].push_back(A[tl]);\\n        } else {\\n            int tm = (tl + tr) >> 1;\\n            build(v*2, tl, tm);\\n            build(v*2+1, tm+1, tr);\\n            merge(T[v*2].begin(), T[v*2].end(), T[v*2+1].begin(), T[v*2+1].end(), back_inserter(T[v]));\\n        }\\n    }\\n\\n    int query(int v, int tl, int tr, int l, int r, int x) {\\n        if (l > r) return 0;\\n        if (tl == l && tr == r) return distance(T[v].begin(), lower_bound(T[v].begin(), T[v].end(), x));\\n        int tm = (tl + tr) >> 1;\\n        return query(v*2, tl, tm, l, min(r, tm), x) + query(v*2+1, tm+1, tr, max(l, tm+1), r, x);\\n    }\\n};\\n\\n//Time complexity: O(nlg^2(n))\\n//Space complexity: O(nlgn)\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        \\n        ST st(nums);\\n        \\n        int count = 0;\\n        for (int i = 0; i < nums.size() - 1; ++i) count += st.query(1, 0, nums.size()-1, i+1, nums.size() - 1, ceil(nums[i] / 2.f));\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417232,
                "title": "python-simple-and-short-solution",
                "content": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        import bisect \\n        a = []\\n        ret = 0 \\n        for x in nums[::-1]:\\n            ret += bisect.bisect_left(a,x/2)\\n            bisect.insort(a,x)\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        import bisect \\n        a = []\\n        ret = 0 \\n        for x in nums[::-1]:\\n            ret += bisect.bisect_left(a,x/2)\\n            bisect.insort(a,x)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347778,
                "title": "c-solution",
                "content": "Time complexity is O(logn * nlogn).\\n\\nIt can be very easily converted to (nlogn) by changing Array.Sort O(nlogn) to a merge funtion to merge the two sorted array in O(n) time.\\n\\n```\\npublic class Solution \\n{\\n    public int ReversePairs(int[] nums) \\n    {\\n        return MergeSort(nums, 0, nums.Length - 1);\\n    }\\n    \\n    private int MergeSort(int[] nums, int start, int end)\\n    {\\n        if(start >= end) return 0; \\n        int mid = start + (end - start) / 2; \\n        int count = MergeSort(nums, start, mid) + MergeSort(nums, mid+1, end); \\n        \\n        for(int i = start, j = mid + 1; i<= mid; i++)\\n        {\\n            while( j<= end  && nums[i] / 2.0 > nums[j]) \\n                j++;\\n            \\n            count += j - (mid + 1); \\n        }\\n        \\n        Array.Sort(nums, start, end - start + 1); \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int ReversePairs(int[] nums) \\n    {\\n        return MergeSort(nums, 0, nums.Length - 1);\\n    }\\n    \\n    private int MergeSort(int[] nums, int start, int end)\\n    {\\n        if(start >= end) return 0; \\n        int mid = start + (end - start) / 2; \\n        int count = MergeSort(nums, start, mid) + MergeSort(nums, mid+1, end); \\n        \\n        for(int i = start, j = mid + 1; i<= mid; i++)\\n        {\\n            while( j<= end  && nums[i] / 2.0 > nums[j]) \\n                j++;\\n            \\n            count += j - (mid + 1); \\n        }\\n        \\n        Array.Sort(nums, start, end - start + 1); \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324283,
                "title": "javascript-bit-solution-with-explanation-sources-links",
                "content": "JavaScript implementation of the BIT solution here: https://leetcode.com/problems/reverse-pairs/discuss/97268/General-principles-behind-problems-similar-to-%22Reverse-Pairs%22\\n\\nFor BIT intuition explanation, please refer to this super concise and comprehensive answer: https://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst search = (bit, i) => {\\n    let sum = 0;\\n    while (i < bit.length){\\n        sum += bit[i];\\n        i += i & -i;\\n    }\\n    return sum;\\n}\\n\\nconst insert = (bit, i) => {\\n    while (i > 0){\\n        bit[i] += 1;\\n        i -= i & -i;\\n    }\\n    return bit;\\n}\\n\\nconst indexed = (arr, val) => {\\n    let l = 0, r = arr.length-1, m = 0;\\n    while (l <= r) {\\n        m = l + ((r-l) >> 1);\\n        if (arr[m] >= val){\\n            r = m-1;\\n        }else{\\n            l = m+1;\\n        }\\n    }\\n    return l+1;\\n}\\n\\nvar reversePairs = function(nums) {\\n    let count = 0;\\n    let copy = nums.slice().sort((a,b)=>a-b);\\n    let bit = new Array(nums.length+1).fill(0);\\n    for (let num of nums){\\n        count += search(bit, indexed(copy, 2*num+1));\\n        bit = insert(bit, indexed(copy, num));\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst search = (bit, i) => {\\n    let sum = 0;\\n    while (i < bit.length){\\n        sum += bit[i];\\n        i += i & -i;\\n    }\\n    return sum;\\n}\\n\\nconst insert = (bit, i) => {\\n    while (i > 0){\\n        bit[i] += 1;\\n        i -= i & -i;\\n    }\\n    return bit;\\n}\\n\\nconst indexed = (arr, val) => {\\n    let l = 0, r = arr.length-1, m = 0;\\n    while (l <= r) {\\n        m = l + ((r-l) >> 1);\\n        if (arr[m] >= val){\\n            r = m-1;\\n        }else{\\n            l = m+1;\\n        }\\n    }\\n    return l+1;\\n}\\n\\nvar reversePairs = function(nums) {\\n    let count = 0;\\n    let copy = nums.slice().sort((a,b)=>a-b);\\n    let bit = new Array(nums.length+1).fill(0);\\n    for (let num of nums){\\n        count += search(bit, indexed(copy, 2*num+1));\\n        bit = insert(bit, indexed(copy, num));\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290151,
                "title": "pyhton-bisect-solution-with-explanation",
                "content": "The idea is to check the items in nums backwards, so j > i is satisfied. Insert 2\\\\*nums[i] into r at position k and keep r sorted. The number of items ahead of k is the number of previous j that satisified nums[i] > 2\\\\*nums[j] . \\n\\nThis is O(n\\\\*2) solution, as bisect.insort_left() is O(n) operation. \\n\\n```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r, ans = [], 0\\n        for n in nums[::-1]:\\n            ans += bisect.bisect_left(r, n)\\n            bisect.insort_left(r, 2*n)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r, ans = [], 0\\n        for n in nums[::-1]:\\n            ans += bisect.bisect_left(r, n)\\n            bisect.insort_left(r, 2*n)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275350,
                "title": "very-short-python-solutions",
                "content": "```\\nimport bisect\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        res, doubles = 0, []\\n        for num in reversed(nums):\\n            idx = bisect.bisect_left(doubles, num)\\n            res += idx\\n            bisect.insort(doubles, num*2)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        res, doubles = 0, []\\n        for num in reversed(nums):\\n            idx = bisect.bisect_left(doubles, num)\\n            res += idx\\n            bisect.insort(doubles, num*2)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213714,
                "title": "java-merge-sort-bit-segment-tree-solution",
                "content": "```\\n//merge sort...\\nclass Solution {\\n    \\n    int cnt = 0;            \\n    public int reversePairs(int[] nums) {\\n        if (nums == null || nums.length <= 1) return 0;\\n        int n = nums.length;\\n        int[] aux = new int[n];\\n        mergeSort(nums, 0, n - 1, aux);\\n        return cnt;\\n    }\\n    \\n    private void mergeSort(int[] nums, int lo, int hi, int[] aux) {\\n        if (lo == hi) { return; }\\n        int mid = lo + (hi - lo) / 2;\\n        mergeSort(nums, lo, mid, aux);\\n        mergeSort(nums, mid + 1, hi, aux);\\n        for (int i = lo; i <= hi; i++) {\\n            aux[i] = nums[i];\\n        }\\n        int j = mid + 1, t = mid + 1, k = lo;\\n        for (int i = lo; i <= mid; i++) {\\n            while (t <= hi && aux[i] > 2L * aux[t]) {\\n                //avoid integer overflow...\\n                t++;\\n            }\\n            cnt += t - mid - 1;\\n            while (j <= hi && aux[j] < aux[i]) {\\n                nums[k++] = aux[j++];\\n            }\\n            nums[k++] = aux[i];\\n        }\\n    }\\n}\\n\\n\\n//BIT...\\n//Binary search can be one merge to 1...\\nclass Solution {\\n    \\n    int[] BIT;\\n    \\n    public int reversePairs(int[] nums) {\\n        if (nums == null || nums.length <= 1) return 0;\\n        int n = nums.length;\\n        \\n        int[] copy = nums.clone();\\n        Arrays.sort(copy);\\n        \\n        //discretization\\n        //so different num will be mapped to 0 - (p - 1)...in order...\\n        int p = 0;\\n        for (int num : copy) {\\n            if (p == 0 || num != copy[p - 1]) {\\n                copy[p++] = num;\\n            }\\n        }\\n        \\n        BIT = new int[p + 1];\\n        int cnt = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int index1 = binarySearch(1.0 * nums[i] / 2, 0, p, copy);\\n            //if all number are negative... the index could be p...\\n            int index2 = binarySearch(nums[i], 0, p - 1, copy);\\n            cnt += query(index1);\\n            update(index2 + 1); //need to add 1...\\n        }\\n        return cnt;\\n    }\\n    \\n    private int query(int i) {\\n        int sum = 0;\\n        while (i > 0) {\\n            sum += BIT[i];\\n            i -= (i & -i);\\n            //System.out.println(\"loop1\");\\n        }\\n        return sum;\\n    }\\n    \\n    private void update(int i) {\\n        int n = BIT.length;\\n        while (i < n) {\\n            BIT[i] += 1;\\n            i += (i & -i);\\n        }\\n    }\\n    //find the first index with num[index] * 2 >= num...\\n    private int binarySearch(double num, int lo, int hi, int[] nums) {\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] >= num) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n                \\n            }\\n            //System.out.println(\"loop3\");\\n        }\\n        return lo;\\n    }\\n}\\n\\n\\n//use segment tree...\\nclass Solution {\\n    \\n    int[] seg;\\n    \\n    public int reversePairs(int[] nums) {\\n        if (nums == null || nums.length <= 1) return 0;\\n        int n = nums.length;\\n        \\n        int[] copy = nums.clone();\\n        Arrays.sort(copy);\\n        \\n        //discretization\\n        int p = 0;\\n        for (int num : copy) {\\n            if (p == 0 || num != copy[p - 1]) {\\n                copy[p++] = num;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while ((1 << i) < p) {\\n            i++;\\n        }\\n        \\n        seg = new int[(1 << (i + 1)) - 1];\\n        \\n        int cnt = 0;\\n        for (i = n - 1; i >= 0; i--) {\\n            int index1 = binarySearch(1.0 * nums[i] / 2, 0, p, copy);\\n            int index2 = binarySearch(nums[i], 0, p - 1, copy);\\n            cnt += query(0, index1 - 1, 0, p - 1, 0);\\n            update(index2, 0, p - 1, 0);\\n        }\\n        return cnt;\\n    }\\n    \\n    private int query(int tl, int tr, int cl, int cr, int index) {\\n        if (tl <= cl && tr >= cr) {\\n            return seg[index];\\n        }\\n        if (tr < cl || tl > cr) { return 0; }\\n        int mid = cl + (cr - cl) / 2;\\n        return query(tl, tr, cl, mid, 2 * index + 1) + \\n            query(tl, tr, mid + 1, cr, 2 * index + 2); \\n    }\\n    \\n    private void update(int i, int l, int r, int index) {\\n        if (l <= i && r >= i) {\\n            seg[index]++;\\n        }\\n        if (l == r) return;\\n        int mid = l + (r - l) / 2;\\n        if (mid < i) {\\n            update(i, mid + 1, r, 2 * index + 2);\\n        } else {\\n            update(i, l, mid, 2 * index + 1);\\n        }\\n    }\\n    \\n    //find the first index with num[index] * 2 >= num...\\n    private int binarySearch(double num, int lo, int hi, int[] nums) {\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] >= num) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n                \\n            }\\n        }\\n        return lo;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int cnt = 0;            \\n    public int reversePairs(int[] nums) {\\n        if (nums == null || nums.length <= 1) return 0;\\n        int n = nums.length;\\n        int[] aux = new int[n];\\n        mergeSort(nums, 0, n - 1, aux);\\n        return cnt;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 187259,
                "title": "java-short-mergesort-solution",
                "content": "https://www.jiuzhang.com/solution/reverse-pairs/#tag-other\\n\\n```\\n    public int reversePairs(int[] a) {\\n        return mergeSort(a, 0, a.length-1);\\n    }\\n    \\n    int mergeSort(int[] a, int s, int e) {\\n        if(s >= e) return 0;\\n        int mid = s + (e - s) / 2;\\n        int count = mergeSort(a, s, mid) + mergeSort(a, mid + 1, e);\\n        int idx1 = s, idx2 = mid +1;\\n        while(idx1 <= mid && idx2 <= e) {\\n            while(idx2 <= e && a[idx1] > 2L * a[idx2]) idx2++;\\n            count += idx2 - mid -1;\\n            idx1++;\\n            if(idx2 > e && idx1 <= mid) count +=  (mid - idx1 + 1) * (idx2 - mid -1);\\n        }\\n        merge(a, s, mid, e);\\n        return count;\\n    }\\n    \\n    void merge(int[] a, int s, int m, int e) {\\n        int[] t = new int[e - s + 1];\\n        int idx = 0, start = s, s1 = m + 1;\\n        while(s <= m && s1 <= e) t[idx++] = a[s] <= a[s1] ? a[s++] : a[s1++];\\n        while(s <= m) t[idx++] = a[s++];\\n        while(s1 <= e) t[idx++] = a[s1++];\\n        for(int i = 0; i < idx; i++) a[start + i] = t[i];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int reversePairs(int[] a) {\\n        return mergeSort(a, 0, a.length-1);\\n    }\\n    \\n    int mergeSort(int[] a, int s, int e) {\\n        if(s >= e) return 0;\\n        int mid = s + (e - s) / 2;\\n        int count = mergeSort(a, s, mid) + mergeSort(a, mid + 1, e);\\n        int idx1 = s, idx2 = mid +1;\\n        while(idx1 <= mid && idx2 <= e) {\\n            while(idx2 <= e && a[idx1] > 2L * a[idx2]) idx2++;\\n            count += idx2 - mid -1;\\n            idx1++;\\n            if(idx2 > e && idx1 <= mid) count +=  (mid - idx1 + 1) * (idx2 - mid -1);\\n        }\\n        merge(a, s, mid, e);\\n        return count;\\n    }\\n    \\n    void merge(int[] a, int s, int m, int e) {\\n        int[] t = new int[e - s + 1];\\n        int idx = 0, start = s, s1 = m + 1;\\n        while(s <= m && s1 <= e) t[idx++] = a[s] <= a[s1] ? a[s++] : a[s1++];\\n        while(s <= m) t[idx++] = a[s++];\\n        while(s1 <= e) t[idx++] = a[s1++];\\n        for(int i = 0; i < idx; i++) a[start + i] = t[i];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97270,
                "title": "10-lines-c-accepted-using-binary-search",
                "content": "I have to say that I like the divide & conquer (merge sort) and binary indexed tree solutions more. However, I guess this solution using binary search also with time complexity O(NlogN) (?) is the one I might think out and implement during an interview. The main idea is insertion sort and binary search. \\n\\nLet me know if you have questions.\\n\\n```\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        vector<int> sortedNums;\\n        int res = 0, target = 0, pos = 0;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            target = nums[i] > 0 ? (nums[i] - 1) / 2 : nums[i] / 2 - 1; \\n            // find the target that is approximately nums[i]/2 in the sorted array\\n            auto ptr = upper_bound(sortedNums.begin(), sortedNums.end(), target);\\n            res += ptr - sortedNums.begin(); \\n            // the number of reverse pair for nums[i] (j > i elements in nums are already sorted in \"sortedNums\")\\n            pos = upper_bound(sortedNums.begin(), sortedNums.end(), nums[i]) - sortedNums.begin(); \\n            // insert nums[i] in \"sortedNums\"\\n            sortedNums.insert(sortedNums.begin() + pos, nums[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        vector<int> sortedNums;\\n        int res = 0, target = 0, pos = 0;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            target = nums[i] > 0 ? (nums[i] - 1) / 2 : nums[i] / 2 - 1; \\n            // find the target that is approximately nums[i]/2 in the sorted array\\n            auto ptr = upper_bound(sortedNums.begin(), sortedNums.end(), target);\\n            res += ptr - sortedNums.begin(); \\n            // the number of reverse pair for nums[i] (j > i elements in nums are already sorted in \"sortedNums\")\\n            pos = upper_bound(sortedNums.begin(), sortedNums.end(), nums[i]) - sortedNums.begin(); \\n            // insert nums[i] in \"sortedNums\"\\n            sortedNums.insert(sortedNums.begin() + pos, nums[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97307,
                "title": "i-couldn-t-get-why-the-champion-s-algorithm-works-can-someone-help-thanks",
                "content": "I don't know why his algorithm works. Here is his code below:\\n```\\nclass Solution {\\npublic:\\n    map<long long, int> bit;\\n    long long lowbit(long long x)\\n    {\\n        return x & (-x);\\n    }\\n    void add(long long x)\\n    {\\n        for(x += (1ll << 34); x <= (1ll << 36); x += lowbit(x))\\n            ++bit[x];\\n    }\\n    int que(long long x)\\n    {\\n        int ans = 0;\\n        for(x += (1ll << 34); x; x -= lowbit(x))\\n            ans += bit[x];\\n        return ans;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        bit.clear();\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            ans += que((long long) nums[i] - 1ll);\\n            add((long long) nums[i] * 2ll);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<long long, int> bit;\\n    long long lowbit(long long x)\\n    {\\n        return x & (-x);\\n    }\\n    void add(long long x)\\n    {\\n        for(x += (1ll << 34); x <= (1ll << 36); x += lowbit(x))\\n            ++bit[x];\\n    }\\n    int que(long long x)\\n    {\\n        int ans = 0;\\n        for(x += (1ll << 34); x; x -= lowbit(x))\\n            ans += bit[x];\\n        return ans;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        bit.clear();\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            ans += que((long long) nums[i] - 1ll);\\n            add((long long) nums[i] * 2ll);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97288,
                "title": "short-but-slow-python-with-bisect",
                "content": "Only O(n^2), but has a decent chance to get accepted (just submitted five times, got 1919ms, TLE, TLE, TLE, 1969ms).\\n\\n    def reversePairs(self, nums):\\n        count = 0\\n        done = []\\n        for num in nums:\\n            count += len(done) - bisect.bisect(done, num * 2)\\n            bisect.insort(done, num)\\n        return count",
                "solutionTags": [],
                "code": "Only O(n^2), but has a decent chance to get accepted (just submitted five times, got 1919ms, TLE, TLE, TLE, 1969ms).\\n\\n    def reversePairs(self, nums):\\n        count = 0\\n        done = []\\n        for num in nums:\\n            count += len(done) - bisect.bisect(done, num * 2)\\n            bisect.insort(done, num)\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 97322,
                "title": "c-self-ballancing-bst-with-counters",
                "content": "**Update (3/2/2017):** It looks like a new test case was added [0, 1, ... 49998, 49999], and the original solution without self-balancing now causes TLE. I added the rotation logic back, and now it's accepted. My implementation is similar to AVL tree, but instead of balance factor I am using the existing left and right tree counters. This approach may not produce a perfectly balanced tree, but it works and does not introduce any new member variables. \\n\\nThe idea is to start from the end, and add number * 2 to BST (e.g. multiset<T> in C++) as you go. You can then use BST to search in O (log n). However, finding exactly how many elements in BST are lower than the current number requires O(n). \\n\\nTo counter that, my implementation of BST tracks the number of elements in left and right sub-trees. So, you can find out how many elements so far are smaller than the current element in O (log n). Also, instead of adding a node with the same value, my implementation just increases the counter in the existing node. This optimization dramatically improves the run-time. \\n\\n~~I tried to rotate the tree to balance the maximum depth, but run-time was the same (or slightly worse). I guess that there are no test cases causing a skewed tree. So I removed the rotation to keep it short.~~ I am also ignoring the memory management.\\n```\\ntemplate<class T> class TreeNodeWithCounter {\\n    T val;\\n    TreeNodeWithCounter *left = nullptr, *right = nullptr;\\n    int cnt_left = 0, cnt_right = 0, cnt_val = 1;\\npublic:\\n    TreeNodeWithCounter(T v) : val(v) {};\\n    void insert(T v, TreeNodeWithCounter **thisNode) {\\n        if (v == val) ++cnt_val;\\n        else if (v < val) {\\n            ++cnt_left;\\n            if (left == nullptr) left = new TreeNodeWithCounter(v);\\n            else left->insert(v, &left);\\n        }\\n        else {\\n            ++cnt_right;\\n            if (right == nullptr) right = new TreeNodeWithCounter(v);\\n            else right->insert(v, &right);\\n        }\\n\\n        if (cnt_left > cnt_right + 2) { // right rotation\\n            *thisNode = left;\\n            left = left->right;\\n            (*thisNode)->right = this;\\n            this->cnt_left = (*thisNode)->cnt_right;\\n            (*thisNode)->cnt_right += this->cnt_val + this->cnt_right;\\n        }\\n        else if (cnt_left + 2 < cnt_right) { // left rotation\\n            *thisNode = right;\\n            right = right->left;\\n            (*thisNode)->left = this;\\n            this->cnt_right = (*thisNode)->cnt_left;\\n            (*thisNode)->cnt_left += this->cnt_val + this->cnt_left;\\n        }\\n    }\\n    int lower_count(T v) {\\n        if (v == val) return cnt_left;\\n        if (v < val) return (left == NULL ? 0 : left->lower_count(v));\\n        else return cnt_left + cnt_val + (right == NULL ? 0 : right->lower_count(v));\\n    }    \\n};\\n\\nint reversePairs(vector<int>& nums) {\\n    int res = 0, size = nums.size();\\n    if (size > 0) {\\n        auto *root = new TreeNodeWithCounter<long long>((long long)nums[size - 1] * 2);\\n        for (int i = size - 2; i >= 0; --i) {\\n            res += root->lower_count(nums[i]);\\n            root->insert((long long)nums[i] * 2, &root); }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate<class T> class TreeNodeWithCounter {\\n    T val;\\n    TreeNodeWithCounter *left = nullptr, *right = nullptr;\\n    int cnt_left = 0, cnt_right = 0, cnt_val = 1;\\npublic:\\n    TreeNodeWithCounter(T v) : val(v) {};\\n    void insert(T v, TreeNodeWithCounter **thisNode) {\\n        if (v == val) ++cnt_val;\\n        else if (v < val) {\\n            ++cnt_left;\\n            if (left == nullptr) left = new TreeNodeWithCounter(v);\\n            else left->insert(v, &left);\\n        }\\n        else {\\n            ++cnt_right;\\n            if (right == nullptr) right = new TreeNodeWithCounter(v);\\n            else right->insert(v, &right);\\n        }\\n\\n        if (cnt_left > cnt_right + 2) { // right rotation\\n            *thisNode = left;\\n            left = left->right;\\n            (*thisNode)->right = this;\\n            this->cnt_left = (*thisNode)->cnt_right;\\n            (*thisNode)->cnt_right += this->cnt_val + this->cnt_right;\\n        }\\n        else if (cnt_left + 2 < cnt_right) { // left rotation\\n            *thisNode = right;\\n            right = right->left;\\n            (*thisNode)->left = this;\\n            this->cnt_right = (*thisNode)->cnt_left;\\n            (*thisNode)->cnt_left += this->cnt_val + this->cnt_left;\\n        }\\n    }\\n    int lower_count(T v) {\\n        if (v == val) return cnt_left;\\n        if (v < val) return (left == NULL ? 0 : left->lower_count(v));\\n        else return cnt_left + cnt_val + (right == NULL ? 0 : right->lower_count(v));\\n    }    \\n};\\n\\nint reversePairs(vector<int>& nums) {\\n    int res = 0, size = nums.size();\\n    if (size > 0) {\\n        auto *root = new TreeNodeWithCounter<long long>((long long)nums[size - 1] * 2);\\n        for (int i = size - 2; i >= 0; --i) {\\n            res += root->lower_count(nums[i]);\\n            root->insert((long long)nums[i] * 2, &root); }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97289,
                "title": "python-divide-conquer-and-dp",
                "content": "Probably replace the binary search with liear search would be faster.\\nThe idea is quit simple,\\n\\nHere is an example\\n[5,1,4,2,5,2]\\nNow consider we are trying to find all elements (<2*n - 1) for 5 at index 0.\\n\\nif we divide it into two parts [5,1,4], [2,5,2], then we sort the right part.\\nit becomes [2,2,5], since we only need to consider the elements after index 0, also the right array has been sorted, if the found the last element that satisfies the condition, then all the elements before this element would be the result.\\n\\nAnd how do we handle the \"1\" on the left array? since it is also meet the condition. Well it has been handled by the recursive call.\\n\\nThis code is also used DP, since the left hand side array was also sorted, we can save the result for the previous smaller integer, then we only need to consider the elements  after the point where the previous iteration stops.\\n\\n```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        return self.helper(nums, 0, len(nums))\\n        \\n    def helper(self, nums, l, r):\\n        mid = l + r >> 1\\n        if mid == l: return 0\\n        total = self.helper(nums, l, mid) + self.helper(nums, mid, r)\\n        prev_total = 0\\n        for i in range(l, mid):\\n            target = nums[i] - 1 >> 1\\n            idx = bisect.bisect_right(nums, target, mid, r)\\n            prev_total += idx - mid\\n            mid = idx\\n            total += prev_total\\n        nums[l: r] = sorted(nums[l: r])\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        return self.helper(nums, 0, len(nums))\\n        \\n    def helper(self, nums, l, r):\\n        mid = l + r >> 1\\n        if mid == l: return 0\\n        total = self.helper(nums, l, mid) + self.helper(nums, mid, r)\\n        prev_total = 0\\n        for i in range(l, mid):\\n            target = nums[i] - 1 >> 1\\n            idx = bisect.bisect_right(nums, target, mid, r)\\n            prev_total += idx - mid\\n            mid = idx\\n            total += prev_total\\n        nums[l: r] = sorted(nums[l: r])\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97330,
                "title": "slow-but-pass-but-short-and-self-explaination-d-c",
                "content": "    class Solution {\\n    public:\\n        int reversePairs(vector<int>& nums) {\\n            vector<long long> m(nums.begin(), nums.end());\\n            return helper(m.begin(), m.end());\\n        }\\n    \\n        int helper(vector<long long>::iterator b, vector<long long>::iterator e) {\\n            if (e - b < 2) return 0;\\n            auto m = b + distance(b, e) / 2;\\n            int res = helper(b, m) + helper(m, e);\\n            sort(b, m);\\n            for (auto s = m; s != e; ++s) {\\n                res += m - upper_bound(b, m, 2 * *s);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int reversePairs(vector<int>& nums) {\\n            vector<long long> m(nums.begin(), nums.end());\\n            return helper(m.begin(), m.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4081732,
                "title": "divide-and-conquer-merge-sort-java-solution-short-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the divide and conquer pattern of Merge Sort. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHave the left half and right half array return their counts, then count the reverse pairs across the two sub-arrays, and return the total of three.\\n\\nNeed to take care of integer overflow. We cannot do 2 * nums[j] since this would overflow. One way is to use long. Another way is to use division since that will not overflow. \\n\\n# Complexity\\n- Time complexity: O(N*logN*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        // base case\\n        if (nums.length <= 1) {\\n            return 0;\\n        }\\n        // divide and conquer\\n        int[] leftArray = Arrays.copyOfRange(nums, 0, nums.length / 2);\\n        int[] rightArray = Arrays.copyOfRange(nums, nums.length / 2, nums.length);\\n        int left = reversePairs(leftArray);\\n        int right = reversePairs(rightArray);\\n        Arrays.sort(leftArray);\\n        Arrays.sort(rightArray);\\n        int cross = countCrossInversions(leftArray, rightArray);\\n        return left + right + cross;\\n\\n    }\\n\\n    private int countCrossInversions(int[] num1, int[] num2) {\\n        int count = 0;\\n        int i = 0, j = 0; // two pointers\\n        while (i < num1.length && j < num2.length) {\\n            if (isReverse(num1[i], num2[j])) {\\n                // we find all inversions with num2[j], hence need to move j\\n                count += (num1.length - i);\\n                j++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private boolean isReverse(int a, int b) {\\n        return (a % 2 == 0) ? a / 2 > b : (a - 1) / 2 >= b;\\n    }\\n}\\n\\n// Time Complexity O(N*logN*logN)\\n// Space Complexity O(N)\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        // base case\\n        if (nums.length <= 1) {\\n            return 0;\\n        }\\n        // divide and conquer\\n        int[] leftArray = Arrays.copyOfRange(nums, 0, nums.length / 2);\\n        int[] rightArray = Arrays.copyOfRange(nums, nums.length / 2, nums.length);\\n        int left = reversePairs(leftArray);\\n        int right = reversePairs(rightArray);\\n        Arrays.sort(leftArray);\\n        Arrays.sort(rightArray);\\n        int cross = countCrossInversions(leftArray, rightArray);\\n        return left + right + cross;\\n\\n    }\\n\\n    private int countCrossInversions(int[] num1, int[] num2) {\\n        int count = 0;\\n        int i = 0, j = 0; // two pointers\\n        while (i < num1.length && j < num2.length) {\\n            if (isReverse(num1[i], num2[j])) {\\n                // we find all inversions with num2[j], hence need to move j\\n                count += (num1.length - i);\\n                j++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private boolean isReverse(int a, int b) {\\n        return (a % 2 == 0) ? a / 2 > b : (a - 1) / 2 >= b;\\n    }\\n}\\n\\n// Time Complexity O(N*logN*logN)\\n// Space Complexity O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022890,
                "title": "simple-code-with-the-explanation-of-intuition-with-the-comment",
                "content": "# Intuition\\nThe intuition is based on the **Merge Sort**.As we know the merge sort is a divide and conquer algorithm.It is basically divide the whole array into left and right halves and then perform comparison operation for each element to make sure set at the correct position that\\'s why merge sort is also called the COMPARISONS ALGORITHM.So we use this property of merge sort to solve our problems\\n\\n# Approach\\n1. Perform merge divide arrays into left and right half,by below calls.\\n\\n   `mergeSort(nums,low,mid);\\n    mergeSort(nums,mid+1,high); `\\n\\n 2. Now call the mergesort function to merge the elements into its correct position but before merge the all element we have to count the numbers of elements(2*element) in right array are smaller then current element is the left array \\n This piece of code is help to count the pairs:\\n`while(i<=mid)\\n        {\\n            while(j<=high && nums[i]>(long long)2*nums[j])\\n            {\\n                j++;\\n            }\\n            total+=(j-(mid+1));\\n            i++;\\n        }`\\n* For each element of left array we check the right array ,how many elements(2*element) in the right array are smaller than the current element in the left array.We simply take their count and add to our total count answer\\n# Complexity\\n- Time complexity:Same as Merge Sort : O(nlogn)\\n\\n- Space complexity: O(N) Negligible \\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    int pairCount=0;\\n    void merge(vector<int>& nums,int low,int mid,int high){\\n        int total=0;\\n        int i=low;\\n        int j=mid+1;\\n        // only this piece of code is include else whole code is same as a merge sort\\n    // incode from line 10-18 we only count the number of 2*nums[j] are smaller than nums[i]\\n        while(i<=mid)\\n        {\\n            while(j<=high && nums[i]>(long long)2*nums[j])\\n            {\\n                j++;\\n            }\\n            total+=(j-(mid+1));\\n            i++;\\n        }        \\n        //now perform merge function to set elements in the correct posn \\n        vector<int> temp;\\n        i=low;\\n        j=mid+1;\\n> //apply merge sort for the set the element to their correct position\\n        while(i<=mid && j<=high){\\n            if(nums[i]<nums[j]){\\n                temp.push_back(nums[i++]);\\n            }else{\\n                temp.push_back(nums[j++]);\\n            }\\n        }\\n        //mrege remaining left halves elements\\n        while(i<=mid){\\n            temp.push_back(nums[i++]);\\n        }\\n         //mrege remaining right halves elements\\n        while(j<=high){\\n            temp.push_back(nums[j++]);\\n        }\\n        // move all elements from temp array to original(nums) array\\n        for(int it=low;it<=high;it++){\\n            nums[it]=temp[it-low];\\n        }\\n        pairCount+=total;\\n    }\\n    void mergeSort(vector<int>& nums,int low,int high){\\n        if(low<high){\\n            int mid=low+(high-low)/2;\\n            mergeSort(nums,low,mid);\\n            mergeSort(nums,mid+1,high);\\n            merge(nums,low,mid,high);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return pairCount;\\n    }\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int pairCount=0;\\n    void merge(vector<int>& nums,int low,int mid,int high){\\n        int total=0;\\n        int i=low;\\n        int j=mid+1;\\n        // only this piece of code is include else whole code is same as a merge sort\\n    // incode from line 10-18 we only count the number of 2*nums[j] are smaller than nums[i]\\n        while(i<=mid)\\n        {\\n            while(j<=high && nums[i]>(long long)2*nums[j])\\n            {\\n                j++;\\n            }\\n            total+=(j-(mid+1));\\n            i++;\\n        }        \\n        //now perform merge function to set elements in the correct posn \\n        vector<int> temp;\\n        i=low;\\n        j=mid+1;\\n> //apply merge sort for the set the element to their correct position\\n        while(i<=mid && j<=high){\\n            if(nums[i]<nums[j]){\\n                temp.push_back(nums[i++]);\\n            }else{\\n                temp.push_back(nums[j++]);\\n            }\\n        }\\n        //mrege remaining left halves elements\\n        while(i<=mid){\\n            temp.push_back(nums[i++]);\\n        }\\n         //mrege remaining right halves elements\\n        while(j<=high){\\n            temp.push_back(nums[j++]);\\n        }\\n        // move all elements from temp array to original(nums) array\\n        for(int it=low;it<=high;it++){\\n            nums[it]=temp[it-low];\\n        }\\n        pairCount+=total;\\n    }\\n    void mergeSort(vector<int>& nums,int low,int high){\\n        if(low<high){\\n            int mid=low+(high-low)/2;\\n            mergeSort(nums,low,mid);\\n            mergeSort(nums,mid+1,high);\\n            merge(nums,low,mid,high);\\n        }\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return pairCount;\\n    }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878052,
                "title": "mergesort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count;\\n    public int reversePairs(int[] nums) {\\n        count = 0;\\n        merger(nums,0,nums.length-1);\\n\\n        return count;\\n    }\\n    private ArrayList<Integer> merge(ArrayList<Integer> left,ArrayList<Integer> right){\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        int i = 0;\\n        int j = 0;\\n        while(i < left.size() && j < right.size()){\\n            if (left.get(i) >right.get(j)){\\n                ans.add(right.get(j));\\n                j++;\\n            }\\n            else {\\n                ans.add(left.get(i));\\n                i++;\\n            }\\n           /* else if(left.get(i) == right.get(j)){\\n                ans.add(left.get(i));\\n                ans.add(right.get(j));\\n                i++;\\n                j++;\\n            }*/\\n        }\\n        if ( i < left.size()){\\n            while (i <left.size())\\n             ans.add(left.get(i++));\\n        }\\n        if(j < right.size()){\\n            while (j < right.size())\\n             ans.add(right.get(j++));\\n        }\\n        return ans;\\n    }\\n    private void helper(ArrayList<Integer> left,ArrayList<Integer> right){\\n        int i = 0;\\n        int j = 0;\\n        while (i < left.size() && j < right.size()){\\n            if(left.get(i) > 2*(long)right.get(j)){\\n                count += left.size() - i;\\n                j++;\\n            }\\n            else\\n            i++;\\n        }\\n        \\n    }\\n    private ArrayList<Integer> merger(int[] nums,int start,int end){\\n        if(start == end){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(nums[start]);\\n            return temp;\\n        }\\n        int mid = (start + end)/2;\\n        \\n        ArrayList<Integer> left = merger(nums,start,mid);\\n        ArrayList<Integer> right = merger(nums,mid+1,end);\\n        helper(left,right);\\n        \\n        return merge(left,right);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int reversePairs(int[] nums) {\\n        count = 0;\\n        merger(nums,0,nums.length-1);\\n\\n        return count;\\n    }\\n    private ArrayList<Integer> merge(ArrayList<Integer> left,ArrayList<Integer> right){\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        int i = 0;\\n        int j = 0;\\n        while(i < left.size() && j < right.size()){\\n            if (left.get(i) >right.get(j)){\\n                ans.add(right.get(j));\\n                j++;\\n            }\\n            else {\\n                ans.add(left.get(i));\\n                i++;\\n            }\\n           /* else if(left.get(i) == right.get(j)){\\n                ans.add(left.get(i));\\n                ans.add(right.get(j));\\n                i++;\\n                j++;\\n            }*/\\n        }\\n        if ( i < left.size()){\\n            while (i <left.size())\\n             ans.add(left.get(i++));\\n        }\\n        if(j < right.size()){\\n            while (j < right.size())\\n             ans.add(right.get(j++));\\n        }\\n        return ans;\\n    }\\n    private void helper(ArrayList<Integer> left,ArrayList<Integer> right){\\n        int i = 0;\\n        int j = 0;\\n        while (i < left.size() && j < right.size()){\\n            if(left.get(i) > 2*(long)right.get(j)){\\n                count += left.size() - i;\\n                j++;\\n            }\\n            else\\n            i++;\\n        }\\n        \\n    }\\n    private ArrayList<Integer> merger(int[] nums,int start,int end){\\n        if(start == end){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(nums[start]);\\n            return temp;\\n        }\\n        int mid = (start + end)/2;\\n        \\n        ArrayList<Integer> left = merger(nums,start,mid);\\n        ArrayList<Integer> right = merger(nums,mid+1,end);\\n        helper(left,right);\\n        \\n        return merge(left,right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861231,
                "title": "simple-c-solution-using-merge-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &nums, int low, int mid, int high) {\\n        vector<int> temp; // temporary numsay\\n        int left = low;      // starting index of left half of nums\\n        int right = mid + 1;   // starting index of right half of nums\\n\\n        //storing elements in the temporary numsay in a sorted manner//\\n        while (left <= mid && right <= high) {\\n            if (nums[left] <= nums[right]) {\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n            else {\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        // if elements on the left half are still left //\\n        while (left <= mid) {\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        //  if elements on the right half are still left //\\n        while (right <= high) {\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n        // transfering all elements from temporary to nums //\\n        for (int i = low; i <= high; i++) {\\n            nums[i] = temp[i - low];\\n        }\\n    }\\n    \\n    int countPairs(vector<int> &nums, int low,int mid, int high) {\\n        int right=mid+1;\\n        int cnt=0;\\n        for(int i=low;i<=mid;i++) {\\n            while(right<=high && nums[i]> 2* (long long) nums[right])\\n                ++right;\\n            cnt += (right-(mid+1));\\n        }\\n        return cnt;\\n    }\\n    int mergeSort(vector<int>& nums, int low, int high) {\\n        int count = 0;\\n        if (low >= high) \\n            return 0;\\n        int mid = (low + high) / 2 ;\\n        count += mergeSort(nums, low, mid);\\n        count += mergeSort(nums, mid + 1, high);\\n        count += countPairs(nums, low, mid, high);\\n        merge(nums, low, mid, high);\\n        return count;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums, 0, nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &nums, int low, int mid, int high) {\\n        vector<int> temp; // temporary numsay\\n        int left = low;      // starting index of left half of nums\\n        int right = mid + 1;   // starting index of right half of nums\\n\\n        //storing elements in the temporary numsay in a sorted manner//\\n        while (left <= mid && right <= high) {\\n            if (nums[left] <= nums[right]) {\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n            else {\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        // if elements on the left half are still left //\\n        while (left <= mid) {\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        //  if elements on the right half are still left //\\n        while (right <= high) {\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n        // transfering all elements from temporary to nums //\\n        for (int i = low; i <= high; i++) {\\n            nums[i] = temp[i - low];\\n        }\\n    }\\n    \\n    int countPairs(vector<int> &nums, int low,int mid, int high) {\\n        int right=mid+1;\\n        int cnt=0;\\n        for(int i=low;i<=mid;i++) {\\n            while(right<=high && nums[i]> 2* (long long) nums[right])\\n                ++right;\\n            cnt += (right-(mid+1));\\n        }\\n        return cnt;\\n    }\\n    int mergeSort(vector<int>& nums, int low, int high) {\\n        int count = 0;\\n        if (low >= high) \\n            return 0;\\n        int mid = (low + high) / 2 ;\\n        count += mergeSort(nums, low, mid);\\n        count += mergeSort(nums, mid + 1, high);\\n        count += countPairs(nums, low, mid, high);\\n        merge(nums, low, mid, high);\\n        return count;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        return mergeSort(nums, 0, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815265,
                "title": "simple-n-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\n\\n        \\n\\n        N = len(nums)\\n        tot = 0\\n        sorted_right_side = [nums[-1]*2]\\n        for j in range(N-2,-1,-1):\\n\\n            n = nums[j]\\n            # count of numbers that are < 2 * n\\n            tot += bisect.bisect_left(sorted_right_side,n)\\n\\n            bisect.insort(sorted_right_side, n*2)\\n\\n\\n        return tot\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        \\n\\n        \\n\\n        N = len(nums)\\n        tot = 0\\n        sorted_right_side = [nums[-1]*2]\\n        for j in range(N-2,-1,-1):\\n\\n            n = nums[j]\\n            # count of numbers that are < 2 * n\\n            tot += bisect.bisect_left(sorted_right_side,n)\\n\\n            bisect.insort(sorted_right_side, n*2)\\n\\n\\n        return tot\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754635,
                "title": "merge-sort-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mergSort(vector<int>&num,int l,int h){\\n        if(l>=h)\\n            return 0;\\n        int m=(l+h)/2;\\n        int ans=0;\\n        ans+=mergSort(num,l,m);\\n        ans+=mergSort(num,m+1,h);\\n        ans+=merg(num,l,m,h);\\n        return ans;\\n    }\\n    int merg(vector<int> &num,int l,int m,int r){\\n        int left=l,right=m+1,ans=0;\\n        while(left<=m && right<=r)\\n            if(num[left]>(1ll*2*num[right])){\\n                ans+=m-left+1;right++;\\n            }\\n            else left++;            \\n        sort(num.begin()+l,num.begin()+r+1);\\n        return ans;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        return mergSort(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    int mergSort(vector<int>&num,int l,int h){\\n        if(l>=h)\\n            return 0;\\n        int m=(l+h)/2;\\n        int ans=0;\\n        ans+=mergSort(num,l,m);\\n        ans+=mergSort(num,m+1,h);\\n        ans+=merg(num,l,m,h);\\n        return ans;\\n    }\\n    int merg(vector<int> &num,int l,int m,int r){\\n        int left=l,right=m+1,ans=0;\\n        while(left<=m && right<=r)\\n            if(num[left]>(1ll*2*num[right])){\\n                ans+=m-left+1;right++;\\n            }\\n            else left++;            \\n        sort(num.begin()+l,num.begin()+r+1);\\n        return ans;\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        return mergSort(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741029,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code uses merger sort approach.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<long long>merge(vector<long long>&v1, vector<long long>&v2){\\n        long long l1=v1.size();\\n        long long l2=v2.size();\\n        vector<long long>v;\\n        long long pt1=0,pt2=0;\\n        while(pt1<l1 && pt2<l2){\\n            if(v1[pt1]<=v2[pt2]){\\n                v.push_back(v1[pt1]);\\n                pt1++;\\n            }else{\\n                v.push_back(v2[pt2]);\\n                pt2++;\\n            }\\n        }\\n        while(pt1<l1){\\n            v.push_back(v1[pt1]);\\n            pt1++;\\n        }\\n        while(pt2<l2){\\n            v.push_back(v2[pt2]);\\n            pt2++;\\n        }\\n        return v;\\n    }\\n    vector<long long> mergeSort(int l,int h,vector<int>& nums){\\n        if(l==h)return {nums[l]};\\n        long long m=(l+h)/2;\\n        vector<long long>v1 = mergeSort(l,m,nums);\\n        vector<long long>v2 = mergeSort(m+1,h,nums);\\n        long long l1=v1.size(), l2=v2.size();\\n        long long p1=0,p2=0;\\n        while(p1<l1 && p2<l2){\\n             if(v1[p1] <= 2*v2[p2]){\\n                 p1++;\\n             }else{\\n                 ans+=l1-p1;\\n                 p2++;\\n             }\\n        }\\n        return merge(v1,v2);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long>v=mergeSort(0,n-1,nums);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<long long>merge(vector<long long>&v1, vector<long long>&v2){\\n        long long l1=v1.size();\\n        long long l2=v2.size();\\n        vector<long long>v;\\n        long long pt1=0,pt2=0;\\n        while(pt1<l1 && pt2<l2){\\n            if(v1[pt1]<=v2[pt2]){\\n                v.push_back(v1[pt1]);\\n                pt1++;\\n            }else{\\n                v.push_back(v2[pt2]);\\n                pt2++;\\n            }\\n        }\\n        while(pt1<l1){\\n            v.push_back(v1[pt1]);\\n            pt1++;\\n        }\\n        while(pt2<l2){\\n            v.push_back(v2[pt2]);\\n            pt2++;\\n        }\\n        return v;\\n    }\\n    vector<long long> mergeSort(int l,int h,vector<int>& nums){\\n        if(l==h)return {nums[l]};\\n        long long m=(l+h)/2;\\n        vector<long long>v1 = mergeSort(l,m,nums);\\n        vector<long long>v2 = mergeSort(m+1,h,nums);\\n        long long l1=v1.size(), l2=v2.size();\\n        long long p1=0,p2=0;\\n        while(p1<l1 && p2<l2){\\n             if(v1[p1] <= 2*v2[p2]){\\n                 p1++;\\n             }else{\\n                 ans+=l1-p1;\\n                 p2++;\\n             }\\n        }\\n        return merge(v1,v2);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long>v=mergeSort(0,n-1,nums);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629504,
                "title": "easiest-mergesort-no-change-in-merge-func-100-java-c-please-upvote",
                "content": "# Intuition\\nTo get an intuition of merge sort u think basically we have to check how many elements are greater as per some condtion like inversions SO in these kind of problems merge sort can be used beacuase we comapre left subarray which is sorted to right subarray through that we can minimize time complexity beacuse we don\\'t need to chekc all combinations .. That is key thing about merge sort just like it makes sorting in nlogn\\n\\n# Approach\\nJust Modified Merge sort only a change in merge function count as per condition rest is same\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res=0;\\n    public int reversePairs(int[] nums) {\\n        sort(nums,0,nums.length-1);\\n        return res;\\n    }\\n //No change in merge function\\n     void merge(int arr[], int l, int m, int r)\\n    {\\n        // Find sizes of two subarrays to be merged\\n        int n1 = m - l + 1;\\n        int n2 = r - m;\\n \\n        // Create temp arrays\\n        int L[] = new int[n1];\\n        int R[] = new int[n2];\\n \\n        // Copy data to temp arrays\\n        for (int i = 0; i < n1; ++i)\\n            L[i] = arr[l + i];\\n        for (int j = 0; j < n2; ++j)\\n            R[j] = arr[m + 1 + j];\\n \\n        // Merge the temp arrays\\n \\n        // Initial indices of first and second subarrays\\n        int i = 0, j = 0;\\n \\n        // Initial index of merged subarray array\\n        int k = l;\\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j]) {\\n                arr[k] = L[i];\\n                i++;\\n            }\\n            else {\\n                arr[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n \\n        // Copy remaining elements of L[] if any\\n        while (i < n1) {\\n            arr[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n \\n        // Copy remaining elements of R[] if any\\n        while (j < n2) {\\n            arr[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n\\n    void sort(int arr[], int l, int r)\\n    {\\n        if (l < r) {\\n            int m = l + (r - l) / 2;\\n            sort(arr, l, m);\\n            sort(arr, m + 1, r);\\n            int i=0,j=0;\\n            for(  i=l;i<=m;i++){\\n              for( j=m+1;j<=r;j++){\\n                  if(arr[i]<=2*(long)arr[j]){\\n                       res+=j-m-1;\\n                       i++;\\n                       j--;\\n                       if(i>m){j++; break;}\\n                       }        \\n              }\\n              if(j>r)\\n              res+=(r-m)*(m-i+1);\\n                   break;  \\n            }\\n                  \\n            merge(arr, l, m, r);\\n        }\\n    }    \\n} \\n```\\n![image.png](https://assets.leetcode.com/users/images/56c68041-6390-4655-a3b3-ce9e12abaf83_1686575799.739806.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    public int reversePairs(int[] nums) {\\n        sort(nums,0,nums.length-1);\\n        return res;\\n    }\\n //No change in merge function\\n     void merge(int arr[], int l, int m, int r)\\n    {\\n        // Find sizes of two subarrays to be merged\\n        int n1 = m - l + 1;\\n        int n2 = r - m;\\n \\n        // Create temp arrays\\n        int L[] = new int[n1];\\n        int R[] = new int[n2];\\n \\n        // Copy data to temp arrays\\n        for (int i = 0; i < n1; ++i)\\n            L[i] = arr[l + i];\\n        for (int j = 0; j < n2; ++j)\\n            R[j] = arr[m + 1 + j];\\n \\n        // Merge the temp arrays\\n \\n        // Initial indices of first and second subarrays\\n        int i = 0, j = 0;\\n \\n        // Initial index of merged subarray array\\n        int k = l;\\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j]) {\\n                arr[k] = L[i];\\n                i++;\\n            }\\n            else {\\n                arr[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n \\n        // Copy remaining elements of L[] if any\\n        while (i < n1) {\\n            arr[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n \\n        // Copy remaining elements of R[] if any\\n        while (j < n2) {\\n            arr[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n\\n    void sort(int arr[], int l, int r)\\n    {\\n        if (l < r) {\\n            int m = l + (r - l) / 2;\\n            sort(arr, l, m);\\n            sort(arr, m + 1, r);\\n            int i=0,j=0;\\n            for(  i=l;i<=m;i++){\\n              for( j=m+1;j<=r;j++){\\n                  if(arr[i]<=2*(long)arr[j]){\\n                       res+=j-m-1;\\n                       i++;\\n                       j--;\\n                       if(i>m){j++; break;}\\n                       }        \\n              }\\n              if(j>r)\\n              res+=(r-m)*(m-i+1);\\n                   break;  \\n            }\\n                  \\n            merge(arr, l, m, r);\\n        }\\n    }    \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577362,
                "title": "c-most-optimal-code-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // the whole process is exact same as merge sort and cnt inversions \\n    // just a little change in counting is there\\n    int merge(vector<int> &nums,int low,int mid,int high){\\n        int total=0;\\n        int j=mid+1;\\n        for(int i=low;i<=mid;i++){\\n            while(j<=high && (long)nums[i]>(long)2*nums[j]) j++;\\n            // STEP3\\n            // this will cnt the possible pairs \\n            total+=j-(mid+1);\\n        }\\n        // STEP4\\n        // this is to merge the array\\n        vector<int> t;\\n        int left=low,right=mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                t.push_back(nums[left]);\\n                left++;\\n            }\\n            else{\\n                t.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left<=mid){\\n            t.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right<=high){\\n            t.push_back(nums[right]);\\n            right++;\\n        }\\n        for(int i=low;i<=high;i++){\\n            nums[i]=t[i-low];\\n        }\\n        return total;\\n    }\\n    int mergesort(vector<int> &nums,int low, int high){\\n        if(low>=high) return 0;\\n        int mid=(low+high)/2;\\n        // STEP2 \\n        // cnt all the possible pairs \\n        int cnt=0;\\n        cnt+=mergesort(nums,low,mid);\\n        cnt+=mergesort(nums,mid+1,high);\\n        cnt+=merge(nums,low,mid,high);\\n        return cnt;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        // STEP1\\n        // apply merge sort on whole array\\n        return mergesort(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // the whole process is exact same as merge sort and cnt inversions \\n    // just a little change in counting is there\\n    int merge(vector<int> &nums,int low,int mid,int high){\\n        int total=0;\\n        int j=mid+1;\\n        for(int i=low;i<=mid;i++){\\n            while(j<=high && (long)nums[i]>(long)2*nums[j]) j++;\\n            // STEP3\\n            // this will cnt the possible pairs \\n            total+=j-(mid+1);\\n        }\\n        // STEP4\\n        // this is to merge the array\\n        vector<int> t;\\n        int left=low,right=mid+1;\\n        while(left<=mid && right<=high){\\n            if(nums[left]<=nums[right]){\\n                t.push_back(nums[left]);\\n                left++;\\n            }\\n            else{\\n                t.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left<=mid){\\n            t.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right<=high){\\n            t.push_back(nums[right]);\\n            right++;\\n        }\\n        for(int i=low;i<=high;i++){\\n            nums[i]=t[i-low];\\n        }\\n        return total;\\n    }\\n    int mergesort(vector<int> &nums,int low, int high){\\n        if(low>=high) return 0;\\n        int mid=(low+high)/2;\\n        // STEP2 \\n        // cnt all the possible pairs \\n        int cnt=0;\\n        cnt+=mergesort(nums,low,mid);\\n        cnt+=mergesort(nums,mid+1,high);\\n        cnt+=merge(nums,low,mid,high);\\n        return cnt;\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        // STEP1\\n        // apply merge sort on whole array\\n        return mergesort(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553278,
                "title": "important-comment-striver-technique-c-accepted-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLOOK AT CODE PLEASE\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(NLOGN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   void  counting ( int i1, int j1 , int i2 , int j2 ,vector<int>&nums ,int&count )\\n   {\\n////////// right portion --> i  of merge sort array act \\'i\\' and  left portion of merge sort array act as \\'j\\' (because i<j)\\n//left side sorted array --> i\\'s array \\n//right side sorted array --> j\\'s array \\n\\n//question condition nums[i] > 2* nums[j] (i<j)\\n\\n         while( i1<=j1 && i2 <=j2)\\n         {\\n\\n              double check = nums[i2]; //double prevent from INT_MAX condition \\n              check = check*2;\\n\\n              if( nums[i1]>check)\\n              {\\n                \\n                   count = count+ (j1-i1+1);\\n/// it kisi particular i1 ke liye satisfy ho gya to rest ( current i1 to j1) ke liye bhi hoga ( because i1, i2 wala array is shorted )\\n                  \\n /////j2 ko pecche se mat  dekhna  start karna kyuki \\n  // i [1,2,3,4]  ,  j [1,10,12 ]\\n  //  iss case me fail ho jayega                  \\n                   i2++;\\n              }\\n              else\\n              {\\n                   i1++;\\n              }\\n\\n\\n         }\\n   }\\n\\n   ///////////////////////this is complete merge sort \\n    void merge_sort ( vector<int>&nums , int i1 , int j2 ,int &count )\\n    {\\n        if( i1>=j2) { return;  }\\n        int mid = (i1+j2)/2;     \\n        merge_sort( nums , i1 , mid, count  ); \\n        merge_sort( nums , mid+1, j2 , count  );  \\n         int j1 = mid; \\n         int i2 = mid+1;\\n       \\n       ////////////checking/counting question condition \\n        counting( i1, j1 ,i2 ,j2 ,nums ,count  );\\n       \\n      vector<int>ans ;\\n \\n int ind =i1;\\n      while( i1<=j1 && i2<=j2 )\\n      {\\n  if( nums[i1]>nums[i2])\\n  {\\n      ans.push_back( nums[i2]);\\n       i2++;\\n  }\\n\\n  else{\\n      ans.push_back( nums[i1]);\\n       i1++;\\n  }\\n      }\\n\\n      while( i1<=j1)\\n      {\\n           ans.push_back(nums[i1]);\\n           i1++;\\n      }\\n\\n        while( i2<=j2)\\n      {\\n           ans.push_back(nums[i2]);\\n           i2++;\\n      }\\n \\n\\n        for( int i =0 ; i<ans.size(); i++ )\\n        {  \\n            \\n             nums[ind+i] = ans[i];\\n          \\n        }\\n     return;        \\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        \\n        int count = 0 ;\\n        merge_sort( nums , 0 , nums.size()-1 , count);\\n        \\n        \\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   void  counting ( int i1, int j1 , int i2 , int j2 ,vector<int>&nums ,int&count )\\n   {\\n////////// right portion --> i  of merge sort array act \\'i\\' and  left portion of merge sort array act as \\'j\\' (because i<j)\\n//left side sorted array --> i\\'s array \\n//right side sorted array --> j\\'s array \\n\\n//question condition nums[i] > 2* nums[j] (i<j)\\n\\n         while( i1<=j1 && i2 <=j2)\\n         {\\n\\n              double check = nums[i2]; //double prevent from INT_MAX condition \\n              check = check*2;\\n\\n              if( nums[i1]>check)\\n              {\\n                \\n                   count = count+ (j1-i1+1);\\n/// it kisi particular i1 ke liye satisfy ho gya to rest ( current i1 to j1) ke liye bhi hoga ( because i1, i2 wala array is shorted )\\n                  \\n /////j2 ko pecche se mat  dekhna  start karna kyuki \\n  // i [1,2,3,4]  ,  j [1,10,12 ]\\n  //  iss case me fail ho jayega                  \\n                   i2++;\\n              }\\n              else\\n              {\\n                   i1++;\\n              }\\n\\n\\n         }\\n   }\\n\\n   ///////////////////////this is complete merge sort \\n    void merge_sort ( vector<int>&nums , int i1 , int j2 ,int &count )\\n    {\\n        if( i1>=j2) { return;  }\\n        int mid = (i1+j2)/2;     \\n        merge_sort( nums , i1 , mid, count  ); \\n        merge_sort( nums , mid+1, j2 , count  );  \\n         int j1 = mid; \\n         int i2 = mid+1;\\n       \\n       ////////////checking/counting question condition \\n        counting( i1, j1 ,i2 ,j2 ,nums ,count  );\\n       \\n      vector<int>ans ;\\n \\n int ind =i1;\\n      while( i1<=j1 && i2<=j2 )\\n      {\\n  if( nums[i1]>nums[i2])\\n  {\\n      ans.push_back( nums[i2]);\\n       i2++;\\n  }\\n\\n  else{\\n      ans.push_back( nums[i1]);\\n       i1++;\\n  }\\n      }\\n\\n      while( i1<=j1)\\n      {\\n           ans.push_back(nums[i1]);\\n           i1++;\\n      }\\n\\n        while( i2<=j2)\\n      {\\n           ans.push_back(nums[i2]);\\n           i2++;\\n      }\\n \\n\\n        for( int i =0 ; i<ans.size(); i++ )\\n        {  \\n            \\n             nums[ind+i] = ans[i];\\n          \\n        }\\n     return;        \\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        \\n        int count = 0 ;\\n        merge_sort( nums , 0 , nums.size()-1 , count);\\n        \\n        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353978,
                "title": "striver-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void merge(vector<int> &nums, int low, int mid ,int high, int &count)\\n    {\\n        int j = mid + 1;\\n        for(int i = low; i<=mid ; i++)\\n        {\\n            while(j<=high && nums[i] > 2*(long long)nums[j])\\n            {\\n                j++;\\n            }\\n            count += j - (mid+1);\\n        }\\n        int size = high - low + 1;\\n        vector<int> temp(size, 0);\\n        int left = low, right = mid+1, k=0;\\n        while(left <= mid && right <= high)\\n        {\\n            if(nums[left] < nums[right])\\n            {\\n                temp[k++] = nums[left++];\\n            }\\n            else\\n            {\\n                temp[k++] = nums[right++];\\n            }\\n        }\\n\\n        while(left <= mid)\\n        {\\n            temp[k++] = nums[left++];\\n        }\\n        while(right <= high)\\n        {\\n            temp[k++] = nums[right++];\\n        }\\n        int m = 0;\\n        for(int i = low; i<= high; i++)\\n        {\\n            nums[i] = temp[m++];\\n        }\\n    } \\n    void mergesort(vector<int> &nums, int low, int high,  int &count)\\n    {\\n        if(low>=high)\\n        {\\n            return ;\\n        }\\n        int mid = (high+low)/2;\\n        mergesort(nums,low,mid, count);\\n        mergesort(nums,mid+1,high, count);\\n        merge(nums,low, mid, high, count);\\n    }\\npublic :\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        mergesort(nums,0,nums.size()-1, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void merge(vector<int> &nums, int low, int mid ,int high, int &count)\\n    {\\n        int j = mid + 1;\\n        for(int i = low; i<=mid ; i++)\\n        {\\n            while(j<=high && nums[i] > 2*(long long)nums[j])\\n            {\\n                j++;\\n            }\\n            count += j - (mid+1);\\n        }\\n        int size = high - low + 1;\\n        vector<int> temp(size, 0);\\n        int left = low, right = mid+1, k=0;\\n        while(left <= mid && right <= high)\\n        {\\n            if(nums[left] < nums[right])\\n            {\\n                temp[k++] = nums[left++];\\n            }\\n            else\\n            {\\n                temp[k++] = nums[right++];\\n            }\\n        }\\n\\n        while(left <= mid)\\n        {\\n            temp[k++] = nums[left++];\\n        }\\n        while(right <= high)\\n        {\\n            temp[k++] = nums[right++];\\n        }\\n        int m = 0;\\n        for(int i = low; i<= high; i++)\\n        {\\n            nums[i] = temp[m++];\\n        }\\n    } \\n    void mergesort(vector<int> &nums, int low, int high,  int &count)\\n    {\\n        if(low>=high)\\n        {\\n            return ;\\n        }\\n        int mid = (high+low)/2;\\n        mergesort(nums,low,mid, count);\\n        mergesort(nums,mid+1,high, count);\\n        merge(nums,low, mid, high, count);\\n    }\\npublic :\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        mergesort(nums,0,nums.size()-1, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248529,
                "title": "find-reverse-pair",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public static int count(int arr[],int si,int mid,int ei)\\n    {\\n        int max_cnt = 0;\\n        int j = mid+1;\\n        for (int i=si;i<=mid;i++){\\n            while (j<=ei && arr[i] > (2*(long)arr[j])) j++;\\n            max_cnt += j - (mid+1);\\n        }\\n        int temp[]=new int[ei-si+1];//array index start from 0\\n        int i=si;\\n        j=mid+1;\\n        int tempIndex=0;\\n        while(i<=mid && j<=ei)\\n        {\\n            if(arr[i]<arr[j])\\n            {\\n                temp[tempIndex]=arr[i];\\n                i++;\\n                tempIndex++;\\n            }\\n            else\\n            {\\n                temp[tempIndex]=arr[j];\\n                j++;\\n                tempIndex++;\\n            }\\n        }\\n        //for remaining elemnts\\n        //left\\n        while(i<=mid)\\n        {\\n            temp[tempIndex++]=arr[i++];\\n        }\\n        //right\\n        while(j<=ei)\\n        {\\n            temp[tempIndex++]=arr[j++];\\n        }\\n        i=si;\\n        for(int k=0;k<temp.length;k++)\\n        {\\n            arr[i]=temp[k];\\n            i++;\\n        }\\n        return max_cnt;\\n    }\\n    public static int mergeSort(int arr[],int si,int ei)\\n    {\\n        if(si>=ei)\\n        {\\n            return 0;\\n        }\\n        int mid=si+(ei-si)/2;\\n        int c=mergeSort(arr,si,mid);\\n        c+=mergeSort(arr,mid+1,ei);\\n        c+=count(arr,si,mid,ei);\\n        return c;\\n    }\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums,0,nums.length-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public static int count(int arr[],int si,int mid,int ei)\\n    {\\n        int max_cnt = 0;\\n        int j = mid+1;\\n        for (int i=si;i<=mid;i++){\\n            while (j<=ei && arr[i] > (2*(long)arr[j])) j++;\\n            max_cnt += j - (mid+1);\\n        }\\n        int temp[]=new int[ei-si+1];//array index start from 0\\n        int i=si;\\n        j=mid+1;\\n        int tempIndex=0;\\n        while(i<=mid && j<=ei)\\n        {\\n            if(arr[i]<arr[j])\\n            {\\n                temp[tempIndex]=arr[i];\\n                i++;\\n                tempIndex++;\\n            }\\n            else\\n            {\\n                temp[tempIndex]=arr[j];\\n                j++;\\n                tempIndex++;\\n            }\\n        }\\n        //for remaining elemnts\\n        //left\\n        while(i<=mid)\\n        {\\n            temp[tempIndex++]=arr[i++];\\n        }\\n        //right\\n        while(j<=ei)\\n        {\\n            temp[tempIndex++]=arr[j++];\\n        }\\n        i=si;\\n        for(int k=0;k<temp.length;k++)\\n        {\\n            arr[i]=temp[k];\\n            i++;\\n        }\\n        return max_cnt;\\n    }\\n    public static int mergeSort(int arr[],int si,int ei)\\n    {\\n        if(si>=ei)\\n        {\\n            return 0;\\n        }\\n        int mid=si+(ei-si)/2;\\n        int c=mergeSort(arr,si,mid);\\n        c+=mergeSort(arr,mid+1,ei);\\n        c+=count(arr,si,mid,ei);\\n        return c;\\n    }\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums,0,nums.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122513,
                "title": "python-2-lines-sortedlist",
                "content": "Don\\'t try this at home.\\n\\nSimilar to the other BST solutions for this problem, you scan through the numbers in reverse order and repeatedly add them to a BST, which will be used to tell the next numbers how many valid pairs are available to them.\\n\\nGetting it down to 2 lines is due to me taking advantage of SortedList and playing with side effects in list comprehensions, which you should almost never do.\\n\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        bst = SortedList()\\n        return sum([bst.add(n*2) or pairs for n in nums[::-1] for pairs in [bst.bisect_left(n)]])\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        bst = SortedList()\\n        return sum([bst.add(n*2) or pairs for n in nums[::-1] for pairs in [bst.bisect_left(n)]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112760,
                "title": "python-solution-using-sorted-list-beats-85",
                "content": "\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        arr = SortedList()\\n        count = 0\\n        for i in range(len(nums)-1, -1, -1):\\n            count += arr.bisect_left(nums[i])\\n            arr.add(2*nums[i])\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        arr = SortedList()\\n        count = 0\\n        for i in range(len(nums)-1, -1, -1):\\n            count += arr.bisect_left(nums[i])\\n            arr.add(2*nums[i])\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795121,
                "title": "c-reverse-pairs-merge-sort-method-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- used merge sort method\\n- during merge steps just check for valid pairs in O(n) complexity\\n\\n# Complexity\\n- Time complexity: O(nlogn + n+ n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n long long merge(vector<int>& arr,vector<int>& tmp,int l,int mid,int r){\\n        int i=l;\\n        int j=mid+1;\\n        long long inv=0;\\n        // loop to count valid pairs before merging sorted array\\n        for(i=l;i<=mid;i++){\\n            while(j<=r && arr[i]>(2*(long)arr[j]))\\n            j++;\\n            inv+=(j-mid-1);\\n        }\\n        j=mid+1;\\n        i=l;\\n        int k=l;\\n        // merging sorted array\\n        while(i<=mid && j<=r){\\n            if(arr[i] > arr[j]){\\n                tmp[k++]=arr[j++];\\n            }\\n            else{\\n                tmp[k++]=arr[i++];\\n            }\\n        }\\n        while(i<=mid){\\n            tmp[k++]=arr[i++];\\n        }\\n        while(j<=r){\\n            tmp[k++]=arr[j++];\\n        }\\n        for(i = l ; i <= r ; i++)\\n            arr[i] = tmp[i];\\n        return inv;\\n    }\\n    \\n    \\n    long long merge_sort(vector<int>& arr,vector<int>& tmp,int l,int r){\\n        long long inv=0;\\n        if(l<r){\\n            int m=(r+l)/2;\\n            inv+=merge_sort(arr,tmp,l,m);\\n            inv+=merge_sort(arr,tmp,m+1,r);\\n            inv+=merge(arr,tmp,l,m,r);\\n        }\\n        return inv;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        vector<int> tmp(nums.size());\\n        return merge_sort(nums,tmp,0,nums.size()-1);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n long long merge(vector<int>& arr,vector<int>& tmp,int l,int mid,int r){\\n        int i=l;\\n        int j=mid+1;\\n        long long inv=0;\\n        // loop to count valid pairs before merging sorted array\\n        for(i=l;i<=mid;i++){\\n            while(j<=r && arr[i]>(2*(long)arr[j]))\\n            j++;\\n            inv+=(j-mid-1);\\n        }\\n        j=mid+1;\\n        i=l;\\n        int k=l;\\n        // merging sorted array\\n        while(i<=mid && j<=r){\\n            if(arr[i] > arr[j]){\\n                tmp[k++]=arr[j++];\\n            }\\n            else{\\n                tmp[k++]=arr[i++];\\n            }\\n        }\\n        while(i<=mid){\\n            tmp[k++]=arr[i++];\\n        }\\n        while(j<=r){\\n            tmp[k++]=arr[j++];\\n        }\\n        for(i = l ; i <= r ; i++)\\n            arr[i] = tmp[i];\\n        return inv;\\n    }\\n    \\n    \\n    long long merge_sort(vector<int>& arr,vector<int>& tmp,int l,int r){\\n        long long inv=0;\\n        if(l<r){\\n            int m=(r+l)/2;\\n            inv+=merge_sort(arr,tmp,l,m);\\n            inv+=merge_sort(arr,tmp,m+1,r);\\n            inv+=merge(arr,tmp,l,m,r);\\n        }\\n        return inv;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        vector<int> tmp(nums.size());\\n        return merge_sort(nums,tmp,0,nums.size()-1);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752300,
                "title": "variant-of-popular-question-inverse-pair-merge-sort-nlogn-tc-n-space",
                "content": "**If you are familar with merge sort you will understand the full code\\nit is simalr to one popular interview question \"Inverse pairs\"**\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int merge(vector<int>&v,int l,int m,int h){\\n    int n1=m-l+1,n2=h-m;\\n    int left[n1],right[n2];\\n    for(int i=0;i<n1;i++){left[i]=v[l+i];}\\n    for(int i=0;i<n2;i++){right[i]=v[m+1+i];}\\n    int j=m+1;\\n    int res=0;\\n    for(int i=l;i<=m;i++){\\n        while(j<=h&&v[i]>2ll*v[j]){\\n            j++;\\n        }\\n        res+=j-(m+1);\\n    }\\n    j=0;\\n    int k=l,i=0;\\n    while(i<n1&&j<n2){\\n        if(left[i]<=right[j]){v[k]=left[i];i++;}\\n        else{v[k]=right[j];j++;}\\n        k++;\\n    }\\n    while(i<n1){v[k]=left[i];i++;k++;}\\n    while(j<n2){v[k]=right[j];j++;k++;}\\n    return res;                                                                                          \\n}\\nint count(vector<int>&v,int l,int h){\\n    int res=0;\\n    if(l<h){\\n        int m=l+(h-l)/2;\\n        res+=count(v,l,m);\\n        res+=count(v,m+1,h);\\n        res+=merge(v,l,m,h);\\n    }\\n    return res;\\n}\\nint reversePairs(vector<int>& nums) {\\n    int l=0,h=nums.size()-1;\\n    int ans=count(nums,l,h);\\n    return ans;\\n}\\n};\\n```\\nhappy coding :)",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int merge(vector<int>&v,int l,int m,int h){\\n    int n1=m-l+1,n2=h-m;\\n    int left[n1],right[n2];\\n    for(int i=0;i<n1;i++){left[i]=v[l+i];}\\n    for(int i=0;i<n2;i++){right[i]=v[m+1+i];}\\n    int j=m+1;\\n    int res=0;\\n    for(int i=l;i<=m;i++){\\n        while(j<=h&&v[i]>2ll*v[j]){\\n            j++;\\n        }\\n        res+=j-(m+1);\\n    }\\n    j=0;\\n    int k=l,i=0;\\n    while(i<n1&&j<n2){\\n        if(left[i]<=right[j]){v[k]=left[i];i++;}\\n        else{v[k]=right[j];j++;}\\n        k++;\\n    }\\n    while(i<n1){v[k]=left[i];i++;k++;}\\n    while(j<n2){v[k]=right[j];j++;k++;}\\n    return res;                                                                                          \\n}\\nint count(vector<int>&v,int l,int h){\\n    int res=0;\\n    if(l<h){\\n        int m=l+(h-l)/2;\\n        res+=count(v,l,m);\\n        res+=count(v,m+1,h);\\n        res+=merge(v,l,m,h);\\n    }\\n    return res;\\n}\\nint reversePairs(vector<int>& nums) {\\n    int l=0,h=nums.size()-1;\\n    int ans=count(nums,l,h);\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717300,
                "title": "python-merge-sort",
                "content": "\\n```python\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        if not nums or len(nums) == 0:\\n                return \\n        tmp = [0 for _ in range(len(nums))]\\n        \\n        return self.merge_sort(nums, tmp, 0, len(nums) - 1)\\n            \\n    \\n    def merge_sort(self, nums, tmp, start, end):\\n        if start >= end:\\n            return 0\\n\\n        mid = start + (end - start) // 2\\n        sum = 0\\n        \\n        sum = self.merge_sort(nums, tmp, start, mid) + \\\\\\n              self.merge_sort(nums, tmp, mid + 1, end) + \\\\\\n              self.find_reverse(nums, start, end) \\n            \\n        self.merge(nums, tmp, start, end, mid)\\n        \\n        return sum\\n\\n\\n    def merge(self, nums, tmp, start, end, mid):\\n        l, r = start, mid + 1\\n        idx = start\\n        while l <= mid and r <= end:\\n            if nums[l] <= nums[r]:\\n                tmp[idx] = nums[l]\\n                l += 1\\n            else:\\n                # nums[l] > nums[r]\\n                tmp[idx] = nums[r]\\n                r += 1\\n            idx += 1\\n\\n        while l <= mid:\\n            tmp[idx] = nums[l]\\n            l += 1\\n            idx += 1\\n\\n        while r <= end:\\n            tmp[idx] = nums[r]\\n            r += 1\\n            idx += 1\\n\\n        for i in range(start, end + 1):\\n            nums[i] = tmp[i]  \\n            \\n    def find_reverse(self, nums, start, end):\\n        res, mid = 0, (start + end) // 2\\n        \\n        j = mid + 1\\n        for i in range(start, j):\\n            while j <= end and nums[i] > 2 * nums[j]:\\n                res += mid - i + 1\\n                j += 1\\n        return res\\n  ```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        if not nums or len(nums) == 0:\\n                return \\n        tmp = [0 for _ in range(len(nums))]\\n        \\n        return self.merge_sort(nums, tmp, 0, len(nums) - 1)\\n            \\n    \\n    def merge_sort(self, nums, tmp, start, end):\\n        if start >= end:\\n            return 0\\n\\n        mid = start + (end - start) // 2\\n        sum = 0\\n        \\n        sum = self.merge_sort(nums, tmp, start, mid) + \\\\\\n              self.merge_sort(nums, tmp, mid + 1, end) + \\\\\\n              self.find_reverse(nums, start, end) \\n            \\n        self.merge(nums, tmp, start, end, mid)\\n        \\n        return sum\\n\\n\\n    def merge(self, nums, tmp, start, end, mid):\\n        l, r = start, mid + 1\\n        idx = start\\n        while l <= mid and r <= end:\\n            if nums[l] <= nums[r]:\\n                tmp[idx] = nums[l]\\n                l += 1\\n            else:\\n                # nums[l] > nums[r]\\n                tmp[idx] = nums[r]\\n                r += 1\\n            idx += 1\\n\\n        while l <= mid:\\n            tmp[idx] = nums[l]\\n            l += 1\\n            idx += 1\\n\\n        while r <= end:\\n            tmp[idx] = nums[r]\\n            r += 1\\n            idx += 1\\n\\n        for i in range(start, end + 1):\\n            nums[i] = tmp[i]  \\n            \\n    def find_reverse(self, nums, start, end):\\n        res, mid = 0, (start + end) // 2\\n        \\n        j = mid + 1\\n        for i in range(start, j):\\n            while j <= end and nums[i] > 2 * nums[j]:\\n                res += mid - i + 1\\n                j += 1\\n        return res\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2703936,
                "title": "fastest-0ms-runtime-100-faster-than-other-submissions-merge-sort",
                "content": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        \\n        int ans =  mergesort(nums,0,nums.length-1);\\n        return ans ;\\n    }\\n    public static int mergesort(int[] arr, int l , int r  ){\\n        \\n        if(l>=r){\\n            return 0;\\n        }\\n            int mid = (l+r)/2;\\n            int count = mergesort(arr,l,mid);\\n            count += mergesort(arr,mid+1,r);\\n            count += merge(arr,l,mid,r);\\n        \\n        return count;\\n    }\\n    public static int merge(int[] arr, int l , int mid, int r ){\\n        int count = 0;\\n        int j = mid+1;\\n        \\n        for(int i=l;i<=mid;i++){\\n            while(j<=r && arr[i] > (2 *(long) arr[j] ) ){\\n                j++;\\n            }\\n            count += (j- (mid+1)) ;\\n        }\\n       ArrayList<Integer> temp = new ArrayList<>(); \\n        int i =l, idx = l;\\n        j = mid+1;\\n        while(i<= mid && j<=r ){\\n            if(arr[i]<=arr[j] ){\\n                temp.add(arr[i++] );\\n            }else{\\n                temp.add(arr[j++] );\\n\\n            }\\n        }\\n        while(i<=mid){\\n            temp.add(arr[i++] );\\n        }\\n        while(j<= r){\\n            temp.add(arr[j++] );\\n        }\\n        for( i=l;i<=r;i++){\\n            arr[i] = temp.get(i-l);\\n        }\\n        return count;\\n    }\\n    \\n}\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        \\n        int ans =  mergesort(nums,0,nums.length-1);\\n        return ans ;\\n    }\\n    public static int mergesort(int[] arr, int l , int r  ){\\n        \\n        if(l>=r){\\n            return 0;\\n        }\\n            int mid = (l+r)/2;\\n            int count = mergesort(arr,l,mid);\\n            count += mergesort(arr,mid+1,r);\\n            count += merge(arr,l,mid,r);\\n        \\n        return count;\\n    }\\n    public static int merge(int[] arr, int l , int mid, int r ){\\n        int count = 0;\\n        int j = mid+1;\\n        \\n        for(int i=l;i<=mid;i++){\\n            while(j<=r && arr[i] > (2 *(long) arr[j] ) ){\\n                j++;\\n            }\\n            count += (j- (mid+1)) ;\\n        }\\n       ArrayList<Integer> temp = new ArrayList<>(); \\n        int i =l, idx = l;\\n        j = mid+1;\\n        while(i<= mid && j<=r ){\\n            if(arr[i]<=arr[j] ){\\n                temp.add(arr[i++] );\\n            }else{\\n                temp.add(arr[j++] );\\n\\n            }\\n        }\\n        while(i<=mid){\\n            temp.add(arr[i++] );\\n        }\\n        while(j<= r){\\n            temp.add(arr[j++] );\\n        }\\n        for( i=l;i<=r;i++){\\n            arr[i] = temp.get(i-l);\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1779560,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1783760,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2007703,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1733884,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1576841,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1575838,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1911664,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2076867,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2057136,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2050828,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1779560,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1783760,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2007703,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1733884,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1576841,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1575838,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 1911664,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2076867,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2057136,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2050828,
                "content": [
                    {
                        "username": "reemantech",
                        "content": "3 hrs.. worth a try. Now, I can feel mergeSort running through my veins.\\n\\nTip: While counting the pairs in right half, don\\'t forget to check for   `nums[left] > 2*(long)nums[right]` for testCase having nums[i]=intMax\\n \\n `[2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]`\\n"
                    },
                    {
                        "username": "Raj126",
                        "content": "+1 here"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "same"
                    },
                    {
                        "username": "Vedant_Naik",
                        "content": "int count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[j]*2 < nums[i]){\\n                    count++;\\n                }\\n            }\\n        }\\nwhy does this code not work for the testcase [2147483647,2147483647,2147483647,2147483647,2147483647,2147483647]???"
                    },
                    {
                        "username": "zoro992370",
                        "content": "[@Vithesh](/Vithesh) Thanks for the solution"
                    },
                    {
                        "username": "priyanshu_sharma_1720",
                        "content": "long a = nums[i];\\nlong b = nums[j] ;\\nif(a > 2*b) {\\ncount++;\\n}\\nthen this test case passed but for big size array this code will give TLE bcz it is o(n^2) \\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "when you are using long you must declare every integer as \"l\" that means when you use any digit like 0 or 2 you must write it as 0l or 2l. Because its long.\nso change \nnums[j]*2 < nums[i] \nto \nnums[j]*2l < nums[i]"
                    },
                    {
                        "username": "01raj_kumar",
                        "content": "try using \" (long long)nums[j]*2 \"\\nbut still this solution will give TLE "
                    },
                    {
                        "username": "MihirHS",
                        "content": "2*2147483647 goes beyond the range of int. Try converting it to \\'long\\'."
                    },
                    {
                        "username": "ayush6203",
                        "content": "oh god! i hope these kind of questions will not appear in interviews :("
                    },
                    {
                        "username": "adit1102",
                        "content": "My friend was asked this question in Accolite\\'s technical round."
                    },
                    {
                        "username": "nnvakhil",
                        "content": "Why using multiset and lowerbound is leading to TLE although it is also O(nlogn) .I can\\'t understand .Can someone explain?"
                    },
                    {
                        "username": "anshulkashyap1409",
                        "content": "Can anyone please explain me why on this input [2147483647,2147483647,-2147483647,-2147483647,-2147483647,2147483647]   the output is 9, from my understanding output must be 6?\\n\\n\\n"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": "Because if you multipy negative value by 2 it will become more smaller,for example \n-->  -2 > 2*(-2)  i.e   -2 > -4.\nso\n-->  -2147483647 > 2*(-2147483647) \n.That's why answer is 9 not 6."
                    },
                    {
                        "username": "aakash0091",
                        "content": "please take -5 -5 -5 calculate for this you get to know where you are wrong for this answer is 3"
                    },
                    {
                        "username": "AyuAnchor",
                        "content": "Adding 1 to this input leads to overflow and thus wrong answer."
                    },
                    {
                        "username": "gultainn",
                        "content": "Bcz of negative numbers present in array. in this case arr[2]>2*arr[3] and >2*arr[4], also arr[3]>2*arr[4].so count is 9."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Take any 6-tuplet  b = (a, a, -a, -a, -a, a), where a is any integer >= 1.  Then clearly a  x 2 > -a.  So (b[0], b[2]), (b[0], b[3]), (b[0], b[4]), and (b[1], b[2]), (b[1], b[3]), (b[1], b[4]) all qualify as reverse pairs..  These are the six reverse pairs you probably counted.\\n\\nBut -a >= -a x 2 as well.  So (b[2], b[3]), (b[2], b[4]), and (b[3], b[4]) also qualify.  That brings the total to 9."
                    },
                    {
                        "username": "bharatbanavalikar",
                        "content": "its because when you multiply this number with 2, it will not fit into integer. Use long or double with your solution. That should work"
                    },
                    {
                        "username": "user0881r",
                        "content": "I would expect the code to return 0 for input [-5,-5]. However the test fails and says it expects 1. Any idea why? This seems like a bug to me."
                    },
                    {
                        "username": "AvanishCodes",
                        "content": "cause \n`a[0] > 2*a[1]`\n`-5 > -10`"
                    },
                    {
                        "username": "kishore86",
                        "content": " void merge(vector<int> nums,int low,int mid,int high,int &c){\\n        int i = low;\\n        int j = mid+1;\\n        vector<int> temp;\\n        while(i<=mid && j<=high){\\n            if(nums[i]<=nums[j]){\\n                temp.push_back(nums[i]);\\n                i++;\\n            }\\n            else{\\n                temp.push_back(nums[j]);\\n                if(nums[i]>2*nums[j]) c+=mid-i+1;\\n                j++;\\n            }\\n        }\\n        while(i<=mid){\\n            temp.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j<=high){\\n            temp.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = low;i<=high;i++){\\n            nums[i] = temp[i-low];\\n        }\\n    }\\n    void mergeSort(vector<int> &nums,int low,int high,int &c){\\n        if(low>=high) return;\\n        int mid = (low+high)/2;\\n        mergeSort(nums,low,mid,c);\\n        mergeSort(nums,mid+1,high,c);\\n        return merge(nums,low,mid,high,c);\\n    }\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        mergeSort(nums,0,n-1,count);\\n        return count;\\n    }\\n\\nCan somebody explain why it is not working?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you shouldn\\'t post solutions here"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "How to think it\\'ll be solved with divide and conquer? Seriously if I\\'m being asked I\\'ll not consider it at all. How how how???"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "This question really helped me to understand merge sort well ,wonderful question to solve today"
                    },
                    {
                        "username": "z_acc",
                        "content": " N^2 TLE "
                    }
                ]
            },
            {
                "id": 2017056,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 2011076,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 1946368,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 1937221,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 1903910,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 1881207,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 1876834,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 1804023,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 1760497,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            },
            {
                "id": 1749288,
                "content": [
                    {
                        "username": "sabhar",
                        "content": "WHY IS IT SHOWING STACK OVERFLOW????\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergesort(nums,0,nums.length -1);\\n    }\\n    public static int mergesort(int[] nums, int left,int right){\\n        int mid=left+(right-left) /2;\\n        int j=mid+1;\\n        int count=mergesort(nums,left,mid)+mergesort(nums,mid+1,right);\\n        for(int i=left;i<=mid;i++){\\n            while(j<=right&&nums[i]>2L*nums[j]){\\n                count+= j-(mid+1);\\n                j++;\\n            }\\n        }\\n        merge(nums,left,mid,right);\\n        return count;\\n    }\\n    public static void merge(int[] nums , int left, int mid, int right){\\n        int[] temp =new int[right-left+1];\\n        int i=left,j=mid+1,k=0;\\n        while(i<=mid&&j<=right){\\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }else{\\n                temp[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid){\\n            temp[k++]=nums[i++];\\n        }\\n        while(j<=right){\\n            temp[k++]=nums[j++];\\n        }\\n        System.arraycopy(temp,0,nums,left,temp.length);\\n    }\\n}\\n"
                    },
                    {
                        "username": "heyb5721",
                        "content": "Can someone please explain why is this code not working for all testcases, it passed only 107/140 test cases? \\n\\nfrom bisect import bisect_right, bisect_left\\n\\ndef mergesort(left,right,ctr):\\n    ans = []\\n    i = 0\\n    j = 0\\n    while i<len(left) and j<len(right):  \\n        if left[i]<right[j]:\\n            ans.append(left[i])\\n            i+=1    \\n        elif left[i]>right[j]:\\n            x = 2*right[j]    \\n            ind = bisect_right(left,x)\\n            if ind<len(left):\\n                ctr[0]+= (len(left)-ind) \\n            ans.append(right[j])\\n            j+=1        \\n        else:         \\n            ans.append(left[i])\\n            i+=1\\n    while i<len(left):\\n        ans.append(left[i])\\n        i+=1        \\n    while j<len(right):\\n        ans.append(right[j])\\n        j+=1\\n    return ans        \\n\\ndef merge(arr,n,ctr):\\n    if n==1:\\n        return arr\\n    mid = n//2 \\n    left = arr[:mid]\\n    right = arr[mid:]\\n    left = merge(left,len(left),ctr)\\n    right = merge(right,len(right),ctr)\\n    sarr = mergesort(left,right,ctr)   \\n    return sarr\\n\\nclass Solution:\\n    def reversePairs(self, nums: List[int]) -> int:\\n        ctr = [0]\\n        merge(nums,len(nums),ctr)\\n        return ctr[0]"
                    },
                    {
                        "username": "utkarshdwivedi130903",
                        "content": "Can anyone please explain if i add a[i]>(long)2*b[j] in merge function for checking only why it is not working:\\n`void merge(vector<int> &v,int l,int mid,int r){\\n      int n=mid-l+1;\\n      int m=r-mid;\\n      vector<int> a(n);\\n      vector<int> b(m);\\n      for(int i=0;i<n;i++){\\n          a[i]=v[l+i];\\n      }\\n      for(int i=0;i<m;i++){\\n          b[i]=v[mid+i+1];\\n      }\\n    //   int ans=0;\\n      int i=0,j=0,k=l;\\n      int x=0;\\n      while(i<n && j<m){\\n        \\n          if(a[i]>b[j]){\\n              v[l]=b[j];\\n              j++;\\n              l++;\\n             long c=2*b[j];\\n             long d=a[i];\\n             if(d>c){\\n                 ans+=n-i;\\n             }\\n             \\n          }else{\\n              v[l]=a[i];\\n              i++;\\n              l++;\\n          }\\n      }\\n      while(i<n){\\n      v[l]=a[i];\\n          l++;\\n          i++;\\n      }\\n      while(j<m){\\n          v[l]=b[j];\\n          l++;\\n          j++;\\n      }\\n     \\n  }\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "Ohh, merge sort!!"
                    },
                    {
                        "username": "Prabhat_7",
                        "content": "`\nimport java.util.* ;\nimport java.io.*; \nimport java.util.ArrayList;\n\npublic class Solution \n{\n    static int num=0;\n    public static int reversePairs(ArrayList<Integer> arr) \n    {\n        \n        // num=0;\n        int[] A=new int[arr.size()];\n        for(int i=0;i<arr.size();i++)\n            A[i]=arr.get(i);\n\n        merge(A,0,A.length-1);\n        // for(int i=0;i<arr.size();i++)\n        //     System.out.println(A[i]+\", \");\n        return num;\n\n    }\n\n    public static void merge(int[] arr, int start, int end){\n        if(start>=end)return;\n        int mid=start+(end-start)/2;\n        int s=start;\n        int m=mid+1;\n        int k=mid+1;\n        int a=0;\n        int[] arr2=new int[end-start+1];\n\n        merge(arr, s, mid);\n        merge(arr,mid+1,end);\n        int last=0;\n        \n        while(s<=mid&&m<=end){\n            last=arr[m];\n            if(arr[s]>arr[m]){\n                if(arr[s]>2*arr[m])num++;\n                arr2[a++]=arr[m++];\n            }\n            else arr2[a++]=arr[s++];\n           \n        }\n        while(s<=mid){\n            //if(arr[s]>2*last)num+=\n            arr2[a++]=arr[s++];\n        }\n        while(m<=end)arr2[a++]=arr[m++];\n        //System.out.println(\" \");\n\n         \n\n        for(int i=0,j=start;i<a;i++,j++){\n            arr[j]=arr2[i];\n            //System.out.print(arr[j]+\" \");\n        }\n\n        while(k<=end){\n            int target=2*arr[k]+1;\n            //System.out.print(\"tar: \"+target+\"... \");\n            int l =bst(arr,start,mid,target);\n            if(l!=-1) {num+=mid-l+1;\n            \n            System.out.print(\"pos: \"+l+\"/ \");\n            }\n            k++;\n        }\n       \n\n\n\n    }\n\n    public static int bst(int[] arr, int start, int end, int target){\n    \n\n        if(start>end)return -1;\n        int mid=start+(end-start)/2;\n        if(arr[mid]==target){\n            if(mid==start)return mid;\n            if(arr[mid-1]==target)return bst(arr,start,mid-1,target);\n            else return mid;\n        }\n        else if(arr[mid]>target){\n            if(mid==start)return mid;\n            if(arr[mid-1]>=target)return bst(arr,start,mid-1,target);\n            if(arr[mid-1]<target)return mid;\n        }\n        else{\n            if(mid==end)return -1;\n            if(arr[mid+1]>=target)return mid+1;\n            if(arr[mid+1]<target)return bst(arr,mid+1,end,target);\n            \n        }\n        return -1;\n\n    }\n}\n`\n\ncan anyone please tell me where i am wrong??"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "The length of the array is <= 5*10^4 so a O(n^2) algorithm should be able to compute the result in 1sec (which I am assuming is the time limit as it\\'s common across other sites).\\nI submitted a brute force algo with this complexity but case #32 is giving TLE. How?"
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "Can someone tell what is wrong with my solution? \n122 / 140 testcases passed\n\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n    }\n\n    int mergeSort(int[] nums, int l, int r, int[] temp) {\n        int res = 0;\n        if(l < r) {\n            int mid = (l + r)/2;\n            res = mergeSort(nums, l, mid, temp) + mergeSort(nums, mid+1, r, temp);\n            res += merge(nums, temp, l, mid, r);\n        }\n        return res;\n    }\n\n    int merge(int[] nums, int[] temp, int l, int mid, int r) {\n        int i = l, j = mid + 1, k = l;\n        int res = 0;\n        while(i <= mid && j <= r) {\n            if(nums[i] >= nums[j]) {\n                long target = 2l * nums[j];\n                int p = upper_bound(nums, l, mid+1, target);\n                res += mid - p + 1;\n                temp[k++] = nums[j++];\n            } else {\n                temp[k++] = nums[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = nums[i++];\n        }\n        while(j <= r) {\n            temp[k++] = nums[j++];\n        }\n        for(i = l; i <= r; i++) {\n            nums[i] = temp[i];\n        }\n        return res;\n    }\n\n    int upper_bound(int[] arr, int left, int right, long target) {\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\nIt's failing for this test case (it's too large to add to comments, adding part of it):\n[-185,143,-154,-338,-269,287,214,313,165,-364,-22,-5,9,-212,46,328,-432,-47,317,206,-112,-9,-224,-207,6,198,290,27,408,155,111,-230,-2,-266,84,-224,-317,39,-482,159,35,132,-151,70,-179,104,-156,450,-13,216,190,238,-138,354,171,-398,-36,417,26,-27,-142,478,-362,-91,-262,-11,469,248,-286,-269,-69,-221,-70,26,484,-31,-236,-173,-380,-8,312,-138,-96,23,-7,39,-345,269,156,349,200,52,193,152,168,159,181,272,-259,210,76,194,-31,139,392,-16,-151,50,166,45,9,44,-179,151,-8,75,-277,-18,49,314,-332,449,24,362,88,159,14,-279,232,211,-206,-192,27,238,-339,-79,30,-370,-29,81,251,-189,21,-202,-41,198,51,-6,172,108,26,-168,316,271,-76,-20,-249,-111,47,-86,303,35,127,113,-181,289,-105,-30,-16,-9,95,-144,-422,198,320,7,-227,-161,447,486,-406,-121,-280,-76,285,-453,42,15,-335,-189,-154,280,-206,68,-313,-375,-401,47,184,-320,369,-146,-60,150,378,87,102,138,-54,169,33,-339,-19,147,333,84,92,-57,104,76,-239,99,300,217,-140,153,-344,-103,-6,-37,399,323,-138,279,-259,217,172,-94,-55,29,462,-327,-177,-163,-444,...\n"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "same for me also\\nclass Solution {\\n    public int reversePairs(int[] nums) {\\n           int global=mergeSort(nums,0,nums.length-1);\\nreturn global;\\n\\n    }\\n    int  mergeSort(int arr[], int l, int r)\\n    {\\n        int count=0;\\n        if(l<r){\\n            int m=(l+r)/2;\\n           count +=  mergeSort(arr,l,m);\\n           count +=  mergeSort(arr,m+1,r);\\n         count += merge(arr,l,m,r);\\n        }\\n        return count;\\n    }\\n           int  merge(int arr[], int l,int m, int r)\\n    {\\n        int count=0;\\n        int temp[]=new int[r-l+1];\\n        int i=l;\\n        int j=m+1;\\n        int f=0;\\n        while(i<=m&&j<=r){\\n            if(arr[i]<arr[j]){\\n                temp[f++]=arr[i++];\\n            }\\n            else{\\n            long target=2L*arr[j];\\n           \\n            int ind=binsearch(arr,i,m,target);\\n            count=count+(m-ind+1);\\n                temp[f++]=arr[j++];\\n            \\n            }\\n        }\\n        for(;i<=m;i++){\\n            temp[f++]=arr[i];\\n        }\\n        for(;j<=r;j++){\\n            temp[f++]=arr[j];\\n        }\\n         for ( int k = 0; k<temp.length; k++) {\\n                     arr[l+k] = temp[k];\\n         }\\n         return count;\\n    }\\n    public int  binsearch(int nums[],int s,int e,long  target){\\n        int ans=e+1;\\n        while(s<=e){\\n          int mid=(s+e)/2;\\n      \\n          if(nums[mid]<=target){\\n             s=mid+1;\\n          }\\n          else{\\n            ans=mid;\\n            e=mid-1;\\n          }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contain ALL LEETCODE SOLUTIONS IN C++,\\nIf you find it useful PLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/493.%20Reverse%20Pairs.CPP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "try using merge sort good hint"
                    },
                    {
                        "username": "shivanigam",
                        "content": "why this isn\\'t working?\\n\\n\\n\\n\\nint c=0;\\n\\n    int i=0,j=nums.length-1;\\n    while(j>i){\\n    while(i<j){\\n        if(nums[i]>nums[j]*2)\\n            c++;\\n        i++;\\n    }\\n    i=0;\\n    j--;\\n    }\\n       return c;"
                    }
                ]
            }
        ]
    }
]