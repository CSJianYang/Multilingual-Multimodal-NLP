[
    {
        "title": "Unique Morse Code Words",
        "question_content": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\n\n\t'a' maps to \".-\",\n\t'b' maps to \"-...\",\n\t'c' maps to \"-.-.\", and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\nGiven an array of strings words where each word can be written as a concatenation of the Morse code of each letter.\n\n\tFor example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word.\n\nReturn the number of different transformations among all words we have.\n&nbsp;\nExample 1:\n\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\nOutput: 2\nExplanation: The transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\nThere are 2 different transformations: \"--...-.\" and \"--...--.\".\n\nExample 2:\n\nInput: words = [\"a\"]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 100\n\t1 <= words[i].length <= 12\n\twords[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 120675,
                "title": "java-c-python-easy-and-concise-solution",
                "content": "\\n**Java**\\n```java\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        HashSet<String> s = new HashSet<>();\\n        for (String w : words) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < w.length(); ++i)\\n                sb.append(d[w.charAt(i) - \\'a\\']);\\n            s.add(sb.toString());\\n        }\\n        return s.size();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        unordered_set<string> s;\\n        for (auto w : words) {\\n            string code;\\n            for (auto c : w) code += d[c - \\'a\\'];\\n            s.insert(code);\\n        }\\n        return s.size();\\n    }\\n```\\n\\n**Python**\\n```python\\n    def uniqueMorseRepresentations(self, words):\\n        d = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n             \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n        return len({\\'\\'.join(d[ord(i) - ord(\\'a\\')] for i in w) for w in words})",
                "solutionTags": [],
                "code": "```java\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        HashSet<String> s = new HashSet<>();\\n        for (String w : words) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < w.length(); ++i)\\n                sb.append(d[w.charAt(i) - \\'a\\']);\\n            s.add(sb.toString());\\n        }\\n        return s.size();\\n    }\\n```\n```cpp\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        unordered_set<string> s;\\n        for (auto w : words) {\\n            string code;\\n            for (auto c : w) code += d[c - \\'a\\'];\\n            s.insert(code);\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329303,
                "title": "javascript-one-line-solution-w-explanation-52-ms-beats-94",
                "content": "**Approach**:\\nWe need to return the number of morse representations for the given list of words. The approach for this problem is as follows:\\n1. Look at each word in `words`.\\n2. For each word, look at each letter.\\n3. Get the morse representation of each letter\\n4. Build the word with the morse letter\\n5. Once we finished building the word, add it to our set if it isn\\'t already in there\\n6. Return the number of *unique* morse representations.\\n\\n**Solution**: \\n```js\\nconst alphabet = {\\n    a: \\'.-\\', b: \\'-...\\',   c: \\'-.-.\\', d: \\'-..\\', e: \\'.\\', f: \\'..-.\\', g: \\'--.\\', h: \\'....\\', i: \\'..\\',  j: \\'.---\\',  k: \\'-.-\\',  l: \\'.-..\\', m: \\'--\\',\\n    n: \\'-.\\',  o: \\'---\\', p: \\'.--.\\',  q: \\'--.-\\',  r: \\'.-.\\', s: \\'...\\', t: \\'-\\', u: \\'..-\\', v: \\'...-\\', w: \\'.--\\', x: \\'-..-\\',  y: \\'-.--\\', z: \\'--..\\' \\n}\\n\\n/**\\n * @param {string[]} words the word array to convert to morse\\n * @return {number} the length of unique morse representations\\n */\\nconst uniqueMorseRepresentations = words => {  \\n\\t// PREVIOUS SOLUTION:\\n\\t// return [...new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\')))].length\\n   \\n    // Edited on 9-9-2019\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\'))).size\\n}\\n```\\n**Explanation**: \\nThis is a fun problem to apply [Array.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)! Since we\\'re changing every element in the array, `map()` works nicely.  We\\'ll use the example `words = [\\'gin\\', \\'zen\\', \\'gig\\', \\'msg\\']` to explain how this works:\\n\\n1. For each word, we\\'ll split the characters of each word with our first use of `map()`. We\\'ll have something like this after looking at one word:\\n\\n\\t```js  \\n\\t[ [\\'g\\', \\'i\\', \\'n\\'], \\'zen\\', \\'gig\\', \\'msg\\' ] \\n\\t ```\\n\\t\\n2. We\\'ll use `map()`  again inside our first map method. We\\'ll do this to look at each letter of the inner array to create a Morse Code word. \\n\\n3.  For each letter during our second use of `map()`, we\\'ll get the letter\\'s Morse Code, and build a word with it using `join(\\'\\')`. After one use of both `map()` methods, we\\'ll get the first Morse word for `\\'gin\\'`: \\n\\t```js  \\n\\t[\\'--...-.\\', \\'zen\\', \\'gig\\', \\'msg\\'] \\n\\t ```\\n\\n4. We\\'ll repeat steps 1-3 until we have an array of new Morse Code words:\\n\\n\\t```js\\n\\t[\\'--...-.\\', \\'--...-.\\', \\'--...--.\\', \\'--...--.\\']\\n\\t```\\n\\n\\n5. We\\'ll use JavaScript\\'s [Set Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) to only keep the unique representations. The Set constructor takes in an array, which will be the array shown in Step 2, and then removes duplicate elements, so we\\'ll only be left with unique Morse Code words:\\n\\n\\t```js\\n\\t[\\'--...-.\\', \\'--...--.\\']\\n\\t```\\n\\n(EDITED on September 9th, 2019)\\nFinally, we can return the size of the set\\n```js\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\'))).size\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst alphabet = {\\n    a: \\'.-\\', b: \\'-...\\',   c: \\'-.-.\\', d: \\'-..\\', e: \\'.\\', f: \\'..-.\\', g: \\'--.\\', h: \\'....\\', i: \\'..\\',  j: \\'.---\\',  k: \\'-.-\\',  l: \\'.-..\\', m: \\'--\\',\\n    n: \\'-.\\',  o: \\'---\\', p: \\'.--.\\',  q: \\'--.-\\',  r: \\'.-.\\', s: \\'...\\', t: \\'-\\', u: \\'..-\\', v: \\'...-\\', w: \\'.--\\', x: \\'-..-\\',  y: \\'-.--\\', z: \\'--..\\' \\n}\\n\\n/**\\n * @param {string[]} words the word array to convert to morse\\n * @return {number} the length of unique morse representations\\n */\\nconst uniqueMorseRepresentations = words => {  \\n\\t// PREVIOUS SOLUTION:\\n\\t// return [...new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\')))].length\\n   \\n    // Edited on 9-9-2019\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\'))).size\\n}\\n```\n```js  \\n\\t[ [\\'g\\', \\'i\\', \\'n\\'], \\'zen\\', \\'gig\\', \\'msg\\' ] \\n\\t ```\n```js  \\n\\t[\\'--...-.\\', \\'zen\\', \\'gig\\', \\'msg\\'] \\n\\t ```\n```js\\n\\t[\\'--...-.\\', \\'--...-.\\', \\'--...--.\\', \\'--...--.\\']\\n\\t```\n```js\\n\\t[\\'--...-.\\', \\'--...--.\\']\\n\\t```\n```js\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => alphabet[letter]).join(\\'\\'))).size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 120672,
                "title": "c-straightforward",
                "content": "    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> gen_codes;\\n        \\n        for(auto word : words) {\\n            string code = \"\";\\n            for(auto ch : word)\\n                code += morse_code[ch - \\'a\\'];\\n            gen_codes.insert(code);\\n        }\\n        \\n        return gen_codes.size();\\n    }",
                "solutionTags": [],
                "code": "    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> gen_codes;\\n        \\n        for(auto word : words) {\\n            string code = \"\";\\n            for(auto ch : word)\\n                code += morse_code[ch - \\'a\\'];\\n            gen_codes.insert(code);\\n        }\\n        \\n        return gen_codes.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 944921,
                "title": "python-just-use-set-explained",
                "content": "Nothing very special about this problem: we just need to iterate through our `words` and for each of them build string. It is actually can be done even in one line (not including `alphabet`) if we use double comperehsions, but this is up to you if you like oneliners.\\n\\n**Complexity**: time and space complexity is `O(n*k)`, where `n` is number of words and `k` average is length of each word and we note that length of each encoding is not more than `4`. Space complexity is `O(n*k)` as well.\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        alphabet = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        ans = []\\n        for word in words:\\n            ans.append(\"\".join(alphabet[ord(s)-ord(\"a\")] for s in word))\\n        return len(set(ans))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        alphabet = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        ans = []\\n        for word in words:\\n            ans.append(\"\".join(alphabet[ord(s)-ord(\"a\")] for s in word))\\n        return len(set(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437990,
                "title": "python-easily-understood-faster-than-99-7-2-lines",
                "content": "In this question, the easiest way is to create a dict like this:\\n```\\n\\tmorse_code_dict = {\\'a\\': \\'.-\\',\\n\\t\\t\\'b\\': \\'-...\\',\\n\\t\\t\\'c\\': \\'-.-.\\',\\n\\t\\tand so on...\\n\\t}\\n```\\nbut this is time consuming.\\nThus, we can use the idea of **ASCII** in which\\n```\\na = 97\\nb = 98\\nand so on...\\n```\\n\\nCode:\\n```\\ndef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\tmorse_code_array = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n\\tresult = set()\\n\\tfor word in words:\\n\\t\\tword = word.lower()\\n\\t\\ttransformations = \"\"\\n\\t\\tfor chr in word:\\n\\t\\t\\ttransformations += morse_code_array[ord(chr) - 97]\\n\\t\\tresult.add(transformations)\\n\\treturn len(result)\\n```\\n\\nAlso, we can reduce the runtime by **set and list comprehension**:\\n```\\ndef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\tmorse_code_array = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\treturn len({\\'\\'.join([morse_code_array[ord(chr) - 97] for chr in word]) for word in words})\\n```\\n\\n**Time Complexity**: `O(n*m)`\\n**Space Complexity**: `O(n*m)`\\n<br/>",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\tmorse_code_dict = {\\'a\\': \\'.-\\',\\n\\t\\t\\'b\\': \\'-...\\',\\n\\t\\t\\'c\\': \\'-.-.\\',\\n\\t\\tand so on...\\n\\t}\\n```\n```\\na = 97\\nb = 98\\nand so on...\\n```\n```\\ndef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\tmorse_code_array = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n\\tresult = set()\\n\\tfor word in words:\\n\\t\\tword = word.lower()\\n\\t\\ttransformations = \"\"\\n\\t\\tfor chr in word:\\n\\t\\t\\ttransformations += morse_code_array[ord(chr) - 97]\\n\\t\\tresult.add(transformations)\\n\\treturn len(result)\\n```\n```\\ndef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\tmorse_code_array = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\treturn len({\\'\\'.join([morse_code_array[ord(chr) - 97] for chr in word]) for word in words})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 120826,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        map_=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        res=set()\\n        \\n        for word in words:\\n            val=\"\"\\n            for s in word:\\n                val+=map_[ord(s)-ord(\\'a\\')]\\n            res.add(val)\\n        \\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        map_=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        res=set()\\n        \\n        for word in words:\\n            val=\"\"\\n            for s in word:\\n                val+=map_[ord(s)-ord(\\'a\\')]\\n            res.add(val)\\n        \\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437353,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=uFNUoytk270\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\n  class Solution {\\n  public:\\n\\n\\n  int uniqueMorseRepresentations(vector<string>& words) \\n  {\\n  \\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                  \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n  \\tunordered_map<string,int> um;\\n\\n  \\tfor (int i=0; i< words.size(); i++) {\\n  \\t\\tstring st;\\n  \\t\\tfor (int j=0; j<words[i].size(); j++) st += a[words[i][j] - \\'a\\'];\\n  \\t\\tum[st]=1;\\n  \\t }\\n\\n  return um.size ();\\n  }\\n  };\\n```\\n\\n**PYTHON**(copied)\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                    \\n            m = \\'\\'\\n            for l in w:                       \\n                m += mos[ord(l) - ord(\\'a\\')] \\n            s.add(m)                      \\n        \\n        return len(s)\\n```\\n**JAVA**(copied)\\n\\n```\\nclass Solution {\\n    private final String[] morseCodes = {\\n        \".-\",\\n        \"-...\",\\n        \"-.-.\",\\n        \"-..\",\\n        \".\",\\n        \"..-.\",\\n        \"--.\",\\n        \"....\",\\n        \"..\",\\n        \".---\",\\n        \"-.-\",\\n        \".-..\",\\n        \"--\",\\n        \"-.\",\\n        \"---\",\\n        \".--.\",\\n        \"--.-\",\\n        \".-.\",\\n        \"...\",\\n        \"-\",\\n        \"..-\",\\n        \"...-\",\\n        \".--\",\\n        \"-..-\",\\n        \"-.--\",\\n        \"--..\"\\n    };\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        final Set<String> codes = new HashSet<>();\\n\\n        for (String word : words) {\\n            final StringBuilder morseCode = new StringBuilder();\\n            for (int i = 0, n = word.length(); i < n; i++) {\\n                morseCode.append(morseCodes[word.charAt(i) - \\'a\\']);\\n            }\\n            codes.add(morseCode.toString());\\n        }\\n\\n        return codes.size();\\n    }\\n}\\n```\\n**Please UPVOTE  to motivate me for solving more questions like this and clubbing all languages solution!!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n  class Solution {\\n  public:\\n\\n\\n  int uniqueMorseRepresentations(vector<string>& words) \\n  {\\n  \\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                  \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n  \\tunordered_map<string,int> um;\\n\\n  \\tfor (int i=0; i< words.size(); i++) {\\n  \\t\\tstring st;\\n  \\t\\tfor (int j=0; j<words[i].size(); j++) st += a[words[i][j] - \\'a\\'];\\n  \\t\\tum[st]=1;\\n  \\t }\\n\\n  return um.size ();\\n  }\\n  };\\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                    \\n            m = \\'\\'\\n            for l in w:                       \\n                m += mos[ord(l) - ord(\\'a\\')] \\n            s.add(m)                      \\n        \\n        return len(s)\\n```\n```\\nclass Solution {\\n    private final String[] morseCodes = {\\n        \".-\",\\n        \"-...\",\\n        \"-.-.\",\\n        \"-..\",\\n        \".\",\\n        \"..-.\",\\n        \"--.\",\\n        \"....\",\\n        \"..\",\\n        \".---\",\\n        \"-.-\",\\n        \".-..\",\\n        \"--\",\\n        \"-.\",\\n        \"---\",\\n        \".--.\",\\n        \"--.-\",\\n        \".-.\",\\n        \"...\",\\n        \"-\",\\n        \"..-\",\\n        \"...-\",\\n        \".--\",\\n        \"-..-\",\\n        \"-.--\",\\n        \"--..\"\\n    };\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        final Set<String> codes = new HashSet<>();\\n\\n        for (String word : words) {\\n            final StringBuilder morseCode = new StringBuilder();\\n            for (int i = 0, n = word.length(); i < n; i++) {\\n                morseCode.append(morseCodes[word.charAt(i) - \\'a\\']);\\n            }\\n            codes.add(morseCode.toString());\\n        }\\n\\n        return codes.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433758,
                "title": "python-simple-faster-than-94",
                "content": "<b>Approach 1: </b>Using ```List```\\n\\nLong:\\n```\\ndef solution(words):\\n    codes = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n             \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n    res = set()\\n    for word in words:\\n        m = []                           # store the Morse representation of each letter in a word\\n        for ch in word:\\n            m.append(codes[ord(ch) - 97])\\n        res.add(\"\".join(m))\\n    return len(res)\\n```\\n\\nShort:\\n```\\ndef solution(words):\\n    codes = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n             \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n\\treturn len(set(\"\".join([codes[ord(ch)-97] for ch in word]) for word in words))\\n```\\n\\n<b>Approach 2: </b>Using ```Dictionary```\\n\\nLong:\\n```\\ndef solution(words):\\n    codes = {\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\",\\n             \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\",\\n             \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"}\\n    res = set()\\n    for word in words:\\n        m = []                          # store the Morse representation of each letter in a word\\n        for ch in word:\\n            m.append(codes.get(ch))\\n        res.add(\"\".join(m))\\n    return len(res)\\n```\\n\\nShort:\\n```\\ndef solution(words):\\n    codes = {\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\",\\n             \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\",\\n             \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"}\\n    return len(set([\"\".join([codes.get(ch) for ch in word]) for word in words]))\\n```\\nIf you like my solution and/or find it useful, please upvote :) Thank you.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```List```\n```\\ndef solution(words):\\n    codes = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n             \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n    res = set()\\n    for word in words:\\n        m = []                           # store the Morse representation of each letter in a word\\n        for ch in word:\\n            m.append(codes[ord(ch) - 97])\\n        res.add(\"\".join(m))\\n    return len(res)\\n```\n```\\ndef solution(words):\\n    codes = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n             \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n\\treturn len(set(\"\".join([codes[ord(ch)-97] for ch in word]) for word in words))\\n```\n```Dictionary```\n```\\ndef solution(words):\\n    codes = {\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\",\\n             \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\",\\n             \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"}\\n    res = set()\\n    for word in words:\\n        m = []                          # store the Morse representation of each letter in a word\\n        for ch in word:\\n            m.append(codes.get(ch))\\n        res.add(\"\".join(m))\\n    return len(res)\\n```\n```\\ndef solution(words):\\n    codes = {\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\",\\n             \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\",\\n             \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"}\\n    return len(set([\"\".join([codes.get(ch) for ch in word]) for word in words]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2437635,
                "title": "set-stream",
                "content": "\\n### Java Set\\n```java\\npublic int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> uniqueRepresentations = new HashSet<>();\\n        \\n        for (String word : words) {\\n            StringBuilder newWord = new StringBuilder();\\n            for (char character : word.toCharArray()) \\n                newWord.append(alphabet[character - \\'a\\']);\\n            \\n            uniqueRepresentations.add(newWord.toString());\\n        }\\n        return uniqueRepresentations.size();\\n    }\\n```\\n\\n#### Java Stream\\n```java\\npublic int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        return (int) Arrays.stream(words).map(word -> word.chars().mapToObj(character -> alphabet[character - \\'a\\'])\\n                .collect(Collectors.joining())).distinct().count();\\n    }\\n```\\n\\n#### C++\\n```\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> alphabet = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> uniqueRepresentations;\\n\\n        for (string word : words) {\\n            string newWord;\\n            for (char symbol : word) \\n                newWord += (alphabet[symbol - \\'a\\']);\\n            \\n            uniqueRepresentations.insert(newWord);\\n        }\\n        return uniqueRepresentations.size();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> uniqueRepresentations = new HashSet<>();\\n        \\n        for (String word : words) {\\n            StringBuilder newWord = new StringBuilder();\\n            for (char character : word.toCharArray()) \\n                newWord.append(alphabet[character - \\'a\\']);\\n            \\n            uniqueRepresentations.add(newWord.toString());\\n        }\\n        return uniqueRepresentations.size();\\n    }\\n```\n```java\\npublic int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        return (int) Arrays.stream(words).map(word -> word.chars().mapToObj(character -> alphabet[character - \\'a\\'])\\n                .collect(Collectors.joining())).distinct().count();\\n    }\\n```\n```\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> alphabet = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\"\\n                ,\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> uniqueRepresentations;\\n\\n        for (string word : words) {\\n            string newWord;\\n            for (char symbol : word) \\n                newWord += (alphabet[symbol - \\'a\\']);\\n            \\n            uniqueRepresentations.insert(newWord);\\n        }\\n        return uniqueRepresentations.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2439228,
                "title": "python-3-liner-solution-explained-easy-understand-dictionary-beginner-friendly",
                "content": "**You can just copy & paste the Morse code map**\\n\\nHere\\'s the 3 lines solution:\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        ENG_to_MORSE = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\" }\\n        transform = lambda c: ENG_to_MORSE[c]   # use lambda function\\n        return len(Counter(\"\".join(map(transform, word)) for word in words))\\n```\\n\\nAnd here\\'s the code for better understand:\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        \\n        # create a dictionary for morse code (You can just copy & paste it! ^.^)\\n        ENG_to_MORSE = {  \\n            \\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\",\\n            \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\",\\n            \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\",\\n            \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\",\\n            \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\",\\n        }\\n        \\n        cnt = {}    # dictionary for different transformations\\n        \\n        for word in words:      # loop through every word\\n            \\n            tmp = \"\"\\n            \\n            for c in word:      # loop through every character\\n                tmp += ENG_to_MORSE[c]    # convert the word to morse code\\n                \\n            if tmp not in cnt:\\n                cnt[tmp] = 0\\n            else:\\n                cnt[tmp] += 1\\n\\n        return len(cnt)     # return how many different elements in cnt\\n```\\n\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        ENG_to_MORSE = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\" }\\n        transform = lambda c: ENG_to_MORSE[c]   # use lambda function\\n        return len(Counter(\"\".join(map(transform, word)) for word in words))\\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        \\n        # create a dictionary for morse code (You can just copy & paste it! ^.^)\\n        ENG_to_MORSE = {  \\n            \\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\",\\n            \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\",\\n            \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\",\\n            \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\",\\n            \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\",\\n        }\\n        \\n        cnt = {}    # dictionary for different transformations\\n        \\n        for word in words:      # loop through every word\\n            \\n            tmp = \"\"\\n            \\n            for c in word:      # loop through every character\\n                tmp += ENG_to_MORSE[c]    # convert the word to morse code\\n                \\n            if tmp not in cnt:\\n                cnt[tmp] = 0\\n            else:\\n                cnt[tmp] += 1\\n\\n        return len(cnt)     # return how many different elements in cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436484,
                "title": "daily-leetcoding-challenge-august-day-17",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-morse-code-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Hash Set\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-morse-code-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 120671,
                "title": "1-ms-faster-than-100-00-of-java-online-submissions",
                "content": "For me, most times it took 1 ms, but admittedly, sometimes it\\'s 2 ms (faster than 99.55% ) or 3 ms. Depends on the Judge\\'s mood ;) \\n\\n```\\n    String[] codes = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            set.add(getCode(word));\\n        }\\n        return set.size();\\n    }\\n\\n    private String getCode(String word) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : word.toCharArray()) {\\n            sb.append(codes[ch - \\'a\\']);\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n```\\n\\t\\nHere\\'s a slightly more readable version, but based on my experience (or maybe luck), it takes 3-4 ms:\\n\\t\\n\\n\\t\\n```\\n    String[] codes = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String morseCode = getCode(word);\\n            set.add(morseCode);\\n        }\\n        return set.size();\\n    }\\n\\n    private String getCode(String word) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : word.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            String characterCode = codes[index];\\n            sb.append(characterCode);\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    String[] codes = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            set.add(getCode(word));\\n        }\\n        return set.size();\\n    }\\n\\n    private String getCode(String word) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : word.toCharArray()) {\\n            sb.append(codes[ch - \\'a\\']);\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374214,
                "title": "javascript-solution-using-set",
                "content": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    var morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n                  \"--.\",\"....\",\"..\",\".---\",\\n                  \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                  \".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    var transformations = new Set();\\n    \\n    for (let word of words) {        \\n        var trans = \"\";\\n        for (let letter of word) {\\n            var index = letter.charCodeAt(0) - 97;\\n            trans += morse[index];\\n        }\\n        \\n        transformations.add(trans);   \\n    }\\n    \\n    return transformations.size;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    var morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n                  \"--.\",\"....\",\"..\",\".---\",\\n                  \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                  \".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    var transformations = new Set();\\n    \\n    for (let word of words) {        \\n        var trans = \"\";\\n        for (let letter of word) {\\n            var index = letter.charCodeAt(0) - 97;\\n            trans += morse[index];\\n        }\\n        \\n        transformations.add(trans);   \\n    }\\n    \\n    return transformations.size;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 945063,
                "title": "c-super-easy-and-simple-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> codes = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> res;\\n        for (auto word : words) {\\n            string curr = \"\";\\n            for (auto ch : word)\\n                curr += codes[ch-97];\\n            res.insert(curr);\\n        }\\n        return res.size();\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> codes = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> res;\\n        for (auto word : words) {\\n            string curr = \"\";\\n            for (auto ch : word)\\n                curr += codes[ch-97];\\n            res.insert(curr);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436848,
                "title": "java-100-faster-code-easy-solution-using-hashset",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] arr = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        HashSet<String> set = new HashSet<>();\\n        for (String word : words) \\n            set.add(transformMorse(word, arr));\\n        return set.size();\\n    }\\n    private String transformMorse(String word, String[] arr) {\\n        StringBuilder build = new StringBuilder();\\n        for (char c : word.toCharArray())\\n            build.append(arr[(int)c - 97]);\\n        return build.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] arr = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        HashSet<String> set = new HashSet<>();\\n        for (String word : words) \\n            set.add(transformMorse(word, arr));\\n        return set.size();\\n    }\\n    private String transformMorse(String word, String[] arr) {\\n        StringBuilder build = new StringBuilder();\\n        for (char c : word.toCharArray())\\n            build.append(arr[(int)c - 97]);\\n        return build.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436733,
                "title": "100-c-easy-with-explanation-hashmap-clean-code",
                "content": "**General Idea:**\\n- construct each word in morse code\\n- insert word into a set (sets won\\'t store duplicates) <- key point\\n- return set size at the end\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n    \\n\\n\\t\\tint uniqueMorseRepresentations(vector<string>& words) \\n\\t\\t{\\n\\t\\t\\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                        \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                        \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n\\t\\t\\tunordered_set<string> u;\\n\\n\\t\\t\\tfor (auto word : words) {\\n\\t\\t\\t\\tstring t;\\n\\t\\t\\t\\tfor (auto c : word) t += a[c - \\'a\\'];\\n\\t\\t\\t\\tu.insert (t);\\n\\t\\t\\t }\\n\\n\\t\\treturn u.size ();\\n\\t\\t}\\n\\t\\t};\\n\\t\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community).**\\n\\n**HAPPY CODING:)**\\n\\n*Any suggestions and improvements are always welcome*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n    \\n\\n\\t\\tint uniqueMorseRepresentations(vector<string>& words) \\n\\t\\t{\\n\\t\\t\\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                        \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                        \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 120805,
                "title": "functional-javascript-map-reduce",
                "content": "1. Map each word into it\\'s morse code representation\\n2. Reduce the list of morse code strings into a single set\\n3. Return the size of the set\\n\\nThe helper function just uses the ascii code to index into the `codes` array.\\n\\n```\\nconst codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\nconst getIdx = char => char.charCodeAt(0) - \\'a\\'.charCodeAt(0)\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    return words.map( word => word.split(\\'\\')\\n                                 .map( char => codes[getIdx(char)])\\n                                 .join(\\'\\'))\\n                .reduce((set, cur) => set.add(cur), new Set())\\n                .size\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\nconst getIdx = char => char.charCodeAt(0) - \\'a\\'.charCodeAt(0)\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    return words.map( word => word.split(\\'\\')\\n                                 .map( char => codes[getIdx(char)])\\n                                 .join(\\'\\'))\\n                .reduce((set, cur) => set.add(cur), new Set())\\n                .size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437807,
                "title": "c-0ms-100-easy-solution-explained-easy-to-understand-beginner-friendly-qsort",
                "content": "Basicly, we just convert every word from English to Morse code.\\nWe use qsort to rearrange order, so that we can just compare two adjacent elements.\\n```\\nint cmp(const void* a, const void*b){   // qsort compare function\\n    return strcmp(*(const char**)a, *(const char**)b);\\n}\\n\\n// create a map for morse code\\nchar morse[26][5] = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n                   \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n                   \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n\\nint uniqueMorseRepresentations(char ** words, int wordsSize){\\n    \\n    if (wordsSize == 1) return 1;\\n    \\n    char** trans = (char**)malloc(wordsSize * sizeof(char*));   // create 2D array \\n    \\n    for(int i=0; i < wordsSize; i++){\\n        int len = strlen(words[i]);\\n        trans[i] = (char*) calloc((len * 4 + 1), sizeof(char)); // create space for each morse code\\n        for(int j=0; j < len; j++)\\n            strcat(trans[i], morse[words[i][j] - \\'a\\']);     // convert english to morse code\\n    }\\n    \\n    qsort(trans, wordsSize, sizeof(char**), cmp);      // sort these morse codes by their length\\n    \\n    int cnt = wordsSize;        // this is how many elements are different\\n    for(int i=1; i < wordsSize; i++)\\n        if (!strcmp(trans[i-1], trans[i])) cnt--;   // loop through trans and compare\\n    \\n    for(int i=0; i < wordsSize; i++)    // free the space\\n        free(trans[i]);\\n    free(trans);\\n    \\n    return cnt;\\n}\\n```\\n**Please UPVOTE if you LIKE!!**\\n![image](https://assets.leetcode.com/users/images/d7089d0b-18ee-4752-af79-8abd501568cb_1660717565.7753801.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void* a, const void*b){   // qsort compare function\\n    return strcmp(*(const char**)a, *(const char**)b);\\n}\\n\\n// create a map for morse code\\nchar morse[26][5] = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n                   \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n                   \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n\\n\\nint uniqueMorseRepresentations(char ** words, int wordsSize){\\n    \\n    if (wordsSize == 1) return 1;\\n    \\n    char** trans = (char**)malloc(wordsSize * sizeof(char*));   // create 2D array \\n    \\n    for(int i=0; i < wordsSize; i++){\\n        int len = strlen(words[i]);\\n        trans[i] = (char*) calloc((len * 4 + 1), sizeof(char)); // create space for each morse code\\n        for(int j=0; j < len; j++)\\n            strcat(trans[i], morse[words[i][j] - \\'a\\']);     // convert english to morse code\\n    }\\n    \\n    qsort(trans, wordsSize, sizeof(char**), cmp);      // sort these morse codes by their length\\n    \\n    int cnt = wordsSize;        // this is how many elements are different\\n    for(int i=1; i < wordsSize; i++)\\n        if (!strcmp(trans[i-1], trans[i])) cnt--;   // loop through trans and compare\\n    \\n    for(int i=0; i < wordsSize; i++)    // free the space\\n        free(trans[i]);\\n    free(trans);\\n    \\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869706,
                "title": "804-unique-morse-code-words-hasmap-hashset-4ms-java",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashMap<Character, String> map = new HashMap<>();\\n        map.put(\\'a\\', \".-\");\\n        map.put(\\'b\\', \"-...\");\\n        map.put(\\'c\\', \"-.-.\");\\n        map.put(\\'d\\', \"-..\");\\n        map.put(\\'e\\', \".\");\\n        map.put(\\'f\\', \"..-.\");\\n        map.put(\\'g\\', \"--.\");\\n        map.put(\\'h\\', \"....\");\\n        map.put(\\'i\\', \"..\");\\n        map.put(\\'j\\', \".---\");\\n        map.put(\\'k\\', \"-.-\");\\n        map.put(\\'l\\', \".-..\");\\n        map.put(\\'m\\', \"--\");\\n        map.put(\\'n\\', \"-.\");\\n        map.put(\\'o\\', \"---\");\\n        map.put(\\'p\\', \".--.\");\\n        map.put(\\'q\\', \"--.-\");\\n        map.put(\\'r\\', \".-.\");\\n        map.put(\\'s\\', \"...\");\\n        map.put(\\'t\\', \"-\");\\n        map.put(\\'u\\', \"..-\");\\n        map.put(\\'v\\', \"...-\");\\n        map.put(\\'w\\', \".--\");\\n        map.put(\\'x\\', \"-..-\");\\n        map.put(\\'y\\', \"-.--\");\\n        map.put(\\'z\\', \"--..\");\\n        \\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<words.length; i++)\\n        {\\n            String str = words[i];\\n            String str1 = \"\";\\n                for(int j=0; j<str.length(); j++)\\n                {\\n                    str1 = str1 + map.get(str.charAt(j));\\n                }\\n            set.add(str1);\\n        }\\n        return set.size();\\n        \\n    }\\n}\\n```\\n**If you like my solution Please UPVOTE**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashMap<Character, String> map = new HashMap<>();\\n        map.put(\\'a\\', \".-\");\\n        map.put(\\'b\\', \"-...\");\\n        map.put(\\'c\\', \"-.-.\");\\n        map.put(\\'d\\', \"-..\");\\n        map.put(\\'e\\', \".\");\\n        map.put(\\'f\\', \"..-.\");\\n        map.put(\\'g\\', \"--.\");\\n        map.put(\\'h\\', \"....\");\\n        map.put(\\'i\\', \"..\");\\n        map.put(\\'j\\', \".---\");\\n        map.put(\\'k\\', \"-.-\");\\n        map.put(\\'l\\', \".-..\");\\n        map.put(\\'m\\', \"--\");\\n        map.put(\\'n\\', \"-.\");\\n        map.put(\\'o\\', \"---\");\\n        map.put(\\'p\\', \".--.\");\\n        map.put(\\'q\\', \"--.-\");\\n        map.put(\\'r\\', \".-.\");\\n        map.put(\\'s\\', \"...\");\\n        map.put(\\'t\\', \"-\");\\n        map.put(\\'u\\', \"..-\");\\n        map.put(\\'v\\', \"...-\");\\n        map.put(\\'w\\', \".--\");\\n        map.put(\\'x\\', \"-..-\");\\n        map.put(\\'y\\', \"-.--\");\\n        map.put(\\'z\\', \"--..\");\\n        \\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<words.length; i++)\\n        {\\n            String str = words[i];\\n            String str1 = \"\";\\n                for(int j=0; j<str.length(); j++)\\n                {\\n                    str1 = str1 + map.get(str.charAt(j));\\n                }\\n            set.add(str1);\\n        }\\n        return set.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568159,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=uFNUoytk270\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\n  class Solution {\\n  public:\\n\\n\\n  int uniqueMorseRepresentations(vector<string>& words) \\n  {\\n  \\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                  \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n  \\tunordered_map<string,int> um;\\n\\n  \\tfor (int i=0; i< words.size(); i++) {\\n  \\t\\tstring st;\\n  \\t\\tfor (int j=0; j<words[i].size(); j++) st += a[words[i][j] - \\'a\\'];\\n  \\t\\tum[st]=1;\\n  \\t }\\n\\n  return um.size ();\\n  }\\n  };\\n```\\n\\n**PYTHON**(copied)\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                    \\n            m = \\'\\'\\n            for l in w:                       \\n                m += mos[ord(l) - ord(\\'a\\')] \\n            s.add(m)                      \\n        \\n        return len(s)\\n```\\n**JAVA**(copied)\\n\\n```\\nclass Solution {\\n    private final String[] morseCodes = {\\n        \".-\",\\n        \"-...\",\\n        \"-.-.\",\\n        \"-..\",\\n        \".\",\\n        \"..-.\",\\n        \"--.\",\\n        \"....\",\\n        \"..\",\\n        \".---\",\\n        \"-.-\",\\n        \".-..\",\\n        \"--\",\\n        \"-.\",\\n        \"---\",\\n        \".--.\",\\n        \"--.-\",\\n        \".-.\",\\n        \"...\",\\n        \"-\",\\n        \"..-\",\\n        \"...-\",\\n        \".--\",\\n        \"-..-\",\\n        \"-.--\",\\n        \"--..\"\\n    };\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        final Set<String> codes = new HashSet<>();\\n\\n        for (String word : words) {\\n            final StringBuilder morseCode = new StringBuilder();\\n            for (int i = 0, n = word.length(); i < n; i++) {\\n                morseCode.append(morseCodes[word.charAt(i) - \\'a\\']);\\n            }\\n            codes.add(morseCode.toString());\\n        }\\n\\n        return codes.size();\\n    }\\n}\\n```\\n**Please UPVOTE  to motivate me for solving more questions like this and clubbing all languages solution!!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n  class Solution {\\n  public:\\n\\n\\n  int uniqueMorseRepresentations(vector<string>& words) \\n  {\\n  \\tvector<string> a = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\\n                  \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n  \\tunordered_map<string,int> um;\\n\\n  \\tfor (int i=0; i< words.size(); i++) {\\n  \\t\\tstring st;\\n  \\t\\tfor (int j=0; j<words[i].size(); j++) st += a[words[i][j] - \\'a\\'];\\n  \\t\\tum[st]=1;\\n  \\t }\\n\\n  return um.size ();\\n  }\\n  };\\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                    \\n            m = \\'\\'\\n            for l in w:                       \\n                m += mos[ord(l) - ord(\\'a\\')] \\n            s.add(m)                      \\n        \\n        return len(s)\\n```\n```\\nclass Solution {\\n    private final String[] morseCodes = {\\n        \".-\",\\n        \"-...\",\\n        \"-.-.\",\\n        \"-..\",\\n        \".\",\\n        \"..-.\",\\n        \"--.\",\\n        \"....\",\\n        \"..\",\\n        \".---\",\\n        \"-.-\",\\n        \".-..\",\\n        \"--\",\\n        \"-.\",\\n        \"---\",\\n        \".--.\",\\n        \"--.-\",\\n        \".-.\",\\n        \"...\",\\n        \"-\",\\n        \"..-\",\\n        \"...-\",\\n        \".--\",\\n        \"-..-\",\\n        \"-.--\",\\n        \"--..\"\\n    };\\n\\n    public int uniqueMorseRepresentations(String[] words) {\\n        final Set<String> codes = new HashSet<>();\\n\\n        for (String word : words) {\\n            final StringBuilder morseCode = new StringBuilder();\\n            for (int i = 0, n = word.length(); i < n; i++) {\\n                morseCode.append(morseCodes[word.charAt(i) - \\'a\\']);\\n            }\\n            codes.add(morseCode.toString());\\n        }\\n\\n        return codes.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800987,
                "title": "c-simple-solution-explained-100-time-93-space",
                "content": "Pro-tip: if there are no extra constraints, go for performing low hanging fruits in your own interviews.\\n\\nAnd this one seemed like a typical case: we can solve it using very little extra resources, so let\\'s plan in advance:\\n* we know we need to convert the strings to find similar matches (you might do so without converting and finding how a few characters can overlap others in morse, but I would not go there);\\n* we need some convenient data structure to store our intermediate results so that we can know how many unique morse strings we will get.\\n\\nWe can solve easily the first point with a helper function (`convertToMorse`, in my case) and an `unordered_set` looks ideal for the latter point, so I will call it `seen` and accumulate the results there.\\n\\nOnce I am done, I will just return its length and will be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string morse[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    string convertToMorse(string s) {\\n        string res;\\n        for (char c: s) res.append(morse[c - \\'a\\']);\\n        return res;\\n    }\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string> seen;\\n        for (string s: words) seen.insert(convertToMorse(s));\\n        return seen.size();\\n    }\\n};\\n```\\n\\nP.S.: extra goodie: an array to keep track of the characters to convert is more than enough - lightweight and with quick 1:1 matching.",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string morse[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    string convertToMorse(string s) {\\n        string res;\\n        for (char c: s) res.append(morse[c - \\'a\\']);\\n        return res;\\n    }\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string> seen;\\n        for (string s: words) seen.insert(convertToMorse(s));\\n        return seen.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079850,
                "title": "easy-solution-line-by-line-explanation-python-java-c-ruby",
                "content": "# Beats\\n![image.png](https://assets.leetcode.com/users/images/3d70d2c2-15a4-4bac-85ee-60513e1da5b6_1695459168.514062.png)\\n\\n# Intuition\\nThe problem asks for the number of different transformations among a list of words, where each word can be represented as a concatenation of Morse code representations for its letters. To solve this, we need to convert each letter in a word to its Morse code equivalent and count the unique representations.\\n\\n# Approach\\n1. Define the English alphabet and Morse code representations:\\n   - `letters` stores the lowercase English alphabet from \\'a\\' to \\'z\\'.\\n   - `morse_code` stores the corresponding Morse code representations for each letter.\\n\\n2. Create a dictionary mapping letters to Morse code:\\n   - `morse_dict` is a dictionary created by zipping `letters` and `morse_code` together. It maps each letter to its Morse code representation.\\n\\n3. Initialize a list to store words converted to Morse code:\\n   - `words2` is an empty list that will be used to store the Morse code representations of the input words.\\n\\n4. Iterate through each word in the input list:\\n   - For each word in `words`, the code initializes an empty string `k` to store the Morse code for the current word.\\n\\n5. Iterate through each character in the current word:\\n   - For each character `i` in the current word, the code appends the Morse code representation of that character (retrieved from `morse_dict`) to the string `k`.\\n\\n6. Append the Morse code for the current word to the list:\\n   - After converting the entire word to Morse code and building the string `k`, the code appends `k` to the `words2` list.\\n\\n7. Return the count of unique Morse code representations:\\n   - The code returns the length of the set of `words2`. This effectively counts the number of unique Morse code representations in the list and returns that count as the result.\\n\\n# Complexity\\n- Time complexity: The code iterates through each character in each word, so the time complexity is O(n), where n is the total number of characters in all words.\\n- Space complexity: The space complexity is O(n) as well because the `words2` list stores Morse code representations for each word.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        # Define the English alphabet\\n        letters = \"abcdefghijklmnopqrstuvwxyz\"\\n        \\n        # Define the corresponding Morse code representations\\n        morse_code = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n\\n        # Create a dictionary that maps letters to Morse code\\n        morse_dict = dict(zip(letters, morse_code))\\n\\n        # Initialize a list to store words converted to Morse code\\n        words2 = []\\n\\n        # Iterate through each word in the input list\\n        for word in words:\\n            # Initialize an empty string to store the Morse code for the current word\\n            k = \"\"\\n            \\n            # Iterate through each character in the current word\\n            for i in word:\\n                # Append the Morse code representation of the character to the string\\n                k += morse_dict[i]\\n\\n            # Append the Morse code for the current word to the list\\n            words2.append(k) \\n\\n        # Return the count of unique Morse code representations\\n        return len(set(words2))\\n\\n```\\n\\n# Java\\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        };\\n\\n        Set<String> uniqueMorse = new HashSet<>();\\n\\n        for (String word : words) {\\n            StringBuilder morseRepresentation = new StringBuilder();\\n            for (char c : word.toCharArray()) {\\n                morseRepresentation.append(morseCode[c - \\'a\\']);\\n            }\\n            uniqueMorse.add(morseRepresentation.toString());\\n        }\\n\\n        return uniqueMorse.size();\\n    }\\n}\\n\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        };\\n\\n        unordered_set<string> uniqueMorse;\\n\\n        for (const string& word : words) {\\n            string morseRepresentation = \"\";\\n            for (char c : word) {\\n                morseRepresentation += morseCode[c - \\'a\\'];\\n            }\\n            uniqueMorse.insert(morseRepresentation);\\n        }\\n\\n        return uniqueMorse.size();\\n    }\\n};\\n\\n```\\n# Ruby\\n```\\nclass Solution\\n  MORSE_CODE = [\\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n    \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n    \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n  ]\\n\\n  def unique_morse_representations(words)\\n    unique_morse = Set.new\\n\\n    words.each do |word|\\n      morse_representation = \"\"\\n      word.each_char do |char|\\n        morse_representation += MORSE_CODE[char.ord - \\'a\\'.ord]\\n      end\\n      unique_morse.add(morse_representation)\\n    end\\n\\n    unique_morse.size\\n  end\\nend\\n\\n```\\n# javascript\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar uniqueMorseRepresentations = function (words) {\\n    const morseCode = [\\n        \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n        \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\\n        \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n    ];\\n\\n    const uniqueMorse = new Set();\\n\\n    for (const word of words) {\\n        let morseRepresentation = \"\";\\n        for (const char of word) {\\n            morseRepresentation += morseCode[char.charCodeAt(0) - \\'a\\'.charCodeAt(0)];\\n        }\\n        uniqueMorse.add(morseRepresentation);\\n    }\\n\\n    return uniqueMorse.size;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Ruby"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        # Define the English alphabet\\n        letters = \"abcdefghijklmnopqrstuvwxyz\"\\n        \\n        # Define the corresponding Morse code representations\\n        morse_code = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\\n\\n        # Create a dictionary that maps letters to Morse code\\n        morse_dict = dict(zip(letters, morse_code))\\n\\n        # Initialize a list to store words converted to Morse code\\n        words2 = []\\n\\n        # Iterate through each word in the input list\\n        for word in words:\\n            # Initialize an empty string to store the Morse code for the current word\\n            k = \"\"\\n            \\n            # Iterate through each character in the current word\\n            for i in word:\\n                # Append the Morse code representation of the character to the string\\n                k += morse_dict[i]\\n\\n            # Append the Morse code for the current word to the list\\n            words2.append(k) \\n\\n        # Return the count of unique Morse code representations\\n        return len(set(words2))\\n\\n```\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        };\\n\\n        Set<String> uniqueMorse = new HashSet<>();\\n\\n        for (String word : words) {\\n            StringBuilder morseRepresentation = new StringBuilder();\\n            for (char c : word.toCharArray()) {\\n                morseRepresentation.append(morseCode[c - \\'a\\']);\\n            }\\n            uniqueMorse.add(morseRepresentation.toString());\\n        }\\n\\n        return uniqueMorse.size();\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morseCode = {\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n        };\\n\\n        unordered_set<string> uniqueMorse;\\n\\n        for (const string& word : words) {\\n            string morseRepresentation = \"\";\\n            for (char c : word) {\\n                morseRepresentation += morseCode[c - \\'a\\'];\\n            }\\n            uniqueMorse.insert(morseRepresentation);\\n        }\\n\\n        return uniqueMorse.size();\\n    }\\n};\\n\\n```\n```\\nclass Solution\\n  MORSE_CODE = [\\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n    \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\",\\n    \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n  ]\\n\\n  def unique_morse_representations(words)\\n    unique_morse = Set.new\\n\\n    words.each do |word|\\n      morse_representation = \"\"\\n      word.each_char do |char|\\n        morse_representation += MORSE_CODE[char.ord - \\'a\\'.ord]\\n      end\\n      unique_morse.add(morse_representation)\\n    end\\n\\n    unique_morse.size\\n  end\\nend\\n\\n```\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar uniqueMorseRepresentations = function (words) {\\n    const morseCode = [\\n        \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\",\\n        \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\\n        \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\\n    ];\\n\\n    const uniqueMorse = new Set();\\n\\n    for (const word of words) {\\n        let morseRepresentation = \"\";\\n        for (const char of word) {\\n            morseRepresentation += morseCode[char.charCodeAt(0) - \\'a\\'.charCodeAt(0)];\\n        }\\n        uniqueMorse.add(morseRepresentation);\\n    }\\n\\n    return uniqueMorse.size;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390327,
                "title": "c-and-c-very-easy-solution",
                "content": "![photo_2023-04-07_17-44-42.jpg](https://assets.leetcode.com/users/images/37fcecb2-fe9c-4b22-83d2-23102a7c2ba5_1680871628.659171.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:Beats 49.9% of other solutions in C#.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:Beats 94.55% of other solutions in C#.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector <string> v={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n        \"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\\n        \".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\\n        \"-.--\",\"--..\"};\\n        unordered_map <string,int> my;\\n        string s;\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].length();j++){\\n                s+=v[words[i][j]-\\'a\\'];\\n            }\\n            my[s]=1;\\n            s.clear();\\n        }\\n      return my.size();\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n        Dictionary<char,string> dic=new();\\n        dic.Add(\\'a\\',\".-\");dic.Add(\\'b\\',\"-...\");dic.Add(\\'c\\',\"-.-.\");\\n        dic.Add(\\'d\\',\"-..\");dic.Add(\\'e\\',\".\");dic.Add(\\'f\\',\"..-.\");\\n        dic.Add(\\'g\\',\"--.\");dic.Add(\\'h\\',\"....\");dic.Add(\\'i\\',\"..\");\\n        dic.Add(\\'j\\',\".---\");dic.Add(\\'k\\',\"-.-\");dic.Add(\\'l\\',\".-..\");\\n        dic.Add(\\'m\\',\"--\");dic.Add(\\'n\\',\"-.\");dic.Add(\\'o\\',\"---\");\\n        dic.Add(\\'p\\',\".--.\");dic.Add(\\'q\\',\"--.-\");dic.Add(\\'r\\',\".-.\");\\n        dic.Add(\\'s\\',\"...\");dic.Add(\\'t\\',\"-\");dic.Add(\\'u\\',\"..-\");\\n        dic.Add(\\'v\\',\"...-\");dic.Add(\\'w\\',\".--\");dic.Add(\\'x\\',\"-..-\");\\n        dic.Add(\\'y\\',\"-.--\");dic.Add(\\'z\\',\"--..\");\\n        Dictionary<string,char> res=new();\\n        \\n        for(int i=0;i<words.Length;i++){\\n            string s=string.Empty;\\n            for(int j=0;j<words[i].Length;j++){\\n             s+=dic[words[i][j]];\\n            }\\n            if(!res.ContainsKey(s))\\n            res.Add(s,\\'*\\');\\n        }\\n        return res.Count;\\n    }\\n}\\n```\\n```C# []\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n         List<string> d =new List<string>() {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        HashSet<string> s=new();\\n        foreach (var w in words) {\\n            string code=\"\";\\n            foreach (var c in w) \\n            code += d[c - \\'a\\'];\\n            s.Add(code);\\n        }\\n        return s.Count;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector <string> v={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n        \"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\\n        \".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\\n        \"-.--\",\"--..\"};\\n        unordered_map <string,int> my;\\n        string s;\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].length();j++){\\n                s+=v[words[i][j]-\\'a\\'];\\n            }\\n            my[s]=1;\\n            s.clear();\\n        }\\n      return my.size();\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n        Dictionary<char,string> dic=new();\\n        dic.Add(\\'a\\',\".-\");dic.Add(\\'b\\',\"-...\");dic.Add(\\'c\\',\"-.-.\");\\n        dic.Add(\\'d\\',\"-..\");dic.Add(\\'e\\',\".\");dic.Add(\\'f\\',\"..-.\");\\n        dic.Add(\\'g\\',\"--.\");dic.Add(\\'h\\',\"....\");dic.Add(\\'i\\',\"..\");\\n        dic.Add(\\'j\\',\".---\");dic.Add(\\'k\\',\"-.-\");dic.Add(\\'l\\',\".-..\");\\n        dic.Add(\\'m\\',\"--\");dic.Add(\\'n\\',\"-.\");dic.Add(\\'o\\',\"---\");\\n        dic.Add(\\'p\\',\".--.\");dic.Add(\\'q\\',\"--.-\");dic.Add(\\'r\\',\".-.\");\\n        dic.Add(\\'s\\',\"...\");dic.Add(\\'t\\',\"-\");dic.Add(\\'u\\',\"..-\");\\n        dic.Add(\\'v\\',\"...-\");dic.Add(\\'w\\',\".--\");dic.Add(\\'x\\',\"-..-\");\\n        dic.Add(\\'y\\',\"-.--\");dic.Add(\\'z\\',\"--..\");\\n        Dictionary<string,char> res=new();\\n        \\n        for(int i=0;i<words.Length;i++){\\n            string s=string.Empty;\\n            for(int j=0;j<words[i].Length;j++){\\n             s+=dic[words[i][j]];\\n            }\\n            if(!res.ContainsKey(s))\\n            res.Add(s,\\'*\\');\\n        }\\n        return res.Count;\\n    }\\n}\\n```\n```C# []\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n         List<string> d =new List<string>() {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        HashSet<string> s=new();\\n        foreach (var w in words) {\\n            string code=\"\";\\n            foreach (var c in w) \\n            code += d[c - \\'a\\'];\\n            s.Add(code);\\n        }\\n        return s.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273741,
                "title": "easiest-approach-c-explained",
                "content": "# Approach\\nWe make an array `morse` to order the morse codes for each alphabet. \\nThen we convert each word in the string to morse code and push back to the `code` vector. \\nThen we count distinct elements in the `code` array and return.\\n\\n# Complexity\\n- **Time complexity**:  O(NM)\\n- **Space complexity**: O(NM)\\nWhere $$N$$ is the size of array and $$M$$ is the length of word.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        vector<string> code; //To store morse codes\\n        int count=1; // To count distinct codes\\n        for(auto i: words){\\n            int n;\\n            string str;\\n            for(int j=0;j<i.length();j++){\\n                n=i[j]-97; // To get index for each alphabet from morse array\\n                str+=morse[n];\\n            }\\n            code.push_back(str);\\n        }\\n\\n        // Count distinct codes\\n        for (int i = 1; i < code.size(); i++) {\\n            int j;\\n            for (j = 0; j < i; j++)\\n                if (code[i] == code[j])\\n                    break;\\n            if (i == j) count++;\\n        }\\n\\n\\n        return count;\\n    }\\n        \\n};\\n```\\n\\n---\\n\\n\\n***Note**: `count` is initialized with 1 as the first element of an array is always unique.*\\n\\n---\\nIf it helped, would really appreciate an upvote ;)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        vector<string> code; //To store morse codes\\n        int count=1; // To count distinct codes\\n        for(auto i: words){\\n            int n;\\n            string str;\\n            for(int j=0;j<i.length();j++){\\n                n=i[j]-97; // To get index for each alphabet from morse array\\n                str+=morse[n];\\n            }\\n            code.push_back(str);\\n        }\\n\\n        // Count distinct codes\\n        for (int i = 1; i < code.size(); i++) {\\n            int j;\\n            for (j = 0; j < i; j++)\\n                if (code[i] == code[j])\\n                    break;\\n            if (i == j) count++;\\n        }\\n\\n\\n        return count;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165283,
                "title": "c-solution-using-sets-explained",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        // store morse codes for each letter \\n        vector<string> hash = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n                                \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        set<string> s ;\\n        for (int i = 0 ; i < words.size() ; i++)\\n        {\\n            string temp = \"\" ;\\n            for (int j = 0 ; j < words[i].length() ; j++)\\n            {\\n                // create string of morse of each word \\n                temp += hash[words[i][j] - \\'a\\'] ;\\n            }\\n            // store into a set, set stores only unique elements \\n            s.insert(temp) ;\\n        }\\n        // size of set gives unique morse codes \\n        return s.size() ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/4f899ab0-e157-4430-b23e-dd609b9ba0a8_1675965365.1080947.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        // store morse codes for each letter \\n        vector<string> hash = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n                                \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        set<string> s ;\\n        for (int i = 0 ; i < words.size() ; i++)\\n        {\\n            string temp = \"\" ;\\n            for (int j = 0 ; j < words[i].length() ; j++)\\n            {\\n                // create string of morse of each word \\n                temp += hash[words[i][j] - \\'a\\'] ;\\n            }\\n            // store into a set, set stores only unique elements \\n            s.insert(temp) ;\\n        }\\n        // size of set gives unique morse codes \\n        return s.size() ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126042,
                "title": "java-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] tokens = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for ( String word : words ) {\\n            StringBuilder sb = new StringBuilder();\\n            for ( int i = 0; i < word.length(); i++ ) {\\n                sb.append( tokens[word.charAt(i)-\\'a\\'] );\\n            }\\n            set.add( sb.toString() );\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] tokens = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for ( String word : words ) {\\n            StringBuilder sb = new StringBuilder();\\n            for ( int i = 0; i < word.length(); i++ ) {\\n                sb.append( tokens[word.charAt(i)-\\'a\\'] );\\n            }\\n            set.add( sb.toString() );\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122579,
                "title": "rust-0ms-using-iterators-hashset",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        static MORSE: [&str; 26] = [\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\",\\n            \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\",\\n            \"-.--\", \"--..\",\\n        ];\\n\\t\\t\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                w.chars()\\n                    .map(|c| MORSE[c as usize - \\'a\\' as usize])\\n                    .collect::<String>()\\n            })\\n            .collect::<HashSet<_>>()\\n            .len() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        static MORSE: [&str; 26] = [\\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\",\\n            \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\",\\n            \"-.--\", \"--..\",\\n        ];\\n\\t\\t\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                w.chars()\\n                    .map(|c| MORSE[c as usize - \\'a\\' as usize])\\n                    .collect::<String>()\\n            })\\n            .collect::<HashSet<_>>()\\n            .len() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2438206,
                "title": "python-elegant-short-two-lines-no-loops",
                "content": "\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tMORSE = {\\n\\t\\t\\t\\'a\\': \\'.-\\',   \\'b\\': \\'-...\\', \\'c\\': \\'-.-.\\', \\'d\\': \\'-..\\',  \\'e\\': \\'.\\',    \\'f\\': \\'..-.\\', \\'g\\': \\'--.\\',\\n\\t\\t\\t\\'h\\': \\'....\\', \\'i\\': \\'..\\',   \\'j\\': \\'.---\\', \\'k\\': \\'-.-\\',  \\'l\\': \\'.-..\\', \\'m\\': \\'--\\',   \\'n\\': \\'-.\\',\\n\\t\\t\\t\\'o\\': \\'---\\',  \\'p\\': \\'.--.\\', \\'q\\': \\'--.-\\', \\'r\\': \\'.-.\\',  \\'s\\': \\'...\\',  \\'t\\': \\'-\\',    \\'u\\': \\'..-\\',\\n\\t\\t\\t\\'v\\': \\'...-\\', \\'w\\': \\'.--\\',  \\'x\\': \\'-..-\\', \\'y\\': \\'-.--\\', \\'z\\': \\'--..\\',\\n\\t\\t}\\n\\n\\t\\tdef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\t\\t\\treturn len(set(map(self.encode, words)))\\n\\n\\t\\t@classmethod\\n\\t\\tdef encode(cls, word: str) -> str:\\n\\t\\t\\treturn \\'\\'.join(map(cls.MORSE.get, word))\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tMORSE = {\\n\\t\\t\\t\\'a\\': \\'.-\\',   \\'b\\': \\'-...\\', \\'c\\': \\'-.-.\\', \\'d\\': \\'-..\\',  \\'e\\': \\'.\\',    \\'f\\': \\'..-.\\', \\'g\\': \\'--.\\',\\n\\t\\t\\t\\'h\\': \\'....\\', \\'i\\': \\'..\\',   \\'j\\': \\'.---\\', \\'k\\': \\'-.-\\',  \\'l\\': \\'.-..\\', \\'m\\': \\'--\\',   \\'n\\': \\'-.\\',\\n\\t\\t\\t\\'o\\': \\'---\\',  \\'p\\': \\'.--.\\', \\'q\\': \\'--.-\\', \\'r\\': \\'.-.\\',  \\'s\\': \\'...\\',  \\'t\\': \\'-\\',    \\'u\\': \\'..-\\',\\n\\t\\t\\t\\'v\\': \\'...-\\', \\'w\\': \\'.--\\',  \\'x\\': \\'-..-\\', \\'y\\': \\'-.--\\', \\'z\\': \\'--..\\',\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 946854,
                "title": "python-faster-than-98",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int: \\n        transformations = []\\n        count = 0\\n        \\n        morse_code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for word in words:\\n            m = \\'\\'\\n            for char in word:\\n                m += morse_code[ord(char)-97]\\n            \\n            if m not in transformations:\\n                transformations.append(m)\\n                count +=1\\n        \\n        return count\\n\\'\\'\\'\\n\\nRuntime: 24 ms, faster than 98.75% of Python3 online submissions for Unique Morse Code Words.\\nMemory Usage: 14.4 MB, less than 13.24% of Python3 online submissions for Unique Morse Code Words.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int: \\n        transformations = []\\n        count = 0\\n        \\n        morse_code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for word in words:\\n            m = \\'\\'\\n            for char in word:\\n                m += morse_code[ord(char)-97]\\n            \\n            if m not in transformations:\\n                transformations.append(m)\\n                count +=1\\n        \\n        return count\\n\\'\\'\\'\\n\\nRuntime: 24 ms, faster than 98.75% of Python3 online submissions for Unique Morse Code Words.\\nMemory Usage: 14.4 MB, less than 13.24% of Python3 online submissions for Unique Morse Code Words.",
                "codeTag": "Java"
            },
            {
                "id": 945532,
                "title": "c-linear-scan-and-hash-set",
                "content": "```\\nclass Solution { // Linear scan and hash set\\npublic: \\n// Time/Space: O(N*M); O(N*M*P); \\n//where N is the number of word in the vector of \\'words\\',M is the maximal length of a word in \\'words\\', \\n//P is the maximal length of the Morse code for each letter.\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> m{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t// string m[26]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; // ok\\n        unordered_set<string> sset;\\n        for(const auto& w: words){\\n            string temp;\\n            for(const char& c: w) temp += m[c-\\'a\\'];\\n            sset.insert(temp);\\n        }\\n        return sset.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { // Linear scan and hash set\\npublic: \\n// Time/Space: O(N*M); O(N*M*P); \\n//where N is the number of word in the vector of \\'words\\',M is the maximal length of a word in \\'words\\', \\n//P is the maximal length of the Morse code for each letter.\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> m{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t// string m[26]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; // ok\\n        unordered_set<string> sset;\\n        for(const auto& w: words){\\n            string temp;\\n            for(const char& c: w) temp += m[c-\\'a\\'];\\n            sset.insert(temp);\\n        }\\n        return sset.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944888,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        code_words = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        uq = set()\\n        for word in words:\\n            this = []\\n            for c in word:\\n                this.append(code_words[ord(c)-97])\\n            uq.add(\\'\\'.join(this))\\n            \\n        return(len(uq))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        code_words = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        uq = set()\\n        for word in words:\\n            this = []\\n            for c in word:\\n                this.append(code_words[ord(c)-97])\\n            uq.add(\\'\\'.join(this))\\n            \\n        return(len(uq))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285283,
                "title": "4ms-93-66-c-solution",
                "content": "```\\nstruct Entry_s {\\n    char *key;\\n    int value;\\n    struct Entry_s *next;\\n};\\n\\ntypedef struct Entry_s Entry;\\n\\nstruct Hashtable_s {\\n    int size;\\n    int keys;\\n    struct Entry_s** table;\\n};\\n\\ntypedef struct Hashtable_s Hashtable;\\n\\nint hash(Hashtable *hashtable, char *key) {\\n    unsigned long int hashvalue = 0;\\n    int idx = 0;\\n    while (hashvalue < ULONG_MAX && idx < strlen(key)) {\\n        hashvalue = hashvalue << 8;\\n        hashvalue += key[idx];\\n        idx++;\\n    }\\n    return hashvalue % hashtable->size;\\n}\\n\\nEntry *createEntry(char *key, int value) {\\n    Entry *entry = (Entry *) malloc(sizeof(Entry));\\n    entry->key = strdup(key);\\n    entry->value = value;\\n    entry->next = NULL;\\n    return entry;\\n}\\n\\nvoid set(Hashtable *hashtable, char *key, int value) {\\n    Entry *entry = createEntry(key, value);\\n    int hashvalue = hash(hashtable, key);\\n    if (hashtable->table[hashvalue] == NULL) {\\n        hashtable->table[hashvalue] = entry;\\n        hashtable->keys++;\\n    } else {\\n        Entry *current = hashtable->table[hashvalue];\\n        while (current != NULL) {\\n            if (strcmp(current->key, key) == 0) return;\\n            if (current->next == NULL) {\\n                current->next = entry;\\n                hashtable->keys++;\\n            }\\n            current = current-> next;\\n        }\\n    }\\n}\\n\\nint *get(Hashtable *hashtable, char *key) {\\n    int hashvalue = hash(hashtable, key);\\n    if (hashtable->table[hashvalue] != NULL) {\\n        Entry *current = hashtable->table[hashvalue];\\n        while (current != NULL) {\\n            if (strcmp(current->key, key) == 0) {\\n                return &(current->value);\\n            }\\n            current = current->next;\\n        }\\n        return NULL;\\n    }\\n    return NULL;\\n}\\n\\nHashtable *createHashtable(int size) {\\n    Hashtable *hashtable = (Hashtable *) malloc(sizeof(Hashtable));\\n    hashtable->size = size;\\n    hashtable->keys = 0;\\n    hashtable->table = (Entry **) calloc(size, sizeof(Entry *));\\n    return hashtable;\\n}\\n\\nchar morse[][5] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\nchar *getMorse(char *str) {\\n    char *morseRep = (char *) malloc(200 * sizeof(char));\\n    int morseIdx = 0;\\n    for (int index = 0; str[index] != \\'\\\\0\\'; index++) {\\n        for (int idx = 0; morse[str[index] - 97][idx] != \\'\\\\0\\'; idx++) {\\n            morseRep[morseIdx++] = morse[str[index] - 97][idx];\\n        }\\n    }\\n    morseRep[morseIdx] = \\'\\\\0\\';\\n    return morseRep;\\n}\\n\\nint uniqueMorseRepresentations(char ** words, int wordsSize){\\n    Hashtable *hashtable = createHashtable(wordsSize);\\n    for (int index = 0; index < wordsSize; index++) {\\n        char *morse = getMorse(words[index]);\\n        set(hashtable, morse, 1);\\n    }\\n    return hashtable->keys;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Entry_s {\\n    char *key;\\n    int value;\\n    struct Entry_s *next;\\n};\\n\\ntypedef struct Entry_s Entry;\\n\\nstruct Hashtable_s {\\n    int size;\\n    int keys;\\n    struct Entry_s** table;\\n};\\n\\ntypedef struct Hashtable_s Hashtable;\\n\\nint hash(Hashtable *hashtable, char *key) {\\n    unsigned long int hashvalue = 0;\\n    int idx = 0;\\n    while (hashvalue < ULONG_MAX && idx < strlen(key)) {\\n        hashvalue = hashvalue << 8;\\n        hashvalue += key[idx];\\n        idx++;\\n    }\\n    return hashvalue % hashtable->size;\\n}\\n\\nEntry *createEntry(char *key, int value) {\\n    Entry *entry = (Entry *) malloc(sizeof(Entry));\\n    entry->key = strdup(key);\\n    entry->value = value;\\n    entry->next = NULL;\\n    return entry;\\n}\\n\\nvoid set(Hashtable *hashtable, char *key, int value) {\\n    Entry *entry = createEntry(key, value);\\n    int hashvalue = hash(hashtable, key);\\n    if (hashtable->table[hashvalue] == NULL) {\\n        hashtable->table[hashvalue] = entry;\\n        hashtable->keys++;\\n    } else {\\n        Entry *current = hashtable->table[hashvalue];\\n        while (current != NULL) {\\n            if (strcmp(current->key, key) == 0) return;\\n            if (current->next == NULL) {\\n                current->next = entry;\\n                hashtable->keys++;\\n            }\\n            current = current-> next;\\n        }\\n    }\\n}\\n\\nint *get(Hashtable *hashtable, char *key) {\\n    int hashvalue = hash(hashtable, key);\\n    if (hashtable->table[hashvalue] != NULL) {\\n        Entry *current = hashtable->table[hashvalue];\\n        while (current != NULL) {\\n            if (strcmp(current->key, key) == 0) {\\n                return &(current->value);\\n            }\\n            current = current->next;\\n        }\\n        return NULL;\\n    }\\n    return NULL;\\n}\\n\\nHashtable *createHashtable(int size) {\\n    Hashtable *hashtable = (Hashtable *) malloc(sizeof(Hashtable));\\n    hashtable->size = size;\\n    hashtable->keys = 0;\\n    hashtable->table = (Entry **) calloc(size, sizeof(Entry *));\\n    return hashtable;\\n}\\n\\nchar morse[][5] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\nchar *getMorse(char *str) {\\n    char *morseRep = (char *) malloc(200 * sizeof(char));\\n    int morseIdx = 0;\\n    for (int index = 0; str[index] != \\'\\\\0\\'; index++) {\\n        for (int idx = 0; morse[str[index] - 97][idx] != \\'\\\\0\\'; idx++) {\\n            morseRep[morseIdx++] = morse[str[index] - 97][idx];\\n        }\\n    }\\n    morseRep[morseIdx] = \\'\\\\0\\';\\n    return morseRep;\\n}\\n\\nint uniqueMorseRepresentations(char ** words, int wordsSize){\\n    Hashtable *hashtable = createHashtable(wordsSize);\\n    for (int index = 0; index < wordsSize; index++) {\\n        char *morse = getMorse(words[index]);\\n        set(hashtable, morse, 1);\\n    }\\n    return hashtable->keys;\\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 240121,
                "title": "python-o-n-beats-100",
                "content": "```python\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = {\\'a\\':\".-\",\\n                 \\'b\\':\"-...\",\\n                 \\'c\\':\"-.-.\",\\n                 \\'d\\':\"-..\",\\n                 \\'e\\':\".\",\\n                 \\'f\\':\"..-.\",\\n                 \\'g\\':\"--.\",\\n                 \\'h\\':\"....\",\\n                 \\'i\\':\"..\",\\n                 \\'j\\':\".---\",\\n                 \\'k\\':\"-.-\",\\n                 \\'l\\':\".-..\",\\n                 \\'m\\':\"--\",\\n                 \\'n\\':\"-.\",\\n                 \\'o\\':\"---\",\\n                 \\'p\\':\".--.\",\\n                 \\'q\\':\"--.-\",\\n                 \\'r\\':\".-.\",\\n                 \\'s\\':\"...\",\\n                 \\'t\\':\"-\",\\n                 \\'u\\':\"..-\",\\n                 \\'v\\':\"...-\",\\n                 \\'w\\':\".--\",\\n                 \\'x\\':\"-..-\",\\n                 \\'y\\':\"-.--\",\\n                 \\'z\\':\"--..\"}\\n        \\n        transformations = set()\\n        for word in words:\\n            transformation = \\'\\'\\n            for c in word:\\n                transformation += morse[c]\\n            transformations.add(transformation)\\n            \\n        return len(transformations)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = {\\'a\\':\".-\",\\n                 \\'b\\':\"-...\",\\n                 \\'c\\':\"-.-.\",\\n                 \\'d\\':\"-..\",\\n                 \\'e\\':\".\",\\n                 \\'f\\':\"..-.\",\\n                 \\'g\\':\"--.\",\\n                 \\'h\\':\"....\",\\n                 \\'i\\':\"..\",\\n                 \\'j\\':\".---\",\\n                 \\'k\\':\"-.-\",\\n                 \\'l\\':\".-..\",\\n                 \\'m\\':\"--\",\\n                 \\'n\\':\"-.\",\\n                 \\'o\\':\"---\",\\n                 \\'p\\':\".--.\",\\n                 \\'q\\':\"--.-\",\\n                 \\'r\\':\".-.\",\\n                 \\'s\\':\"...\",\\n                 \\'t\\':\"-\",\\n                 \\'u\\':\"..-\",\\n                 \\'v\\':\"...-\",\\n                 \\'w\\':\".--\",\\n                 \\'x\\':\"-..-\",\\n                 \\'y\\':\"-.--\",\\n                 \\'z\\':\"--..\"}\\n        \\n        transformations = set()\\n        for word in words:\\n            transformation = \\'\\'\\n            for c in word:\\n                transformation += morse[c]\\n            transformations.add(transformation)\\n            \\n        return len(transformations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137639,
                "title": "4ms-in-c",
                "content": "\\n```\\n#include <string.h>\\n\\nchar *getMorseString(char c)\\n{\\n    char *morse[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    \\n    return morse[c - \\'a\\'];\\n}\\n\\nvoid setMorseTransform(char *word, char *transform)\\n{    \\n    char *morseString;\\n    \\n    // Add each Morse character of each alphabetical letter from the word to the transform string\\n    while(*word)\\n    {\\n        morseString = getMorseString(*(word++));\\n            \\n        while(*morseString)\\n            *(transform++) = *(morseString++);\\n    }\\n    \\n    // Add the null terminating character to the end of the transform string\\n    *transform = \\'\\\\0\\';\\n    \\n    return;\\n}\\n\\n\\nint uniqueMorseRepresentations(char** words, int wordsSize) \\n{\\n    char *dd, *m, *c, transforms[100][50] = {\"\"};\\n    int counter, i, j, trans_count = 0;\\n    \\n    // Populate the Morse transform array with an entry for each word\\n    for(i = 0; i < wordsSize; i++)\\n        setMorseTransform(words[i], transforms[i]);\\n    \\n    // Starting with first element, perform linear search through array for duplicates.\\n    // When a duplicate transform is found, copy the\\n    // last element in the transform array to position j, and decrement wordsSize.\\n    //\\n    // If the new element at transforms[j] is also a duplicate, repeat the process until\\n    // a non-duplicate is found or wordsSize is less than 2.\\n    //\\n    // The end result should be a de-duplicated array of transforms.\\n    \\n    for(i = 0; i < wordsSize; i++)\\n        for(j = i+1; j < (wordsSize); j++)\\n            while(j < wordsSize && wordsSize > 1 && !strcmp(transforms[i], transforms[j]))\\n            {\\n                strcpy(transforms[j], transforms[wordsSize - 1]);\\n                --wordsSize;\\n            }\\n        \\n    return wordsSize;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <string.h>\\n\\nchar *getMorseString(char c)\\n{\\n    char *morse[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    \\n    return morse[c - \\'a\\'];\\n}\\n\\nvoid setMorseTransform(char *word, char *transform)\\n{    \\n    char *morseString;\\n    \\n    // Add each Morse character of each alphabetical letter from the word to the transform string\\n    while(*word)\\n    {\\n        morseString = getMorseString(*(word++));\\n            \\n        while(*morseString)\\n            *(transform++) = *(morseString++);\\n    }\\n    \\n    // Add the null terminating character to the end of the transform string\\n    *transform = \\'\\\\0\\';\\n    \\n    return;\\n}\\n\\n\\nint uniqueMorseRepresentations(char** words, int wordsSize) \\n{\\n    char *dd, *m, *c, transforms[100][50] = {\"\"};\\n    int counter, i, j, trans_count = 0;\\n    \\n    // Populate the Morse transform array with an entry for each word\\n    for(i = 0; i < wordsSize; i++)\\n        setMorseTransform(words[i], transforms[i]);\\n    \\n    // Starting with first element, perform linear search through array for duplicates.\\n    // When a duplicate transform is found, copy the\\n    // last element in the transform array to position j, and decrement wordsSize.\\n    //\\n    // If the new element at transforms[j] is also a duplicate, repeat the process until\\n    // a non-duplicate is found or wordsSize is less than 2.\\n    //\\n    // The end result should be a de-duplicated array of transforms.\\n    \\n    for(i = 0; i < wordsSize; i++)\\n        for(j = i+1; j < (wordsSize); j++)\\n            while(j < wordsSize && wordsSize > 1 && !strcmp(transforms[i], transforms[j]))\\n            {\\n                strcpy(transforms[j], transforms[wordsSize - 1]);\\n                --wordsSize;\\n            }\\n        \\n    return wordsSize;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3471332,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n        int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        unordered_set<string> s;\\n        for (auto w : words) {\\n            string code;\\n            for (auto c : w) code += d[c - \\'a\\'];\\n            s.insert(code);\\n        }\\n        return s.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        table = {}\\n        i = \\'a\\'\\n        for m in morse:\\n            table[i] = m\\n            i = chr(ord(i) + 1)\\n        pairs = set()\\n        for word in words:\\n            string = \"\"\\n            for w in word:\\n                string += table[w]\\n            pairs.add(string)\\n        return len(pairs)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        Set<String> set = new HashSet<>();\\n        for(String word : words){\\n            StringBuilder sb = new StringBuilder();\\n            for(char c : word.toCharArray()){\\n                sb.append(morseCode[c - \\'a\\']);\\n            }\\n            set.add(sb.toString());\\n        } \\n        return set.size();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n        int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> d = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        unordered_set<string> s;\\n        for (auto w : words) {\\n            string code;\\n            for (auto c : w) code += d[c - \\'a\\'];\\n            s.insert(code);\\n        }\\n        return s.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        table = {}\\n        i = \\'a\\'\\n        for m in morse:\\n            table[i] = m\\n            i = chr(ord(i) + 1)\\n        pairs = set()\\n        for word in words:\\n            string = \"\"\\n            for w in word:\\n                string += table[w]\\n            pairs.add(string)\\n        return len(pairs)\\n```\n```Java []\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCode = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        Set<String> set = new HashSet<>();\\n        for(String word : words){\\n            StringBuilder sb = new StringBuilder();\\n            for(char c : word.toCharArray()){\\n                sb.append(morseCode[c - \\'a\\']);\\n            }\\n            set.add(sb.toString());\\n        } \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437307,
                "title": "simple-easy-concise-solution-for-java-hashset",
                "content": "```\\nclass Solution {\\n    private String transform(String str) {\\n        String s[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"},res=\"\";\\n        for(int i=0;i<str.length();i++)\\n            res+=s[(int)str.charAt(i)-\\'a\\'];\\n        return res;\\n    }\\n    \\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashSet<String> set = new HashSet<String>();\\n        for(String w : words) set.add(transform(w));\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    private String transform(String str) {\\n        String s[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"},res=\"\";\\n        for(int i=0;i<str.length();i++)\\n            res+=s[(int)str.charAt(i)-\\'a\\'];\\n        return res;\\n    }\\n    \\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashSet<String> set = new HashSet<String>();\\n        for(String w : words) set.add(transform(w));\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436985,
                "title": "javascript-fast-and-simple-single-iteration-of-words-solution-hashmap-set",
                "content": "```\\nconst morseCode = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n\\nfunction uniqueMorseRepresentations(words) {\\n    const set = new Set();\\n\\n    for(let i = 0; i < words.length; i++) {\\n        let encryptedWord = \"\";\\n\\n        for (let l = 0; l < words[i].length; l++) {\\n            const character = words[i][l];\\n            \\n            encryptedWord += morseCode[character];\\n        }\\n\\n        set.add(encryptedWord);\\n    }\\n\\n    return set.size;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst morseCode = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n\\nfunction uniqueMorseRepresentations(words) {\\n    const set = new Set();\\n\\n    for(let i = 0; i < words.length; i++) {\\n        let encryptedWord = \"\";\\n\\n        for (let l = 0; l < words[i].length; l++) {\\n            const character = words[i][l];\\n            \\n            encryptedWord += morseCode[character];\\n        }\\n\\n        set.add(encryptedWord);\\n    }\\n\\n    return set.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436616,
                "title": "c-set-and-vectors",
                "content": "1.  keep the morse codes in a vector.\\n2.  iterate thru each character of each word\\n3.  build the code with the morse codes\\n4.  put the code in a set\\n5.  return the size of the set\\n6.  **Tune in to TWITCH to watch me solve it LIVE ON STREAM with my cool keyboards.  6pm Pacific time.  Link in profile.**\\n  \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string> codes;\\n        vector<string> morses = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(auto& word : words) {\\n            string curCode = \"\";\\n            for(char c : word) {\\n                curCode += morses[c - \\'a\\'];\\n            }\\n            codes.insert(curCode);\\n        }\\n        return codes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string> codes;\\n        vector<string> morses = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(auto& word : words) {\\n            string curCode = \"\";\\n            for(char c : word) {\\n                curCode += morses[c - \\'a\\'];\\n            }\\n            codes.insert(curCode);\\n        }\\n        return codes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436612,
                "title": "c-easy-solution-using-hashmap",
                "content": "# **C++ Easy solution Using Hashmap**\\n```\\nclass Solution {\\n    \\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        string arr[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_map<string,int>m;\\n        for(int i=0;i<words.size();i++){\\n            string s=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                s+=arr[words[i][j]-\\'a\\'];\\n            }\\n            m[s]++;\\n        }\\n        return m.size();\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        string arr[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_map<string,int>m;\\n        for(int i=0;i<words.size();i++){\\n            string s=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                s+=arr[words[i][j]-\\'a\\'];\\n            }\\n            m[s]++;\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362150,
                "title": "solution-in-python-3-beats-100-two-lines",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n    \\tM = [\\'.-\\',\\'-...\\',\\'-.-.\\',\\'-..\\',\\'.\\',\\'..-.\\',\\'--.\\',\\'....\\',\\'..\\',\\'.---\\',\\'-.-\\',\\'.-..\\',\\'--\\',\\'-.\\',\\'---\\',\\'.--.\\',\\'--.-\\',\\'.-.\\',\\'...\\',\\'-\\',\\'..-\\',\\'...-\\',\\'.--\\',\\'-..-\\',\\'-.--\\',\\'--..\\']\\n    \\treturn len(set([\\'\\'.join(map(lambda x: M[ord(x)-97], w)) for w in words]))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n    \\tM = [\\'.-\\',\\'-...\\',\\'-.-.\\',\\'-..\\',\\'.\\',\\'..-.\\',\\'--.\\',\\'....\\',\\'..\\',\\'.---\\',\\'-.-\\',\\'.-..\\',\\'--\\',\\'-.\\',\\'---\\',\\'.--.\\',\\'--.-\\',\\'.-.\\',\\'...\\',\\'-\\',\\'..-\\',\\'...-\\',\\'.--\\',\\'-..-\\',\\'-.--\\',\\'--..\\']\\n    \\treturn len(set([\\'\\'.join(map(lambda x: M[ord(x)-97], w)) for w in words]))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 351647,
                "title": "swift-5-12ms",
                "content": "```\\nclass Solution {\\n    func uniqueMorseRepresentations(_ words: [String]) -> Int {\\n        let morse: [Character : String] = [\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\", \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\", \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"]\\n\\n        return words.reduce(into: Set<String>()) {\\n            let transform = $1.reduce(into: \"\") { $0 += morse[$1] ?? \"\" }\\n            $0.insert(transform)\\n        }.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func uniqueMorseRepresentations(_ words: [String]) -> Int {\\n        let morse: [Character : String] = [\"a\": \".-\", \"b\": \"-...\", \"c\": \"-.-.\", \"d\": \"-..\", \"e\": \".\", \"f\": \"..-.\", \"g\": \"--.\", \"h\": \"....\", \"i\": \"..\", \"j\": \".---\", \"k\": \"-.-\", \"l\": \".-..\", \"m\": \"--\", \"n\": \"-.\", \"o\": \"---\", \"p\": \".--.\", \"q\": \"--.-\", \"r\": \".-.\", \"s\": \"...\", \"t\": \"-\", \"u\": \"..-\", \"v\": \"...-\", \"w\": \".--\", \"x\": \"-..-\", \"y\": \"-.--\", \"z\": \"--..\"]\\n\\n        return words.reduce(into: Set<String>()) {\\n            let transform = $1.reduce(into: \"\") { $0 += morse[$1] ?? \"\" }\\n            $0.insert(transform)\\n        }.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348948,
                "title": "python-3-using-dict-and-set",
                "content": "The idea is to map each character in the alphabet to a Morse code in a dictionary. Then use this map to make a set of words formated in Morse Code. Then return `len(set())`\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\" \\\\\\n             ,\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\" \\\\\\n             ,\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        D = dict( zip( string.ascii_lowercase,code ) ) # string.ascii_lowercase returns \"abc...xyz\"\\n        \\n\\t\\ts = set()\\n        for word in words:\\n\\t\\t\\t# add the joint of letter (in code format) to a set\\n            s.add(\"\".join( [ D[letter] for letter in word ] ) ) \\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\" \\\\\\n             ,\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\" \\\\\\n             ,\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        D = dict( zip( string.ascii_lowercase,code ) ) # string.ascii_lowercase returns \"abc...xyz\"\\n        \\n\\t\\ts = set()\\n        for word in words:\\n\\t\\t\\t# add the joint of letter (in code format) to a set\\n            s.add(\"\".join( [ D[letter] for letter in word ] ) ) \\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296064,
                "title": "javascript-solution",
                "content": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n    morsecode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    let set = new Set()\\n    \\n    for(let word of words){\\n        let mc = \"\"\\n        for(let c of word){\\n            mc += morsecode[c.charCodeAt(0)-\\'a\\'.charCodeAt(0)]\\n        }\\n        set.add(mc)\\n    }\\n    return set.size\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n    morsecode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    let set = new Set()\\n    \\n    for(let word of words){\\n        let mc = \"\"\\n        for(let c of word){\\n            mc += morsecode[c.charCodeAt(0)-\\'a\\'.charCodeAt(0)]\\n        }\\n        set.add(mc)\\n    }\\n    return set.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151852,
                "title": "python-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        transformation = []\\n        for word in words:\\n            temp = []\\n            for char in word:\\n                temp.append(morse[ord(char)-97])\\n            transformation.append(\\'\\'.join(temp))\\n        return len(set(transformation))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        transformation = []\\n        for word in words:\\n            temp = []\\n            for char in word:\\n                temp.append(morse[ord(char)-97])\\n            transformation.append(\\'\\'.join(temp))\\n        return len(set(transformation))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128738,
                "title": "declarative-javascript",
                "content": "Doesn\\'t get better than a good\\'ole map.reduce and JSON\\n\\n```\\nvar morse = {\\n    a: \".-\",\\n    b: \"-...\",\\n    c: \"-.-.\",\\n    d: \"-..\",\\n    e: \".\",\\n    f: \"..-.\",\\n    g: \"--.\",\\n    h: \"....\",\\n    i: \"..\",\\n    j: \".---\",\\n    k: \"-.-\",\\n    l: \".-..\",\\n    m: \"--\",\\n    n: \"-.\",\\n    o: \"---\",\\n    p: \".--.\",\\n    q: \"--.-\",\\n    r: \".-.\",\\n    s: \"...\",\\n    t: \"-\",\\n    u: \"..-\",\\n    v: \"...-\",\\n    w: \".--\",\\n    x: \"-..-\",\\n    y: \"-.--\",\\n    z: \"--..\"\\n}\\n\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n    const transformWord = (word) => Array.from(word).reduce((acc, char) => acc + morse[char], \\'\\')\\n    const addToSet = (set, word) => set.add(word)\\n    \\n    return words.map(transformWord).reduce(addToSet, new Set([])).size    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar morse = {\\n    a: \".-\",\\n    b: \"-...\",\\n    c: \"-.-.\",\\n    d: \"-..\",\\n    e: \".\",\\n    f: \"..-.\",\\n    g: \"--.\",\\n    h: \"....\",\\n    i: \"..\",\\n    j: \".---\",\\n    k: \"-.-\",\\n    l: \".-..\",\\n    m: \"--\",\\n    n: \"-.\",\\n    o: \"---\",\\n    p: \".--.\",\\n    q: \"--.-\",\\n    r: \".-.\",\\n    s: \"...\",\\n    t: \"-\",\\n    u: \"..-\",\\n    v: \"...-\",\\n    w: \".--\",\\n    x: \"-..-\",\\n    y: \"-.--\",\\n    z: \"--..\"\\n}\\n\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n    const transformWord = (word) => Array.from(word).reduce((acc, char) => acc + morse[char], \\'\\')\\n    const addToSet = (set, word) => set.add(word)\\n    \\n    return words.map(transformWord).reduce(addToSet, new Set([])).size    \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846821,
                "title": "simple-easy-solution-beats-99-30-ms-accepted",
                "content": "# Code\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, x: List[str]) -> int:\\n        a=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set([\"\".join([a[ord(i)-97] for i in j]) for j in x]))\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, x: List[str]) -> int:\\n        a=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set([\"\".join([a[ord(i)-97] for i in j]) for j in x]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649613,
                "title": "simple-understandable-solution-python-code",
                "content": "# Approach\\n- Convert each word in words array to its corresponding encrypted text\\n- Check if the encrypted text is present in transformations array/list or not\\n- If not present then add it\\n- Finally return the total number of transformations present\\n\\n# Do Upvote if u like it :)\\n\\n# Code\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        cipher_txt = \\'\\'\\n        transformations = []\\n\\n        if len(words) == 0:\\n            return 0\\n        \\n        for word in words:\\n            for alpha in word:\\n                cipher_txt = cipher_txt + morse[ord(alpha) - 97]\\n\\n            if cipher_txt not in transformations:\\n                transformations.append(cipher_txt)\\n\\n            cipher_txt = \\'\\'\\n        \\n        return len(transformations)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        cipher_txt = \\'\\'\\n        transformations = []\\n\\n        if len(words) == 0:\\n            return 0\\n        \\n        for word in words:\\n            for alpha in word:\\n                cipher_txt = cipher_txt + morse[ord(alpha) - 97]\\n\\n            if cipher_txt not in transformations:\\n                transformations.append(cipher_txt)\\n\\n            cipher_txt = \\'\\'\\n        \\n        return len(transformations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098442,
                "title": "easiest-approach-c-hasing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> hash={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string>unique;\\n        for(int i=0;i<words.size();i++){\\n            string temp=\"\";\\n            for(int j=0;j<words[i].length();j++){\\n                temp+=hash[words[i][j]-97];\\n            }\\n            unique.insert(temp);\\n        }\\n        return unique.size();\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> hash={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string>unique;\\n        for(int i=0;i<words.size();i++){\\n            string temp=\"\";\\n            for(int j=0;j<words[i].length();j++){\\n                temp+=hash[words[i][j]-97];\\n            }\\n            unique.insert(temp);\\n        }\\n        return unique.size();\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796304,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nk) k->word length.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    String[] morseCode = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    public int uniqueMorseRepresentations(String[] words) {\\n       Set<String> code=new HashSet<>();\\n   \\n\\n       for(String word:words){\\n           StringBuilder sb=new StringBuilder();\\n\\n           for(char c:word.toCharArray()){\\n               int index=c-\\'a\\';\\n               sb.append(morseCode[index]);\\n\\n           }\\n           code.add(sb.toString());\\n       }\\n       \\n       return code.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String[] morseCode = new String[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    public int uniqueMorseRepresentations(String[] words) {\\n       Set<String> code=new HashSet<>();\\n   \\n\\n       for(String word:words){\\n           StringBuilder sb=new StringBuilder();\\n\\n           for(char c:word.toCharArray()){\\n               int index=c-\\'a\\';\\n               sb.append(morseCode[index]);\\n\\n           }\\n           code.add(sb.toString());\\n       }\\n       \\n       return code.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621809,
                "title": "python3-best-solution-o-n-k-where-k-is-a-max-length-of-string",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        s =set()\\n        for word in words:\\n            string = \"\"\\n            for ele in word:\\n                string+=arr[ord(ele)-97]\\n            s.add(string)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        s =set()\\n        for word in words:\\n            string = \"\"\\n            for ele in word:\\n                string+=arr[ord(ele)-97]\\n            s.add(string)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544285,
                "title": "js-best-solution-with-hashmap-100",
                "content": "```\\nconst CONFIG = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    let output = 0;\\n    const hashmap = {};\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        let code = \\'\\';\\n        for (let j = 0; j < word.length; j++) {\\n            code += CONFIG[word.charCodeAt(j) - 97];\\n        }\\n        \\n        if (hashmap[code] === undefined) {\\n            output++;\\n            hashmap[code] = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst CONFIG = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n\\nvar uniqueMorseRepresentations = function(words) {\\n    let output = 0;\\n    const hashmap = {};\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        let code = \\'\\';\\n        for (let j = 0; j < word.length; j++) {\\n            code += CONFIG[word.charCodeAt(j) - 97];\\n        }\\n        \\n        if (hashmap[code] === undefined) {\\n            output++;\\n            hashmap[code] = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2443616,
                "title": "short-c-best-method",
                "content": "Here is the short code:\\n \\n int uniqueMorseRepresentations(vector<string>& words) {\\n\\t\\t\\tset<string> se;\\n\\t\\t\\tvector<string> v={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t\\tfor(int i=0;i<words.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring s=\"\";\\n\\t\\t\\t\\tfor(int j=0;j<words[i].length();j++) s+=v[words[i][j]-\\'a\\'];\\n\\t\\t\\t\\tse.insert(s);\\n\\t\\t\\t}\\n\\t\\t\\treturn se.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "Here is the short code:\\n \\n int uniqueMorseRepresentations(vector<string>& words) {\\n\\t\\t\\tset<string> se;\\n\\t\\t\\tvector<string> v={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t\\tfor(int i=0;i<words.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring s=\"\";\\n\\t\\t\\t\\tfor(int j=0;j<words[i].length();j++) s+=v[words[i][j]-\\'a\\'];\\n\\t\\t\\t\\tse.insert(s);\\n\\t\\t\\t}\\n\\t\\t\\treturn se.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2439894,
                "title": "easy-peasy-solution-in-python",
                "content": "\\tclass Solution:\\n\\t\\tdef uniqueMorseRepresentations(self, words) -> int:\\n\\n\\t\\t\\tans = set()\\n\\t\\t\\ttrans = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}\\n\\n\\t\\t\\tfor i in words:\\n\\t\\t\\t\\ttemp = \\'\\'\\n\\t\\t\\t\\tfor j in i:\\n\\t\\t\\t\\t\\ttemp += trans[j]\\n\\t\\t\\t\\tans.add(temp)\\n\\n\\t\\t\\treturn len(ans)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef uniqueMorseRepresentations(self, words) -> int:\\n\\n\\t\\t\\tans = set()\\n\\t\\t\\ttrans = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\", \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 2438990,
                "title": "for-beginners-java-using-set-only",
                "content": "```\\nclass Solution {\\n    public String []check;\\n    public int uniqueMorseRepresentations(String[] words) {\\n        check = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String> set = new HashSet<String>();\\n        for(String temp : words) set.add(helper(temp));\\n        return set.size();\\n    }\\n    public String helper(String word){\\n        String ans = \"\";\\n        for(int i = 0; i < word.length(); i++) ans += check[(int)word.charAt(i) - \\'a\\'];\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String []check;\\n    public int uniqueMorseRepresentations(String[] words) {\\n        check = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 2437862,
                "title": "1-liner-python-solution",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        translate = {\\'\\'.join([morse[ord(c)-97] for c in word]) for word in words}\\n        return len(translate)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        translate = {\\'\\'.join([morse[ord(c)-97] for c in word]) for word in words}\\n        return len(translate)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437777,
                "title": "easy-and-100-faster-0ms",
                "content": "We traverse through the vector and for each word, we convert it to morse directly using the array we are given in the question. \\nInsert this new string into set so there are no repeatitions in them. \\nThe size of this set is the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> st;\\n        const char* morse[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for(auto word:words){\\n            string ans=\"\";\\n            for(auto ch:word)\\n                ans+=morse[ch-\\'a\\'];\\n            st.insert(ans);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> st;\\n        const char* morse[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for(auto word:words){\\n            string ans=\"\";\\n            for(auto ch:word)\\n                ans+=morse[ch-\\'a\\'];\\n            st.insert(ans);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437699,
                "title": "c-modular-code-0ms-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/02569a9b-b09e-41aa-a8cc-3d08a2e27772_1660717258.9231017.png)\\n```\\nstring arr[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    string string_to_morse(string s){\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            temp+=arr[s[i]-97];\\n        }\\n        return temp;\\n    }\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            st.insert(string_to_morse(words[i]));\\n        }\\n        return st.size();\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/02569a9b-b09e-41aa-a8cc-3d08a2e27772_1660717258.9231017.png)\\n```\\nstring arr[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    string string_to_morse(string s){\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            temp+=arr[s[i]-97];\\n        }\\n        return temp;\\n    }\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            st.insert(string_to_morse(words[i]));\\n        }\\n        return st.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2437571,
                "title": "java-solution-easy-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Map<Character, String> res = new HashMap<>();\\n        res.put(\\'a\\', \".-\"); res.put(\\'b\\', \"-...\"); res.put(\\'c\\', \"-.-.\"); res.put(\\'d\\', \"-..\"); res.put(\\'e\\', \".\");           res.put(\\'f\\', \"..-.\");res.put(\\'g\\', \"--.\"); res.put(\\'h\\', \"....\"); res.put(\\'i\\', \"..\"); res.put(\\'j\\', \".---\");         res.put(\\'k\\', \"-.-\"); res.put(\\'l\\', \".-..\"); res.put(\\'m\\', \"--\"); res.put(\\'n\\', \"-.\"); res.put(\\'o\\', \"---\");\\n        res.put(\\'p\\', \".--.\"); res.put(\\'q\\', \"--.-\"); res.put(\\'r\\', \".-.\"); res.put(\\'s\\', \"...\"); res.put(\\'t\\', \"-\");\\n        res.put(\\'u\\', \"..-\"); res.put(\\'v\\', \"...-\"); res.put(\\'w\\', \".--\"); res.put(\\'x\\', \"-..-\");\\n        res.put(\\'y\\', \"-.--\"); res.put(\\'z\\', \"--..\");\\n        Set<String> set = new HashSet<>();\\n        int count = 0;\\n        for(String word : words){\\n            String str = \"\";\\n            for(char ch : word.toCharArray()){\\n                str = str + res.get(ch);\\n            }\\n            if(!set.contains(str)){\\n                set.add(str);\\n                count ++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Map<Character, String> res = new HashMap<>();\\n        res.put(\\'a\\', \".-\"); res.put(\\'b\\', \"-...\"); res.put(\\'c\\', \"-.-.\"); res.put(\\'d\\', \"-..\"); res.put(\\'e\\', \".\");           res.put(\\'f\\', \"..-.\");res.put(\\'g\\', \"--.\"); res.put(\\'h\\', \"....\"); res.put(\\'i\\', \"..\"); res.put(\\'j\\', \".---\");         res.put(\\'k\\', \"-.-\"); res.put(\\'l\\', \".-..\"); res.put(\\'m\\', \"--\"); res.put(\\'n\\', \"-.\"); res.put(\\'o\\', \"---\");\\n        res.put(\\'p\\', \".--.\"); res.put(\\'q\\', \"--.-\"); res.put(\\'r\\', \".-.\"); res.put(\\'s\\', \"...\"); res.put(\\'t\\', \"-\");\\n        res.put(\\'u\\', \"..-\"); res.put(\\'v\\', \"...-\"); res.put(\\'w\\', \".--\"); res.put(\\'x\\', \"-..-\");\\n        res.put(\\'y\\', \"-.--\"); res.put(\\'z\\', \"--..\");\\n        Set<String> set = new HashSet<>();\\n        int count = 0;\\n        for(String word : words){\\n            String str = \"\";\\n            for(char ch : word.toCharArray()){\\n                str = str + res.get(ch);\\n            }\\n            if(!set.contains(str)){\\n                set.add(str);\\n                count ++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437556,
                "title": "easy-to-understand-java-solution-using-hashset-faster-than-99-55",
                "content": "**Please Upvote if you like my approach**\\n\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] chart = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> count = new HashSet();\\n        for (String word : words) {\\n            StringBuilder code = new StringBuilder();\\n            for (char c : word.toCharArray())\\n             code.append(chart[c - \\'a\\']);\\n             count.add(code.toString());\\n        }\\n        return count.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] chart = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> count = new HashSet();\\n        for (String word : words) {\\n            StringBuilder code = new StringBuilder();\\n            for (char c : word.toCharArray())\\n             code.append(chart[c - \\'a\\']);\\n             count.add(code.toString());\\n        }\\n        return count.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437442,
                "title": "c-easy-approach-simple-to-understand-beginner-friendly",
                "content": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> output;\\n        for(auto i : words)\\n        {\\n            string s = \"\";\\n            for(int j : i) s += morse[j-97];\\n            output.insert(s);\\n        }\\n        return output.size();\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> output;\\n        for(auto i : words)\\n        {\\n            string s = \"\";\\n            for(int j : i) s += morse[j-97];\\n            output.insert(s);\\n        }\\n        return output.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436772,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                         # Iterate through every word.\\n            m = \\'\\'\\n            for l in w:                         # Iterate through every letter in current word.\\n                m += mos[ord(l) - ord(\\'a\\')]     # Change the letter into morse code.\\n            s.add(m)                            # Use set to avoid replicate answer.\\n        \\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        s = set()\\n        mos = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        for w in words:                         # Iterate through every word.\\n            m = \\'\\'\\n            for l in w:                         # Iterate through every letter in current word.\\n                m += mos[ord(l) - ord(\\'a\\')]     # Change the letter into morse code.\\n            s.add(m)                            # Use set to avoid replicate answer.\\n        \\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436763,
                "title": "c-solution-0ms-better-than-100-only-sets-8-lines-comments",
                "content": "![image](https://assets.leetcode.com/users/images/8ceda11d-fd93-4cae-b2d1-304f63a67f15_1660703125.0653307.png)\\n\\n```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n\\tset<string> s;\\n\\t\\n\\t// we map with vector as 0 based indexing for chars, {\\'a\\', \".-\"}, {\\'b\\', \"-...\"}.....\\n\\tvector<string> vec ={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\tstring st;\\n\\t\\n\\t// then we traverse the string and for each characters from the word, \\n\\t// we get its morse code and add it to the set\\n\\tfor(int i=0; i<words.size(); i++){\\n\\t\\tst = \"\";\\n\\t\\tfor(int j=0; j<words[i].length(); j++)\\n\\t\\t\\tst+=vec[words[i][j]-\\'a\\'];\\n\\t\\t\\t\\n\\t\\t// then we add this string to the set, and continue for all the words\\n\\t\\ts.insert(st);\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n\\tset<string> s;\\n\\t\\n\\t// we map with vector as 0 based indexing for chars, {\\'a\\', \".-\"}, {\\'b\\', \"-...\"}.....\\n\\tvector<string> vec ={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\tstring st;\\n\\t\\n\\t// then we traverse the string and for each characters from the word, \\n\\t// we get its morse code and add it to the set\\n\\tfor(int i=0; i<words.size(); i++){\\n\\t\\tst = \"\";\\n\\t\\tfor(int j=0; j<words[i].length(); j++)\\n\\t\\t\\tst+=vec[words[i][j]-\\'a\\'];\\n\\t\\t\\t\\n\\t\\t// then we add this string to the set, and continue for all the words\\n\\t\\ts.insert(st);\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436736,
                "title": "0ms-with-go-map-string-builder",
                "content": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n    wordSet := make(map[string]struct{})\\n    \\n    alphabet := []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n    \\n    for i := 0; i < len(words); i++ {\\n        var currentWord strings.Builder\\n        \\n        for j := 0; j < len(words[i]); j++ {\\n            currentWord.WriteString(alphabet[words[i][j] - \\'a\\'])\\n        }\\n        \\n        if _, ok := wordSet[currentWord.String()]; !ok {\\n            wordSet[currentWord.String()] = struct{}{}\\n        }\\n    }\\n    \\n    return len(wordSet)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String"
                ],
                "code": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n    wordSet := make(map[string]struct{})\\n    \\n    alphabet := []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n    \\n    for i := 0; i < len(words); i++ {\\n        var currentWord strings.Builder\\n        \\n        for j := 0; j < len(words[i]); j++ {\\n            currentWord.WriteString(alphabet[words[i][j] - \\'a\\'])\\n        }\\n        \\n        if _, ok := wordSet[currentWord.String()]; !ok {\\n            wordSet[currentWord.String()] = struct{}{}\\n        }\\n    }\\n    \\n    return len(wordSet)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436566,
                "title": "js-set-easy-solution-in-3-lines",
                "content": "## **TL-DR:** Three variations of solution\\n\\n![image](https://assets.leetcode.com/users/images/a5d97667-f9a5-4974-8339-f0528f10ce5f_1660699065.9906268.png)\\n\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n\\tconst morseCode = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n    const morseRepresentation = word => word.split(\\'\\').map(c => morseCode[c]).join(\\'\\');\\n    \\n    return new Set(words.map(morseRepresentation)).size;\\n};\\n```\\n\\n---\\n\\n## **First** acceptance\\n\\nAt beginning, I was using a `reduce()` function to insert each transformation into the set at time:\\n\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    return words.reduce((set, w) => set.add(transform(w)), new Set()).size;\\n    \\n    function transform(word) {\\n        const morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return word.split(\\'\\').map(c => morse[c.charCodeAt() - \\'a\\'.charCodeAt()]).join(\\'\\');\\n    }\\n};\\n```\\n\\n---\\n\\n## **Cleaner way** to use `Set()`\\n\\nAs the [Set() constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/Set/) accepts any [iterable object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) as argument, we can achieve the same result in a better way.\\n\\nEven it would be possible to have a solution in one single line - as we can see at [@acupoftee\\'s great one line solution](https://leetcode.com/problems/unique-morse-code-words/discuss/329303/JavaScript-One-Line-Solution-w-Explanation-(52-ms-beats-94)) - keeping the `transform(word)` function helps to have a lot cleaner solution:\\n\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    \\n    return new Set(words.map(transformWord)).size;\\n    \\n    function transformWord (word) {\\n        return word.split(\\'\\').map(c => morse[c.charCodeAt() - \\'a\\'.charCodeAt()]).join(\\'\\');\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fed24540-1ab1-4be6-b9e5-bb9e665cd5ce_1660697627.3583236.png)\\n\\n---\\n\\n## **Best approach** using *hash table* to keep values\\n\\nFinally, a last improvement that can be made is to use an *hash table* instead of using the *Array* structure given at problem statement.\\n\\nIt will not just make it easier to read and simpler to code, but also will be a lot more efficient, as it will not be necessary any more to make the *maths* and function calls involving ASCII code to find the correct index for morse representations: \\n\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n\\tconst morse = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n    const transformWord = word => word.split(\\'\\').map(c => morse[c]).join(\\'\\');\\n    \\n    return new Set(words.map(transformWord)).size;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a5d97667-f9a5-4974-8339-f0528f10ce5f_1660699065.9906268.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n\\tconst morseCode = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n    const morseRepresentation = word => word.split(\\'\\').map(c => morseCode[c]).join(\\'\\');\\n    \\n    return new Set(words.map(morseRepresentation)).size;\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    return words.reduce((set, w) => set.add(transform(w)), new Set()).size;\\n    \\n    function transform(word) {\\n        const morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return word.split(\\'\\').map(c => morse[c.charCodeAt() - \\'a\\'.charCodeAt()]).join(\\'\\');\\n    }\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    \\n    return new Set(words.map(transformWord)).size;\\n    \\n    function transformWord (word) {\\n        return word.split(\\'\\').map(c => morse[c.charCodeAt() - \\'a\\'.charCodeAt()]).join(\\'\\');\\n    }\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n\\tconst morse = { a: \".-\", b: \"-...\", c: \"-.-.\", d: \"-..\", e: \".\", f: \"..-.\", g: \"--.\", h: \"....\", i: \"..\", j: \".---\", k: \"-.-\", l: \".-..\", m: \"--\", n: \"-.\", o: \"---\", p: \".--.\", q: \"--.-\", r: \".-.\", s: \"...\", t: \"-\", u: \"..-\", v: \"...-\", w: \".--\", x: \"-..-\", y: \"-.--\", z: \"--..\" }\\n    const transformWord = word => word.split(\\'\\').map(c => morse[c]).join(\\'\\');\\n    \\n    return new Set(words.map(transformWord)).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2280241,
                "title": "c-solution-time-o-n-beats-99",
                "content": "```C#\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n        string[] code = new [] { \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\" };\\n        \\n        HashSet<string> h = new HashSet<string>();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.Length; i++) {\\n            for (int j = 0; j < words[i].Length; j++) sb.Append(code[words[i][j] - \\'a\\']);\\n            h.Add(sb.ToString());\\n            sb.Clear();\\n        }\\n        \\n        return h.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int UniqueMorseRepresentations(string[] words) {\\n        string[] code = new [] { \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\" };\\n        \\n        HashSet<string> h = new HashSet<string>();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.Length; i++) {\\n            for (int j = 0; j < words[i].Length; j++) sb.Append(code[words[i][j] - \\'a\\']);\\n            h.Add(sb.ToString());\\n            sb.Clear();\\n        }\\n        \\n        return h.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901444,
                "title": "easy-c-solution-beginner-friendly",
                "content": "unordered_set<string> st;\\n        string arr[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            string str=\"\";\\n            for(int i=0;i<temp.size();i++)\\n                str+=arr[temp[i]-\\'a\\'];\\n            \\n            st.insert(str);\\n        }\\n        return st.size();",
                "solutionTags": [
                    "C"
                ],
                "code": "unordered_set<string> st;\\n        string arr[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            string str=\"\";\\n            for(int i=0;i<temp.size();i++)\\n                str+=arr[temp[i]-\\'a\\'];\\n            \\n            st.insert(str);\\n        }\\n        return st.size();",
                "codeTag": "Unknown"
            },
            {
                "id": 1610931,
                "title": "one-line-solution-new-set",
                "content": "```\\nconst uniqueMorseRepresentations = (words) => {\\n  const code = [\\'.-\\', \\'-...\\', \\'-.-.\\', \\'-..\\', \\'.\\', \\'..-.\\', \\'--.\\', \\'....\\', \\'..\\', \\'.---\\', \\'-.-\\', \\'.-..\\', \\'--\\', \\'-.\\', \\'---\\', \\'.--.\\', \\'--.-\\', \\'.-.\\', \\'...\\', \\'-\\', \\'..-\\', \\'...-\\', \\'.--\\', \\'-..-\\', \\'-.--\\', \\'--..\\'];\\n\\n  return new Set(words.map((word) => [...word].map((char) => code[char.charCodeAt() - 97]).join(\\'\\'))).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst uniqueMorseRepresentations = (words) => {\\n  const code = [\\'.-\\', \\'-...\\', \\'-.-.\\', \\'-..\\', \\'.\\', \\'..-.\\', \\'--.\\', \\'....\\', \\'..\\', \\'.---\\', \\'-.-\\', \\'.-..\\', \\'--\\', \\'-.\\', \\'---\\', \\'.--.\\', \\'--.-\\', \\'.-.\\', \\'...\\', \\'-\\', \\'..-\\', \\'...-\\', \\'.--\\', \\'-..-\\', \\'-.--\\', \\'--..\\'];\\n\\n  return new Set(words.map((word) => [...word].map((char) => code[char.charCodeAt() - 97]).join(\\'\\'))).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1088637,
                "title": "java-simple-easy-to-understand",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Unique Morse Code Words.\\nMemory Usage: 37.2 MB, less than 56.75% of Java online submissions for Unique Morse Code Words.\\n```\\npublic int uniqueMorseRepresentations(String[] words) {\\n    String[] arr = new String[]{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n    Set<String> set = new HashSet<>();\\n    for (String s : words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : s.toCharArray()) sb.append(arr[ch - \\'a\\']);\\n        set.add(sb.toString());\\n    }\\n\\n    return set.size();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int uniqueMorseRepresentations(String[] words) {\\n    String[] arr = new String[]{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n    Set<String> set = new HashSet<>();\\n    for (String s : words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch : s.toCharArray()) sb.append(arr[ch - \\'a\\']);\\n        set.add(sb.toString());\\n    }\\n\\n    return set.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 944902,
                "title": "python-simplest-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        res = set()\\n        for word in words:\\n            curr = \"\"\\n            for char in word:\\n                curr += codes[ord(char)-97]\\n            res.add(curr)\\n        return len(res)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        res = set()\\n        for word in words:\\n            curr = \"\"\\n            for char in word:\\n                curr += codes[ord(char)-97]\\n            res.add(curr)\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790324,
                "title": "c-faster-than-100-custom-trie",
                "content": "Idea is to get rid of set,because its expensive translation from string to hashcode,and also we store each string of group where most of them is similar.\\n\\nI get this trie code from geeks,and modify it to have only 2 childs,and to count string we have not previously\\n\\nUpvote if you like it.\\n\\nMy first solution with set was faster than 67%\\n\\n\\n```\\n#define CHAR_SIZE 2\\n\\nint n = 0;\\n\\nclass Trie {\\npublic:\\n\\tbool isLeaf;\\n\\tTrie* character[CHAR_SIZE];\\n\\n\\tTrie()\\n\\t{\\n\\t\\tthis->isLeaf = false;\\n\\t\\tfor (int i = 0; i < CHAR_SIZE; i++)\\n\\t\\t\\tthis->character[i] = nullptr;\\n\\t}\\n\\n\\tvoid insert(std::string);\\n};\\n\\nvoid Trie::insert(std::string key) {\\n\\tTrie* curr = this;\\n\\tfor (int i = 0; i < key.length(); i++) {\\n        int k = key[i]==\\'.\\'?0:1;\\n\\t\\tif (curr->character[k] == nullptr)\\n\\t\\t\\tcurr->character[k] = new Trie();\\n\\t\\t\\n\\t\\tcurr = curr->character[k];\\n\\t}\\n\\tif (!curr->isLeaf) n++;\\n    curr->isLeaf = true;\\n}\\n\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        n = 0;\\n        Trie* root = new Trie();\\n        string morse[26] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for (string& s:words) {\\n            string mapped;\\n            for (char c:s) {\\n                mapped += morse[c-\\'a\\'];\\n            }\\n            root->insert(mapped);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define CHAR_SIZE 2\\n\\nint n = 0;\\n\\nclass Trie {\\npublic:\\n\\tbool isLeaf;\\n\\tTrie* character[CHAR_SIZE];\\n\\n\\tTrie()\\n\\t{\\n\\t\\tthis->isLeaf = false;\\n\\t\\tfor (int i = 0; i < CHAR_SIZE; i++)\\n\\t\\t\\tthis->character[i] = nullptr;\\n\\t}\\n\\n\\tvoid insert(std::string);\\n};\\n\\nvoid Trie::insert(std::string key) {\\n\\tTrie* curr = this;\\n\\tfor (int i = 0; i < key.length(); i++) {\\n        int k = key[i]==\\'.\\'?0:1;\\n\\t\\tif (curr->character[k] == nullptr)\\n\\t\\t\\tcurr->character[k] = new Trie();\\n\\t\\t\\n\\t\\tcurr = curr->character[k];\\n\\t}\\n\\tif (!curr->isLeaf) n++;\\n    curr->isLeaf = true;\\n}\\n\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        n = 0;\\n        Trie* root = new Trie();\\n        string morse[26] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for (string& s:words) {\\n            string mapped;\\n            for (char c:s) {\\n                mapped += morse[c-\\'a\\'];\\n            }\\n            root->insert(mapped);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536145,
                "title": "c-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> dict{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"} ;\\n        \\n        set<string> set ;\\n        \\n        for( int i=0 ; i<words.size() ; i++ ){\\n            int word_size = words[i].length() ;\\n            string res = \"\" ;\\n            for( int j=0 ; j<word_size ; j++ ){\\n                res = res + dict[words[i][j]-\\'a\\'] ;\\n            }\\n            set.insert(res) ;\\n        }\\n        \\n        return set.size() ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> dict{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"} ;\\n        \\n        set<string> set ;\\n        \\n        for( int i=0 ; i<words.size() ; i++ ){\\n            int word_size = words[i].length() ;\\n            string res = \"\" ;\\n            for( int j=0 ; j<word_size ; j++ ){\\n                res = res + dict[words[i][j]-\\'a\\'] ;\\n            }\\n            set.insert(res) ;\\n        }\\n        \\n        return set.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322913,
                "title": "simple-python-solution-beats-99-83-time-83-96-space",
                "content": "```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        letters = \"abcdefghijklmnopqrstuvwxyz\"\\n        encodings = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\t\\t\\n\\t\\t# map letter to encoding\\n        map = dict()\\n        for letter, encoding in zip(letters,encodings):\\n            map[letter] = encoding\\n           \\n\\t\\t# for each word given, translate to Morse code using lookup table \\n        for i in range(len(words)):\\n            words[i] = \"\".join([map[c] for c in words[i]])\\n        \\n\\t\\t# count distinct encodings\\n        return len(set(words))\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        letters = \"abcdefghijklmnopqrstuvwxyz\"\\n        encodings = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\t\\t\\n\\t\\t# map letter to encoding\\n        map = dict()\\n        for letter, encoding in zip(letters,encodings):\\n            map[letter] = encoding\\n           \\n\\t\\t# for each word given, translate to Morse code using lookup table \\n        for i in range(len(words)):\\n            words[i] = \"\".join([map[c] for c in words[i]])\\n        \\n\\t\\t# count distinct encodings\\n        return len(set(words))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242518,
                "title": "c-easy-to-understand",
                "content": "```\\nint uniqueMorseRepresentations(char** words, int wordsSize) {\\n\\t\\tchar comp[26][6]={\".-\", \"-...\" , \"-.-.\", \"-..\", \".\" ,\"..-.\", \"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    char str1[100],str2[100][100],str3[100];\\n    int i,j,k,l,unique,found;\\n    found=unique=k=0;\\n    for(i=0;i<wordsSize;i++){\\n    \\tstrcpy(str3,\"\");\\n    \\tstrcpy(str1,words[i]);\\n    \\t\\n\\t\\t    for(j=0;j<strlen(str1);j++){\\n    \\t\\tstrcat(str3,comp[str1[j]-\\'a\\']);           //\\u5B57\\u7B26\\u4E32\\u540E\\u8FFD\\u52A0\\u65B0\\u5B57\\u7B26\\u4E32 \\n\\t\\t}\\n\\t\\tfor(l=0;l<unique;l++){\\n\\t\\tif(strcmp(str2[l],str3)==0){\\n\\t\\tfound=1;\\n\\t\\tbreak;}\\n\\t\\t}\\n\\t\\tif(found==0)\\n\\t\\tstrcpy(str2[unique++],str3);\\n\\t\\tfound=0;\\n\\t}\\n\\treturn unique;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint uniqueMorseRepresentations(char** words, int wordsSize) {\\n\\t\\tchar comp[26][6]={\".-\", \"-...\" , \"-.-.\", \"-..\", \".\" ,\"..-.\", \"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    char str1[100],str2[100][100],str3[100];\\n    int i,j,k,l,unique,found;\\n    found=unique=k=0;\\n    for(i=0;i<wordsSize;i++){\\n    \\tstrcpy(str3,\"\");\\n    \\tstrcpy(str1,words[i]);\\n    \\t\\n\\t\\t    for(j=0;j<strlen(str1);j++){\\n    \\t\\tstrcat(str3,comp[str1[j]-\\'a\\']);           //\\u5B57\\u7B26\\u4E32\\u540E\\u8FFD\\u52A0\\u65B0\\u5B57\\u7B26\\u4E32 \\n\\t\\t}\\n\\t\\tfor(l=0;l<unique;l++){\\n\\t\\tif(strcmp(str2[l],str3)==0){\\n\\t\\tfound=1;\\n\\t\\tbreak;}\\n\\t\\t}\\n\\t\\tif(found==0)\\n\\t\\tstrcpy(str2[unique++],str3);\\n\\t\\tfound=0;\\n\\t}\\n\\treturn unique;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224779,
                "title": "rust-concise-solution-0ms",
                "content": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    const morse : [&\\'static str; 26] = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        HashSet::<String>::from_iter(words.iter()\\n                                          .map(|w| w.chars()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    .map(|c| Solution::morse[(c as usize) - (\\'a\\' as usize)])\\n                                                    .collect::<String>())).len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    const morse : [&\\'static str; 26] = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        HashSet::<String>::from_iter(words.iter()\\n                                          .map(|w| w.chars()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    .map(|c| Solution::morse[(c as usize) - (\\'a\\' as usize)])\\n                                                    .collect::<String>())).len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 223445,
                "title": "java-5ms-faster-than-94",
                "content": "```\\nclass solutaion{\\n\\tpublic int uniqueMorseRepresentations(String[] words) {\\n\\t\\tString letters=\"abcdefghijklmnopqrstuvwxyz\";\\n        String[] morse={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> s1=new HashSet<>();\\n        for (String word : words) {\\n            String str=\"\";\\n           int num=word.length();\\n            for(int i=0;i<num;i++) {\\n                str=str+morse[letters.indexOf(word.charAt(i))];\\n            }\\n            s1.add(str);\\n        }\\n        return s1.size(); \\n\\t  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass solutaion{\\n\\tpublic int uniqueMorseRepresentations(String[] words) {\\n\\t\\tString letters=\"abcdefghijklmnopqrstuvwxyz\";\\n        String[] morse={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> s1=new HashSet<>();\\n        for (String word : words) {\\n            String str=\"\";\\n           int num=word.length();\\n            for(int i=0;i<num;i++) {\\n                str=str+morse[letters.indexOf(word.charAt(i))];\\n            }\\n            s1.add(str);\\n        }\\n        return s1.size(); \\n\\t  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217697,
                "title": "runtime-0-ms-faster-than-100-00-of-go-online-submissions-for-unique-morse-code-words",
                "content": "```\\nvar morseCodes []string = []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n\\n\\nfunc uniqueMorseRepresentations(words []string) int {\\n    transformations := make(map[string]int)\\n\\n    for _, word := range words {\\n\\t    var sb strings.Builder\\n\\t\\n\\t    for _, char := range []byte(word) {\\n\\t\\t    sb.WriteString(morseCodes[char - 97])\\t\\n\\t    }\\n\\t\\n\\t    transformations[sb.String()]++\\n    }\\n\\n    return len(transformations)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar morseCodes []string = []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n\\n\\nfunc uniqueMorseRepresentations(words []string) int {\\n    transformations := make(map[string]int)\\n\\n    for _, word := range words {\\n\\t    var sb strings.Builder\\n\\t\\n\\t    for _, char := range []byte(word) {\\n\\t\\t    sb.WriteString(morseCodes[char - 97])\\t\\n\\t    }\\n\\t\\n\\t    transformations[sb.String()]++\\n    }\\n\\n    return len(transformations)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 214221,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        \\n        let morse_codes = vec![\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n        \\n        let mut morse_set = HashSet::new();\\n        for word in &words{\\n            let mut temp_str : String = \"\".into();\\n            let mut chars = word.chars();\\n            let mut each_char = chars.next();\\n            loop {\\n                match each_char {\\n                    Some(x) => temp_str.push_str(morse_codes[(x as u8 - 97) as usize]),\\n                    None => break,\\n                }\\n             each_char = chars.next();\\n            }\\n            morse_set.insert(temp_str);\\n        }\\n        return morse_set.len() as i32;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n        \\n        let morse_codes = vec![\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n        \\n        let mut morse_set = HashSet::new();\\n        for word in &words{\\n            let mut temp_str : String = \"\".into();\\n            let mut chars = word.chars();\\n            let mut each_char = chars.next();\\n            loop {\\n                match each_char {\\n                    Some(x) => temp_str.push_str(morse_codes[(x as u8 - 97) as usize]),\\n                    None => break,\\n                }\\n             each_char = chars.next();\\n            }\\n            morse_set.insert(temp_str);\\n        }\\n        return morse_set.len() as i32;\\n    }\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200334,
                "title": "python-2-lines",
                "content": "```\\nclass Solution:\\n    \\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set([\\n            \\'\\'.join([morse[ord(c)-ord(\\'a\\')] for c in word]) \\n            for word in words\\n        ]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set([\\n            \\'\\'.join([morse[ord(c)-ord(\\'a\\')] for c in word]) \\n            for word in words\\n        ]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194241,
                "title": "simple-javascript-solution",
                "content": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    var trans = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    return new Set(words.map((ele, idx) => {\\n       return ele.split(\\'\\').map((item, i) => {\\n            return trans[ele.charCodeAt(i) - \\'a\\'.charCodeAt(0)];\\n        }).join(\\'\\');\\n    })).size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    var trans = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    return new Set(words.map((ele, idx) => {\\n       return ele.split(\\'\\').map((item, i) => {\\n            return trans[ele.charCodeAt(i) - \\'a\\'.charCodeAt(0)];\\n        }).join(\\'\\');\\n    })).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122289,
                "title": "2-line-code-with-java-8-stream",
                "content": "```\\npublic int uniqueMorseRepresentations(String[] words) {\\n        Set<String> res = Arrays.stream(words).map(i -> getMC(i)).collect(Collectors.toSet());\\n        return res.size();\\n    }\\n    private String getMC(String str) {\\n        String[] mCode = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                          \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n                          \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        return str.chars().mapToObj(ch -> mCode[(char)ch % 97]).reduce(\"\", String::concat);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int uniqueMorseRepresentations(String[] words) {\\n        Set<String> res = Arrays.stream(words).map(i -> getMC(i)).collect(Collectors.toSet());\\n        return res.size();\\n    }\\n    private String getMC(String str) {\\n        String[] mCode = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                          \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n                          \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        return str.chars().mapToObj(ch -> mCode[(char)ch % 97]).reduce(\"\", String::concat);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945955,
                "title": "3-types-solutions-fully-explained-simple-solutions",
                "content": "# **1. \"Mapping and Set\" approach:**\\n# Intuition\\nWe are given a list of words and we need to find the number of unique Morse code representations that can be generated from these words. Each letter of the alphabet corresponds to a specific Morse code pattern. Our goal is to map each word to its Morse code representation and count the number of unique representations.\\n# Approach\\n1. First, we create a mapping of each letter to its Morse code pattern using the symbols object provided in the code.\\n2. For each word in the input words list, we split the word into individual letters and map each letter to its Morse code pattern using the symbols object.\\n3. We join these Morse code patterns for each letter to form the Morse code representation of the entire word.\\n4. We use a Set data structure to store these unique Morse code representations. The Set automatically ensures that only unique representations are stored.\\n5. Finally, we return the size of the Set, which represents the number of unique Morse code representations.\\n# Complexity\\n- Time complexity: `O(n * k)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const symbols = {\\n        a: \\'.-\\',\\n        b: \\'-...\\',\\n        c: \\'-.-.\\',\\n        d: \\'-..\\',\\n        e: \\'.\\',\\n        f: \\'..-.\\',\\n        g: \\'--.\\',\\n        h: \\'....\\',\\n        i: \\'..\\',\\n        j: \\'.---\\',\\n        k: \\'-.-\\',\\n        l: \\'.-..\\',\\n        m: \\'--\\',\\n        n: \\'-.\\',\\n        o: \\'---\\',\\n        p: \\'.--.\\',\\n        q: \\'--.-\\',\\n        r: \\'.-.\\',\\n        s: \\'...\\',\\n        t: \\'-\\',\\n        u: \\'..-\\',\\n        v: \\'...-\\',\\n        w: \\'.--\\',\\n        x: \\'-..-\\',\\n        y: \\'-.--\\',\\n        z: \\'--..\\'\\n    }\\n\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => symbols[letter]).join(\\'\\'))).size;\\n};\\n```\\n\\n\\n---\\n\\n# **2. \"Mapping and Set\" approach:**\\n# Intuition\\nWe are given a list of words and we need to find the number of unique Morse code representations that can be generated from these words. Each letter of the alphabet corresponds to a specific Morse code pattern. Our goal is to map each word to its Morse code representation and count the number of unique representations.\\n# Approach\\n1. An array named symbols holds the Morse code patterns for each letter of the alphabet. The index of each pattern corresponds to the character\\'s position in the alphabet.\\n2. A Set called transformations is initialized to keep track of unique Morse code representations.\\n3. For each word in the words list:\\n    - A temporary string trans is initialized to store the Morse code transformation of the current word.\\n    - For each letter in the word:\\n        - The ASCII code of the letter is subtracted by 97 (ASCII code of \\'a\\') to get the index in the symbols array.\\n        - The Morse code pattern for the letter at that index is added to the trans string.\\n    - The trans string, representing the Morse code transformation of the   current word, is added to the transformations set.\\n4. After processing all words, the size of the transformations set is returned, which represents the number of unique Morse code representations.\\n# Complexity\\n- Time complexity: `O(n * k)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    var symbols = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n                  \"--.\",\"....\",\"..\",\".---\",\\n                  \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                  \".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    var transformations = new Set();\\n    \\n    for (let word of words) {        \\n        var trans = \"\";\\n        for (let letter of word) {\\n            var index = letter.charCodeAt(0) - 97;\\n            trans += symbols[index];\\n        }\\n        \\n        transformations.add(trans);   \\n    }\\n    \\n    return transformations.size;\\n};\\n```\\n---\\n\\n# **3. \"Subarray Transformation and Set\" approach:**\\n# Intuition\\nThis code aims to determine the number of unique Morse code transformations that can be generated from a list of words. Each word is treated as a subarray of characters, and for each character, its Morse code equivalent is appended to a temporary string. The goal is to count the number of unique strings that result from these transformations.\\n# Approach\\n1. The symbols object holds the mapping of letters to their corresponding Morse code patterns, similar to the previous codes.\\n2. A Set named transformations is created to store unique Morse code transformations.\\n3. For each subArr (subarray or word) in the words list:\\n    - A temporary string tempStr is initialized to store the Morse code transformation of the current subarray.\\n    - For each word (character) in the subArr:\\n        - The key is obtained by looking up the symbols object using the word as the key. This retrieves the Morse code pattern corresponding to the current character.\\n        - The Morse code pattern is appended to the tempStr.\\n    - After processing all characters in the subarray, the resulting tempStr represents the Morse code transformation of that subarray.\\n    - The tempStr is added to the transformations set to keep track of unique transformations.\\n4. Once all subarrays have been processed, the function returns the size of the transformations set, which represents the count of unique Morse code transformations.\\n# Complexity\\n- Time complexity: `O(n * k)`\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const symbols = {\\n        a: \\'.-\\',\\n        b: \\'-...\\',\\n        c: \\'-.-.\\',\\n        d: \\'-..\\',\\n        e: \\'.\\',\\n        f: \\'..-.\\',\\n        g: \\'--.\\',\\n        h: \\'....\\',\\n        i: \\'..\\',\\n        j: \\'.---\\',\\n        k: \\'-.-\\',\\n        l: \\'.-..\\',\\n        m: \\'--\\',\\n        n: \\'-.\\',\\n        o: \\'---\\',\\n        p: \\'.--.\\',\\n        q: \\'--.-\\',\\n        r: \\'.-.\\',\\n        s: \\'...\\',\\n        t: \\'-\\',\\n        u: \\'..-\\',\\n        v: \\'...-\\',\\n        w: \\'.--\\',\\n        x: \\'-..-\\',\\n        y: \\'-.--\\',\\n        z: \\'--..\\'\\n    }\\n\\n    let transformations = new Set();\\n\\n    for (let subArr of words) {\\n        let tempStr = \\'\\';\\n        for (let word of subArr) {\\n            let key = symbols[word];\\n            tempStr += key;\\n        }\\n        transformations.add(tempStr);\\n    }\\n    return transformations.size;\\n};\\n```\\n\\n\\n---\\n\\n**Any doubts Comment it!**\\n\\nHappy Coding : )\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/a3814417-9c24-4b25-a61d-9cd994a1b091_1692715864.4624593.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    const symbols = {\\n        a: \\'.-\\',\\n        b: \\'-...\\',\\n        c: \\'-.-.\\',\\n        d: \\'-..\\',\\n        e: \\'.\\',\\n        f: \\'..-.\\',\\n        g: \\'--.\\',\\n        h: \\'....\\',\\n        i: \\'..\\',\\n        j: \\'.---\\',\\n        k: \\'-.-\\',\\n        l: \\'.-..\\',\\n        m: \\'--\\',\\n        n: \\'-.\\',\\n        o: \\'---\\',\\n        p: \\'.--.\\',\\n        q: \\'--.-\\',\\n        r: \\'.-.\\',\\n        s: \\'...\\',\\n        t: \\'-\\',\\n        u: \\'..-\\',\\n        v: \\'...-\\',\\n        w: \\'.--\\',\\n        x: \\'-..-\\',\\n        y: \\'-.--\\',\\n        z: \\'--..\\'\\n    }\\n\\n    return new Set(words.map(word => word.split(\\'\\').map(letter => symbols[letter]).join(\\'\\'))).size;\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    var symbols = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\\n                  \"--.\",\"....\",\"..\",\".---\",\\n                  \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\\n                  \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                  \".--\",\"-..-\",\"-.--\",\"--..\"];\\n    \\n    var transformations = new Set();\\n    \\n    for (let word of words) {        \\n        var trans = \"\";\\n        for (let letter of word) {\\n            var index = letter.charCodeAt(0) - 97;\\n            trans += symbols[index];\\n        }\\n        \\n        transformations.add(trans);   \\n    }\\n    \\n    return transformations.size;\\n};\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    const symbols = {\\n        a: \\'.-\\',\\n        b: \\'-...\\',\\n        c: \\'-.-.\\',\\n        d: \\'-..\\',\\n        e: \\'.\\',\\n        f: \\'..-.\\',\\n        g: \\'--.\\',\\n        h: \\'....\\',\\n        i: \\'..\\',\\n        j: \\'.---\\',\\n        k: \\'-.-\\',\\n        l: \\'.-..\\',\\n        m: \\'--\\',\\n        n: \\'-.\\',\\n        o: \\'---\\',\\n        p: \\'.--.\\',\\n        q: \\'--.-\\',\\n        r: \\'.-.\\',\\n        s: \\'...\\',\\n        t: \\'-\\',\\n        u: \\'..-\\',\\n        v: \\'...-\\',\\n        w: \\'.--\\',\\n        x: \\'-..-\\',\\n        y: \\'-.--\\',\\n        z: \\'--..\\'\\n    }\\n\\n    let transformations = new Set();\\n\\n    for (let subArr of words) {\\n        let tempStr = \\'\\';\\n        for (let word of subArr) {\\n            let key = symbols[word];\\n            tempStr += key;\\n        }\\n        transformations.add(tempStr);\\n    }\\n    return transformations.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3828299,
                "title": "solution-in-java-beginner-friendly-using-for-loop-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                \".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char[] alphabet = {\\n                \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\',\\n                \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\'\\n        };\\n\\n        String[] new_morse_code_arr = new String[words.length];\\n        int index=0;\\n\\n        String check;\\n        for (String word : words) {\\n            check = word;\\n            for (int j = 0; j < check.length(); j++) {\\n                for (int k = 0; k < alphabet.length; k++) {\\n                    if (check.charAt(j) == alphabet[k]) {\\n                        if (new_morse_code_arr[index] == null) {\\n                            new_morse_code_arr[index] = \"\";\\n                        }\\n                        new_morse_code_arr[index] = new_morse_code_arr[index] + morse_code[k];\\n                    }\\n                }\\n            }\\n            index++;\\n        }\\n\\n        HashSet<String> hs = new HashSet<>(Arrays.asList(new_morse_code_arr));\\n\\n        return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\\n                \".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char[] alphabet = {\\n                \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\',\\n                \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\'\\n        };\\n\\n        String[] new_morse_code_arr = new String[words.length];\\n        int index=0;\\n\\n        String check;\\n        for (String word : words) {\\n            check = word;\\n            for (int j = 0; j < check.length(); j++) {\\n                for (int k = 0; k < alphabet.length; k++) {\\n                    if (check.charAt(j) == alphabet[k]) {\\n                        if (new_morse_code_arr[index] == null) {\\n                            new_morse_code_arr[index] = \"\";\\n                        }\\n                        new_morse_code_arr[index] = new_morse_code_arr[index] + morse_code[k];\\n                    }\\n                }\\n            }\\n            index++;\\n        }\\n\\n        HashSet<String> hs = new HashSet<>(Arrays.asList(new_morse_code_arr));\\n\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415075,
                "title": "golang-performance-speed-is-faster-than-others",
                "content": "\\n# Complexity\\n- Time complexity:100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:28%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc uniqueMorseRepresentations(words []string) int {\\nmorseMap := map[byte]string {\\n\\'a\\': \".-\",\\n\\'b\\': \"-...\",\\n\\'c\\': \"-.-.\",\\n\\'d\\': \"-..\",\\n\\'e\\': \".\",\\n\\'f\\': \"..-.\",\\n\\'g\\': \"--.\",\\n\\'h\\': \"....\",\\n\\'i\\': \"..\",\\n\\'j\\': \".---\",\\n\\'k\\': \"-.-\",\\n\\'l\\': \".-..\",\\n\\'m\\': \"--\",\\n\\'n\\': \"-.\",\\n\\'o\\': \"---\",\\n\\'p\\': \".--.\",\\n\\'q\\': \"--.-\",\\n\\'r\\': \".-.\",\\n\\'s\\': \"...\",\\n\\'t\\': \"-\",\\n\\'u\\': \"..-\",\\n\\'v\\': \"...-\",\\n\\'w\\': \".--\",\\n\\'x\\': \"-..-\",\\n\\'y\\': \"-.--\",\\n\\'z\\': \"--..\",\\n}\\nmorseSet := make(map[string]bool)\\n\\nfor _, word := range words {\\n    morseWord := \"\"\\n\\n    for _, letter := range []byte(word) {\\n        morseWord += morseMap[letter]\\n    }\\n\\n    morseSet[morseWord] = true\\n}\\n\\nreturn len(morseSet)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\nmorseMap := map[byte]string {\\n\\'a\\': \".-\",\\n\\'b\\': \"-...\",\\n\\'c\\': \"-.-.\",\\n\\'d\\': \"-..\",\\n\\'e\\': \".\",\\n\\'f\\': \"..-.\",\\n\\'g\\': \"--.\",\\n\\'h\\': \"....\",\\n\\'i\\': \"..\",\\n\\'j\\': \".---\",\\n\\'k\\': \"-.-\",\\n\\'l\\': \".-..\",\\n\\'m\\': \"--\",\\n\\'n\\': \"-.\",\\n\\'o\\': \"---\",\\n\\'p\\': \".--.\",\\n\\'q\\': \"--.-\",\\n\\'r\\': \".-.\",\\n\\'s\\': \"...\",\\n\\'t\\': \"-\",\\n\\'u\\': \"..-\",\\n\\'v\\': \"...-\",\\n\\'w\\': \".--\",\\n\\'x\\': \"-..-\",\\n\\'y\\': \"-.--\",\\n\\'z\\': \"--..\",\\n}\\nmorseSet := make(map[string]bool)\\n\\nfor _, word := range words {\\n    morseWord := \"\"\\n\\n    for _, letter := range []byte(word) {\\n        morseWord += morseMap[letter]\\n    }\\n\\n    morseSet[morseWord] = true\\n}\\n\\nreturn len(morseSet)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285657,
                "title": "java-simple-solution-easy-to-understand",
                "content": "# Java\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n\\n        int l = words.length;\\n        String s = \"\";\\n        StringBuilder m = new StringBuilder();\\n\\n        String morse[] = new String[] {\\n          \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n          \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n          \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"\\n        }; \\n\\n        Map<Character, String> map = new HashMap<>();\\n\\n        for (int i = 97, j = 0; i < 123; i++, j++) {\\n           map.put((char) i, morse[j]);\\n        }\\n\\n        for (int i = 0; i < l; i++) {\\n            s = words[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                m.append(map.get(s.charAt(j)));\\n            }\\n            words[i] = m.toString();\\n            m.setLength(0);\\n        }\\n\\n        Set<String> ans = new HashSet<String>(Arrays.asList(words));\\n\\n       return ans.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n\\n        int l = words.length;\\n        String s = \"\";\\n        StringBuilder m = new StringBuilder();\\n\\n        String morse[] = new String[] {\\n          \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n          \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\\n          \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"\\n        }; \\n\\n        Map<Character, String> map = new HashMap<>();\\n\\n        for (int i = 97, j = 0; i < 123; i++, j++) {\\n           map.put((char) i, morse[j]);\\n        }\\n\\n        for (int i = 0; i < l; i++) {\\n            s = words[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                m.append(map.get(s.charAt(j)));\\n            }\\n            words[i] = m.toString();\\n            m.setLength(0);\\n        }\\n\\n        Set<String> ans = new HashSet<String>(Arrays.asList(words));\\n\\n       return ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234710,
                "title": "unique-morse-javascript-98-48-55-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/007f6567-605a-498f-a9e6-409185d149b5_1677465451.361765.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar uniqueMorseRepresentations = function(words) {\\n    // set morse array (26 elements like english letters)\\n    morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]    \\n    // set array to store result of words transformation\\n    arr = []\\n    // enumerate all word in words array\\n    for (word of words) {        \\n        let temp = []\\n        // transform letter to morse\\n        for(let i = 0; i < word.length; i++)\\n            temp.push(morse[word[i].charCodeAt(0) - 97])\\n        // push result in arr\\n        arr.push(temp.join(\\'\\'))\\n    }   \\n    // return unique values number in arr\\n    return [...new Set(arr)].length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar uniqueMorseRepresentations = function(words) {\\n    // set morse array (26 elements like english letters)\\n    morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]    \\n    // set array to store result of words transformation\\n    arr = []\\n    // enumerate all word in words array\\n    for (word of words) {        \\n        let temp = []\\n        // transform letter to morse\\n        for(let i = 0; i < word.length; i++)\\n            temp.push(morse[word[i].charCodeAt(0) - 97])\\n        // push result in arr\\n        arr.push(temp.join(\\'\\'))\\n    }   \\n    // return unique values number in arr\\n    return [...new Set(arr)].length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172534,
                "title": "easy-java-solution-self-explanatory-1-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] strArr = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for(String str : words){\\n            StringBuffer sb = new StringBuffer();\\n            for(char ch : str.toCharArray()){\\n                sb.append(strArr[ch-\\'a\\']);\\n            }\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] strArr = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for(String str : words){\\n            StringBuffer sb = new StringBuffer();\\n            for(char ch : str.toCharArray()){\\n                sb.append(strArr[ch-\\'a\\']);\\n            }\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966829,
                "title": "easiest-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n\\n    String []arr={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n    HashMap<String,Boolean>mp=new HashMap<>();\\n\\n    for(int i=0;i<words.length;i++){\\n\\n    String check=\"\";\\n\\n    for(int j=0;j<words[i].length();j++){\\n\\n    check+=arr[words[i].charAt(j)-\\'a\\'];\\n\\n    }\\n\\n    mp.put(check,true);\\n\\n    }\\n\\n    return mp.size();\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n\\n    String []arr={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n    HashMap<String,Boolean>mp=new HashMap<>();\\n\\n    for(int i=0;i<words.length;i++){\\n\\n    String check=\"\";\\n\\n    for(int j=0;j<words[i].length();j++){\\n\\n    check+=arr[words[i].charAt(j)-\\'a\\'];\\n\\n    }\\n\\n    mp.put(check,true);\\n\\n    }\\n\\n    return mp.size();\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872834,
                "title": "java-solution-using-hashset-2ms-99-8-faster",
                "content": "```\\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashSet<String>set=new HashSet<String>();\\n        for(String stu:words){\\n            set.add(code(stu));\\n        }\\n        return set.size();\\n        \\n    }\\n    public String code(String word){\\n        String morse[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n            \\n        StringBuilder str=new StringBuilder();\\n        for(char ch:word.toCharArray()){\\n            str.append(morse[(int)ch-97]);\\n        }\\n        return str.toString();\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int uniqueMorseRepresentations(String[] words) {\\n        HashSet<String>set=new HashSet<String>();\\n        for(String stu:words){\\n            set.add(code(stu));\\n        }\\n        return set.size();\\n        \\n    }\\n    public String code(String word){\\n        String morse[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n            \\n        StringBuilder str=new StringBuilder();\\n        for(char ch:word.toCharArray()){\\n            str.append(morse[(int)ch-97]);\\n        }\\n        return str.toString();\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706198,
                "title": "c-3ms",
                "content": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& w) {\\n        map<char,string> morse{\\n            {\\'a\\',\".-\"},\\n            {\\'b\\',\"-...\"},\\n            {\\'c\\',\"-.-.\"},\\n            {\\'d\\',\"-..\"},\\n            {\\'e\\',\".\"},\\n            {\\'f\\',\"..-.\"},\\n            {\\'g\\',\"--.\"},\\n            {\\'h\\',\"....\"},\\n            {\\'i\\',\"..\"},\\n            {\\'j\\',\".---\"},\\n            {\\'k\\',\"-.-\"},\\n            {\\'l\\',\".-..\"},\\n            {\\'m\\',\"--\"},\\n            {\\'n\\',\"-.\"},\\n            {\\'o\\',\"---\"},\\n            {\\'p\\',\".--.\"},\\n            {\\'q\\',\"--.-\"},\\n            {\\'r\\',\".-.\"},\\n            {\\'s\\',\"...\"},\\n            {\\'t\\',\"-\"},\\n            {\\'u\\',\"..-\"},\\n            {\\'v\\',\"...-\"},\\n            {\\'w\\',\".--\"},\\n            {\\'x\\',\"-..-\"},\\n            {\\'y\\',\"-.--\"},\\n            {\\'z\\',\"--..\"}\\n        };\\n        set<string>se;\\n        int n=w.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=\"\";\\n            for(int j=0;j<w[i].size();j++)a+=morse[w[i][j]];\\n            se.insert(a);\\n        }\\n        return se.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& w) {\\n        map<char,string> morse{\\n            {\\'a\\',\".-\"}",
                "codeTag": "Java"
            },
            {
                "id": 2440022,
                "title": "c-simple-easy-to-understand-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n       const vector<string> morseCode  {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(auto &x : words) {\\n            string temp = \"\";\\n            \\n            for(auto &y : x)  temp += morseCode[y - \\'a\\'];\\n            \\n            x = temp;\\n        }\\n        \\n        unordered_set<string> mSet;\\n        \\n        for(auto &x : words) mSet.insert(x);\\n        \\n        \\n        return size(mSet);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n       const vector<string> morseCode  {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        for(auto &x : words) {\\n            string temp = \"\";\\n            \\n            for(auto &y : x)  temp += morseCode[y - \\'a\\'];\\n            \\n            x = temp;\\n        }\\n        \\n        unordered_set<string> mSet;\\n        \\n        for(auto &x : words) mSet.insert(x);\\n        \\n        \\n        return size(mSet);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439056,
                "title": "python-2-liner",
                "content": "# With lambda expression (readability):\\n\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        encode = lambda word: [morse_codes[ord(c) - ord(\\'a\\')] for c in word]\\n        return len({\"\".join(encode(word)) for word in words})\\n        \\n```\\n\\n# Without lambda expression\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len({\"\".join(morse_codes[ord(c) - ord(\\'a\\')] for c in word) for word in words})\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        encode = lambda word: [morse_codes[ord(c) - ord(\\'a\\')] for c in word]\\n        return len({\"\".join(encode(word)) for word in words})\\n        \\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len({\"\".join(morse_codes[ord(c) - ord(\\'a\\')] for c in word) for word in words})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438949,
                "title": "c-easy-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> mp = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        unordered_map<string, bool> check;\\n        for(int i = 0 ; i<words.size() ; i++)\\n        {\\n            string temp = \"\";\\n            string word = words[i];\\n            \\n            for(int j = 0 ; j<word.length() ; j++)\\n            {\\n                temp+= mp[word[j]-\\'a\\'];\\n            }\\n            check[temp] = true;\\n            \\n        }\\n        \\n        return check.size();\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3eab6ea7-1859-489f-aa13-1b4d0cde7948_1660735826.2910888.png)\\n",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> mp = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        unordered_map<string, bool> check;\\n        for(int i = 0 ; i<words.size() ; i++)\\n        {\\n            string temp = \"\";\\n            string word = words[i];\\n            \\n            for(int j = 0 ; j<word.length() ; j++)\\n            {\\n                temp+= mp[word[j]-\\'a\\'];\\n            }\\n            check[temp] = true;\\n            \\n        }\\n        \\n        return check.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438913,
                "title": "daily-leetcode-challenge",
                "content": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\nunordered_set<string> s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string temp=\"\";\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                int e=words[i][j]-\\'a\\';\\n                temp+=v[e];\\n            }s.insert(temp);\\n        }return s.size();\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 2438600,
                "title": "js-3-line-faster-than-71",
                "content": "\\n```\\n\\nconst MORSE_CODE = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n\\nconst DICTIONARY = \\'abcdefghijklmnopqrstuvwxyz\\'.split(\\'\\').reduce((a, e,i)=> ({...a, [e]:MORSE_CODE[i]}) , {})\\n\\nconst uniqueMorseRepresentations = (words) => [...new Set(words.map(w=> w.split(\\'\\').map(e=> DICTIONARY[e]).join(\\'\\')))].length\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst MORSE_CODE = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n\\nconst DICTIONARY = \\'abcdefghijklmnopqrstuvwxyz\\'.split(\\'\\').reduce((a, e,i)=> ({...a, [e]:MORSE_CODE[i]}) , {})\\n\\nconst uniqueMorseRepresentations = (words) => [...new Set(words.map(w=> w.split(\\'\\').map(e=> DICTIONARY[e]).join(\\'\\')))].length\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2438355,
                "title": "c-beginner-friendly-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> alpha={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        map<string,int> m;\\n        for(auto it : words){\\n            string ans;\\n            for(int i=0;i<it.size();++i){\\n                  ans+=alpha[it[i]-\\'a\\'];\\n            }\\n            m[ans]++;\\n            \\n        }\\n        return m.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> alpha={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        map<string,int> m;\\n        for(auto it : words){\\n            string ans;\\n            for(int i=0;i<it.size();++i){\\n                  ans+=alpha[it[i]-\\'a\\'];\\n            }\\n            m[ans]++;\\n            \\n        }\\n        return m.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438240,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "**Time Complexity : O(n*m)**\\n**Java**\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String morse[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet();\\n        for(String word: words){\\n            StringBuilder str = new StringBuilder();\\n            for(char c: word.toCharArray()){\\n                str.append(morse[c -\\'a\\']);\\n            }\\n            set.add(str.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    let myset = new Set()\\n    for(let word of words){\\n        let str = \"\"\\n        for(let i=0; i<word.length; i++){\\n            str += morse[word.charCodeAt(i) - 97]\\n        }\\n        myset.add(str.toString())\\n    }\\n    return myset.size\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        myset = set()\\n        for word in words:\\n            s = \"\"\\n            for c in word:\\n                s += morse[ord(c) - 97]\\n            myset.add(s)\\n        return len(myset)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String morse[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet();\\n        for(String word: words){\\n            StringBuilder str = new StringBuilder();\\n            for(char c: word.toCharArray()){\\n                str.append(morse[c -\\'a\\']);\\n            }\\n            set.add(str.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```\\nvar uniqueMorseRepresentations = function(words) {\\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    let myset = new Set()\\n    for(let word of words){\\n        let str = \"\"\\n        for(let i=0; i<word.length; i++){\\n            str += morse[word.charCodeAt(i) - 97]\\n        }\\n        myset.add(str.toString())\\n    }\\n    return myset.size\\n};\\n```\n```\\nclass Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        myset = set()\\n        for word in words:\\n            s = \"\"\\n            for c in word:\\n                s += morse[ord(c) - 97]\\n            myset.add(s)\\n        return len(myset)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437872,
                "title": "simple-hashset-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] a={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String>hs=new HashSet<String>();int c=0;\\n        for(String w: words){\\n            String s=\"\";\\n            for(int i=0;i<w.length();i++)\\n                s+=a[(int)w.charAt(i)-\\'a\\'];\\n    \\n            hs.add(s);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] a={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String>hs=new HashSet<String>();int c=0;\\n        for(String w: words){\\n            String s=\"\";\\n            for(int i=0;i<w.length();i++)\\n                s+=a[(int)w.charAt(i)-\\'a\\'];\\n    \\n            hs.add(s);\\n        }\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437743,
                "title": "easy-and-concised-solution-c-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> x = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> s;\\n        \\n        for(auto c : words){\\n            string tempAns = \"\";\\n            for(auto t : c){\\n                string temp = x[t - \\'a\\'];\\n                tempAns += temp;\\n            }\\n            s.insert(tempAns);\\n            \\n        }\\n        return (s.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> x = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> s;\\n        \\n        for(auto c : words){\\n            string tempAns = \"\";\\n            for(auto t : c){\\n                string temp = x[t - \\'a\\'];\\n                tempAns += temp;\\n            }\\n            s.insert(tempAns);\\n            \\n        }\\n        return (s.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437541,
                "title": "unique-morse-code-words-simple-c-solution",
                "content": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        set<string> ans;\\n\\n        for(int i = 0; i < words.size();i++){\\n            string s = words[i]; \\n            string temp = \"\"; \\n\\n            for(int j= 0 ;j < s.length(); j++){\\n                int e = s[j] - \\'a\\'; \\n                temp += morse[e];\\n            }\\n            ans.insert(temp); \\n        }\\n        return ans.size(); \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        set<string> ans;\\n\\n        for(int i = 0; i < words.size();i++){\\n            string s = words[i]; \\n            string temp = \"\"; \\n\\n            for(int j= 0 ;j < s.length(); j++){\\n                int e = s[j] - \\'a\\'; \\n                temp += morse[e];\\n            }\\n            ans.insert(temp); \\n        }\\n        return ans.size(); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437361,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> set;\\n        \\n        for(auto &w :words)\\n        {\\n            string s= \"\";\\n            for(auto &ch:w)\\n            {\\n                s+=v[ch - \\'a\\']; \\n            }\\n            set.insert(s);\\n        }\\n        return set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> set;\\n        \\n        for(auto &w :words)\\n        {\\n            string s= \"\";\\n            for(auto &ch:w)\\n            {\\n                s+=v[ch - \\'a\\']; \\n            }\\n            set.insert(s);\\n        }\\n        return set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437311,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] w) {\\n        String a[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> nm=new HashSet<>();\\n        for(String k:w)\\n        {\\n            StringBuilder kk=new StringBuilder();\\n            for(int i=0;i<k.length();i++)\\n            {\\n                kk.append(a[k.charAt(i)-\\'a\\']);\\n            }\\n            nm.add(kk.toString());\\n        }\\n        return nm.size(); \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int uniqueMorseRepresentations(String[] w) {\\n        String a[]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 2437170,
                "title": "c-easy-explanation-map",
                "content": "**Approache : for every word find Morse code and store in the map**\\n\\n**Finnaly return the size of map which is gives unique no of Morse Code**\\n\\n\\n\\n\\n\\n     int uniqueMorseRepresentations(vector<string>& words) {\\n        \\n    // all the Morse Code   \\n    string code[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    \\n        //Declaration map\\n    unordered_map<string,int>mp;\\n    \\n        //loop for no of word\\n     for(int i=0;i<words.size();i++){\\n            string s=\"\";\\n         //for every word calculated Morese code\\n            for(int j=0;j<words[i].size();j++){\\n                s+=code[words[i][j]-\\'a\\'];\\n            }\\n         //store in the map...no duplicate can\\'t add due to 1 assign\\n            mp[s]=1;\\n        }\\n    \\n        //return the size of map\\n    return mp.size();\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Approache : for every word find Morse code and store in the map**\\n\\n**Finnaly return the size of map which is gives unique no of Morse Code**\\n\\n\\n\\n\\n\\n     int uniqueMorseRepresentations(vector<string>& words) {\\n        \\n    // all the Morse Code   \\n    string code[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    \\n        //Declaration map\\n    unordered_map<string,int>mp;\\n    \\n        //loop for no of word\\n     for(int i=0;i<words.size();i++){\\n            string s=\"\";\\n         //for every word calculated Morese code\\n            for(int j=0;j<words[i].size();j++){\\n                s+=code[words[i][j]-\\'a\\'];\\n            }\\n         //store in the map...no duplicate can\\'t add due to 1 assign\\n            mp[s]=1;\\n        }\\n    \\n        //return the size of map\\n    return mp.size();\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2437112,
                "title": "easy-java-solution-explained-beginner-friendly-best-method-comments",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        //Storing the code in the Array of Strings\\n        String[] code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t\\n\\t\\t//Declaring an HashMap to map each key to its respective value such as {\\'a\\' = \".-\",\\'b\\' = \"-...\",....etc}\\n\\t\\tHashMap<Character,String> map = new HashMap<Character,String>();\\n\\t\\t//initializing a Character Count with value \\'a\\'\\n\\t\\tchar ch = \\'a\\';\\n\\t\\t\\n        for(int i = 0 ; i < code.length ; i ++){\\n\\t\\t\\t//at each iteration we are incrementing the character count by one \\n\\t\\t\\t//i.e from \\'a\\' to \\'b\\' and \\'b\\' to \\'c\\' and so on \\n\\t\\t\\t//and respectively storing the key value pair in HashMap\\n\\t\\t    map.put(ch++,code[i]);\\n\\t\\t}\\n        int n = words.length;\\n\\t\\t//Declaring a HashSet to store Unique set of Concatenated morse code\\n        HashSet<String> hs = new HashSet<String>();\\n\\t\\t\\n\\t\\t//iterating over the array words\\n        for(int i = 0; i < n; i++){\\n\\t\\t\\t//storing each words at index location to string and performing the concatenation\\n            String str = words[i];\\n\\t\\t\\t//declaring an empty string to store the concatenated code at each iteration of a letter of words\\n            String ans = \"\";\\n            for(int j = 0 ; j < str.length(); j++){\\n\\t\\t\\t\\t//concatenating the each letter corresponding code to ans to form proper morse code for the respective words\\n                ans = ans + map.get(str.charAt(j));\\n            }\\n\\t\\t\\t//Storing the generated String(ans) in HashSet to get only unique Strings\\n            hs.add(ans);\\n        }\\n\\t\\t//returning the length of HashSet to get the total no. of unique String obtain from the following words\\n        return hs.size();\\n    }\\n}\\n```\\n**Please Up Vote (if you liked the approach and solution)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        //Storing the code in the Array of Strings\\n        String[] code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\t\\n\\t\\t//Declaring an HashMap to map each key to its respective value such as {\\'a\\' = \".-\",\\'b\\' = \"-...\",....etc}\\n\\t\\tHashMap<Character,String> map = new HashMap<Character,String>();\\n\\t\\t//initializing a Character Count with value \\'a\\'\\n\\t\\tchar ch = \\'a\\';\\n\\t\\t\\n        for(int i = 0 ; i < code.length ; i ++){\\n\\t\\t\\t//at each iteration we are incrementing the character count by one \\n\\t\\t\\t//i.e from \\'a\\' to \\'b\\' and \\'b\\' to \\'c\\' and so on \\n\\t\\t\\t//and respectively storing the key value pair in HashMap\\n\\t\\t    map.put(ch++,code[i]);\\n\\t\\t}\\n        int n = words.length;\\n\\t\\t//Declaring a HashSet to store Unique set of Concatenated morse code\\n        HashSet<String> hs = new HashSet<String>();\\n\\t\\t\\n\\t\\t//iterating over the array words\\n        for(int i = 0; i < n; i++){\\n\\t\\t\\t//storing each words at index location to string and performing the concatenation\\n            String str = words[i];\\n\\t\\t\\t//declaring an empty string to store the concatenated code at each iteration of a letter of words\\n            String ans = \"\";\\n            for(int j = 0 ; j < str.length(); j++){\\n\\t\\t\\t\\t//concatenating the each letter corresponding code to ans to form proper morse code for the respective words\\n                ans = ans + map.get(str.charAt(j));\\n            }\\n\\t\\t\\t//Storing the generated String(ans) in HashSet to get only unique Strings\\n            hs.add(ans);\\n        }\\n\\t\\t//returning the length of HashSet to get the total no. of unique String obtain from the following words\\n        return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436871,
                "title": "q387-c-100-faster-hash-map-simple-for-loop",
                "content": "### C++ Solution \\nResult:\\n![image](https://assets.leetcode.com/users/images/7d78cf65-202e-4ecc-adee-6ee904ce539f_1660705116.1725438.png)\\n\\nMy Method: \\n```\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morses = { \\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" \\n            };\\n        map<string, bool> m;\\n        for (int i = 0; i < words.size(); i++) {\\n            string morse = \"\";\\n            for (int j = 0; j < words[i].size(); j++) {\\n                morse += morses[words[i][j] - \\'a\\'];\\n            }\\n            m[morse] = true;\\n        }\\n        return m.size();\\n    }\\n```\\n\\n**The complexity of this solution:**\\n-\\tTime: O( N^2 ) ...  // depend on the size of words\\n-\\tSpace: O( N ) ... // depend on the size of words\\n\\n**If you loved this solution then please up vote to motivate me \\uD83D\\uDE0A**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morses = { \\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \\n            \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \\n            \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" \\n            };\\n        map<string, bool> m;\\n        for (int i = 0; i < words.size(); i++) {\\n            string morse = \"\";\\n            for (int j = 0; j < words[i].size(); j++) {\\n                morse += morses[words[i][j] - \\'a\\'];\\n            }\\n            m[morse] = true;\\n        }\\n        return m.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436869,
                "title": "easy-solution-daily-leetcode-challenge-august-17-c-java",
                "content": "## if u find it helpful , please give it a upvote\\n\\n### Approach\\n1) creating a vector of codes.\\n2) convert a word to code by traversing each letter of a word and getting the code for the letter from vector \\n3) concatinating the code into a string \\n4) the string containing transformation of a word is inserted into a set\\n5) repeating for all words\\n6) set contains unique values , so will contain only unique tranformations\\n7) returning set size as the number of different transformations.\\n\\n### C++ solution\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> set;\\n        for(int i=0;i<words.size();i++){\\n            string temp = \"\";\\n            for(int j=0;j<words[i].size();j++){\\n                temp+=v[words[i][j]-\\'a\\'];\\n            }\\n            set.insert(temp);\\n            temp.clear();\\n        }\\n        return set.size();\\n    }\\n};\\n```\\n\\n### java code\\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n         String[] v = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        Set<String> set = new HashSet<>();\\n        for(String i:words){\\n            StringBuilder temp = new StringBuilder();\\n            int j=0;\\n            while(j<i.length()){\\n                temp.append(v[i.charAt(j)-\\'a\\']);\\n                j++;\\n            }\\n            set.add(temp.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> v = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> set;\\n        for(int i=0;i<words.size();i++){\\n            string temp = \"\";\\n            for(int j=0;j<words[i].size();j++){\\n                temp+=v[words[i][j]-\\'a\\'];\\n            }\\n            set.insert(temp);\\n            temp.clear();\\n        }\\n        return set.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n         String[] v = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        Set<String> set = new HashSet<>();\\n        for(String i:words){\\n            StringBuilder temp = new StringBuilder();\\n            int j=0;\\n            while(j<i.length()){\\n                temp.append(v[i.charAt(j)-\\'a\\']);\\n                j++;\\n            }\\n            set.add(temp.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436494,
                "title": "simple-c-solution-100-faster-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n    vector<string>morse= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    unordered_set<string>ans;\\n    for(auto word : words) {\\n        string code = \"\";\\n        for(auto ch : word)\\n            code += morse[ch - \\'a\\'];\\n        ans.insert(code);\\n    }\\n    \\n    return ans.size();\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n    vector<string>morse= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n    unordered_set<string>ans;\\n    for(auto word : words) {\\n        string code = \"\";\\n        for(auto ch : word)\\n            code += morse[ch - \\'a\\'];\\n        ans.insert(code);\\n    }\\n    \\n    return ans.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326190,
                "title": "a-ts-solution-hasmap-and-set",
                "content": "```\\nconst morse: { [key: string]: string } = {\\n  a: \\'.-\\',\\n  b: \\'-...\\',\\n  c: \\'-.-.\\',\\n  d: \\'-..\\',\\n  e: \\'.\\',\\n  f: \\'..-.\\',\\n  g: \\'--.\\',\\n  h: \\'....\\',\\n  i: \\'..\\',\\n  j: \\'.---\\',\\n  k: \\'-.-\\',\\n  l: \\'.-..\\',\\n  m: \\'--\\',\\n  n: \\'-.\\',\\n  o: \\'---\\',\\n  p: \\'.--.\\',\\n  q: \\'--.-\\',\\n  r: \\'.-.\\',\\n  s: \\'...\\',\\n  t: \\'-\\',\\n  u: \\'..-\\',\\n  v: \\'...-\\',\\n  w: \\'.--\\',\\n  x: \\'-..-\\',\\n  y: \\'-.--\\',\\n  z: \\'--..\\',\\n};\\n\\nfunction uniqueMorseRepresentations(words: string[]): number {\\n  const transformations: Set<string> = new Set();\\n  \\n  for (let i = 0; i < words.length; i++) {\\n    let transformation = \\'\\';\\n    \\n    for (let j = 0; j < words[i].length; j++) {\\n      transformation += morse[words[i][j]];\\n    }\\n    \\n    transformations.add(transformation);\\n  }\\n  \\n  return transformations.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst morse: { [key: string]: string } = {\\n  a: \\'.-\\',\\n  b: \\'-...\\',\\n  c: \\'-.-.\\',\\n  d: \\'-..\\',\\n  e: \\'.\\',\\n  f: \\'..-.\\',\\n  g: \\'--.\\',\\n  h: \\'....\\',\\n  i: \\'..\\',\\n  j: \\'.---\\',\\n  k: \\'-.-\\',\\n  l: \\'.-..\\',\\n  m: \\'--\\',\\n  n: \\'-.\\',\\n  o: \\'---\\',\\n  p: \\'.--.\\',\\n  q: \\'--.-\\',\\n  r: \\'.-.\\',\\n  s: \\'...\\',\\n  t: \\'-\\',\\n  u: \\'..-\\',\\n  v: \\'...-\\',\\n  w: \\'.--\\',\\n  x: \\'-..-\\',\\n  y: \\'-.--\\',\\n  z: \\'--..\\',\\n};\\n\\nfunction uniqueMorseRepresentations(words: string[]): number {\\n  const transformations: Set<string> = new Set();\\n  \\n  for (let i = 0; i < words.length; i++) {\\n    let transformation = \\'\\';\\n    \\n    for (let j = 0; j < words[i].length; j++) {\\n      transformation += morse[words[i][j]];\\n    }\\n    \\n    transformations.add(transformation);\\n  }\\n  \\n  return transformations.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166577,
                "title": "python3-o-n-m-o-n",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n#         O(n*m) || O(n)\\n        hashMap = {\\'a\\': \\'.-\\', \\'b\\': \\'-...\\', \\'c\\': \\'-.-.\\', \\'d\\': \\'-..\\', \\'e\\': \\'.\\', \\'f\\': \\'..-.\\', \\'g\\': \\'--.\\', \\'h\\': \\'....\\', \\'i\\': \\'..\\', \\'j\\': \\'.---\\', \\'k\\': \\'-.-\\', \\'l\\': \\'.-..\\', \\'m\\': \\'--\\', \\'n\\': \\'-.\\', \\'o\\': \\'---\\', \\'p\\': \\'.--.\\', \\'q\\': \\'--.-\\', \\'r\\': \\'.-.\\', \\'s\\': \\'...\\', \\'t\\': \\'-\\', \\'u\\': \\'..-\\', \\'v\\': \\'...-\\', \\'w\\': \\'.--\\', \\'x\\': \\'-..-\\', \\'y\\': \\'-.--\\', \\'z\\': \\'--..\\'}\\n            \\n        seen = set()\\n        for word in words:\\n            newList = []\\n            for code in word:\\n                newList.append(hashMap[code])\\n            seen.add(\\'\\'.join(newList))\\n\\n        return len(seen)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n#         O(n*m) || O(n)\\n        hashMap = {\\'a\\': \\'.-\\', \\'b\\': \\'-...\\', \\'c\\': \\'-.-.\\', \\'d\\': \\'-..\\', \\'e\\': \\'.\\', \\'f\\': \\'..-.\\', \\'g\\': \\'--.\\', \\'h\\': \\'....\\', \\'i\\': \\'..\\', \\'j\\': \\'.---\\', \\'k\\': \\'-.-\\', \\'l\\': \\'.-..\\', \\'m\\': \\'--\\', \\'n\\': \\'-.\\', \\'o\\': \\'---\\', \\'p\\': \\'.--.\\', \\'q\\': \\'--.-\\', \\'r\\': \\'.-.\\', \\'s\\': \\'...\\', \\'t\\': \\'-\\', \\'u\\': \\'..-\\', \\'v\\': \\'...-\\', \\'w\\': \\'.--\\', \\'x\\': \\'-..-\\', \\'y\\': \\'-.--\\', \\'z\\': \\'--..\\'}\\n            \\n        seen = set()\\n        for word in words:\\n            newList = []\\n            for code in word:\\n                newList.append(hashMap[code])\\n            seen.add(\\'\\'.join(newList))\\n\\n        return len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153713,
                "title": "unique-morse-code-words-using-maps-and-sets-easy",
                "content": "\\'\\'\\'\\n\\n      vector<string>v{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n       string str=\"abcdefghijklmnopqrstuvwxyz\";\\n        vector<char>arr;\\n        for(auto val:str){\\n            arr.push_back(val);\\n        }\\n        unordered_map<char,string>m;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            m[arr[i]]=v[i];\\n        }\\n        set<string>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                str=str+m[words[i][j]];\\n            }\\n            s.insert(str);\\n            \\n        }\\n        return s.size();\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "\\'\\'\\'\\n\\n      vector<string>v{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n       string str=\"abcdefghijklmnopqrstuvwxyz\";\\n        vector<char>arr;\\n        for(auto val:str){\\n            arr.push_back(val);\\n        }\\n        unordered_map<char,string>m;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            m[arr[i]]=v[i];\\n        }\\n        set<string>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                str=str+m[words[i][j]];\\n            }\\n            s.insert(str);\\n            \\n        }\\n        return s.size();\\n\\t\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1994527,
                "title": "my-easy-to-understand-fast-3ms-java-code",
                "content": "```\\nclass Solution \\n{\\n    public int uniqueMorseRepresentations(String[] words) \\n    {\\n        String[] arr = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        HashSet<String> hs = new HashSet<>();\\n        \\n        for(String s:words)\\n        {\\n            String morse=\"\";\\n            for(int i=0;i<s.length();i++)\\n            {\\n                int c = s.charAt(i)-97;\\n                morse+=arr[c];\\n            }\\n            hs.add(morse);\\n        }\\n        return hs.size();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int uniqueMorseRepresentations(String[] words) \\n    {\\n        String[] arr = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 1966436,
                "title": "fp-scala-solution",
                "content": "```\\nobject Solution {\\n    def uniqueMorseRepresentations(words: Array[String]): Int = {\\n    val mapMorse = (0 until 26).zip(Array(\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n      \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\")).toMap\\n    val arr = \"abcdefghijklmnopqrstuvwxyz\".zipWithIndex.toMap\\n    val result = words.foldLeft(List.empty[String]) { (list, e) =>\\n      val x = e.foldLeft(\"\") { (str, ch) =>\\n        str + mapMorse.get(arr.getOrElse(ch, -1)).mkString\\n      }\\n      list :+ x\\n    }\\n    result.toSet.size\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def uniqueMorseRepresentations(words: Array[String]): Int = {\\n    val mapMorse = (0 until 26).zip(Array(\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n      \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\")).toMap\\n    val arr = \"abcdefghijklmnopqrstuvwxyz\".zipWithIndex.toMap\\n    val result = words.foldLeft(List.empty[String]) { (list, e) =>\\n      val x = e.foldLeft(\"\") { (str, ch) =>\\n        str + mapMorse.get(arr.getOrElse(ch, -1)).mkString\\n      }\\n      list :+ x\\n    }\\n    result.toSet.size\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1869086,
                "title": "faster-than-100-easy-to-understand-maps-beginer-friendly",
                "content": "PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\nASK IN COMMENTS IF FACING ANY DOUBTS\\nHAPPY LEARNING ;)\\n\\n```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        string p[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        int x=words.size();\\n        map<string,int > mp;\\n        for(int i=0;i<x;i++)\\n        {\\n            string s;\\n            int y=words[i].length();\\n            for(int j=0;j<y;j++)\\n                s+=p[words[i][j]-\\'a\\'];\\n           \\n            mp[s]++;\\n        }return mp.size();\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nint uniqueMorseRepresentations(vector<string>& words) {\\n        string p[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        int x=words.size();\\n        map<string,int > mp;\\n        for(int i=0;i<x;i++)\\n        {\\n            string s;\\n            int y=words[i].length();\\n            for(int j=0;j<y;j++)\\n                s+=p[words[i][j]-\\'a\\'];\\n           \\n            mp[s]++;\\n        }return mp.size();\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692119,
                "title": "java-solution-using-arraylist-and-for-loop",
                "content": "class Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n       String[] mapOfMorse = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\\n        ArrayList<String> list = new ArrayList<>();\\n        for (int i=0; i< words.length; i++){\\n            String newStr = \"\";\\n            for (int j=0; j<words[i].length(); j++){\\n                int ch = words[i].charAt(j) - \\'a\\';\\n                newStr += mapOfMorse[ch];\\n            }\\n            list.add(newStr);\\n        }\\n        Collections.sort(list);\\n        System.out.println(list);\\n        int transformation = 1;\\n        for (int z=0; z< list.size()-1; z++){\\n            if (!list.get(z).equals(list.get(z+1))){\\n                transformation++;\\n            }\\n        }\\n        return transformation;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n       String[] mapOfMorse = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 1646046,
                "title": "easiest-js-solution",
                "content": "var uniqueMorseRepresentations = function(words) {\\n    let final = new Set();\\n    let arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    let str;\\n    for(let val of words){\\n        str = \"\";\\n        for(let i=0; i<val.length; i++){\\n            let num = val.charCodeAt(i) - 97;\\n            str += arr[num];\\n        }\\n        final.add(str);\\n    }\\n    return final.size;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var uniqueMorseRepresentations = function(words) {\\n    let final = new Set();\\n    let arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    let str;\\n    for(let val of words){\\n        str = \"\";\\n        for(let i=0; i<val.length; i++){\\n            let num = val.charCodeAt(i) - 97;\\n            str += arr[num];\\n        }\\n        final.add(str);\\n    }\\n    return final.size;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1640131,
                "title": "solution-with-complete-explanation-c",
                "content": "**What Question is asking about:-**\\n** **\\nOk So lets see what the question is all about.\\n\\n<img src=\"https://assets.leetcode.com/users/images/40e79095-c826-4ac0-9880-3e04f77feb87_1640111990.1353734.png\" width=\"500px\">\\n\\nSo we have to find number of distinct set we can all make.\\nNote:- The morse code is made in such a way that on multiple combination of letter it shows the same output.(see below example!).\\n\\n**Lets see this from the example:-**\\n** **\\n<img src=\"https://assets.leetcode.com/users/images/3e11c816-f357-4dc1-95ef-a8da3634b586_1640112391.845648.png\" width=\"500px\">\\n\\nAs you can see we get two unique combination of morse code.\\n\\n** **\\n**Solution:-**\\n\\nWe will use ***set*** because we need distinct values so taking any other datatype will only add aditional steps to count all distinct elements.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n\\t\\n    vector<string> s={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> strSet;\\n \\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str=str+s[words[i][j]-\\'a\\'];\\n            }\\n            strSet.insert(str);\\n        }\\n        return strSet.size();\\n    }\\n\\t\\n};\\n```\\n\\n<br>\\n\\n**If you liked the answer, leave an upvote!\\nThank You So Much :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n\\t\\n    vector<string> s={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        set<string> strSet;\\n \\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str=str+s[words[i][j]-\\'a\\'];\\n            }\\n            strSet.insert(str);\\n        }\\n        return strSet.size();\\n    }\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615290,
                "title": "0-ms-faster-than-100-00-simple-easy-to-understand-with-explaination",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Unique Morse Code Words.\\nMemory Usage: 5.7 MB, less than 79.41% of C online submissions for Unique Morse Code Words.\\n\\nsubmission link:\\nhttps://leetcode.com/submissions/detail/597923184/\\n\\n```\\nint uniqueMorseRepresentations(char ** words, int wordsSize)\\n{\\n    // array containing morse code corresponding to indices 0:a, 1:b, 2:c ...\\n    char *morse[26] = {\\n        \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"\\n    };\\n\\n    // array to store morse code for each given words\\n    // max. length of an english character in morse code = 4\\n    // now, words[i].length <= 12\\n    // hence 12*4 = 48 + 1(\\'\\\\0\\') = 49(size of morse code of max. words[i].length)\\n    char store[wordsSize][49];\\n    \\n    // converting english characters to morse by accessing the morse array\\n    // english small letters start with ASCII 97, hence it is subtracted\\n    for(int i=0; i<wordsSize; i++)\\n    {\\n        strcpy(store[i], \"\");\\n        for(int j=0; words[i][j]!=\\'\\\\0\\'; j++)\\n            strcat(store[i], morse[words[i][j]-97]);\\n    }\\n     \\n    // counting the unique elements in the store array\\n    int ans=1, j=0;\\n    for(int i=1; i<wordsSize; i++)\\n    {\\n        for(j=0; j<i; j++)\\n            if(!strcmp(store[i], store[j]))\\n                break;\\n        if(i==j)\\n            ans++;\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint uniqueMorseRepresentations(char ** words, int wordsSize)\\n{\\n    // array containing morse code corresponding to indices 0:a, 1:b, 2:c ...\\n    char *morse[26] = {\\n        \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"\\n    };\\n\\n    // array to store morse code for each given words\\n    // max. length of an english character in morse code = 4\\n    // now, words[i].length <= 12\\n    // hence 12*4 = 48 + 1(\\'\\\\0\\') = 49(size of morse code of max. words[i].length)\\n    char store[wordsSize][49];\\n    \\n    // converting english characters to morse by accessing the morse array\\n    // english small letters start with ASCII 97, hence it is subtracted\\n    for(int i=0; i<wordsSize; i++)\\n    {\\n        strcpy(store[i], \"\");\\n        for(int j=0; words[i][j]!=\\'\\\\0\\'; j++)\\n            strcat(store[i], morse[words[i][j]-97]);\\n    }\\n     \\n    // counting the unique elements in the store array\\n    int ans=1, j=0;\\n    for(int i=1; i<wordsSize; i++)\\n    {\\n        for(j=0; j<i; j++)\\n            if(!strcmp(store[i], store[j]))\\n                break;\\n        if(i==j)\\n            ans++;\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492492,
                "title": "2-line-solution-in-python-using-set-and-list",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse, a = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"], ord(\\'a\\')\\n        return len(set([\"\".join(morse[ord(c) - a] for c in word) for word in words]))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse, a = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"], ord(\\'a\\')\\n        return len(set([\"\".join(morse[ord(c) - a] for c in word) for word in words]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459311,
                "title": "java-solution-runtime-1-ms-faster-than-99-93",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String []strings = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\\n                \"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        HashSet<String> hashSet = new HashSet<>();\\n        for (String st : words){\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0;i<st.length();i++){\\n                int index = st.charAt(i);\\n                index = index %97;\\n                sb.append(strings[index]);\\n            }\\n            hashSet.add(sb.toString());\\n        }\\n        return hashSet.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String []strings = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\\n                \"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        HashSet<String> hashSet = new HashSet<>();\\n        for (String st : words){\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0;i<st.length();i++){\\n                int index = st.charAt(i);\\n                index = index %97;\\n                sb.append(strings[index]);\\n            }\\n            hashSet.add(sb.toString());\\n        }\\n        return hashSet.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438934,
                "title": "straightforward-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string morse[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        \\n        set<string> mp;\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            string word = \"\";\\n            for(char ch : words[i])\\n            {\\n                int idx = ch - \\'a\\';\\n                word += morse[idx];\\n            }\\n            mp.insert(word);\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string morse[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\t\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        \\n        set<string> mp;\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            string word = \"\";\\n            for(char ch : words[i])\\n            {\\n                int idx = ch - \\'a\\';\\n                word += morse[idx];\\n            }\\n            mp.insert(word);\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411931,
                "title": "easy-java-solution-no-hashset",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCodeLetterTranslations = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        List<String> convertedUniqueMorseCodes = new ArrayList<>();\\n        for(String indivWord : words){\\n            StringBuilder morseCodeWord = new StringBuilder(); //store morse code here\\n            for(char indivChar : indivWord.toCharArray()){\\n                String morseCodeChar = morseCodeLetterTranslations[indivChar - 97];\\n                morseCodeWord.append(morseCodeChar);\\n            }\\n            if(!convertedUniqueMorseCodes.contains(morseCodeWord.toString())){\\n                convertedUniqueMorseCodes.add(morseCodeWord.toString());\\n            }\\n        }\\n    \\n        return convertedUniqueMorseCodes.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] morseCodeLetterTranslations = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        List<String> convertedUniqueMorseCodes = new ArrayList<>();\\n        for(String indivWord : words){\\n            StringBuilder morseCodeWord = new StringBuilder(); //store morse code here\\n            for(char indivChar : indivWord.toCharArray()){\\n                String morseCodeChar = morseCodeLetterTranslations[indivChar - 97];\\n                morseCodeWord.append(morseCodeChar);\\n            }\\n            if(!convertedUniqueMorseCodes.contains(morseCodeWord.toString())){\\n                convertedUniqueMorseCodes.add(morseCodeWord.toString());\\n            }\\n        }\\n    \\n        return convertedUniqueMorseCodes.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397714,
                "title": "simple-python",
                "content": "```\\ncode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\", \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\nalp = \"abcdefghijklmnopqrstuvwxyz\"\\n        \\n        ls = []\\n        count = 0\\n        string = \"\"\\n        for i in words:\\n            for j in i:\\n                index = alp.index(j)\\n                string += code[index]\\n            ls.append(string)\\n            string = \"\"\\n            \\n        \\n        res = set(ls)\\n        for i in res:\\n            count += 1\\n            \\n        return count\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\ncode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\", \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\nalp = \"abcdefghijklmnopqrstuvwxyz\"\\n        \\n        ls = []\\n        count = 0\\n        string = \"\"\\n        for i in words:\\n            for j in i:\\n                index = alp.index(j)\\n                string += code[index]\\n            ls.append(string)\\n            string = \"\"\\n            \\n        \\n        res = set(ls)\\n        for i in res:\\n            count += 1\\n            \\n        return count\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270782,
                "title": "golang-solution-faster-than-100",
                "content": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n\\tletters := []string{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n\\t\\t\".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"}\\n\\tm := make(map[string]int)\\n\\n\\tfor _, word := range words {\\n\\t\\ts := \"\"\\n\\t\\tfor _, i := range word {\\n\\t\\t\\ts += letters[i - \\'a\\']\\n\\t\\t}\\n\\t\\tm[s]++\\n\\t}\\n\\treturn len(m)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n\\tletters := []string{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\",\\n\\t\\t\".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"}\\n\\tm := make(map[string]int)\\n\\n\\tfor _, word := range words {\\n\\t\\ts := \"\"\\n\\t\\tfor _, i := range word {\\n\\t\\t\\ts += letters[i - \\'a\\']\\n\\t\\t}\\n\\t\\tm[s]++\\n\\t}\\n\\treturn len(m)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991040,
                "title": "o-n-time-o-n-space-easy-solution-using-hashmap",
                "content": "```\\npublic int uniqueMorseRepresentations(String[] words) \\n    {\\n        String[] morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        int count = 0;\\n        HashMap<String,Integer> hash = new HashMap<String,Integer>();\\n        for(String word : words){\\n            char[] chars = word.toCharArray();\\n            String rep = \"\";\\n            for(char c : chars)\\n            {\\n                rep+= morse[c - 97];\\n                \\n            }\\n            if(!hash.containsKey(rep)){\\n                count++;\\n                hash.put(rep,1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```\\n\\nthought i\\'d share my solution. If anyone has any improvements please send them my way!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int uniqueMorseRepresentations(String[] words) \\n    {\\n        String[] morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        int count = 0;\\n        HashMap<String,Integer> hash = new HashMap<String,Integer>();\\n        for(String word : words){\\n            char[] chars = word.toCharArray();\\n            String rep = \"\";\\n            for(char c : chars)\\n            {\\n                rep+= morse[c - 97];\\n                \\n            }\\n            if(!hash.containsKey(rep)){\\n                count++;\\n                hash.put(rep,1);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974860,
                "title": "c-and-python-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        unordered_set<string> unique_transformations;\\n        \\n        for (auto word: words)\\n        {\\n            string curr_transformation = \"\";\\n            for (auto letter: word)\\n            {\\n                curr_transformation += morse_code[letter - \\'a\\'];\\n\\n            }\\n            unique_transformations.insert(curr_transformation);\\n\\n        }\\n            \\n        return unique_transformations.size();\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        unique_transformations = set()\\n        \\n        for word in words:\\n            curr_transformation = \"\"\\n            for letter in word:\\n                curr_transformation += morse_code[ord(letter) - ord(\\'a\\')]\\n            unique_transformations.add(curr_transformation)\\n\\n        return len(unique_transformations)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> morse_code = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        unordered_set<string> unique_transformations;\\n        \\n        for (auto word: words)\\n        {\\n            string curr_transformation = \"\";\\n            for (auto letter: word)\\n            {\\n                curr_transformation += morse_code[letter - \\'a\\'];\\n\\n            }\\n            unique_transformations.insert(curr_transformation);\\n\\n        }\\n            \\n        return unique_transformations.size();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse_code = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        unique_transformations = set()\\n        \\n        for word in words:\\n            curr_transformation = \"\"\\n            for letter in word:\\n                curr_transformation += morse_code[ord(letter) - ord(\\'a\\')]\\n            unique_transformations.add(curr_transformation)\\n\\n        return len(unique_transformations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945604,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        myS=set()\\n        for word in words:\\n            res=\"\"\\n            for c in word:\\n                char=ord(c)\\n                res+=morse[char%97]\\n            myS.add(res)\\n            \\n            \\n        return len(myS)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        morse=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        \\n        myS=set()\\n        for word in words:\\n            res=\"\"\\n            for c in word:\\n                char=ord(c)\\n                res+=morse[char%97]\\n            myS.add(res)\\n            \\n            \\n        return len(myS)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944891,
                "title": "c-99-100-memory-9-liner-crispy-af",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> res;\\n        for (auto word : words) {\\n            string code;\\n            for (auto ch : word) {\\n                code += morse[ch - \\'a\\'];\\n            }\\n            res.insert(code);\\n        }\\n        return res.size();\\n    }\\n};\\n```\\n\\nExplanation -\\n\\n1. Find encoded string and insert in set\\n2. Return set size\\n3. ???\\n4. Profit! \\uD83E\\uDD19\\n\\nAs always,\\n\\uD83E\\uDD19 Stay crispy guys \\uD83E\\uDD19",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string> morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> res;\\n        for (auto word : words) {\\n            string code;\\n            for (auto ch : word) {\\n                code += morse[ch - \\'a\\'];\\n            }\\n            res.insert(code);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828074,
                "title": "java-solution-100-speed-98-memory",
                "content": "Simply create the morsecode and add it to a hashset, which removes any duplicates. Note that we subtract \\'a\\' in order to get the index. To see this, consider \\'a\\' itself. \\'a\\' = 97, or some value in either ASCII, Unicode. \\'a\\' - \\'a\\' will always get us 0. \\'b\\' will be 1 above a, at 98-97 and so on. This will get us 1. Our alphabet is arranged so the 0th item is \\'a\\', 1st item is b, and so on. Hence, we subtract to get the index. \\n```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String> set = new HashSet<>();\\n        for(String word : words){\\n            StringBuilder build = new StringBuilder();\\n            for(int c : word.toCharArray()){\\n                c = c-\\'a\\';\\n                build.append(alphabet[c]);\\n            }\\n            set.add(build.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String[] alphabet = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        HashSet<String> set = new HashSet<>();\\n        for(String word : words){\\n            StringBuilder build = new StringBuilder();\\n            for(int c : word.toCharArray()){\\n                c = c-\\'a\\';\\n                build.append(alphabet[c]);\\n            }\\n            set.add(build.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696527,
                "title": "java-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String dict[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                         \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\\n                         \".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder sb = new StringBuilder(\"\");\\n            char[] str = words[i].toCharArray();\\n            for(char ch : str) sb.append(dict[ch-97]);\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        String dict[] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\\n                         \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\\n                         \".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        Set<String> set = new HashSet<>();\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder sb = new StringBuilder(\"\");\\n            char[] str = words[i].toCharArray();\\n            for(char ch : str) sb.append(dict[ch-97]);\\n            set.add(sb.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652411,
                "title": "javascript-concat-fcn-to-build-strings-store-in-set",
                "content": "Note: In JavaScript, primitive values are immutable so we must use trans = trans.concat to make a copy of the variable and change it.\\n\\n```\\nlet uniqueMorseRepresentations = (words) => {\\n    const ca = \\'a\\'.charCodeAt(0);\\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    let record = new Set();\\n    for (let i in words){\\n        let trans = \"\";\\n        for (let c of words[i])\\n            trans = trans.concat(morse[c.charCodeAt(0)-ca]);\\n        record.add(trans);\\n    }\\n    return record.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet uniqueMorseRepresentations = (words) => {\\n    const ca = \\'a\\'.charCodeAt(0);\\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\\n    let record = new Set();\\n    for (let i in words){\\n        let trans = \"\";\\n        for (let c of words[i])\\n            trans = trans.concat(morse[c.charCodeAt(0)-ca]);\\n        record.add(trans);\\n    }\\n    return record.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549576,
                "title": "object-fromentries-not-working",
                "content": "How come this doesn\\'t work on LeetCode?\\n```\\nRuntime Error\\nLine 9 in solution.js\\n    const dict = Object.freeze(Object.fromEntries([\\n                                      ^\\nTypeError: Object.fromEntries is not a function\\n    Line 9: Char 39 in solution.js \\n```",
                "solutionTags": [],
                "code": "```\\nRuntime Error\\nLine 9 in solution.js\\n    const dict = Object.freeze(Object.fromEntries([\\n                                      ^\\nTypeError: Object.fromEntries is not a function\\n    Line 9: Char 39 in solution.js \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545198,
                "title": "javascript-easy-readable-95-34",
                "content": "```\\nvar getMorseCodeByStr = str => {\\n  const morseMap = {\\n    a: \\'.-\\',\\n    b: \\'-...\\',\\n    c: \\'-.-.\\',\\n    d: \\'-..\\',\\n    e: \\'.\\',\\n    f: \\'..-.\\',\\n    g: \\'--.\\',\\n    h: \\'....\\',\\n    i: \\'..\\',\\n    j: \\'.---\\',\\n    k: \\'-.-\\',\\n    l: \\'.-..\\',\\n    m: \\'--\\',\\n    n: \\'-.\\',\\n    o: \\'---\\',\\n    p: \\'.--.\\',\\n    q: \\'--.-\\',\\n    r: \\'.-.\\',\\n    s: \\'...\\',\\n    t: \\'-\\',\\n    u: \\'..-\\',\\n    v: \\'...-\\',\\n    w: \\'.--\\',\\n    x: \\'-..-\\',\\n    y: \\'-.--\\',\\n    z: \\'--..\\',\\n  };\\n  let result = \\'\\';\\n  \\n  for (let i = 0; i < str.length; i += 1) {\\n    result += morseMap[str[i]];\\n  }\\n  \\n  return result;\\n};\\n\\nvar uniqueMorseRepresentations = function(words) {\\n  const set = new Set();\\n  \\n  for (let i = 0; i < words.length; i += 1) {\\n    set.add(getMorseCodeByStr(words[i]));\\n  }\\n  \\n  return set.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMorseCodeByStr = str => {\\n  const morseMap = {\\n    a: \\'.-\\',\\n    b: \\'-...\\',\\n    c: \\'-.-.\\',\\n    d: \\'-..\\',\\n    e: \\'.\\',\\n    f: \\'..-.\\',\\n    g: \\'--.\\',\\n    h: \\'....\\',\\n    i: \\'..\\',\\n    j: \\'.---\\',\\n    k: \\'-.-\\',\\n    l: \\'.-..\\',\\n    m: \\'--\\',\\n    n: \\'-.\\',\\n    o: \\'---\\',\\n    p: \\'.--.\\',\\n    q: \\'--.-\\',\\n    r: \\'.-.\\',\\n    s: \\'...\\',\\n    t: \\'-\\',\\n    u: \\'..-\\',\\n    v: \\'...-\\',\\n    w: \\'.--\\',\\n    x: \\'-..-\\',\\n    y: \\'-.--\\',\\n    z: \\'--..\\',\\n  };\\n  let result = \\'\\';\\n  \\n  for (let i = 0; i < str.length; i += 1) {\\n    result += morseMap[str[i]];\\n  }\\n  \\n  return result;\\n};\\n\\nvar uniqueMorseRepresentations = function(words) {\\n  const set = new Set();\\n  \\n  for (let i = 0; i < words.length; i += 1) {\\n    set.add(getMorseCodeByStr(words[i]));\\n  }\\n  \\n  return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536814,
                "title": "python-3-set-map-solution-with-explanation-beats-98-61",
                "content": "```\\n## set + map--find all cases\\uFF0Cthen use len(set()) to get number of different cases\\n## Time complexity = O(n)\\uFF0CSpace complexity = O(1)        \\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        moorse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        trans = lambda x: moorse[ord(x) - ord(\\'a\\')]\\n        map_word = lambda word: \\'\\'.join([trans(x) for x in word])\\n        res = map(map_word, words)\\n        return len(set(res))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n## set + map--find all cases\\uFF0Cthen use len(set()) to get number of different cases\\n## Time complexity = O(n)\\uFF0CSpace complexity = O(1)        \\nclass Solution:\\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\\n        moorse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        trans = lambda x: moorse[ord(x) - ord(\\'a\\')]\\n        map_word = lambda word: \\'\\'.join([trans(x) for x in word])\\n        res = map(map_word, words)\\n        return len(set(res))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461805,
                "title": "rust-0ms-functional-solution",
                "content": "```rust\\npub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n\\tconst TABLE: [&str; 26] = [\\n\\t\\t\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n\\t\\t\"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\",\\n\\t];\\n\\twords\\n\\t\\t.iter()\\n\\t\\t.map(|w| w.chars().map(|c| TABLE[c as usize - \\'a\\' as usize]).collect::<String>())\\n\\t\\t.collect::<std::collections::HashSet<_>>()\\n\\t\\t.len() as i32\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn unique_morse_representations(words: Vec<String>) -> i32 {\\n\\tconst TABLE: [&str; 26] = [\\n\\t\\t\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n\\t\\t\"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\",\\n\\t];\\n\\twords\\n\\t\\t.iter()\\n\\t\\t.map(|w| w.chars().map(|c| TABLE[c as usize - \\'a\\' as usize]).collect::<String>())\\n\\t\\t.collect::<std::collections::HashSet<_>>()\\n\\t\\t.len() as i32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361389,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<String>();\\n\\t\\tString[] encodes = { \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n\\t\\t\\t\\t\"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" };\\n\\t\\tfor (String item : words) {\\n\\t\\t\\tString temp = \"\";\\n\\t\\t\\tfor (int i = 0; i < item.length(); i++) {\\n\\t\\t\\t\\ttemp += encodes[item.charAt(i) - \\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tset.add(temp);\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> set = new HashSet<String>();\\n\\t\\tString[] encodes = { \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\\n\\t\\t\\t\\t\"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\" };\\n\\t\\tfor (String item : words) {\\n\\t\\t\\tString temp = \"\";\\n\\t\\t\\tfor (int i = 0; i < item.length(); i++) {\\n\\t\\t\\t\\ttemp += encodes[item.charAt(i) - \\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tset.add(temp);\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338046,
                "title": "javascript-1-2-line-solution-using-set-charcodeat",
                "content": "```\\nvar uniqueMorseRepresentations = function (words) {\\n  const morse = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"];\\n  return [...(new Set(words.map(word => word.split(\"\").map(c => morse[c.charCodeAt() - 97]).join(\"\"))))].length;\\n};",
                "solutionTags": [],
                "code": "```\\nvar uniqueMorseRepresentations = function (words) {\\n  const morse = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"];\\n  return [...(new Set(words.map(word => word.split(\"\").map(c => morse[c.charCodeAt() - 97]).join(\"\"))))].length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 330729,
                "title": "python-code",
                "content": "Runtime: 4 ms, faster than 100.00% of Python online submissions for Unique Morse Code Words.\\nMemory Usage: 11.7 MB, less than 75.08% of Python online submissions for Unique Morse Code Words.\\n\\n\\n```\\n\\t\\tmorse=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        s=[]\\n        for i in words:\\n            a=\\'\\'\\n            for ii in i:\\n                a=a+morse[ord(ii)-97]\\n            if a in s:\\n                continue\\n            else:\\n                s.append(a)\\n        return len(s)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tmorse=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        s=[]\\n        for i in words:\\n            a=\\'\\'\\n            for ii in i:\\n                a=a+morse[ord(ii)-97]\\n            if a in s:\\n                continue\\n            else:\\n                s.append(a)\\n        return len(s)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293028,
                "title": "easy-to-understand-modern-javascript-solution",
                "content": "Most time spent to array => map conversion. Could be done programmatically as well.\\n\\n```js\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst uniqueMorseRepresentations = (words) => {\\n    const set = new Set();\\n    \\n    for (let word of words) {\\n        set.add(toMorse(word));\\n    }\\n    \\n    return set.size\\n};\\n\\nconst toMorse = (word) => {\\n    let result = \\'\\';\\n\\n    for (let char of word) {\\n        result += map.get(char);\\n    }\\n    \\n    return result;\\n}\\n\\nconst map = new Map([\\n  [\\'a\\', \\'.-\\'],\\n  [\\'b\\', \\'-...\\'],\\n  [\\'c\\', \\'-.-.\\'],\\n  [\\'d\\', \\'-..\\'],\\n  [\\'e\\', \\'.\\'],\\n  [\\'f\\', \\'..-.\\'],\\n  [\\'g\\', \\'--.\\'],\\n  [\\'h\\', \\'....\\'],\\n  [\\'i\\', \\'..\\'],\\n  [\\'j\\', \\'.---\\'],\\n  [\\'k\\', \\'-.-\\'],\\n  [\\'l\\', \\'.-..\\'],\\n  [\\'m\\', \\'--\\'],\\n  [\\'n\\', \\'-.\\'],\\n  [\\'o\\', \\'---\\'],\\n  [\\'p\\', \\'.--.\\'],\\n  [\\'q\\', \\'--.-\\'],\\n  [\\'r\\', \\'.-.\\'],\\n  [\\'s\\', \\'...\\'],\\n  [\\'t\\', \\'-\\'],\\n  [\\'u\\', \\'..-\\'],\\n  [\\'v\\', \\'...-\\'],\\n  [\\'w\\', \\'.--\\'],\\n  [\\'x\\', \\'-..-\\'],\\n  [\\'y\\', \\'-.--\\'],\\n  [\\'z\\', \\'--..\\']\\n]);\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```js\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst uniqueMorseRepresentations = (words) => {\\n    const set = new Set();\\n    \\n    for (let word of words) {\\n        set.add(toMorse(word));\\n    }\\n    \\n    return set.size\\n};\\n\\nconst toMorse = (word) => {\\n    let result = \\'\\';\\n\\n    for (let char of word) {\\n        result += map.get(char);\\n    }\\n    \\n    return result;\\n}\\n\\nconst map = new Map([\\n  [\\'a\\', \\'.-\\'],\\n  [\\'b\\', \\'-...\\'],\\n  [\\'c\\', \\'-.-.\\'],\\n  [\\'d\\', \\'-..\\'],\\n  [\\'e\\', \\'.\\'],\\n  [\\'f\\', \\'..-.\\'],\\n  [\\'g\\', \\'--.\\'],\\n  [\\'h\\', \\'....\\'],\\n  [\\'i\\', \\'..\\'],\\n  [\\'j\\', \\'.---\\'],\\n  [\\'k\\', \\'-.-\\'],\\n  [\\'l\\', \\'.-..\\'],\\n  [\\'m\\', \\'--\\'],\\n  [\\'n\\', \\'-.\\'],\\n  [\\'o\\', \\'---\\'],\\n  [\\'p\\', \\'.--.\\'],\\n  [\\'q\\', \\'--.-\\'],\\n  [\\'r\\', \\'.-.\\'],\\n  [\\'s\\', \\'...\\'],\\n  [\\'t\\', \\'-\\'],\\n  [\\'u\\', \\'..-\\'],\\n  [\\'v\\', \\'...-\\'],\\n  [\\'w\\', \\'.--\\'],\\n  [\\'x\\', \\'-..-\\'],\\n  [\\'y\\', \\'-.--\\'],\\n  [\\'z\\', \\'--..\\']\\n]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278164,
                "title": "javascript-89-34",
                "content": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n\\t// Define a set and variable morse (set to empty string);\\n    let morseSet = new Set;\\n    let morse = \"\";\\n    \\n\\t// Define object literal\\n    function decypher(elem) {\\n        var code = {\\n            \"a\": \".-\",\\n            \"b\":\"-...\",\\n            \"c\":\"-.-.\",\\n            \"d\":\"-..\",\\n            \"e\":\".\",\\n            \"f\":\"..-.\",\\n            \"g\":\"--.\",\\n            \"h\":\"....\",\\n            \"i\":\"..\",\\n            \"j\":\".---\",\\n            \"k\":\"-.-\",\\n            \"l\":\".-..\",\\n            \"m\":\"--\",\\n            \"n\":\"-.\",\\n            \"o\":\"---\",\\n            \"p\":\".--.\",\\n            \"q\":\"--.-\",\\n            \"r\":\".-.\",\\n            \"s\":\"...\",\\n            \"t\":\"-\",\\n            \"u\":\"..-\",\\n            \"v\":\"...-\",\\n            \"w\":\".--\",\\n            \"x\":\"-..-\",\\n            \"y\":\"-.--\",\\n            \"z\":\"--..\"\\n        };    \\n        return (code[elem]);\\n    }\\n    \\n\\t// Iterate through each character in each word\\n    for(let i = 0; i < words.length; i++) {\\n        for(let j = 0; j < words[i].length; j++) {\\n            morse += decypher(words[i][j]);\\n        }\\n\\t\\t// Add to set\\n        morseSet.add(morse);\\n\\t\\t\\n\\t\\t// Reset morse variable\\n        morse = \"\";\\n    }\\n\\n\\t// Return size of set \\n    return morseSet.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar uniqueMorseRepresentations = function(words) {\\n    \\n\\t// Define a set and variable morse (set to empty string);\\n    let morseSet = new Set;\\n    let morse = \"\";\\n    \\n\\t// Define object literal\\n    function decypher(elem) {\\n        var code = {\\n            \"a\": \".-\",\\n            \"b\":\"-...\",\\n            \"c\":\"-.-.\",\\n            \"d\":\"-..\",\\n            \"e\":\".\",\\n            \"f\":\"..-.\",\\n            \"g\":\"--.\",\\n            \"h\":\"....\",\\n            \"i\":\"..\",\\n            \"j\":\".---\",\\n            \"k\":\"-.-\",\\n            \"l\":\".-..\",\\n            \"m\":\"--\",\\n            \"n\":\"-.\",\\n            \"o\":\"---\",\\n            \"p\":\".--.\",\\n            \"q\":\"--.-\",\\n            \"r\":\".-.\",\\n            \"s\":\"...\",\\n            \"t\":\"-\",\\n            \"u\":\"..-\",\\n            \"v\":\"...-\",\\n            \"w\":\".--\",\\n            \"x\":\"-..-\",\\n            \"y\":\"-.--\",\\n            \"z\":\"--..\"\\n        };    \\n        return (code[elem]);\\n    }\\n    \\n\\t// Iterate through each character in each word\\n    for(let i = 0; i < words.length; i++) {\\n        for(let j = 0; j < words[i].length; j++) {\\n            morse += decypher(words[i][j]);\\n        }\\n\\t\\t// Add to set\\n        morseSet.add(morse);\\n\\t\\t\\n\\t\\t// Reset morse variable\\n        morse = \"\";\\n    }\\n\\n\\t// Return size of set \\n    return morseSet.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275680,
                "title": "beats-97-85-simple-python-code",
                "content": "```\\nclass Solution:\\t\\n\\tdef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\t   result_letter = \"\"\\n       result_word = []\\n\\t\\t\\n        morse_arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        for word in words:\\n            for letter in word:\\n                result_letter = result_letter +morse_arr[ord(letter)-97]\\n            result_word.append(result_letter)\\n            result_letter = \"\"              \\n               \\n        return(len(set(result_word)))\\n```\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\t\\n\\tdef uniqueMorseRepresentations(self, words: List[str]) -> int:\\n\\t   result_letter = \"\"\\n       result_word = []\\n\\t\\t\\n        morse_arr = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n\\n        for word in words:\\n            for letter in word:\\n                result_letter = result_letter +morse_arr[ord(letter)-97]\\n            result_word.append(result_letter)\\n            result_letter = \"\"              \\n               \\n        return(len(set(result_word)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266684,
                "title": "c-4ms-faster-than-100-and-8-9-mb-less",
                "content": "``` \\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        string code[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        unordered_set<string> temp;\\n        string word;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            word=\"\";\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                word += code[words[i][j]-97];\\n            }\\n            temp.insert(word);\\n        }\\n        return temp.size();\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        string code[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}",
                "codeTag": "Java"
            },
            {
                "id": 244975,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> uniq;\\n        vector<string> abc = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        for(auto word : words){\\n            string trans = \"\";\\n            for(auto c : word){\\n                trans += abc[c - \\'a\\'];\\n            }\\n            uniq.insert(trans);\\n        }\\n        return uniq.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        set<string> uniq;\\n        vector<string> abc = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n\\n        for(auto word : words){\\n            string trans = \"\";\\n            for(auto c : word){\\n                trans += abc[c - \\'a\\'];\\n            }\\n            uniq.insert(trans);\\n        }\\n        return uniq.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201895,
                "title": "0ms-solution-in-c",
                "content": "```\\ntypedef struct {\\n    char len;\\n    char val;\\n} morseCode;\\n\\nmorseCode codeTable[] = {\\n    {2, 2}, /* a .-   10*/\\n    {4, 7}, /* b -... 0111*/\\n    {4, 5}, /* c -.-. 0101 */\\n    {3, 3},\\n    {1, 1},\\n    {4,13},\\n    {3, 1},\\n    {4,15},\\n    {2, 3},\\n    {4, 8},\\n    {3, 2},\\n    {4,11},\\n    {2, 0},\\n    {2, 1},\\n    {3, 0},\\n    {4, 9},\\n    {4, 2},\\n    {3, 5},\\n    {3, 7},\\n    {1, 0},\\n    {3, 6},\\n    {4,14},\\n    {3, 4},\\n    {4, 6},\\n    {4, 4},\\n    {4, 3}\\n};\\n\\ntypedef struct{\\n    int len;\\n    int val;\\n}morseString;\\n\\nmorseString getmorseString(char* s) {\\n    morseString str;\\n    str.len = 0;\\n    str.val = 0;\\n    \\n    char *p = s;\\n    while(*p != \\'\\\\0\\')\\n    {\\n        char c = *p;\\n        if (c < \\'a\\' || c > \\'z\\'){\\n            printf(\"Invalid input *p = %c\\\\n\", c);\\n            p++;\\n            continue;\\n        }\\n        \\n        morseCode code = codeTable[c - \\'a\\']; \\n        str.len += code.len;\\n        str.val = (str.val << (code.len)) + code.val;\\n        p++;\\n    }\\n    \\n    return str;\\n}\\n\\nint uniqueMorseRepresentations(char** words, int wordsSize) {\\n    int result = -1;\\n    morseString stack[100];\\n    \\n    for(int i = 0; i < wordsSize; i++)\\n    {\\n        morseString str = getmorseString(words[i]);\\n        bool foundone = false;\\n        for (int j = 0; j <= result; j++)\\n        {\\n            // check one by one if str in stack\\n            if (stack[j].len == str.len && stack[j].val == str.val) {\\n                foundone = true;\\n                break;\\n            }\\n        }\\n        \\n        if (!foundone)\\n        {\\n            stack[++result] = str;\\n        }\\n    }\\n    \\n    return result + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct {\\n    char len;\\n    char val;\\n} morseCode;\\n\\nmorseCode codeTable[] = {\\n    {2, 2}, /* a .-   10*/\\n    {4, 7}, /* b -... 0111*/\\n    {4, 5}, /* c -.-. 0101 */\\n    {3, 3},\\n    {1, 1},\\n    {4,13},\\n    {3, 1},\\n    {4,15},\\n    {2, 3},\\n    {4, 8},\\n    {3, 2},\\n    {4,11},\\n    {2, 0},\\n    {2, 1},\\n    {3, 0},\\n    {4, 9},\\n    {4, 2},\\n    {3, 5},\\n    {3, 7},\\n    {1, 0},\\n    {3, 6},\\n    {4,14},\\n    {3, 4},\\n    {4, 6},\\n    {4, 4},\\n    {4, 3}\\n};\\n\\ntypedef struct{\\n    int len;\\n    int val;\\n}morseString;\\n\\nmorseString getmorseString(char* s) {\\n    morseString str;\\n    str.len = 0;\\n    str.val = 0;\\n    \\n    char *p = s;\\n    while(*p != \\'\\\\0\\')\\n    {\\n        char c = *p;\\n        if (c < \\'a\\' || c > \\'z\\'){\\n            printf(\"Invalid input *p = %c\\\\n\", c);\\n            p++;\\n            continue;\\n        }\\n        \\n        morseCode code = codeTable[c - \\'a\\']; \\n        str.len += code.len;\\n        str.val = (str.val << (code.len)) + code.val;\\n        p++;\\n    }\\n    \\n    return str;\\n}\\n\\nint uniqueMorseRepresentations(char** words, int wordsSize) {\\n    int result = -1;\\n    morseString stack[100];\\n    \\n    for(int i = 0; i < wordsSize; i++)\\n    {\\n        morseString str = getmorseString(words[i]);\\n        bool foundone = false;\\n        for (int j = 0; j <= result; j++)\\n        {\\n            // check one by one if str in stack\\n            if (stack[j].len == str.len && stack[j].val == str.val) {\\n                foundone = true;\\n                break;\\n            }\\n        }\\n        \\n        if (!foundone)\\n        {\\n            stack[++result] = str;\\n        }\\n    }\\n    \\n    return result + 1;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 185719,
                "title": "python-2-liner",
                "content": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        letters=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set(\"\".join(letters[ord(letter)-ord(\"a\")] for letter in word) for word in words))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        letters=[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        return len(set(\"\".join(letters[ord(letter)-ord(\"a\")] for letter in word) for word in words))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172828,
                "title": "python-3-line-simple-intuitive-pythonic",
                "content": "`zip()` to create `(alphabet-morse)` tuple, `dict()` to construct dictionary mapping. itereate word and letter and apply `join()` to construct string. Throw to `set()` to remove any duplicate and return its `len()` \\n```\\nfrom string import ascii_lowercase\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        \"\"\"\\n        morsecode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        translation = dict(zip(ascii_lowercase,morsecode))\\n        return len(set([\"\".join(translation[letter] for letter in word) for word in words]))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom string import ascii_lowercase\\nclass Solution:\\n    def uniqueMorseRepresentations(self, words):\\n        \"\"\"\\n        \"\"\"\\n        morsecode = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n        translation = dict(zip(ascii_lowercase,morsecode))\\n        return len(set([\"\".join(translation[letter] for letter in word) for word in words]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141987,
                "title": "c-beats-100-100ms-clear-solution",
                "content": "Store the morse code letter representations in an array. \\nAccess that array by getting the index. You get the index by using ASCII math and taking the current letter you want and subtracting \\'a\\'. \\nUse StringBuilder to build the morse code version of the word and throw that into a HashSet.\\n\\n```\\npublic int UniqueMorseRepresentations(string[] words) {\\n        var letters = new string[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        var hash = new HashSet<string>();\\n        \\n        var sb = new StringBuilder();\\n        foreach (var word in words)\\n        {\\n            sb = new StringBuilder();\\n            var r = word.ToCharArray();\\n            for (int i = 0; i < r.Length; i++)\\n            {\\n                sb.Append(letters[r[i]-\\'a\\']);\\n            }\\n            hash.Add(sb.ToString());\\n        }\\n        \\n        return hash.Count;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\npublic int UniqueMorseRepresentations(string[] words) {\\n        var letters = new string[] {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        \\n        var hash = new HashSet<string>();\\n        \\n        var sb = new StringBuilder();\\n        foreach (var word in words)\\n        {\\n            sb = new StringBuilder();\\n            var r = word.ToCharArray();\\n            for (int i = 0; i < r.Length; i++)\\n            {\\n                sb.Append(letters[r[i]-\\'a\\']);\\n            }\\n            hash.Add(sb.ToString());\\n        }\\n        \\n        return hash.Count;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 138396,
                "title": "0ms-golang-solution",
                "content": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n    table := []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n    \\n    result := make(map[string]bool)\\n    for _, w := range words {\\n        var res string\\n        for _, r  := range w {\\n            res += table[unicode.ToLower(r)-\\'a\\']\\n        }\\n        result[res] = true\\n    }\\n    \\n    return len(result)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc uniqueMorseRepresentations(words []string) int {\\n    table := []string{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}\\n    \\n    result := make(map[string]bool)\\n    for _, w := range words {\\n        var res string\\n        for _, r  := range w {\\n            res += table[unicode.ToLower(r)-\\'a\\']\\n        }\\n        result[res] = true\\n    }\\n    \\n    return len(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133135,
                "title": "c-beats-99-7-short-and-simple",
                "content": "```\\nstring decode(string a){\\n    string morse [26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        string temp=\"\";\\n        for(int i = 0;i<a.size();i++){\\n            temp+=morse[int(a[i])-97];     \\n            }\\n            return temp;\\n        }\\n    class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> temp;\\n        for(int i = 0;i<words.size();i++){\\n            words[i]= decode(words[i]);\\n            bool found = false;\\n            for(int j = 0; j<temp.size();j++){\\n                if(words[i]==temp[j]){\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                temp.push_back(words[i]);\\n            }\\n        }\\n        return temp.size();\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstring decode(string a){\\n    string morse [26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        string temp=\"\";\\n        for(int i = 0;i<a.size();i++){\\n            temp+=morse[int(a[i])-97];     \\n            }\\n            return temp;\\n        }\\n    class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        vector<string> temp;\\n        for(int i = 0;i<words.size();i++){\\n            words[i]= decode(words[i]);\\n            bool found = false;\\n            for(int j = 0; j<temp.size();j++){\\n                if(words[i]==temp[j]){\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                temp.push_back(words[i]);\\n            }\\n        }\\n        return temp.size();\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131560,
                "title": "c-bits-99-7-with-no-strings-comparison",
                "content": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<unsigned long> results;\\n        vector<pair<int, unsigned>> alphabet = {{2, 0b01}, {4 ,0b1000}, {4 ,0b1010}, {3 ,0b100}, {1 ,0b0}, {4 ,0b0010}, {3 ,0b110}, {4 ,0b0000}, {2 ,0b00}, {4 ,0b0111}, {3 ,0b101}, {4 ,0b0100}, {2 ,0b11}, {2 ,0b10}, {3 ,0b111}, {4 ,0b0110}, {4 ,0b1101}, {3 ,0b010}, {3 ,0b000}, {1 ,0b1}, {3 ,0b001}, {4 ,0b0001}, {3 ,0b011}, {4 ,0b1001}, {4 ,0b1011}, {4 ,0b1100}};\\n        for(size_t i = 0; i < words.size(); ++i)\\n        {\\n            unsigned long result = 0;\\n            for(size_t j = 0; j < words[i].size(); ++j)\\n            {\\n                auto cur = alphabet[words[i][j] - \\'a\\'];\\n                result = result << cur.first | cur.second;\\n            }\\n            results.insert(result);\\n        }        \\n        return results.size();\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int uniqueMorseRepresentations(vector<string>& words) {\\n        unordered_set<unsigned long> results;\\n        vector<pair<int, unsigned>> alphabet = {{2, 0b01}",
                "codeTag": "Java"
            },
            {
                "id": 125655,
                "title": "ruby-solution-by-a-ruby-noob",
                "content": "```\\n# @param {String[]} words\\n# @return {Integer}\\ndef unique_morse_representations(words)\\n    \\n    letter = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n    morseLetter = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    translation = {}\\n    morseWords = []\\n    \\n    # map each letter to its morse code equivalent\\n    letter.each_with_index {|k,v|translation[k] = morseLetter[v]}\\n\\n    # iterate through words and get morse code translation\\n    words.each{ |word| morseWords << word.split(\"\").map{ |char| translation[char] }.join(\"\") }\\n    \\n    # remove duplicates and return length\\n    return morseWords.uniq.length\\n    \\n    \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String[]} words\\n# @return {Integer}\\ndef unique_morse_representations(words)\\n    \\n    letter = [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n    morseLetter = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\\n    translation = {}\\n    morseWords = []\\n    \\n    # map each letter to its morse code equivalent\\n    letter.each_with_index {|k,v|translation[k] = morseLetter[v]}\\n\\n    # iterate through words and get morse code translation\\n    words.each{ |word| morseWords << word.split(\"\").map{ |char| translation[char] }.join(\"\") }\\n    \\n    # remove duplicates and return length\\n    return morseWords.uniq.length\\n    \\n    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 122225,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> uniqueMorse = new HashSet();\\n        String[] morseCodes = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for(String word: words){\\n            String code=\"\";\\n            for(int i =0; i<word.length();i++){\\n                int n = word.charAt(i) - \\'a\\';\\n                code+=morseCodes[n];\\n            }\\n            uniqueMorse.add(code);\\n        }\\n        return uniqueMorse.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniqueMorseRepresentations(String[] words) {\\n        Set<String> uniqueMorse = new HashSet();\\n        String[] morseCodes = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        for(String word: words){\\n            String code=\"\";\\n            for(int i =0; i<word.length();i++){\\n                int n = word.charAt(i) - \\'a\\';\\n                code+=morseCodes[n];\\n            }\\n            uniqueMorse.add(code);\\n        }\\n        return uniqueMorse.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1775004,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1571919,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1566109,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1566857,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1714477,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1567297,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1569215,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1846798,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1756496,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1573307,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1775004,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1571919,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1566109,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1566857,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1714477,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1567297,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1569215,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1846798,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1756496,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            },
            {
                "id": 1573307,
                "content": [
                    {
                        "username": "abhay30",
                        "content": "Python\\n\\nHere is the dictionary for the morse code\\n\\n `dicti = {\\'a\\':\".-\", \\'b\\':\"-...\", \\'c\\':\"-.-.\", \\'d\\':\"-..\", \\'e\\':\".\", \\'f\\':\"..-.\", \\'g\\':\"--.\", \\'h\\':\"....\", \\'i\\':\"..\", \\'j\\':\".---\", \\'k\\':\"-.-\", \\'l\\':\".-..\", \\'m\\':\"--\",    \\'n\\':\"-.\", \\'o\\':\"---\", \\'p\\':\".--.\", \\'q\\':\"--.-\", \\'r\\':\".-.\", \\'s\\':\"...\", \\'t\\':\"-\", \\'u\\':\"..-\", \\'v\\':\"...-\", \\'w\\':\".--\", \\'x\\':\"-..-\", \\'y\\':\"-.--\", \\'z\\':\"--..\"}` "
                    },
                    {
                        "username": "Snappawapa",
                        "content": "I am missing something here?\\n\\nI see what the goal is, but I am having trouble understanding why two different words would have the same transformation.\\n\\nShouldn\\'t all strings be diffrerent from each other, since there is a 1-1 match between characters and code? Is it that without properly separating the characters, they will actually produce the \\'same\\' morse code?"
                    },
                    {
                        "username": "jc531",
                        "content": "That\\'s correct. Since in this problem the transformed words don\\'t have spaces between the converted morse letters, its possible for two different words to have the same morse sequence.\\n\\nIf you look at the example (copied from the prompt) below, notice that \"gin\" and \"zen\" produce the same morse sequence. Similarly, \"gig\" and \"msg\" also produce the same morse sequence. Given the sequences, the problem is looking for you to find how many unique morse sequences there are. In the below example, there are 2.\\n\\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\\nOutput: 2\\nExplanation: The transformation of each word is:\\n\"gin\" -> \"--...-.\"\\n\"zen\" -> \"--...-.\"\\n\"gig\" -> \"--...--.\"\\n\"msg\" -> \"--...--.\"\\nThere are 2 different transformations: \"--...-.\" and \"--...--.\"."
                    },
                    {
                        "username": "int-i",
                        "content": "The question says \"For example, \"cba\" can be written as **\"-.-..--...\"**, (which is the concatenation \"-.-.\" + \"-...\" + \".-\").\"\\nShouldn\\'t the bold text be **\"-.-.-....-\"** instead ? and isn\\'t the original morse code in the line above the representation of \"cab\" ?\\n\\nThis had me wondering for more than 5 minutes :) and creating overlapping complex cases !\\nCan comeone correct this please ...\\n"
                    },
                    {
                        "username": "liyun1988",
                        "content": "Quote from the description: \"For example, \"cba\" can be written as \"**-.-..--...**\", (which is the concatenation **\"-.-.\" + \"-...\" + \".-\"**).\"\\n\\nHere \"cba\" should be decoded as **\"-.-.-....-\"**"
                    },
                    {
                        "username": "griff_",
                        "content": "for c#\\n\\nhere is the dictionary for easy translation\\n\\n `Dictionary<char, string> code = new Dictionary<char, string>(){`\\n            `{\\'a\\', \".-\"},\\n            {\\'b\\', \"-...\"},\\n            {\\'c\\', \"-.-.\"},\\n            {\\'d\\', \"-..\"},\\n            {\\'e\\', \".\"},\\n            {\\'f\\', \"..-.\"},\\n            {\\'g\\', \"--.\"},\\n            {\\'h\\', \"....\"},\\n            {\\'i\\', \"..\"},\\n            {\\'j\\', \".---\"},\\n            {\\'k\\', \"-.-\"},\\n            {\\'l\\', \".-..\"},\\n            {\\'m\\', \"--\"},\\n            {\\'n\\', \"-.\"},\\n            {\\'o\\', \"---\"},\\n            {\\'p\\', \".--.\"},\\n            {\\'q\\', \"--.-\"},\\n            {\\'r\\', \".-.\"},\\n            {\\'s\\', \"...\"},\\n            {\\'t\\', \"-\"},\\n            {\\'u\\', \"..-\"},\\n            {\\'v\\', \"...-\"},\\n            {\\'w\\', \".--\"},\\n            {\\'x\\', \"-..-\"},\\n            {\\'y\\', \"-.--\"},\\n            {\\'z\\', \"--..\"},\\n        };`"
                    },
                    {
                        "username": "liuheng92",
                        "content": "cab sample is wrong"
                    },
                    {
                        "username": "dreamjjy",
                        "content": "Actually in the description the morse of \\'cab\\' is \\'cba\\'... it misled me and made me think the sequence of chars can be changed. Hope it can be repaired!"
                    },
                    {
                        "username": "sindy",
                        "content": "Testcase [\"rwjje\",\"aittjje\",\"auyyn\",\"lqtktn\",\"lmjwn\"]. All strings have same morse code \".-..--.---.---.\". Why the expected value is 1?"
                    },
                    {
                        "username": "Tiago14",
                        "content": " If all are the same then you have only one case"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: For any problem asking number of distinguish element in a list, a set is a good candidate :-) "
                    },
                    {
                        "username": "TimothyLiu",
                        "content": "In the description, it says ***Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We\\'ll call such a concatenation, the transformation of a word.***\\n\\nI feel the \"cba\" should be \"cab\". Am I correct?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Chunked Palindrome Decomposition",
        "question_content": "<p>You are given a string <code>text</code>. You should split it to k substrings <code>(subtext<sub>1</sub>, subtext<sub>2</sub>, ..., subtext<sub>k</sub>)</code> such that:</p>\n\n<ul>\n\t<li><code>subtext<sub>i</sub></code> is a <strong>non-empty</strong> string.</li>\n\t<li>The concatenation of all the substrings is equal to <code>text</code> (i.e., <code>subtext<sub>1</sub> + subtext<sub>2</sub> + ... + subtext<sub>k</sub> == text</code>).</li>\n\t<li><code>subtext<sub>i</sub> == subtext<sub>k - i + 1</sub></code> for all valid values of <code>i</code> (i.e., <code>1 &lt;= i &lt;= k</code>).</li>\n</ul>\n\n<p>Return the largest possible value of <code>k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;merchant&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can split the string on &quot;(merchant)&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;antaprezatepzapreanta&quot;\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> We can split the string on &quot;(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code> consists only of lowercase English characters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 350560,
                "title": "java-c-python-easy-greedy-with-prove",
                "content": "## **Intuition**\\nHonestly I wrote a DP solution first, to ensure it get accepted.\\nThen I realized greedy solution is right.\\n\\nGive a quick prove here.\\nIf we have long prefix matched and a shorter prefix matched at the same time.\\nThe longer prefix can always be divided in to smaller part.\\n\\n![image](https://assets.leetcode.com/users/lee215/image_1564892108.png)\\n\\nAssume we have a longer blue matched and a shorter red matched.\\nAs definition of the statement, we have `B1 = B2, R1 = R4`.\\n\\nBecause `B1 = B2`,\\nthe end part of `B1` = the end part of `B2`,\\nequal to `R2 = R4`,\\nSo we have `R1 = R4 = R2`.\\n\\n`B` is in a pattern of `R` + middle part + `R`.\\nInstead take a longer `B` with 1 point,\\nwe can cut it in to 3 parts to gain more points.\\n\\nThis proves that greedily take shorter matched it right.\\nNote that the above diagram shows cases when `shorter length <= longer length/ 2`\\nWhen `shorter length > longer length/ 2`, this conclusion is still correct.\\n<br>\\n\\nTo be more general,\\nthe longer prefix and shorter prefix will alway be in these patter:\\n\\n`longer = a + ab * N`\\n`shorter = a + ab * (N - 1)`\\n\\nfor example:\\nlonger = `\"abc\" + \"def\" + \"abc\"`\\nshorter = `\"abc\"`\\n\\nfor example:\\nlonger = `\"abc\" * M`\\nshorter = `\"abc\" * N`\\nwhere `M > N`\\n<br>\\n\\n## **Solution 1, very brute force**\\nWhen we know the greedy solution is right,\\nthe coding is easier.\\nJust take letters from the left and right side,\\nWhenever they match, `res++`.\\n<br>\\n\\n## **Complexity**\\nI just very brute force generate new string and loop the whole string.\\nComplexity can be improve on these two aspects.\\nPardon that I choose the concise over the performance.\\n\\nTime `O(N) * O(string)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int longestDecomposition(String S) {\\n        int res = 0, n = S.length();\\n        String l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S.charAt(i);\\n            r = S.charAt(n - i - 1) + r;\\n            if (l.equals(r)) {\\n                ++res;\\n                l = \"\";\\n                r = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int longestDecomposition(string S) {\\n        int res = 0, n = S.length();\\n        string l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S[i], r = S[n - i - 1] + r;\\n            if (l == r)\\n                ++res, l = \"\", r = \"\";\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def longestDecomposition(self, S):\\n        res, l, r = 0, \"\", \"\"\\n        for i, j in zip(S, S[::-1]):\\n            l, r = l + i, j + r\\n            if l == r:\\n                res, l, r = res + 1, \"\", \"\"\\n        return res\\n```\\n<br>\\n\\n## **Solution 2, Tail Recursion**\\nSame idea, just apply tail recursion.\\nAnd add a quick check before we slice the string.\\n<br>\\n**C++:**\\n```cpp\\n    int longestDecomposition(string S, int res = 0) {\\n        int n = S.length();\\n        for (int l = 1; l <= n / 2; ++l)\\n            if (S[0] == S[n - l] && S[l - 1] == S[n - 1])\\n                if (S.substr(0, l) == S.substr(n - l))\\n                    return longestDecomposition(S.substr(l, n - l - l), res + 2);\\n        return n ? res + 1 : res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def longestDecomposition(self, S, res=0):\\n        n = len(S)\\n        for l in xrange(1, n / 2 + 1):\\n            if S[0] == S[n - l] and S[l - 1] == S[n - 1]:\\n                if S[:l] == S[n - l:]:\\n                    return self.longestDecomposition(S[l:n - l], res + 2)\\n        return res + 1 if S else res\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int longestDecomposition(String S) {\\n        int res = 0, n = S.length();\\n        String l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S.charAt(i);\\n            r = S.charAt(n - i - 1) + r;\\n            if (l.equals(r)) {\\n                ++res;\\n                l = \"\";\\n                r = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int longestDecomposition(string S) {\\n        int res = 0, n = S.length();\\n        string l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S[i], r = S[n - i - 1] + r;\\n            if (l == r)\\n                ++res, l = \"\", r = \"\";\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def longestDecomposition(self, S):\\n        res, l, r = 0, \"\", \"\"\\n        for i, j in zip(S, S[::-1]):\\n            l, r = l + i, j + r\\n            if l == r:\\n                res, l, r = res + 1, \"\", \"\"\\n        return res\\n```\n```cpp\\n    int longestDecomposition(string S, int res = 0) {\\n        int n = S.length();\\n        for (int l = 1; l <= n / 2; ++l)\\n            if (S[0] == S[n - l] && S[l - 1] == S[n - 1])\\n                if (S.substr(0, l) == S.substr(n - l))\\n                    return longestDecomposition(S.substr(l, n - l - l), res + 2);\\n        return n ? res + 1 : res;\\n    }\\n```\n```python\\n    def longestDecomposition(self, S, res=0):\\n        n = len(S)\\n        for l in xrange(1, n / 2 + 1):\\n            if S[0] == S[n - l] and S[l - 1] == S[n - 1]:\\n                if S[:l] == S[n - l:]:\\n                    return self.longestDecomposition(S[l:n - l], res + 2)\\n        return res + 1 if S else res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 350762,
                "title": "java-0ms-concise-beats-100-both-time-and-memory-with-algo",
                "content": "Traverse from 0 to n/2 to find the smallest left side chunk and right side chunk which are equal.\\nOnce you find it(\\uD83E\\uDDD2 \\uD83D\\uDC64.........\\uD83D\\uDC64 \\uD83E\\uDDD2), add 2\\xA0(\\uD83E\\uDDD2\\uD83E\\uDDD2) to solution and then recursively call the function for remaining string(\\uD83D\\uDC64..........\\uD83D\\uDC64 ).\\nTerminating conditions:\\na. Either string will be empty : return 0 \\nb. Or there are no more equal right and left chunks left (just a single lonely chunk \\uD83D\\uDE47\\u200D\\u2642\\uFE0F ): return 1\\n\\n```\\n public int longestDecomposition(String text) {\\n        int n = text.length();   \\n        for (int i = 0; i < n/2; i++) \\n            if (text.substring(0, i + 1).equals(text.substring(n-1-i, n))) \\n                return 2+longestDecomposition(text.substring(i+1, n-1-i));\\n        return (n==0)?0:1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n public int longestDecomposition(String text) {\\n        int n = text.length();   \\n        for (int i = 0; i < n/2; i++) \\n            if (text.substring(0, i + 1).equals(text.substring(n-1-i, n))) \\n                return 2+longestDecomposition(text.substring(i+1, n-1-i));\\n        return (n==0)?0:1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350711,
                "title": "close-to-o-n-python-rabin-karp-algorithm-with-two-pointer-technique-with-explanation-40ms",
                "content": "[Important edit: I stand corrected. This algorithm isn\\'t actually O(n), technically it\\'s O(n^2). But in practice, it\\'s very close to O(n), and will achieve substantially better performance than the more traditional O(n^2) approaches. In terms of real world performance/ progamming competitions, just pick a good big prime number and it\\'ll scale more like an O(n) algorithm, achieving the ultimate objective of fastness. :-) Thanks to those who pointed out the incorrectness in my analysis!]\\n\\nThe Rabin-Karp algorithm seems perfect for this situation, so it is the approach I took.\\n\\nhttps://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm\\n\\nSee code comments for an explanation of how it works. In essence, we keep track of a hash of the current substring at the start and the end of the string. **After the code I provide a few examples of the math and the ideas in the algorithm.**\\n\\nThis algorithm is **O(n)**, as we are only processing each character once, and we\\'re not doing costly string comparing operations (remember, comparing 2 strings of length n has a cost of O(n), which would bring an algorithm depending on it up to O(n^2)). \\n\\n```py\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        \\n\\t\\t# Used a prime number generator on the internet to grab a prime number to use.\\n        magic_prime = 32416189573\\n        \\n\\t\\t# Standard 2 pointer technique variables.\\n        low = 0\\n        high = len(text) - 1\\n        \\n\\t\\t# These are the hash tracking variables.\\n\\t\\tcur_low_hash = 0\\n        cur_high_hash = 0\\n        cur_hash_length = 0\\n        \\n\\t\\t# This is the number of parts we\\'ve found, i.e. the k value we need to return.\\n\\t\\tk = 0\\n        \\n        while low < high:\\n            \\n\\t\\t\\t# To put the current letter onto our low hash (i.e. the one that goes forward from\\n\\t\\t\\t# the start of the string, we shift up the existing hash by multiplying by the base\\n\\t\\t\\t# of 26, and then adding on the new character by converting it to a number from 0 - 25.\\n            cur_low_hash *= 26 # Shift up by the base of 26.\\n            cur_low_hash += ord(text[low]) - 97 # Take away 97 so that it\\'s between 0 and 25.\\n            \\n\\t\\t\\t\\n\\t\\t\\t# The high one, i.e. the one backwards from the end is a little more complex, as we want the \\n\\t\\t\\t# hash to represent the characters in forward order, not backwards. If we did the exact same\\n\\t\\t\\t# thing we did for low, the string abc would be represented as cba, which is not right.\\t\\n\\t\\t\\t\\n\\t\\t\\t# Start by getting the character\\'s 0 - 25 number.\\n\\t\\t\\thigh_char = ord(text[high]) - 97\\n\\t\\t\\t\\n\\t\\t\\t# The third argument to pow is modular arithmetic. It says to give the answer modulo the\\n\\t\\t\\t# magic prime (more on that below). Just pretend it isn\\'t doing that for now if it confuses you. \\n            # What we\\'re doing is making an int that puts the high character at the top, and then the \\n\\t\\t\\t# existing hash at the bottom.\\n\\t\\t\\tcur_high_hash = (high_char * pow(26, cur_hash_length, magic_prime)) + cur_high_hash            \\n            \\n\\t\\t\\t# Mathematically, we can safely do this. Impressive, huh? I\\'m not going to go into here, but\\n\\t\\t\\t# I recommend studying up on modular arithmetic if you\\'re confused.\\n\\t\\t\\t# The algorithm would be correct without doing this, BUT it\\'d be very slow as the numbers could\\n\\t\\t\\t# become tens of thousands of bits long. The problem with that of course is that comparing the\\n\\t\\t\\t# numbers would no longer be O(1) constant. So we need to keep them small.\\n\\t\\t\\tcur_low_hash %= magic_prime \\n            cur_high_hash %= magic_prime\\n            \\n\\t\\t\\t# And now some standard 2 pointer technique stuff.\\n            low += 1\\n            high -= 1\\n            cur_hash_length += 1\\n            \\n\\t\\t\\t# This piece of code checks if we currently have a match.\\n            # This is actually probabilistic, i.e. it is possible to get false positives.\\n            # For correctness, we should be verifying that this is actually correct.\\n            # We would do this by ensuring the characters in each hash (using\\n\\t\\t\\t# the low, high, and length variables we\\'ve been tracking) are\\n\\t\\t\\t# actually the same. But here I didn\\'t bother as I figured Leetcode\\n\\t\\t\\t# would not have a test case that broke my specific prime.\\n\\t\\t\\tif cur_low_hash == cur_high_hash:\\n                k += 2 # We have just added 2 new strings to k.\\n                # And reset our hashing variables.\\n\\t\\t\\t\\tcur_low_hash = 0\\n                cur_high_hash = 0\\n                cur_hash_length = 0\\n        \\n\\t\\t# At the end, there are a couple of edge cases we need to address....\\n\\t\\t# The first is if there is a middle character left.\\n\\t\\t# The second is a non-paired off string in the middle.\\n        if (cur_hash_length == 0 and low == high) or cur_hash_length > 0:\\n            k += 1\\n        \\n        return k\\n```\\n\\n# Representing a number as an integer.\\nWe can represent a string of lower case letters as a base-26 number. Each letter is assigned a value from 0 to 25, and then each letter is the string is converted into its number and multiplied by a power of the base, based on its position. The numbers are then added together. For example, the string \"cat\":\\nc = 2\\na = 0\\nt = 19\\n\\nnumber_for(\"cat\") => (26 ^ 2) * 2 + (26 ^ 1) * 0 + (26 ^ 0) * 19\\n\\nThis is very much like how numbers are converted from base 2 to base 10.\\n\\n# Keeping track of rolling hashes.\\nThe good thing about representing strings as a number is that it\\'s very easy to add and remove characters from each end of the string, allowing us to maintain a \"rolling hash\" in O(n) time.\\n\\nSo say we have the string \"foxyfox\".\\'\\nf = 5\\no = 14\\nx = 23\\ny = 24\\n\\nThe low hash will build up as follows.\\n\\nFirst letter: f\\nlower_hash = 5\\n\\nSecond letter: o\\nSo we multiply lower_hash by 26 and then add 14 (the number for \"o\").\\n5 * 26 = 130\\n130 + 14 = 144\\nSo we now have lower_hash = 144\\n\\nThird letter: x\\nSo we multply lower_hash by 26 and then add 23 (the number for \"x\").\\n144 * 26 = 3744\\n3744 + 23 = 3767\\nSo now we have lower_hash = 3767\\n\\nAnd at the same time, the high hash is building up.\\n\\nFirst letter: x\\nhigh_hash = 23\\n\\nSecond letter: o\\nBecause we want the o \"above\" the x in the hash, we need to do this a bit differently to before.\\n14 * (26 ** 1) = 364 (\"Slide up\" the new number making room for the old below).\\n364 + 23 = 387 (Add the old hash on)\\nhigh_hash = 387\\n\\nThird letter: f\\n5 * (26 ** 2) = 3380 (Slide up the new number)\\n3380 + 387 = 3767\\n\\nNow you might notice that when we add f->o->x onto the low high, and x->o->f onto the high hash, we end up with the same value: 3767. This is good, because it tells us we have a match. And it could be done in O(n) time.\\n\\n# Throwing modular arithmetic in\\nThere is one problem with this approach though. What if the strings are *massive*. How many bits are there in a 1000 letter string? We are multiplying by 26 for every letter, so that is 26^1000, a very massive number. Comparing 2 numbers of this size is NOT O(1) anymore. \\n\\nIt turns out that we can take it modulo a large prime number at each step of the algorithm. I\\'m not going to go into that here, but I recommend reading up on modular arithmetic if you\\'re confused.\\n# Resolving the potential bug\\nSo there is one potential problem. It\\'s possible for the hashes to be equal even if the strings weren\\'t. This is more likely to happen with a smaller prime number.\\n\\nFor example, if our prime was 7, then that would mean the hash could only ever be 0, 1, 2, 3, 4, 5, or 6. \"a\" would be 0, and so would \"h\", so the algorithm would give a false positive match.\\n\\nWith a much higher prime number, it becomes increasingly less likely. This is how I protected against it in the contest.\\n\\nBut the correct way would be, each time we get a match, to also check the actual strings. As long as we are getting far fewer false positives than true positives, it will still be O(n) overall. A high enough prime will keep the number of false positives low.\\n\\nWith lots of collisons though, it will become O(n^2). Think about what would happen if our prime was 2.\\n\\nThis is a classic hashing collision problem.",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```py\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        \\n\\t\\t# Used a prime number generator on the internet to grab a prime number to use.\\n        magic_prime = 32416189573\\n        \\n\\t\\t# Standard 2 pointer technique variables.\\n        low = 0\\n        high = len(text) - 1\\n        \\n\\t\\t# These are the hash tracking variables.\\n\\t\\tcur_low_hash = 0\\n        cur_high_hash = 0\\n        cur_hash_length = 0\\n        \\n\\t\\t# This is the number of parts we\\'ve found, i.e. the k value we need to return.\\n\\t\\tk = 0\\n        \\n        while low < high:\\n            \\n\\t\\t\\t# To put the current letter onto our low hash (i.e. the one that goes forward from\\n\\t\\t\\t# the start of the string, we shift up the existing hash by multiplying by the base\\n\\t\\t\\t# of 26, and then adding on the new character by converting it to a number from 0 - 25.\\n            cur_low_hash *= 26 # Shift up by the base of 26.\\n            cur_low_hash += ord(text[low]) - 97 # Take away 97 so that it\\'s between 0 and 25.\\n            \\n\\t\\t\\t\\n\\t\\t\\t# The high one, i.e. the one backwards from the end is a little more complex, as we want the \\n\\t\\t\\t# hash to represent the characters in forward order, not backwards. If we did the exact same\\n\\t\\t\\t# thing we did for low, the string abc would be represented as cba, which is not right.\\t\\n\\t\\t\\t\\n\\t\\t\\t# Start by getting the character\\'s 0 - 25 number.\\n\\t\\t\\thigh_char = ord(text[high]) - 97\\n\\t\\t\\t\\n\\t\\t\\t# The third argument to pow is modular arithmetic. It says to give the answer modulo the\\n\\t\\t\\t# magic prime (more on that below). Just pretend it isn\\'t doing that for now if it confuses you. \\n            # What we\\'re doing is making an int that puts the high character at the top, and then the \\n\\t\\t\\t# existing hash at the bottom.\\n\\t\\t\\tcur_high_hash = (high_char * pow(26, cur_hash_length, magic_prime)) + cur_high_hash            \\n            \\n\\t\\t\\t# Mathematically, we can safely do this. Impressive, huh? I\\'m not going to go into here, but\\n\\t\\t\\t# I recommend studying up on modular arithmetic if you\\'re confused.\\n\\t\\t\\t# The algorithm would be correct without doing this, BUT it\\'d be very slow as the numbers could\\n\\t\\t\\t# become tens of thousands of bits long. The problem with that of course is that comparing the\\n\\t\\t\\t# numbers would no longer be O(1) constant. So we need to keep them small.\\n\\t\\t\\tcur_low_hash %= magic_prime \\n            cur_high_hash %= magic_prime\\n            \\n\\t\\t\\t# And now some standard 2 pointer technique stuff.\\n            low += 1\\n            high -= 1\\n            cur_hash_length += 1\\n            \\n\\t\\t\\t# This piece of code checks if we currently have a match.\\n            # This is actually probabilistic, i.e. it is possible to get false positives.\\n            # For correctness, we should be verifying that this is actually correct.\\n            # We would do this by ensuring the characters in each hash (using\\n\\t\\t\\t# the low, high, and length variables we\\'ve been tracking) are\\n\\t\\t\\t# actually the same. But here I didn\\'t bother as I figured Leetcode\\n\\t\\t\\t# would not have a test case that broke my specific prime.\\n\\t\\t\\tif cur_low_hash == cur_high_hash:\\n                k += 2 # We have just added 2 new strings to k.\\n                # And reset our hashing variables.\\n\\t\\t\\t\\tcur_low_hash = 0\\n                cur_high_hash = 0\\n                cur_hash_length = 0\\n        \\n\\t\\t# At the end, there are a couple of edge cases we need to address....\\n\\t\\t# The first is if there is a middle character left.\\n\\t\\t# The second is a non-paired off string in the middle.\\n        if (cur_hash_length == 0 and low == high) or cur_hash_length > 0:\\n            k += 1\\n        \\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350589,
                "title": "python-simple-dp",
                "content": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.memo = {}\\n        def dp(i,j):\\n            if i > j:\\n                return 0\\n            if i == j:\\n                return 1\\n            if (i,j) not in self.memo:\\n                k = 0\\n                tmp = 1\\n                while i+k< j-k:\\n                    if text[i:i+k+1] == text[j-k:j+1]:\\n                        tmp = max(tmp,2+dp(i+k+1,j-k-1))\\n                    k += 1\\n                self.memo[(i,j)] = tmp\\n            return self.memo[(i,j)]\\n        return dp(0,len(text)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.memo = {}\\n        def dp(i,j):\\n            if i > j:\\n                return 0\\n            if i == j:\\n                return 1\\n            if (i,j) not in self.memo:\\n                k = 0\\n                tmp = 1\\n                while i+k< j-k:\\n                    if text[i:i+k+1] == text[j-k:j+1]:\\n                        tmp = max(tmp,2+dp(i+k+1,j-k-1))\\n                    k += 1\\n                self.memo[(i,j)] = tmp\\n            return self.memo[(i,j)]\\n        return dp(0,len(text)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408184,
                "title": "java-rolling-hash-solution",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int count = 0;\\n        int i = 0, j = text.length() - 1;\\n        long h1 = 0, h2 = 0;\\n        long base1 = 26, base2 = 1;\\n        \\n        while (i <= j) {\\n            char c1 = text.charAt(i), c2 = text.charAt(j);\\n            h1 = h1 * base1 + (c1 - \\'a\\' + 1);\\n            h2 = h2 + (c2 - \\'a\\' + 1) * base2;\\n            base2 *= base1;\\n            if (h1 == h2) {\\n                if (i == j) count += 1;\\n                else count += 2;\\n                h1 = 0;\\n                h2 = 0;\\n                base2 = 1;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if (h1 != 0) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int count = 0;\\n        int i = 0, j = text.length() - 1;\\n        long h1 = 0, h2 = 0;\\n        long base1 = 26, base2 = 1;\\n        \\n        while (i <= j) {\\n            char c1 = text.charAt(i), c2 = text.charAt(j);\\n            h1 = h1 * base1 + (c1 - \\'a\\' + 1);\\n            h2 = h2 + (c2 - \\'a\\' + 1) * base2;\\n            base2 *= base1;\\n            if (h1 == h2) {\\n                if (i == j) count += 1;\\n                else count += 2;\\n                h1 = 0;\\n                h2 = 0;\\n                base2 = 1;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if (h1 != 0) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003924,
                "title": "c-o-n-with-queue-and-stack-0ms-beats-100",
                "content": "```\\nint longestDecomposition(string text) {\\n        int res = 0;\\n        int l = 0, r = text.length() - 1;\\n        stack<int> s;\\n        queue<int> q;\\n        while (l < r) {\\n            s.push(text[l++]);\\n            q.push(text[r--]);\\n            while (!s.empty() && s.top() == q.front()) {\\n                q.pop();\\n                s.pop();\\n            }\\n            if (s.empty())\\n                res += l <= r ? 2 : 1;\\n        }\\n        return res + 1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nint longestDecomposition(string text) {\\n        int res = 0;\\n        int l = 0, r = text.length() - 1;\\n        stack<int> s;\\n        queue<int> q;\\n        while (l < r) {\\n            s.push(text[l++]);\\n            q.push(text[r--]);\\n            while (!s.empty() && s.top() == q.front()) {\\n                q.pop();\\n                s.pop();\\n            }\\n            if (s.empty())\\n                res += l <= r ? 2 : 1;\\n        }\\n        return res + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2913599,
                "title": "easy-two-pointer-0-ms-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe shall greedily form the smallest substrings that are equal on both sides.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use two pointer approach and maintain two strings(A & B) to keep track. The moment they become equal, we count it as one partition and increment out answer by 1.\\n\\n\\nNow there can be two cases possible. We can either have our whole string partitioned into either side like (S1)(S2)(S2)(S1) or a string may exist in middle i.e. S gets partitioned  in the form (S1)(S2)(S3)(S2)(S1)\\n\\nTo check for that, we just need to see if before two pointer loop\\nended, whether we had string A as empty or not. If it was non-empty, we can be sure that a string exists in the middle. However even in case of non-empty string, the loop might have ended at i=j (i<j was used instead of i<=j in order to avoid counting abcba as (abc)(cba)).\\n\\nFeel free to clarify any doubts, I would be happy to help.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n), where n=length of string; We only need to traverse the whole string once, and perform appened operation using assignment operator(which is also O(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n=length of string; Since we will be storing complete string in two halves in the worst case.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        string a,b;\\n        int i=0,j=text.size()-1,ans=0;\\n\\n        while(i<j)\\n        {\\n            //Appending characters from start and end\\n            a+=text[i];\\n            b=text[j]+b;\\n\\n            if(a==b)\\n            {\\n                ans++;\\n                a=\"\";\\n                b=\"\";\\n            }\\n            i++;\\n            j--;\\n        }\\n\\n        //We incremented answer by 1, but actually got two strings; so multiply answer by 2.\\n        ans*=2;\\n\\n        //If no string exists in middle, we can directly return answer.\\n        if(a==\"\" and i>j)\\n            return ans;\\n        //Account for the string in the middle\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        string a,b;\\n        int i=0,j=text.size()-1,ans=0;\\n\\n        while(i<j)\\n        {\\n            //Appending characters from start and end\\n            a+=text[i];\\n            b=text[j]+b;\\n\\n            if(a==b)\\n            {\\n                ans++;\\n                a=\"\";\\n                b=\"\";\\n            }\\n            i++;\\n            j--;\\n        }\\n\\n        //We incremented answer by 1, but actually got two strings; so multiply answer by 2.\\n        ans*=2;\\n\\n        //If no string exists in middle, we can directly return answer.\\n        if(a==\"\" and i>j)\\n            return ans;\\n        //Account for the string in the middle\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 547826,
                "title": "c-solution-rolling-hash-with-comments",
                "content": "```\\nclass Solution {\\n    const int Mod = int(1e9) + 123; // prime mod of polynomial hashing\\n    const int Base = 26;\\n    \\n    int helper(const string& s, int l, int r) {\\n        if (l >= r)\\n            return 0;\\n        // use rolling/polynomial hashes for prefix and suffix substrings\\n        long long prefix_hash = 0;\\n        long long suffix_hash = 0;\\n        long long pow = 1;\\n        for (int i = 0; i < (r - l) / 2; ++i) {\\n            // update hashes with the next letter\\n            prefix_hash = (prefix_hash + (s[l + i] - \\'a\\') * pow) % Mod;\\n            suffix_hash = (suffix_hash * Base + (s[r - i - 1] - \\'a\\')) % Mod;\\n            pow = (pow * Base) % Mod;\\n            // perform the expensive string check only for the equal hashes\\n            if (prefix_hash == suffix_hash) {\\n                if (s.substr(l, i + 1) == s.substr(r - i - 1, i + 1)) {\\n                    return 2 + helper(s, l + i + 1, r - i - 1);   \\n                }\\n            }\\n        }\\n        // there is no equal chunks\\n        return 1;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        return helper(text, 0, text.size());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int Mod = int(1e9) + 123; // prime mod of polynomial hashing\\n    const int Base = 26;\\n    \\n    int helper(const string& s, int l, int r) {\\n        if (l >= r)\\n            return 0;\\n        // use rolling/polynomial hashes for prefix and suffix substrings\\n        long long prefix_hash = 0;\\n        long long suffix_hash = 0;\\n        long long pow = 1;\\n        for (int i = 0; i < (r - l) / 2; ++i) {\\n            // update hashes with the next letter\\n            prefix_hash = (prefix_hash + (s[l + i] - \\'a\\') * pow) % Mod;\\n            suffix_hash = (suffix_hash * Base + (s[r - i - 1] - \\'a\\')) % Mod;\\n            pow = (pow * Base) % Mod;\\n            // perform the expensive string check only for the equal hashes\\n            if (prefix_hash == suffix_hash) {\\n                if (s.substr(l, i + 1) == s.substr(r - i - 1, i + 1)) {\\n                    return 2 + helper(s, l + i + 1, r - i - 1);   \\n                }\\n            }\\n        }\\n        // there is no equal chunks\\n        return 1;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        return helper(text, 0, text.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593030,
                "title": "python-2-pointers-approach-o-n-t-o-1-s-explained-with-comments",
                "content": "```\\n    def longestDecomposition(self, text: str) -> int:\\n        i = count = 0\\n        j = len(text) - 1\\n        stop = len(text)\\n        \\n        while j >= i:\\n            # Keep decrementing j until we find a letter equal to text[i]\\n            while (j > i) and (text[j] != text[i]):\\n                j -= 1\\n                \\n            # If i becomes equal to j, we know that there is only one substring that we can add\\n            # We add that to the count and decrement j to break the loop\\n            if i == j:\\n                count += 1\\n                j -= 1\\n            \\n            else:\\n                # We keep the temp variables for the case where text[i] != text[j]; we will be able to reset the values of i and j using them\\n                temp_i = i\\n                temp_j = j\\n                # stop keeps track of the beginning of the previous substring\\n                while j < stop:\\n                    if text[i] == text[j]:\\n                        i += 1\\n                        j += 1\\n                    else:\\n                        i = temp_i\\n                        j = temp_j - 1\\n                        break\\n                        \\n                # This part is executed only if all the cases of text[i] == text[j] were true\\n                else:\\n                    count += 2\\n                    stop -= (i - temp_i)\\n                    j = stop - 1\\n                    \\n        return count\\n```\\nPlease upvote if you liked the solution :)",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n    def longestDecomposition(self, text: str) -> int:\\n        i = count = 0\\n        j = len(text) - 1\\n        stop = len(text)\\n        \\n        while j >= i:\\n            # Keep decrementing j until we find a letter equal to text[i]\\n            while (j > i) and (text[j] != text[i]):\\n                j -= 1\\n                \\n            # If i becomes equal to j, we know that there is only one substring that we can add\\n            # We add that to the count and decrement j to break the loop\\n            if i == j:\\n                count += 1\\n                j -= 1\\n            \\n            else:\\n                # We keep the temp variables for the case where text[i] != text[j]; we will be able to reset the values of i and j using them\\n                temp_i = i\\n                temp_j = j\\n                # stop keeps track of the beginning of the previous substring\\n                while j < stop:\\n                    if text[i] == text[j]:\\n                        i += 1\\n                        j += 1\\n                    else:\\n                        i = temp_i\\n                        j = temp_j - 1\\n                        break\\n                        \\n                # This part is executed only if all the cases of text[i] == text[j] were true\\n                else:\\n                    count += 2\\n                    stop -= (i - temp_i)\\n                    j = stop - 1\\n                    \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 350625,
                "title": "java-4-line-solution-1-ms-100",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        for(int i = 1; i<=text.length()/2; i++)\\n            if(text.substring(0, i).equals(text.substring(text.length()-i, text.length())))\\n                return 2 + longestDecomposition(text.substring(i, text.length()-i));\\n        return text.length() == 0 ? 0 : 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        for(int i = 1; i<=text.length()/2; i++)\\n            if(text.substring(0, i).equals(text.substring(text.length()-i, text.length())))\\n                return 2 + longestDecomposition(text.substring(i, text.length()-i));\\n        return text.length() == 0 ? 0 : 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359555,
                "title": "no-code-proof-of-correctness-for-greedy-break-off-shortest-prefix-suffix-continue-approach",
                "content": "(I hope this proof might help some people understand the greedy strategy)\\n\\nLet s be the shortest nontrivial word which is both a prefix and suffix of *text*.\\nSuppose there is a longer word which is also a prefix and suffix of *text*: it is, like s, a prefix of *text*, so we can write this longer word as a concatenation, st, where t is a nontrivial word. So\\n```\\ntext = sWs = stVst\\n```\\nwhere W, V are the remaining \"middles\".\\n\\n **Claim**: longestDecomposition(W)>=longestDecomposition(V). Note this would justify the use of a greedy algorithm. \\n **Proof:** We consider two cases:\\n Case (i) If len(t)>=len(s), then s must be a suffix of t, since (as in the equation above) *text* ends with s and also ends with t. This means that t can be written t = es for some (posisbly empty) word e.\\n Then sWs = stVst = sesVses, hence W = esVse. So W has at least 2 more chunks V if e is empty, and at least 4 more chunks than V if e is nonempty. Done with case (i).\\n\\nCase (ii) If len(t)<len(s), then again, looking at the equation above, t must be a suffix of s, since *text* ends with t and also ends with s. Write s = s[1]s[2]...s[k] and t = s[i]s[i+1]...s[k] where i>1. Then just expanding the equation above, we get\\n```\\nsWs[1]...s[k] = stVs[1]...s[k]s[i]...s[k]\\n```\\nBut if you cancel k-i+1 letters from the end of each side, you see s[1]...s[i-1] = s[k-(i-1)]...s[k]. This is all to say that there is a proper prefix of s which is also a suffix, contradicting that s is the *shortest* word which is both a prefix and suffix of *text*:  the word s\\'=s[1]...s[i-1] would be shorter.",
                "solutionTags": [],
                "code": "```\\ntext = sWs = stVst\\n```\n```\\nsWs[1]...s[k] = stVs[1]...s[k]s[i]...s[k]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351919,
                "title": "java-dp-solution-straight-forward-with-explanation",
                "content": "The greedy solution requires you to be able to prove by contradiction. Here is the dp solution. ```dp[i]``` here represents the max number of palin-decompositions that ```s[0:i] + s[len-i:len]``` can form, not counting the strings between [i+1:len-i-1]. Here\\'s the code\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int N = text.length();\\n\\t\\t// instantiate dp array 1 longer than half the text, since we need dp[0] = 0 for base case, every i is stored with \"+1\" offset\\n        int[] dp = new int[N/2+1];\\n        int max = 0;\\n        for (int j=0; j<N/2; j++) {\\n            for (int i=0; i<=j; i++) {\\n\\t\\t\\t\\t// s[i:j] (inclusive both ends) has a matching palindrome\\n\\t\\t\\t\\t// and we need to make sure that i covers the entire string or it has matching pairs to its left\\n                if (text.substring(i, j+1).equals(text.substring(N-1-j, N-i)) && (i==0 || dp[i]!=0)) {\\n                    dp[j+1] = Math.max(dp[j+1], dp[i]+2);\\n                    max = Math.max(max, dp[i]+2);\\n                }\\n            }\\n        }\\n\\t\\t// I feel like this part is not as straight-forward and took me a while\\n\\t\\t// if string is even length and has dp[n/2] != 0 then we just want to return that, otherwise, we need to add 1 to the max(dp) (odd length string always has one unmatched segment in the middle)\\n        return ((N % 2 == 0) && dp[N/2] != 0) ? dp[N/2] : max+1;\\n    }\\n}\\n```\\n\\n*Time: O(n^2)  O(substring_match) = O(n^3) <- correct me if I\\'m wrong here\\nSpace: O(n)*\\n\\nHope you enjoyed that!",
                "solutionTags": [],
                "code": "```dp[i]```\n```s[0:i] + s[len-i:len]```\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int N = text.length();\\n\\t\\t// instantiate dp array 1 longer than half the text, since we need dp[0] = 0 for base case, every i is stored with \"+1\" offset\\n        int[] dp = new int[N/2+1];\\n        int max = 0;\\n        for (int j=0; j<N/2; j++) {\\n            for (int i=0; i<=j; i++) {\\n\\t\\t\\t\\t// s[i:j] (inclusive both ends) has a matching palindrome\\n\\t\\t\\t\\t// and we need to make sure that i covers the entire string or it has matching pairs to its left\\n                if (text.substring(i, j+1).equals(text.substring(N-1-j, N-i)) && (i==0 || dp[i]!=0)) {\\n                    dp[j+1] = Math.max(dp[j+1], dp[i]+2);\\n                    max = Math.max(max, dp[i]+2);\\n                }\\n            }\\n        }\\n\\t\\t// I feel like this part is not as straight-forward and took me a while\\n\\t\\t// if string is even length and has dp[n/2] != 0 then we just want to return that, otherwise, we need to add 1 to the max(dp) (odd length string always has one unmatched segment in the middle)\\n        return ((N % 2 == 0) && dp[N/2] != 0) ? dp[N/2] : max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534801,
                "title": "cpp-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int ans=0,i=0,j=text.size()-1;\\n        string s=\"\",t=\"\";\\n        \\n        while(i<j){\\n            s+=text[i];\\n            t+=text[j];\\n            string rev=t;\\n            reverse(rev.begin(),rev.end());\\n            \\n            if(s==rev){\\n                ans++;\\n                t=\"\";\\n                s=\"\";\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        ans*=2;\\n        \\n        if(i==j || s.size()!=0)ans++;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int ans=0,i=0,j=text.size()-1;\\n        string s=\"\",t=\"\";\\n        \\n        while(i<j){\\n            s+=text[i];\\n            t+=text[j];\\n            string rev=t;\\n            reverse(rev.begin(),rev.end());\\n            \\n            if(s==rev){\\n                ans++;\\n                t=\"\";\\n                s=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 358105,
                "title": "java-easy-sol-palindrome-check-1ms",
                "content": "```\\n public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int chunkCount = 0;\\n        int start=0;\\n        int end = n;\\n        int i=0,j=n-1;\\n        while(i<j) {\\n            String left = text.substring(start,i+1);\\n            String right = text.substring(j,end);\\n            if(left.equals(right)) {\\n                chunkCount+=2;\\n                start=i+1;\\n                end = j;\\n            }\\n            i++;j--;\\n        }\\n        if(start<end) {\\n            chunkCount++;\\n        }\\n        return chunkCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int chunkCount = 0;\\n        int start=0;\\n        int end = n;\\n        int i=0,j=n-1;\\n        while(i<j) {\\n            String left = text.substring(start,i+1);\\n            String right = text.substring(j,end);\\n            if(left.equals(right)) {\\n                chunkCount+=2;\\n                start=i+1;\\n                end = j;\\n            }\\n            i++;j--;\\n        }\\n        if(start<end) {\\n            chunkCount++;\\n        }\\n        return chunkCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351174,
                "title": "java-real-space-o-1-iterative-greedy-solution-w-explanation-and-analysis",
                "content": "**Method 1: Iterative code**\\n\\nRead lots of java version without finding `O(1)` space solution. Some of them use `substring()`, which could cost `O(n / 2)` each, and some use recursion in addition, which cost more space due to recursion stack.\\n\\nHere is real space `O(1)` solution, idea is similar to the top voted:\\n1. Try to match the `substring(out[0], in[0])` and `substring(in[1], out[1])`; \\n2. If succeed, increase the `counter` by `2`, then continue to operate on the remaining parts; otherwise, expand by `1` the size of both substrings;\\n3. Repeat 2 till the 2 substrings meet.\\n\\n```\\n    public int longestDecomposition(String text) {\\n        int out[] = { 0, text.length() }, in[] = out.clone(), counter = 0;\\n        label:\\n        while (++in[0] <= --in[1]) {\\n            for (int i = out[0], j = in[1]; i < in[0]; ++i, ++j)\\n                if (text.charAt(i) != text.charAt(j))\\n                    continue label;\\n            counter += 2;\\n            out = in.clone();\\n        }\\n        return counter + (out[1] > out[0] ? 1 : 0);\\n    }\\n```\\n**Analysis:**\\n\\nTime: O(n ^ 2), space: O(1).\\n\\n----\\n**Method 2: Recursive code**:\\n\\n```\\n    public int longestDecomposition(String text) {\\n        return longestDecomposition(text, 0, text.length());\\n    }\\n    private int longestDecomposition(String text, int lo, int hi) {\\n        label:\\n        for (int len = 1; len <= (hi - lo) / 2; ++len) {\\n            for (int i = lo, j = hi - len; i < lo + len; ++i, ++j)\\n                if (text.charAt(i) != text.charAt(j))\\n                        continue label;\\n            return 2 + longestDecomposition(text, lo + len, hi - len);\\n        }\\n        return hi - lo < 2 ? hi - lo : 1;\\n    }\\n```\\n**Analysis:**\\n\\nTime: O(n ^ 2), space: O(n).\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int longestDecomposition(String text) {\\n        int out[] = { 0, text.length() }, in[] = out.clone(), counter = 0;\\n        label:\\n        while (++in[0] <= --in[1]) {\\n            for (int i = out[0], j = in[1]; i < in[0]; ++i, ++j)\\n                if (text.charAt(i) != text.charAt(j))\\n                    continue label;\\n            counter += 2;\\n            out = in.clone();\\n        }\\n        return counter + (out[1] > out[0] ? 1 : 0);\\n    }\\n```\n```\\n    public int longestDecomposition(String text) {\\n        return longestDecomposition(text, 0, text.length());\\n    }\\n    private int longestDecomposition(String text, int lo, int hi) {\\n        label:\\n        for (int len = 1; len <= (hi - lo) / 2; ++len) {\\n            for (int i = lo, j = hi - len; i < lo + len; ++i, ++j)\\n                if (text.charAt(i) != text.charAt(j))\\n                        continue label;\\n            return 2 + longestDecomposition(text, lo + len, hi - len);\\n        }\\n        return hi - lo < 2 ? hi - lo : 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089276,
                "title": "easy-python-solution-two-pointers",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        left = 0\\n        right = len(text)-1\\n        temp1 = \"\"\\n        temp2 = \"\"\\n        count = 0\\n        while left < right:\\n            temp1 += text[left]\\n            temp2 += text[right]\\n            if temp1 == temp2[::-1]:\\n                count += 2\\n                temp1 = \"\"\\n                temp2 = \"\"\\n                left += 1\\n                right -= 1\\n            else:\\n                left += 1\\n                right -= 1\\n        if left == right and len(temp1) == 0:\\n            count += 1\\n        if len(temp1) != 0:\\n            count += 1\\n        return count\\n```\\nDo upvote if you like the solution :)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        left = 0\\n        right = len(text)-1\\n        temp1 = \"\"\\n        temp2 = \"\"\\n        count = 0\\n        while left < right:\\n            temp1 += text[left]\\n            temp2 += text[right]\\n            if temp1 == temp2[::-1]:\\n                count += 2\\n                temp1 = \"\"\\n                temp2 = \"\"\\n                left += 1\\n                right -= 1\\n            else:\\n                left += 1\\n                right -= 1\\n        if left == right and len(temp1) == 0:\\n            count += 1\\n        if len(temp1) != 0:\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416709,
                "title": "java-two-pointers",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        String l=\"\",r=\"\";\\n        int c=0;\\n        for(int i=0;i<text.length();i++){\\n            l=l+text.charAt(i);\\n            r=text.charAt(text.length()-i-1)+r;\\n            if(l.equals(r)){\\n                c++;\\n                l=\"\";\\n                r=\"\";\\n            }\\n        }\\n        return c;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestDecomposition(String text) {\\n        String l=\"\",r=\"\";\\n        int c=0;\\n        for(int i=0;i<text.length();i++){\\n            l=l+text.charAt(i);\\n            r=text.charAt(text.length()-i-1)+r;\\n            if(l.equals(r)){\\n                c++;\\n                l=\"\";\\n                r=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1925238,
                "title": "c-simple-approach-greedy",
                "content": "We are saving the indexes of of every letter\\'s occurrence from rear and with respect to that letter, checking if the word being formed by it matches our word from the beginning word or not. If not we will look for another index with that letter.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        vector<int> index[26]; //array to store indices of occurrence of each letter\\n        int count = 0;\\n        for(int i = text.size()-1; i >= 0; i--){\\n            index[text[i] - \\'a\\'].push_back(i); //taking the indices in\\n        }\\n        int i = 0;\\n        int n = text.size();\\n        int j = n;\\n        while(i < j){\\n            int temp = text[i] - \\'a\\'; //finding index of the current letter\\n            int track = i;\\n            for(auto x: index[temp]){\\n                if(x >= j) continue; //if the index we are looking for has already been counted in another tree\\n                int sz = j-x; //size of the word \\n                if(i + sz > x) break; // if the words are overlapping\\n                if(text.substr(i, sz) == text.substr(x, sz)){\\n                count+=2; //increasing count if the words are same\\n                j = x;\\n                i+=sz;\\n                break;\\n                }  \\n            }\\n            if(track == i) return count+=1; // taking the last reamaining word as whoel\\n        }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        vector<int> index[26]; //array to store indices of occurrence of each letter\\n        int count = 0;\\n        for(int i = text.size()-1; i >= 0; i--){\\n            index[text[i] - \\'a\\'].push_back(i); //taking the indices in\\n        }\\n        int i = 0;\\n        int n = text.size();\\n        int j = n;\\n        while(i < j){\\n            int temp = text[i] - \\'a\\'; //finding index of the current letter\\n            int track = i;\\n            for(auto x: index[temp]){\\n                if(x >= j) continue; //if the index we are looking for has already been counted in another tree\\n                int sz = j-x; //size of the word \\n                if(i + sz > x) break; // if the words are overlapping\\n                if(text.substr(i, sz) == text.substr(x, sz)){\\n                count+=2; //increasing count if the words are same\\n                j = x;\\n                i+=sz;\\n                break;\\n                }  \\n            }\\n            if(track == i) return count+=1; // taking the last reamaining word as whoel\\n        }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873970,
                "title": "cpp-0ms-faster-then-100",
                "content": "class Solution {\\npublic:\\n    \\n    int longestDecomposition(string s)\\n    {\\n        map<string,int> mp;\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int l=0,r=n-1;\\n        string ls,rs;\\n        int ans=0;\\n        while(i<j)\\n        {\\n            ls=s.substr(l,i-l+1);\\n            rs=s.substr(j,r-j+1);\\n            if(ls==rs)\\n            {\\n                mp[ls]++;\\n                l=i+1;\\n                r=j-1;\\n                \\n                ans+=2;\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        if(mp.size()==0) //\"merchant\"\\n            return 1;\\n        if(l>r)   // (ghi)(abcdef)(hello)(adam)(adam)(hello)(abcdef)(ghi)\".\\n            return ans;\\n        return ans+1; //(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\".\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int longestDecomposition(string s)\\n    {\\n        map<string,int> mp;\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int l=0,r=n-1;\\n        string ls,rs;\\n        int ans=0;\\n        while(i<j)\\n        {\\n            ls=s.substr(l,i-l+1);\\n            rs=s.substr(j,r-j+1);\\n            if(ls==rs)\\n            {\\n                mp[ls]++;\\n                l=i+1;\\n                r=j-1;\\n                \\n                ans+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 353581,
                "title": "intuitive-python-less-than-10-lines-greedy",
                "content": "```\\nclass Solution(object):\\n    def longestDecomposition(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        def helper(s):\\n            if not s:\\n                return 0\\n            for i in range(0,len(s)//2):\\n                if s[:i+1]==s[~i:]:\\n                    return 2+helper(s[i+1:~i])\\n            return 1\\n                \\n        return helper(text)\\n\\n\\n\\n```\\nSolution is greedy. Least Possible answer is 1 if it is a valid string else 0\\nGreedily compare k characters from starting and end. If it matches call it recursively to get the results for the newer substring.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestDecomposition(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        def helper(s):\\n            if not s:\\n                return 0\\n            for i in range(0,len(s)//2):\\n                if s[:i+1]==s[~i:]:\\n                    return 2+helper(s[i+1:~i])\\n            return 1\\n                \\n        return helper(text)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350691,
                "title": "easy-four-pointers-solutions",
                "content": "```\\n    public int longestDecomposition(String text) {\\n        //four pointers;\\n        if(text == null || text.length() == 0) return 0;\\n        int left = 0, right = text.length();\\n        int low = left + 1, high = right - 1;\\n        int count = 0;\\n        while(low <= high) {\\n            String sl = text.substring(left, low);\\n            String sr = text.substring(high, right);\\n            if(sl.equals(sr)) {\\n                count += 2;\\n                left = low;\\n                right = high;\\n            } \\n            low++;\\n            high--;\\n        }\\n        if(left < right) {\\n            count += 1;\\n        }\\n        //System.out.print(left + \" \" + right);\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestDecomposition(String text) {\\n        //four pointers;\\n        if(text == null || text.length() == 0) return 0;\\n        int left = 0, right = text.length();\\n        int low = left + 1, high = right - 1;\\n        int count = 0;\\n        while(low <= high) {\\n            String sl = text.substring(left, low);\\n            String sr = text.substring(high, right);\\n            if(sl.equals(sr)) {\\n                count += 2;\\n                left = low;\\n                right = high;\\n            } \\n            low++;\\n            high--;\\n        }\\n        if(left < right) {\\n            count += 1;\\n        }\\n        //System.out.print(left + \" \" + right);\\n        return count;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 350549,
                "title": "python-beats-100-two-pointer-approach",
                "content": "keep comparing first k and last k characters and remove both from the main string.\\nonly stop when:\\n1. len(text)<2, the if condition.\\n2. text remains same after one pass.\\n```\\nclass Solution(object):\\n    def longestDecomposition(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n    \\n        count = 0\\n        done = False\\n        while not done:\\n\\n            l,r = 0, len(text)-1\\n            if len(text) <2 :\\n                done = True\\n\\n            while(l<r):\\n                if text[0:l+1] == text[r:len(text)]:\\n                    text = text[l+1:r]\\n                    count+=1\\n                    done = False\\n                    break\\n\\n                done = True\\n                l +=1\\n                r-=1\\n\\n        return 2*count+1 if len(text) else 2*count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestDecomposition(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n    \\n        count = 0\\n        done = False\\n        while not done:\\n\\n            l,r = 0, len(text)-1\\n            if len(text) <2 :\\n                done = True\\n\\n            while(l<r):\\n                if text[0:l+1] == text[r:len(text)]:\\n                    text = text[l+1:r]\\n                    count+=1\\n                    done = False\\n                    break\\n\\n                done = True\\n                l +=1\\n                r-=1\\n\\n        return 2*count+1 if len(text) else 2*count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599546,
                "title": "c-2-pointer-approach-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int s=0,e=text.size()-1;\\n        int first_found=0,last_found=text.size()-1;\\n        int cnt=0;\\n        while(s<e){\\n            string a=text.substr(first_found,s-first_found+1);\\n            string b=text.substr(e,last_found-e+1);\\n            s++;\\n            e--;\\n            if(a==b){\\n                cnt+=2;\\n                first_found=s;\\n                last_found=e;\\n            }   \\n        }\\n        if(first_found<=last_found){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int s=0,e=text.size()-1;\\n        int first_found=0,last_found=text.size()-1;\\n        int cnt=0;\\n        while(s<e){\\n            string a=text.substr(first_found,s-first_found+1);\\n            string b=text.substr(e,last_found-e+1);\\n            s++;\\n            e--;\\n            if(a==b){\\n                cnt+=2;\\n                first_found=s;\\n                last_found=e;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2266702,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        string a=\"\";\\n        while(i<j){\\n            a+=s[i];\\n            if(s[i]==s[j]){\\n                int len=a.size();\\n                if(a==s.substr(j-len+1,len)){\\n                    ans+=2;j=j-len;\\n                    a=\"\";\\n                }\\n            }i++;            \\n        }\\n        if(i==j) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        string a=\"\";\\n        while(i<j){\\n            a+=s[i];\\n            if(s[i]==s[j]){\\n                int len=a.size();\\n                if(a==s.substr(j-len+1,len)){\\n                    ans+=2;j=j-len;\\n                    a=\"\";\\n                }\\n            }i++;            \\n        }\\n        if(i==j) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641222,
                "title": "c-rolling-hash-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long mod = 1e9 + 7;\\n    \\n    long long power(long long a, long long b) {\\n        long long res = 1;\\n        while(b) {\\n            if(b%2) res = (res%mod * a%mod)%mod , b-=1;\\n            b/=2;\\n            a = ((a%mod) * (a%mod))%mod;\\n        }\\n        \\n        return res%mod;\\n    }\\n        \\n  \\n    // precalculate hash of each prefix\\n    void generateHashes(string &text, vector<long long> &hash, vector<long long> &invModulo) {\\n        long long p = 31;\\n        long long p_power = 1;\\n        invModulo[0] = 1;\\n        hash[0] = (text[0] - \\'a\\' + 1);\\n        \\n        for(int i=1; i < text.length(); i++) {\\n            char ch = text[i];\\n            p_power = (p_power%mod * p%mod)%mod;\\n            invModulo[i] = power(p_power, mod-2); // fermet\\'s little theorem for calculating inverse modulo\\n            hash[i] = (hash[i-1]%mod + ((ch - \\'a\\' + 1) * p_power%mod)%mod)%mod;\\n        }\\n        \\n    }\\n    \\n    // return hash of each substring in O(1)\\n    long long substringHash(int left, int right, vector<long long> &hash, vector<long long> &invModulo) {\\n        long long res = hash[right]%mod;\\n        if(left > 0) res = (res%mod -  hash[left - 1]%mod)%mod;\\n        \\n        return (mod + (res%mod * invModulo[left]%mod))%mod;\\n    }\\n    \\n    \\n    int longestDecomposition(string text) {\\n        int n = text.length();\\n        vector<long long> hash(n), invModulo(n);\\n        \\n        generateHashes(text, hash, invModulo);\\n        \\n        int start = 0, left = 0, right = n-1, end = n-1;\\n        int ans = 0;\\n        \\n        while(left < right) {\\n            \\n            // we found one substring matching so split from this point (we have to get the max number of times we can split the string (largest Possible value of k))\\n            if(substringHash(start, left, hash, invModulo) == substringHash(right, end, hash, invModulo)) {\\n                ans += 2; // because 2 parts are being created.\\n                \\n                start = left+1;\\n                end = right-1;\\n            } \\n            \\n            left += 1;\\n            right -= 1;\\n\\n            \\n        }\\n        \\n        if(start <= end) ans += 1; // if one of the substring is still remaining.\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long mod = 1e9 + 7;\\n    \\n    long long power(long long a, long long b) {\\n        long long res = 1;\\n        while(b) {\\n            if(b%2) res = (res%mod * a%mod)%mod , b-=1;\\n            b/=2;\\n            a = ((a%mod) * (a%mod))%mod;\\n        }\\n        \\n        return res%mod;\\n    }\\n        \\n  \\n    // precalculate hash of each prefix\\n    void generateHashes(string &text, vector<long long> &hash, vector<long long> &invModulo) {\\n        long long p = 31;\\n        long long p_power = 1;\\n        invModulo[0] = 1;\\n        hash[0] = (text[0] - \\'a\\' + 1);\\n        \\n        for(int i=1; i < text.length(); i++) {\\n            char ch = text[i];\\n            p_power = (p_power%mod * p%mod)%mod;\\n            invModulo[i] = power(p_power, mod-2); // fermet\\'s little theorem for calculating inverse modulo\\n            hash[i] = (hash[i-1]%mod + ((ch - \\'a\\' + 1) * p_power%mod)%mod)%mod;\\n        }\\n        \\n    }\\n    \\n    // return hash of each substring in O(1)\\n    long long substringHash(int left, int right, vector<long long> &hash, vector<long long> &invModulo) {\\n        long long res = hash[right]%mod;\\n        if(left > 0) res = (res%mod -  hash[left - 1]%mod)%mod;\\n        \\n        return (mod + (res%mod * invModulo[left]%mod))%mod;\\n    }\\n    \\n    \\n    int longestDecomposition(string text) {\\n        int n = text.length();\\n        vector<long long> hash(n), invModulo(n);\\n        \\n        generateHashes(text, hash, invModulo);\\n        \\n        int start = 0, left = 0, right = n-1, end = n-1;\\n        int ans = 0;\\n        \\n        while(left < right) {\\n            \\n            // we found one substring matching so split from this point (we have to get the max number of times we can split the string (largest Possible value of k))\\n            if(substringHash(start, left, hash, invModulo) == substringHash(right, end, hash, invModulo)) {\\n                ans += 2; // because 2 parts are being created.\\n                \\n                start = left+1;\\n                end = right-1;\\n            } \\n            \\n            left += 1;\\n            right -= 1;\\n\\n            \\n        }\\n        \\n        if(start <= end) ans += 1; // if one of the substring is still remaining.\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587221,
                "title": "c-linear-queue-and-stack-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n       int ans=0,l=0,r=text.size()-1;\\n        stack<int>st;\\n        queue<int>q;\\n        while(l<r){\\n            st.push(text[l++]);\\n            q.push(text[r--]);\\n            while(!st.empty() && q.front()==st.top()){\\n                q.pop();\\n                st.pop();\\n            }\\n            if(st.empty())ans+=l<=r?2:1;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n       int ans=0,l=0,r=text.size()-1;\\n        stack<int>st;\\n        queue<int>q;\\n        while(l<r){\\n            st.push(text[l++]);\\n            q.push(text[r--]);\\n            while(!st.empty() && q.front()==st.top()){\\n                q.pop();\\n                st.pop();\\n            }\\n            if(st.empty())ans+=l<=r?2:1;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339182,
                "title": "cpp-super-simple-memozation-two-pointer-comments",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int dp[1001][1001];\\n    int solve(string txt, int b, int e){\\n        if(e<b) return 0;  // empty string\\n        int res=1;  // for nonempty string with no partition possible\\n        int len=1;  // length of the prefix that matches the suffix\\n        if(dp[b][e]!=-1) return dp[b][e];\\n        for(int i=e; i>b; i--,len++){\\n            if(txt[b]==txt[i]){\\n                string suff = txt.substr(i,len);\\n                string pref = txt.substr(b,len);\\n\\t\\t\\t\\t// if prefix and suffix are same, those two form a partition and then recursivley calculate for the inner subproblems. return the maximum value\\n                if(suff==pref) res = max(res,2+solve(txt,b+len,i-1));\\n            }\\n        }\\n        return dp[b][e]=res;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans = solve(text,0,n-1);\\n        return ans;\\n    }\\n};\\n```\\n\\nA better DP optimized\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    int dp[1001][1001];\\n    int solve(string txt, int b, int e){\\n        if(e<b) return 0;  // empty string\\n        int res=1;  // for nonempty string with no partition possible\\n        int len=1;  // length of the prefix that matches the suffix\\n        if(dp[b][e]!=-1) return dp[b][e];\\n        for(int i=e; i>b; i--,len++){\\n            if(txt[b]==txt[i]){\\n                string suff = txt.substr(i,len);\\n                string pref = txt.substr(b,len);\\n\\t\\t\\t\\t// if prefix and suffix are same, those two form a partition and then recursivley calculate for the inner subproblems. return the maximum value\\n                if(suff==pref){\\n                    res = 2+solve(txt,b+len,i-1);\\n                    break;\\n                } \\n            }\\n        }\\n        return dp[b][e]=res;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans = solve(text,0,n-1);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nBelow is using 2 pointer greedy approach different from the DP one\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n=text.size();\\n        int b=0,e=n-1;\\n        int count=0, lencompleted=0;\\n        string pref=\"\",suff=\"\";\\n        while(b<e){\\n            pref+=text[b++];\\n            suff=text[e--]+suff;\\n            if(pref==suff){\\n                count+=2;\\n                lencompleted+=2*pref.size();\\n                pref=\"\";\\n                suff=\"\";\\n            }\\n        }\\n        if(lencompleted==n) return count;\\n        return count+1; // one nonempty string in the middle was remaining\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int dp[1001][1001];\\n    int solve(string txt, int b, int e){\\n        if(e<b) return 0;  // empty string\\n        int res=1;  // for nonempty string with no partition possible\\n        int len=1;  // length of the prefix that matches the suffix\\n        if(dp[b][e]!=-1) return dp[b][e];\\n        for(int i=e; i>b; i--,len++){\\n            if(txt[b]==txt[i]){\\n                string suff = txt.substr(i,len);\\n                string pref = txt.substr(b,len);\\n\\t\\t\\t\\t// if prefix and suffix are same, those two form a partition and then recursivley calculate for the inner subproblems. return the maximum value\\n                if(suff==pref) res = max(res,2+solve(txt,b+len,i-1));\\n            }\\n        }\\n        return dp[b][e]=res;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans = solve(text,0,n-1);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int dp[1001][1001];\\n    int solve(string txt, int b, int e){\\n        if(e<b) return 0;  // empty string\\n        int res=1;  // for nonempty string with no partition possible\\n        int len=1;  // length of the prefix that matches the suffix\\n        if(dp[b][e]!=-1) return dp[b][e];\\n        for(int i=e; i>b; i--,len++){\\n            if(txt[b]==txt[i]){\\n                string suff = txt.substr(i,len);\\n                string pref = txt.substr(b,len);\\n\\t\\t\\t\\t// if prefix and suffix are same, those two form a partition and then recursivley calculate for the inner subproblems. return the maximum value\\n                if(suff==pref){\\n                    res = 2+solve(txt,b+len,i-1);\\n                    break;\\n                } \\n            }\\n        }\\n        return dp[b][e]=res;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        memset(dp,-1,sizeof dp);\\n        int ans = solve(text,0,n-1);\\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n=text.size();\\n        int b=0,e=n-1;\\n        int count=0, lencompleted=0;\\n        string pref=\"\",suff=\"\";\\n        while(b<e){\\n            pref+=text[b++];\\n            suff=text[e--]+suff;\\n            if(pref==suff){\\n                count+=2;\\n                lencompleted+=2*pref.size();\\n                pref=\"\";\\n                suff=\"\";\\n            }\\n        }\\n        if(lencompleted==n) return count;\\n        return count+1; // one nonempty string in the middle was remaining\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208172,
                "title": "python-recursion-beats-100",
                "content": "The idea is fairly simple. Just keeping a track of the shortest match where the string from start and end are equal. In case, such a string is found, apply the same logic on remaining string. In case, no match is found, return 0 if string is empty, else 1.\\n\\n```\\ndef longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        start = \\'\\'\\n        end = \\'\\'\\n        for i in range(n // 2):\\n            start += text[i]\\n            end = text[n - i - 1] + end\\n            if start == end:\\n                return 2 + self.longestDecomposition(text[i + 1: n - i - 1])\\n        return 0 if n == 0 else 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        start = \\'\\'\\n        end = \\'\\'\\n        for i in range(n // 2):\\n            start += text[i]\\n            end = text[n - i - 1] + end\\n            if start == end:\\n                return 2 + self.longestDecomposition(text[i + 1: n - i - 1])\\n        return 0 if n == 0 else 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 949854,
                "title": "c-two-pointer-technique-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int i = 0, j = text.size() - 1;\\n   \\n        int ans = 0;\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        while(i < j){\\n          s1 += text[i];\\n          s2 = text[j] + s2;\\n          //cout << s1 << \" \" << s2 << endl;\\n          if(s1 == s2){\\n            ans += 2;\\n            s1 = \"\";\\n            s2 = \"\";\\n          }\\n          ++i;  --j;\\n        }\\n        if(s1.size() == 0 and s2.size() == 0 and text.size() % 2)  ans += 1;\\n        if(s1.size() or s2.size()) ans++;\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int i = 0, j = text.size() - 1;\\n   \\n        int ans = 0;\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        while(i < j){\\n          s1 += text[i];\\n          s2 = text[j] + s2;\\n          //cout << s1 << \" \" << s2 << endl;\\n          if(s1 == s2){\\n            ans += 2;\\n            s1 = \"\";\\n            s2 = \"\";\\n          }\\n          ++i;  --j;\\n        }\\n        if(s1.size() == 0 and s2.size() == 0 and text.size() % 2)  ans += 1;\\n        if(s1.size() or s2.size()) ans++;\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 357272,
                "title": "o-n-solution-using-rolling-hash",
                "content": "Greedily match string from start and end using rolling hash\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        long long i = 0,j = s.length()-1,count=0;\\n        long long m = 1e9+7,sum1=0,sum2=0,prev2 = j;\\n        vector <long long> po(1005,0);\\n        po[0] = 1;\\n        for(int i=1;i<=s.length()+1;i++){\\n            po[i] = (po[i-1]*31)%m;\\n        }\\n        bool ismiddleleft = true;\\n        while(i<=j){\\n            sum1 = (((sum1 + (s[i]-\\'a\\'+1))%m)*31)%m;\\n            sum2 = (((s[j]-\\'a\\'+1)*po[prev2-j+1])%m + sum2)%m;\\n            if(i==j){\\n                count++;\\n                ismiddleleft = false;\\n                break;\\n            }\\n            if(sum1 == sum2){                \\n                count+=2;\\n                sum1 = 0;\\n                sum2 = 0;\\n                prev2 = j-1;       \\n                if(i+1==j)\\n                    ismiddleleft = false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(ismiddleleft)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        long long i = 0,j = s.length()-1,count=0;\\n        long long m = 1e9+7,sum1=0,sum2=0,prev2 = j;\\n        vector <long long> po(1005,0);\\n        po[0] = 1;\\n        for(int i=1;i<=s.length()+1;i++){\\n            po[i] = (po[i-1]*31)%m;\\n        }\\n        bool ismiddleleft = true;\\n        while(i<=j){\\n            sum1 = (((sum1 + (s[i]-\\'a\\'+1))%m)*31)%m;\\n            sum2 = (((s[j]-\\'a\\'+1)*po[prev2-j+1])%m + sum2)%m;\\n            if(i==j){\\n                count++;\\n                ismiddleleft = false;\\n                break;\\n            }\\n            if(sum1 == sum2){                \\n                count+=2;\\n                sum1 = 0;\\n                sum2 = 0;\\n                prev2 = j-1;       \\n                if(i+1==j)\\n                    ismiddleleft = false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(ismiddleleft)\\n            count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350974,
                "title": "c-inward-traversal-greedy-chunk-matching",
                "content": "The main info you need to follow this algorithm is:\\n\\n* We\\'re comparing chunks, starting at the outer extremes of the text, traveling inward.\\n* Index `l` points at the first character of the current chunk.\\n* Index `r` points at one past the last character of the current chunk.\\n* Index `N-r` points at the first character of the equivalent chunk on the other side of the text.\\n* We want every match to be as small as possible. As soon as we match, we advance `l`.\\n* At the end we still need to check whether there\\'s a lone chunk left in the middle.\\n\\n```C++\\nint longestDecomposition(const string& text) {\\n  const int N = text.size();\\n  const auto tb = text.begin();\\n  int count = 0, l = 0;\\n  for (int r = 1; 2*r <= N; ++r)\\n    if (equal(tb+l, tb+r, tb+N-r))\\n      count += 2, l = r;\\n  return count + (2 * l < N);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nint longestDecomposition(const string& text) {\\n  const int N = text.size();\\n  const auto tb = text.begin();\\n  int count = 0, l = 0;\\n  for (int r = 1; 2*r <= N; ++r)\\n    if (equal(tb+l, tb+r, tb+N-r))\\n      count += 2, l = r;\\n  return count + (2 * l < N);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350618,
                "title": "java-recursion-memo",
                "content": "```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    public int longestDecomposition(String text) {\\n        if (map.containsKey(text)) return map.get(text);\\n        int len = text.length();\\n        if (len == 0) return 0;\\n        else if (len == 1) return 1;\\n        int count = 1;\\n        for (int i = 0; i <= len / 2 - 1; i++) {\\n            String sub = text.substring(0,  i + 1);\\n            if (text.startsWith(sub, len - i - 1)) {\\n                String s = text.substring(i + 1, text.length() - sub.length());\\n                count = Math.max(2 + longestDecomposition(s), count);\\n            }\\n        }\\n        map.put(text, count);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    public int longestDecomposition(String text) {\\n        if (map.containsKey(text)) return map.get(text);\\n        int len = text.length();\\n        if (len == 0) return 0;\\n        else if (len == 1) return 1;\\n        int count = 1;\\n        for (int i = 0; i <= len / 2 - 1; i++) {\\n            String sub = text.substring(0,  i + 1);\\n            if (text.startsWith(sub, len - i - 1)) {\\n                String s = text.substring(i + 1, text.length() - sub.length());\\n                count = Math.max(2 + longestDecomposition(s), count);\\n            }\\n        }\\n        map.put(text, count);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350597,
                "title": "simple-python-two-pointer-solution",
                "content": "```\\n    def longestDecomposition(self, text: str) -> int:\\n        res = 0\\n        l, r = 0, len(text) - 1\\n        while l <= r:\\n            j = 0\\n            while l + j < r:\\n                if text[l:l+j+1] != text[r-j:r+1]:\\n                    j += 1\\n                else:\\n                    break\\n            if l + j == r:\\n                res += 1\\n                break\\n            else:\\n                res += 2\\n                l, r = l + j + 1, r - j - 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestDecomposition(self, text: str) -> int:\\n        res = 0\\n        l, r = 0, len(text) - 1\\n        while l <= r:\\n            j = 0\\n            while l + j < r:\\n                if text[l:l+j+1] != text[r-j:r+1]:\\n                    j += 1\\n                else:\\n                    break\\n            if l + j == r:\\n                res += 1\\n                break\\n            else:\\n                res += 2\\n                l, r = l + j + 1, r - j - 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 350591,
                "title": "c-recursion-with-memoization",
                "content": "The entire idea is to create chunks from left and right and recursively.\\n![image](https://assets.leetcode.com/users/bangerlee/image_1564891466.png)\\n```\\nclass Solution {\\nprivate:\\n    int res=1;\\n    unordered_map<string,int> m;\\n    int helper(string& s,int l,int r){\\n        if(l>r) return 0;\\n        if(m.count(s.substr(l,r-l+1))) return m[s.substr(l,r-l+1)];\\n        for(int len=1;len<=(r-l+1)/2;len++){\\n            if(s.substr(l,len)==s.substr(r-len+1,len))\\n                res=max(res,2+helper(s,l+len,r-len));\\n        }\\n        m[s.substr(l,r-l+1)]=res;\\n        return res;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        return helper(text,0,text.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int res=1;\\n    unordered_map<string,int> m;\\n    int helper(string& s,int l,int r){\\n        if(l>r) return 0;\\n        if(m.count(s.substr(l,r-l+1))) return m[s.substr(l,r-l+1)];\\n        for(int len=1;len<=(r-l+1)/2;len++){\\n            if(s.substr(l,len)==s.substr(r-len+1,len))\\n                res=max(res,2+helper(s,l+len,r-len));\\n        }\\n        m[s.substr(l,r-l+1)]=res;\\n        return res;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        return helper(text,0,text.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799803,
                "title": "beats-100-easy-understanding-c-two-pointers",
                "content": "**Approach**\\n\\n There is simple approach to solve this problem,we use two pointers to identify palindromic substrings from both ends of the string. When a valid palindrome is found, it increments the count and moves the pointers accordingly. The loop continues until both pointers meet at the middle or cross each other. The result returned is the count of valid palindromic decompositions found.\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int i=0, j=text.size()-1;\\n        int last=text.size();\\n        int ctr=0;\\n        int half=text.size()/2;\\n        while(i<=j && j>=half){\\n            if(i==j){\\n                ctr++;\\n                break;\\n            }\\n            \\n          \\n            if(text[i]==text[j]){\\n                int x=i;\\n                int y=j;\\n                int flag=0;\\n                while(y<last){\\n                    if(text[x]!=text[y]){\\n                        flag=1;\\n                        break;\\n                    }\\n                    x++;\\n                    y++;\\n                }\\n               \\n                if(flag==0){\\n                    ctr+=2;\\n                    last=j;\\n                    i=x;\\n                }\\n            }\\n            j--;\\n            \\n        }\\n        if(j<half && i>=half) return ctr;\\n        \\n        if(j<half && i<half)return ctr+1;\\n        return ctr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int i=0, j=text.size()-1;\\n        int last=text.size();\\n        int ctr=0;\\n        int half=text.size()/2;\\n        while(i<=j && j>=half){\\n            if(i==j){\\n                ctr++;\\n                break;\\n            }\\n            \\n          \\n            if(text[i]==text[j]){\\n                int x=i;\\n                int y=j;\\n                int flag=0;\\n                while(y<last){\\n                    if(text[x]!=text[y]){\\n                        flag=1;\\n                        break;\\n                    }\\n                    x++;\\n                    y++;\\n                }\\n               \\n                if(flag==0){\\n                    ctr+=2;\\n                    last=j;\\n                    i=x;\\n                }\\n            }\\n            j--;\\n            \\n        }\\n        if(j<half && i>=half) return ctr;\\n        \\n        if(j<half && i<half)return ctr+1;\\n        return ctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731758,
                "title": "c-easiest-greedy-solution-top-down-dp",
                "content": "# **Greedy**\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        int n = s.size(), res = 0;\\n        string a = \"\", b = \"\";\\n        for(int i = 0; i < n; i++){\\n            a += s[i], b = s[n - 1 - i] + b;\\n            if(a == b)\\n                res++, a = \"\", b = \"\";\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# **Top-Down DP**\\n```\\nclass Solution {\\npublic:\\n    int memo[1001][1001];\\n    int n;\\n    int longestDecomposition(string s) {\\n        n = s.size();\\n        memset(memo, -1, sizeof(memo));\\n        return dp(s, 0, 1);\\n    }\\n    int dp(string& s, int idx, int sz){\\n        if(n % 2 == 0 && idx + sz == n / 2)\\n            return s.substr(idx, sz) == s.substr(n - sz - idx, sz) ? 2 : 1;\\n        if(idx + sz > n / 2) return 1;\\n        if(memo[idx][sz] != -1) return memo[idx][sz];\\n        return memo[idx][sz] = s.substr(idx, sz) == s.substr(n - sz - idx, sz) ? 2 + dp(s, idx + sz, 1) : dp(s, idx, sz + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        int n = s.size(), res = 0;\\n        string a = \"\", b = \"\";\\n        for(int i = 0; i < n; i++){\\n            a += s[i], b = s[n - 1 - i] + b;\\n            if(a == b)\\n                res++, a = \"\", b = \"\";\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int memo[1001][1001];\\n    int n;\\n    int longestDecomposition(string s) {\\n        n = s.size();\\n        memset(memo, -1, sizeof(memo));\\n        return dp(s, 0, 1);\\n    }\\n    int dp(string& s, int idx, int sz){\\n        if(n % 2 == 0 && idx + sz == n / 2)\\n            return s.substr(idx, sz) == s.substr(n - sz - idx, sz) ? 2 : 1;\\n        if(idx + sz > n / 2) return 1;\\n        if(memo[idx][sz] != -1) return memo[idx][sz];\\n        return memo[idx][sz] = s.substr(idx, sz) == s.substr(n - sz - idx, sz) ? 2 + dp(s, idx + sz, 1) : dp(s, idx, sz + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546784,
                "title": "c-simple-rolling-hash-no-recursion",
                "content": "This implementation is a simple rolling hash implementation in C++. It doesn\\'t involve string comparison that at times might be of O(N) time complexity magnitude.\\n\\n```cpp\\nclass Solution {\\n    #define ll long long\\n    const int MOD7 = 1e9+7;\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size(), l = 0, r = n-1, ans = 0, base = 26;\\n        \\n        ll pref = 0, suff = 0, pw = 1;\\n        while(l < r)\\n        {\\n            pref = ((pref*base) + (text[l++]-\\'a\\')) % MOD7;\\n            suff = (suff + (text[r--]-\\'a\\')*pw) % MOD7;\\n            pw = (pw*base) % MOD7;\\n            \\n            if (pref == suff)\\n            {\\n                ans += 2;\\n                pref = 0;\\n                suff = 0;\\n                pw = 1;\\n                if (l > r) return ans;\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```cpp\\nclass Solution {\\n    #define ll long long\\n    const int MOD7 = 1e9+7;\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size(), l = 0, r = n-1, ans = 0, base = 26;\\n        \\n        ll pref = 0, suff = 0, pw = 1;\\n        while(l < r)\\n        {\\n            pref = ((pref*base) + (text[l++]-\\'a\\')) % MOD7;\\n            suff = (suff + (text[r--]-\\'a\\')*pw) % MOD7;\\n            pw = (pw*base) % MOD7;\\n            \\n            if (pref == suff)\\n            {\\n                ans += 2;\\n                pref = 0;\\n                suff = 0;\\n                pw = 1;\\n                if (l > r) return ans;\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205665,
                "title": "c-dp-lps-solution",
                "content": "In the computation of LPS array, you get the length of the proper prefix that is also a suffix for all the indices in the length of the string. Create n such LPS array for the substring of a given string with increasing starting position. To maximize k, we will take greedy approach. Find the shortest prefix that is also suffix whille recursive drillling down in the LPS DP array. Reduce the size of the string by that lenght from both end and increment the `k` based on the following rule:\\n1. If the smallest prefix is less than the length of string, add 2\\n2. Else, add 1\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getDP(string& s){\\n        int l = s.length();\\n        vector<vector<int>> dp(l, vector<int>(l, 0));\\n        for(int start = 0; start < l; start++){\\n            int i = 0, j = 1;\\n            while(start + j < l){\\n                if(s[start+i] == s[start+j]){\\n                    i++;\\n                    dp[start][start+j] = i;\\n                    j++;\\n                }\\n                else{\\n                    if(i != 0){\\n                        i = dp[start][start+i-1];\\n                    }\\n                    else{\\n                        dp[start][start+j] = 0;\\n                        j++;\\n                    }\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    int longestDecomposition(string text) {\\n        vector<vector<int>> lpsDP = getDP(text);\\n        int i = 0, j = text.length()-1, k = 0, l;\\n        while(i <= j){\\n            int s = text.length();\\n            int l = j;\\n            while(lpsDP[i][l]){\\n                s = lpsDP[i][l];\\n                l = i + s - 1;\\n            }\\n            if(s != text.length()){\\n                k += 2;\\n            }\\n            else{\\n                k++;\\n            }\\n            i += s;\\n            j -= s;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getDP(string& s){\\n        int l = s.length();\\n        vector<vector<int>> dp(l, vector<int>(l, 0));\\n        for(int start = 0; start < l; start++){\\n            int i = 0, j = 1;\\n            while(start + j < l){\\n                if(s[start+i] == s[start+j]){\\n                    i++;\\n                    dp[start][start+j] = i;\\n                    j++;\\n                }\\n                else{\\n                    if(i != 0){\\n                        i = dp[start][start+i-1];\\n                    }\\n                    else{\\n                        dp[start][start+j] = 0;\\n                        j++;\\n                    }\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    int longestDecomposition(string text) {\\n        vector<vector<int>> lpsDP = getDP(text);\\n        int i = 0, j = text.length()-1, k = 0, l;\\n        while(i <= j){\\n            int s = text.length();\\n            int l = j;\\n            while(lpsDP[i][l]){\\n                s = lpsDP[i][l];\\n                l = i + s - 1;\\n            }\\n            if(s != text.length()){\\n                k += 2;\\n            }\\n            else{\\n                k++;\\n            }\\n            i += s;\\n            j -= s;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188097,
                "title": "two-pointer-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestDecomposition(string s) {\\n\\t\\t\\tint i=0,j=s.size()-1;\\n\\t\\t\\tstring tmp,tmp1;\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\twhile(i < j)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttmp+=s[i];\\n\\t\\t\\t\\ttmp1=s[j]+tmp1;\\n\\t\\t\\t\\tif(tmp==tmp1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttmp=\"\",tmp1=\"\";\\n\\t\\t\\t\\t\\tcnt+=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++,j--;\\n\\t\\t\\t}\\n\\t\\t\\tif(i==j)return cnt+1;\\n\\t\\t\\telse if(tmp.size()==0 && tmp1.size()==0)return cnt;\\n\\n\\t\\t\\treturn cnt+1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestDecomposition(string s) {\\n\\t\\t\\tint i=0,j=s.size()-1;\\n\\t\\t\\tstring tmp,tmp1;\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\twhile(i < j)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttmp+=s[i];\\n\\t\\t\\t\\ttmp1=s[j]+tmp1;\\n\\t\\t\\t\\tif(tmp==tmp1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttmp=\"\",tmp1=\"\";\\n\\t\\t\\t\\t\\tcnt+=2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2070317,
                "title": "python-easy-beats-94-deque-two-pointer",
                "content": "Appending a element to the left of a list (insert operation) takes `O(N)` time.\\nHence we can use a deque to append a element to the left of list in `O(1)` time.\\nWe maintain two deques `a` and `b` and keep checking if they are equal while traversing `text` in a 2-Pointer approach.\\nWe add characters to the right in `a` and add characters to the left in `b`.\\n```\\neg , text=\"abcabc\"\\nIteration 1: a=>[a] b=>[c]\\nIteration 2: a=>[a,b] b=>[b,c]\\nIteration 3: a=>[a,b,c] b=>[a,b,c]\\n```\\n\\n```py\\n\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        left, right = 0, len(text) - 1\\n        sol, last_left = 0, 0\\n        a, b = deque(), deque()\\n        while right > left:\\n            a.append(text[left])\\n            b.appendleft(text[right])\\n            if a == b:\\n                sol += 2\\n                last_left = left\\n                a, b = deque(), deque()\\n            right -= 1\\n            left += 1\\n        if left == right or left > last_left + 1:\\n            sol += 1\\n        return max(sol, 1)\\n\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2efaa2c9-9e82-4bad-8b14-f9ad1e3c9bdb_1653408173.8650315.png)\\n\\n**Happy Coding !!**\\n\\nIf you have any questions , feel free to ask.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\neg , text=\"abcabc\"\\nIteration 1: a=>[a] b=>[c]\\nIteration 2: a=>[a,b] b=>[b,c]\\nIteration 3: a=>[a,b,c] b=>[a,b,c]\\n```\n```py\\n\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        left, right = 0, len(text) - 1\\n        sol, last_left = 0, 0\\n        a, b = deque(), deque()\\n        while right > left:\\n            a.append(text[left])\\n            b.appendleft(text[right])\\n            if a == b:\\n                sol += 2\\n                last_left = left\\n                a, b = deque(), deque()\\n            right -= 1\\n            left += 1\\n        if left == right or left > last_left + 1:\\n            sol += 1\\n        return max(sol, 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898032,
                "title": "simple-solution-in-java-easy-to-understand-dp-with-comments",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        if(text.length() == 0) return 0;\\n        \\n        int n = text.length();\\n        int[] dp = new int[n/2+2];\\n        \\n        int max = 0; \\n        int maxIndex = -1;\\n        \\n        // i is length of the chunk \\n        for(int i=1; i<=n/2; i++){ \\n            for(int j=0; j<i; j++){\\n                if(text.substring(j, i).equals(text.substring(n-i, n-j))){\\n                    if(j == 0 || dp[j] != 0){\\n                        dp[i] = Math.max(dp[i], 2 + dp[j]);\\n                    }\\n                }\\n            }\\n            \\n            max = Math.max(max, dp[i]);\\n            if(dp[i] != 0) maxIndex = i;\\n        }\\n        \\n        if(maxIndex == -1) return 1; // There are no palindromes, take the entire string as one chunk\\n        if(n%2 == 0){\\n             /* \\n                The length is even, if the palindrome is possible at the middle like abba then ab -> 2nd position (i.e. size/2), It\\n                will give the max chunks\\n                And if the palindrome decomposition is not possible in the middle, take the middle as one chunk and return max + 1\\n                like if the text is \"abcdklmdcba\", here we will take \"klm\" as one chunk \\n             */\\n            if(maxIndex == n/2) return max;\\n            return max + 1;\\n        }\\n        \\n        // Max chunks plus the one chunk in the middle whose decomposition is not possible \\n        return max + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        if(text.length() == 0) return 0;\\n        \\n        int n = text.length();\\n        int[] dp = new int[n/2+2];\\n        \\n        int max = 0; \\n        int maxIndex = -1;\\n        \\n        // i is length of the chunk \\n        for(int i=1; i<=n/2; i++){ \\n            for(int j=0; j<i; j++){\\n                if(text.substring(j, i).equals(text.substring(n-i, n-j))){\\n                    if(j == 0 || dp[j] != 0){\\n                        dp[i] = Math.max(dp[i], 2 + dp[j]);\\n                    }\\n                }\\n            }\\n            \\n            max = Math.max(max, dp[i]);\\n            if(dp[i] != 0) maxIndex = i;\\n        }\\n        \\n        if(maxIndex == -1) return 1; // There are no palindromes, take the entire string as one chunk\\n        if(n%2 == 0){\\n             /* \\n                The length is even, if the palindrome is possible at the middle like abba then ab -> 2nd position (i.e. size/2), It\\n                will give the max chunks\\n                And if the palindrome decomposition is not possible in the middle, take the middle as one chunk and return max + 1\\n                like if the text is \"abcdklmdcba\", here we will take \"klm\" as one chunk \\n             */\\n            if(maxIndex == n/2) return max;\\n            return max + 1;\\n        }\\n        \\n        // Max chunks plus the one chunk in the middle whose decomposition is not possible \\n        return max + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427274,
                "title": "why-hard-it-should-be-in-easy-see-my-python-solution-no-dp-at-all",
                "content": "However we can make dp solution but as it is in hard section we can also solve this problem by simple checking using one while loop . \\n\\n<iframe src=\"https://leetcode.com/playground/jjeTAFQR/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python"
                ],
                "code": "However we can make dp solution but as it is in hard section we can also solve this problem by simple checking using one while loop . \\n\\n<iframe src=\"https://leetcode.com/playground/jjeTAFQR/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1399637,
                "title": "c-easy-solution-with-diagram-representation",
                "content": "![image](https://assets.leetcode.com/users/images/2eaddbe4-7403-4ade-83a3-ecd9f11e5e18_1628777834.972519.png)\\n\\n\\nclass Solution {\\npublic:\\n#     int longestDecomposition(string text) {\\n        int ans = 0;\\n        int n = text.size();\\n        int i=0, j=n-1;\\n        int last = n;\\n        while(i<j)\\n        {\\n            if(text[i]==text[j])\\n            {\\n                bool ansb = true;\\n                \\n                for(int k=j+1; k<last; k++)\\n                {\\n                    if(text[k]!=text[k-j+i])\\n                    {\\n                        ansb = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(ansb)\\n                {\\n                    if(i!=j) ans+=2;\\n                 \\n                    else ans+=1;\\n                   \\n                    i+=last-j;\\n                    \\n                    last = j;\\n                    \\n                    j--;\\n                }\\n                else j--;   \\n            }\\n            else j--;   \\n        }\\n        \\n        if(i==j) ans++;\\n       \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n#     int longestDecomposition(string text) {\\n        int ans = 0;\\n        int n = text.size();\\n        int i=0, j=n-1;\\n        int last = n;\\n        while(i<j)\\n        {\\n            if(text[i]==text[j])\\n            {\\n                bool ansb = true;\\n                \\n                for(int k=j+1; k<last; k++)\\n                {\\n                    if(text[k]!=text[k-j+i])\\n                    {\\n                        ansb = false;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1268605,
                "title": "faster-than-100-submissions-rolling-hash-o-n-memory-usage-less-than-99-34-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        long long lh = 0LL, rh = 0LL, powers=1LL, MOD = 1000000007LL;\\n        int l =0, r = text.size()-1;\\n        int ans =0;\\n        while(l<r){\\n            lh = (lh*26LL + text[l++]-\\'a\\'+1) % MOD;\\n            rh = (rh + (text[r--]-\\'a\\'+1)*powers% MOD )% MOD;\\n            if(lh == rh){\\n                ans +=2;\\n                powers = 1;\\n                lh = rh =0LL;\\n            }\\n            else\\n                powers = (powers*26LL) % MOD;\\n        }\\n        if(l==r || powers > 1)\\n            return ans+1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        long long lh = 0LL, rh = 0LL, powers=1LL, MOD = 1000000007LL;\\n        int l =0, r = text.size()-1;\\n        int ans =0;\\n        while(l<r){\\n            lh = (lh*26LL + text[l++]-\\'a\\'+1) % MOD;\\n            rh = (rh + (text[r--]-\\'a\\'+1)*powers% MOD )% MOD;\\n            if(lh == rh){\\n                ans +=2;\\n                powers = 1;\\n                lh = rh =0LL;\\n            }\\n            else\\n                powers = (powers*26LL) % MOD;\\n        }\\n        if(l==r || powers > 1)\\n            return ans+1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213864,
                "title": "c-code-beats-100-time-and-99-9-space-simple-and-easy",
                "content": "class Solution {\\npublic:\\nint longestDecomposition(string text) {\\n        \\n        int ans=0;\\n        int l=0;\\n        int r=text.size()-1;\\n        stack<char>sd;\\n        queue<char>ds;\\n        while(l<r)\\n        {\\n            sd.push(text[l++]);\\n            ds.push(text[r--]);\\n            while(!sd.empty()&&sd.top()==ds.front())\\n            {\\n                ds.pop();\\n            sd.pop();\\n            }\\n            if(sd.empty())\\n            {\\n                ans+=l<=r?2:1;\\n            }\\n        }\\nreturn ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint longestDecomposition(string text) {\\n        \\n        int ans=0;\\n        int l=0;\\n        int r=text.size()-1;\\n        stack<char>sd;\\n        queue<char>ds;\\n        while(l<r)\\n        {\\n            sd.push(text[l++]);\\n            ds.push(text[r--]);\\n            while(!sd.empty()&&sd.top()==ds.front())\\n            {\\n                ds.pop();\\n            sd.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1117465,
                "title": "javascript-solution",
                "content": "```\\nvar longestDecomposition = function(text) {\\n    var i = 1\\n    var output = 0\\n    while(i < text.length)\\n    {\\n        if(text.substring(0,i) == text.substring(text.length-i))\\n        {\\n            output += 2 //add 2 to simulate adding to both sides of output array\\n            text = text.substring(i,text.length-i) //cut text to simulate popping off of both sides\\n            i=1\\n        } else {\\n            i++\\n        }\\n    }\\n    \\n    return text ? output + 1 : output //if there\\'s any text leftover that didn\\'t have a match, it\\'s the middle and would add 1 to output array\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestDecomposition = function(text) {\\n    var i = 1\\n    var output = 0\\n    while(i < text.length)\\n    {\\n        if(text.substring(0,i) == text.substring(text.length-i))\\n        {\\n            output += 2 //add 2 to simulate adding to both sides of output array\\n            text = text.substring(i,text.length-i) //cut text to simulate popping off of both sides\\n            i=1\\n        } else {\\n            i++\\n        }\\n    }\\n    \\n    return text ? output + 1 : output //if there\\'s any text leftover that didn\\'t have a match, it\\'s the middle and would add 1 to output array\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902898,
                "title": "java-rabin-karp-algorithm-rolling-hash-o-n-short-and-concise",
                "content": "```\\n// Using Rabin Karp Algorithm\\npublic int longestDecomposition(String text) {\\n\\tlong hash1 = 0;\\n\\tlong hash2 = 0;\\n\\n\\tlong mod = (long)Math.pow(2, 31);\\n\\n\\tint l = 0;\\n\\tint r = text.length() - 1;\\n\\n\\tlong rightPow = 1;\\n\\n\\tint count = 0;\\n\\twhile(l < r) {            \\n\\t\\thash1 *= 26;\\n\\t\\thash1 += text.charAt(l) - \\'a\\';\\n\\t\\thash1 %= mod;\\n\\n\\t\\thash2 += (text.charAt(r) - \\'a\\') * rightPow;\\n\\t\\thash2 %= mod;\\n\\n\\t\\trightPow *= 26;\\n\\t\\trightPow %= mod;\\n\\n\\t\\tif(hash1 == hash2) {\\n\\t\\t\\tcount += 2;\\n\\n\\t\\t\\thash1 = 0;\\n\\t\\t\\thash2 = 0;\\n\\t\\t\\trightPow = 1;\\n\\t\\t}\\n\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n\\n\\tif(hash1 != 0 || l == r || count == 0)\\n\\t\\tcount++;\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Using Rabin Karp Algorithm\\npublic int longestDecomposition(String text) {\\n\\tlong hash1 = 0;\\n\\tlong hash2 = 0;\\n\\n\\tlong mod = (long)Math.pow(2, 31);\\n\\n\\tint l = 0;\\n\\tint r = text.length() - 1;\\n\\n\\tlong rightPow = 1;\\n\\n\\tint count = 0;\\n\\twhile(l < r) {            \\n\\t\\thash1 *= 26;\\n\\t\\thash1 += text.charAt(l) - \\'a\\';\\n\\t\\thash1 %= mod;\\n\\n\\t\\thash2 += (text.charAt(r) - \\'a\\') * rightPow;\\n\\t\\thash2 %= mod;\\n\\n\\t\\trightPow *= 26;\\n\\t\\trightPow %= mod;\\n\\n\\t\\tif(hash1 == hash2) {\\n\\t\\t\\tcount += 2;\\n\\n\\t\\t\\thash1 = 0;\\n\\t\\t\\thash2 = 0;\\n\\t\\t\\trightPow = 1;\\n\\t\\t}\\n\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n\\n\\tif(hash1 != 0 || l == r || count == 0)\\n\\t\\tcount++;\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 897806,
                "title": "python-3-look-for-smallest-subtext-that-matches-at-beginning-and-end-if-any-recurse",
                "content": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        if n <= 1: return n\\n        for i in range(1,n//2+1):\\n            if text[:i] == text[-i:]:\\n                return 2+self.longestDecomposition(text[i:-i])\\n        return 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        if n <= 1: return n\\n        for i in range(1,n//2+1):\\n            if text[:i] == text[-i:]:\\n                return 2+self.longestDecomposition(text[i:-i])\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858169,
                "title": "python-greedy-deques-simple-explanation-and-example",
                "content": "```html5\\n<b>Time Complexity: O(n)\\nSpace complexity: O(n)</b>\\n```\\n\\nUse two double ended queues: \\n**left** to keep track of the current substring as we read text from the left\\n**right** to keep track of the current substring as we read text from the right.  \\n***See example at the end***\\n\\nDouble ended queues (deques) are used because they offer **O(1) time complexity** when adding a letter to the beginning or to the end of the queue.  \\n\\nWhenever **left == right** then we have found 2 chunks that match, so add 2 to res. \\n\\n```python\\ndef longestDecomposition(self, text: str) -> int:\\n\\n\\tres = 0\\n\\tleft = collections.deque()\\n\\tright = collections.deque()\\n\\ti, j = 0, len(text)-1\\n\\twhile i <= j:\\n\\t\\tleft.append(text[i])\\n\\t\\tright.appendleft(text[j])\\n\\t\\tif left == right:\\n\\t\\t\\tres += 2 - (i == j) # - (i == j) subtracts one chunk when left and right overlap i.e. text = \"a\" left = \"a\" right = \"a\"\\n\\t\\t\\tleft = collections.deque()\\n\\t\\t\\tright = collections.deque()\\n\\t\\ti += 1\\n\\t\\tj -= 1\\n\\telse:\\n\\t\\tres += bool(left) # If i >= j and left is not empty, then combine left and right into 1 chunk (res += 1)\\n\\n\\treturn res\\n```\\n\\n**Walk-through Example:**\\n```\\ntext = \"ghiabcdefhelloadamhelloabcdefghi\"\\n\\nleft = [\"g\"] ;                     right = [\"i\"] ; res = 0\\nleft = [\"g\",\"h\"] ;                 right = [\"h\",\"i\"] ; res = 0\\nleft = [\"g\",\"h\",\"i\"] ;             right = [\"g\",\"h\",\"i\"] ; res = 2\\n\\nleft = [\"a\"] ;                     right = [\"f\"] ; res = 2\\nleft = [\"a\",\"b\"] ;                 right = [\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\"] ;             right = [\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\"] ;         right = [\"c\",\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\",\"e\"] ;     right = [\"b\",\"c\",\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] ; right = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] ; res = 4\\n...\\nleft = [\"h\",\"e\",\"l\",\"l\",\"o\"] ;     right = [\"h\",\"e\",\"l\",\"l\",\"o\"] ; res = 6\\n...\\nleft = [\"a\",\"d\"] ; right = [\"a\", \"m\"] ; res = 6 + bool(left) = 7\\n```\\n\\n<img src=\"https://assets.leetcode.com/users/images/95fc1a59-3980-4002-a404-314d63602ef1_1600722431.3899684.png\" width=\"50%\">",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O(n)\\nSpace complexity: O(n)</b>\\n```\n```python\\ndef longestDecomposition(self, text: str) -> int:\\n\\n\\tres = 0\\n\\tleft = collections.deque()\\n\\tright = collections.deque()\\n\\ti, j = 0, len(text)-1\\n\\twhile i <= j:\\n\\t\\tleft.append(text[i])\\n\\t\\tright.appendleft(text[j])\\n\\t\\tif left == right:\\n\\t\\t\\tres += 2 - (i == j) # - (i == j) subtracts one chunk when left and right overlap i.e. text = \"a\" left = \"a\" right = \"a\"\\n\\t\\t\\tleft = collections.deque()\\n\\t\\t\\tright = collections.deque()\\n\\t\\ti += 1\\n\\t\\tj -= 1\\n\\telse:\\n\\t\\tres += bool(left) # If i >= j and left is not empty, then combine left and right into 1 chunk (res += 1)\\n\\n\\treturn res\\n```\n```\\ntext = \"ghiabcdefhelloadamhelloabcdefghi\"\\n\\nleft = [\"g\"] ;                     right = [\"i\"] ; res = 0\\nleft = [\"g\",\"h\"] ;                 right = [\"h\",\"i\"] ; res = 0\\nleft = [\"g\",\"h\",\"i\"] ;             right = [\"g\",\"h\",\"i\"] ; res = 2\\n\\nleft = [\"a\"] ;                     right = [\"f\"] ; res = 2\\nleft = [\"a\",\"b\"] ;                 right = [\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\"] ;             right = [\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\"] ;         right = [\"c\",\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\",\"e\"] ;     right = [\"b\",\"c\",\"d\",\"e\",\"f\"] ; res = 2\\nleft = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] ; right = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] ; res = 4\\n...\\nleft = [\"h\",\"e\",\"l\",\"l\",\"o\"] ;     right = [\"h\",\"e\",\"l\",\"l\",\"o\"] ; res = 6\\n...\\nleft = [\"a\",\"d\"] ; right = [\"a\", \"m\"] ; res = 6 + bool(left) = 7\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 640029,
                "title": "simple-java",
                "content": "```\\npublic int longestDecomposition(String text) {\\n        \\n        int count = 0;\\n        int n = text.length();\\n        int i=0;\\n        int j = 1;\\n\\t\\t//to check if the middle most substring had a palindrome pair or not \\n        boolean flag = false; \\n        while(j<=text.length()/2){\\n                flag = false;\\n                if(text.substring(i,j).equals(text.substring(n-i-(j-i),n-i))){\\n                    count++;\\n                    i=j;\\n                    j=i+1;\\n                    flag = true;\\n                }else j++;\\n        }\\n        if(flag && n%2==0) return count*2;\\n        return count*2+1;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int longestDecomposition(String text) {\\n        \\n        int count = 0;\\n        int n = text.length();\\n        int i=0;\\n        int j = 1;\\n\\t\\t//to check if the middle most substring had a palindrome pair or not \\n        boolean flag = false; \\n        while(j<=text.length()/2){\\n                flag = false;\\n                if(text.substring(i,j).equals(text.substring(n-i-(j-i),n-i))){\\n                    count++;\\n                    i=j;\\n                    j=i+1;\\n                    flag = true;\\n                }else j++;\\n        }\\n        if(flag && n%2==0) return count*2;\\n        return count*2+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 528363,
                "title": "javascript-greedy",
                "content": "```javascript\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    let count = 0;\\n    let left = 0;\\n    let right = text.length - 1;\\n    let leftStr = \\'\\';\\n    let rightStr = \\'\\';\\n    while (left < right) {\\n        leftStr += text[left++];\\n        rightStr = text[right--] + rightStr;\\n        if (leftStr === rightStr) {\\n            count += 2;\\n            leftStr = \\'\\';\\n            rightStr = \\'\\';\\n        }\\n    }\\n    if (leftStr || left === right) count++;\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```javascript\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    let count = 0;\\n    let left = 0;\\n    let right = text.length - 1;\\n    let leftStr = \\'\\';\\n    let rightStr = \\'\\';\\n    while (left < right) {\\n        leftStr += text[left++];\\n        rightStr = text[right--] + rightStr;\\n        if (leftStr === rightStr) {\\n            count += 2;\\n            leftStr = \\'\\';\\n            rightStr = \\'\\';\\n        }\\n    }\\n    if (leftStr || left === right) count++;\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519791,
                "title": "java-rollinghash-dfs-memo",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long hash[];\\n    long pow[];\\n    int dp[][];\\n    public int longestDecomposition(String text) {\\n        dp=new int[text.length()+1][text.length()+1];\\n        hash=new long[text.length()];\\n        pow=new long[text.length()];\\n        pow[0]=1;\\n        hash[0]=text.charAt(0)%mod;\\n        for(int i=1;i<text.length();i++){\\n            hash[i]=(hash[i-1]*26+text.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*26)%mod;\\n        }//seting up the hash\\n        int ans=dfs(text,0,text.length()-1);\\n        return ans;\\n    }\\n    \\n    public int dfs(String text,int left,int right){\\n        if(left==right)return 1;\\n        if(left>right)return 0;\\n        int res=1;\\n        for(int len=1;len<text.length();len++){\\n            long hash1=0;long hash2=0;\\n            int leftend=left+len-1;\\n            int rightstart=right-len+1;\\n            if(leftend>=rightstart){\\n                break;\\n            }\\n            hash1=gethash(text,left,leftend);\\n            hash2=gethash(text,rightstart,right);\\n            if(hash1==hash2){\\n                if(dp[leftend+1][rightstart-1]==0){\\n                   dp[leftend+1][rightstart-1]=dfs(text,leftend+1,rightstart-1); \\n                }\\n                if(dp[leftend+1][rightstart-1]!=-1){\\n                    res=Math.max(res,2+dp[leftend+1][rightstart-1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public long gethash(String text,int left,int right){\\n        if(left==0)return hash[right];\\n        long res=(hash[right]-hash[left-1]*pow[right-left+1])%mod;\\n        if(res<0)res+=mod;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long hash[];\\n    long pow[];\\n    int dp[][];\\n    public int longestDecomposition(String text) {\\n        dp=new int[text.length()+1][text.length()+1];\\n        hash=new long[text.length()];\\n        pow=new long[text.length()];\\n        pow[0]=1;\\n        hash[0]=text.charAt(0)%mod;\\n        for(int i=1;i<text.length();i++){\\n            hash[i]=(hash[i-1]*26+text.charAt(i))%mod;\\n            pow[i]=(pow[i-1]*26)%mod;\\n        }//seting up the hash\\n        int ans=dfs(text,0,text.length()-1);\\n        return ans;\\n    }\\n    \\n    public int dfs(String text,int left,int right){\\n        if(left==right)return 1;\\n        if(left>right)return 0;\\n        int res=1;\\n        for(int len=1;len<text.length();len++){\\n            long hash1=0;long hash2=0;\\n            int leftend=left+len-1;\\n            int rightstart=right-len+1;\\n            if(leftend>=rightstart){\\n                break;\\n            }\\n            hash1=gethash(text,left,leftend);\\n            hash2=gethash(text,rightstart,right);\\n            if(hash1==hash2){\\n                if(dp[leftend+1][rightstart-1]==0){\\n                   dp[leftend+1][rightstart-1]=dfs(text,leftend+1,rightstart-1); \\n                }\\n                if(dp[leftend+1][rightstart-1]!=-1){\\n                    res=Math.max(res,2+dp[leftend+1][rightstart-1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public long gethash(String text,int left,int right){\\n        if(left==0)return hash[right];\\n        long res=(hash[right]-hash[left-1]*pow[right-left+1])%mod;\\n        if(res<0)res+=mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479247,
                "title": "o-n-2-c-dp-might-be-easier-to-figure-out-during-the-real-interview",
                "content": "I am aware of the O(n) greedy solution, just wrote this DP solution for fun.\\nCould transform to be the greedy solution by adding a break \\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int dfs(const string &text, int l, int r) {\\n        if(r < l) return 0;\\n        if(l == r) return 1;\\n        if(dp[l][r] > 0) return dp[l][r];\\n\\t\\t\\n        int n = r - l + 1;\\n        int ans = 1;\\n        for(int len = 1; len <= n / 2; len++) {\\n            auto left = text.substr(l, len);\\n            auto right = text.substr(r - len + 1, len);\\n            if(left == right) {\\n                ans = max(ans, 2 + dfs(text, l + len, r - len));\\n\\t\\t\\t\\t// break; // if you can prove the correctness of greedy to the interviewer :)\\n            }\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    \\n    int longestDecomposition(string text) {\\n        return dfs(text, 0, text.size()-1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[1001][1001];\\n    int dfs(const string &text, int l, int r) {\\n        if(r < l) return 0;\\n        if(l == r) return 1;\\n        if(dp[l][r] > 0) return dp[l][r];\\n\\t\\t\\n        int n = r - l + 1;\\n        int ans = 1;\\n        for(int len = 1; len <= n / 2; len++) {\\n            auto left = text.substr(l, len);\\n            auto right = text.substr(r - len + 1, len);\\n            if(left == right) {\\n                ans = max(ans, 2 + dfs(text, l + len, r - len));\\n\\t\\t\\t\\t// break; // if you can prove the correctness of greedy to the interviewer :)\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 444193,
                "title": "c-prefix-pattern-table-use-logical-annotated-4ms-runtime-and-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //Return the largest possible number of chunk that forms palindromic relationship inside the given text\\n    int longestDecomposition(string text) {\\n        if(text.empty()){ //if the given string is empty, it cannot even have a single chunk.\\n            return 0;\\n        }\\n        vector<int> pTable(text.length());//prefix pattern table essentially used in KMP algorithm\\n        //1. No segfault: since we have checked empty string case at the beginig\\n        //2. should be 0, because we are comparing the same character(\"same\" as literally same, not about their value)\\n        pTable[0] = 0;\\n        \\n        int j = 0;//j pointer pointing the next prefix candidate\\n        int i = 1;//iterating through the text string to fill up the ptable\\n        while(i < text.length()){\\n            if(text[i] == text[j]){//if their character matches\\n                pTable[i] = j + 1; //record the length of recurring prefix the string(0, i) can have\\n                ++j;\\n                ++i;\\n            }\\n            else if(j == 0){\\n                /*to prevent the infinite loop:\\n                if the two characters are different and there are no more previous characters to be comoapred\\n                then just move onto the next char in the text to fill up the table\\n                */\\n                ++i;\\n            }\\n            else{\\n                //if not match, but still there can be another possible match to previous pattern\\n                //ex) abacabab == the last abab does not match with abac but the last two character ab matches with the first ab \\n                j = pTable[j-1];\\n            }\\n        }\\n        int len = pTable[pTable.size() - 1]; //the length of the last chunk that also occuring at the beginning\\n        if(len == 0){//if there is no such chunk, then we cannot form a palindrome with multiple chunks\\n            //Therefore, the smallest palindromic chunk is the string itself.\\n            return 1;\\n        }\\n        else if(len > text.length() / 2){ //Since the chunk is greater than the (text length / 2), so we know that that pattern is continuous\\n            //In other words, the entire string is made of many of one chunk.\\n            int chunkLen = text.length() - len;//calculating the shortest chucnk length because we have to maximize the number of chunks\\n            return text.length() / chunkLen;\\n        }\\n        else{\\n            //(chunkA)(ChunkB)(chunkA) case\\n            //treat each chunk as another \"text\" string and get the largest k value of that text thru recurisve call.\\n            string midStr = text.substr(len, text.length() - (2*len));\\n            string outerStr = text.substr(0, len);\\n            return longestDecomposition(midStr) + (2 * longestDecomposition(outerStr));\\n        }\\n    }\\n};\\n```\\nPoint:\\nCore: Use Prefix Pattern Table to deductively figure out the length of each side chunk.\\n3 cases:\\n1. If the length of each side chunk is 0 --> the only possible chunk is the string itself, so return 1\\n2. If the length of each side chunk is > (text string length / 2) --> the whole string is made of many of \"one type of chunk\" --> so find the shortest possible chunk length and return (text string length / the shortest possible chunk length)\\n3. If the length of each side chuck is <= (text string length / 2) --> (chunkA)(chunkB)(chunkA) case. *Note: chunkB can be an empty string\\n--> treat each chunk as another \"text\" and get their larget possible number of chunks through recursive call.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //Return the largest possible number of chunk that forms palindromic relationship inside the given text\\n    int longestDecomposition(string text) {\\n        if(text.empty()){ //if the given string is empty, it cannot even have a single chunk.\\n            return 0;\\n        }\\n        vector<int> pTable(text.length());//prefix pattern table essentially used in KMP algorithm\\n        //1. No segfault: since we have checked empty string case at the beginig\\n        //2. should be 0, because we are comparing the same character(\"same\" as literally same, not about their value)\\n        pTable[0] = 0;\\n        \\n        int j = 0;//j pointer pointing the next prefix candidate\\n        int i = 1;//iterating through the text string to fill up the ptable\\n        while(i < text.length()){\\n            if(text[i] == text[j]){//if their character matches\\n                pTable[i] = j + 1; //record the length of recurring prefix the string(0, i) can have\\n                ++j;\\n                ++i;\\n            }\\n            else if(j == 0){\\n                /*to prevent the infinite loop:\\n                if the two characters are different and there are no more previous characters to be comoapred\\n                then just move onto the next char in the text to fill up the table\\n                */\\n                ++i;\\n            }\\n            else{\\n                //if not match, but still there can be another possible match to previous pattern\\n                //ex) abacabab == the last abab does not match with abac but the last two character ab matches with the first ab \\n                j = pTable[j-1];\\n            }\\n        }\\n        int len = pTable[pTable.size() - 1]; //the length of the last chunk that also occuring at the beginning\\n        if(len == 0){//if there is no such chunk, then we cannot form a palindrome with multiple chunks\\n            //Therefore, the smallest palindromic chunk is the string itself.\\n            return 1;\\n        }\\n        else if(len > text.length() / 2){ //Since the chunk is greater than the (text length / 2), so we know that that pattern is continuous\\n            //In other words, the entire string is made of many of one chunk.\\n            int chunkLen = text.length() - len;//calculating the shortest chucnk length because we have to maximize the number of chunks\\n            return text.length() / chunkLen;\\n        }\\n        else{\\n            //(chunkA)(ChunkB)(chunkA) case\\n            //treat each chunk as another \"text\" string and get the largest k value of that text thru recurisve call.\\n            string midStr = text.substr(len, text.length() - (2*len));\\n            string outerStr = text.substr(0, len);\\n            return longestDecomposition(midStr) + (2 * longestDecomposition(outerStr));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433019,
                "title": "one-pass-iteration-count-letters-very-very-esay-0-ms",
                "content": "### Solution 1\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Longest Chunked Palindrome Decomposition.\\nMemory Usage: 9.3 MB, less than 100.00% of C++ online submissions for Longest Chunked Palindrome Decomposition.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n        string rtext(text.rbegin(), text.rend());   // reversed text\\n        map<char, int> cnts;\\n        int ret = 0, pos = 0, size = text.size();\\n        while (pos < size) {\\n            ++cnts[text[pos]];\\n            if (cnts[text[pos]] == 0) cnts.erase(text[pos]);\\n            --cnts[rtext[pos]];\\n            if (cnts[rtext[pos]] == 0) cnts.erase(rtext[pos]);\\n            if (cnts.empty()) ++ret;\\n            ++pos;\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n\\n### Solution 2 ( Modified Solution 1, remove redundant memory and calculation)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n        map<char, int> cnts;\\n        int ret = 0, left = 0, right = text.size() - 1;\\n        while (left < right) {\\n            char ch = text[left];\\n            ++cnts[ch];\\n            if (cnts[ch] == 0) cnts.erase(ch);\\n\\n            ch = text[right];\\n            --cnts[ch];\\n            if (cnts[ch] == 0) cnts.erase(ch);\\n\\n            if (cnts.empty()) ret += 2;\\n            ++left;\\n            --right;\\n        }\\n        if (left == right || !cnts.empty()) ++ret;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n        string rtext(text.rbegin(), text.rend());   // reversed text\\n        map<char, int> cnts;\\n        int ret = 0, pos = 0, size = text.size();\\n        while (pos < size) {\\n            ++cnts[text[pos]];\\n            if (cnts[text[pos]] == 0) cnts.erase(text[pos]);\\n            --cnts[rtext[pos]];\\n            if (cnts[rtext[pos]] == 0) cnts.erase(rtext[pos]);\\n            if (cnts.empty()) ++ret;\\n            ++pos;\\n        }\\n        return ret;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n        map<char, int> cnts;\\n        int ret = 0, left = 0, right = text.size() - 1;\\n        while (left < right) {\\n            char ch = text[left];\\n            ++cnts[ch];\\n            if (cnts[ch] == 0) cnts.erase(ch);\\n\\n            ch = text[right];\\n            --cnts[ch];\\n            if (cnts[ch] == 0) cnts.erase(ch);\\n\\n            if (cnts.empty()) ret += 2;\\n            ++left;\\n            --right;\\n        }\\n        if (left == right || !cnts.empty()) ++ret;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416596,
                "title": "c-o-n-beats-100-simple-rolling-hash",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int l = 0;\\n        int r = text.size() - 1;\\n        int hl = 0;\\n        int hr = 0;\\n        int p = 100007;\\n        int d = 256;\\n        int countr = 1;\\n        int ans = 0;\\n        while(l < r) {\\n            hl = (hl*d+text[l])%p;\\n            hr = (countr*text[r] + hr)%p;\\n            countr = (countr*d)%p;\\n            if(hl == hr) {\\n                ans+=2;\\n                hl = 0;\\n                hr = 0;\\n                countr = 1;\\n            }\\n            l++;\\n            r--;\\n        }\\n        if(countr==1){\\n            if(l==r)\\n                ans++;\\n        } else {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int l = 0;\\n        int r = text.size() - 1;\\n        int hl = 0;\\n        int hr = 0;\\n        int p = 100007;\\n        int d = 256;\\n        int countr = 1;\\n        int ans = 0;\\n        while(l < r) {\\n            hl = (hl*d+text[l])%p;\\n            hr = (countr*text[r] + hr)%p;\\n            countr = (countr*d)%p;\\n            if(hl == hr) {\\n                ans+=2;\\n                hl = 0;\\n                hr = 0;\\n                countr = 1;\\n            }\\n            l++;\\n            r--;\\n        }\\n        if(countr==1){\\n            if(l==r)\\n                ans++;\\n        } else {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371020,
                "title": "java-rolling-hash-o-n-runtime-90",
                "content": "```\\n    int mod = 1000000007;\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int p1 = 0, p2 = n-1;\\n        int res = 0;\\n        long h1 = 0;\\n        long h2 = 0;\\n        long base = 35;\\n        long pow = 1;\\n        while(p1<=p2){\\n            h1 = (h1*base%mod + (text.charAt(p1)-\\'a\\'+1))%mod;\\n            h2 = (h2+(text.charAt(p2)-\\'a\\'+1)*pow%mod)%mod;\\n            pow = pow*base%mod;\\n            if(h1==h2){\\n                res += p1==p2 ? 1 : 2;\\n                h1 = 0;\\n                h2 = 0;\\n                pow = 1;\\n            }\\n            p1++;\\n            p2--;\\n        }\\n        return h1>0 ? res+1 : res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int mod = 1000000007;\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int p1 = 0, p2 = n-1;\\n        int res = 0;\\n        long h1 = 0;\\n        long h2 = 0;\\n        long base = 35;\\n        long pow = 1;\\n        while(p1<=p2){\\n            h1 = (h1*base%mod + (text.charAt(p1)-\\'a\\'+1))%mod;\\n            h2 = (h2+(text.charAt(p2)-\\'a\\'+1)*pow%mod)%mod;\\n            pow = pow*base%mod;\\n            if(h1==h2){\\n                res += p1==p2 ? 1 : 2;\\n                h1 = 0;\\n                h2 = 0;\\n                pow = 1;\\n            }\\n            p1++;\\n            p2--;\\n        }\\n        return h1>0 ? res+1 : res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 357589,
                "title": "lc1147-longest-chunked-palindrome-greedy-in-disguise-with-console-output-for-better-understanding",
                "content": "This solution is taken from - [Java/C++/Python Easy Greedy with Proof](http://leetcode.com/problems/longest-chunked-palindrome-decomposition/discuss/350560/JavaC%2B%2BPython-Easy-Greedy-with-Prove) iterative solution.\\nand seems to be one of easier to understand in the discuss section. There are several variations of the same approach.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        string left= \"\", right=\"\";\\n        int count = 0, i=0;\\n        bool consumed;\\n        for(;i < n/2; i++){\\n            consumed = false;\\n            left = left + text[i];\\n            right= text[n-i-1] + right;\\n            if(left == right){\\n                count+=2;\\n                consumed = true;\\n                left = \"\"; right =\"\";\\n            }\\n        }\\n        \\n        return consumed && i == n/2 + n%2?count : count +1; \\n    }\\n};\\n```\\n\\n\\nBelow is the console log.\\nFormat is  **left_string--right_string; left_string--right string;  ... left_string--right string; count**\\n\\n1. `input string - \"ghiabcdefhelloadamhelloabcdefghi\"`\\n\\n```\\n\\tg--i ; gh--hi ; ghi--ghi ; 1\\n\\ta--f ; ab--ef ; abc--def ; abcd--cdef ; abcde--bcdef ; abcdef--abcdef ; 2\\n\\th--o ; he--lo ; hel--llo ; hell--ello ; hello--hello ; 3\\n\\ta--m ; ad--am ; ada--dam ; adam--adam ; 4\\n\\th--o ; he--lo ; hel--llo ; hell--ello ; hello--hello ; 5\\n\\ta--f ; ab--ef ; abc--def ; abcd--cdef ; abcde--bcdef ; abcdef--abcdef ; 6\\n\\tg--i ; gh--hi ; ghi--ghi ; 7\\n\\nreturns 7 as answer\\n```\\n\\n\\n2. `\"leetcodeshallcodeleet\"`\\n\\n```\\nl--t ; le--et ; lee--eet ; leet--leet ; 1\\nc--e ; co--de ; cod--ode ; code--code ; 2\\ns--l ; sh--ll ; sha--all ; shal--hall ; shall--shall ; 3\\nc--e ; co--de ; cod--ode ; code--code ; 4\\nl--t ; le--et ; lee--eet ; leet--leet ; 5\\n\\nreturns 5 as answer\\n```\\n\\n3. `\"merchant\"`\\n```\\nm--t ; me--nt ; mer--ant ; merc--hant ; merch--chant ; mercha--rchant ; merchan--erchant ; merchant--merchant ; 1\\n\\nreturns 1 as answer\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        string left= \"\", right=\"\";\\n        int count = 0, i=0;\\n        bool consumed;\\n        for(;i < n/2; i++){\\n            consumed = false;\\n            left = left + text[i];\\n            right= text[n-i-1] + right;\\n            if(left == right){\\n                count+=2;\\n                consumed = true;\\n                left = \"\"; right =\"\";\\n            }\\n        }\\n        \\n        return consumed && i == n/2 + n%2?count : count +1; \\n    }\\n};\\n```\n```\\n\\tg--i ; gh--hi ; ghi--ghi ; 1\\n\\ta--f ; ab--ef ; abc--def ; abcd--cdef ; abcde--bcdef ; abcdef--abcdef ; 2\\n\\th--o ; he--lo ; hel--llo ; hell--ello ; hello--hello ; 3\\n\\ta--m ; ad--am ; ada--dam ; adam--adam ; 4\\n\\th--o ; he--lo ; hel--llo ; hell--ello ; hello--hello ; 5\\n\\ta--f ; ab--ef ; abc--def ; abcd--cdef ; abcde--bcdef ; abcdef--abcdef ; 6\\n\\tg--i ; gh--hi ; ghi--ghi ; 7\\n\\nreturns 7 as answer\\n```\n```\\nl--t ; le--et ; lee--eet ; leet--leet ; 1\\nc--e ; co--de ; cod--ode ; code--code ; 2\\ns--l ; sh--ll ; sha--all ; shal--hall ; shall--shall ; 3\\nc--e ; co--de ; cod--ode ; code--code ; 4\\nl--t ; le--et ; lee--eet ; leet--leet ; 5\\n\\nreturns 5 as answer\\n```\n```\\nm--t ; me--nt ; mer--ant ; merc--hant ; merch--chant ; mercha--rchant ; merchan--erchant ; merchant--merchant ; 1\\n\\nreturns 1 as answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355702,
                "title": "beat-100-java-rolling-hash",
                "content": "\\n```java\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int leftHash = 0;\\n        int rightHash = 0;\\n        int n = text.length();\\n        int cur = 1;\\n        int res = 0;\\n        int l = 0;\\n        int r = n - 1;\\n        while(l < r) {\\n            leftHash = 26 * leftHash + (text.charAt(l) - \\'a\\') ;\\n            rightHash = rightHash + (text.charAt(r) - \\'a\\') * cur;\\n            cur *= 26;\\n            \\n            if (leftHash == rightHash) {\\n                leftHash = 0;\\n                rightHash = 0;\\n                res += 2;\\n                cur = 1;\\n            }\\n            l++;\\n            r--; \\n        }\\n        if (l > r && leftHash != rightHash) {\\n            res += 1;\\n        }\\n        if (l == r) {\\n            res += 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Rolling Hash"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int leftHash = 0;\\n        int rightHash = 0;\\n        int n = text.length();\\n        int cur = 1;\\n        int res = 0;\\n        int l = 0;\\n        int r = n - 1;\\n        while(l < r) {\\n            leftHash = 26 * leftHash + (text.charAt(l) - \\'a\\') ;\\n            rightHash = rightHash + (text.charAt(r) - \\'a\\') * cur;\\n            cur *= 26;\\n            \\n            if (leftHash == rightHash) {\\n                leftHash = 0;\\n                rightHash = 0;\\n                res += 2;\\n                cur = 1;\\n            }\\n            l++;\\n            r--; \\n        }\\n        if (l > r && leftHash != rightHash) {\\n            res += 1;\\n        }\\n        if (l == r) {\\n            res += 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353298,
                "title": "simple-recursive-c",
                "content": "We simply want to find the shortest substring that exists on both ends of the larger string. If there no such pair exists, we return 1 representing the entire string. We can stop when we find the shortest as this will give us the max number of possibilities, i.e. any larger substrings that match on both ends can be split into more substrings giving us a larger total.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        if (text.empty()) return 0;\\n        int i = 1;\\n        while (i < text.size() && text.substr(0, i) != text.substr(text.size() - i, i)) i++;\\n        \\n        if (i >= text.size()) return 1;\\n        return 2 + longestDecomposition(text.substr(i, text.size() - 2*i));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        if (text.empty()) return 0;\\n        int i = 1;\\n        while (i < text.size() && text.substr(0, i) != text.substr(text.size() - i, i)) i++;\\n        \\n        if (i >= text.size()) return 1;\\n        return 2 + longestDecomposition(text.substr(i, text.size() - 2*i));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351120,
                "title": "greedy-9-lines",
                "content": "```\\n    int longestDecomposition(string text) {\\n        if(text.size() == 0){  return 0;}\\n        for(int i = 1;i <= text.size()/2; ++i){\\n           if(text.substr(0,i) == text.substr(n-i,i)){\\n               return 2 + longestDecomposition(text.substr(i,n-2*i));\\n           }\\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int longestDecomposition(string text) {\\n        if(text.size() == 0){  return 0;}\\n        for(int i = 1;i <= text.size()/2; ++i){\\n           if(text.substr(0,i) == text.substr(n-i,i)){\\n               return 2 + longestDecomposition(text.substr(i,n-2*i));\\n           }\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351101,
                "title": "java-recursion",
                "content": "```\\n\\tpublic static int longestDecomposition(String text) {\\n        if (text.length() == 0) {\\n            return 0;\\n        }\\n        for (int i = 1; i * 2 <= text.length(); i++) {\\n            String front = text.substring(0, i);\\n            String end = text.substring(text.length() - i);\\n            if (front.equals(end)) {\\n                return 2 + longestDecomposition(text.substring(i,\\n                        text.length() - i));\\n            }\\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic static int longestDecomposition(String text) {\\n        if (text.length() == 0) {\\n            return 0;\\n        }\\n        for (int i = 1; i * 2 <= text.length(); i++) {\\n            String front = text.substring(0, i);\\n            String end = text.substring(text.length() - i);\\n            if (front.equals(end)) {\\n                return 2 + longestDecomposition(text.substring(i,\\n                        text.length() - i));\\n            }\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350780,
                "title": "java-dfs-memorization",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        return dfs(text, new HashMap<>());\\n    }\\n    \\n    private int dfs(String text, Map<String, Integer> cache) {\\n        int n = text.length();\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (cache.containsKey(text)) {\\n            return cache.get(text);\\n        }\\n        int max = 1;\\n        for (int i = 0; i < n / 2; i++) {\\n            if (text.substring(0, i + 1).equals(text.substring(n - 1 - i))) {\\n                max = Math.max(max, 2 + dfs(text.substring(i + 1, n - 1 - i), cache));\\n            }\\n        }\\n        cache.put(text, max);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        return dfs(text, new HashMap<>());\\n    }\\n    \\n    private int dfs(String text, Map<String, Integer> cache) {\\n        int n = text.length();\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (cache.containsKey(text)) {\\n            return cache.get(text);\\n        }\\n        int max = 1;\\n        for (int i = 0; i < n / 2; i++) {\\n            if (text.substring(0, i + 1).equals(text.substring(n - 1 - i))) {\\n                max = Math.max(max, 2 + dfs(text.substring(i + 1, n - 1 - i), cache));\\n            }\\n        }\\n        cache.put(text, max);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350630,
                "title": "c-greedy-o-n-2",
                "content": "```\\nclass Solution {\\n    int solve(const string &text, int lo, int hi) {\\n        if(lo == hi) return 1;\\n        if(lo > hi) return 0;\\n        for(int len=1;lo+len-1<hi-len+1;len++) {\\n            if(text.substr(lo, len) == text.substr(hi-len+1, len)) return solve(text, lo + len, hi - len) + 2;\\n        }\\n        return 1;\\n    }\\npublic:\\n    int longestDecomposition(string text) {        \\n        int n = text.size();\\n        return solve(text, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int solve(const string &text, int lo, int hi) {\\n        if(lo == hi) return 1;\\n        if(lo > hi) return 0;\\n        for(int len=1;lo+len-1<hi-len+1;len++) {\\n            if(text.substr(lo, len) == text.substr(hi-len+1, len)) return solve(text, lo + len, hi - len) + 2;\\n        }\\n        return 1;\\n    }\\npublic:\\n    int longestDecomposition(string text) {        \\n        int n = text.size();\\n        return solve(text, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093687,
                "title": "very-short-and-clean-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVery beginner level solution\\niterating through the string and checking left and right are equal\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int i =0;\\n        int j = 0;\\n        int last = text.size()-1;\\n        int count = 0;\\n        for(int i =0;i<text.size();i++){\\n            if(text.substr(j, i-j+1)==text.substr(last-i+j, i-j+1)){\\n                count++;\\n                last-=(i-j+1);\\n                j= i+1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int i =0;\\n        int j = 0;\\n        int last = text.size()-1;\\n        int count = 0;\\n        for(int i =0;i<text.size();i++){\\n            if(text.substr(j, i-j+1)==text.substr(last-i+j, i-j+1)){\\n                count++;\\n                last-=(i-j+1);\\n                j= i+1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078310,
                "title": "easy-kotlin-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun longestDecomposition(text: String): Int {\\n        val n = text.length\\n        var largestK = 0\\n        var left = \"\"\\n        var right = \"\"\\n        \\n        for (i in 0 until n) {\\n            left = left + text[i]\\n            right = text[n - i - 1] + right\\n            \\n            if (left == right) {\\n                largestK += 1\\n                left = \"\"\\n                right = \"\"\\n            }\\n        }\\n        \\n        return largestK\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun longestDecomposition(text: String): Int {\\n        val n = text.length\\n        var largestK = 0\\n        var left = \"\"\\n        var right = \"\"\\n        \\n        for (i in 0 until n) {\\n            left = left + text[i]\\n            right = text[n - i - 1] + right\\n            \\n            if (left == right) {\\n                largestK += 1\\n                left = \"\"\\n                right = \"\"\\n            }\\n        }\\n        \\n        return largestK\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061055,
                "title": "c-magic-happen-recursive-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\nIf anything wrong let me know...\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nonly recursive stack\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int recursion(string &s, int l, int r){\\n        if(l > r) return 0;\\n        if(l == r) return 1;\\n\\n        int boundary = (l + r - 1) / 2;\\n        int ans = 0;\\n        bool comp = false;\\n        for(int i = r; i > boundary; i--){\\n            bool flg = true;\\n            for(int j = 0; j <= (r-i); j++){\\n                if(s[l + j] != s[i + j]){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg){\\n                comp = true;\\n                ans = max(ans, recursion(s, l + (r - i) + 1, r - (r - i) - 1));\\n            }\\n            if(flg) break;\\n        }\\n        if(!comp) return 1;\\n        return ans+2;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return recursion(text, 0, text.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int recursion(string &s, int l, int r){\\n        if(l > r) return 0;\\n        if(l == r) return 1;\\n\\n        int boundary = (l + r - 1) / 2;\\n        int ans = 0;\\n        bool comp = false;\\n        for(int i = r; i > boundary; i--){\\n            bool flg = true;\\n            for(int j = 0; j <= (r-i); j++){\\n                if(s[l + j] != s[i + j]){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg){\\n                comp = true;\\n                ans = max(ans, recursion(s, l + (r - i) + 1, r - (r - i) - 1));\\n            }\\n            if(flg) break;\\n        }\\n        if(!comp) return 1;\\n        return ans+2;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return recursion(text, 0, text.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043630,
                "title": "dp-intuitive-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int solve(string &text){\\n        if(text==\"\") return 0;\\n        int ans=1;\\n        if(mp.find(text)!=mp.end()) return mp[text];\\n        for(int i=1;i<text.size();i++){\\n            string sub=text.substr(0,i);\\n            string rev=text.substr(text.size()-i,i);\\n            if(sub==rev){\\n                string news=text.substr(i,text.size()-2*i);\\n                ans=max(ans,2+solve(news));\\n            }\\n        }\\n        return mp[text]=ans;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return solve(text);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int solve(string &text){\\n        if(text==\"\") return 0;\\n        int ans=1;\\n        if(mp.find(text)!=mp.end()) return mp[text];\\n        for(int i=1;i<text.size();i++){\\n            string sub=text.substr(0,i);\\n            string rev=text.substr(text.size()-i,i);\\n            if(sub==rev){\\n                string news=text.substr(i,text.size()-2*i);\\n                ans=max(ans,2+solve(news));\\n            }\\n        }\\n        return mp[text]=ans;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return solve(text);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990682,
                "title": "begginer-friendly-java-code-beats-52-58",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        StringBuilder check=new StringBuilder(text);\\n        char[] str=text.toCharArray();\\n        int i=0,j=str.length-1;\\n        int count=0;\\n        int start=0;\\n        int end=str.length;\\n        while(i<j){\\n            map1.put(str[i],map1.getOrDefault(str[i],0)+1);\\n            map2.put(str[j],map2.getOrDefault(str[j],0)+1);\\n            if(map1.equals(map2)){\\n                if(check.substring(start,i+1).equals(check.substring(j,end))){\\n                    start=i+1;\\n                    end=j;\\n                    count+=2;\\n                    map1.clear();\\n                    map2.clear();\\n                } \\n            }\\n            j--;\\n            i++;\\n        }\\n        if(str.length%2==0 && map1.size()==0) return count;\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        StringBuilder check=new StringBuilder(text);\\n        char[] str=text.toCharArray();\\n        int i=0,j=str.length-1;\\n        int count=0;\\n        int start=0;\\n        int end=str.length;\\n        while(i<j){\\n            map1.put(str[i],map1.getOrDefault(str[i],0)+1);\\n            map2.put(str[j],map2.getOrDefault(str[j],0)+1);\\n            if(map1.equals(map2)){\\n                if(check.substring(start,i+1).equals(check.substring(j,end))){\\n                    start=i+1;\\n                    end=j;\\n                    count+=2;\\n                    map1.clear();\\n                    map2.clear();\\n                } \\n            }\\n            j--;\\n            i++;\\n        }\\n        if(str.length%2==0 && map1.size()==0) return count;\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979969,
                "title": "lcp-array-and-dp",
                "content": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        lcp = [[0] * n for _ in range(n)]\\n        dp = [1] * n\\n        if n % 2 == 0:\\n            dp[n // 2] = 0\\n        for i in range(n - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                lcp[i][j] = 1 + lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 1\\n                if text[i] != text[j]:\\n                    lcp[i][j] = 0\\n        for i in range(n // 2, -1, -1):\\n            for l in range(1, 1 + (n - 2 * i) // 2):\\n                if lcp[i][n - i - l] >= l:\\n                    dp[i] = max(dp[i], 2 + dp[i + l])\\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        lcp = [[0] * n for _ in range(n)]\\n        dp = [1] * n\\n        if n % 2 == 0:\\n            dp[n // 2] = 0\\n        for i in range(n - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                lcp[i][j] = 1 + lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 1\\n                if text[i] != text[j]:\\n                    lcp[i][j] = 0\\n        for i in range(n // 2, -1, -1):\\n            for l in range(1, 1 + (n - 2 * i) // 2):\\n                if lcp[i][n - i - l] >= l:\\n                    dp[i] = max(dp[i], 2 + dp[i + l])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978375,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int result = 0;\\n        \\n        string left = \"\";\\n        string right = \"\";\\n        \\n        for (int i = 0; i < n; ++i) {\\n            left += text[i];\\n            right = text[n - i - 1] + right;\\n            \\n            if (left == right) {\\n                ++result;\\n                left = \"\";\\n                right = \"\";\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int result = 0;\\n        \\n        string left = \"\";\\n        string right = \"\";\\n        \\n        for (int i = 0; i < n; ++i) {\\n            left += text[i];\\n            right = text[n - i - 1] + right;\\n            \\n            if (left == right) {\\n                ++result;\\n                left = \"\";\\n                right = \"\";\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932951,
                "title": "dp-rabin-karp-c-easy-solution",
                "content": "# Intuition\\nComparison can be optimized using Rabin Karp other than that its simple dp problem\\n\\n# Approach\\nIterate through the starting point while keeping the ending point to be compared with and use dp to check the maximum value.\\n\\n# Complexity\\n\\n- Space complexity:\\n    O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long factor = 26;\\n    const long MOD = 1e9+7;\\n    bool check(string &text, int l, int r, int end, vector<long>&val, vector<long> &calc)\\n    {\\n        if(((val[r] - (l==0?0:val[l-1])+ MOD ) * calc[end - (r-l)]) % MOD == ((val[end] - val[end-(r-l)-1] + MOD) * calc[l])%MOD)\\n            return true;\\n        return false;   \\n    }\\n    int find(vector<vector<int>> &dp, int idx, int end, vector<long> &val, string &text, vector<long> &calc)\\n    {\\n        if(idx==end)\\n            return 1;\\n        if(idx>=text.length()/2)\\n            return 0;\\n        if(dp[idx][end]!=-1)\\n            return dp[idx][end];\\n        for(int i=idx;i<text.size()/2;i++)\\n        {\\n            if(check(text, idx, i, end, val, calc))\\n                dp[idx][end]=max(dp[idx][end], find(dp, i+1, end-(i-idx)-1, val, text, calc)+2);\\n        }\\n        return dp[idx][end]==-1?1:dp[idx][end];\\n    }\\n    int longestDecomposition(string text) {\\n        vector<long> calc(text.size()+1), val(text.size()+1);\\n        for(int i=0;i<calc.size();i++)\\n        {\\n            if(i==0)\\n                calc[i]=1;\\n            else\\n                calc[i]=(calc[i-1]*factor)%MOD;\\n        }\\n        int val_of_b=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            val_of_b = (val_of_b + ((text[i]-\\'a\\'+1) * calc[i])%MOD)%MOD;\\n            val[i]=val_of_b;\\n        }\\n        vector<vector<int>>dp(text.size(), vector<int>(text.size(), -1));\\n        return find(dp, 0, text.size()-1, val, text, calc);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long factor = 26;\\n    const long MOD = 1e9+7;\\n    bool check(string &text, int l, int r, int end, vector<long>&val, vector<long> &calc)\\n    {\\n        if(((val[r] - (l==0?0:val[l-1])+ MOD ) * calc[end - (r-l)]) % MOD == ((val[end] - val[end-(r-l)-1] + MOD) * calc[l])%MOD)\\n            return true;\\n        return false;   \\n    }\\n    int find(vector<vector<int>> &dp, int idx, int end, vector<long> &val, string &text, vector<long> &calc)\\n    {\\n        if(idx==end)\\n            return 1;\\n        if(idx>=text.length()/2)\\n            return 0;\\n        if(dp[idx][end]!=-1)\\n            return dp[idx][end];\\n        for(int i=idx;i<text.size()/2;i++)\\n        {\\n            if(check(text, idx, i, end, val, calc))\\n                dp[idx][end]=max(dp[idx][end], find(dp, i+1, end-(i-idx)-1, val, text, calc)+2);\\n        }\\n        return dp[idx][end]==-1?1:dp[idx][end];\\n    }\\n    int longestDecomposition(string text) {\\n        vector<long> calc(text.size()+1), val(text.size()+1);\\n        for(int i=0;i<calc.size();i++)\\n        {\\n            if(i==0)\\n                calc[i]=1;\\n            else\\n                calc[i]=(calc[i-1]*factor)%MOD;\\n        }\\n        int val_of_b=0;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            val_of_b = (val_of_b + ((text[i]-\\'a\\'+1) * calc[i])%MOD)%MOD;\\n            val[i]=val_of_b;\\n        }\\n        vector<vector<int>>dp(text.size(), vector<int>(text.size(), -1));\\n        return find(dp, 0, text.size()-1, val, text, calc);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872115,
                "title": "not-hard-beats-97-41",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n      low = 0\\n      high = len(text)-1\\n      ans=0\\n      while high-low>0:\\n        if text[:low+1]==text[high:]:\\n          ans += 2\\n          text=text[low+1:high]\\n          low=0\\n          high=len(text)-1\\n          continue\\n        low +=1\\n        high -=1\\n      if len(text)>0:\\n        ans +=1\\n      return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n      low = 0\\n      high = len(text)-1\\n      ans=0\\n      while high-low>0:\\n        if text[:low+1]==text[high:]:\\n          ans += 2\\n          text=text[low+1:high]\\n          low=0\\n          high=len(text)-1\\n          continue\\n        low +=1\\n        high -=1\\n      if len(text)>0:\\n        ans +=1\\n      return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849429,
                "title": "o-nlogn-time-o-n-space-using-sa-lcp-segment-tree-for-lce",
                "content": "The regular two-pointer approach is good, but if we do a regular string comparison, that comparision takes `O(n)` worst case, and gives a runtime of `O(n^2)`.\\n\\nOur string comparisons can be considered \"longest common extension\" (LCE) queries -- given indices `i` and `j`, what is the longest length `l` where `s[i:i+l] == s[j:j+l]`.\\n\\nLCE queries can be implemented by range-maximum queries (RMQ) over the longest common prefix (LCP) array.\\n\\nThe LCP array is an augmentation of the suffix array (SA) that stores the longest common prefix between two lexicographically neighboring suffixes.\\n\\nThe SA construction takes `O(n)` using SA-IS, the LCP construction takes `O(n)` using Kasai\\'s, and a segment tree construction for RMQ takes `O(n)`.\\nThen, each LCE query takes `O(logn)`, and we do `O(n)` of them, so the total runtime is `O(nlogn)`.\\n\\n```\\n/**\\n * Suffix array\\n * Uses SA-IS\\n *\\n * @param str A sequence of characters, with unique lexicographically smallest\\n * sentinel at the end\\n */\\ntemplate <typename Ti, typename Ts>\\nstd::vector<Ti> sais(Ts str) {\\n        Ti len = str.size();\\n        //Keep track of S(maller)=false or L(arger)=true type suffix\\n        //Sentinel is implicitly set to S already\\n        std::vector<bool> types(len);\\n        //Build types array by iterating right to left\\n        for (Ti i = len - 1; i-- > 0; types[i] = str[i] > str[i + 1] || str[i] == str[i + 1] && types[i + 1]);\\n\\n        //Find Left-Most S-type suffixes\\n        std::vector<Ti> lms;\\n        std::vector<bool> is_lms(len);\\n        for (Ti i = 0; ++i < len; types[i - 1] && !types[i] && (lms.push_back(i), is_lms[i] = true));\\n\\n        //Count character frequencies\\n        std::vector<Ti> freq;\\n        for (Ti i = len; i-- > 0; str[i] < freq.size() || (freq.resize(str[i] + 1), true), freq[str[i]]++);\\n\\n        /**\\n         * Induced sorting procedure\\n         *\\n         * @param lms LMS suffixes to put into the buckets\\n         */\\n        const auto induced_sort = [&](const std::vector<Ti>& lms) {\\n                Ti alphalen = freq.size();\\n                //Calculate bucket begin and end indicies\\n                std::vector<Ti> bkt_begin, bkt_end;\\n                bkt_begin.reserve(alphalen);\\n                bkt_end.reserve(alphalen);\\n                bkt_begin.push_back(0);\\n                bkt_end.push_back(freq[0]);\\n                for (Ti i = 0; ++i < alphalen; (bkt_begin.push_back(bkt_begin[i - 1] + freq[i - 1]), bkt_end.push_back(bkt_begin[i] + freq[i])));\\n\\n                std::vector<Ti> ret(len);\\n\\n                //Put lms suffixes at ends of buckets\\n                std::vector<Ti> bkt_end_copy(bkt_end);\\n                for (Ti i = lms.size(); i-- > 0; ret[--bkt_end[str[lms[i]]]] = lms[i]);\\n\\n                //Restore bkt_end\\n                bkt_end = std::move(bkt_end_copy);\\n\\n                //Place L-type suffixes at beginning of buckets\\n                for (Ti i = -1; ++i < len; ret[i] && types[ret[i] - 1] && (ret[bkt_begin[str[ret[i] - 1]]++] = ret[i] - 1));\\n\\n                //Place S-type suffixes at end of buckets\\n                for (Ti i = len; i-- > 0; ret[i] && !types[ret[i] - 1] && (ret[--bkt_end[str[ret[i] - 1]]] = ret[i] - 1));\\n\\n                return ret;\\n        };\\n\\n        //Run induced sorting using the LMS suffixes in the order they appear\\n        std::vector<Ti> sorted_blocks = induced_sort(lms);\\n\\n        //Number the LMS blocks, assigning duplicate blocks the same number\\n        const auto lms_block_equal = [&](Ti a, Ti b) {\\n                for (bool seen_l = false; !seen_l || types[a] || types[b]; seen_l |= types[a++] | types[b++]) {\\n                        if (str[a] != str[b] || types[a] != types[b])\\n                                return false;\\n                }\\n                return str[a] == str[b];\\n        };\\n        std::vector<Ti> lms_number_map(len);\\n        bool all_unique = true;\\n        for (Ti i, last_used_num = i = 0, prevlms = len - 1, curlms; ++i < len; is_lms[curlms = sorted_blocks[i]] && (lms_number_map[curlms] = lms_block_equal(curlms, prevlms) ? (all_unique = false, last_used_num) : ++last_used_num, prevlms = curlms));\\n\\n        //Form reduced string from block numbers\\n        std::vector<Ti> reduced;\\n        reduced.reserve(lms.size());\\n        for (const auto& i : lms) reduced.push_back(lms_number_map[i]);\\n\\n        std::vector<Ti> reduced_sa;\\n        if (all_unique) {\\n                //If all blocks are unique, directly invert\\n                reduced_sa.resize(lms.size());\\n                for (Ti i = lms.size(); i-- > 0; reduced_sa[reduced[i]] = i);\\n        } else {\\n                //Otherwise, recurse\\n                reduced_sa = sais<Ti>(reduced);\\n        }\\n\\n        //Use reduced suffix array to sort the LMS suffixes\\n        std::vector<Ti> sorted_lms;\\n        sorted_lms.reserve(lms.size());\\n        for (const auto& i : reduced_sa) sorted_lms.push_back(lms[i]);\\n\\n        //Do a second induced sorting pass of T using the LMS suffixes in sorted order.\\n        return induced_sort(sorted_lms);\\n}\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        text += \\'$\\';\\n        int n = text.size();\\n        auto sa = sais<int>(text);\\n        std::vector<int> sainv(n);\\n        for (int i = 0; i < n; ++i) {\\n            sainv[sa[i]] = i;\\n        }\\n        std::vector<int> lcp(2 * n);\\n        for (int i = 0, l = 0; i < n - 1; ++i) {\\n            int p = sa[sainv[i] - 1];\\n            while (text[i + l] == text[p + l]) ++l;\\n            lcp[n + sainv[i]] = l;\\n            if (l > 0) --l;\\n        }\\n        for (int i = n; --i; ) {\\n            lcp[i] = std::min(lcp[i << 1], lcp[i << 1 | 1]);\\n        }\\n        const auto lce = [&](int i, int j) {\\n            int l = sainv[i];\\n            int r = sainv[j];\\n            if (l > r) std::swap(l, r);\\n            int ret = n;\\n            for (l += 1 + n, r += 1 + n; l < r; l >>= 1, r >>= 1) {\\n                if (l & 1) ret = std::min(ret, lcp[l++]);\\n                if (r & 1) ret = std::min(ret, lcp[--r]);\\n            }\\n            return ret;\\n        };\\n        int groups = 0;\\n        int l = 0;\\n        // for (int i = 0; i < n; ++i) {\\n        //     std::cout << i << \":\" << sa[i] << \",\" << text.substr(sa[i]) << \",\" << lcp[n + i] << std::endl;\\n        // }\\n        for (int i = 0, j = n - 1; ++l, i < --j; ) {\\n            // std::cout << \"comparing\" << i << \",\" << j << \":\" << lce(i, j) << \">=\" << l << std::endl;\\n            if (lce(i, j) >= l) {\\n                i += l;\\n                groups += 2;\\n                l = 0;\\n                if (i >= j) break;\\n            }\\n        }\\n        if (l > 0) ++groups;\\n        return groups;\\n    }\\n};\\n```\\n\\nTheoretically, LCE queries can be improved to `O(1)` using a sparse table, but then the precomputation and space complexity goes up to `O(nlogn)`.\\nTo trim down on precomputation and get the resulting runtime to `O(n)`, it is possible to use Farach-Colton and Bender\\'s Algorithm.\\nThis uses least-common-ancestor (LCA) queries on the cartesian tree of the LCP array to identify the minimum element in the range.\\nLCA queries on a tree can be done by taking an euler tour of the tree to create an array of depths where adjacent elements differ by +-1, and doing RMQ on this +-1 array using the method of the four russians takes `O(n)` precomputation and `O(1)` per RMQ.",
                "solutionTags": [
                    "Tree",
                    "Suffix Array"
                ],
                "code": "```\\n/**\\n * Suffix array\\n * Uses SA-IS\\n *\\n * @param str A sequence of characters, with unique lexicographically smallest\\n * sentinel at the end\\n */\\ntemplate <typename Ti, typename Ts>\\nstd::vector<Ti> sais(Ts str) {\\n        Ti len = str.size();\\n        //Keep track of S(maller)=false or L(arger)=true type suffix\\n        //Sentinel is implicitly set to S already\\n        std::vector<bool> types(len);\\n        //Build types array by iterating right to left\\n        for (Ti i = len - 1; i-- > 0; types[i] = str[i] > str[i + 1] || str[i] == str[i + 1] && types[i + 1]);\\n\\n        //Find Left-Most S-type suffixes\\n        std::vector<Ti> lms;\\n        std::vector<bool> is_lms(len);\\n        for (Ti i = 0; ++i < len; types[i - 1] && !types[i] && (lms.push_back(i), is_lms[i] = true));\\n\\n        //Count character frequencies\\n        std::vector<Ti> freq;\\n        for (Ti i = len; i-- > 0; str[i] < freq.size() || (freq.resize(str[i] + 1), true), freq[str[i]]++);\\n\\n        /**\\n         * Induced sorting procedure\\n         *\\n         * @param lms LMS suffixes to put into the buckets\\n         */\\n        const auto induced_sort = [&](const std::vector<Ti>& lms) {\\n                Ti alphalen = freq.size();\\n                //Calculate bucket begin and end indicies\\n                std::vector<Ti> bkt_begin, bkt_end;\\n                bkt_begin.reserve(alphalen);\\n                bkt_end.reserve(alphalen);\\n                bkt_begin.push_back(0);\\n                bkt_end.push_back(freq[0]);\\n                for (Ti i = 0; ++i < alphalen; (bkt_begin.push_back(bkt_begin[i - 1] + freq[i - 1]), bkt_end.push_back(bkt_begin[i] + freq[i])));\\n\\n                std::vector<Ti> ret(len);\\n\\n                //Put lms suffixes at ends of buckets\\n                std::vector<Ti> bkt_end_copy(bkt_end);\\n                for (Ti i = lms.size(); i-- > 0; ret[--bkt_end[str[lms[i]]]] = lms[i]);\\n\\n                //Restore bkt_end\\n                bkt_end = std::move(bkt_end_copy);\\n\\n                //Place L-type suffixes at beginning of buckets\\n                for (Ti i = -1; ++i < len; ret[i] && types[ret[i] - 1] && (ret[bkt_begin[str[ret[i] - 1]]++] = ret[i] - 1));\\n\\n                //Place S-type suffixes at end of buckets\\n                for (Ti i = len; i-- > 0; ret[i] && !types[ret[i] - 1] && (ret[--bkt_end[str[ret[i] - 1]]] = ret[i] - 1));\\n\\n                return ret;\\n        };\\n\\n        //Run induced sorting using the LMS suffixes in the order they appear\\n        std::vector<Ti> sorted_blocks = induced_sort(lms);\\n\\n        //Number the LMS blocks, assigning duplicate blocks the same number\\n        const auto lms_block_equal = [&](Ti a, Ti b) {\\n                for (bool seen_l = false; !seen_l || types[a] || types[b]; seen_l |= types[a++] | types[b++]) {\\n                        if (str[a] != str[b] || types[a] != types[b])\\n                                return false;\\n                }\\n                return str[a] == str[b];\\n        };\\n        std::vector<Ti> lms_number_map(len);\\n        bool all_unique = true;\\n        for (Ti i, last_used_num = i = 0, prevlms = len - 1, curlms; ++i < len; is_lms[curlms = sorted_blocks[i]] && (lms_number_map[curlms] = lms_block_equal(curlms, prevlms) ? (all_unique = false, last_used_num) : ++last_used_num, prevlms = curlms));\\n\\n        //Form reduced string from block numbers\\n        std::vector<Ti> reduced;\\n        reduced.reserve(lms.size());\\n        for (const auto& i : lms) reduced.push_back(lms_number_map[i]);\\n\\n        std::vector<Ti> reduced_sa;\\n        if (all_unique) {\\n                //If all blocks are unique, directly invert\\n                reduced_sa.resize(lms.size());\\n                for (Ti i = lms.size(); i-- > 0; reduced_sa[reduced[i]] = i);\\n        } else {\\n                //Otherwise, recurse\\n                reduced_sa = sais<Ti>(reduced);\\n        }\\n\\n        //Use reduced suffix array to sort the LMS suffixes\\n        std::vector<Ti> sorted_lms;\\n        sorted_lms.reserve(lms.size());\\n        for (const auto& i : reduced_sa) sorted_lms.push_back(lms[i]);\\n\\n        //Do a second induced sorting pass of T using the LMS suffixes in sorted order.\\n        return induced_sort(sorted_lms);\\n}\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        text += \\'$\\';\\n        int n = text.size();\\n        auto sa = sais<int>(text);\\n        std::vector<int> sainv(n);\\n        for (int i = 0; i < n; ++i) {\\n            sainv[sa[i]] = i;\\n        }\\n        std::vector<int> lcp(2 * n);\\n        for (int i = 0, l = 0; i < n - 1; ++i) {\\n            int p = sa[sainv[i] - 1];\\n            while (text[i + l] == text[p + l]) ++l;\\n            lcp[n + sainv[i]] = l;\\n            if (l > 0) --l;\\n        }\\n        for (int i = n; --i; ) {\\n            lcp[i] = std::min(lcp[i << 1], lcp[i << 1 | 1]);\\n        }\\n        const auto lce = [&](int i, int j) {\\n            int l = sainv[i];\\n            int r = sainv[j];\\n            if (l > r) std::swap(l, r);\\n            int ret = n;\\n            for (l += 1 + n, r += 1 + n; l < r; l >>= 1, r >>= 1) {\\n                if (l & 1) ret = std::min(ret, lcp[l++]);\\n                if (r & 1) ret = std::min(ret, lcp[--r]);\\n            }\\n            return ret;\\n        };\\n        int groups = 0;\\n        int l = 0;\\n        // for (int i = 0; i < n; ++i) {\\n        //     std::cout << i << \":\" << sa[i] << \",\" << text.substr(sa[i]) << \",\" << lcp[n + i] << std::endl;\\n        // }\\n        for (int i = 0, j = n - 1; ++l, i < --j; ) {\\n            // std::cout << \"comparing\" << i << \",\" << j << \":\" << lce(i, j) << \">=\" << l << std::endl;\\n            if (lce(i, j) >= l) {\\n                i += l;\\n                groups += 2;\\n                l = 0;\\n                if (i >= j) break;\\n            }\\n        }\\n        if (l > 0) ++groups;\\n        return groups;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3788908,
                "title": "dp-rolling-hash-solution-c-explained",
                "content": "# Intuition\\nwe can compare if two substrings are euqal in O(1) time using rolling hash, with O(N) precomputation\\n\\n# Approach\\nfirstly we will calculate hash till every index of string and store in an array\\nLet say we solving subproblem from idx1 to idx2,\\nNow if(idx1 == idx2) we can easily return 1\\nelse\\n    we can start traversing from idx1 to half ans we will check \\n    if(hash(idx1 , i) == hash(j , idx2))\\n        in this case we maximize our result with\\n            ans(i + 1 , j - 1) + 2;\\nNote: we are also decreasing j while increasing i because we want equal strins from both sides\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N * N)\\n\\n- Space complexity:\\nO(N * N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7 ;\\n    int getHash(vector<long long>&hash, vector<long long>&power , int left , int right){\\n        if(left == 0)return hash[right];\\n        long long result = (hash[right] - (hash[left - 1] * power[right - left + 1] % mod) + mod) % mod;\\n        if(result < 0)\\n            result += mod ;\\n        return result % mod ;\\n    }\\n    vector<vector<int>>dp;\\n    int ans(int idx1 , int idx2 , vector<long long>&hash, vector<long long>&power){\\n        if(idx1 == idx2)return 1 ;\\n        if(idx1 > idx2)return 0 ;\\n        if(dp[idx1][idx2] != -1)return dp[idx1][idx2];\\n        int i = idx1 , j = idx2 ;\\n        int result = 1 ;\\n        while(i < j){\\n            int first = getHash(hash , power , idx1 , i);\\n            int second = getHash(hash , power , j , idx2);\\n            if(first == second){\\n                result = max(result , ans(i + 1 , j - 1 , hash , power) + 2);\\n            }\\n            i++ , j-- ;\\n        }\\n        return dp[idx1][idx2] = result  ;\\n    }\\n    int longestDecomposition(string text) {\\n        int n = text.length();\\n        long long base = 27;\\n        vector<long long>hash(n , 0);\\n        vector<long long>power(n , 0);\\n        power[0] = 1 ;\\n        long long h = 0 ;\\n        for(int i = 0 ; i < n ; i++){\\n            h = (h * base % mod + (text[i] - \\'a\\' + 1) % mod) % mod ;\\n            hash[i] = h ;\\n            if(i){\\n                power[i] = power[i - 1] * base ;\\n                power[i] %= mod ;\\n            }\\n        }\\n        dp = vector<vector<int>>(n , vector<int>(n , -1));\\n        return ans(0 , n - 1 , hash , power);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7 ;\\n    int getHash(vector<long long>&hash, vector<long long>&power , int left , int right){\\n        if(left == 0)return hash[right];\\n        long long result = (hash[right] - (hash[left - 1] * power[right - left + 1] % mod) + mod) % mod;\\n        if(result < 0)\\n            result += mod ;\\n        return result % mod ;\\n    }\\n    vector<vector<int>>dp;\\n    int ans(int idx1 , int idx2 , vector<long long>&hash, vector<long long>&power){\\n        if(idx1 == idx2)return 1 ;\\n        if(idx1 > idx2)return 0 ;\\n        if(dp[idx1][idx2] != -1)return dp[idx1][idx2];\\n        int i = idx1 , j = idx2 ;\\n        int result = 1 ;\\n        while(i < j){\\n            int first = getHash(hash , power , idx1 , i);\\n            int second = getHash(hash , power , j , idx2);\\n            if(first == second){\\n                result = max(result , ans(i + 1 , j - 1 , hash , power) + 2);\\n            }\\n            i++ , j-- ;\\n        }\\n        return dp[idx1][idx2] = result  ;\\n    }\\n    int longestDecomposition(string text) {\\n        int n = text.length();\\n        long long base = 27;\\n        vector<long long>hash(n , 0);\\n        vector<long long>power(n , 0);\\n        power[0] = 1 ;\\n        long long h = 0 ;\\n        for(int i = 0 ; i < n ; i++){\\n            h = (h * base % mod + (text[i] - \\'a\\' + 1) % mod) % mod ;\\n            hash[i] = h ;\\n            if(i){\\n                power[i] = power[i - 1] * base ;\\n                power[i] %= mod ;\\n            }\\n        }\\n        dp = vector<vector<int>>(n , vector<int>(n , -1));\\n        return ans(0 , n - 1 , hash , power);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729007,
                "title": "detailed-commented-easy-c-solution-beats-100-memory",
                "content": "# Solution\\n\\n1. The solution begins by checking if the given string is empty. If so, it returns 1. This is an edge case which is separately addressed as technically an empty string doesn\\'t satisfy the problem\\'s criteria, but logically there is one substring, the empty string itself.\\n\\n2. Then a counter `k` is initialized to 0. This counter is utilized to keep track of the number of mirrored substrings found thus far.\\n\\n3. Two variables `left` and `len` are used to keep track of the starting point of the current left substring and the length of the current substring respectively.\\n\\n4. `halfSize` is calculated as half the length of the string. There can\\'t be a valid pair of mirrored substrings beyond this point. `isZ` checks if the string length is even. This boolean value is used later to determine whether or not to increment `k` an additional time.\\n\\n5. `ss` is a string_view of the input string, `text`, which provides more efficient substring operations. `firstStr` and `secondStr` are string_views that will represent the current pair of substrings being compared.\\n\\n6. The solution enters a loop which continues until the left starting point plus the current length exceed the halfway point. Inside the loop, it extracts two substrings from the original string: one starting from the left and one from the mirrored right position.\\n\\n7. If the two substrings are equal, `k` is incremented to indicate a match, `left` is moved forward by the length of the matched substring, and `len` is reset to 1 for the next round of substring extraction.\\n\\n8. If the two substrings are not equal, `len` is incremented to increase the length of the substring being compared in the next iteration.\\n\\n9. After the loop, `k` is doubled to account for the mirrored pairs of substrings found. If `left` hasn\\'t reached the halfway point, or if the string length is odd (which means there is a central unpaired character), `k` is incremented an additional time.\\n\\n10. Finally, `k` is returned as the largest possible number of substrings that satisfy the problem\\'s criteria.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n\\n        if(text.length() == 0) return 1;\\n\\n        int k = 0;\\n        int left = 0;\\n        int len = 1;\\n        int halfSize =text.length()/2;\\n        bool isZ = !(text.length() % 2);\\n\\n        string_view ss =text;\\n        string_view firstStr;\\n        string_view secondStr;\\n\\n        while (left + len <= halfSize)\\n        {\\n            firstStr = ss.substr(left, len);\\n            secondStr = ss.substr(text.length() - left - len, len);if(firstStr == secondStr)\\n            {\\n                k++;\\n                left += len;\\n                len = 1;\\n            }\\n            else\\n            {\\n                len++;\\n            }\\n        }\\n        k *=2;\\n        if(left != halfSize || !isZ) k++;\\n\\n        return k;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string& text) {\\n\\n        if(text.length() == 0) return 1;\\n\\n        int k = 0;\\n        int left = 0;\\n        int len = 1;\\n        int halfSize =text.length()/2;\\n        bool isZ = !(text.length() % 2);\\n\\n        string_view ss =text;\\n        string_view firstStr;\\n        string_view secondStr;\\n\\n        while (left + len <= halfSize)\\n        {\\n            firstStr = ss.substr(left, len);\\n            secondStr = ss.substr(text.length() - left - len, len);if(firstStr == secondStr)\\n            {\\n                k++;\\n                left += len;\\n                len = 1;\\n            }\\n            else\\n            {\\n                len++;\\n            }\\n        }\\n        k *=2;\\n        if(left != halfSize || !isZ) k++;\\n\\n        return k;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705529,
                "title": "fast-solution-with-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        char[] c = text.toCharArray();\\n        int highest = 0;\\n        int lowest = c.length;\\n        int ans = 0;\\n        while (highest < lowest){\\n            char letter = c[highest];\\n            int length = 0;\\n            for (int i = lowest - 1; i >= 0; i--){\\n                int temp_lowest;\\n                if (c[i] == letter){\\n                    length = lowest - i;\\n                    temp_lowest = i; //temporary lowest\\n                }\\n                else continue;\\n                \\n                if (highest >= temp_lowest){\\n                    if (highest < lowest) ans++; //there is at least one more unused letter\\n                    lowest = -1; //to break out of the while loop\\n                    break;\\n                }\\n                \\n                boolean same = true;\\n                for (int j = 0; j < length; j++){\\n                    char left = c[highest+j];\\n                    char right = c[temp_lowest+j];\\n                    if (left != right) same = false;\\n                }\\n                if (same){\\n                    ans += 2;\\n                    highest += length;\\n                    lowest = i;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        char[] c = text.toCharArray();\\n        int highest = 0;\\n        int lowest = c.length;\\n        int ans = 0;\\n        while (highest < lowest){\\n            char letter = c[highest];\\n            int length = 0;\\n            for (int i = lowest - 1; i >= 0; i--){\\n                int temp_lowest;\\n                if (c[i] == letter){\\n                    length = lowest - i;\\n                    temp_lowest = i; //temporary lowest\\n                }\\n                else continue;\\n                \\n                if (highest >= temp_lowest){\\n                    if (highest < lowest) ans++; //there is at least one more unused letter\\n                    lowest = -1; //to break out of the while loop\\n                    break;\\n                }\\n                \\n                boolean same = true;\\n                for (int j = 0; j < length; j++){\\n                    char left = c[highest+j];\\n                    char right = c[temp_lowest+j];\\n                    if (left != right) same = false;\\n                }\\n                if (same){\\n                    ans += 2;\\n                    highest += length;\\n                    lowest = i;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683670,
                "title": "simple-greedy-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int cnt = 0;\\n\\n        int i = 0 , j = text.length()-1;\\n\\n        string a , b;\\n\\n        while(i < j) {\\n            a += text[i];\\n            b = text[j] + b;\\n\\n            if(a == b) {\\n                cnt++;\\n                a = \"\";\\n                b = \"\";\\n            }\\n\\n            i++; j--;\\n        }\\n\\n        cnt *= 2;    // total 2*cnt partitions\\n\\n        if(i == j && a == \"\" && b == \"\") cnt++;    // think about tc : \"aaa\" (edge case)\\n        \\n        if(a != \"\" && b != \"\")cnt++;    // a & b were not matching so count them as a combined partition\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int cnt = 0;\\n\\n        int i = 0 , j = text.length()-1;\\n\\n        string a , b;\\n\\n        while(i < j) {\\n            a += text[i];\\n            b = text[j] + b;\\n\\n            if(a == b) {\\n                cnt++;\\n                a = \"\";\\n                b = \"\";\\n            }\\n\\n            i++; j--;\\n        }\\n\\n        cnt *= 2;    // total 2*cnt partitions\\n\\n        if(i == j && a == \"\" && b == \"\") cnt++;    // think about tc : \"aaa\" (edge case)\\n        \\n        if(a != \"\" && b != \"\")cnt++;    // a & b were not matching so count them as a combined partition\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682541,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def longestDecomposition(text: String): Int = {\\n      val n = text.length\\n      var result = 0\\n      var i = 0\\n      var found = false\\n\\n      while (i < n/2 && !found) {\\n        if (text.substring(0, i + 1) == text.substring(n-1-i, n)) {\\n          result = 2 + longestDecomposition(text.substring(i+1, n-1-i))\\n          found = true\\n        }\\n        i += 1\\n      }\\n\\n      if (!found) if (n == 0) 0 else 1\\n      else result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def longestDecomposition(text: String): Int = {\\n      val n = text.length\\n      var result = 0\\n      var i = 0\\n      var found = false\\n\\n      while (i < n/2 && !found) {\\n        if (text.substring(0, i + 1) == text.substring(n-1-i, n)) {\\n          result = 2 + longestDecomposition(text.substring(i+1, n-1-i))\\n          found = true\\n        }\\n        i += 1\\n      }\\n\\n      if (!found) if (n == 0) 0 else 1\\n      else result\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3671140,
                "title": "easy-to-understand-c-solution-2-pointers-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Example : ghisghisghi\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int left = 0, right = n - 1, count = 0;\\n        string substr1, substr2;\\n\\n        while (left < right) {\\n            substr1 = substr1 + text[left]; // append the letter at the end\\n            substr2 = text[right] + substr2; // append the letter at the front\\n\\n            if (substr1 == substr2) { // ghi (sghi) ghi\\n                count += 2;\\n                substr1 = \"\";\\n                substr2 = \"\";\\n            }\\n\\n            left++;\\n            right--; // sg hi .. after this left > right\\n        }\\n\\n        if (left == right || !substr1.empty()) { // substr of the form (s1)s2(s1)\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Example : ghisghisghi\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int left = 0, right = n - 1, count = 0;\\n        string substr1, substr2;\\n\\n        while (left < right) {\\n            substr1 = substr1 + text[left]; // append the letter at the end\\n            substr2 = text[right] + substr2; // append the letter at the front\\n\\n            if (substr1 == substr2) { // ghi (sghi) ghi\\n                count += 2;\\n                substr1 = \"\";\\n                substr2 = \"\";\\n            }\\n\\n            left++;\\n            right--; // sg hi .. after this left > right\\n        }\\n\\n        if (left == right || !substr1.empty()) { // substr of the form (s1)s2(s1)\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630283,
                "title": "longest-chunked-palindrome-decomposition-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nitrate 1 side check other side \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        l=0\\n        r=1\\n        n=len(text)\\n        res=0\\n        while r<=n//2:\\n            print(text[l:r])\\n            if (l==0 and text[l:r]==text[-r:]) or text[l:r]==text[-r:-l]:\\n                res+=2\\n                l=r\\n                r+=1\\n            else:\\n                r+=1\\n        s=text[l:-l]\\n        print(s)\\n        if l==0:\\n            s=text\\n        \\n        if len(s)==1 or s[::-1]!=s:\\n            res+=1\\n    \\n        \\n        return res\\n                \\n            \\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        l=0\\n        r=1\\n        n=len(text)\\n        res=0\\n        while r<=n//2:\\n            print(text[l:r])\\n            if (l==0 and text[l:r]==text[-r:]) or text[l:r]==text[-r:-l]:\\n                res+=2\\n                l=r\\n                r+=1\\n            else:\\n                r+=1\\n        s=text[l:-l]\\n        print(s)\\n        if l==0:\\n            s=text\\n        \\n        if len(s)==1 or s[::-1]!=s:\\n            res+=1\\n    \\n        \\n        return res\\n                \\n            \\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626223,
                "title": "antarnab-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   // public int longestDecomposition(String text) {\\n            public int longestDecomposition(String S) {\\n        int res = 0, n = S.length();\\n        String l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S.charAt(i);\\n            r = S.charAt(n - i - 1) + r;\\n            if (l.equals(r)) {\\n                ++res;\\n                l = \"\";\\n                r = \"\";//Antarnab solution\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   // public int longestDecomposition(String text) {\\n            public int longestDecomposition(String S) {\\n        int res = 0, n = S.length();\\n        String l = \"\", r = \"\";\\n        for (int i = 0; i < n; ++i) {\\n            l = l + S.charAt(i);\\n            r = S.charAt(n - i - 1) + r;\\n            if (l.equals(r)) {\\n                ++res;\\n                l = \"\";\\n                r = \"\";//Antarnab solution\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625574,
                "title": "recursion-simple-logic",
                "content": "# Intuition\\nIt can be seen from the task that you need to split this string into the maximum number of substrings with the following list of requirements:\\n\\n1. The substrings must be the same.\\n1. Substrings should be placed at the beginning and end of the main line.\\n\\n# Approach\\nTo solve this problem, it is necessary to use a recursive algorithm. \\nWe need to check whether it is possible to isolate two pieces of a string that are identical to each other (one of the pairs), then remove them from the string and repeat for the remaining parts.\\nThe recursion ends when we can no longer get two comparable substrings.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\nThe algorithm goes through each character of the string twice (i.e. the complexity is $$O(n))$$, but we also have another loop inside - this is from `i=1 to n/2`. The loop finds potential pairs of substrings in the main string, so the entire time of the function is $$O(n^2)$$.\\n\\n- Space complexity: $$O(n)$$\\nIn the worst case, a new variable will be created for each character of the string - the complexity of the space will be $$O(n)$$.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestDecomposition(string text)\\n    {\\n        string helper = text;\\n        int count = 0;\\n\\n        void Recursive(string txt)\\n        {\\n            helper = txt;\\n            for (int i = 1; i <= txt.Length / 2; i++)\\n            {\\n                if (txt.Substring(0, i) == txt.Substring(txt.Length - i))\\n                {\\n                    count += 2;\\n                    Recursive(txt.Substring(i, txt.Length - 2 * i));\\n                    break;\\n                }\\n            }\\n        }\\n\\n        Recursive(text);\\n        return (helper == \"\") ? count : count + 1;\\n    }\\n}\\n```\\n\\nThis function takes the string text as an argument and returns an integer - the maximum number of substrings into which this string can be divided according to the rules from the task.\\n\\nThe function starts by storing the value of the original string in the helper variable, and then recursively calls itself to search for substrings. If a pair of substrings was found, the function increments the count counter by 2 and runs recursively with the trimmed string. The recursion continues until the end of the string is reached.\\n\\nThe return value is determined by the value of the helper variable. If after all the actions its value is an empty string, then we can return the current count value. Otherwise, i.e. if no pair of substrings could be found, the current value `count + 1` is returned.\\n",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestDecomposition(string text)\\n    {\\n        string helper = text;\\n        int count = 0;\\n\\n        void Recursive(string txt)\\n        {\\n            helper = txt;\\n            for (int i = 1; i <= txt.Length / 2; i++)\\n            {\\n                if (txt.Substring(0, i) == txt.Substring(txt.Length - i))\\n                {\\n                    count += 2;\\n                    Recursive(txt.Substring(i, txt.Length - 2 * i));\\n                    break;\\n                }\\n            }\\n        }\\n\\n        Recursive(text);\\n        return (helper == \"\") ? count : count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606466,
                "title": "python3-consuming-shortest-palindrome-from-either-end-of-text",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        count = 0\\n        start = 0\\n        end = len(text) - 1\\n        while end - start > 0:\\n            if text[:start+1] == text[end:]:\\n                count += 2\\n                text = text[start+1:end]\\n                start = 0\\n                end = len(text) - 1\\n                continue\\n            start += 1\\n            end -= 1\\n        if len(text) > 0: count += 1\\n        return count \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        count = 0\\n        start = 0\\n        end = len(text) - 1\\n        while end - start > 0:\\n            if text[:start+1] == text[end:]:\\n                count += 2\\n                text = text[start+1:end]\\n                start = 0\\n                end = len(text) - 1\\n                continue\\n            start += 1\\n            end -= 1\\n        if len(text) > 0: count += 1\\n        return count \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600676,
                "title": "simple-question-greedy-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int cnt = 0;\\n        int n = text.length();\\n        int i = 0;\\n        int j = n-1;\\n        int e = j;\\n        while(i<=j){\\n            if(i==j){\\n                cnt++;\\n                break;\\n            }\\n            if(text[i]==text[j]){\\n                int d = e-j+1;\\n                int ind = i;\\n                bool flag = true;\\n                for(int k=j; k<=e; k++){\\n                    if(text[ind]!=text[k]){\\n                        flag = false;\\n                        break;\\n                    }\\n                    ind++;\\n                }\\n                if(flag){\\n                    i = ind;\\n                    cnt+=2;\\n                    e = j-1;\\n                }\\n                j--;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int cnt = 0;\\n        int n = text.length();\\n        int i = 0;\\n        int j = n-1;\\n        int e = j;\\n        while(i<=j){\\n            if(i==j){\\n                cnt++;\\n                break;\\n            }\\n            if(text[i]==text[j]){\\n                int d = e-j+1;\\n                int ind = i;\\n                bool flag = true;\\n                for(int k=j; k<=e; k++){\\n                    if(text[ind]!=text[k]){\\n                        flag = false;\\n                        break;\\n                    }\\n                    ind++;\\n                }\\n                if(flag){\\n                    i = ind;\\n                    cnt+=2;\\n                    e = j-1;\\n                }\\n                j--;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574849,
                "title": "golang-using-z-functions-dp",
                "content": "# Intuition\\nWe can use the Z function to efficiently identify the shortest suffix that is also a prefix of a particular string.\\n\\n# Code\\n```\\nfunc longestDecomposition(text string) int {\\n  return dp(text)\\n}\\n\\nfunc dp(s string) int {\\n  if len(s) == 0 {\\n    return 0\\n  }\\n  // Using Z functions check for prefix\\n  z := make([]int, len(s))\\n  l, r := 0, 0\\n  for i := 1; i < len(s); i++ {\\n    if i < r {\\n      z[i] = min(r - i, z[i - l])\\n    }\\n    for i+z[i] < len(s) && s[z[i]] == s[i+z[i]] {\\n      z[i]++\\n    }\\n    if i + z[i] > r {\\n      l = i\\n      r = i+z[i]\\n    }\\n  }\\n  i := len(s)-1\\n  sublen := 0\\n  for i >= 0 {\\n    if i + z[i] == len(s) {\\n      sublen = z[i]\\n      break\\n    }\\n    i--\\n  }\\n  // No substring match. Z[0] is undefined\\n  if i == -1 {\\n    return 1\\n  }\\n  return 2 + dp(s[sublen:len(s)-sublen])\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "String Matching"
                ],
                "code": "```\\nfunc longestDecomposition(text string) int {\\n  return dp(text)\\n}\\n\\nfunc dp(s string) int {\\n  if len(s) == 0 {\\n    return 0\\n  }\\n  // Using Z functions check for prefix\\n  z := make([]int, len(s))\\n  l, r := 0, 0\\n  for i := 1; i < len(s); i++ {\\n    if i < r {\\n      z[i] = min(r - i, z[i - l])\\n    }\\n    for i+z[i] < len(s) && s[z[i]] == s[i+z[i]] {\\n      z[i]++\\n    }\\n    if i + z[i] > r {\\n      l = i\\n      r = i+z[i]\\n    }\\n  }\\n  i := len(s)-1\\n  sublen := 0\\n  for i >= 0 {\\n    if i + z[i] == len(s) {\\n      sublen = z[i]\\n      break\\n    }\\n    i--\\n  }\\n  // No substring match. Z[0] is undefined\\n  if i == -1 {\\n    return 1\\n  }\\n  return 2 + dp(s[sublen:len(s)-sublen])\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555557,
                "title": "two-pointer-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\nLet `n` = length  of `text` string\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int k = 0;\\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        for(int i = 0,j = text.length() - 1;j >= 0;i++,--j){\\n            sb1.append(text.charAt(i));\\n            sb2.insert(0,text.charAt(j));\\n            if(sb1.toString().equals(sb2.toString())){\\n                k += 2;\\n                sb1.delete(0,sb1.length());\\n                sb2.delete(0,sb2.length());\\n            }\\n        }\\n        k++;\\n        return k / 2;\\n    }\\n}\\n```\\n\\n# Upvote if you like it \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int k = 0;\\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        for(int i = 0,j = text.length() - 1;j >= 0;i++,--j){\\n            sb1.append(text.charAt(i));\\n            sb2.insert(0,text.charAt(j));\\n            if(sb1.toString().equals(sb2.toString())){\\n                k += 2;\\n                sb1.delete(0,sb1.length());\\n                sb2.delete(0,sb2.length());\\n            }\\n        }\\n        k++;\\n        return k / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543112,
                "title": "python-3-hashing-greedy-o-n-time",
                "content": "# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    X, X_INV, MOD = 31, 129032259, 1000000007\\n\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        prefixHash = [0] * (n + 1)\\n        xiInvs = [0] * n\\n        h, xi, xiInv = 0, 1, 1\\n        for i, c in enumerate(text):\\n            val = ord(c) - 96\\n            h = (h + xi*val) % Solution.MOD\\n            prefixHash[i] = h\\n            xiInvs[i] = xiInv\\n            xi = (Solution.X * xi) % Solution.MOD\\n            xiInv = (Solution.X_INV * xiInv) % Solution.MOD\\n        \\n        def equal(i, j):\\n            h1 = ((prefixHash[j] - prefixHash[i - 1]) * xiInvs[i]) % Solution.MOD\\n            ir, jr = n - i - 1, n - j - 1\\n            h2 = ((prefixHash[ir] - prefixHash[jr - 1]) * xiInvs[jr]) % Solution.MOD\\n            if h1 != h2:\\n                return False\\n            return all(text[i + idx] == text[jr + idx] for idx in range(j - i + 1))\\n\\n        half = n >> 1\\n        res = i = j = 0\\n        while i < half:\\n            if j == half:\\n                return res + 1\\n            if equal(i, j):\\n                res += 2\\n                i = j + 1\\n            j += 1\\n        return res + (n & 1)\\n\\n                \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    X, X_INV, MOD = 31, 129032259, 1000000007\\n\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        prefixHash = [0] * (n + 1)\\n        xiInvs = [0] * n\\n        h, xi, xiInv = 0, 1, 1\\n        for i, c in enumerate(text):\\n            val = ord(c) - 96\\n            h = (h + xi*val) % Solution.MOD\\n            prefixHash[i] = h\\n            xiInvs[i] = xiInv\\n            xi = (Solution.X * xi) % Solution.MOD\\n            xiInv = (Solution.X_INV * xiInv) % Solution.MOD\\n        \\n        def equal(i, j):\\n            h1 = ((prefixHash[j] - prefixHash[i - 1]) * xiInvs[i]) % Solution.MOD\\n            ir, jr = n - i - 1, n - j - 1\\n            h2 = ((prefixHash[ir] - prefixHash[jr - 1]) * xiInvs[jr]) % Solution.MOD\\n            if h1 != h2:\\n                return False\\n            return all(text[i + idx] == text[jr + idx] for idx in range(j - i + 1))\\n\\n        half = n >> 1\\n        res = i = j = 0\\n        while i < half:\\n            if j == half:\\n                return res + 1\\n            if equal(i, j):\\n                res += 2\\n                i = j + 1\\n            j += 1\\n        return res + (n & 1)\\n\\n                \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480710,
                "title": "c-recursion-but-beast-22",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i, string s) {\\n        int j=s.size()-1;\\n        if(i==j) return 1;\\n        if(i>j) return 0;\\n        while(i<j) {\\n            string a=s.substr(j);\\n            string b=s.substr(i,s.size()-j);\\n            if(a==b) {\\n                return 2+solve(0,s.substr(s.size()-j,j-(s.size()-j)));\\n                break ;\\n            }\\n            j--;\\n        }\\n        return 1;\\n    }\\n    int longestDecomposition(string text) {\\n        return solve(0,text);\\n    }\\n# };\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, string s) {\\n        int j=s.size()-1;\\n        if(i==j) return 1;\\n        if(i>j) return 0;\\n        while(i<j) {\\n            string a=s.substr(j);\\n            string b=s.substr(i,s.size()-j);\\n            if(a==b) {\\n                return 2+solve(0,s.substr(s.size()-j,j-(s.size()-j)));\\n                break ;\\n            }\\n            j--;\\n        }\\n        return 1;\\n    }\\n    int longestDecomposition(string text) {\\n        return solve(0,text);\\n    }\\n# };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411317,
                "title": "1147-longest-chunked-palindrome-decomposition-c-two-pointer-stack-prateek-ece",
                "content": "# Intuition (Ignore grammatical errors)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointer and stack will come into you mind when you see the problem;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbhut simple hai code dekh lo;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) + thoda sa jada ;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N);\\n\\n\\n# Code\\n```\\n\\n#define For(i,a,b) for(int i=a; i<b; i++)\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        stack<int> st;\\n        int i=0;\\n        int j=text.size()-1;\\n        int cnt=0;\\n        while (i<=j){\\n            st.push(text[i]);\\n            stack<int>temp;\\n            int tempj=j;\\n            while(!st.empty() && text[j]==st.top()&& i!=j){\\n                temp.push(st.top());\\n                st.pop();\\n                j--;\\n            }\\n            \\n            if (st.empty()) {\\n                cnt++;\\n            }\\n            else{\\n                while(!temp.empty()){\\n                    st.push(temp.top());\\n                    temp.pop();\\n                }\\n                j=tempj;\\n            }\\n            i++;\\n        }\\n    \\n    cnt*=2;\\n\\n    if(!st.empty()) cnt++;\\n\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n#define For(i,a,b) for(int i=a; i<b; i++)\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        stack<int> st;\\n        int i=0;\\n        int j=text.size()-1;\\n        int cnt=0;\\n        while (i<=j){\\n            st.push(text[i]);\\n            stack<int>temp;\\n            int tempj=j;\\n            while(!st.empty() && text[j]==st.top()&& i!=j){\\n                temp.push(st.top());\\n                st.pop();\\n                j--;\\n            }\\n            \\n            if (st.empty()) {\\n                cnt++;\\n            }\\n            else{\\n                while(!temp.empty()){\\n                    st.push(temp.top());\\n                    temp.pop();\\n                }\\n                j=tempj;\\n            }\\n            i++;\\n        }\\n    \\n    cnt*=2;\\n\\n    if(!st.empty()) cnt++;\\n\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393406,
                "title": "kmp-algorithm-o-n-2-string-lps",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int compute_lps(string& s,int st,int en){\\n\\n        //  case 1\\n        if(s[st]==s[en]){\\n           return 1;\\n        }\\n\\n        // case 2 : lps\\n        int n = en-st+1;\\n        vector<int>lps(n,st);\\n\\n        int len = st;\\n        int i = st+1;\\n\\n        while(i<=en){\\n            if(s[i] == s[len]){\\n                lps[i-st] = len+1;\\n                i++;\\n                len++;\\n            }\\n            else if(len == st){\\n                lps[i-st] = st;\\n                i++;\\n            }\\n            else{\\n                len = lps[len-1-st];\\n            }\\n        }\\n        return len-st;\\n    }\\n\\n    int solve(string& text,int st,int en){\\n        // base case\\n        if(st>en) return 0;\\n        if(st == en) return 1;\\n\\n        // compute lps\\n        int lps_len = compute_lps(text,st,en);\\n        if(lps_len == 0) return 1;\\n        return 2 + solve(text,st+lps_len,en-lps_len);\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return solve(text,0,text.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int compute_lps(string& s,int st,int en){\\n\\n        //  case 1\\n        if(s[st]==s[en]){\\n           return 1;\\n        }\\n\\n        // case 2 : lps\\n        int n = en-st+1;\\n        vector<int>lps(n,st);\\n\\n        int len = st;\\n        int i = st+1;\\n\\n        while(i<=en){\\n            if(s[i] == s[len]){\\n                lps[i-st] = len+1;\\n                i++;\\n                len++;\\n            }\\n            else if(len == st){\\n                lps[i-st] = st;\\n                i++;\\n            }\\n            else{\\n                len = lps[len-1-st];\\n            }\\n        }\\n        return len-st;\\n    }\\n\\n    int solve(string& text,int st,int en){\\n        // base case\\n        if(st>en) return 0;\\n        if(st == en) return 1;\\n\\n        // compute lps\\n        int lps_len = compute_lps(text,st,en);\\n        if(lps_len == 0) return 1;\\n        return 2 + solve(text,st+lps_len,en-lps_len);\\n    }\\n\\n    int longestDecomposition(string text) {\\n        return solve(text,0,text.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376687,
                "title": "c",
                "content": "```\\nint longestDecomposition(char * text){\\n    int n = strlen(text) ;\\n    int ret = 0 ;\\n    int left = 0, right ;\\n    for(right = 1; right <= n/2; right++){\\n        int len = right - left ;\\n        bool flag = true ;\\n        for(int i = 0; i < len; i++){\\n            if(text[left+i] != text[n-right+i]){\\n                flag = false ;\\n                break ;\\n            }\\n        }\\n        if(flag){\\n            ret += 2 ;\\n            left = right ;\\n        }\\n    }\\n    if(left * 2 < n)\\n        ret++ ;\\n    return ret ;\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nint longestDecomposition(char * text){\\n    int n = strlen(text) ;\\n    int ret = 0 ;\\n    int left = 0, right ;\\n    for(right = 1; right <= n/2; right++){\\n        int len = right - left ;\\n        bool flag = true ;\\n        for(int i = 0; i < len; i++){\\n            if(text[left+i] != text[n-right+i]){\\n                flag = false ;\\n                break ;\\n            }\\n        }\\n        if(flag){\\n            ret += 2 ;\\n            left = right ;\\n        }\\n    }\\n    if(left * 2 < n)\\n        ret++ ;\\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3358776,
                "title": "brute-force",
                "content": "**INTUTION :-** \\njust use brute force, save the all occurences of each characters in string in a map then start traversing from the starting find the first character that is same from the end of the string and check until u find the same string as from starting and ending add+=2 if u find the string otherwise add+=1 and break\\n\\n```\\n\\t    int ans = 0;\\n    bool check(string s)\\n    {\\n        sort(s.begin() , s.end());\\n        return s[0] == s[s.length()-1];\\n    }\\n    int longestDecomposition(string text) {\\n        \\n        if(check(text)) return text.length();\\n        map<char ,  vector<int>> mp;\\n        int i = text.length()-1;\\n        for(;i>=0 ; i--)\\n        {\\n            mp[text[i]].push_back(i);\\n        }\\n        i = 0;\\n        int j = text.length()-1;\\n        cout<<mp[\\'h\\'].size();\\n        for( ;i<=j ; )\\n        {\\n            cout<<text[i]<<\" \";\\n            int len = j - mp[text[i]].front()+1;\\n            while(mp[text[i]].size() > 0  && text.substr(i , len) != text.substr(mp[text[i]].front() , len) )\\n            {\\n                mp[text[i]].erase(mp[text[i]].begin());\\n                // cout<<mp[text[i]].front();\\n                // j = mp[text[i]].front()-1;\\n                len = j-mp[text[i]].front()+1;\\n            }\\n            if(mp[text[i]].front() == i)\\n            {\\n                ans+=1;\\n                break;\\n            }\\n            \\n            if(text.substr(i , len) == text.substr(mp[text[i]].front() , len))\\n            {\\n                ans+=2;\\n                j = mp[text[i]].front()-1;\\n                mp[text[i]].erase(mp[text[i]].begin());\\n            }\\n            else\\n            {\\n\\n                ans+=1;\\n                break;\\n            }\\n            i = i+len;\\n        }\\n        return ans;\\n        \\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t    int ans = 0;\\n    bool check(string s)\\n    {\\n        sort(s.begin() , s.end());\\n        return s[0] == s[s.length()-1];\\n    }\\n    int longestDecomposition(string text) {\\n        \\n        if(check(text)) return text.length();\\n        map<char ,  vector<int>> mp;\\n        int i = text.length()-1;\\n        for(;i>=0 ; i--)\\n        {\\n            mp[text[i]].push_back(i);\\n        }\\n        i = 0;\\n        int j = text.length()-1;\\n        cout<<mp[\\'h\\'].size();\\n        for( ;i<=j ; )\\n        {\\n            cout<<text[i]<<\" \";\\n            int len = j - mp[text[i]].front()+1;\\n            while(mp[text[i]].size() > 0  && text.substr(i , len) != text.substr(mp[text[i]].front() , len) )\\n            {\\n                mp[text[i]].erase(mp[text[i]].begin());\\n                // cout<<mp[text[i]].front();\\n                // j = mp[text[i]].front()-1;\\n                len = j-mp[text[i]].front()+1;\\n            }\\n            if(mp[text[i]].front() == i)\\n            {\\n                ans+=1;\\n                break;\\n            }\\n            \\n            if(text.substr(i , len) == text.substr(mp[text[i]].front() , len))\\n            {\\n                ans+=2;\\n                j = mp[text[i]].front()-1;\\n                mp[text[i]].erase(mp[text[i]].begin());\\n            }\\n            else\\n            {\\n\\n                ans+=1;\\n                break;\\n            }\\n            i = i+len;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3352965,
                "title": "easy-greedy-4-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, S, res=0):\\n        n = len(S)\\n        for l in range(1, n // 2 + 1):\\n            if S[0] == S[n - l] and S[l - 1] == S[n - 1]:\\n                if S[:l] == S[n - l:]: return self.longestDecomposition(S[l:n - l], res + 2)\\n        return res + 1 if S else res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, S, res=0):\\n        n = len(S)\\n        for l in range(1, n // 2 + 1):\\n            if S[0] == S[n - l] and S[l - 1] == S[n - 1]:\\n                if S[:l] == S[n - l:]: return self.longestDecomposition(S[l:n - l], res + 2)\\n        return res + 1 if S else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328533,
                "title": "c-clean-and-concise",
                "content": "# Intuition\\nwhen equal string found both end -> recurse for remaining function\\n\\n# Approach\\nGreedly take strings from both ends, if equal strings found then call recursive function for remaining string\\n\\n# Complexity\\n- Time complexity:\\nO(N2)\\n\\n- Space complexity:\\nBased on recursive call\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(string &s, int i)\\n    {\\n        int j=s.length()-1-i;\\n        int currLength=j-i+1;\\n        if(currLength<=1) return currLength;\\n\\n        for(int len=1;len<=currLength/2;len++)\\n        {\\n            if(s.substr(i,len)==s.substr(j-len+1,len))\\n            {\\n                return 2+fun(s,i+len);\\n            }\\n        }\\n        return 1;\\n    }\\n\\n\\n    int longestDecomposition(string text) {\\n        //greedy\\n        return fun(text,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int fun(string &s, int i)\\n    {\\n        int j=s.length()-1-i;\\n        int currLength=j-i+1;\\n        if(currLength<=1) return currLength;\\n\\n        for(int len=1;len<=currLength/2;len++)\\n        {\\n            if(s.substr(i,len)==s.substr(j-len+1,len))\\n            {\\n                return 2+fun(s,i+len);\\n            }\\n        }\\n        return 1;\\n    }\\n\\n\\n    int longestDecomposition(string text) {\\n        //greedy\\n        return fun(text,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291656,
                "title": "go-0ms-recursively-check-for-first-palindrome-substring",
                "content": "```go\\nfunc longestDecomposition(text string) int {\\n    return firstDecomp(text)\\n}\\n\\nfunc firstDecomp(text string) int {\\n    if len(text) == 0 {\\n        return 0\\n    }\\n    i := 1\\n    for ;i<len(text);i++ {\\n        if text[i-1] != text[len(text)-1] {\\n            continue\\n        }\\n        begin := text[:i]\\n        end := text[len(text)-i:]\\n        if begin == end {\\n            break\\n        }\\n    }\\n    if i == len(text) {\\n        return 1\\n    }\\n    decompedText := text[i:len(text)-i]\\n    return 2 + firstDecomp(decompedText)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```go\\nfunc longestDecomposition(text string) int {\\n    return firstDecomp(text)\\n}\\n\\nfunc firstDecomp(text string) int {\\n    if len(text) == 0 {\\n        return 0\\n    }\\n    i := 1\\n    for ;i<len(text);i++ {\\n        if text[i-1] != text[len(text)-1] {\\n            continue\\n        }\\n        begin := text[:i]\\n        end := text[len(text)-i:]\\n        if begin == end {\\n            break\\n        }\\n    }\\n    if i == len(text) {\\n        return 1\\n    }\\n    decompedText := text[i:len(text)-i]\\n    return 2 + firstDecomp(decompedText)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259057,
                "title": "100-fast-easy-to-understand-greedy-2-pointer-approach-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Two Pointer Approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe increase the prefix and suffix chunk unless they are equal.\\nOnce they are equal i.e, prefix == reverse( Suffix ), we increase the result by 2.\\nAnd reset the prefix and suffix.\\nTo handle odd lenght strings and non palindromic middle chunck we check if l == r or wether prefix and suffix are non empty ans increase result by one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, t: str) -> int:\\n        # if string is already a palindrome return its length, as each element will get chuncked\\n        if(t == t[::-1]):\\n            return len(t)\\n\\n        out = []    # to store the result\\n        l, r = 0,len(t)-1   # two pointers pointing to start and end of string\\n        x,y=\"\",\"\"   # two empty string to check prefix and suffix\\n\\n        while l < r:\\n            x+=t[l]        # add prefix to x until x = reverse of y\\n            y+=t[r]        # add suffix to y \\n            if(x == y[::-1]):      # check if  x = reverse of y\\n                out.append(x)      # add the chunk to result\\n                x=\"\"               # reset the strings\\n                y=\"\"\\n            l+=1\\n            r-=1\\n    \\n        res = len(out)*2    # all the chuncked elements are apearing twice, hence multiply result by 2\\n        \\n        #if the string if odd length, middle element needs to be added and if middle window ex: (adam) is not a palindrome it needs to be added\\n        if(l == r or x != \"\" and y != \"\"):\\n            return res+1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, t: str) -> int:\\n        # if string is already a palindrome return its length, as each element will get chuncked\\n        if(t == t[::-1]):\\n            return len(t)\\n\\n        out = []    # to store the result\\n        l, r = 0,len(t)-1   # two pointers pointing to start and end of string\\n        x,y=\"\",\"\"   # two empty string to check prefix and suffix\\n\\n        while l < r:\\n            x+=t[l]        # add prefix to x until x = reverse of y\\n            y+=t[r]        # add suffix to y \\n            if(x == y[::-1]):      # check if  x = reverse of y\\n                out.append(x)      # add the chunk to result\\n                x=\"\"               # reset the strings\\n                y=\"\"\\n            l+=1\\n            r-=1\\n    \\n        res = len(out)*2    # all the chuncked elements are apearing twice, hence multiply result by 2\\n        \\n        #if the string if odd length, middle element needs to be added and if middle window ex: (adam) is not a palindrome it needs to be added\\n        if(l == r or x != \"\" and y != \"\"):\\n            return res+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252333,
                "title": "using-z-function-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is best problem which can be solved using `z-function`. \\n\\n`Definition of z-function :` \\nSuppose we are given a string \\u200A$s$\\u200A of length \\u200A$n$\\u200A. The Z-function for this string is an array of length \\u200A$n$\\u200A where the \\u200A$i$\\u200A-th element is equal to the greatest number of characters starting from the position \\u200A$i$\\u200A that coincide with the first characters of \\u200A$s$\\u200A. \\n\\nHere we call Z_function and get the last best prefix. Untill last best prefix is zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int z_function(string s) {\\n        int n = s.size();\\n\\n        vector<int> z(n);\\n        for(int i = 1, l =0, r = 0; i<n; ++i) {\\n            if(i<=r)\\n                z[i] = min(r - i +1, z[i-l]);\\n            while(i+z[i] < n && s[z[i]] == s[i + z[i] ]) ++z[i];\\n\\n            if(i+ z[i] -1 > r) {\\n                l = i; r = i+z[i]-1;\\n            } \\n\\n        }\\n\\n        for(int i = n-1; i>=0; --i) {\\n            if(z[i] + i == n) return z[i];\\n        }\\n        return 0;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int start = 0, end = n-1, ans = 0;\\n        while(start <= end) {\\n            int len = z_function(text.substr(start, end-start+1));\\n\\n            start +=len;\\n            end -= len;\\n            if(len == 0) {\\n                ++ans;\\n                break;\\n            } else {\\n                ans+=2;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int z_function(string s) {\\n        int n = s.size();\\n\\n        vector<int> z(n);\\n        for(int i = 1, l =0, r = 0; i<n; ++i) {\\n            if(i<=r)\\n                z[i] = min(r - i +1, z[i-l]);\\n            while(i+z[i] < n && s[z[i]] == s[i + z[i] ]) ++z[i];\\n\\n            if(i+ z[i] -1 > r) {\\n                l = i; r = i+z[i]-1;\\n            } \\n\\n        }\\n\\n        for(int i = n-1; i>=0; --i) {\\n            if(z[i] + i == n) return z[i];\\n        }\\n        return 0;\\n    }\\n\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int start = 0, end = n-1, ans = 0;\\n        while(start <= end) {\\n            int len = z_function(text.substr(start, end-start+1));\\n\\n            start +=len;\\n            end -= len;\\n            if(len == 0) {\\n                ++ans;\\n                break;\\n            } else {\\n                ans+=2;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234939,
                "title": "o-n-2-with-constant-memory-using-c-strings",
                "content": "# Intuition\\nFrom the offset, it\\'s clear that you can break this down into subproblems. Once you find the first palindrome, then you can apply the same algorithm to the original string minus the palindrome characters to get the next palindrome, and so on. The problem then becomes \"Find the smallest palindrome on the start/end of this string\", which is the problem I tried to focus on.\\n\\n# Approach\\nI couldn\\'t think of a way better than O(n), since we need to look at least the whole string\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1) - C strings are helpful here since the STL doesn\\'t provide a substring API that returns references.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\npalindromes = 0\\ni = 0, end_start, end_last = text.size()\\nfirst = text.start\\n\\nfor (j = end_last - 1; j > i; --j)\\n    range = end_last - j\\n    check if [i, i + range] == [j, j + range] \\n    yes \\n        i = i + range\\n        end_last = j\\n\\n*/\\n    int longestDecomposition(string text) {\\n        int k = 0;\\n\\n        // left = i, right = j\\n        const char * left = text.c_str(), * end = text.c_str() + text.size(), *right;\\n        for (right = end - 1; right > left; --right) {\\n            // cout << \"i: \" << i << \" j: \" << j << endl;\\n            // cout << \"Comparing: \" << left << \" | \" << right << \", Range: \" << range << endl;\\n            if (strncmp(left, right, end - right) == 0) {\\n                // cout << \"Found a match!\" << endl;\\n                left = left + (end - right);\\n                end = right;\\n                k += 2;\\n            }\\n        }\\n        if (left != right + 1) {\\n            k += 1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\npalindromes = 0\\ni = 0, end_start, end_last = text.size()\\nfirst = text.start\\n\\nfor (j = end_last - 1; j > i; --j)\\n    range = end_last - j\\n    check if [i, i + range] == [j, j + range] \\n    yes \\n        i = i + range\\n        end_last = j\\n\\n*/\\n    int longestDecomposition(string text) {\\n        int k = 0;\\n\\n        // left = i, right = j\\n        const char * left = text.c_str(), * end = text.c_str() + text.size(), *right;\\n        for (right = end - 1; right > left; --right) {\\n            // cout << \"i: \" << i << \" j: \" << j << endl;\\n            // cout << \"Comparing: \" << left << \" | \" << right << \", Range: \" << range << endl;\\n            if (strncmp(left, right, end - right) == 0) {\\n                // cout << \"Found a match!\" << endl;\\n                left = left + (end - right);\\n                end = right;\\n                k += 2;\\n            }\\n        }\\n        if (left != right + 1) {\\n            k += 1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3211774,
                "title": "swift-0-ms",
                "content": "```\\nclass Solution {\\n    func longestDecomposition(_ text: String) -> Int {\\n        var k = 0\\n        var pos = 0\\n        let cc = Array(text)\\n        for i in 0 ..< cc.count / 2 {\\n            var isPalindrome = true\\n            for j in pos ... i {\\n                if cc[j] != cc[cc.count - 1 - pos - i + j] { \\n                    isPalindrome = false\\n                    break \\n                }\\n            }\\n            guard isPalindrome else { continue }\\n            k += 2\\n            pos = i + 1\\n        }\\n        return cc.count % 2 == 0 && pos == cc.count / 2 ? k : k + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestDecomposition(_ text: String) -> Int {\\n        var k = 0\\n        var pos = 0\\n        let cc = Array(text)\\n        for i in 0 ..< cc.count / 2 {\\n            var isPalindrome = true\\n            for j in pos ... i {\\n                if cc[j] != cc[cc.count - 1 - pos - i + j] { \\n                    isPalindrome = false\\n                    break \\n                }\\n            }\\n            guard isPalindrome else { continue }\\n            k += 2\\n            pos = i + 1\\n        }\\n        return cc.count % 2 == 0 && pos == cc.count / 2 ? k : k + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134951,
                "title": "100-beats-easy-to-understand-c-two-pointer-iit-roorkee",
                "content": "# Approach :- Two Pointer Approach\\n\\n# Complexity\\n\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) \\n    {\\n      int count=0;\\n      int i=0;\\n      int j=text.length()-1;\\n      string str1;\\n      string str2;\\n      while(i<j)\\n      {\\n          str1+=text[i];\\n          str2=text[j]+str2;\\n          if(str1==str2)\\n          {\\n              count+=2;\\n              str1.clear();\\n              str2.clear();\\n          }\\n          i++;\\n          j--;\\n      }\\n      if((i==j)||(str1.length()!=0))\\n      {\\n        count+=1;\\n      }\\n      return count;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) \\n    {\\n      int count=0;\\n      int i=0;\\n      int j=text.length()-1;\\n      string str1;\\n      string str2;\\n      while(i<j)\\n      {\\n          str1+=text[i];\\n          str2=text[j]+str2;\\n          if(str1==str2)\\n          {\\n              count+=2;\\n              str1.clear();\\n              str2.clear();\\n          }\\n          i++;\\n          j--;\\n      }\\n      if((i==j)||(str1.length()!=0))\\n      {\\n        count+=1;\\n      }\\n      return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098253,
                "title": "java-brute-force-recursion",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Brute Force\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int count=0;\\n        int r=text.length()-1;\\n        int l=0;\\n        String leftStr=\"\";\\n        String rightStr=\"\";\\n        while(l<text.length()){\\n            leftStr+=text.charAt(l);\\n            rightStr=text.charAt(r)+rightStr;\\n            if(leftStr.equals(rightStr)){\\n                count++;\\n                leftStr=\"\";\\n                rightStr=\"\";\\n            }\\n            l++;\\n            r--;\\n        }\\n        return count;\\n    }\\n}\\n```\\n# Recursion\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        //Recursion\\n        int n=text.length();\\n        for(int i=0;i<n/2;i++){\\n            if(text.substring(0,i+1).equals(text.substring(n-1-i,n))){\\n                return 2+longestDecomposition(text.substring(i+1,n-1-i));\\n            }\\n        }\\n        return n==0?0:1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int count=0;\\n        int r=text.length()-1;\\n        int l=0;\\n        String leftStr=\"\";\\n        String rightStr=\"\";\\n        while(l<text.length()){\\n            leftStr+=text.charAt(l);\\n            rightStr=text.charAt(r)+rightStr;\\n            if(leftStr.equals(rightStr)){\\n                count++;\\n                leftStr=\"\";\\n                rightStr=\"\";\\n            }\\n            l++;\\n            r--;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        //Recursion\\n        int n=text.length();\\n        for(int i=0;i<n/2;i++){\\n            if(text.substring(0,i+1).equals(text.substring(n-1-i,n))){\\n                return 2+longestDecomposition(text.substring(i+1,n-1-i));\\n            }\\n        }\\n        return n==0?0:1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079067,
                "title": "not-bad",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, arr: str) -> int:\\n        size=len(arr)\\n        arr=list(arr)\\n        x=1\\n        y=len(arr)-1\\n        count=0\\n        lol=0\\n        while y>=x:\\n            if arr[:x]==arr[y:]:\\n                lol+=len(arr[:x])\\n                lol+=len(arr[y:])\\n                for i in range(len(arr[:x])):\\n                \\n                    arr.pop(0)\\n                    arr.pop()\\n                x=1\\n                y=len(arr)-1\\n                count+=2\\n            else:\\n                x+=1\\n                y-=1\\n        if size==lol:return count\\n        return count +1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, arr: str) -> int:\\n        size=len(arr)\\n        arr=list(arr)\\n        x=1\\n        y=len(arr)-1\\n        count=0\\n        lol=0\\n        while y>=x:\\n            if arr[:x]==arr[y:]:\\n                lol+=len(arr[:x])\\n                lol+=len(arr[y:])\\n                for i in range(len(arr[:x])):\\n                \\n                    arr.pop(0)\\n                    arr.pop()\\n                x=1\\n                y=len(arr)-1\\n                count+=2\\n            else:\\n                x+=1\\n                y-=1\\n        if size==lol:return count\\n        return count +1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021007,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    \\n};\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    if(text==\\'\\')\\n        return 0;\\n    for(let i=1;i<text.length;i++){\\n        if(text.substring(0,i)==text.substring(text.length-i))\\n            return 2+longestDecomposition(text.substring(i,text.length-i));\\n    }\\n    return 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    \\n};\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar longestDecomposition = function(text) {\\n    if(text==\\'\\')\\n        return 0;\\n    for(let i=1;i<text.length;i++){\\n        if(text.substring(0,i)==text.substring(text.length-i))\\n            return 2+longestDecomposition(text.substring(i,text.length-i));\\n    }\\n    return 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018718,
                "title": "golang-dp-rolling-hash",
                "content": "```\\nfunc longestDecomposition(t string) int {\\n    mem := make([][]int, len(t))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, len(t))\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n    \\n\\tvar p uint64 = 31\\n\\tpPow := make([]uint64, len(t))\\n\\tpPow[0] = 1\\n\\tfor i := 1; i < len(pPow); i++ {\\n\\t\\tpPow[i] = pPow[i-1] * p\\n\\t}\\n\\t\\n\\th := make([]uint64, len(t))\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\th[i] = (uint64(t[i]) - \\'a\\' + 1) * pPow[i]\\n\\t\\tif i > 0 {\\n\\t\\t\\th[i] += h[i-1]\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(int, int) int\\n\\tdp = func(st int, end int) int {\\n\\t\\tif end >= len(t) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif mem[st][end] != -1 {\\n\\t\\t\\treturn mem[st][end]\\n\\t\\t}\\n\\t\\tcf := h[end]\\n\\t\\tif st > 0 {\\n\\t\\t\\tcf -= h[st-1]\\n\\t\\t}\\n\\n\\t\\txend := len(t) - 1 - st\\n\\t\\txst := xend - (end - st)\\n\\n\\t\\tcs := h[xend]\\n\\t\\tif xst > 0 {\\n\\t\\t\\tcs -= h[xst-1]\\n\\t\\t}\\n\\n\\t\\tmn := xst - st\\n\\t\\ttk := 0\\n\\t\\tif mn < 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif cf*pPow[mn] == cs {\\n\\t\\t\\ta := 2\\n\\t\\t\\tif end >= len(t)/2 {\\n\\t\\t\\t\\ta = 1\\n\\t\\t\\t}\\n\\t\\t\\ttk = a + dp(end+1, end+1)\\n\\t\\t}\\n\\t\\tntk := dp(st, end+1)\\n\\t\\tif ntk > tk {\\n\\t\\t\\tmem[st][end] = ntk\\n\\t\\t\\treturn ntk\\n\\t\\t}\\n\\t\\tmem[st][end] = tk\\n\\t\\treturn tk\\n\\t}\\n\\n\\treturn dp(0, 0)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestDecomposition(t string) int {\\n    mem := make([][]int, len(t))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, len(t))\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n    \\n\\tvar p uint64 = 31\\n\\tpPow := make([]uint64, len(t))\\n\\tpPow[0] = 1\\n\\tfor i := 1; i < len(pPow); i++ {\\n\\t\\tpPow[i] = pPow[i-1] * p\\n\\t}\\n\\t\\n\\th := make([]uint64, len(t))\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\th[i] = (uint64(t[i]) - \\'a\\' + 1) * pPow[i]\\n\\t\\tif i > 0 {\\n\\t\\t\\th[i] += h[i-1]\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(int, int) int\\n\\tdp = func(st int, end int) int {\\n\\t\\tif end >= len(t) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif mem[st][end] != -1 {\\n\\t\\t\\treturn mem[st][end]\\n\\t\\t}\\n\\t\\tcf := h[end]\\n\\t\\tif st > 0 {\\n\\t\\t\\tcf -= h[st-1]\\n\\t\\t}\\n\\n\\t\\txend := len(t) - 1 - st\\n\\t\\txst := xend - (end - st)\\n\\n\\t\\tcs := h[xend]\\n\\t\\tif xst > 0 {\\n\\t\\t\\tcs -= h[xst-1]\\n\\t\\t}\\n\\n\\t\\tmn := xst - st\\n\\t\\ttk := 0\\n\\t\\tif mn < 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif cf*pPow[mn] == cs {\\n\\t\\t\\ta := 2\\n\\t\\t\\tif end >= len(t)/2 {\\n\\t\\t\\t\\ta = 1\\n\\t\\t\\t}\\n\\t\\t\\ttk = a + dp(end+1, end+1)\\n\\t\\t}\\n\\t\\tntk := dp(st, end+1)\\n\\t\\tif ntk > tk {\\n\\t\\t\\tmem[st][end] = ntk\\n\\t\\t\\treturn ntk\\n\\t\\t}\\n\\t\\tmem[st][end] = tk\\n\\t\\treturn tk\\n\\t}\\n\\n\\treturn dp(0, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994516,
                "title": "100-faster-c-solution",
                "content": "The idea is pretty simple but the implementation is terrific.\\nHere is the idea :\\n  We know that if two strings are equal then their hash will be equal right ? Yeah\\n Compute the prefix hash for the entire string so we can get the hash for a substring in O(1)\\n\\nNow, after we have done that. we need to maximize how we split our string by comparing first and last string or first two and last two or first three and last three e.t.c. until we get the first match.\\ne.g \\ngcbagcb\\ng!=b\\ngc!=cb\\ngcb==gcb\\nwhen it becomes equal, we will do the necessary index adjustment and try again taking 1 or 2 or 3 e.tc strings at a time. \\ni.e s.substr(index, k) == s.substr(size-index-1, k) where k = 1,2,3,4...(size/2 + 1)\\nwe will repeat this until the substrings overlap\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int longestDecomposition(string s) {\\n         // ok we need to calculate the prefix hash of the string then compute \\n         // accordingly...\\n         int size = s.size(), prime = 53, mod = 1e9+9;\\n         vector<long long>hash(size),p(size);\\n         p[0]=1;\\n        \\n         for(int i =1; i < size; i++){\\n              p[i]= (p[i-1]*prime)%mod;\\n         }\\n         hash[0] = s[0]-\\'a\\'+1;\\n        \\n         for(int i = 1; i < size; i++){\\n             \\n               hash[i] = (hash[i-1]+ (s[i]-\\'a\\'+1)*p[i])%mod;\\n             \\n         }\\n        \\n         int maxi = size/2, answer = 0, index = 0;\\n         maxi++;\\n        \\n         \\n         for(int tryy = 1; tryy <= (maxi+1); tryy++){\\n              \\n              int begin1 = index, end1= index+tryy-1, begin2=size-index-tryy, end2=begin2+tryy-1;\\n             \\n              if(begin2  <= end1){\\n                   answer+=1;\\n                   break;\\n              }\\n             \\n              long long compute = (hash[end1]- ((begin1-1)>=0 ? hash[begin1-1]: 0)+mod)%mod;\\n              compute = (compute * p[size-index-1])%mod;\\n             \\n              long long compute2 = (hash[end2]-((begin2-1)>=0 ? hash[begin2-1]: 0)+mod)%mod;\\n              compute2 = (compute2* p[size-begin2-1])%mod;\\n             \\n              if(compute==compute2){\\n                  answer+=2;\\n                  index+=tryy;\\n                  tryy=0;\\n                  if(end1+1==begin2)break;\\n              }\\n             \\n         }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int longestDecomposition(string s) {\\n         // ok we need to calculate the prefix hash of the string then compute \\n         // accordingly...\\n         int size = s.size(), prime = 53, mod = 1e9+9;\\n         vector<long long>hash(size),p(size);\\n         p[0]=1;\\n        \\n         for(int i =1; i < size; i++){\\n              p[i]= (p[i-1]*prime)%mod;\\n         }\\n         hash[0] = s[0]-\\'a\\'+1;\\n        \\n         for(int i = 1; i < size; i++){\\n             \\n               hash[i] = (hash[i-1]+ (s[i]-\\'a\\'+1)*p[i])%mod;\\n             \\n         }\\n        \\n         int maxi = size/2, answer = 0, index = 0;\\n         maxi++;\\n        \\n         \\n         for(int tryy = 1; tryy <= (maxi+1); tryy++){\\n              \\n              int begin1 = index, end1= index+tryy-1, begin2=size-index-tryy, end2=begin2+tryy-1;\\n             \\n              if(begin2  <= end1){\\n                   answer+=1;\\n                   break;\\n              }\\n             \\n              long long compute = (hash[end1]- ((begin1-1)>=0 ? hash[begin1-1]: 0)+mod)%mod;\\n              compute = (compute * p[size-index-1])%mod;\\n             \\n              long long compute2 = (hash[end2]-((begin2-1)>=0 ? hash[begin2-1]: 0)+mod)%mod;\\n              compute2 = (compute2* p[size-begin2-1])%mod;\\n             \\n              if(compute==compute2){\\n                  answer+=2;\\n                  index+=tryy;\\n                  tryy=0;\\n                  if(end1+1==begin2)break;\\n              }\\n             \\n         }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941020,
                "title": "c-beats-100-time-complexity-o-n-space-complexity-o-1",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n       int i=0,cnt=0,j=text.size(),ans=0;\\n       while(i<=j){\\n            cnt++;\\n            if(text.compare(i,cnt,text,j-cnt,cnt)==0){\\n             i=i+cnt;\\n             j=j-cnt;\\n             cnt=0;\\n             if(i<j) ans+=2;\\n             else ans++;\\n            }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n       int i=0,cnt=0,j=text.size(),ans=0;\\n       while(i<=j){\\n            cnt++;\\n            if(text.compare(i,cnt,text,j-cnt,cnt)==0){\\n             i=i+cnt;\\n             j=j-cnt;\\n             cnt=0;\\n             if(i<j) ans+=2;\\n             else ans++;\\n            }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924107,
                "title": "python-dp-solution-faster-than-70-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```text[left: start]``` means the first left chunk and ```text[end: right]``` means the second right chunk. If they are equal, find the next chunks i.e. ```text[start: start + 1]``` and ```text[end - 1: end]```. If not, increase the size of both the chunks by 1. Keep storing the results of all the sub-problems.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.res, sz = 0, len(text)\\n\\n        @cache\\n        def dp(left: int, start: int, end: int, right: int) -> int:\\n            if left == start == end == right:\\n                return 1\\n            if start >= end:\\n                return 0\\n            if text[left: start + 1] == text[end: right + 1]:\\n                return dp(start + 1, start + 1, end - 1, end - 1) + 2\\n            chunk = dp(left, start + 1, end - 1, right)\\n            return chunk if chunk > 0 else 1\\n\\n        return dp(0, 0, sz - 1, sz - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```text[left: start]```\n```text[end: right]```\n```text[start: start + 1]```\n```text[end - 1: end]```\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.res, sz = 0, len(text)\\n\\n        @cache\\n        def dp(left: int, start: int, end: int, right: int) -> int:\\n            if left == start == end == right:\\n                return 1\\n            if start >= end:\\n                return 0\\n            if text[left: start + 1] == text[end: right + 1]:\\n                return dp(start + 1, start + 1, end - 1, end - 1) + 2\\n            chunk = dp(left, start + 1, end - 1, right)\\n            return chunk if chunk > 0 else 1\\n\\n        return dp(0, 0, sz - 1, sz - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919040,
                "title": "rolling-hash-with-dynamic-programming-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(n*n)\\n- Space complexity: O(n*n)\\n\\n# Code\\n```\\ntemplate<typename T>\\nclass RABIN_KARP_HASH {\\n    long long p{}, mod{};\\n    std::vector<long long> pref_hash;\\n    std::vector<int> p_pow;\\n\\npublic:\\n    RABIN_KARP_HASH (T &s, int p, int mod) {\\n        this->p = p;\\n        this->mod = mod;\\n        init(s);\\n    }\\n\\n    void init(T& s) {\\n        int n = s.size();\\n        pref_hash.resize(n);\\n        pref_hash[0] = s[0];\\n        for (int i = 1; i < n; i++) {\\n            pref_hash[i] = (pref_hash[i-1] * p + s[i]) % mod;\\n        }\\n        p_pow.resize(n);\\n        p_pow[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            p_pow[i] = (p_pow[i-1] * 1LL * p) % mod;\\n        }\\n    }\\n\\n    long long get_hash(int i, int j) {\\n        if (i == 0) return pref_hash[j];\\n        long long ans = pref_hash[j] - (pref_hash[i-1] * p_pow[j-i+1]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n};\\n\\nclass Solution {\\n\\npublic:\\n    int longestDecomposition(string& text) {\\n        RABIN_KARP_HASH<string> h1(text, 31, 1e9+7), h2(text, 67, 1e9+9);\\n        int n = text.size();\\n        int dp[n][n];\\n        memset(dp, -1, sizeof dp);\\n        function<int(int, int)> rec = [&] (int x, int y) {\\n            if (x > y) return 0;\\n            if (x == y) return 1;\\n            if (dp[x][y] != -1) return dp[x][y];\\n            int len = y-x+1;\\n            int ans = 1;\\n            for (int i = 0; i < (len>>1); i++) {\\n                if (h1.get_hash(x, x+i) == h1.get_hash(y-i, y) && h2.get_hash(x, x+i) == h2.get_hash(y-i, y)) {\\n                    ans = max(ans, rec(x+i+1, y-i-1)+2);\\n                }\\n            }\\n            return dp[x][y] = ans;\\n        };\\n        return rec(0, n-1);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntemplate<typename T>\\nclass RABIN_KARP_HASH {\\n    long long p{}, mod{};\\n    std::vector<long long> pref_hash;\\n    std::vector<int> p_pow;\\n\\npublic:\\n    RABIN_KARP_HASH (T &s, int p, int mod) {\\n        this->p = p;\\n        this->mod = mod;\\n        init(s);\\n    }\\n\\n    void init(T& s) {\\n        int n = s.size();\\n        pref_hash.resize(n);\\n        pref_hash[0] = s[0];\\n        for (int i = 1; i < n; i++) {\\n            pref_hash[i] = (pref_hash[i-1] * p + s[i]) % mod;\\n        }\\n        p_pow.resize(n);\\n        p_pow[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            p_pow[i] = (p_pow[i-1] * 1LL * p) % mod;\\n        }\\n    }\\n\\n    long long get_hash(int i, int j) {\\n        if (i == 0) return pref_hash[j];\\n        long long ans = pref_hash[j] - (pref_hash[i-1] * p_pow[j-i+1]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n};\\n\\nclass Solution {\\n\\npublic:\\n    int longestDecomposition(string& text) {\\n        RABIN_KARP_HASH<string> h1(text, 31, 1e9+7), h2(text, 67, 1e9+9);\\n        int n = text.size();\\n        int dp[n][n];\\n        memset(dp, -1, sizeof dp);\\n        function<int(int, int)> rec = [&] (int x, int y) {\\n            if (x > y) return 0;\\n            if (x == y) return 1;\\n            if (dp[x][y] != -1) return dp[x][y];\\n            int len = y-x+1;\\n            int ans = 1;\\n            for (int i = 0; i < (len>>1); i++) {\\n                if (h1.get_hash(x, x+i) == h1.get_hash(y-i, y) && h2.get_hash(x, x+i) == h2.get_hash(y-i, y)) {\\n                    ans = max(ans, rec(x+i+1, y-i-1)+2);\\n                }\\n            }\\n            return dp[x][y] = ans;\\n        };\\n        return rec(0, n-1);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914191,
                "title": "c-simple-approach-to-solve-this-question",
                "content": "# Intuition\\nbasically it is  a simple question on recusion and the main idea behind is to reduce the time complexity that we will do using dp.\\n\\n# Approach\\nIn the  Approach question is the we are just checking the substring from the first that are matching with substring from the last by increasing for first and last postioner if they matches a string \\nand i am try to memsorisation to reduce the time complexity.\\n\\n# Complexity\\n- Time complexity:  O(N*N); N  is the size of string;\\n  \\n- Space complexity:\\n O(N)->for N size of String +O(N)-->for running the recusion;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int dp[1005][1005];\\n  int fun(int i,int j,int a,int b,string &s){\\n      if(i>=s.size() || j<0){\\n          return 0;\\n      }\\n      if(dp[i][j]!=-1){\\n          return dp[i][j];\\n      }\\n      int ans=0;\\n     if(s.substr(a,i-a+1)==s.substr(j,b-j+1)){\\n        ans=max(ans,fun(i+1,j-1,i+1,j-1,s)+1);\\n     }\\n    ans=max(ans,fun(i+1,j-1,a,b,s));\\n    return dp[i][j]=ans;\\n  }\\n    int longestDecomposition(string text) {\\n      \\n      memset(dp,-1,sizeof(dp));\\n     return fun(0,text.size()-1,0,text.size()-1,text);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int dp[1005][1005];\\n  int fun(int i,int j,int a,int b,string &s){\\n      if(i>=s.size() || j<0){\\n          return 0;\\n      }\\n      if(dp[i][j]!=-1){\\n          return dp[i][j];\\n      }\\n      int ans=0;\\n     if(s.substr(a,i-a+1)==s.substr(j,b-j+1)){\\n        ans=max(ans,fun(i+1,j-1,i+1,j-1,s)+1);\\n     }\\n    ans=max(ans,fun(i+1,j-1,a,b,s));\\n    return dp[i][j]=ans;\\n  }\\n    int longestDecomposition(string text) {\\n      \\n      memset(dp,-1,sizeof(dp));\\n     return fun(0,text.size()-1,0,text.size()-1,text);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913555,
                "title": "top-down-4d-dp-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find maximum chunk length, decomposed string\\n\\nthis question tricky because of edge cases\\n- how to count last middle chunk which can\\'t be palindrome\\n- Last single letter chunk \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n(left, i ) means that first left chunk\\n(j, right) means that second right chunk\\n\\n### Compare if two chunks are same \\n- if same, decompose chunk , find next two chunk (i+1, i+1), (j-1,j-1)\\n- if not, extend chunk length (left, i+1) , (j-1, right)\\n- if can\\'t decompose (i>=j) -> end loof (return 0)\\n\\n### edge cases\\n- if decompose all letters, return chunk count \\n- if there is any left chunk, count + 1 \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.res = 1\\n        m = len(text)\\n\\n        @cache\\n        def dp(left, i, j, right):\\n            \\n            if left == i == j == right:\\n                return 1\\n\\n            if i>= j:\\n                return 0\\n\\n\\n            if text[left:i+1] == text[j:right+1]:\\n                decomposition = dp(i+1, i+1, j-1, j-1) + 2\\n                return decomposition\\n            \\n            chunk = dp(left, i+1, j-1, right)\\n            if chunk ==0:\\n                return 1\\n\\n            return chunk\\n        \\n        return dp(0,0, m-1,m-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        self.res = 1\\n        m = len(text)\\n\\n        @cache\\n        def dp(left, i, j, right):\\n            \\n            if left == i == j == right:\\n                return 1\\n\\n            if i>= j:\\n                return 0\\n\\n\\n            if text[left:i+1] == text[j:right+1]:\\n                decomposition = dp(i+1, i+1, j-1, j-1) + 2\\n                return decomposition\\n            \\n            chunk = dp(left, i+1, j-1, right)\\n            if chunk ==0:\\n                return 1\\n\\n            return chunk\\n        \\n        return dp(0,0, m-1,m-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913490,
                "title": "faster-than-100-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake strings till you get same string in end and start then update answer and i and j\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/18b37ec3-cab0-406c-be0d-be6703c6dffc_1671085175.2209547.png)\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int ans = 0;\\n        int i = 0, j = text.length()-1;\\n        while(i <= j){\\n            string ti = \"\";\\n            ti = text[i];\\n            string tj = \"\";\\n            tj = text[j];\\n            // we have to increase i till we get jth char\\n            while(ti != tj && i < j){\\n                i++;\\n                j--;\\n                ti = ti + text[i];\\n                tj = text[j] + tj;\\n            }\\n            if(i >= j){ ans++; break;}\\n            // we got same\\n            // now update j and i\\n            // and ans\\n            i++;\\n            j--;\\n            ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int ans = 0;\\n        int i = 0, j = text.length()-1;\\n        while(i <= j){\\n            string ti = \"\";\\n            ti = text[i];\\n            string tj = \"\";\\n            tj = text[j];\\n            // we have to increase i till we get jth char\\n            while(ti != tj && i < j){\\n                i++;\\n                j--;\\n                ti = ti + text[i];\\n                tj = text[j] + tj;\\n            }\\n            if(i >= j){ ans++; break;}\\n            // we got same\\n            // now update j and i\\n            // and ans\\n            i++;\\n            j--;\\n            ans += 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913134,
                "title": "python-two-pointers-recursion-beats-92-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use two pointers combined with recursion to solve the problem. We start with left($l$) and right($r$) pointers at $0$ and $len(text) - 1$ respectively and compare the strings formed by the first $l$ characters and the last $r$ characters. As soon as we find a match, we remove the matched strings and solve the sub-problem on the remainder of $text$. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNotice that splitting into smaller chunks is favorable over splitting into larger chunks if both options are available.\\neg: in the string $text$ = \"antaprezatepzapreanta\" , we could choose the first 2 characters to match the last two characters (\"an\" = \"an\") or the first four characters to match the last four characters (\"anta\" = \"anta\"). In this case, it is favorible to choose the chunk of two characters. This allows us to stop at the very first match we find.\\n\\nThe algorithm is as follows: \\n1. Initialize $l=0$ and $r = len(text) - 1$\\n2. Until you find a match or $l$ becomes greater than $r$, move each pointer closer to the center\\n3. If match is found, solve the subproblem obtained by removing the matching chunks from $text$. Since we get two additional chunks as compared to the sub-problem, return 2 + (sub-problem solution) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nString comparison: $O(n)$ in the worst case, as we could potentially end up comparing the first $n/2$ and last $n/2$ characters\\n\\nThere are a total of ~ $n/2$ comparisons since either $l$ or $r$ goes over each character exactly once.\\n\\nHence, time complexity is $O(n^2)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$ since substrings are allocated additional memory in Python.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        if text == \"\": \\n            return 0\\n        if len(text) == 1:\\n            return 1 \\n        l, r = 0, len(text) - 1\\n\\n        # print(\\'Text: \\', text)\\n        found = False\\n\\n        while l < r: \\n            print(\\'testing:\\', text[:l+1], text[r:])\\n            if text[:l+1] == text[r:]: \\n                found = True\\n                # print(\\'Match:\\', l, r)\\n                break\\n            l += 1\\n            r -= 1\\n        \\n        if not found: \\n            return 1\\n        \\n        return 2*found + self.longestDecomposition(text[l+1:r])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        if text == \"\": \\n            return 0\\n        if len(text) == 1:\\n            return 1 \\n        l, r = 0, len(text) - 1\\n\\n        # print(\\'Text: \\', text)\\n        found = False\\n\\n        while l < r: \\n            print(\\'testing:\\', text[:l+1], text[r:])\\n            if text[:l+1] == text[r:]: \\n                found = True\\n                # print(\\'Match:\\', l, r)\\n                break\\n            l += 1\\n            r -= 1\\n        \\n        if not found: \\n            return 1\\n        \\n        return 2*found + self.longestDecomposition(text[l+1:r])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912862,
                "title": "python-simple-rolling-hash",
                "content": "# Approach\\nIterate the string from both ends simultaneously and update hash function of both substrings. Whenever the hashes are equal, increment answer by 2 and reset hashes to 0. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nmod = int(1e18)+7\\nB = 31\\n\\nclass Solution(object):\\n    def longestDecomposition(self, s):\\n        hL, hR = 0, 0\\n        kL = 1\\n        n = len(s)\\n        ans = 0\\n        for i in range(n):\\n            hL = (hL + ord(s[i])*kL)%mod\\n            kL = (kL*B)%mod\\n\\n            hR = (hR*B)%mod\\n            hR = (hR + ord(s[n-1-i]))%mod \\n            if hL==hR:\\n                ans+=2\\n                hL, hR = 0, 0\\n                kL = 1\\n        \\n        return ans//2\\n```",
                "solutionTags": [
                    "Python",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nmod = int(1e18)+7\\nB = 31\\n\\nclass Solution(object):\\n    def longestDecomposition(self, s):\\n        hL, hR = 0, 0\\n        kL = 1\\n        n = len(s)\\n        ans = 0\\n        for i in range(n):\\n            hL = (hL + ord(s[i])*kL)%mod\\n            kL = (kL*B)%mod\\n\\n            hR = (hR*B)%mod\\n            hR = (hR + ord(s[n-1-i]))%mod \\n            if hL==hR:\\n                ans+=2\\n                hL, hR = 0, 0\\n                kL = 1\\n        \\n        return ans//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910364,
                "title": "python-two-pointer-and-recursion-solution-with-explanation",
                "content": "### two-pointer\\n```\\n\\'\\'\\'\\nif we find two subtexts are the same,  pre_l, pre_r are on the head of subtexts,  l, r are on the tail of subtexts\\nwalk through text from head and tail to find subtexts,\\nstr_l  and str_r is to store subtexts, if they are the same, cnt += 2, initialize str_l  and str_r, and update the pointer\\nIn the end, l and r are on the same position, but pre_l, pre maybe not\\nif pre_l == pre_r, there is one letter left, cnt +=1\\nif pre_l < pre_r, there is one subtext left, cnt +=1\\n\\ne.g., abcdfdabc\\npre_l, l, pre_r, r, cnt, explanation\\n 0, 2, 8, 6, 2 (abc)dfd(abd)\\n 3, 3, 5, 5, 4 (d)f(d)\\n 4, 4, 4, 4, 4 l == r, end\\n pre_l == pre_r -> cnt = 5\\n tc is O(len(text)) * O(len(subtext)) because of string concatenation, sc is O(len(subtext))\\n\\'\\'\\'\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        pre_l, pre_r, l, r = 0, n-1, 0, n-1\\n        str_l, str_r = \"\", \"\"\\n        cnt = 0\\n        while l < r:\\n            str_l += text[l]\\n            str_r = text[r] + str_r\\n            if str_l == str_r:\\n                pre_l, pre_r = l+1, r-1\\n                cnt += 2\\n                str_l, str_r = \"\", \"\"\\n            l += 1\\n            r -= 1\\n        if pre_l <= pre_r:\\n            cnt += 1\\n        return cnt\\n```\\n\\n### recursion\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        if not text: return 0\\n        n = len(text)\\n        for i in range(n//2):\\n            if text[:i+1] == text[n-i-1:]:\\n                return 2 + self.longestDecomposition(text[i+1:n-i-1])\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\n\\'\\'\\'\\nif we find two subtexts are the same,  pre_l, pre_r are on the head of subtexts,  l, r are on the tail of subtexts\\nwalk through text from head and tail to find subtexts,\\nstr_l  and str_r is to store subtexts, if they are the same, cnt += 2, initialize str_l  and str_r, and update the pointer\\nIn the end, l and r are on the same position, but pre_l, pre maybe not\\nif pre_l == pre_r, there is one letter left, cnt +=1\\nif pre_l < pre_r, there is one subtext left, cnt +=1\\n\\ne.g., abcdfdabc\\npre_l, l, pre_r, r, cnt, explanation\\n 0, 2, 8, 6, 2 (abc)dfd(abd)\\n 3, 3, 5, 5, 4 (d)f(d)\\n 4, 4, 4, 4, 4 l == r, end\\n pre_l == pre_r -> cnt = 5\\n tc is O(len(text)) * O(len(subtext)) because of string concatenation, sc is O(len(subtext))\\n\\'\\'\\'\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n = len(text)\\n        pre_l, pre_r, l, r = 0, n-1, 0, n-1\\n        str_l, str_r = \"\", \"\"\\n        cnt = 0\\n        while l < r:\\n            str_l += text[l]\\n            str_r = text[r] + str_r\\n            if str_l == str_r:\\n                pre_l, pre_r = l+1, r-1\\n                cnt += 2\\n                str_l, str_r = \"\", \"\"\\n            l += 1\\n            r -= 1\\n        if pre_l <= pre_r:\\n            cnt += 1\\n        return cnt\\n```\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        if not text: return 0\\n        n = len(text)\\n        for i in range(n//2):\\n            if text[:i+1] == text[n-i-1:]:\\n                return 2 + self.longestDecomposition(text[i+1:n-i-1])\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855834,
                "title": "java-kmp-using-next-array",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int longestDecomposition(String s) {\\n        while (true) {\\n            s = skip(s);\\n            if (s.isEmpty()) {\\n                break;\\n            }\\n            int t = maxSP(s);\\n            if (t == 0) {\\n                break;\\n            }\\n            s = s.substring(t, s.length() - t);\\n            ans += 2;\\n        }\\n        return s.isEmpty() ? ans : ans + 1;\\n    }\\n    \\n    String skip(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n        while (l < r && s.charAt(l) == s.charAt(r)) {\\n            ans += 2;\\n            l++;\\n            r--;\\n        }\\n        return s.substring(l, r + 1);\\n    }\\n    \\n    int maxSP(String s) {\\n        int[] next = new int[s.length()];\\n        int j = -1;\\n        next[0] = j;\\n        for (int i = 1; i < s.length(); i++) {\\n            while (j >= 0 && s.charAt(i) != s.charAt(j + 1)) {\\n                j = next[j];\\n            }\\n            if (s.charAt(i) == s.charAt(j + 1)) {\\n                j++;\\n            }\\n            next[i] = j;\\n        }\\n        return next[s.length() - 1] + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int longestDecomposition(String s) {\\n        while (true) {\\n            s = skip(s);\\n            if (s.isEmpty()) {\\n                break;\\n            }\\n            int t = maxSP(s);\\n            if (t == 0) {\\n                break;\\n            }\\n            s = s.substring(t, s.length() - t);\\n            ans += 2;\\n        }\\n        return s.isEmpty() ? ans : ans + 1;\\n    }\\n    \\n    String skip(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n        while (l < r && s.charAt(l) == s.charAt(r)) {\\n            ans += 2;\\n            l++;\\n            r--;\\n        }\\n        return s.substring(l, r + 1);\\n    }\\n    \\n    int maxSP(String s) {\\n        int[] next = new int[s.length()];\\n        int j = -1;\\n        next[0] = j;\\n        for (int i = 1; i < s.length(); i++) {\\n            while (j >= 0 && s.charAt(i) != s.charAt(j + 1)) {\\n                j = next[j];\\n            }\\n            if (s.charAt(i) == s.charAt(j + 1)) {\\n                j++;\\n            }\\n            next[i] = j;\\n        }\\n        return next[s.length() - 1] + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829348,
                "title": "java-greedy-recursive-approach",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        return solve(0, n-1, text);\\n    }\\n    \\n    int solve(int start, int end, String s) {\\n        if(start > end)\\n            return 0;\\n        \\n        for(int i = start; i < end; i++) {\\n            if(s.charAt(i) == s.charAt(end) && i < end  + start - i && s.substring(start, i + 1).equals(s.substring(end + start - i, end + 1))) {\\n                return 2 + solve(i+1, end + start - i - 1, s);\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        return solve(0, n-1, text);\\n    }\\n    \\n    int solve(int start, int end, String s) {\\n        if(start > end)\\n            return 0;\\n        \\n        for(int i = start; i < end; i++) {\\n            if(s.charAt(i) == s.charAt(end) && i < end  + start - i && s.substring(start, i + 1).equals(s.substring(end + start - i, end + 1))) {\\n                return 2 + solve(i+1, end + start - i - 1, s);\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811418,
                "title": "fastest-and-also-rather-straight-forward-rust-solution-by-matching-substrings-o-n",
                "content": "# Intuition\\ngo through the list from back and front simultanously and check whether a token (substring) matches\\n\\n# Approach\\nThe simplest approach would look like this\\n```\\nimpl Solution {\\n    pub fn longest_decomposition(text: String) -> i32 {\\n        let mut tokencount = 0;\\n        let mut prevtokenend = 0;\\n        let tl = text.len();\\n        let maxi = (tl)/2+1;\\n        for i in 1..maxi{\\n            if (i<=prevtokenend){continue;} //length of token would be 0, skip\\n            if text[prevtokenend..i] == text[(tl-i)..(tl-prevtokenend)]{\\n                //the token matched, count it and set start for next token to current end\\n                tokencount +=1;\\n                prevtokenend = i;\\n            }\\n        }\\n        tokencount\\n    }\\n}\\n```\\nbut with this approach we would check every token twice, we can shortcut this by only going through half the string and checking for edge cases with the middle token\\n\\n# Complexity\\n- Time complexity: $O(n)$; or $O(n*l)$ when we assume substring equality check takes $O(l)$, $l$ would be the longest token length\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn longest_decomposition(text: String) -> i32 {\\n        let mut singlecentre = true;\\n        let mut tokencount = 0;\\n        let mut prevtokenend = 0;\\n        let tl = text.len();\\n        let maxi = (tl)/2+1;\\n        for i in 1..maxi{\\n            if (i<=prevtokenend){continue;}\\n            if text[prevtokenend..i] == text[(tl-i)..(tl-prevtokenend)]{\\n                tokencount +=1;\\n                if i >= maxi-1 && tl % 2 !=1{\\n                    singlecentre = false;\\n                    if prevtokenend>i-1 {\\n                        tokencount -=1;\\n                    }\\n                }\\n                prevtokenend = i;\\n            }\\n        }\\n        tokencount *2 + if singlecentre {1} else {0}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_decomposition(text: String) -> i32 {\\n        let mut tokencount = 0;\\n        let mut prevtokenend = 0;\\n        let tl = text.len();\\n        let maxi = (tl)/2+1;\\n        for i in 1..maxi{\\n            if (i<=prevtokenend){continue;} //length of token would be 0, skip\\n            if text[prevtokenend..i] == text[(tl-i)..(tl-prevtokenend)]{\\n                //the token matched, count it and set start for next token to current end\\n                tokencount +=1;\\n                prevtokenend = i;\\n            }\\n        }\\n        tokencount\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn longest_decomposition(text: String) -> i32 {\\n        let mut singlecentre = true;\\n        let mut tokencount = 0;\\n        let mut prevtokenend = 0;\\n        let tl = text.len();\\n        let maxi = (tl)/2+1;\\n        for i in 1..maxi{\\n            if (i<=prevtokenend){continue;}\\n            if text[prevtokenend..i] == text[(tl-i)..(tl-prevtokenend)]{\\n                tokencount +=1;\\n                if i >= maxi-1 && tl % 2 !=1{\\n                    singlecentre = false;\\n                    if prevtokenend>i-1 {\\n                        tokencount -=1;\\n                    }\\n                }\\n                prevtokenend = i;\\n            }\\n        }\\n        tokencount *2 + if singlecentre {1} else {0}\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2773968,
                "title": "python3-simple-fast-am-i-missing-something",
                "content": "Usually find the \"hard\" problems much harder, maybe I\\'m missing something, maybe I lucked out?\\n\\n```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        \\n        count = 0\\n        \\n        curr = \"\" \\n        \\n        while len(curr) < len(text) / 2 and len(text) > 1:\\n            \\n            curr = curr + text[len(curr)]\\n       \\n            if text.endswith(curr):\\n                count += 2\\n                text = text[len(curr):-len(curr)]\\n                curr = \"\"\\n                \\n        if len(text) > 0:\\n            count += 1\\n        \\n        return count\\n   ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        \\n        count = 0\\n        \\n        curr = \"\" \\n        \\n        while len(curr) < len(text) / 2 and len(text) > 1:\\n            \\n            curr = curr + text[len(curr)]\\n       \\n            if text.endswith(curr):\\n                count += 2\\n                text = text[len(curr):-len(curr)]\\n                curr = \"\"\\n                \\n        if len(text) > 0:\\n            count += 1\\n        \\n        return count\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2746035,
                "title": "java-o-n-time-o-1-memory-rolling-hash-simple",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int hl = 0, hr = 0, exp = 1, ans = 0;\\n        int i = 0, j = text.length() - 1, p = 0;\\n        for (; j > i; ++i, --j) {\\n            hl = 31 * hl + (text.charAt(i) - \\'a\\');\\n            hr += exp * (text.charAt(j) - \\'a\\');\\n            if (hl == hr) {\\n                // check for conflicts\\n                int x = p;\\n                for (int y = j; x <= i && text.charAt(x) == text.charAt(y); ++x, ++y) {\\n                }\\n                if (x > i) {\\n                    exp = 1;\\n                    hl = hr = 0;\\n                    p = x;\\n                    ans += 2;\\n                    continue;\\n                }\\n            }\\n            exp *= 31;\\n        }\\n        return (p < i || i == j) ? ans + 1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int hl = 0, hr = 0, exp = 1, ans = 0;\\n        int i = 0, j = text.length() - 1, p = 0;\\n        for (; j > i; ++i, --j) {\\n            hl = 31 * hl + (text.charAt(i) - \\'a\\');\\n            hr += exp * (text.charAt(j) - \\'a\\');\\n            if (hl == hr) {\\n                // check for conflicts\\n                int x = p;\\n                for (int y = j; x <= i && text.charAt(x) == text.charAt(y); ++x, ++y) {\\n                }\\n                if (x > i) {\\n                    exp = 1;\\n                    hl = hr = 0;\\n                    p = x;\\n                    ans += 2;\\n                    continue;\\n                }\\n            }\\n            exp *= 31;\\n        }\\n        return (p < i || i == j) ? ans + 1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697185,
                "title": "java-greedy",
                "content": "```\\npublic class LongestChunkedPalindromeDecomposition1147 {\\n    public static void main(String[] args) {\\n        System.out.println(longestDecomposition(\"antaprezatepzapreanta\"));\\n    }\\n    public static int longestDecomposition(String text) {\\n\\n        int start = 0;\\n        int end = text.length() -1 ;\\n\\n        String startTemp = \"\";\\n        String endTemp = \"\";\\n\\n        int sameCount = 0;\\n        while( end != -1){\\n            startTemp += text.charAt(start++);\\n            endTemp = text.charAt(end--) + endTemp;\\n\\n            if(startTemp.equals(endTemp)){\\n                sameCount++;\\n                startTemp = \"\";\\n                endTemp = \"\";\\n            }\\n\\n        }\\n\\n        if(sameCount == 0){\\n            return 1;\\n        }\\n        return sameCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic class LongestChunkedPalindromeDecomposition1147 {\\n    public static void main(String[] args) {\\n        System.out.println(longestDecomposition(\"antaprezatepzapreanta\"));\\n    }\\n    public static int longestDecomposition(String text) {\\n\\n        int start = 0;\\n        int end = text.length() -1 ;\\n\\n        String startTemp = \"\";\\n        String endTemp = \"\";\\n\\n        int sameCount = 0;\\n        while( end != -1){\\n            startTemp += text.charAt(start++);\\n            endTemp = text.charAt(end--) + endTemp;\\n\\n            if(startTemp.equals(endTemp)){\\n                sameCount++;\\n                startTemp = \"\";\\n                endTemp = \"\";\\n            }\\n\\n        }\\n\\n        if(sameCount == 0){\\n            return 1;\\n        }\\n        return sameCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695526,
                "title": "c-memoization",
                "content": "**Here I used the string_view(c++ 17 >=) instead of simple string to get string comparison in O(1)**\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(string_view & s,int i,int j)\\n    {\\n        if(i == j) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int res = 1;\\n        for(int k = 1;k<=s.length()/2;k++)\\n        {\\n            if(s.substr(0,k) == s.substr(s.length()-k))\\n            {\\n                string_view t = s.substr(k,s.length()-2*k);\\n                if(t.length() ==  0)\\n                {\\n                    res = max(res,solve(t,i,j-k)+1);\\n                }else\\n                {\\n                    res = max(res,solve(t,i,j-k)+2);\\n                }\\n            }\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int longestDecomposition(string text) {\\n        memset(dp,-1,sizeof(dp));\\n        string_view ss = string_view(text);\\n        return solve(ss,0,text.length()-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(string_view & s,int i,int j)\\n    {\\n        if(i == j) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int res = 1;\\n        for(int k = 1;k<=s.length()/2;k++)\\n        {\\n            if(s.substr(0,k) == s.substr(s.length()-k))\\n            {\\n                string_view t = s.substr(k,s.length()-2*k);\\n                if(t.length() ==  0)\\n                {\\n                    res = max(res,solve(t,i,j-k)+1);\\n                }else\\n                {\\n                    res = max(res,solve(t,i,j-k)+2);\\n                }\\n            }\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int longestDecomposition(string text) {\\n        memset(dp,-1,sizeof(dp));\\n        string_view ss = string_view(text);\\n        return solve(ss,0,text.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617431,
                "title": "simplified-two-pointers-all-edge-cases-handled-neat-and-clean-code",
                "content": "Very sure, Two Pointers will be used in this problem.\\n\\nBut `How can we optimize it so that it covers all edge cases ?` \\n\\nIn most solutions, we are running ith pointer till half of the array and incrementing the result twice everytime.\\n\\nBut now, ith pointer will loop from start to end and res will be increased by one only.\\n\\nBecause every state of division will be witnessed twice as we are looping till the end.\\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n=text.length();\\n        \\n        String l=\"\";\\n        String r=\"\";\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            l+=text.charAt(i);\\n            r=text.charAt(n-i-1)+r;\\n            \\n            if(l.equals(r)){\\n                l=\"\";\\n                r=\"\";\\n                ans++;\\n            }\\n           \\n            \\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n   \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n=text.length();\\n        \\n        String l=\"\";\\n        String r=\"\";\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            l+=text.charAt(i);\\n            r=text.charAt(n-i-1)+r;\\n            \\n            if(l.equals(r)){\\n                l=\"\";\\n                r=\"\";\\n                ans++;\\n            }\\n           \\n            \\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611727,
                "title": "c-100-2-pointer-approach-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int start = 0, end = text.length()-1;\\n        int count = 0, endL = end+1;\\n        while (start < end) {\\n            if (text[end] == text[start]) {\\n                int i = start, j = end;\\n                while (j < endL && (text[i] == text[j])) {\\n                    i++; j++;\\n                }\\n                if (std::abs(start - i)==std::abs(end-endL)) {\\n                    endL = end;\\n                    end--;\\n                    start = i;\\n                    count+=2;\\n                } else {\\n                    end--;\\n                }\\n            } else {\\n                end--;\\n            }\\n        }\\n        if (start == end) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int start = 0, end = text.length()-1;\\n        int count = 0, endL = end+1;\\n        while (start < end) {\\n            if (text[end] == text[start]) {\\n                int i = start, j = end;\\n                while (j < endL && (text[i] == text[j])) {\\n                    i++; j++;\\n                }\\n                if (std::abs(start - i)==std::abs(end-endL)) {\\n                    endL = end;\\n                    end--;\\n                    start = i;\\n                    count+=2;\\n                } else {\\n                    end--;\\n                }\\n            } else {\\n                end--;\\n            }\\n        }\\n        if (start == end) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567646,
                "title": "python3-recursive-dp",
                "content": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n=len(text)-1\\n        dp=[[-1 for i in range(n+1)] for j in range(n+1)]\\n        def dfs(start,end):\\n            if start>end:\\n                return 0\\n            if dp[start][end]!=-1:\\n                return dp[start][end]\\n            best=1\\n            l,r=start,end\\n            mid=(r+l)//2\\n            while r>mid:\\n                chunk=end-r+1\\n                if text[l:l+chunk]==text[r:end+1]:\\n                    val=dfs(l+chunk,r-1)+2\\n                    best=max(best,val)\\n                r-=1\\n            dp[start][end]=best\\n            return dp[start][end]\\n        return dfs(0,n)\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestDecomposition(self, text: str) -> int:\\n        n=len(text)-1\\n        dp=[[-1 for i in range(n+1)] for j in range(n+1)]\\n        def dfs(start,end):\\n            if start>end:\\n                return 0\\n            if dp[start][end]!=-1:\\n                return dp[start][end]\\n            best=1\\n            l,r=start,end\\n            mid=(r+l)//2\\n            while r>mid:\\n                chunk=end-r+1\\n                if text[l:l+chunk]==text[r:end+1]:\\n                    val=dfs(l+chunk,r-1)+2\\n                    best=max(best,val)\\n                r-=1\\n            dp[start][end]=best\\n            return dp[start][end]\\n        return dfs(0,n)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557831,
                "title": "faster-than-99-38-of-java-solution-o-n-complexity",
                "content": "public int longestDecomposition(String text) {\\n        int start = 0;\\n        int end = text.length()-1;\\n        int count=0;\\n        int leng = 0;\\n        while(start <= end){\\n            if(start==end){\\n                count++;\\n                break;\\n            }\\n            if(text.charAt(start)==text.charAt(end) && text.substring(start,start+leng+1).equals(text.substring(end,end+leng+1))) {\\n                count += 2;\\n                start = start + leng + 1;\\n                leng = 0;\\n                end = end - 1;\\n            }\\n            else{\\n                end--;\\n                leng++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "public int longestDecomposition(String text) {\\n        int start = 0;\\n        int end = text.length()-1;\\n        int count=0;\\n        int leng = 0;\\n        while(start <= end){\\n            if(start==end){\\n                count++;\\n                break;\\n            }\\n            if(text.charAt(start)==text.charAt(end) && text.substring(start,start+leng+1).equals(text.substring(end,end+leng+1))) {\\n                count += 2;\\n                start = start + leng + 1;\\n                leng = 0;\\n                end = end - 1;\\n            }\\n            else{\\n                end--;\\n                leng++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2546083,
                "title": "c-kmp-dp",
                "content": "```\\nconst int                   N   = 10 + 1e3;\\n\\nint     n;\\nint     Next[N];\\nint     f[N][N];\\n\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        n = s.size();\\n        s = \"#\" + s;\\n        \\n        memset(f, 0, sizeof(f));\\n\\n        int k = 0;\\n        for (int l = n; l >= 1; l--) {          Next[l] = k = l-1;      f[l][l] = 1;\\n            for (int r = l+1; r <= n; r++) {                            f[l][r] = 1;\\n                while (k>=l && s[k+1] != s[r]) k = Next[k];\\n                if (s[k+1] == s[r]) k++;\\n                Next[r] = k;\\n                \\n                for (int i = k; i >= l; i = Next[i]) if ((i-l+1)*2 <= (r-l+1)){\\n                    f[l][r] = max(f[l][r], f[i+1][r-(i-l+1)] + 2);\\n                }\\n            }\\n        }\\n        return f[1][n];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst int                   N   = 10 + 1e3;\\n\\nint     n;\\nint     Next[N];\\nint     f[N][N];\\n\\n\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s) {\\n        n = s.size();\\n        s = \"#\" + s;\\n        \\n        memset(f, 0, sizeof(f));\\n\\n        int k = 0;\\n        for (int l = n; l >= 1; l--) {          Next[l] = k = l-1;      f[l][l] = 1;\\n            for (int r = l+1; r <= n; r++) {                            f[l][r] = 1;\\n                while (k>=l && s[k+1] != s[r]) k = Next[k];\\n                if (s[k+1] == s[r]) k++;\\n                Next[r] = k;\\n                \\n                for (int i = k; i >= l; i = Next[i]) if ((i-l+1)*2 <= (r-l+1)){\\n                    f[l][r] = max(f[l][r], f[i+1][r-(i-l+1)] + 2);\\n                }\\n            }\\n        }\\n        return f[1][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541214,
                "title": "two-pointers-approach-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int s=0,e=text.size()-1;\\n        int first_found=0,last_found=text.size()-1;\\n        int cnt=0;\\n        while(s<e){\\n            string a=text.substr(first_found,s-first_found+1);\\n            string b=text.substr(e,last_found-e+1);\\n            s++;\\n            e--;\\n            if(a==b){\\n                cnt+=2;\\n                first_found=s;\\n                last_found=e;\\n            }   \\n        }\\n        if(first_found<=last_found){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int s=0,e=text.size()-1;\\n        int first_found=0,last_found=text.size()-1;\\n        int cnt=0;\\n        while(s<e){\\n            string a=text.substr(first_found,s-first_found+1);\\n            string b=text.substr(e,last_found-e+1);\\n            s++;\\n            e--;\\n            if(a==b){\\n                cnt+=2;\\n                first_found=s;\\n                last_found=e;\\n            }   \\n        }\\n        if(first_found<=last_found){\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539927,
                "title": "javascript-100-fast-easy",
                "content": "```\\nvar longestDecomposition = function(text) {\\n    let counter = 0\\n    let len = text.length\\n\\n    for (let i = 1; i <= len / 2; i++) {\\n        const start = text.substr(0, i)\\n        const end = text.substr(len - i, i)\\n        if (start == end) {\\n            // Cut palindromes from text, increase counter, loop again\\n            text = text.substr(0, len - i).substr(i)\\n            len = text.length\\n            i = 0\\n            counter += 2\\n        }\\n    }\\n\\n    return counter + (text.length ? 1 : 0)\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/1fbaeec9-f8b9-4a43-b5e3-5a2ad890fcb6_1662467617.2266948.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar longestDecomposition = function(text) {\\n    let counter = 0\\n    let len = text.length\\n\\n    for (let i = 1; i <= len / 2; i++) {\\n        const start = text.substr(0, i)\\n        const end = text.substr(len - i, i)\\n        if (start == end) {\\n            // Cut palindromes from text, increase counter, loop again\\n            text = text.substr(0, len - i).substr(i)\\n            len = text.length\\n            i = 0\\n            counter += 2\\n        }\\n    }\\n\\n    return counter + (text.length ? 1 : 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539337,
                "title": "golang-two-pointer",
                "content": "Simple two pointer solution. \\n\\nRuntime: 4 ms, faster than 75.00% of Go online submissions for Longest Chunked Palindrome Decomposition.\\nMemory Usage: 2 MB, less than 75.00% of Go online submissions for Longest Chunked Palindrome Decomposition.\\n\\n```\\nfunc longestDecomposition(text string) int {\\n\\t// used for right pointer\\n\\tn := len(text)-1\\n\\t// last is used to keep track of the last word\\'s index that we find\\n    last, ans := 0, 0\\n    for i := range text {\\n\\t    // check if the first word matches the second word\\n\\t\\t// we make use of the `last` pointer here to search for the next matching words\\n        if text[last:i+1] == text[n-i:n-last+1] {\\n\\t\\t\\t// update answer and move last pointer\\n            ans++\\n            last = i+1\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestDecomposition(text string) int {\\n\\t// used for right pointer\\n\\tn := len(text)-1\\n\\t// last is used to keep track of the last word\\'s index that we find\\n    last, ans := 0, 0\\n    for i := range text {\\n\\t    // check if the first word matches the second word\\n\\t\\t// we make use of the `last` pointer here to search for the next matching words\\n        if text[last:i+1] == text[n-i:n-last+1] {\\n\\t\\t\\t// update answer and move last pointer\\n            ans++\\n            last = i+1\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537039,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string s)\\n    {\\n        int n=s.size(),i=0,res=0;\\n        string l=\"\",r=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            l=l+s[i];\\n            r=s[n-1-i]+r;\\n            if(l==r)\\n            {\\n                res++;\\n                l=\"\";\\n                r=\"\";\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int longestDecomposition(string s)\\n    {\\n        int n=s.size(),i=0,res=0;\\n        string l=\"\",r=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            l=l+s[i];\\n            r=s[n-1-i]+r;\\n            if(l==r)\\n            {\\n                res++;\\n                l=\"\";\\n                r=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2532852,
                "title": "c-pointer-and-sliding-window-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/ba72f1b8-90e6-4b2f-b5c6-9ad27833ee41_1662354871.486079.jpeg)\\n\\n\\n<br/><br/>\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int left_bound=0, right_bound=text.size()-1, left=0, right=text.size()-1, left_itr, right_itr, count=0;\\n        \\n        while(left<=right) {\\n            right_itr=right;\\n            // right_itr will find a matched char same as at left_bound\\n            while(right_itr>=0 and text[right_itr]!=text[left_bound]) \\n                right_itr--;\\n            right=right_itr;      // now we consider right window as [right, right_bound]\\n            left_itr=left_bound;\\n            // to check if we find a matched window in the left side same as right window\\n            while(right_itr<=right_bound and text[right_itr]==text[left_itr]) {\\n                right_itr++;\\n                left_itr++;\\n            }\\n            \\n            right_itr--;\\n            left_itr--;\\n            left=left_itr;\\n            // if both left window and right window matched\\n            if(right_itr==right_bound) {\\n                if(left_itr==right_itr) count+=1;      // both are actually same window\\n                else count+=2;                         // different window\\n                left_bound=left+1;\\n                left=left+1;\\n                right_bound=right-1;\\n                right=right-1;\\n            } else {\\n                right--;         // left window and right window didn\\'t matched\\n            }\\n            \\n        }\\n        \\n        return text.size()<2 ? text.size() : count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        int left_bound=0, right_bound=text.size()-1, left=0, right=text.size()-1, left_itr, right_itr, count=0;\\n        \\n        while(left<=right) {\\n            right_itr=right;\\n            // right_itr will find a matched char same as at left_bound\\n            while(right_itr>=0 and text[right_itr]!=text[left_bound]) \\n                right_itr--;\\n            right=right_itr;      // now we consider right window as [right, right_bound]\\n            left_itr=left_bound;\\n            // to check if we find a matched window in the left side same as right window\\n            while(right_itr<=right_bound and text[right_itr]==text[left_itr]) {\\n                right_itr++;\\n                left_itr++;\\n            }\\n            \\n            right_itr--;\\n            left_itr--;\\n            left=left_itr;\\n            // if both left window and right window matched\\n            if(right_itr==right_bound) {\\n                if(left_itr==right_itr) count+=1;      // both are actually same window\\n                else count+=2;                         // different window\\n                left_bound=left+1;\\n                left=left+1;\\n                right_bound=right-1;\\n                right=right-1;\\n            } else {\\n                right--;         // left window and right window didn\\'t matched\\n            }\\n            \\n        }\\n        \\n        return text.size()<2 ? text.size() : count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518112,
                "title": "string-two-pointer",
                "content": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        return solve(text,0);\\n    }\\n    public int solve(String text,int i){\\n        //System.out.println(text);\\n        if(text.equals(\"\"))\\n            return 0;\\n        if(i>=text.length()/2)\\n            return 1;\\n        String prefix=text.substring(0,i+1);\\n        String suffix=text.substring(text.length()-i-1,text.length());\\n        \\n        if(prefix.equals(suffix)){\\n            //System.out.println(prefix);\\n            return 2+solve(text.substring(i+1,text.length()-i-1),0);\\n        }\\n        else{\\n            return solve(text,i+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        return solve(text,0);\\n    }\\n    public int solve(String text,int i){\\n        //System.out.println(text);\\n        if(text.equals(\"\"))\\n            return 0;\\n        if(i>=text.length()/2)\\n            return 1;\\n        String prefix=text.substring(0,i+1);\\n        String suffix=text.substring(text.length()-i-1,text.length());\\n        \\n        if(prefix.equals(suffix)){\\n            //System.out.println(prefix);\\n            return 2+solve(text.substring(i+1,text.length()-i-1),0);\\n        }\\n        else{\\n            return solve(text,i+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497821,
                "title": "python-solution-greedy-recursive",
                "content": "```\\nclass Solution:\\n    # This question asks for COMPLETE split\\n    # So, the strategy is to construct substring from two ends of the string\\n    # if see perfect match, we add 2 to the result\\n    # When both pointers reaches the end, we return 1\\n\\t# Edge case: text is empty, return 0\\n    def longestDecomposition(self, text: str) -> int:\\n        if not text:\\n            return 0\\n        l, r = 0, len(text)-1\\n        prefix, suffix, match = \"\", \"\", False \\n        while l < len(text) and r >= 0 and not match:\\n            prefix += text[l]\\n            suffix = text[r] + suffix\\n            if prefix == suffix:\\n                match = True\\n            l += 1\\n            r -= 1\\n        if l == len(text) and r == -1:\\n            return 1\\n        else:\\n            return 2 + self.longestDecomposition(text[l:r+1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # This question asks for COMPLETE split\\n    # So, the strategy is to construct substring from two ends of the string\\n    # if see perfect match, we add 2 to the result\\n    # When both pointers reaches the end, we return 1\\n\\t# Edge case: text is empty, return 0\\n    def longestDecomposition(self, text: str) -> int:\\n        if not text:\\n            return 0\\n        l, r = 0, len(text)-1\\n        prefix, suffix, match = \"\", \"\", False \\n        while l < len(text) and r >= 0 and not match:\\n            prefix += text[l]\\n            suffix = text[r] + suffix\\n            if prefix == suffix:\\n                match = True\\n            l += 1\\n            r -= 1\\n        if l == len(text) and r == -1:\\n            return 1\\n        else:\\n            return 2 + self.longestDecomposition(text[l:r+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461596,
                "title": "java-easy-to-understand-two-pointers",
                "content": "The approach is very simple. Start collecting the characters from left and right separately. \\n\\n```\\npublic int longestDecomposition(String text) {\\n        if(text == null || text.length() == 0) return 0;\\n\\n        int n = text.length();\\n        StringBuilder left = new StringBuilder();\\n        String right = \"\";\\n\\n        int matchedCount = 0;\\n\\n        for(int i=0; i < text.length(); i++) {\\n            left.append(text.charAt(i));\\n            right = text.charAt(n - i - 1) + right;\\n            if(left.toString().equals(right)){\\n                matchedCount++;\\n                left = new StringBuilder();\\n                right = \"\";\\n            }\\n        }\\n\\n        return matchedCount;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic int longestDecomposition(String text) {\\n        if(text == null || text.length() == 0) return 0;\\n\\n        int n = text.length();\\n        StringBuilder left = new StringBuilder();\\n        String right = \"\";\\n\\n        int matchedCount = 0;\\n\\n        for(int i=0; i < text.length(); i++) {\\n            left.append(text.charAt(i));\\n            right = text.charAt(n - i - 1) + right;\\n            if(left.toString().equals(right)){\\n                matchedCount++;\\n                left = new StringBuilder();\\n                right = \"\";\\n            }\\n        }\\n\\n        return matchedCount;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458452,
                "title": "simple-short-c-code",
                "content": "```\\n//The logic part is preety straightforward we just have to compare prefix string \\n//and suffix string (mentioned as start & end)\\n//There are two cases :\\n//1. n is even - in this case the edge case is that from the ith position till n/2-1\\n//if it is not equal to corresponding suffix then that complete whole string is \\n//considered to be 1. how do we check this ?? by placing continue statement \\n// in the comparison (start==end)\\n\\n//2.n is odd- this is somewhat in continuation to even case if suppose from the \\n// ith position till n/2-1 is equal to corresponding suffix then flag still remains //true and as the length is odd there must be some character left which will be\\n//cnt as 1 therefore increament in ans as ans++;\\n\\n int longestDecomposition(string text) {\\n     \\n        string start,end;\\n        int n=text.size();\\n        \\n        int ans=0,lastIndx=n;\\n        int flag=1;\\n        for(int i=0;i<n/2;i++){\\n          start+=text[i];\\n          end=\"\";  \\n          for(int j=n-1-i;j<lastIndx;j++){\\n              end+=text[j];\\n          }\\n          if(start==end){\\n              ans+=2;\\n              start=\"\";\\n             lastIndx=n-1-i;\\n              continue;\\n          }\\n          if(i==n/2-1)flag=0,ans++; \\n        }\\n        if(flag && n%2)ans++;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n//The logic part is preety straightforward we just have to compare prefix string \\n//and suffix string (mentioned as start & end)\\n//There are two cases :\\n//1. n is even - in this case the edge case is that from the ith position till n/2-1\\n//if it is not equal to corresponding suffix then that complete whole string is \\n//considered to be 1. how do we check this ?? by placing continue statement \\n// in the comparison (start==end)\\n\\n//2.n is odd- this is somewhat in continuation to even case if suppose from the \\n// ith position till n/2-1 is equal to corresponding suffix then flag still remains //true and as the length is odd there must be some character left which will be\\n//cnt as 1 therefore increament in ans as ans++;\\n\\n int longestDecomposition(string text) {\\n     \\n        string start,end;\\n        int n=text.size();\\n        \\n        int ans=0,lastIndx=n;\\n        int flag=1;\\n        for(int i=0;i<n/2;i++){\\n          start+=text[i];\\n          end=\"\";  \\n          for(int j=n-1-i;j<lastIndx;j++){\\n              end+=text[j];\\n          }\\n          if(start==end){\\n              ans+=2;\\n              start=\"\";\\n             lastIndx=n-1-i;\\n              continue;\\n          }\\n          if(i==n/2-1)flag=0,ans++; \\n        }\\n        if(flag && n%2)ans++;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2449835,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    bool issame(string &lst, string &rst)\\n    {\\n        for(int i = 0; i < lst.size(); i++)\\n        {\\n            if(lst[i] != rst[i])\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int left = 0, right = n-1, ans = 0;\\n        string lst = \"\", rst = \"\";\\n        while(left < right)\\n        {\\n            lst.push_back(text[left]);\\n            rst = text[right] + rst;\\n            if(issame(lst,rst))\\n            {\\n                ans +=2;\\n                lst = \"\";\\n                rst = \"\";\\n            }\\n            if(left+1 == right && lst == rst)\\n                return ans;\\n            left++;\\n            right--;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    bool issame(string &lst, string &rst)\\n    {\\n        for(int i = 0; i < lst.size(); i++)\\n        {\\n            if(lst[i] != rst[i])\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        int left = 0, right = n-1, ans = 0;\\n        string lst = \"\", rst = \"\";\\n        while(left < right)\\n        {\\n            lst.push_back(text[left]);\\n            rst = text[right] + rst;\\n            if(issame(lst,rst))\\n            {\\n                ans +=2;\\n                lst = \"\";\\n                rst = \"\";\\n            }\\n            if(left+1 == right && lst == rst)\\n                return ans;\\n            left++;\\n            right--;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439732,
                "title": "easy-to-understand-python-solution",
                "content": "\\t\\tclass Solution:\\n\\t\\t\\tdef longestDecomposition(self, text: str) -> int:\\n\\t\\t\\t\\n\\t\\t\\t\\treverse = text[::-1]\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\tpreviousIdx = 0\\n\\t\\t\\t\\tnextIdx = 1\\n\\n\\t\\t\\t\\twhile nextIdx < len(reverse) + 1:\\n\\t\\t\\t\\t\\tif reverse[previousIdx:nextIdx][::-1] == text[previousIdx:nextIdx]:\\n\\t\\t\\t\\t\\t\\tpreviousIdx = nextIdx\\n\\t\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\t\\tnextIdx += 1\\n\\n\\t\\t\\t\\treturn(k)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tclass Solution:\\n\\t\\t\\tdef longestDecomposition(self, text: str) -> int:\\n\\t\\t\\t\\n\\t\\t\\t\\treverse = text[::-1]\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\tpreviousIdx = 0\\n\\t\\t\\t\\tnextIdx = 1\\n\\n\\t\\t\\t\\twhile nextIdx < len(reverse) + 1:\\n\\t\\t\\t\\t\\tif reverse[previousIdx:nextIdx][::-1] == text[previousIdx:nextIdx]:\\n\\t\\t\\t\\t\\t\\tpreviousIdx = nextIdx\\n\\t\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\t\\tnextIdx += 1\\n\\n\\t\\t\\t\\treturn(k)",
                "codeTag": "Java"
            },
            {
                "id": 2421223,
                "title": "c-faster-than-100-o-n-time-complexity",
                "content": "int longestDecomposition(string s) {\\n        \\n        int n = s.length();\\n        \\n        int i=0,j=n-1;\\n        int count=0;\\n        string left=\"\",right=\"\";\\n        while(i<j){\\n            left+=s[i];\\n            right = s[j]+right;\\n            \\n            if(left==right){\\n                count+=2;\\n                left=\"\";\\n                right=\"\";\\n            }\\n            if(i+1==j && left==right){\\n                return count;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return count+1;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "int longestDecomposition(string s) {\\n        \\n        int n = s.length();\\n        \\n        int i=0,j=n-1;\\n        int count=0;\\n        string left=\"\",right=\"\";\\n        while(i<j){\\n            left+=s[i];\\n            right = s[j]+right;\\n            \\n            if(left==right){\\n                count+=2;\\n                left=\"\";\\n                right=\"\";\\n            }\\n            if(i+1==j && left==right){\\n                return count;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return count+1;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2411362,
                "title": "c-100-fast-solution",
                "content": "\\'\\'\\' \\nclass Solution { \\npublic:\\n\\n    int longestDecomposition(string text) {\\n\\t\\n        int ans = 0 , n = text.size();\\n\\t\\t\\n        int i = -1 , j = n;\\n        \\n        while(i < j-1){\\n            \\n            int k = j-1;\\n            while(k >i && text.substr(k , (j-k)) != text.substr(i+1,(j-k)) ){\\n                k--;\\n            }\\n            \\n            if(k == i+1){\\n                ans +=1;\\n            }else{\\n                ans +=2;\\n            }\\n            i = i+ (j-k);\\n            j = k;\\n        }\\n        return ans;\\n    }\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution { \\npublic:\\n\\n    int longestDecomposition(string text) {\\n\\t\\n        int ans = 0 , n = text.size();\\n\\t\\t\\n        int i = -1 , j = n;\\n        \\n        while(i < j-1){\\n            \\n            int k = j-1;\\n            while(k >i && text.substr(k , (j-k)) != text.substr(i+1,(j-k)) ){\\n                k--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2340593,
                "title": "python-3-rolling-hash",
                "content": "\\tclass Solution:\\n\\t\\tdef longestDecomposition(self, text: str) -> int:\\n\\t\\t\\tdef get_val(ch):\\n\\t\\t\\t\\treturn ord(ch)-ord(\\'a\\')\\n\\t\\t\\tn=len(text)\\n\\t\\t\\tl,r=0,n-1\\n\\t\\t\\tp,mod=26,pow(10,9)+7\\n\\t\\t\\tc=1\\n\\t\\t\\th1=h2=count=size=0\\n\\t\\t\\twhile l<r:\\n\\t\\t\\t\\th1=(h1*p+get_val(text[l]))%mod\\n\\t\\t\\t\\th2=(c*get_val(text[r])+h2)%mod\\n\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tr-=1\\n\\t\\t\\t\\tsize+=1\\n\\t\\t\\t\\tif h1==h2:\\n\\t\\t\\t\\t\\tcount+=2\\n\\t\\t\\t\\t\\tc=1\\n\\t\\t\\t\\t\\th1=h2=size=0\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc*=p\\n\\t\\t\\treturn count+ int((size == 0 and l == r) or size > 0)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef longestDecomposition(self, text: str) -> int:\\n\\t\\t\\tdef get_val(ch):\\n\\t\\t\\t\\treturn ord(ch)-ord(\\'a\\')\\n\\t\\t\\tn=len(text)\\n\\t\\t\\tl,r=0,n-1\\n\\t\\t\\tp,mod=26,pow(10,9)+7\\n\\t\\t\\tc=1\\n\\t\\t\\th1=h2=count=size=0\\n\\t\\t\\twhile l<r:\\n\\t\\t\\t\\th1=(h1*p+get_val(text[l]))%mod\\n\\t\\t\\t\\th2=(c*get_val(text[r])+h2)%mod\\n\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tr-=1\\n\\t\\t\\t\\tsize+=1\\n\\t\\t\\t\\tif h1==h2:\\n\\t\\t\\t\\t\\tcount+=2\\n\\t\\t\\t\\t\\tc=1\\n\\t\\t\\t\\t\\th1=h2=size=0\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc*=p\\n\\t\\t\\treturn count+ int((size == 0 and l == r) or size > 0)",
                "codeTag": "Java"
            },
            {
                "id": 2331574,
                "title": "2-ms-faster-then-83-56-java-solution",
                "content": "2 ms , Faster then 83.56% || JAVA SOLUTION\\n```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int i=0,j=text.length()-1,ans = 0;\\n        StringBuilder s = new StringBuilder();\\n        while(i<=j){\\n            //find the start char from last and add it in string;\\n            while(text.charAt(j)!=text.charAt(i)){ \\n                s.append(text.charAt(j)); \\n                j--;\\n            }\\n            // when both char are same we terminate from while loop so add explicitly\\n            s.append(text.charAt(j));\\n            \\n            //check string from start is equal to string from back\\n            if(text.substring(i,n-j).equals(s.reverse().toString())){\\n                ans++;\\n                i=n-j; \\n                s.setLength(0);\\n            }\\n            // while checking in if condition we reverse s ,to get back we again reverse it\\n            else{\\n                s.reverse();   \\n            }\\n            j--;\\n        }\\n        //when each substring in string occur twice\\n        if(i==j+1){\\n            return (2*ans);\\n        }\\n        return (2*ans)-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestDecomposition(String text) {\\n        int n = text.length();\\n        int i=0,j=text.length()-1,ans = 0;\\n        StringBuilder s = new StringBuilder();\\n        while(i<=j){\\n            //find the start char from last and add it in string;\\n            while(text.charAt(j)!=text.charAt(i)){ \\n                s.append(text.charAt(j)); \\n                j--;\\n            }\\n            // when both char are same we terminate from while loop so add explicitly\\n            s.append(text.charAt(j));\\n            \\n            //check string from start is equal to string from back\\n            if(text.substring(i,n-j).equals(s.reverse().toString())){\\n                ans++;\\n                i=n-j; \\n                s.setLength(0);\\n            }\\n            // while checking in if condition we reverse s ,to get back we again reverse it\\n            else{\\n                s.reverse();   \\n            }\\n            j--;\\n        }\\n        //when each substring in string occur twice\\n        if(i==j+1){\\n            return (2*ans);\\n        }\\n        return (2*ans)-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302425,
                "title": "java-string-prefix-solution",
                "content": "class Solution {\\n\\n    public int longestDecomposition(String text) {\\n        \\n        //prefix, suffix check\\n        //prefix == suffix result+=2;\\n        //prefix == text result+1 return;\\n        int result = 0;\\n        int start = 0;\\n        int left = 1;\\n        \\n        while(text.length() > 0) {\\n            String pre = text.substring(start, left);\\n\\n            if(text.equals(pre) == true) return ++result;\\n            \\n            else if(text.endsWith(pre) == true) {\\n                result+=2;\\n                text = text.substring(start + pre.length(), text.length() - pre.length());\\n                left = 1;\\n            }\\n\\n            else left++;\\n        }\\n    return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public int longestDecomposition(String text) {\\n        \\n        //prefix, suffix check\\n        //prefix == suffix result+=2;\\n        //prefix == text result+1 return;\\n        int result = 0;\\n        int start = 0;\\n        int left = 1;\\n        \\n        while(text.length() > 0) {\\n            String pre = text.substring(start, left);\\n\\n            if(text.equals(pre) == true) return ++result;\\n            \\n            else if(text.endsWith(pre) == true) {\\n                result+=2;\\n                text = text.substring(start + pre.length(), text.length() - pre.length());\\n                left = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2298613,
                "title": "o-n-c-solution-using-rolling-hash",
                "content": "```\\n#define ll long long\\n#define mod 1000000007\\n#define p 31\\n\\nclass Solution {\\npublic:\\n    ll hash[1002];\\n    ll p_pow[1003];\\n\\n    int cal(int l,int r){\\n        // to calculate hash between l to r\\n        ll var=(hash[r]-hash[l-1]+mod)%mod;\\n        var=var*(p_pow[1001-l])%mod;\\n        return var;\\n    }\\n    \\n    int longestDecomposition(string s) {\\n      int n=s.size();\\n        p_pow[0]=1;\\n      for(int i=1;i<=1002;i++){\\n         p_pow[i]=(p_pow[i-1]*p)%mod;\\n      }\\n      s=\"#\"+s;\\n      for(int i=1;i<=n;i++){\\n          hash[i]=(hash[i-1]+(s[i]-\\'a\\'+1)*p_pow[i])%mod;\\n      }\\n        // hash is calculated\\n        \\n      int l=1,r=n;// initially we have to calculate between [1-n]\\n        int ans=0;\\n        for(int i=1;i<=n;i++){// now we simply traversing greedily \\n            if(l>r)break;     // and updating l and r\\n            if(i>=r+l-i){\\n                ans++;\\n                break;\\n            }\\n            cout<<l<<\" \"<<r<<endl;\\n            if(cal(l,i)==cal(r-i+l,r)){\\n                ans+=2;\\n                r=r-i+l-1;  // l,r will be updated\\n                l=i+1;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\n#define p 31\\n\\nclass Solution {\\npublic:\\n    ll hash[1002];\\n    ll p_pow[1003];\\n\\n    int cal(int l,int r){\\n        // to calculate hash between l to r\\n        ll var=(hash[r]-hash[l-1]+mod)%mod;\\n        var=var*(p_pow[1001-l])%mod;\\n        return var;\\n    }\\n    \\n    int longestDecomposition(string s) {\\n      int n=s.size();\\n        p_pow[0]=1;\\n      for(int i=1;i<=1002;i++){\\n         p_pow[i]=(p_pow[i-1]*p)%mod;\\n      }\\n      s=\"#\"+s;\\n      for(int i=1;i<=n;i++){\\n          hash[i]=(hash[i-1]+(s[i]-\\'a\\'+1)*p_pow[i])%mod;\\n      }\\n        // hash is calculated\\n        \\n      int l=1,r=n;// initially we have to calculate between [1-n]\\n        int ans=0;\\n        for(int i=1;i<=n;i++){// now we simply traversing greedily \\n            if(l>r)break;     // and updating l and r\\n            if(i>=r+l-i){\\n                ans++;\\n                break;\\n            }\\n            cout<<l<<\" \"<<r<<endl;\\n            if(cal(l,i)==cal(r-i+l,r)){\\n                ans+=2;\\n                r=r-i+l-1;  // l,r will be updated\\n                l=i+1;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};``\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2211214,
                "title": "greedy-c",
                "content": "Start with an example: \"abcabc\"\\nWe want to start from either side and construct 2 strings simultaneously: ```left``` & ```right```\\n```left``` is the first ```lo``` characters of ```text```, \\n```right``` is the last ```hi``` characters of ```text``` \\n\\nIf ```left == reverse(right)```, we have found a palindromic decompostion, hence we add 2 to the ```count```, and reset ```left``` and ```right```\\nWe shrink our two pointers (```lo++``` and ```hi--```)\\n\\n\\nCorner case: if there\\'s no palindromic decomposition, ```count=1```\\nOr if only one character left at the end (```lo == hi```), increment ```count``` by 1\\n\\n\\nI guess the tricky part was to figure out the \"greedy-ness\" of the solution. Since we want to maximize the number of palindromic decompositions, as soon as we come across a palindromic decomposition, we create a split. \\n\\nWe can prove this using contradiction:\\nConsider the ```subtext_i``` and suffix ```subtext_k-i+1``` of ```text```. \\nAnd let\\'s say we have already found the \"max\" palindromic decomposition by breaking ```text``` into ```k``` substrings. \\n\\nBut if ```subtext_i[0:x] == (subtext_k-i+1[end-x:end] = reverse(subtext_k-i+1)[0:x]``` for any ```0 < x < len(subtext_i)```, then we can break down ```subtext_i``` & ```subtext_k-i+1``` into 2 pairs: ```subtext_i[0:x] & subtext_k-i+1[end-x:end]``` & ```subtext_i[x:end] & subtext_k-i+1[0:x]```.\\nHence resulting in ```k+2``` decompositions rather than ```k``` which is a contradiction.\\n\\n\\nHope that makes it clear. \\n\\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        string left, right;\\n        int n = text.size();\\n        int lo = 0, hi = n-1;\\n        int count = 0;\\n        \\n        while (lo < hi) {\\n            left.push_back(text[lo++]);\\n            right.push_back(text[hi--]);\\n            reverse(right.begin(), right.end());\\n            if (left == right) {\\n                count += 2;\\n                left = \"\";\\n                right = \"\";\\n            }\\n            else {\\n                reverse(right.begin(), right.end());\\n            }\\n        }\\n        \\n        if (!left.empty() || !right.empty() || lo == hi) ++count;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```left```\n```right```\n```left```\n```lo```\n```text```\n```right```\n```hi```\n```text```\n```left == reverse(right)```\n```count```\n```left```\n```right```\n```lo++```\n```hi--```\n```count=1```\n```lo == hi```\n```count```\n```subtext_i```\n```subtext_k-i+1```\n```text```\n```text```\n```k```\n```subtext_i[0:x] == (subtext_k-i+1[end-x:end] = reverse(subtext_k-i+1)[0:x]```\n```0 < x < len(subtext_i)```\n```subtext_i```\n```subtext_k-i+1```\n```subtext_i[0:x] & subtext_k-i+1[end-x:end]```\n```subtext_i[x:end] & subtext_k-i+1[0:x]```\n```k+2```\n```k```\n```\\nclass Solution {\\npublic:\\n    int longestDecomposition(string text) {\\n        string left, right;\\n        int n = text.size();\\n        int lo = 0, hi = n-1;\\n        int count = 0;\\n        \\n        while (lo < hi) {\\n            left.push_back(text[lo++]);\\n            right.push_back(text[hi--]);\\n            reverse(right.begin(), right.end());\\n            if (left == right) {\\n                count += 2;\\n                left = \"\";\\n                right = \"\";\\n            }\\n            else {\\n                reverse(right.begin(), right.end());\\n            }\\n        }\\n        \\n        if (!left.empty() || !right.empty() || lo == hi) ++count;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146285,
                "title": "c-solution-based-on-recusion-and-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> records;\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        this->records = vector<int>(n / 2 + 1, -1);\\n        return helper(text, n, 0);\\n    }\\n    /*\\n        initially, call helper(text, n, 0)\\n    */\\n    int helper(string text, int n, int p){\\n        \\n        int mirror_p = n - p - 1;\\n        if (p > mirror_p){\\n            return 0;\\n        }\\n        if (p == mirror_p){\\n            return 1;\\n        }\\n        if (this->records[p] != -1){\\n            return this->records[p];\\n        }\\n        // regular case:\\n        int sub, result = 1;\\n        for (int i = p; i < n / 2; i++){\\n            // [p, i] ------ [, mirror_p]\\n            int length = i - p + 1;\\n            string sub_left = text.substr(p, length);\\n            string sub_right = text.substr(n - i - 1, length);\\n            if (sub_left.compare(sub_right) == 0){\\n                sub = 2 + helper(text, n, i + 1);\\n                result = max(result, sub);\\n            }\\n        }\\n        this->records[p] = result;\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> records;\\n    int longestDecomposition(string text) {\\n        int n = text.size();\\n        this->records = vector<int>(n / 2 + 1, -1);\\n        return helper(text, n, 0);\\n    }\\n    /*\\n        initially, call helper(text, n, 0)\\n    */\\n    int helper(string text, int n, int p){\\n        \\n        int mirror_p = n - p - 1;\\n        if (p > mirror_p){\\n            return 0;\\n        }\\n        if (p == mirror_p){\\n            return 1;\\n        }\\n        if (this->records[p] != -1){\\n            return this->records[p];\\n        }\\n        // regular case:\\n        int sub, result = 1;\\n        for (int i = p; i < n / 2; i++){\\n            // [p, i] ------ [, mirror_p]\\n            int length = i - p + 1;\\n            string sub_left = text.substr(p, length);\\n            string sub_right = text.substr(n - i - 1, length);\\n            if (sub_left.compare(sub_right) == 0){\\n                sub = 2 + helper(text, n, i + 1);\\n                result = max(result, sub);\\n            }\\n        }\\n        this->records[p] = result;\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141642,
                "title": "javascript-iterative-two-pointers-o-n-time-o-1-space-69-time-100-space",
                "content": "```\\nvar longestDecomposition = function(text) {\\n    let l = 0, r = text.length - 1, rEnd = text.length;\\n    let output = 0;\\n    while (l <= r) {\\n        if (text[l] === text[r]) {\\n            if (l === r) {\\n                output++;\\n                break;\\n            }\\n            let tempL = l, tempR = r;\\n            // Check if l matches r all the way until rEnd\\n            // r must reach the rEnd, otherwise there is no valid match\\n            while (tempR < rEnd) {\\n                if (text[tempL] === text[tempR]) {\\n                    tempL++, tempR++;\\n                    continue;\\n                } else break;\\n            }\\n            // If matched, set l to its new position at tempL and set rEnd to r, thereby shrinking the window\\n            if (tempR === rEnd) {\\n                l = tempL;\\n                rEnd = r;\\n                output += 2;\\n            }\\n        }\\n        r--;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestDecomposition = function(text) {\\n    let l = 0, r = text.length - 1, rEnd = text.length;\\n    let output = 0;\\n    while (l <= r) {\\n        if (text[l] === text[r]) {\\n            if (l === r) {\\n                output++;\\n                break;\\n            }\\n            let tempL = l, tempR = r;\\n            // Check if l matches r all the way until rEnd\\n            // r must reach the rEnd, otherwise there is no valid match\\n            while (tempR < rEnd) {\\n                if (text[tempL] === text[tempR]) {\\n                    tempL++, tempR++;\\n                    continue;\\n                } else break;\\n            }\\n            // If matched, set l to its new position at tempL and set rEnd to r, thereby shrinking the window\\n            if (tempR === rEnd) {\\n                l = tempL;\\n                rEnd = r;\\n                output += 2;\\n            }\\n        }\\n        r--;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113842,
                "title": "easy-c-solutions-faster-than-100-simple-rolling-hash",
                "content": "```\\nclass Solution {\\n    bool check(string &t, int front, int end, int mover){\\n        string a = t.substr(front-mover,mover);\\n        string b = t.substr(end+1,mover);\\n        return a==b;\\n    }\\n    bool rh(string &t, int &front,int &end){\\n        int first=0,second =0;\\n        int mover=0;\\n        while(front<=end){\\n            mover++;\\n            first+=int(t[front]);\\n            second+=int(t[end]);\\n            front++;\\n            end--;\\n            if(first==second && check(t,front,end,mover))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int longestDecomposition(string t) {\\n        int count=0;\\n        int front=0,end=t.size()-1;\\n        while(front<=end){\\n            if(t[front]==t[end]){\\n                if(front==end) count++;\\n                else count+=2;\\n                front++,end--;\\n            }\\n            else{\\n                if(rh(t,front,end)==true) count+=2;\\n                else count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &t, int front, int end, int mover){\\n        string a = t.substr(front-mover,mover);\\n        string b = t.substr(end+1,mover);\\n        return a==b;\\n    }\\n    bool rh(string &t, int &front,int &end){\\n        int first=0,second =0;\\n        int mover=0;\\n        while(front<=end){\\n            mover++;\\n            first+=int(t[front]);\\n            second+=int(t[end]);\\n            front++;\\n            end--;\\n            if(first==second && check(t,front,end,mover))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int longestDecomposition(string t) {\\n        int count=0;\\n        int front=0,end=t.size()-1;\\n        while(front<=end){\\n            if(t[front]==t[end]){\\n                if(front==end) count++;\\n                else count+=2;\\n                front++,end--;\\n            }\\n            else{\\n                if(rh(t,front,end)==true) count+=2;\\n                else count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106207,
                "title": "go-simple-two-pointer",
                "content": "```\\nfunc longestDecomposition(text string) int {\\n    if len(text) == 1 {\\n        return 1\\n    }\\n    \\n    k := 0\\n    str := text\\n    for len(str) > 0 {\\n        l := 1\\n        r := len(str)-1\\n        for l <= r {\\n            if str[:l] == str[r:] {\\n                k+=2\\n                str = str[l:r]\\n                break\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        if l > r && len(str) > 0 {\\n            k++\\n            break\\n        }\\n    }\\n    return k\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\nfunc longestDecomposition(text string) int {\\n    if len(text) == 1 {\\n        return 1\\n    }\\n    \\n    k := 0\\n    str := text\\n    for len(str) > 0 {\\n        l := 1\\n        r := len(str)-1\\n        for l <= r {\\n            if str[:l] == str[r:] {\\n                k+=2\\n                str = str[l:r]\\n                break\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        if l > r && len(str) > 0 {\\n            k++\\n            break\\n        }\\n    }\\n    return k\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075437,
                "title": "easy-peasy-standard-hashing-rabin-karp-implementation",
                "content": "```\\n#define ll long\\nclass Solution {\\npublic:\\n    // 1-indexed string needed\\n    struct Hashs\\n    {\\n        vector<ll> hash;\\n        vector<ll> pows;\\n        ll P;\\n        ll mod;\\n\\n        Hashs() {}\\n\\n        Hashs(string &s,ll P,ll M) : P(P), mod(M)\\n        {\\n            ll n=s.size();\\n            pows.resize(n+1, 0);\\n            hash.resize(n+1, 0);\\n            pows[0] = 1;\\n            for(ll i=1;i<=n;i++)\\n            {\\n                pows[i]=(pows[i-1]*P)%mod;\\n                hash[i]=(hash[i-1]*P+(s[i-1]-\\'a\\'+1))%mod;\\n            }\\n        }\\n\\n        ll get_hash(ll l,ll r)  // [l,r]\\n        {\\n            return ( hash[r] - (hash[l-1]*pows[r-l+1])%mod + mod ) % mod;\\n        }\\n    };\\n\\n    int longestDecomposition(string s) \\n    {\\n        Hashs hs(s,31,1e9+7);\\n        int l=1,i=1,r=s.length(),j=s.length();\\n        int ans=0;\\n        while(i<=r && j>=l)\\n        {\\n            if(hs.get_hash(l,i)==hs.get_hash(j,r))\\n            {\\n                if(j==l) ans++;\\n                else ans+=2;\\n                l=i+1;\\n                r=j-1;\\n            }\\n            i++; j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long\\nclass Solution {\\npublic:\\n    // 1-indexed string needed\\n    struct Hashs\\n    {\\n        vector<ll> hash;\\n        vector<ll> pows;\\n        ll P;\\n        ll mod;\\n\\n        Hashs() {}\\n\\n        Hashs(string &s,ll P,ll M) : P(P), mod(M)\\n        {\\n            ll n=s.size();\\n            pows.resize(n+1, 0);\\n            hash.resize(n+1, 0);\\n            pows[0] = 1;\\n            for(ll i=1;i<=n;i++)\\n            {\\n                pows[i]=(pows[i-1]*P)%mod;\\n                hash[i]=(hash[i-1]*P+(s[i-1]-\\'a\\'+1))%mod;\\n            }\\n        }\\n\\n        ll get_hash(ll l,ll r)  // [l,r]\\n        {\\n            return ( hash[r] - (hash[l-1]*pows[r-l+1])%mod + mod ) % mod;\\n        }\\n    };\\n\\n    int longestDecomposition(string s) \\n    {\\n        Hashs hs(s,31,1e9+7);\\n        int l=1,i=1,r=s.length(),j=s.length();\\n        int ans=0;\\n        while(i<=r && j>=l)\\n        {\\n            if(hs.get_hash(l,i)==hs.get_hash(j,r))\\n            {\\n                if(j==l) ans++;\\n                else ans+=2;\\n                l=i+1;\\n                r=j-1;\\n            }\\n            i++; j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565401,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            },
            {
                "id": 1572915,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            },
            {
                "id": 1948154,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            },
            {
                "id": 1876288,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            },
            {
                "id": 1717212,
                "content": [
                    {
                        "username": "cuiaoxiang",
                        "content": "The original constraint is 1 <= text.length <= 200, it changed to 1 <= text.length <= 1000 in the middle the contest without announcement, which is improfessional and disappointing.\\n\\nMy first and second submission get RTE b/c there are test cases with text.length > 200."
                    },
                    {
                        "username": "shai_halud",
                        "content": "I built it using a suffix tree. The run-time sucked !\\n\\nBut, the memory was orders of magnitude better than everyone else !"
                    },
                    {
                        "username": "czjnbb",
                        "content": "This is medium."
                    },
                    {
                        "username": "julkar9",
                        "content": "Spoilers...\\n\\n\\n\\n\\n\\nNot a dynamic programming problem, greedy works just fine"
                    },
                    {
                        "username": "Nitish_KSingh1",
                        "content": "unbelievable answer @"
                    }
                ]
            }
        ]
    }
]