[
    {
        "title": "Insert Interval",
        "question_content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n&nbsp;\nConstraints:\n\n\t0 <= intervals.length <= 104\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 105\n\tintervals is sorted by starti in ascending order.\n\tnewInterval.length == 2\n\t0 <= start <= end <= 105",
        "solutions": [
            {
                "id": 21602,
                "title": "short-and-straight-forward-java-solution",
                "content": "Hi guys!\\n\\nHere's a pretty straight-forward and concise solution below.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new LinkedList<>();\\n        int i = 0;\\n        // add all the intervals ending before newInterval starts\\n        while (i < intervals.size() && intervals.get(i).end < newInterval.start)\\n            result.add(intervals.get(i++));\\n        // merge all overlapping intervals to one considering newInterval\\n        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\\n            newInterval = new Interval( // we could mutate newInterval here also\\n                    Math.min(newInterval.start, intervals.get(i).start),\\n                    Math.max(newInterval.end, intervals.get(i).end));\\n            i++;\\n        }\\n        result.add(newInterval); // add the union of intervals we got\\n        // add all the rest\\n        while (i < intervals.size()) result.add(intervals.get(i++)); \\n        return result;\\n    }\\n\\nHope it helps.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nHere's a pretty straight-forward and concise solution below.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new LinkedList<>();\\n        int i = 0;\\n        // add all the intervals ending before newInterval starts\\n        while (i < intervals.size() && intervals.get(i).end < newInterval.start)\\n            result.add(intervals.get(i++));\\n        // merge all overlapping intervals to one considering newInterval\\n        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\\n            newInterval = new Interval( // we could mutate newInterval here also\\n                    Math.min(newInterval.start, intervals.get(i).start),\\n                    Math.max(newInterval.end, intervals.get(i).end));\\n            i++;\\n        }\\n        result.add(newInterval); // add the union of intervals we got\\n        // add all the rest\\n        while (i < intervals.size()) result.add(intervals.get(i++)); \\n        return result;\\n    }\\n\\nHope it helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 21622,
                "title": "7-lines-3-easy-solutions",
                "content": "**Solution 1:** (7 lines, 88 ms)\\n\\nCollect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 2:** (8 lines, 84 ms)\\n\\nSame algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        parts = merge, left, right = [], [], []\\n        for i in intervals:\\n            parts[(i.end < s) - (i.start > e)].append(i)\\n        if merge:\\n            s = min(s, merge[0].start)\\n            e = max(e, merge[-1].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 3:** (11 lines, 80 ms)\\n\\nSame again, but collect and merge while going over the intervals once.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left, right = [], []\\n        for i in intervals:\\n            if i.end < s:\\n                left += i,\\n            elif i.start > e:\\n                right += i,\\n            else:\\n                s = min(s, i.start)\\n                e = max(e, i.end)\\n        return left + [Interval(s, e)] + right",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1:** (7 lines, 88 ms)\\n\\nCollect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 2:** (8 lines, 84 ms)\\n\\nSame algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        parts = merge, left, right = [], [], []\\n        for i in intervals:\\n            parts[(i.end < s) - (i.start > e)].append(i)\\n        if merge:\\n            s = min(s, merge[0].start)\\n            e = max(e, merge[-1].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 3:** (11 lines, 80 ms)\\n\\nSame again, but collect and merge while going over the intervals once.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left, right = [], []\\n        for i in intervals:\\n            if i.end < s:\\n                left += i,\\n            elif i.start > e:\\n                right += i,\\n            else:\\n                s = min(s, i.start)\\n                e = max(e, i.end)\\n        return left + [Interval(s, e)] + right",
                "codeTag": "Python3"
            },
            {
                "id": 1327206,
                "title": "99-16-faster-proper-explaination-c-solution-o-n",
                "content": "Here 3 cases will arive:\\n1) ***Non Overlapping intervals before given newInterval*** -> push into the ans vector \\n2) **Overlapping of intervals and newInterval** update new interval \\n   starting point of newInterval will be min of the interval starting point \\n   or starting point of newInterval\\n   Ending point will be the max of interval ending point or newInterval          end point.\\n3) **Non overlapping intervals after the newintervals have been merged** ->    push ito ans vector   \\n   \\n**Time complexity - O(N)** \\n**space complexity - O(1)**\\n\\nAlso, please do not use sorting algo here because we have already provided with sorted list.\\n\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote and comment if have doubt**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21600,
                "title": "short-java-code",
                "content": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<Interval>();\\n        for (Interval i : intervals) {\\n            if (newInterval == null || i.end < newInterval.start)\\n                result.add(i);\\n            else if (i.start > newInterval.end) {\\n                result.add(newInterval);\\n                result.add(i);\\n                newInterval = null;\\n            } else {\\n                newInterval.start = Math.min(newInterval.start, i.start);\\n                newInterval.end = Math.max(newInterval.end, i.end);\\n            }\\n        }\\n        if (newInterval != null)\\n            result.add(newInterval);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<Interval>();\\n        for (Interval i : intervals) {\\n            if (newInterval == null || i.end < newInterval.start)\\n                result.add(i);\\n            else if (i.start > newInterval.end) {\\n                result.add(newInterval);\\n                result.add(i);\\n                newInterval = null;\\n            } else {\\n                newInterval.start = Math.min(newInterval.start, i.start);\\n                newInterval.end = Math.max(newInterval.end, i.end);\\n            }\\n        }\\n        if (newInterval != null)\\n            result.add(newInterval);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21809,
                "title": "python-o-n-and-o-nlgn-solutions",
                "content": "        \\n    \\n    # O(nlgn) time, the same as Merge Intervals \\n    # https://leetcode.com/problems/merge-intervals/\\n    def insert1(self, intervals, newInterval):\\n        intervals.append(newInterval)\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x.start):\\n            if res and res[-1].end >= i.start:\\n                res[-1].end = max(res[-1].end, i.end)\\n            else:\\n                res.append(i)\\n        return res\\n        \\n    # O(n) time, not in-place, make use of the \\n    # property that the intervals were initially sorted \\n    # according to their start times\\n    def insert(self, intervals, newInterval):\\n        res, n = [], newInterval\\n        for index, i in enumerate(intervals):\\n            if i.end < n.start:\\n                res.append(i)\\n            elif n.end < i.start:\\n                res.append(n)\\n                return res+intervals[index:]  # can return earlier\\n            else:  # overlap case\\n                n.start = min(n.start, i.start)\\n                n.end = max(n.end, i.end)\\n        res.append(n)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    \\n    # O(nlgn) time, the same as Merge Intervals \\n    # https://leetcode.com/problems/merge-intervals/\\n    def insert1(self, intervals, newInterval):\\n        intervals.append(newInterval)\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x.start):\\n            if res and res[-1].end >= i.start:\\n                res[-1].end = max(res[-1].end, i.end)\\n            else:\\n                res.append(i)\\n        return res\\n        \\n    # O(n) time, not in-place, make use of the \\n    # property that the intervals were initially sorted \\n    # according to their start times\\n    def insert(self, intervals, newInterval):\\n        res, n = [], newInterval\\n        for index, i in enumerate(intervals):\\n            if i.end < n.start:\\n                res.append(i)\\n            elif n.end < i.start:\\n                res.append(n)\\n                return res+intervals[index:]  # can return earlier\\n            else:  # overlap case\\n                n.start = min(n.start, i.start)\\n                n.end = max(n.end, i.end)\\n        res.append(n)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 959756,
                "title": "java-1ms-easy-line-by-line-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Iterate through all slots\\n        for(int[] slot : intervals)\\n        {\\n            \\n            // if newInterval before slot insert newInterval & update slot as new interval\\n            if(newInterval[1] < slot[0])\\n            {\\n                result.add(newInterval);\\n                newInterval = slot;\\n            } \\n            \\n            // if slot is lesser than new Interval insert slot\\n            else if(slot[1] < newInterval[0])\\n            {\\n                result.add(slot);\\n            } \\n            \\n            // if above conditions fail its an overlap since possibility of new interval existing in left & right of slot is checked\\n            // update lowest of start & highest of end & not insert\\n            else {\\n                newInterval[0] = Math.min(newInterval[0],slot[0]);\\n                newInterval[1] = Math.max(newInterval[1],slot[1]);\\n            }\\n        }\\n        \\n        // insert the last newInterval\\n        result.add(newInterval);\\n        \\n        // convert to int[][] array\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Iterate through all slots\\n        for(int[] slot : intervals)\\n        {\\n            \\n            // if newInterval before slot insert newInterval & update slot as new interval\\n            if(newInterval[1] < slot[0])\\n            {\\n                result.add(newInterval);\\n                newInterval = slot;\\n            } \\n            \\n            // if slot is lesser than new Interval insert slot\\n            else if(slot[1] < newInterval[0])\\n            {\\n                result.add(slot);\\n            } \\n            \\n            // if above conditions fail its an overlap since possibility of new interval existing in left & right of slot is checked\\n            // update lowest of start & highest of end & not insert\\n            else {\\n                newInterval[0] = Math.min(newInterval[0],slot[0]);\\n                newInterval[1] = Math.max(newInterval[1],slot[1]);\\n            }\\n        }\\n        \\n        // insert the last newInterval\\n        result.add(newInterval);\\n        \\n        // convert to int[][] array\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21599,
                "title": "elegant-c-stl-solution-using-equal-range-to-find-overlapped-intervals",
                "content": "    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            auto compare = [] (const Interval &intv1, const Interval &intv2)\\n                              { return intv1.end < intv2.start; };\\n            auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare);\\n            auto itr1 = range.first, itr2 = range.second;\\n            if (itr1 == itr2) {\\n                intervals.insert(itr1, newInterval);\\n            } else {\\n                itr2--;\\n                itr2->start = min(newInterval.start, itr1->start);\\n                itr2->end = max(newInterval.end, itr2->end);\\n                intervals.erase(itr1, itr2);\\n            }\\n            return intervals;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            auto compare = [] (const Interval &intv1, const Interval &intv2)\\n                              { return intv1.end < intv2.start; }",
                "codeTag": "Java"
            },
            {
                "id": 477856,
                "title": "beat-99-consice-java-solution",
                "content": "```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n        \\n        for (int i = 0; i < intervals.length; i ++) {\\n\\t\\t\\t/*1. No overlap and toAdd appears before current interval, add toAdd to result.*/\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n            /*2. Has overlap, update the toAdd to the merged interval.*/\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n\\t\\t\\t/*3. No overlap and toAdd appears after current interval, add current interval to result.*/\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n        \\n        for (int i = 0; i < intervals.length; i ++) {\\n\\t\\t\\t/*1. No overlap and toAdd appears before current interval, add toAdd to result.*/\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n            /*2. Has overlap, update the toAdd to the merged interval.*/\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n\\t\\t\\t/*3. No overlap and toAdd appears after current interval, add current interval to result.*/\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844494,
                "title": "python-o-n-solution-explained",
                "content": "I am not sure, why this problem is marked as hard, because we do not use any smart ideas to solve it: just do what is asked: traverse our intervals and merge them. Let us consider the case: `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]` and go through our code:\\n\\n1. Interval `[1,2]` is before `[4,8]`, that is `y < I[0]`, so we just add it to our `res`.\\n2. Interval `[3,5]` is not before `[4,8]` but not after also, so it is the third case and we need to update `I`: `I = [3,8]` now.\\n3. Interval `[6,7]`: the same logic, update `I = [3,8]` now (it did not change though)\\n4. Interval `[8,10]`: still condition number `3`, so `I = [3,10]` now.\\n5. Interval `[12,16]`: it is after our `I`, so this is condition number `2` and we `break` from our loop: `i = 3` now.\\n6. Outside loop we combine `res = [1,2]`, `I = [3,10]` and `intervals[4:] = [12,16]`.\\n\\nWhy we use `i -= 1` inside our loop, before `break`? It can happen, that we did not visit this part and it means, that our suffix `intervals[i+1:]` should be empty.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(n)` as well and additional space complexity (if we do not count our output) is `O(1)`.\\n\\n**Note**: that intstead of traversing our intervals with linear search, we can use binary search, however it will not reduce the overall complexity of algorithm, our result will have in average `O(n)` elements.\\n\\n```\\nclass Solution:\\n    def insert(self, intervals, I):\\n        res, i = [], -1\\n        for i, (x, y) in enumerate(intervals):\\n            if y < I[0]:\\n                res.append([x, y])\\n            elif I[1] < x:\\n                i -= 1\\n                break\\n            else:\\n                I[0] = min(I[0], x)\\n                I[1] = max(I[1], y)\\n                \\n        return res + [I] + intervals[i+1:]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, I):\\n        res, i = [], -1\\n        for i, (x, y) in enumerate(intervals):\\n            if y < I[0]:\\n                res.append([x, y])\\n            elif I[1] < x:\\n                i -= 1\\n                break\\n            else:\\n                I[0] = min(I[0], x)\\n                I[1] = max(I[1], y)\\n                \\n        return res + [I] + intervals[i+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844523,
                "title": "c-super-clean-clear-short-simple-solution-o-n-time-o-1-space",
                "content": "the main idea is that when iterating over the intervals there are three cases: \\n1. the new interval is in the range of the other interval\\n2. the new interval\\'s range is before the other\\n3. the new interval is after the range of other interval\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        vector<vector<int>> result;\\n        \\n        for (size_t i = 0; i < intervals.size(); i++)\\n        {\\n\\t\\t\\t//  the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if (intervals[i][1] < newInterval[0])\\n            {\\n                result.push_back(intervals[i]);\\n            }\\n\\t\\t\\t// the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            else if (intervals[i][0] > newInterval[1])\\n            {\\n                result.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\t\\t\\t// the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1])\\n            {\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n\\n            }\\n        }\\n        \\n        result.push_back(newInterval); \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        vector<vector<int>> result;\\n        \\n        for (size_t i = 0; i < intervals.size(); i++)\\n        {\\n\\t\\t\\t//  the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if (intervals[i][1] < newInterval[0])\\n            {\\n                result.push_back(intervals[i]);\\n            }\\n\\t\\t\\t// the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            else if (intervals[i][0] > newInterval[1])\\n            {\\n                result.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\t\\t\\t// the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1])\\n            {\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n\\n            }\\n        }\\n        \\n        result.push_back(newInterval); \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844549,
                "title": "python-super-short-simple-clean-solution-99-faster",
                "content": "the main idea is that when iterating over the intervals there are three cases:\\n\\n1. the new interval is in the range of the other interval\\n2. the new interval\\'s range is before the other\\n3. the new interval is after the range of other interval\\n\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        \\n        for interval in intervals:\\n\\t\\t\\t# the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if interval[1] < newInterval[0]:\\n                result.append(interval)\\n            # the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            elif interval[0] > newInterval[1]:\\n                result.append(newInterval)\\n                newInterval = interval\\n            # the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            elif interval[1] >= newInterval[0] or interval[0] <= newInterval[1]:\\n                newInterval[0] = min(interval[0], newInterval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n\\n        \\n        result.append(newInterval); \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        \\n        for interval in intervals:\\n\\t\\t\\t# the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if interval[1] < newInterval[0]:\\n                result.append(interval)\\n            # the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            elif interval[0] > newInterval[1]:\\n                result.append(newInterval)\\n                newInterval = interval\\n            # the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            elif interval[1] >= newInterval[0] or interval[0] <= newInterval[1]:\\n                newInterval[0] = min(interval[0], newInterval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n\\n        \\n        result.append(newInterval); \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556269,
                "title": "simple-concise-js-solution-w-comments",
                "content": "use ES6 destructuring assignment to make code much more concise and readable.\\n\\n```\\n// O(n), O(n)\\nvar insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t// current interval is smaller than newInterval\\n    if (last < start) left.push(interval);\\n\\t\\n\\t// current interval is larger than newInterval\\n    else if (first > end) right.push(interval);\\n\\t\\n\\t// there is a overlap\\n    else {\\n      start = Math.min(start, first);\\n      end = Math.max(end, last);\\n    }\\n  }\\n  \\n  return [...left, [start, end], ...right]; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n), O(n)\\nvar insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t// current interval is smaller than newInterval\\n    if (last < start) left.push(interval);\\n\\t\\n\\t// current interval is larger than newInterval\\n    else if (first > end) right.push(interval);\\n\\t\\n\\t// there is a overlap\\n    else {\\n      start = Math.min(start, first);\\n      end = Math.max(end, last);\\n    }\\n  }\\n  \\n  return [...left, [start, end], ...right]; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844394,
                "title": "python-js-go-c-o-n-by-boundary-checking-w-comment",
                "content": "Python O( n ) by boundary checking\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        \\n        # Constant to help us access start point and end point of interval\\n        START, END = 0, 1\\n        \\n        s, e = newInterval[START], newInterval[END]\\n        \\n        left, right = [], []\\n        \\n        for cur_interval in intervals:\\n            \\n            if cur_interval[END] < s:\\n                # current interval is on the left-hand side of newInterval\\n                left += [ cur_interval ]\\n                \\n            elif cur_interval[START] > e:\\n                # current interval is on the right-hand side of newInterval\\n                right += [ cur_interval ]\\n                \\n            else:\\n                # current interval has overlap with newInterval\\n                # merge and update boundary\\n                s = min(s, cur_interval[START])\\n                e = max(e, cur_interval[END])\\n                \\n        return left + [ [s, e] ] + right    \\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar insert = function(intervals, newInterval) {\\n    \\n    const [START, END] = [0, 1];\\n    \\n    // start point as well as end point of new interval\\n    let [s, e] = [ newInterval[START], newInterval[END] ];\\n    \\n    // left: \\u3000record of intervals on left hand side\\n    // right:\\u3000record of intervals on right hand side\\n    let [left, right] = [ [], [] ];\\n    \\n    for( let curInterval of intervals){\\n        \\n        if( curInterval[END] < s ){\\n            \\n            // current interval is on the left hand side of newInterval\\n            left.push( curInterval);\\n            \\n        }else if( curInterval[START] > e ){\\n            \\n            // current interval is on the right hand side of newInterval\\n            right.push( curInterval );\\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = Math.min( s, curInterval[START] );\\n            e = Math.max( e, curInterval[END] );\\n            \\n        }\\n        \\n    }\\n    \\n    let result = left.concat( [ [s, e] ]).concat(right);\\n    return result;\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n\\n```\\n// native Go doesn\\'t have built-in interger min/max library function\\n// we have to make it manually\\n\\nfunc max(x, y int) int{\\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int{\\n    if x <= y{\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n// ---------------------------------\\n\\n\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    // Constant to help us access start point and end point of interval\\n    const START, END = 0, 1\\n    \\n    s := newInterval[START]\\n    e := newInterval[END]\\n    \\n    left := make( [][]int, 0)\\n    right := make( [][]int, 0)\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if curInterval[END] < s{\\n            \\n            // current interval is on the left hand side of newInterval\\n            left = append(left, curInterval)\\n            \\n        }else if curInterval[START] > e{\\n            \\n            // current interval is on the right hand side of newInterval\\n            right = append(right, curInterval)\\n            \\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = min( s, curInterval[START] )\\n            e = max( e, curInterval[END] )\\n            \\n        }\\n    }\\n    \\n    result := make( [][]int, 0)\\n    result = append(result, left...)\\n    result = append(result, []int{s, e} )\\n    result = append(result, right...)\\n    \\n    return result\\n    \\n}\\n```\\n\\n---\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        // Constant to help us access start point and end point of interval\\n        const int START=0, END=1;\\n        \\n        int s=newInterval[START], e=newInterval[END];\\n        \\n        vector< vector<int> > left, right;\\n        \\n        for( auto& curInterval : intervals ) {\\n            \\n            if (curInterval[END] < s){\\n                \\n                // current interval is on the left hand side of newInterval\\n                left.push_back( curInterval );\\n                \\n            }else if( curInterval[START] > e ){\\n                \\n                // current interval is on the right hand side of newInterval\\n                right.push_back( curInterval );\\n            \\n            }else{\\n                // current interval has overlap with newInterval\\n                // merge and update boundary\\n                s = min(s, curInterval[START] );\\n                e = max(e, curInterval[END] );\\n            }\\n        }\\n        \\n        result.insert( result.end(), left.begin(), left.end() );\\n        result.push_back( {s, e} );\\n        result.insert( result.end(), right.begin(), right.end() );\\n        \\n        return result;\\n        \\n        \\n    }\\nprivate:\\n    vector< vector<int> > result;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        \\n        # Constant to help us access start point and end point of interval\\n        START, END = 0, 1\\n        \\n        s, e = newInterval[START], newInterval[END]\\n        \\n        left, right = [], []\\n        \\n        for cur_interval in intervals:\\n            \\n            if cur_interval[END] < s:\\n                # current interval is on the left-hand side of newInterval\\n                left += [ cur_interval ]\\n                \\n            elif cur_interval[START] > e:\\n                # current interval is on the right-hand side of newInterval\\n                right += [ cur_interval ]\\n                \\n            else:\\n                # current interval has overlap with newInterval\\n                # merge and update boundary\\n                s = min(s, cur_interval[START])\\n                e = max(e, cur_interval[END])\\n                \\n        return left + [ [s, e] ] + right    \\n```\n```\\nvar insert = function(intervals, newInterval) {\\n    \\n    const [START, END] = [0, 1];\\n    \\n    // start point as well as end point of new interval\\n    let [s, e] = [ newInterval[START], newInterval[END] ];\\n    \\n    // left: \\u3000record of intervals on left hand side\\n    // right:\\u3000record of intervals on right hand side\\n    let [left, right] = [ [], [] ];\\n    \\n    for( let curInterval of intervals){\\n        \\n        if( curInterval[END] < s ){\\n            \\n            // current interval is on the left hand side of newInterval\\n            left.push( curInterval);\\n            \\n        }else if( curInterval[START] > e ){\\n            \\n            // current interval is on the right hand side of newInterval\\n            right.push( curInterval );\\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = Math.min( s, curInterval[START] );\\n            e = Math.max( e, curInterval[END] );\\n            \\n        }\\n        \\n    }\\n    \\n    let result = left.concat( [ [s, e] ]).concat(right);\\n    return result;\\n    \\n};\\n```\n```\\n// native Go doesn\\'t have built-in interger min/max library function\\n// we have to make it manually\\n\\nfunc max(x, y int) int{\\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int{\\n    if x <= y{\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n// ---------------------------------\\n\\n\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    // Constant to help us access start point and end point of interval\\n    const START, END = 0, 1\\n    \\n    s := newInterval[START]\\n    e := newInterval[END]\\n    \\n    left := make( [][]int, 0)\\n    right := make( [][]int, 0)\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if curInterval[END] < s{\\n            \\n            // current interval is on the left hand side of newInterval\\n            left = append(left, curInterval)\\n            \\n        }else if curInterval[START] > e{\\n            \\n            // current interval is on the right hand side of newInterval\\n            right = append(right, curInterval)\\n            \\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = min( s, curInterval[START] )\\n            e = max( e, curInterval[END] )\\n            \\n        }\\n    }\\n    \\n    result := make( [][]int, 0)\\n    result = append(result, left...)\\n    result = append(result, []int{s, e} )\\n    result = append(result, right...)\\n    \\n    return result\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        // Constant to help us access start point and end point of interval\\n        const int START=0, END=1;\\n        \\n        int s=newInterval[START], e=newInterval[END];\\n        \\n        vector< vector<int> > left, right;\\n        \\n        for( auto& curInterval : intervals ) {\\n            \\n            if (curInterval[END] < s){\\n                \\n                // current interval is on the left hand side of newInterval\\n                left.push_back( curInterval );\\n                \\n            }else if( curInterval[START] > e ){\\n                \\n                // current interval is on the right hand side of newInterval\\n                right.push_back( curInterval );\\n            \\n            }else{\\n                // current interval has overlap with newInterval\\n                // merge and update boundary\\n                s = min(s, curInterval[START] );\\n                e = max(e, curInterval[END] );\\n            }\\n        }\\n        \\n        result.insert( result.end(), left.begin(), left.end() );\\n        result.push_back( {s, e} );\\n        result.insert( result.end(), right.begin(), right.end() );\\n        \\n        return result;\\n        \\n        \\n    }\\nprivate:\\n    vector< vector<int> > result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955134,
                "title": "java-solution-with-explanation-and-comments",
                "content": "# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n1. This code defines a class Solution that contains a method insert which takes in two parameters: an array of intervals represented by a 2D array, and a new interval represented by a 1D array. The method returns a new 2D array containing the merged intervals.\\n\\n2. The approach of this code is to add the intervals that come before the new interval to the answer arraylist, then check if the new interval should be merged with the last interval in the answer arraylist, and finally, add the remaining intervals from the input array to the answer arraylist.\\n\\n3. The code first initializes an empty ArrayList called ans. The variable idx is initialized to 0, and the while loop iterates through the input intervals array. The loop compares the starting value of the current interval with the starting value of the new interval, and if the current interval\\'s starting value is less than the new interval\\'s starting value, it is added to the ans arraylist. If the starting value of the current interval is greater than or equal to the new interval\\'s starting value, the loop breaks. This ensures that the intervals in the ans arraylist will be in the same order as they were in the input array, but with the new interval inserted in the correct position.\\n\\n4. Next, the code checks if the ans arraylist is empty or if the new interval\\'s starting value is greater than the last interval\\'s ending value in the ans arraylist. If either of these conditions is true, the new interval is added to the ans arraylist. Otherwise, the last interval in the ans arraylist is merged with the new interval by updating the last interval\\'s ending value to be the maximum of the last interval\\'s ending value and the new interval\\'s ending value.\\n\\n5. Finally, the while loop iterates through the remaining intervals in the input array. The loop compares the ending value of the last interval in the ans arraylist with the starting value of the current interval. If the last interval\\'s ending value is greater than or equal to the current interval\\'s starting value, it means the two intervals overlap and should be merged. The last interval\\'s ending value is updated to be the maximum of the last interval\\'s ending value and the current interval\\'s ending value. If the last interval\\'s ending value is less than the current interval\\'s starting value, it means the two intervals do not overlap and the current interval is added to the ans arraylist.\\n\\n6. After the while loop, the ans arraylist is converted to a 2D array and returned as the final output.\\n```\\n//TC = O(n)\\n//Sc = O(n)\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {   \\n       // Initialize an ArrayList to hold the merged intervals\\n        ArrayList<int[]> ans = new ArrayList<>();\\n        // Initialize a variable to track our position in the input intervals array\\n        int idx = 0;\\n        // Loop through the input intervals\\n        while(idx < intervals.length){\\n            // If the current interval starts before the new interval, add it to the answer list\\n            if(intervals[idx][0] < newInterval[0]){\\n                ans.add(intervals[idx]);\\n                idx++;\\n            // If the current interval starts after or at the same time as the new interval, exit the loop\\n            }else{\\n                break;\\n            }\\n        }\\n        // If the answer list is empty or the last interval in the answer list ends before the new interval starts\\n        // add the new interval to the answer list\\n        if(ans.size() == 0 || (newInterval[0] > ans.get(ans.size()-1)[1])){\\n            ans.add(newInterval);\\n        // If the last interval in the answer list overlaps with the new interval, merge them by updating the end time of the last interval\\n        }else{\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            lastInterval[1] = Math.max(lastInterval[1],newInterval[1]);\\n        }\\n        // Loop through the remaining intervals in the input array\\n        while(idx < intervals.length){\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            // If the last interval in the answer list overlaps with the current interval, merge them by updating the end time of the last interval\\n            if(lastInterval[1] >= intervals[idx][0]){\\n                lastInterval[1] = Math.max(lastInterval[1], intervals[idx][1]);\\n            }else{\\n                // If the last interval does not overlap with the current interval, add it to the answer list\\n                ans.add(intervals[idx]);\\n            }\\n            idx++;\\n        }\\n        // Convert the ArrayList to a 2D int array and return it\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//TC = O(n)\\n//Sc = O(n)\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {   \\n       // Initialize an ArrayList to hold the merged intervals\\n        ArrayList<int[]> ans = new ArrayList<>();\\n        // Initialize a variable to track our position in the input intervals array\\n        int idx = 0;\\n        // Loop through the input intervals\\n        while(idx < intervals.length){\\n            // If the current interval starts before the new interval, add it to the answer list\\n            if(intervals[idx][0] < newInterval[0]){\\n                ans.add(intervals[idx]);\\n                idx++;\\n            // If the current interval starts after or at the same time as the new interval, exit the loop\\n            }else{\\n                break;\\n            }\\n        }\\n        // If the answer list is empty or the last interval in the answer list ends before the new interval starts\\n        // add the new interval to the answer list\\n        if(ans.size() == 0 || (newInterval[0] > ans.get(ans.size()-1)[1])){\\n            ans.add(newInterval);\\n        // If the last interval in the answer list overlaps with the new interval, merge them by updating the end time of the last interval\\n        }else{\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            lastInterval[1] = Math.max(lastInterval[1],newInterval[1]);\\n        }\\n        // Loop through the remaining intervals in the input array\\n        while(idx < intervals.length){\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            // If the last interval in the answer list overlaps with the current interval, merge them by updating the end time of the last interval\\n            if(lastInterval[1] >= intervals[idx][0]){\\n                lastInterval[1] = Math.max(lastInterval[1], intervals[idx][1]);\\n            }else{\\n                // If the last interval does not overlap with the current interval, add it to the answer list\\n                ans.add(intervals[idx]);\\n            }\\n            idx++;\\n        }\\n        // Convert the ArrayList to a 2D int array and return it\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21659,
                "title": "my-binary-search-approach-implementation-2ms",
                "content": "I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval's start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval's end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don't need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you!\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<>();\\n        if (intervals == null || newInterval == null) return result;\\n        int iStart = findStartPos(intervals, newInterval.start);\\n        int iEnd = findEndPos(intervals, newInterval.end);\\n        if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;\\n        if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\\n        \\n        //If not in the corner cases, this condition should apply.\\n        if (iStart <= iEnd) {\\n            newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\\n        }\\n\\n        int i = 0;\\n        while (i < iStart) result.add(intervals.get(i++));\\n        result.add(newInterval);\\n        i = iEnd + 1;\\n        while (i < intervals.size()) result.add(intervals.get(i++));\\n        return result;\\n    }\\n    \\n    private int findStartPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).start == value) return m;\\n            else if (intervals.get(m).start < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int findEndPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).end == value) return m;\\n            else if (intervals.get(m).end < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval's start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval's end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don't need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you!\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<>();\\n        if (intervals == null || newInterval == null) return result;\\n        int iStart = findStartPos(intervals, newInterval.start);\\n        int iEnd = findEndPos(intervals, newInterval.end);\\n        if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;\\n        if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\\n        \\n        //If not in the corner cases, this condition should apply.\\n        if (iStart <= iEnd) {\\n            newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\\n        }\\n\\n        int i = 0;\\n        while (i < iStart) result.add(intervals.get(i++));\\n        result.add(newInterval);\\n        i = iEnd + 1;\\n        while (i < intervals.size()) result.add(intervals.get(i++));\\n        return result;\\n    }\\n    \\n    private int findStartPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).start == value) return m;\\n            else if (intervals.get(m).start < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int findEndPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).end == value) return m;\\n            else if (intervals.get(m).end < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3056665,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=nPwyAn_2nT8&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=16) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QmhQJ3Du/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=nPwyAn_2nT8&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=16) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QmhQJ3Du/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 21753,
                "title": "o-n-python-solution",
                "content": "    class Solution:\\n        # @param intervals, a list of Intervals\\n        # @param newInterval, a Interval\\n        # @return a list of Interval\\n        def insert(self, intervals, newInterval):\\n            start = newInterval.start\\n            end = newInterval.end\\n            result = []\\n            i = 0\\n            while i < len(intervals):\\n                if start <= intervals[i].end:\\n                    if end < intervals[i].start:\\n                        break\\n                    start = min(start, intervals[i].start)\\n                    end = max(end, intervals[i].end)\\n                else:\\n                    result.append(intervals[i])\\n                i += 1\\n            result.append(Interval(start, end))\\n            result += intervals[i:]\\n            return result",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param intervals, a list of Intervals\\n        # @param newInterval, a Interval\\n        # @return a list of Interval\\n        def insert(self, intervals, newInterval):\\n            start = newInterval.start\\n            end = newInterval.end\\n            result = []\\n            i = 0\\n            while i < len(intervals):\\n                if start <= intervals[i].end:\\n                    if end < intervals[i].start:\\n                        break\\n                    start = min(start, intervals[i].start)\\n                    end = max(end, intervals[i].end)\\n                else:\\n                    result.append(intervals[i])\\n                i += 1\\n            result.append(Interval(start, end))\\n            result += intervals[i:]\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 3056559,
                "title": "super-easy-explanation-c-o-n-simple-solution",
                "content": "# **Consider \\uD83D\\uDC4D**\\n```\\n                    Please Upvote If You Find It Helpful.\\n```\\n# Approach\\nThere are 3 cases:\\n1. **Non overlapping intervals before given new interval** push into the res vector.\\n2. In this case check for **overlapping intervals and new interval** and merge then as\\n    Starting point if new interval will be minimun of starting point of intervals or new interval(given)\\n    Ending point of new interval will be the max of ending point of interval or new interval(given)\\n3. **Non overlapping intervals after the new interval** is merged is pushed into the res vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```\\n                                 Give a \\uD83D\\uDC4D\\n```\\nLet\\'s connect on [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n```\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n                                 Give a \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056954,
                "title": "c-java-python-short-crisp-approach",
                "content": "**Approach:**\\n* The approach used is to `first` iterate through the given intervals, and keeping track of the index of the interval where the new `interval` should be inserted such that the intervals remain `sorted`. Then it will `merge` any overlapping intervals with the new interval and update its `start` and `end` times. `Finally`, it will insert the new interval into the correct position in the intervals and `return` the modified intervals.\\n* The `key` idea behind this approach is to maintain the `sorted` order of the intervals, and to `merge` any overlapping intervals with the new interval. \\n* By iterating through the intervals and keeping track of the index where the new interval should be `inserted`, we can ensure that the intervals `remain` sorted, and by merging any `overlapping` intervals with the new interval, we can ensure that the final `output` has no `overlapping` intervals.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> res;\\n        int i = 0, n = intervals.size();\\n        while (i < n && intervals[i][1] < newInterval[0]) res.push_back(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = {min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])}, i++;\\n        res.push_back(newInterval);\\n        while (i < n) res.push_back(intervals[i++]);\\n        return res;\\n    }\\n};\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, n = intervals.length;\\n        while (i < n && intervals[i][1] < newInterval[0]) res.add(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = new int[] {Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])}, i++;\\n        res.add(newInterval);\\n        while (i < n) res.add(intervals[i++]);\\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}\\n```\\n**Python:**\\n\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        res.append(newInterval)\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n        return res\\n```\\n\\n----\\nThe **Time complexity** is **O(n)** \\nThe **Space complexity** is **O(n)** .\\n\\n----\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> res;\\n        int i = 0, n = intervals.size();\\n        while (i < n && intervals[i][1] < newInterval[0]) res.push_back(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = {min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])}, i++;\\n        res.push_back(newInterval);\\n        while (i < n) res.push_back(intervals[i++]);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, n = intervals.length;\\n        while (i < n && intervals[i][1] < newInterval[0]) res.add(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = new int[] {Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])}, i++;\\n        res.add(newInterval);\\n        while (i < n) res.add(intervals[i++]);\\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        res.append(newInterval)\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21632,
                "title": "very-short-and-easy-to-understand-c-solution",
                "content": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        vector<Interval> ret;\\n        auto it = intervals.begin();\\n        for(; it!=intervals.end(); ++it){\\n\\t\\t\\tif(newInterval.end < (*it).start) //all intervals after will not overlap with the newInterval\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\telse if(newInterval.start > (*it).end) //*it will not overlap with the newInterval\\n\\t\\t\\t\\tret.push_back(*it); \\n            else{ //update newInterval bacause *it overlap with the newInterval\\n                newInterval.start = min(newInterval.start, (*it).start);\\n                newInterval.end = max(newInterval.end, (*it).end);\\n            }\\t\\n        }\\n        // don't forget the rest of the intervals and the newInterval\\n\\t\\tret.push_back(newInterval);\\n\\t\\tfor(; it!=intervals.end(); ++it)\\n\\t\\t\\tret.push_back(*it);\\n\\t\\treturn ret;\\n    }\\nMy question is why this code need 500ms !?",
                "solutionTags": [],
                "code": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        vector<Interval> ret;\\n        auto it = intervals.begin();\\n        for(; it!=intervals.end(); ++it){\\n\\t\\t\\tif(newInterval.end < (*it).start) //all intervals after will not overlap with the newInterval\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\telse if(newInterval.start > (*it).end) //*it will not overlap with the newInterval\\n\\t\\t\\t\\tret.push_back(*it); \\n            else{ //update newInterval bacause *it overlap with the newInterval\\n                newInterval.start = min(newInterval.start, (*it).start);\\n                newInterval.end = max(newInterval.end, (*it).end);\\n            }\\t\\n        }\\n        // don't forget the rest of the intervals and the newInterval\\n\\t\\tret.push_back(newInterval);\\n\\t\\tfor(; it!=intervals.end(); ++it)\\n\\t\\t\\tret.push_back(*it);\\n\\t\\treturn ret;\\n    }\\nMy question is why this code need 500ms !?",
                "codeTag": "Unknown"
            },
            {
                "id": 21815,
                "title": "two-easy-o-n-c-solutions-with-explanations",
                "content": "By far the best solution I have seen is of `O(n)` time (some solutions claim to be of `O(logn)` turns out to be `O(n)`). One of the simplest ideas is to compare each interval in `intervals` (`intervals[i]`) with `newInterval` and then perform respective operations according to their relationships.\\n\\n 1. If they overlap, merge them to `newInterval`;\\n 2. If `intervals[i]` is to the left of `newInterval`, push `intervals[i]` to the result vector;\\n 3. If `newInterval` is to the left of `intervals[i]`, push `newInterval` and all the remaining intervals (`intervals[i]`, ..., `intervals[n - 1]`) to the result vector.\\n\\nThe code is as follows. \\n\\n    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            vector<Interval> res;\\n            int n = intervals.size();\\n            for (int i = 0; i < n; i++) {\\n                if (intervals[i].end < newInterval.start)\\n                    res.push_back(intervals[i]);\\n                else if (newInterval.end < intervals[i].start) {\\n                    res.push_back(newInterval);\\n                    for (int j = i; j < n; j++)\\n                        res.push_back(intervals[j]);\\n                    return res; \\n                }\\n                else newInterval = merge(intervals[i], newInterval);\\n            }\\n            res.push_back(newInterval);\\n            return res;\\n        }\\n    private:\\n        Interval merge(Interval& interval1, Interval& interval2) {\\n            int start = min(interval1.start, interval2.start);\\n            int end = max(interval1.end, interval2.end);\\n            return Interval(start, end);\\n        }\\n    };\\n\\nAnother idea is to search for the two ends of the overlapping intervals using binary search. Then we only need to merge `newInterval` with the intervals at the two ends if they overlap. All the intervals within the two ends will be contained in` newInterval`.\\n\\nLet's do the example in the problem statement: `intervals = [1, 2], [3, 5], [6, 7], [8, 10], [12, 16]` and `newInterval = [4, 9]`. We first find the rightmost interval with `start` smaller than that of `newInterval`, which is `[3, 5]`. Then we find the leftmost interval with `end` larger than that of `newInterval`, which is `[8, 10]`. Then all the intervals between them will be contained within `newInterval` (you may check this to convince yourself) and so can be safely ignored. We only need to check whether `newInterval` overlaps with the two intervals on the two ends and merge them if necessary.\\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            int n = intervals.size(), leftEnd, rightEnd, l, r;\\n            vector<Interval> res;\\n            // Find the rightmost interval with start smaller than that of newInterval\\n            for (l = 0, r = n - 1; l <= r; ) {\\n                int mid = l + ((r - l) >> 1);\\n                if (intervals[mid].start > newInterval.start)\\n                    r = mid - 1;\\n                else l = mid + 1;\\n            } \\n            leftEnd = r;\\n            // Find the leftmost interval with end larger than that of newInterval\\n            for (l = 0, r = n - 1; l <= r; ) {\\n                int mid = l + ((r - l) >> 1);\\n                if (intervals[mid].end < newInterval.end)\\n                    l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            rightEnd = l;\\n            // Merge newInterval with intervals[leftEnd] and intervals[rightEnd] if necessary\\n            if (leftEnd >= 0 && intervals[leftEnd].end >= newInterval.start)\\n                newInterval.start = intervals[leftEnd--].start;\\n            if (rightEnd < n && intervals[rightEnd].start <= newInterval.end)\\n                newInterval.end = intervals[rightEnd++].end;\\n            // Save the intervals sequentially\\n            for (int i = 0; i <= leftEnd; i++)\\n                res.push_back(intervals[i]);\\n            res.push_back(newInterval);\\n            for (int i = rightEnd; i < n; i++)\\n                res.push_back(intervals[i]);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            vector<Interval> res;\\n            int n = intervals.size();\\n            for (int i = 0; i < n; i++) {\\n                if (intervals[i].end < newInterval.start)\\n                    res.push_back(intervals[i]);\\n                else if (newInterval.end < intervals[i].start) {\\n                    res.push_back(newInterval);\\n                    for (int j = i; j < n; j++)\\n                        res.push_back(intervals[j]);\\n                    return res; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3056524,
                "title": "python3-merge-interval-solution-explained-space-complexity-o-n-o-1",
                "content": "**Intuition**\\n\\nThis problem is almost the same as [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/) if we first insert ```newInterval``` into ```intervals``` such that ```intervals``` is still sorted by the start time, and then merge overlapped intervals.\\n\\n - use binary search to find the index where ```newInterval``` should be instered into ```intervals```. O(logN)\\n - Insert the ```newInterval```. O(N)\\n - merge overlapped intervals if there are any.\\n    - We can interately build a stack, and merge a new interval with the last interval in the stack if they overlap.\\n    - To check if a new interval is overlap with the last interval in stack, we simply check if the last end is greater than or equal to the new start. If it is, we merge the two intervals by using the last start as the start, and the max(lastEnd, newEnd) as the end.\\n    - If there is no overlap between the new interval and the last interval in stack, we simply add the new interval to the stack.\\n\\n**Solution 1** using stack\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        stack = []\\n        for s,e in intervals:\\n            if stack and stack[-1][1] >= s:\\n                lastS,lastE = stack.pop()\\n                stack.append([lastS, max(lastE,e)])\\n            else:\\n                stack.append([s,e])\\n        return stack\\n```\\n\\nWe don\\'t really need to use a stack, but using the list slicing in Python to merge the overlapped intervals.\\n\\n**Solution 2** inplace merge\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        i = 0\\n        while i<len(intervals):\\n            s,e = intervals[i]\\n            if i>0 and intervals[i-1][1] >= s:\\n                lastS,lastE = intervals[i-1]\\n                intervals[i-1:i+1] = [[lastS, max(lastE,e)]]\\n            else:\\n                i += 1\\n        return intervals\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n",
                "solutionTags": [],
                "code": "```newInterval```\n```intervals```\n```intervals```\n```newInterval```\n```intervals```\n```newInterval```\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        stack = []\\n        for s,e in intervals:\\n            if stack and stack[-1][1] >= s:\\n                lastS,lastE = stack.pop()\\n                stack.append([lastS, max(lastE,e)])\\n            else:\\n                stack.append([s,e])\\n        return stack\\n```\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        i = 0\\n        while i<len(intervals):\\n            s,e = intervals[i]\\n            if i>0 and intervals[i-1][1] >= s:\\n                lastS,lastE = intervals[i-1]\\n                intervals[i-1:i+1] = [[lastS, max(lastE,e)]]\\n            else:\\n                i += 1\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902628,
                "title": "c-optimized-solution-9-lines-beats-95-time",
                "content": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        \\n        while(i < n && intervals[i][1] < newInterval[0])    res.push_back(intervals[i++]);\\n\\t\\t\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        while(i < n)    res.push_back(intervals[i++]);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        \\n        while(i < n && intervals[i][1] < newInterval[0])    res.push_back(intervals[i++]);\\n\\t\\t\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        while(i < n)    res.push_back(intervals[i++]);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342029,
                "title": "javascript-solution-beats-99-79",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let size = intervals.length;\\n    let index = 0;\\n    let res = [];\\n    \\n    while(index < size && intervals[index][1] < newInterval[0]) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    while(index < size && intervals[index][0] <= newInterval[1]) {\\n        newInterval[0] = Math.min(newInterval[0], intervals[index][0]);\\n        newInterval[1] = Math.max(newInterval[1], intervals[index][1]);\\n        index++;\\n    }\\n    res.push(newInterval);\\n    while(index < size) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let size = intervals.length;\\n    let index = 0;\\n    let res = [];\\n    \\n    while(index < size && intervals[index][1] < newInterval[0]) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    while(index < size && intervals[index][0] <= newInterval[1]) {\\n        newInterval[0] = Math.min(newInterval[0], intervals[index][0]);\\n        newInterval[1] = Math.max(newInterval[1], intervals[index][1]);\\n        index++;\\n    }\\n    res.push(newInterval);\\n    while(index < size) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313612,
                "title": "python3-faster-than-99-58-36ms-14-9mb",
                "content": "Python3 - Faster than 99.58% - 36ms & 14.9MB\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda x: x[0])\\n        \\n        result = []\\n        for interval in intervals:\\n            if not result or result[-1][1] < interval[0]:\\n                result.append(interval)\\n            else:\\n                result[-1][1] = max(result[-1][1],interval[1])\\n                \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda x: x[0])\\n        \\n        result = []\\n        for interval in intervals:\\n            if not result or result[-1][1] < interval[0]:\\n                result.append(interval)\\n            else:\\n                result[-1][1] = max(result[-1][1],interval[1])\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298982,
                "title": "javascript-solution-95-fast",
                "content": "```\\nvar insert = function (intervals, newInterval) {\\n    if (intervals.length === 0) {\\n        return [ newInterval ];\\n    }\\n\\n    const result = [];\\n    let flag = 0;\\n    let i;\\n\\n    for (i = 0; i < intervals.length; i++) {\\n        const interval = intervals[i];\\n        if (newInterval[0] > interval[1]){\\n            result.push(interval);\\n        } else if (newInterval[1] < interval[0]){\\n            result.push(newInterval);\\n            flag = 1;\\n            break;\\n        } else {\\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\\n        }\\n    }\\n\\n    if (flag === 0) {\\n        result.push(newInterval);\\n        return result;\\n    } else {\\n        return result.concat(intervals.splice(i));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function (intervals, newInterval) {\\n    if (intervals.length === 0) {\\n        return [ newInterval ];\\n    }\\n\\n    const result = [];\\n    let flag = 0;\\n    let i;\\n\\n    for (i = 0; i < intervals.length; i++) {\\n        const interval = intervals[i];\\n        if (newInterval[0] > interval[1]){\\n            result.push(interval);\\n        } else if (newInterval[1] < interval[0]){\\n            result.push(newInterval);\\n            flag = 1;\\n            break;\\n        } else {\\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\\n        }\\n    }\\n\\n    if (flag === 0) {\\n        result.push(newInterval);\\n        return result;\\n    } else {\\n        return result.concat(intervals.splice(i));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845073,
                "title": "python-3-sweep-line-heap-explanations",
                "content": "### Explanation\\n- Typical `Sweep Line` question, use `heap` for help\\n- Mark every start as `-1`, every end as `1`\\n- Sort all start & end points\\n- Close interval only when counter `cur` equals to `0`\\n- Check out below comments for more detail\\n### Implementation\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        heap, ans, = [], [] \\n        for s, e in intervals + [newInterval]: # add start & end to heap (-1 is start, 1 is end)\\n            heapq.heappush(heap, (s, -1))\\n            heapq.heappush(heap, (e, 1))\\n        cur, s = 0, None            \\n        while heap:                            \\n            i, val = heapq.heappop(heap)       # pop heap\\n            if s is None: s = i                # is s is None, assign i to s (interval start)\\n            cur += val                         # keep counting until close interval\\n            if not cur:                        # when cur == 0, meaning we can close the interval\\n                ans.append([s, i])             # append interval to ans\\n                s = None                       # reset s to None\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        heap, ans, = [], [] \\n        for s, e in intervals + [newInterval]: # add start & end to heap (-1 is start, 1 is end)\\n            heapq.heappush(heap, (s, -1))\\n            heapq.heappush(heap, (e, 1))\\n        cur, s = 0, None            \\n        while heap:                            \\n            i, val = heapq.heappop(heap)       # pop heap\\n            if s is None: s = i                # is s is None, assign i to s (interval start)\\n            cur += val                         # keep counting until close interval\\n            if not cur:                        # when cur == 0, meaning we can close the interval\\n                ans.append([s, i])             # append interval to ans\\n                s = None                       # reset s to None\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 844719,
                "title": "golang-idiomatic-solution",
                "content": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    res := make([][]int, 0)\\n    \\n    i := 0\\n    \\n    for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {\\n        res = append(res, intervals[i])\\n    }\\n    \\n    for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {\\n        newInterval[0] = min(intervals[i][0], newInterval[0])\\n        newInterval[1] = max(intervals[i][1], newInterval[1])\\n    }\\n    \\n    res = append(res, newInterval)\\n    \\n    for i < len(intervals) {\\n        res = append(res, intervals[i])\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    res := make([][]int, 0)\\n    \\n    i := 0\\n    \\n    for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {\\n        res = append(res, intervals[i])\\n    }\\n    \\n    for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {\\n        newInterval[0] = min(intervals[i][0], newInterval[0])\\n        newInterval[1] = max(intervals[i][1], newInterval[1])\\n    }\\n    \\n    res = append(res, newInterval)\\n    \\n    for i < len(intervals) {\\n        res = append(res, intervals[i])\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2429511,
                "title": "java-explained-solution",
                "content": "```\\n/*\\nInterval will not be overlapped\\ncase 1 : when interval[end] < newInterval[start],ex-newInterval = [4,8], interval = [1,2]\\ncase 2 : when interval[start] > newInterval[end],ex-newInterval = [4,8], interval = [12,16]\\ncase 3 : when new interval is already added in output list\\n\\nremaining all cases they will be overlapped\\n*/\\n\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> res = new ArrayList<>();\\n        for(int[] interval: intervals){\\n            // case3 and case1\\n            if(newInterval==null || interval[1]<newInterval[0]){\\n                res.add(interval);\\n            }else if(interval[0]>newInterval[1]){ // case 2\\n                res.add(newInterval);\\n                res.add(interval);\\n                newInterval = null;\\n            }else{ // overlapping\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        if(newInterval!=null) res.add(newInterval);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nInterval will not be overlapped\\ncase 1 : when interval[end] < newInterval[start],ex-newInterval = [4,8], interval = [1,2]\\ncase 2 : when interval[start] > newInterval[end],ex-newInterval = [4,8], interval = [12,16]\\ncase 3 : when new interval is already added in output list\\n\\nremaining all cases they will be overlapped\\n*/\\n\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> res = new ArrayList<>();\\n        for(int[] interval: intervals){\\n            // case3 and case1\\n            if(newInterval==null || interval[1]<newInterval[0]){\\n                res.add(interval);\\n            }else if(interval[0]>newInterval[1]){ // case 2\\n                res.add(newInterval);\\n                res.add(interval);\\n                newInterval = null;\\n            }else{ // overlapping\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        if(newInterval!=null) res.add(newInterval);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388642,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\\n        var res = new List<int[]>();\\n        \\n        foreach (var interval in intervals)\\n        {\\n            if (interval[0] > newInterval[1])\\n            {\\n                res.Add(newInterval);\\n                newInterval = interval;\\n            }\\n            else if (interval[1] < newInterval[0])\\n            {\\n                res.Add(interval);\\n            }\\n            else\\n            {\\n                newInterval[0] = Math.Min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.Max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        res.Add(newInterval);\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\\n        var res = new List<int[]>();\\n        \\n        foreach (var interval in intervals)\\n        {\\n            if (interval[0] > newInterval[1])\\n            {\\n                res.Add(newInterval);\\n                newInterval = interval;\\n            }\\n            else if (interval[1] < newInterval[0])\\n            {\\n                res.Add(interval);\\n            }\\n            else\\n            {\\n                newInterval[0] = Math.Min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.Max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        res.Add(newInterval);\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464497,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "Ported to C# from [Java solution](https://leetcode.com/problems/insert-interval/discuss/463417/My-concise-Java-solution-(single-pass-O(n)-3-steps))\\n\\n```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int i = 0;\\n\\n        // Step 1 - add all intervals ending before newInterval starts\\n        while (i < intervals.Length && intervals[i][1] < newInterval[0])\\n            result.Add(intervals[i++]);\\n\\n        // Step 2 - update the newInterval by merging with all overlapping intervals\\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1])\\n        {\\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        result.Add(newInterval); // add updated interval\\n\\n        // Step 3 - add remaining intervals\\n        while (i < intervals.Length)\\n            result.Add(intervals[i++]);\\n        \\n        return result.ToArray();\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int i = 0;\\n\\n        // Step 1 - add all intervals ending before newInterval starts\\n        while (i < intervals.Length && intervals[i][1] < newInterval[0])\\n            result.Add(intervals[i++]);\\n\\n        // Step 2 - update the newInterval by merging with all overlapping intervals\\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1])\\n        {\\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        result.Add(newInterval); // add updated interval\\n\\n        // Step 3 - add remaining intervals\\n        while (i < intervals.Length)\\n            result.Add(intervals[i++]);\\n        \\n        return result.ToArray();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250459,
                "title": "very-simple-javascript-o-n-solution",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    const result = [];\\n    \\n    for (let i = 0; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n        \\n        // If overlaps\\n        if (Math.max(interval[0], newInterval[0]) <= Math.min(interval[1], newInterval[1])) {\\n            newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])];\\n            continue;\\n        }\\n        \\n        // If lower\\n        if (interval[0] > newInterval[1]) {\\n            result.push(newInterval, ...intervals.slice(i));\\n            return result;\\n        }\\n        \\n        result.push(interval);\\n    }\\n    \\n    result.push(newInterval);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    const result = [];\\n    \\n    for (let i = 0; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n        \\n        // If overlaps\\n        if (Math.max(interval[0], newInterval[0]) <= Math.min(interval[1], newInterval[1])) {\\n            newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])];\\n            continue;\\n        }\\n        \\n        // If lower\\n        if (interval[0] > newInterval[1]) {\\n            result.push(newInterval, ...intervals.slice(i));\\n            return result;\\n        }\\n        \\n        result.push(interval);\\n    }\\n    \\n    result.push(newInterval);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1221925,
                "title": "java-solution-with-comments-o-n",
                "content": "The approach is to:\\n1. Skip all the intervals that end before the newInterval starts because they would not overlap anyway. So we add them to the final result.\\n2. For those intervals that overlap with the newInterval, we will merge them before inserting into the final result list. We say that an interval b overlaps with a is b.start <= a.end.\\n3. At the end, we will add the remaining intervals from the original array that do not overlap with the newInterval.\\n\\nWe will use a List since we do not know the size of our merged intervals beforehand and then we will convert the list to the required 2-dimensional array\\n\\n```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length; // length of intervals\\n        if (intervals == null || n == 0) {\\n            return new int[][] { newInterval };\\n        }\\n        \\n        // result list to be converted to int[] at the end\\n        List<int[]> result = new ArrayList<>();\\n        \\n        // skip the intervals that end before new interval\\n        int i = 0;\\n        \\n        while (i < n && intervals[i][1] < newInterval[0]) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        \\n        // merge all intervals that overlap with newInterval\\n        while (i < n && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n        // add the newly merged interval\\n        result.add(newInterval);\\n        \\n        // add all the remaining intervals to result\\n        while (i < n) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n\\n\\t\\t// convert to a 2d array\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "The approach is to:\\n1. Skip all the intervals that end before the newInterval starts because they would not overlap anyway. So we add them to the final result.\\n2. For those intervals that overlap with the newInterval, we will merge them before inserting into the final result list. We say that an interval b overlaps with a is b.start <= a.end.\\n3. At the end, we will add the remaining intervals from the original array that do not overlap with the newInterval.\\n\\nWe will use a List since we do not know the size of our merged intervals beforehand and then we will convert the list to the required 2-dimensional array\\n\\n```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length; // length of intervals\\n        if (intervals == null || n == 0) {\\n            return new int[][] { newInterval };\\n        }\\n        \\n        // result list to be converted to int[] at the end\\n        List<int[]> result = new ArrayList<>();\\n        \\n        // skip the intervals that end before new interval\\n        int i = 0;\\n        \\n        while (i < n && intervals[i][1] < newInterval[0]) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        \\n        // merge all intervals that overlap with newInterval\\n        while (i < n && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n        // add the newly merged interval\\n        result.add(newInterval);\\n        \\n        // add all the remaining intervals to result\\n        while (i < n) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n\\n\\t\\t// convert to a 2d array\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 685007,
                "title": "python-very-simple-solution-based-on-merge-intervals",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## Similar to Leetcode 56. Merge Intervals ##\\n\\t\\t## LOGIC ##\\n\\t\\t## 1. As per the problem statement, the intervals are initially sorted, so we donot need to sort them, we can just insert the new interval in the right position and apply the merge intervals algorithm. ##\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        i = 0\\n        while( i<len(intervals) and intervals[i][0] < newInterval[0]):\\n            i+= 1\\n        \\n        intervals.insert(i,newInterval)\\n        \\n        ans = []\\n        for interval in intervals:\\n            if len(ans) == 0 or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## Similar to Leetcode 56. Merge Intervals ##\\n\\t\\t## LOGIC ##\\n\\t\\t## 1. As per the problem statement, the intervals are initially sorted, so we donot need to sort them, we can just insert the new interval in the right position and apply the merge intervals algorithm. ##\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        i = 0\\n        while( i<len(intervals) and intervals[i][0] < newInterval[0]):\\n            i+= 1\\n        \\n        intervals.insert(i,newInterval)\\n        \\n        ans = []\\n        for interval in intervals:\\n            if len(ans) == 0 or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056535,
                "title": "python3-79-ms-faster-than-93-12-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        for i in range(len(intervals)):\\n            if newInterval[1] < intervals[i][0]:\\n                result.append(newInterval)\\n                return result + intervals[i:]\\n            elif newInterval[0] > intervals[i][1]:\\n                result.append(intervals[i])\\n            else:\\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\\n        result.append(newInterval)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        for i in range(len(intervals)):\\n            if newInterval[1] < intervals[i][0]:\\n                result.append(newInterval)\\n                return result + intervals[i:]\\n            elif newInterval[0] > intervals[i][1]:\\n                result.append(intervals[i])\\n            else:\\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\\n        result.append(newInterval)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1430986,
                "title": "binary-search-solution",
                "content": "First looking where to insert elements from new interval using binary search (to left of the interval or into the interval itself) - O(log N). Second composing two lists left and right to the new interval. Third merging if start or end falls in between of any interval. Overall worst case still O(N) but binary search helps in cases like new interval consumes all intervals.\\n\\n**Python**\\n```\\n    def bsearch(intervals: List[List[int]], x: int) -> int:\\n        lo, hi = 0, len(intervals)\\n        mid = 0\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if intervals[mid][0] > x:\\n                hi = mid\\n            elif intervals[mid][1] < x:\\n                lo = mid + 1\\n            else:\\n                break\\n        return mid\\n \\n    def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        li, ri = bsearch(intervals, s), bsearch(intervals, e)\\n        l = intervals[:li + int(li < len(intervals) and intervals[li][1] < s)]\\n        r = intervals[ri + int(ri >= len(intervals) or intervals[ri][0] <= e):]\\n        if len(l) + len(r) != len(intervals):\\n            s = min(s, intervals[len(l)][0])\\n            e = max(e, intervals[-len(r)-1][1])\\n        return l + [[s, e]] + r\\n```\\n\\n**Javascript**\\n```\\nconst bsearch = (intervals, x) => {\\n    let mid = 0;\\n    let lo = 0;\\n    let hi = intervals.length;\\n    while (lo < hi) {\\n        mid = (lo + hi - Number((lo + hi) % 2 !== 0)) / 2;\\n        if (intervals[mid][0] > x)\\n            hi = mid;\\n        else if (intervals[mid][1] < x)\\n            lo = mid + 1\\n        else\\n            break;\\n    }\\n    return mid;\\n}\\n\\nconst insert = (intervals, newInterval) => {\\n    let [s, e] = newInterval;\\n    const li = bsearch(intervals, newInterval[0]);\\n    const ri = bsearch(intervals, newInterval[1]);\\n    const l = intervals.slice(0, li + Number(li < intervals.length && intervals[li][1] < s));\\n    const r = intervals.slice(ri + Number(ri >= intervals.length || intervals[ri][0] <= e))\\n    if (l.length + r.length !== intervals.length) {\\n        s = Math.min(s, intervals[l.length][0]);\\n        e = Math.max(e, intervals[intervals.length - r.length - 1][1]);\\n    }\\n    return [...l, [s, e], ...r];\\n};\\n```\\n\\n**Rust**\\n```\\n    use std::cmp::Ordering;\\n    fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        let (mut s, mut e) = (new_interval[0], new_interval[1]);\\n        let pred = |x| {\\n            move |i: &Vec<i32>| {\\n                if i[0] > x {\\n                    Ordering::Greater\\n                } else if i[1] < x {\\n                    Ordering::Less\\n                } else {\\n                    Ordering::Equal\\n                }\\n            }\\n        };\\n        let li = intervals.binary_search_by(pred(s)).unwrap_or_else(|x| x);\\n        let ri = intervals.binary_search_by(pred(e)).unwrap_or_else(|x| x);\\n        let l = &intervals[..(li + usize::from(li < intervals.len() && intervals[li][1] < s))];\\n        let r = &intervals[(ri + usize::from(ri >= intervals.len() || intervals[ri][0] <= e)).min(intervals.len())..];\\n        if l.len() + r.len() != intervals.len() {\\n            s = s.min(intervals[l.len()][0]);\\n            e = e.max(intervals[intervals.len() - r.len() - 1][1]);\\n        }\\n        vec![l, &vec![vec![s, e]], r].concat()\\n    }\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\n    def bsearch(intervals: List[List[int]], x: int) -> int:\\n        lo, hi = 0, len(intervals)\\n        mid = 0\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if intervals[mid][0] > x:\\n                hi = mid\\n            elif intervals[mid][1] < x:\\n                lo = mid + 1\\n            else:\\n                break\\n        return mid\\n \\n    def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        li, ri = bsearch(intervals, s), bsearch(intervals, e)\\n        l = intervals[:li + int(li < len(intervals) and intervals[li][1] < s)]\\n        r = intervals[ri + int(ri >= len(intervals) or intervals[ri][0] <= e):]\\n        if len(l) + len(r) != len(intervals):\\n            s = min(s, intervals[len(l)][0])\\n            e = max(e, intervals[-len(r)-1][1])\\n        return l + [[s, e]] + r\\n```\n```\\nconst bsearch = (intervals, x) => {\\n    let mid = 0;\\n    let lo = 0;\\n    let hi = intervals.length;\\n    while (lo < hi) {\\n        mid = (lo + hi - Number((lo + hi) % 2 !== 0)) / 2;\\n        if (intervals[mid][0] > x)\\n            hi = mid;\\n        else if (intervals[mid][1] < x)\\n            lo = mid + 1\\n        else\\n            break;\\n    }\\n    return mid;\\n}\\n\\nconst insert = (intervals, newInterval) => {\\n    let [s, e] = newInterval;\\n    const li = bsearch(intervals, newInterval[0]);\\n    const ri = bsearch(intervals, newInterval[1]);\\n    const l = intervals.slice(0, li + Number(li < intervals.length && intervals[li][1] < s));\\n    const r = intervals.slice(ri + Number(ri >= intervals.length || intervals[ri][0] <= e))\\n    if (l.length + r.length !== intervals.length) {\\n        s = Math.min(s, intervals[l.length][0]);\\n        e = Math.max(e, intervals[intervals.length - r.length - 1][1]);\\n    }\\n    return [...l, [s, e], ...r];\\n};\\n```\n```\\n    use std::cmp::Ordering;\\n    fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        let (mut s, mut e) = (new_interval[0], new_interval[1]);\\n        let pred = |x| {\\n            move |i: &Vec<i32>| {\\n                if i[0] > x {\\n                    Ordering::Greater\\n                } else if i[1] < x {\\n                    Ordering::Less\\n                } else {\\n                    Ordering::Equal\\n                }\\n            }\\n        };\\n        let li = intervals.binary_search_by(pred(s)).unwrap_or_else(|x| x);\\n        let ri = intervals.binary_search_by(pred(e)).unwrap_or_else(|x| x);\\n        let l = &intervals[..(li + usize::from(li < intervals.len() && intervals[li][1] < s))];\\n        let r = &intervals[(ri + usize::from(ri >= intervals.len() || intervals[ri][0] <= e)).min(intervals.len())..];\\n        if l.len() + r.len() != intervals.len() {\\n            s = s.min(intervals[l.len()][0]);\\n            e = e.max(intervals[intervals.len() - r.len() - 1][1]);\\n        }\\n        vec![l, &vec![vec![s, e]], r].concat()\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463417,
                "title": "my-concise-java-solution-single-pass-o-n-3-steps-with-explanation",
                "content": "The idea is simple. Since the intervals are already sorted by start time, all we need is one pass from left to right. \\n**3 steps:**\\n1. Add any intervals that finish before the new interval starts.\\n2. Update the new interval by merging it will all overlapping intervals. Add the updated newInterval to result.\\n3. Add remaining intervals to result, and voila!\\n\\nHere\\'s the code\\n```\\npublic int[][] insert(int[][] intervals, int[] newInterval) {       \\n\\tList<int[]> result = new ArrayList<>();        \\n\\tint i=0;\\n\\n\\t// Step 1 - add all intervals ending before newInterval starts\\n\\twhile (i<intervals.length && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\\n\\n\\t// Step 2 - update the newInterval by merging with all overlapping intervals\\n\\twhile (i<intervals.length && intervals[i][0] <= newInterval[1]) {\\n\\t\\tnewInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n\\t\\tnewInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n\\t\\ti++;\\n\\t}\\n\\tresult.add(newInterval); // add updated interval\\n\\n\\t// Step 3 - add remaining intervals\\n\\twhile (i<intervals.length) result.add(intervals[i++]);\\n\\treturn result.toArray(new int[0][2]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] insert(int[][] intervals, int[] newInterval) {       \\n\\tList<int[]> result = new ArrayList<>();        \\n\\tint i=0;\\n\\n\\t// Step 1 - add all intervals ending before newInterval starts\\n\\twhile (i<intervals.length && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\\n\\n\\t// Step 2 - update the newInterval by merging with all overlapping intervals\\n\\twhile (i<intervals.length && intervals[i][0] <= newInterval[1]) {\\n\\t\\tnewInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n\\t\\tnewInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n\\t\\ti++;\\n\\t}\\n\\tresult.add(newInterval); // add updated interval\\n\\n\\t// Step 3 - add remaining intervals\\n\\twhile (i<intervals.length) result.add(intervals[i++]);\\n\\treturn result.toArray(new int[0][2]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056859,
                "title": "c-easy-intutive-solution-in-o-nlogn-time-complexity",
                "content": "# Intuition\\nIt is similar to the question [Merge Intervals](https://leetcode.com/problems/merge-intervals/) must try before doing this problem.\\n\\n# Approach\\nInsert the new interval in and then the question becomes same as merge intervals.\\n\\n# Complexity\\n- Time complexity:O(NLogN)\\n\\n- Space complexity:O(2*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval});\\n        sort(intervals.begin() , intervals.end());\\n        int j = 0 , n = intervals.size();\\n        for(int i = 1 ; i < n ; i++){\\n            if(intervals[j][1] >= intervals[i][0]){\\n                intervals[j][1] = max(intervals[j][1] , intervals[i][1]);\\n            }\\n            else{\\n                j++;\\n                intervals[j] = intervals[i];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(int i = 0 ; i <= j ; i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*I just did this solution for doing it some other way and i know there exist a O(N) solution too*\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval});\\n        sort(intervals.begin() , intervals.end());\\n        int j = 0 , n = intervals.size();\\n        for(int i = 1 ; i < n ; i++){\\n            if(intervals[j][1] >= intervals[i][0]){\\n                intervals[j][1] = max(intervals[j][1] , intervals[i][1]);\\n            }\\n            else{\\n                j++;\\n                intervals[j] = intervals[i];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(int i = 0 ; i <= j ; i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912542,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var i = 0\\n\\n        while i < intervals.count, intervals[i][1] < newInterval[0] {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        var newInterval = newInterval\\n        while i < intervals.count, intervals[i][0] <= newInterval[1] {\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        }\\n\\n        ans.append(newInterval)\\n\\n        while i < intervals.count {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var i = 0\\n\\n        while i < intervals.count, intervals[i][1] < newInterval[0] {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        var newInterval = newInterval\\n        while i < intervals.count, intervals[i][0] <= newInterval[1] {\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        }\\n\\n        ans.append(newInterval)\\n\\n        while i < intervals.count {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444764,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        l = bisect.bisect_left([x[1] for x in intervals],newInterval[0])\\n        r = bisect.bisect_right([x[0] for x in intervals],newInterval[1])\\n        \\n        if l < len(intervals):\\n            newInterval[0] = min(newInterval[0],intervals[l][0])\\n            \\n        if r > 0:\\n            newInterval[1] = max(newInterval[1],intervals[r-1][1])\\n            \\n        return intervals[:l] + [ newInterval ] + intervals[r:]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        l = bisect.bisect_left([x[1] for x in intervals],newInterval[0])\\n        r = bisect.bisect_right([x[0] for x in intervals],newInterval[1])\\n        \\n        if l < len(intervals):\\n            newInterval[0] = min(newInterval[0],intervals[l][0])\\n            \\n        if r > 0:\\n            newInterval[1] = max(newInterval[1],intervals[r-1][1])\\n            \\n        return intervals[:l] + [ newInterval ] + intervals[r:]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 792436,
                "title": "c-one-pass-o-n-solution",
                "content": "```csharp\\npublic int[][] Insert(int[][] intervals, int[] newInterval) \\n{\\n\\tif(intervals.Length == 0)\\n\\t{\\n\\t\\treturn new int[][] { newInterval };\\n\\t}        \\n\\n\\tList<int[]> result = new List<int[]>();\\n\\tforeach(var interval in intervals)\\n\\t{\\n\\t\\tif(newInterval[0] > interval[1])\\n\\t\\t{\\n\\t\\t\\tresult.Add(interval);\\n\\t\\t}\\n\\n\\t\\telse if(newInterval[1] < interval[0])\\n\\t\\t{\\n\\t\\t\\tresult.Add(newInterval);\\n\\t\\t\\tnewInterval = interval;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewInterval[0] = Math.Min(interval[0], newInterval[0]);\\n\\t\\t\\tnewInterval[1] = Math.Max(interval[1], newInterval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\tresult.Add(newInterval);\\n\\treturn result.ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[][] Insert(int[][] intervals, int[] newInterval) \\n{\\n\\tif(intervals.Length == 0)\\n\\t{\\n\\t\\treturn new int[][] { newInterval };\\n\\t}        \\n\\n\\tList<int[]> result = new List<int[]>();\\n\\tforeach(var interval in intervals)\\n\\t{\\n\\t\\tif(newInterval[0] > interval[1])\\n\\t\\t{\\n\\t\\t\\tresult.Add(interval);\\n\\t\\t}\\n\\n\\t\\telse if(newInterval[1] < interval[0])\\n\\t\\t{\\n\\t\\t\\tresult.Add(newInterval);\\n\\t\\t\\tnewInterval = interval;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewInterval[0] = Math.Min(interval[0], newInterval[0]);\\n\\t\\t\\tnewInterval[1] = Math.Max(interval[1], newInterval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\tresult.Add(newInterval);\\n\\treturn result.ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056498,
                "title": "c-short-easy-code-with-explanation",
                "content": "# Intuition\\nThe main idea of solving this problem is that when iterate over the intervals, there are three cases:\\n\\n1) the new interval\\'s range is before the range of current interval.\\nExample new interval= {3,4} and current interval= {6,9}\\n\\n2) the new interval is after the range of current interval.\\nExample new interval= {5,7} and current interval= {2,3}\\n3) the new interval range overlaps with the range of current interval.\\nExample interval= {5,9} and new interval= {6,11}\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple iterate through intervals.\\n- If case 1 occurs,ie. The new interval\\'s range is before the current interval, so we can insert the new interval into answer and update new interval to the current interval.\\n- If case 2 occurs,ie. The new interval is after the range of current interval, so we can simply insert the current interval into answer.\\n- If case 3 occurs,ie. The new interval overlaps with current interval, so we update the first element of new interval to the minimum of current interval and new interval and update the second element of new interval to the maximum of current interval and new interval.\\nExample interval= {5,9} and new interval= {6,11}. Then update new interval = {min(5,6),max(9,11)}={5,11}\\n- At the end of iterations simply insert new interval to the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<intervals.size();i++){\\n            //case 1 occurs\\n            if(intervals[i][0] > newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\n            //case 2 occurs\\n            else if(intervals[i][1] < newInterval[0]){ans.push_back(intervals[i]);}       \\n    \\n            //case 3 occurs\\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        //final step\\n        ans.push_back(newInterval); \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<intervals.size();i++){\\n            //case 1 occurs\\n            if(intervals[i][0] > newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\n            //case 2 occurs\\n            else if(intervals[i][1] < newInterval[0]){ans.push_back(intervals[i]);}       \\n    \\n            //case 3 occurs\\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        //final step\\n        ans.push_back(newInterval); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738782,
                "title": "solution-swift-insert-interval-test-cases",
                "content": "```swift\\nclass Solution {\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [newInterval] }\\n        guard !newInterval.isEmpty else { return intervals }\\n        \\n        var idx = 0, new = newInterval, result: [[Int]] = []\\n        let len = intervals.count\\n        \\n        while idx < len, intervals[idx][1] < new[0] {\\n            result.append(intervals[idx])\\n            idx += 1\\n        }\\n        \\n        while idx < len, intervals[idx][0] <= new[1] {\\n            new[0] = min(intervals[idx][0], new[0])\\n            new[1] = max(intervals[idx][1], new[1])\\n            idx += 1\\n        }\\n        \\n        result.append(new)\\n        \\n        for i in idx..<len { result.append(intervals[i]) }\\n        \\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.insert([[1,3],[6,9]], [2,5])\\n        XCTAssertEqual(value, [[1,5],[6,9]])\\n    }\\n    \\n    // Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\\n    func test1() {\\n        let value = solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\\n        XCTAssertEqual(value, [[1,2],[3,10],[12,16]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [newInterval] }\\n        guard !newInterval.isEmpty else { return intervals }\\n        \\n        var idx = 0, new = newInterval, result: [[Int]] = []\\n        let len = intervals.count\\n        \\n        while idx < len, intervals[idx][1] < new[0] {\\n            result.append(intervals[idx])\\n            idx += 1\\n        }\\n        \\n        while idx < len, intervals[idx][0] <= new[1] {\\n            new[0] = min(intervals[idx][0], new[0])\\n            new[1] = max(intervals[idx][1], new[1])\\n            idx += 1\\n        }\\n        \\n        result.append(new)\\n        \\n        for i in idx..<len { result.append(intervals[i]) }\\n        \\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.insert([[1,3],[6,9]], [2,5])\\n        XCTAssertEqual(value, [[1,5],[6,9]])\\n    }\\n    \\n    // Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\\n    func test1() {\\n        let value = solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\\n        XCTAssertEqual(value, [[1,2],[3,10],[12,16]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844503,
                "title": "c-simple-explained-solution-o-n-time-o-1-space-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size();\\n        \\n        if (n == 0) // edge case #1: no intervals in original list\\n            return {newInterval};\\n        \\n        if (intervals[n-1][1] < newInterval[0]) { // edge case #2: new interval goes in the end of the list with no overlap\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        vector<vector<int>> res;\\n        int i = 0;\\n        for(; i<n; i++) {\\n            \\n            if (intervals[i][1] < newInterval[0]) // new interval doesn\\'t overlap\\n                res.push_back(intervals[i]);\\n            else {\\n                int first = min(intervals[i][0], newInterval[0]);\\n                int last = newInterval[1];\\n                \\n                while (i < n && last >= intervals[i][0]) { // while new interval overlaps:\\n                    last = max(intervals[i][1], newInterval[1]);\\n                    i++;\\n                }\\n                res.push_back({first, last});\\n                break;\\n            }\\n        }\\n        \\n        while (i < n) { // add the rest\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size();\\n        \\n        if (n == 0) // edge case #1: no intervals in original list\\n            return {newInterval};\\n        \\n        if (intervals[n-1][1] < newInterval[0]) { // edge case #2: new interval goes in the end of the list with no overlap\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        vector<vector<int>> res;\\n        int i = 0;\\n        for(; i<n; i++) {\\n            \\n            if (intervals[i][1] < newInterval[0]) // new interval doesn\\'t overlap\\n                res.push_back(intervals[i]);\\n            else {\\n                int first = min(intervals[i][0], newInterval[0]);\\n                int last = newInterval[1];\\n                \\n                while (i < n && last >= intervals[i][0]) { // while new interval overlaps:\\n                    last = max(intervals[i][1], newInterval[1]);\\n                    i++;\\n                }\\n                res.push_back({first, last});\\n                break;\\n            }\\n        }\\n        \\n        while (i < n) { // add the rest\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21698,
                "title": "java-2ms-o-log-n-o-1-binary-search-solution-beats-97-7-with-clear-explaination",
                "content": "The idea is using binary search to find the position that the newInterval to be inserted. \\n\\nSince the original intervals are sorted and disjoint, we can apply binary search to find the insertion index of newInterval.start (by interval.start), and to find the insertion index of newInterval.end(by interval.end), \\u3010see LeeCode problem #35\\u3011. Then remove the overlapped elements of the list and merge the newInterval with boundary elements on two sides.\\n\\nComplexity: O(log n) in time (in fact, depending on the implement of the access method list.get(i) and of list.subList(int, int).clear()); O(1) in space.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Since the original list is sorted and all intervals are disjoint,\\n\\t\\t\\t * apply binary search to find the insertion index for the new\\n\\t\\t\\t * interval. [LC35]\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Find insIdx=the insertion index of new.start, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).start>=new.start.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. Find nxtIdx=the insertion index of new.end, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).end>=new.end.\\n\\t\\t\\t * \\n\\t\\t\\t * 3. Remove all elements of the list with indices insIdx<=i<nxtIdx.\\n\\t\\t\\t * \\n\\t\\t\\t * 4. Merge new with list.get(insIdx-1) or list.get(nxtIdx) or both.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint n = intervals.size();\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\tintervals.add(newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint low = 0, high = n - 1, mid = 0;\\n\\t\\t\\tint temp, target = newInterval.start;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).start;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// insIdx = the index where new interval to be inserted\\n\\t\\t\\tint insIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval pre = (insIdx == 0) ? null : intervals.get(insIdx - 1);\\n\\t\\t\\t// 0<=insIdx<=n, pre=[insIdx-1], pre.start<new.start\\n\\n\\t\\t\\tlow = insIdx;\\n\\t\\t\\thigh = n - 1;\\n\\t\\t\\ttarget = newInterval.end;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).end;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// nxtIdx= the next index after the inserted new interval\\n\\t\\t\\tint nxtIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval nxt = (nxtIdx == n) ? null : intervals.get(nxtIdx);\\n\\t\\t\\t// insIdx<=nxtIdx<=n, nxt=[nxtIdx], nxt.end>=new.end\\n\\n\\t\\t\\t// [0]...[insIdx-1] <--> [insIdx]...[nxtIdx-1][nxtIdx]...[n]\\n\\t\\t\\tintervals.subList(insIdx, nxtIdx).clear();\\n\\n\\t\\t\\t// check whether newInterval can be merged with pre or nxt\\n\\t\\t\\tboolean isMerged = false, isMerged2 = false;\\n\\t\\t\\tif (insIdx > 0 && pre.end >= newInterval.start) {\\n\\t\\t\\t\\tpre.end = Math.max(pre.end, newInterval.end);\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nxtIdx < n && newInterval.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = Math.min(nxt.start, newInterval.start);\\n\\t\\t\\t\\tisMerged2 = isMerged;\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isMerged) {\\n\\t\\t\\t\\tintervals.add(insIdx, newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// merged with pre or nxt or both, deal with the both case\\n\\t\\t\\tif (isMerged2 && pre.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = pre.start; // pre.start < new.start, nxt.start;\\n\\t\\t\\t\\tintervals.remove(insIdx - 1); // remove pre\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn intervals;\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "The idea is using binary search to find the position that the newInterval to be inserted. \\n\\nSince the original intervals are sorted and disjoint, we can apply binary search to find the insertion index of newInterval.start (by interval.start), and to find the insertion index of newInterval.end(by interval.end), \\u3010see LeeCode problem #35\\u3011. Then remove the overlapped elements of the list and merge the newInterval with boundary elements on two sides.\\n\\nComplexity: O(log n) in time (in fact, depending on the implement of the access method list.get(i) and of list.subList(int, int).clear()); O(1) in space.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Since the original list is sorted and all intervals are disjoint,\\n\\t\\t\\t * apply binary search to find the insertion index for the new\\n\\t\\t\\t * interval. [LC35]\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Find insIdx=the insertion index of new.start, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).start>=new.start.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. Find nxtIdx=the insertion index of new.end, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).end>=new.end.\\n\\t\\t\\t * \\n\\t\\t\\t * 3. Remove all elements of the list with indices insIdx<=i<nxtIdx.\\n\\t\\t\\t * \\n\\t\\t\\t * 4. Merge new with list.get(insIdx-1) or list.get(nxtIdx) or both.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint n = intervals.size();\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\tintervals.add(newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint low = 0, high = n - 1, mid = 0;\\n\\t\\t\\tint temp, target = newInterval.start;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).start;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// insIdx = the index where new interval to be inserted\\n\\t\\t\\tint insIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval pre = (insIdx == 0) ? null : intervals.get(insIdx - 1);\\n\\t\\t\\t// 0<=insIdx<=n, pre=[insIdx-1], pre.start<new.start\\n\\n\\t\\t\\tlow = insIdx;\\n\\t\\t\\thigh = n - 1;\\n\\t\\t\\ttarget = newInterval.end;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).end;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// nxtIdx= the next index after the inserted new interval\\n\\t\\t\\tint nxtIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval nxt = (nxtIdx == n) ? null : intervals.get(nxtIdx);\\n\\t\\t\\t// insIdx<=nxtIdx<=n, nxt=[nxtIdx], nxt.end>=new.end\\n\\n\\t\\t\\t// [0]...[insIdx-1] <--> [insIdx]...[nxtIdx-1][nxtIdx]...[n]\\n\\t\\t\\tintervals.subList(insIdx, nxtIdx).clear();\\n\\n\\t\\t\\t// check whether newInterval can be merged with pre or nxt\\n\\t\\t\\tboolean isMerged = false, isMerged2 = false;\\n\\t\\t\\tif (insIdx > 0 && pre.end >= newInterval.start) {\\n\\t\\t\\t\\tpre.end = Math.max(pre.end, newInterval.end);\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nxtIdx < n && newInterval.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = Math.min(nxt.start, newInterval.start);\\n\\t\\t\\t\\tisMerged2 = isMerged;\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isMerged) {\\n\\t\\t\\t\\tintervals.add(insIdx, newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// merged with pre or nxt or both, deal with the both case\\n\\t\\t\\tif (isMerged2 && pre.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = pre.start; // pre.start < new.start, nxt.start;\\n\\t\\t\\t\\tintervals.remove(insIdx - 1); // remove pre\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn intervals;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 844481,
                "title": "c-clean-and-commented-with-example-explained-o-n-time",
                "content": "****Explaination****\\n- **1st While loop** to put all intervals that are to the left of the inserted interval. \\n-  **2nd While loop to** merge all intervals that intersect with the inserted interval.\\n-  **3rd While loop** put all intervals that are to the right of the inserted interval.\\n\\n****Example****\\nGiven [1,2],[3,5],[6,7],[8,10],[12,14], insert and merge [4,9] in as [1,2],[3,10],[12,14]\\n![image](https://assets.leetcode.com/users/images/58677d7a-175e-4f97-ab36-44d01d3195e5_1599985042.67296.png)\\n\\n****Code****\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> sol;\\n        if(!size(intervals) and !size(newInterval)){\\n            sol.push_back(newInterval);\\n            return sol;\\n        }\\n        if(!size(intervals)){\\n            sol.push_back(newInterval);\\n            return(sol);\\n        }\\n        int i=0;\\n        int start=newInterval[0];\\n        int end=newInterval[1];\\n\\t\\t//while #1 put all intervals that are to the left of the inserted interval. \\n                while(i<size(intervals) and  intervals[i][1]<newInterval[0]) \\n                    sol.push_back(intervals[i++]);\\n\\t\\t//while #2 merge all intervals that intersect with the inserted interval.\\n                while(i<size(intervals) and intervals[i][0]<=end){\\n                    start = min(start, intervals[i][0]);\\n                    end = max(end, intervals[i][1]);\\n                    i++;\\n                }\\n                sol.push_back({start,end});\\n\\t//while #3 put all intervals that are to the right of the inserted interval.\\n            while(i<size(intervals))\\n                sol.push_back(intervals[i++]);\\n        return sol;          \\n    }\\n};\\n```\\n****Complexity****\\nO(n)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> sol;\\n        if(!size(intervals) and !size(newInterval)){\\n            sol.push_back(newInterval);\\n            return sol;\\n        }\\n        if(!size(intervals)){\\n            sol.push_back(newInterval);\\n            return(sol);\\n        }\\n        int i=0;\\n        int start=newInterval[0];\\n        int end=newInterval[1];\\n\\t\\t//while #1 put all intervals that are to the left of the inserted interval. \\n                while(i<size(intervals) and  intervals[i][1]<newInterval[0]) \\n                    sol.push_back(intervals[i++]);\\n\\t\\t//while #2 merge all intervals that intersect with the inserted interval.\\n                while(i<size(intervals) and intervals[i][0]<=end){\\n                    start = min(start, intervals[i][0]);\\n                    end = max(end, intervals[i][1]);\\n                    i++;\\n                }\\n                sol.push_back({start,end});\\n\\t//while #3 put all intervals that are to the right of the inserted interval.\\n            while(i<size(intervals))\\n                sol.push_back(intervals[i++]);\\n        return sol;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844417,
                "title": "python-simple-explained-solution-o-n-time-o-1-space-faster-than-99",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\n        # edge case #1: no intervals in original list\\n        if len(intervals) == 0:\\n            return [newInterval]\\n\\t\\t\\t\\n        # edge case #2: new interval goes in the end of the list with no overlap\\n        if intervals[-1][1] < newInterval[0]:\\n            return intervals + [newInterval]\\n\\t\\t\\t\\n        # edge case #3: new interval goes in the beginning of the list with no overlap\\n        if newInterval[1] < intervals[0][0]:\\n            return [newInterval] + intervals\\n\\t\\t\\t\\n        res = []\\n        i = 0\\n        for curr_interval in intervals:\\n            # new interval doesn\\'t overlap\\n            if curr_interval[1] < newInterval[0]:\\n                res.append(curr_interval)\\n            else:\\n                first = min(curr_interval[0], newInterval[0])\\n                last = newInterval[1]\\n                i = intervals.index(curr_interval)\\n\\t\\t\\t\\t\\n                # while new interval overlaps:\\n                while i < len(intervals) and last >= intervals[i][0]:\\n                    last = max(intervals[i][1], newInterval[1])\\n                    i+=1\\n                res.append([first, last])\\n                break\\n\\t\\t\\t\\t\\n        # add the rest\\n        res += intervals[i:]\\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\n        # edge case #1: no intervals in original list\\n        if len(intervals) == 0:\\n            return [newInterval]\\n\\t\\t\\t\\n        # edge case #2: new interval goes in the end of the list with no overlap\\n        if intervals[-1][1] < newInterval[0]:\\n            return intervals + [newInterval]\\n\\t\\t\\t\\n        # edge case #3: new interval goes in the beginning of the list with no overlap\\n        if newInterval[1] < intervals[0][0]:\\n            return [newInterval] + intervals\\n\\t\\t\\t\\n        res = []\\n        i = 0\\n        for curr_interval in intervals:\\n            # new interval doesn\\'t overlap\\n            if curr_interval[1] < newInterval[0]:\\n                res.append(curr_interval)\\n            else:\\n                first = min(curr_interval[0], newInterval[0])\\n                last = newInterval[1]\\n                i = intervals.index(curr_interval)\\n\\t\\t\\t\\t\\n                # while new interval overlaps:\\n                while i < len(intervals) and last >= intervals[i][0]:\\n                    last = max(intervals[i][1], newInterval[1])\\n                    i+=1\\n                res.append([first, last])\\n                break\\n\\t\\t\\t\\t\\n        # add the rest\\n        res += intervals[i:]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134823,
                "title": "python-6-lines-easy-to-understand-60-ms-beats-96",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        new, i = [], 0\\n        for i, it in enumerate(intervals):\\n            if newInterval.end < it.start: i -= 1; break\\n            elif it.end < newInterval.start: new += it,\\n            else: newInterval.start, newInterval.end = min(it.start, newInterval.start), max(it.end, newInterval.end)\\n        return new + [newInterval] + intervals[i + 1:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        new, i = [], 0\\n        for i, it in enumerate(intervals):\\n            if newInterval.end < it.start: i -= 1; break\\n            elif it.end < newInterval.start: new += it,\\n            else: newInterval.start, newInterval.end = min(it.start, newInterval.start), max(it.end, newInterval.end)\\n        return new + [newInterval] + intervals[i + 1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21828,
                "title": "my-ac-java-in-place-solution",
                "content": "    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            if(intervals.isEmpty()){\\n                intervals.add(newInterval);\\n                return intervals;\\n            }\\n            \\n            int start = newInterval.start;\\n            int end = newInterval.end;\\n            ListIterator<Interval> li = intervals.listIterator();\\n            boolean inserted = false;\\n            while(li.hasNext()){\\n                Interval itv = li.next();\\n                if(start <= itv.end){\\n                    if(end < itv.start){ //newInterval does not overlap with current itv, time to insert\\n                        li.remove();\\n                        li.add(new Interval(start, end));\\n                        li.add(itv);\\n                        inserted = true;\\n                        break;\\n                    }\\n                    \\n                    // still some overlap so compare start & end\\n                    start = Math.min(start, itv.start);\\n                    end = Math.max(end, itv.end);\\n                    li.remove();\\n                }\\n            }\\n            \\n            if(!inserted){\\n                intervals.add(new Interval(start, end));\\n            }\\n            \\n            return intervals;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            if(intervals.isEmpty()){\\n                intervals.add(newInterval);\\n                return intervals;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3057760,
                "title": "java-99th-percentile-one-pass-explained-article",
                "content": "![image.png](https://assets.leetcode.com/users/images/79f9f39a-f625-4707-9c7b-dcbb13533e2b_1673854957.9331577.png)\\n\\n\\n# Intuition\\nWe are given a non-overlapping, sorted intervals array. These properties are essential because we can utilize them to solve the problem in one pass.\\n\\nLet\\'s visualize a few possibilities that we may have. Imagine these given intervals:\\n```\\n    [     ] [ ] [  ]\\n```\\nImagine them on an x-axis line.\\n\\nWe may need to insert the following intervals:\\n```\\n    [     ] [ ] [  ]\\n |           |   \\n\\n | |\\n                         | |\\n\\n```\\n\\nThese are three situations where we may need to insert a new interval.\\n\\nThe first one overlaps multiple given intervals, the second one doesn\\'t overlap and should be inserted in the beginning, and the last is non-overlapping and should be inserted in the end.\\n\\nWe either need to *merge* the interval with one of the given intervals (or multiple), or insert it.\\n\\n*If we merge an interval, we don\\'t impact the intervals previously added*, because they are sorted. `nextIntervalEnd > previousStart`, which is always true because of non-overlapping sorted property.\\n\\nTherefore we need to merge intervals *until* we find an interval that started after the merged interval.\\n\\nIf the given interval doesn\\'t overlap with the merged interval, we simply add it to the result array.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> mergedIntervals = new ArrayList<>();\\n        int[] merged = new int[] {newInterval[0], newInterval[1]};\\n        boolean isInserted = false;\\n\\n        for (int[] interval : intervals) {\\n            if(interval[0] > merged[1]) {\\n                if(!isInserted) {\\n                    mergedIntervals.add(merged);\\n                    isInserted = true;\\n                }\\n                mergedIntervals.add(interval);\\n                \\n            } else {\\n                // does intersect\\n                if(doesIntersect(merged, interval)) {\\n                    merged[0] = Math.min(merged[0], interval[0]);\\n                    merged[1] = Math.max(merged[1], interval[1]);\\n                } else {\\n                    // not intersecting\\n                    mergedIntervals.add(interval);\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        // new interval is at the end\\n        if(!isInserted) {\\n            mergedIntervals.add(merged);\\n            isInserted = true;\\n        }\\n\\n        // Java specific to copy to arr[][]...\\n        int[][] res = new int[mergedIntervals.size()][2];\\n        for(int i = 0; i < mergedIntervals.size(); i++) {\\n            res[i] = mergedIntervals.get(i);\\n        }\\n        return res;\\n\\n    }\\n\\n    private boolean doesIntersect(int[] intervalA, int[] intervalB) {\\n        return intervalA[0] <= intervalB[1] && intervalB[0] <= intervalA[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    [     ] [ ] [  ]\\n```\n```\\n    [     ] [ ] [  ]\\n |           |   \\n\\n | |\\n                         | |\\n\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> mergedIntervals = new ArrayList<>();\\n        int[] merged = new int[] {newInterval[0], newInterval[1]};\\n        boolean isInserted = false;\\n\\n        for (int[] interval : intervals) {\\n            if(interval[0] > merged[1]) {\\n                if(!isInserted) {\\n                    mergedIntervals.add(merged);\\n                    isInserted = true;\\n                }\\n                mergedIntervals.add(interval);\\n                \\n            } else {\\n                // does intersect\\n                if(doesIntersect(merged, interval)) {\\n                    merged[0] = Math.min(merged[0], interval[0]);\\n                    merged[1] = Math.max(merged[1], interval[1]);\\n                } else {\\n                    // not intersecting\\n                    mergedIntervals.add(interval);\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        // new interval is at the end\\n        if(!isInserted) {\\n            mergedIntervals.add(merged);\\n            isInserted = true;\\n        }\\n\\n        // Java specific to copy to arr[][]...\\n        int[][] res = new int[mergedIntervals.size()][2];\\n        for(int i = 0; i < mergedIntervals.size(); i++) {\\n            res[i] = mergedIntervals.get(i);\\n        }\\n        return res;\\n\\n    }\\n\\n    private boolean doesIntersect(int[] intervalA, int[] intervalB) {\\n        return intervalA[0] <= intervalB[1] && intervalB[0] <= intervalA[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643451,
                "title": "explained-simple-and-clear-python3-code",
                "content": "\\n# Approach\\nThe solution follows the logic of iterating through the intervals to find the correct position to insert the new interval while maintaining the sorted order. After insertion, it iterates over the modified array to merge any overlapping intervals by updating the end time of the previous interval if necessary. Finally, it returns the modified array with the new interval inserted and any overlapping intervals merged.\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, inv: List[List[int]], nw: List[int]) -> List[List[int]]:\\n        #insert nw\\n        test=True\\n        for i in range(len(inv)):\\n            if inv[i][0]>nw[0]:\\n                test=False\\n                inv.insert(i,nw)\\n        if test:\\n            inv.append(nw)\\n\\n        i=1\\n        while i<len(inv):\\n            if inv[i-1][1]>=inv[i][0]:\\n                inv[i-1][1]=max (inv[i-1][1],inv[i][1])\\n                inv.pop(i)\\n            else:\\n                i+=1\\n            \\n        return inv\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, inv: List[List[int]], nw: List[int]) -> List[List[int]]:\\n        #insert nw\\n        test=True\\n        for i in range(len(inv)):\\n            if inv[i][0]>nw[0]:\\n                test=False\\n                inv.insert(i,nw)\\n        if test:\\n            inv.append(nw)\\n\\n        i=1\\n        while i<len(inv):\\n            if inv[i-1][1]>=inv[i][0]:\\n                inv[i-1][1]=max (inv[i-1][1],inv[i][1])\\n                inv.pop(i)\\n            else:\\n                i+=1\\n            \\n        return inv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056720,
                "title": "java-short-beats-99-26-priorityqueue",
                "content": "# One Pass (Beats 99.26%) : Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        /*  \\n            Test Case 1.\\n            newInterval : [2,5]\\n            intervals : [[1,3],[6,9]]\\n                                 ^\\n        */\\n        for (int[] interval : intervals) {\\n            if (interval[1] < newInterval[0]) {\\n                list.add(interval);\\n\\n                // second interval[1] =>  [6, 9] > [1, 5]\\n            } else if (interval[0] > newInterval[1]) {\\n                list.add(new int[] {newInterval[0], newInterval[1]}); // added (1,5)\\n                newInterval = interval; // (6,9)\\n\\n                // first interval[0] => [1, 3] >= [2,5]\\n            } else if (interval[1] >= newInterval[0]) {\\n                // newInterval = [1, 5]\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        list.add(newInterval); // added (6, 9) => list: [(1, 5), (6, 9)]\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n# PriorityQueue : Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] interval : intervals) pq.add(interval);\\n        pq.add(newInterval);\\n        \\n        List<int[]> res = new ArrayList<>(); \\n        int[] prev = pq.poll();        \\n        while (!pq.isEmpty()) {             \\n            int[] cur = pq.poll();\\n            if (prev[1] >= cur[0]) {\\n                prev = new int[]{prev[0], Math.max(cur[1], prev[1])};\\n            } else {\\n                res.add(prev);\\n                prev = cur;\\n            }\\n        }\\n        res.add(prev);       \\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        /*  \\n            Test Case 1.\\n            newInterval : [2,5]\\n            intervals : [[1,3],[6,9]]\\n                                 ^\\n        */\\n        for (int[] interval : intervals) {\\n            if (interval[1] < newInterval[0]) {\\n                list.add(interval);\\n\\n                // second interval[1] =>  [6, 9] > [1, 5]\\n            } else if (interval[0] > newInterval[1]) {\\n                list.add(new int[] {newInterval[0], newInterval[1]}); // added (1,5)\\n                newInterval = interval; // (6,9)\\n\\n                // first interval[0] => [1, 3] >= [2,5]\\n            } else if (interval[1] >= newInterval[0]) {\\n                // newInterval = [1, 5]\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        list.add(newInterval); // added (6, 9) => list: [(1, 5), (6, 9)]\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] interval : intervals) pq.add(interval);\\n        pq.add(newInterval);\\n        \\n        List<int[]> res = new ArrayList<>(); \\n        int[] prev = pq.poll();        \\n        while (!pq.isEmpty()) {             \\n            int[] cur = pq.poll();\\n            if (prev[1] >= cur[0]) {\\n                prev = new int[]{prev[0], Math.max(cur[1], prev[1])};\\n            } else {\\n                res.add(prev);\\n                prev = cur;\\n            }\\n        }\\n        res.add(prev);       \\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038557,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for(int[] in: intervals){\\n            if(in[1] < newInterval[0]){\\n                ans.add(in);\\n            }\\n            else if(in[0] > newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = in;\\n            }\\n            else{\\n                newInterval[0] = Math.min(newInterval[0], in[0]);\\n                newInterval[1] = Math.max(newInterval[1], in[1]);\\n            }\\n        }\\n        \\n        ans.add(newInterval);\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for(int[] in: intervals){\\n            if(in[1] < newInterval[0]){\\n                ans.add(in);\\n            }\\n            else if(in[0] > newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = in;\\n            }\\n            else{\\n                newInterval[0] = Math.min(newInterval[0], in[0]);\\n                newInterval[1] = Math.max(newInterval[1], in[1]);\\n            }\\n        }\\n        \\n        ans.add(newInterval);\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804462,
                "title": "java-99-solution-one-pass-o-n-with-comments",
                "content": "\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> l = new ArrayList<>();\\n        // 1. if an interval end before newInterval start, it can be added to output directly.\\n        // 2. if an interval overlapping with new Interval, merge it into new Interval. overlapping if an interval end after new Interval start and start before new Interval end.\\n        // 3  after all overlapping intervals processed, add the merged new Interval (or the original new interval if no interval meet #2 condition, i.e. no overlap)\\n        // 4. add the rest non overlapping intervals. all the rest have start after new interval end.\\n        \\n        int i = 0, N = intervals.length;\\n        while (i < N && intervals[i][1] < newInterval[0]) // #1\\n            l.add(intervals[i++]);\\n        \\n        while (i < N && intervals[i][0] <= newInterval[1]) { // #2\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);\\n        }\\n        \\n        l.add(newInterval); // #3       \\n        while (i < N) l.add(intervals[i++]);  // #4\\n        return l.toArray(new int[][]{});\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> l = new ArrayList<>();\\n        // 1. if an interval end before newInterval start, it can be added to output directly.\\n        // 2. if an interval overlapping with new Interval, merge it into new Interval. overlapping if an interval end after new Interval start and start before new Interval end.\\n        // 3  after all overlapping intervals processed, add the merged new Interval (or the original new interval if no interval meet #2 condition, i.e. no overlap)\\n        // 4. add the rest non overlapping intervals. all the rest have start after new interval end.\\n        \\n        int i = 0, N = intervals.length;\\n        while (i < N && intervals[i][1] < newInterval[0]) // #1\\n            l.add(intervals[i++]);\\n        \\n        while (i < N && intervals[i][0] <= newInterval[1]) { // #2\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);\\n        }\\n        \\n        l.add(newInterval); // #3       \\n        while (i < N) l.add(intervals[i++]);  // #4\\n        return l.toArray(new int[][]{});\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 703958,
                "title": "javascript-explanation",
                "content": "* append new interval to list of intervals\\n* sort by beg time\\n* then do merge intervals \\n\\n(I know sorting will raise time to O(nlogn) and there are some solutions out there that yield O(n))\\n\\n```javascript\\nconst insert = (intervals, newInterval) => {\\n    if(!intervals) return [];\\n    const ans = new Array();\\n    \\n    intervals.push(newInterval);\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    if(intervals.length === 1) return intervals;\\n    const prev = [intervals[0][0], intervals[0][1]];\\n    for(let i = 1; i < intervals.length; i++) {\\n        const curr = intervals[i];\\n        if(isOverlap(prev, curr)) {\\n            prev[0] = Math.min(prev[0], curr[0]);\\n            prev[1] = Math.max(prev[1], curr[1]);\\n        } else {\\n            ans.push([...prev]);\\n            prev[0] = curr[0];\\n            prev[1] = curr[1];\\n        }\\n        \\n        if(i === intervals.length - 1) ans.push([...prev])\\n    }\\n    \\n    return ans;\\n};\\n\\nconst isOverlap = (prev, curr) => {\\n    return  prev[1] >= curr[0] && prev[1] <= curr[1]\\n            || prev[0] >= curr[0] && prev[0] <= curr[1]\\n            || prev[0] <= curr[0] && prev[1] >= curr[1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst insert = (intervals, newInterval) => {\\n    if(!intervals) return [];\\n    const ans = new Array();\\n    \\n    intervals.push(newInterval);\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    if(intervals.length === 1) return intervals;\\n    const prev = [intervals[0][0], intervals[0][1]];\\n    for(let i = 1; i < intervals.length; i++) {\\n        const curr = intervals[i];\\n        if(isOverlap(prev, curr)) {\\n            prev[0] = Math.min(prev[0], curr[0]);\\n            prev[1] = Math.max(prev[1], curr[1]);\\n        } else {\\n            ans.push([...prev]);\\n            prev[0] = curr[0];\\n            prev[1] = curr[1];\\n        }\\n        \\n        if(i === intervals.length - 1) ans.push([...prev])\\n    }\\n    \\n    return ans;\\n};\\n\\nconst isOverlap = (prev, curr) => {\\n    return  prev[1] >= curr[0] && prev[1] <= curr[1]\\n            || prev[0] >= curr[0] && prev[0] <= curr[1]\\n            || prev[0] <= curr[0] && prev[1] >= curr[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21813,
                "title": "short-simple-o-n-in-place-java-solution-with-explanation",
                "content": "The idea is to look at each interval in the list. If it intersects with newInterval then merge it to newInterval and delete it. In the end add newInterval back to its corresponding place.\\n\\n    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            ListIterator<Interval> i = intervals.listIterator();\\n            Interval in;\\n            while (i.hasNext()) {\\n                in = i.next();\\n                if (newInterval.end < in.start) {\\n                    i.previous();\\n                    break;\\n                }\\n                if (in.start <= newInterval.end && newInterval.start <= in.end) {\\n                    newInterval.start = Math.min(newInterval.start, in.start);\\n                    newInterval.end = Math.max(newInterval.end, in.end);\\n                    i.previous();\\n                    i.remove();\\n                }\\n            }\\n            i.add(newInterval);\\n            return intervals;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            ListIterator<Interval> i = intervals.listIterator();\\n            Interval in;\\n            while (i.hasNext()) {\\n                in = i.next();\\n                if (newInterval.end < in.start) {\\n                    i.previous();\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3992539,
                "title": "best-solution-in-c-100-easily-understandable",
                "content": "# Approach\\nExplained in the code using comments\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n\\n        //sort using the same logic as Merge Intervals question\\n        sort(intervals.begin(), intervals.end()); \\n\\n        for(auto it: intervals)\\n        {\\n            //if interval before is smaller add that\\n            if(it[1] < newInterval[0]) \\n                ans.push_back(it);\\n\\n            //if the newInterval is smaller add that\\n            else if(newInterval[1] < it[0]) \\n            {\\n                ans.push_back(newInterval);\\n                newInterval = it;\\n            }\\n            \\n            //if newInterval lies within the currentIntervals\\n            else \\n            {\\n                newInterval[0] = min(newInterval[0], it[0]);\\n                newInterval[1] = max(newInterval[1], it[1]);\\n            } \\n        }\\n\\n        //add the last Interval\\n        ans.push_back(newInterval);\\n\\n        return ans;                                                                          \\n    }\\n};\\n```\\n\\n![pleaseupvotye.jpeg](https://assets.leetcode.com/users/images/e1cd0d4f-0255-4afa-8f6e-b5fff843647b_1693664013.5913265.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n\\n        //sort using the same logic as Merge Intervals question\\n        sort(intervals.begin(), intervals.end()); \\n\\n        for(auto it: intervals)\\n        {\\n            //if interval before is smaller add that\\n            if(it[1] < newInterval[0]) \\n                ans.push_back(it);\\n\\n            //if the newInterval is smaller add that\\n            else if(newInterval[1] < it[0]) \\n            {\\n                ans.push_back(newInterval);\\n                newInterval = it;\\n            }\\n            \\n            //if newInterval lies within the currentIntervals\\n            else \\n            {\\n                newInterval[0] = min(newInterval[0], it[0]);\\n                newInterval[1] = max(newInterval[1], it[1]);\\n            } \\n        }\\n\\n        //add the last Interval\\n        ans.push_back(newInterval);\\n\\n        return ans;                                                                          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057457,
                "title": "simple-c-beats-99-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all if we think of approach so we can do this by using linear search or Binary search . So we know  Bianry search has logn timpecomplexity but through binary search we find where to insert in logn but we have to merge with others and insert also that will take O(n) so there is no need of binary search we can do a linear serach as well beacuse both will be O(n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nComing to Approach first we can think of many conditions but We only need to check three conditions that are :\\n- Insert those intervals who are not overlapping and are less than our new Interval \\n- Now check if our new Interval is overalpping wiht any other interval(s) so either insert if not overlapping or merge if overallping with others\\n- Now insert those who are left i.e those intervals which are greater than new Interval\\n*These condtions can easily be checked using a while loop*\\nFor second condition when the inertvals are overlapping we can do that by :\\n` (a,b)  and (c,d) the  new interval: [min(a,c),max(b,d)]`\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inv, vector<int>& newI) {\\n       vector<vector<int>>ans;\\n       int n=inv.size();\\n        int i=0;\\n        // insert those intervals which are not overlapping and less than newInterval\\n       while(i<n and inv[i][1]<newI[0]){\\n           ans.push_back(inv[i++]);\\n       }\\n       // now insert the new Interval or merge the interval if neccessary\\n\\n       while(i<n and newI[1]>=inv[i][0]){\\n           newI[0]=min(newI[0],inv[i][0]);\\n           newI[1]=max(newI[1],inv[i][1]);\\n           i++;\\n       }\\n       ans.push_back(newI);\\n      // insert thse intervals which are left or greater than the newInterval\\n      while(i<n ){\\n          ans.push_back(inv[i++]);\\n      }\\n       return ans; \\n    }\\n};\\n```\\n**Please upVote If Found HelpFull \\uD83D\\uDD3C**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inv, vector<int>& newI) {\\n       vector<vector<int>>ans;\\n       int n=inv.size();\\n        int i=0;\\n        // insert those intervals which are not overlapping and less than newInterval\\n       while(i<n and inv[i][1]<newI[0]){\\n           ans.push_back(inv[i++]);\\n       }\\n       // now insert the new Interval or merge the interval if neccessary\\n\\n       while(i<n and newI[1]>=inv[i][0]){\\n           newI[0]=min(newI[0],inv[i][0]);\\n           newI[1]=max(newI[1],inv[i][1]);\\n           i++;\\n       }\\n       ans.push_back(newI);\\n      // insert thse intervals which are left or greater than the newInterval\\n      while(i<n ){\\n          ans.push_back(inv[i++]);\\n      }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681746,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let result = []\\n    \\n    for(let i = 0; i < intervals.length; i++){\\n        //not overlapping with current interval\\n        if(newInterval[1] < intervals[i][0]){\\n            result.push(newInterval)\\n            result.push(...intervals.slice(i))\\n            return result\\n        }else if(newInterval[0] > intervals[i][1]){\\n            result.push(intervals[i])\\n        }else{\\n            //is overlapping with current interval\\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]\\n            //extend interval if needed\\n        }\\n    }\\n    result.push(newInterval)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let result = []\\n    \\n    for(let i = 0; i < intervals.length; i++){\\n        //not overlapping with current interval\\n        if(newInterval[1] < intervals[i][0]){\\n            result.push(newInterval)\\n            result.push(...intervals.slice(i))\\n            return result\\n        }else if(newInterval[0] > intervals[i][1]){\\n            result.push(intervals[i])\\n        }else{\\n            //is overlapping with current interval\\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]\\n            //extend interval if needed\\n        }\\n    }\\n    result.push(newInterval)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581680,
                "title": "python-easy-solution-two-approaches",
                "content": "\\t# 1st Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\tintervals.append(newInterval)\\n\\t\\t\\tintervals.sort(key=lambda x: x[0])\\n\\t\\t\\tstart = intervals[0][0]\\n\\t\\t\\tend = intervals[0][1]\\n\\t\\t\\ti = 1\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tif intervals[i][0] <= end:\\n\\t\\t\\t\\t\\tend = max(end, intervals[i][1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append([start, end])\\n\\t\\t\\t\\t\\tstart = intervals[i][0]\\n\\t\\t\\t\\t\\tend = intervals[i][1]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append([start, end])\\n\\t\\t\\treturn res\\n\\n\\t# 2nd Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\ti = 0\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals) and intervals[i][1] < newInterval[0]:\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\twhile i < len(intervals) and intervals[i][0] <= newInterval[1]:\\n\\t\\t\\t\\tnewInterval[0] = min(intervals[i][0], newInterval[0])\\n\\t\\t\\t\\tnewInterval[1] = max(intervals[i][1], newInterval[1])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append(newInterval)\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# 1st Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\tintervals.append(newInterval)\\n\\t\\t\\tintervals.sort(key=lambda x: x[0])\\n\\t\\t\\tstart = intervals[0][0]\\n\\t\\t\\tend = intervals[0][1]\\n\\t\\t\\ti = 1\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tif intervals[i][0] <= end:\\n\\t\\t\\t\\t\\tend = max(end, intervals[i][1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append([start, end])\\n\\t\\t\\t\\t\\tstart = intervals[i][0]\\n\\t\\t\\t\\t\\tend = intervals[i][1]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append([start, end])\\n\\t\\t\\treturn res\\n\\n\\t# 2nd Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\ti = 0\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals) and intervals[i][1] < newInterval[0]:\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\twhile i < len(intervals) and intervals[i][0] <= newInterval[1]:\\n\\t\\t\\t\\tnewInterval[0] = min(intervals[i][0], newInterval[0])\\n\\t\\t\\t\\tnewInterval[1] = max(intervals[i][1], newInterval[1])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append(newInterval)\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1506902,
                "title": "java-easy-to-understand-o-n-code-with-comments",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Handling edge case when intervals is empty\\n        if(intervals.length == 0){\\n            if(newInterval.length != 0)\\n                result.add(newInterval);\\n            return result.toArray(new int[result.size()][]);\\n        }\\n        \\n        int i=0;\\n        \\n        // 1. Copy until overlap is not found\\n        while(i < intervals.length && newInterval[0] > intervals[i][1])\\n            result.add(intervals[i++]);\\n        \\n        // 2. Update newInterval by comparing it with overlapped intervals\\n        while(i < intervals.length && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        \\n        // 3. Add the updated newInterval\\n        result.add(newInterval);\\n        \\n        // 4. Copy the remaining in the intervals list to the final result\\n        while(i < intervals.length)\\n            result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Handling edge case when intervals is empty\\n        if(intervals.length == 0){\\n            if(newInterval.length != 0)\\n                result.add(newInterval);\\n            return result.toArray(new int[result.size()][]);\\n        }\\n        \\n        int i=0;\\n        \\n        // 1. Copy until overlap is not found\\n        while(i < intervals.length && newInterval[0] > intervals[i][1])\\n            result.add(intervals[i++]);\\n        \\n        // 2. Update newInterval by comparing it with overlapped intervals\\n        while(i < intervals.length && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        \\n        // 3. Add the updated newInterval\\n        result.add(newInterval);\\n        \\n        // 4. Copy the remaining in the intervals list to the final result\\n        while(i < intervals.length)\\n            result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261009,
                "title": "zero-bullshit-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 844384,
                "title": "java-greedily-absorb-overlapping-intervals-o-n-time-o-1-extra-space-explained",
                "content": "```\\n\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        int i=0;\\n\\t\\t/* Add all intervals ending earlier than the start of newInterval */\\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\\n            result.add(intervals[i++]);\\n        }\\n        \\n\\t\\t/* Greedily absorb any interval that overlaps with newInterval */\\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n\\t\\t/* Add newInterval to the result list */\\n        result.add(newInterval);\\n\\t\\t\\n\\t\\t/* Add any remaining intervals. These start later than the end\\n\\t\\t   time of newInterval */\\n        while(i < intervals.length) result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        int i=0;\\n\\t\\t/* Add all intervals ending earlier than the start of newInterval */\\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\\n            result.add(intervals[i++]);\\n        }\\n        \\n\\t\\t/* Greedily absorb any interval that overlaps with newInterval */\\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n\\t\\t/* Add newInterval to the result list */\\n        result.add(newInterval);\\n\\t\\t\\n\\t\\t/* Add any remaining intervals. These start later than the end\\n\\t\\t   time of newInterval */\\n        while(i < intervals.length) result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 530137,
                "title": "hard-problem-c-easy-solution",
                "content": "Not sure why this problem is marked as Hard, it\\'s on the \\'easy\\' side of Easy.\\n```cpp\\nvector<vector<int>> insert(vector<vector<int>>& ints, vector<int>& ni, int i = 0) {\\n    vector<vector<int>> res;\\n    for (; i < ints.size() && ints[i][0] <= ni[1]; ++i) {\\n        if (ints[i][1] < ni[0])\\n            res.push_back(ints[i]);\\n        else {\\n            ni[0] = min(ni[0], ints[i][0]);\\n            ni[1] = max(ni[1], ints[i][1]);\\n        }\\n    }\\n    res.push_back(ni);\\n    res.insert(end(res), begin(ints) + i, end(ints));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> insert(vector<vector<int>>& ints, vector<int>& ni, int i = 0) {\\n    vector<vector<int>> res;\\n    for (; i < ints.size() && ints[i][0] <= ni[1]; ++i) {\\n        if (ints[i][1] < ni[0])\\n            res.push_back(ints[i]);\\n        else {\\n            ni[0] = min(ni[0], ints[i][0]);\\n            ni[1] = max(ni[1], ints[i][1]);\\n        }\\n    }\\n    res.push_back(ni);\\n    res.insert(end(res), begin(ints) + i, end(ints));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395709,
                "title": "beautiful-rust-solution-o-n-0-ms",
                "content": "As straightforward as possible.\\nAvoided most of heap memory allocation in method.\\n\\n```\\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::cmp::{min, max};\\n        let mut less = vec![];\\n        let mut more = vec![];\\n        let mut start = new_interval[0];\\n        let mut end = new_interval[1];\\n        \\n        for curr in intervals{\\n            if curr[1] < new_interval[0]{\\n                less.push(curr);\\n            }\\n            else if curr[0]>new_interval[1]{\\n                more.push(curr);\\n            }\\n            else {\\n                start = min(curr[0], start);\\n                end = max(curr[1], end);\\n            }\\n        }\\n        less.push(vec![start, end]);\\n        less.append(&mut more);\\n        less\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::cmp::{min, max};\\n        let mut less = vec![];\\n        let mut more = vec![];\\n        let mut start = new_interval[0];\\n        let mut end = new_interval[1];\\n        \\n        for curr in intervals{\\n            if curr[1] < new_interval[0]{\\n                less.push(curr);\\n            }\\n            else if curr[0]>new_interval[1]{\\n                more.push(curr);\\n            }\\n            else {\\n                start = min(curr[0], start);\\n                end = max(curr[1], end);\\n            }\\n        }\\n        less.push(vec![start, end]);\\n        less.append(&mut more);\\n        less\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289422,
                "title": "simple-java-solution-with-new-signature-1ms",
                "content": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        for (int[] interval : intervals) {\\n\\t\\t   // If not overlapped, we always add the smaller one to the result and point newInterval to the larger one.\\n            if (newInterval[1] < interval[0]) {\\n                result.add(newInterval);\\n                newInterval = interval;\\n            } else if (newInterval[0] > interval[1]) {\\n                result.add(interval);\\n            } else {\\n\\t\\t\\t// If overlapped, update the newInterval\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        result.add(newInterval);\\n        return result.toArray(new int[][]{});\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        for (int[] interval : intervals) {\\n\\t\\t   // If not overlapped, we always add the smaller one to the result and point newInterval to the larger one.\\n            if (newInterval[1] < interval[0]) {\\n                result.add(newInterval);\\n                newInterval = interval;\\n            } else if (newInterval[0] > interval[1]) {\\n                result.add(interval);\\n            } else {\\n\\t\\t\\t// If overlapped, update the newInterval\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        result.add(newInterval);\\n        return result.toArray(new int[][]{});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21595,
                "title": "c-clean-code",
                "content": "**Steps**\\n1. add all intervals smaller than newitv to the new array\\n2. merge all intervals overlap with newitv, then add the merged interval to the new array;\\n3. add all intervals that is leftover (no overlap) into the new array;\\n```\\nclass Solution {\\npublic:\\n    vector<Interval> insert(vector<Interval>& a, Interval newitv) {\\n        vector<Interval> res;\\n        int i = 0;\\n        for (; i < a.size() && a[i].end < newitv.start; i++) res.push_back(a[i]);\\n        \\n        for (; i < a.size() && max(a[i].start, newitv.start) <= min(a[i].end, newitv.end); i++) {\\n            newitv.start = min(a[i].start, newitv.start);\\n            newitv.end = max(a[i].end, newitv.end);\\n        }\\n        res.push_back(newitv);\\n\\n        for (; i < a.size(); i++) res.push_back(a[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<Interval> insert(vector<Interval>& a, Interval newitv) {\\n        vector<Interval> res;\\n        int i = 0;\\n        for (; i < a.size() && a[i].end < newitv.start; i++) res.push_back(a[i]);\\n        \\n        for (; i < a.size() && max(a[i].start, newitv.start) <= min(a[i].end, newitv.end); i++) {\\n            newitv.start = min(a[i].start, newitv.start);\\n            newitv.end = max(a[i].end, newitv.end);\\n        }\\n        res.push_back(newitv);\\n\\n        for (; i < a.size(); i++) res.push_back(a[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21776,
                "title": "my-18ms-c-code-with-explanation",
                "content": "        class Solution {\\n    public:\\n      std::vector<Interval> insert(std::vector<Interval> &intervals, Interval newInterval) {\\n    \\n        auto partial_order =[](const Interval & a, const Interval & b){\\n          return a.end < b.start;\\n        };\\n    \\n        auto less = std::lower_bound(intervals.begin(), intervals.end(), newInterval, partial_order);\\n    \\n        auto greater = std::upper_bound(intervals.begin(), intervals.end(), newInterval, partial_order);\\n        //printf(\"The index position: %d %d\\\\n\", less - intervals.begin(), greater - intervals.begin());\\n        std::vector<Interval> answer; \\n    \\n        answer.insert(answer.end(), intervals.begin(), less);\\n        answer.push_back(mergeEqual(less, greater, newInterval));\\n        answer.insert(answer.end(), greater, intervals.end());\\n        return answer;\\n      }\\n    \\n    private:\\n    \\n      // Merge the new interval with an array of intervals, all intervals in the \\n      // array equal with the new interval in terms of the partial order we \\n      // defined.\\n      // In other words all of them are overlapped with the new interval.\\n    \\n      Interval mergeEqual(const std::vector<Interval>::iterator & first, const std::vector<Interval>::iterator & last, const Interval &target){\\n    \\n        Interval answer(target);\\n        if(first < last){\\n          answer = merge(answer, *first);\\n          answer = merge(answer, *(last-1));\\n        }\\n        return answer;\\n      }\\n      // Merge two overlapped intervals.\\n      Interval merge(const Interval & a, const Interval & b) {\\n        return Interval(std::min(a.start, b.start), std::max(a.end, b.end));\\n      }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n      std::vector<Interval> insert(std::vector<Interval> &intervals, Interval newInterval) {\\n    \\n        auto partial_order =[](const Interval & a, const Interval & b){\\n          return a.end < b.start;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21844,
                "title": "concise-solution-using-stl",
                "content": "use lower_bound find the left and right bound of newinterval, step back or forward if need.\\n\\n\\n    bool comp1(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.start < rhs.start;\\n\\t}\\n\\tbool comp2(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.end < rhs.end;\\n\\t}\\n\\n\\tvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) \\n\\t{\\n\\t\\tvector<Interval>::iterator begin = lower_bound(intervals.begin(), intervals.end(), newInterval, comp1);\\n\\t\\tif(begin != intervals.begin() && (begin - 1)->end >= newInterval.start)\\n\\t\\t{\\n\\t\\t\\t--begin;\\n\\t\\t\\tnewInterval.start = begin->start;\\n\\t\\t}\\n\\n\\t\\tvector<Interval>::iterator end = lower_bound(intervals.begin(), intervals.end(), newInterval, comp2);\\t\\t\\n\\t\\tif(end != intervals.end() && end->start <= newInterval.end)\\n\\t\\t{\\n\\t\\t\\tnewInterval.end = end->end;\\n\\t\\t\\t++end;\\t\\t\\t\\n\\t\\t}\\n\\t\\tvector<Interval>::iterator t = intervals.erase(begin, end);\\n\\t\\tintervals.insert(t, newInterval);\\n\\n\\t\\treturn intervals;\\n\\t}",
                "solutionTags": [],
                "code": "use lower_bound find the left and right bound of newinterval, step back or forward if need.\\n\\n\\n    bool comp1(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.start < rhs.start;\\n\\t}\\n\\tbool comp2(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.end < rhs.end;\\n\\t}\\n\\n\\tvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) \\n\\t{\\n\\t\\tvector<Interval>::iterator begin = lower_bound(intervals.begin(), intervals.end(), newInterval, comp1);\\n\\t\\tif(begin != intervals.begin() && (begin - 1)->end >= newInterval.start)\\n\\t\\t{\\n\\t\\t\\t--begin;\\n\\t\\t\\tnewInterval.start = begin->start;\\n\\t\\t}\\n\\n\\t\\tvector<Interval>::iterator end = lower_bound(intervals.begin(), intervals.end(), newInterval, comp2);\\t\\t\\n\\t\\tif(end != intervals.end() && end->start <= newInterval.end)\\n\\t\\t{\\n\\t\\t\\tnewInterval.end = end->end;\\n\\t\\t\\t++end;\\t\\t\\t\\n\\t\\t}\\n\\t\\tvector<Interval>::iterator t = intervals.erase(begin, end);\\n\\t\\tintervals.insert(t, newInterval);\\n\\n\\t\\treturn intervals;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3734438,
                "title": "11-lines-of-clean-and-optimized-code-step-by-step-approach",
                "content": "# Approach:\\nMy approach to solving the problem is as follows:\\n\\n- Initialize an empty array for the left side of the intervals and another empty array for the right side.\\n- Iterate through each interval in the given intervals.\\n- Check if the current interval is completely before the new interval. If so, add it to the left array.\\n- Check if the current interval is completely after the new interval. If so, add it to the right array.\\n- If the current interval overlaps with the new interval, update the new interval\\'s start and end values to cover both intervals.\\n- Finally, combine the left array, the new interval, and the right array to get the result.\\n# Complexity:\\n- Time complexity: The time complexity of this approach is O(n), where n is the number of intervals.\\n- Space complexity: The space complexity is also O(n), where n is the number of intervals.\\n\\n# Code\\n```\\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\\n    let [newStart, newEnd] = newInterval, left = [], right = [];\\n    for( let int of intervals ){\\n        let [start, end] = int;\\n        if( end < newStart )left.push(int);\\n        else if( start > newEnd )right.push(int);\\n        else {\\n            newStart = Math.min(start, newStart);\\n            newEnd = Math.max(end, newEnd);\\n        }\\n    }\\n    return [...left, [newStart, newEnd], ...right]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\\n    let [newStart, newEnd] = newInterval, left = [], right = [];\\n    for( let int of intervals ){\\n        let [start, end] = int;\\n        if( end < newStart )left.push(int);\\n        else if( start > newEnd )right.push(int);\\n        else {\\n            newStart = Math.min(start, newStart);\\n            newEnd = Math.max(end, newEnd);\\n        }\\n    }\\n    return [...left, [newStart, newEnd], ...right]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467746,
                "title": "awesome-logic-python3",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        list1=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                list1.append(newInterval)\\n                return list1+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                list1.append(intervals[i])\\n            else:\\n                newInterval=[min(newInterval[0],intervals[i][0]),max(intervals[i][1],newInterval[1])]\\n        list1.append(newInterval)\\n        return list1\\n                \\n````\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        list1=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                list1.append(newInterval)\\n                return list1+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                list1.append(intervals[i])\\n            else:\\n                newInterval=[min(newInterval[0],intervals[i][0]),max(intervals[i][1],newInterval[1])]\\n        list1.append(newInterval)\\n        return list1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248191,
                "title": "easy-java-solution-3ms-solved-using-a-single-loop",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int [][] merged = new int[intervals.length+1][];\\n        int c = 0;\\n        for (int []i : intervals) {\\n            merged[c++] = i;\\n        }\\n        merged[intervals.length] = newInterval;\\n        Arrays.sort(merged , (a,b) -> Integer.compare(a[0], b[0]));\\n        List<int []> l1 = new ArrayList<>();\\n        for(int [] arr : merged){\\n            if(l1.size() == 0) l1.add(arr);\\n            else{\\n                int [] prevArr = l1.get(l1.size()-1);\\n                if(arr[0] <= prevArr[1]){\\n                    prevArr[1] = Math.max(prevArr[1] , arr[1]);\\n                }\\n                else l1.add(arr);\\n            }\\n        }\\n        return l1.toArray(new int[l1.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int [][] merged = new int[intervals.length+1][];\\n        int c = 0;\\n        for (int []i : intervals) {\\n            merged[c++] = i;\\n        }\\n        merged[intervals.length] = newInterval;\\n        Arrays.sort(merged , (a,b) -> Integer.compare(a[0], b[0]));\\n        List<int []> l1 = new ArrayList<>();\\n        for(int [] arr : merged){\\n            if(l1.size() == 0) l1.add(arr);\\n            else{\\n                int [] prevArr = l1.get(l1.size()-1);\\n                if(arr[0] <= prevArr[1]){\\n                    prevArr[1] = Math.max(prevArr[1] , arr[1]);\\n                }\\n                else l1.add(arr);\\n            }\\n        }\\n        return l1.toArray(new int[l1.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057348,
                "title": "c-same-logic-of-merge-intervals-2-pointers-comments-added",
                "content": "### Merge Interval Problem\\n### https://leetcode.com/problems/merge-intervals/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        // just remember the merge intervals problem\\n        // try to change this problem into that\\n        \\n        // add newInterval to the intervals\\n        intervals.push_back(newInterval);\\n        \\n        // now sort this\\n        sort(intervals.begin(),intervals.end());\\n        \\n        // now use the same logic that we used in merge intervals\\n        vector<vector<int>> ans;\\n        int n = intervals.size();\\n        int i=0,j=1;                                // using 2 pointers\\n        ans.push_back(intervals[i]);                // very first interval\\n        \\n        while(j<n)\\n        {\\n            // if my new interval is not overalpping with previous one then just add this\\n            if(intervals[j][0]>ans[i][1])\\n            {\\n                i++;                                // move previous pointer\\n                ans.push_back(intervals[j]);\\n            }\\n            // if it is overlapping then update prev second by curr second\\n            else\\n            {\\n                ans[i][1] = max(ans[i][1],intervals[j][1]);\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        // just remember the merge intervals problem\\n        // try to change this problem into that\\n        \\n        // add newInterval to the intervals\\n        intervals.push_back(newInterval);\\n        \\n        // now sort this\\n        sort(intervals.begin(),intervals.end());\\n        \\n        // now use the same logic that we used in merge intervals\\n        vector<vector<int>> ans;\\n        int n = intervals.size();\\n        int i=0,j=1;                                // using 2 pointers\\n        ans.push_back(intervals[i]);                // very first interval\\n        \\n        while(j<n)\\n        {\\n            // if my new interval is not overalpping with previous one then just add this\\n            if(intervals[j][0]>ans[i][1])\\n            {\\n                i++;                                // move previous pointer\\n                ans.push_back(intervals[j]);\\n            }\\n            // if it is overlapping then update prev second by curr second\\n            else\\n            {\\n                ans[i][1] = max(ans[i][1],intervals[j][1]);\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057029,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ (not considering answer array)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        bool inserted = false;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            // current interval can be merged with last ans interval\\n            int siz = ans.size();\\n            if (siz != 0 && ans[siz - 1][1] >= intervals[i][0]) {\\n                ans[siz - 1][1] = max(ans[siz - 1][1], intervals[i][1]);\\n                continue;\\n            }\\n            // newInterval complete dis-joint with current interval\\n            if (intervals[i][1] < newInterval[0]) {\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            if (intervals[i][0] > newInterval[1]) {\\n                if (!inserted) ans.push_back(newInterval);\\n                ans.push_back(intervals[i]);\\n                inserted = true;\\n                continue;\\n            }\\n\\n            // newInterval overlapping with current interval\\n            ans.push_back({min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])});\\n            inserted = true;\\n        }\\n        // still not inserted\\n        if (!inserted) ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        bool inserted = false;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            // current interval can be merged with last ans interval\\n            int siz = ans.size();\\n            if (siz != 0 && ans[siz - 1][1] >= intervals[i][0]) {\\n                ans[siz - 1][1] = max(ans[siz - 1][1], intervals[i][1]);\\n                continue;\\n            }\\n            // newInterval complete dis-joint with current interval\\n            if (intervals[i][1] < newInterval[0]) {\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            if (intervals[i][0] > newInterval[1]) {\\n                if (!inserted) ans.push_back(newInterval);\\n                ans.push_back(intervals[i]);\\n                inserted = true;\\n                continue;\\n            }\\n\\n            // newInterval overlapping with current interval\\n            ans.push_back({min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])});\\n            inserted = true;\\n        }\\n        // still not inserted\\n        if (!inserted) ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056927,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n      List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n         for (int i = 0; i < intervals.length; i ++) {\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n      List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n         for (int i = 0; i < intervals.length; i ++) {\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056577,
                "title": "python-o-n-beats-90-easy",
                "content": "**if you like the solution -- Please vote this code**\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ans=[]\\n        i=0\\n        \\n        while i<len(intervals) and newInterval[0]>intervals[i][1]:\\n            ans.append(intervals[i])\\n            i+=1\\n            \\n        while i<len(intervals) and intervals[i][0]<=newInterval[1]:\\n            newInterval[0]=min(intervals[i][0],newInterval[0])\\n            newInterval[1]=max(intervals[i][1],newInterval[1])\\n            i+=1\\n        ans.append(newInterval)\\n        \\n        while i<len(intervals):\\n            ans.append(intervals[i])\\n            i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ans=[]\\n        i=0\\n        \\n        while i<len(intervals) and newInterval[0]>intervals[i][1]:\\n            ans.append(intervals[i])\\n            i+=1\\n            \\n        while i<len(intervals) and intervals[i][0]<=newInterval[1]:\\n            newInterval[0]=min(intervals[i][0],newInterval[0])\\n            newInterval[1]=max(intervals[i][1],newInterval[1])\\n            i+=1\\n        ans.append(newInterval)\\n        \\n        while i<len(intervals):\\n            ans.append(intervals[i])\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733979,
                "title": "javascript-solution-based-on-merge-intervals",
                "content": "This solution is written based on the solution to **Merge Intervals** https://leetcode.com/problems/merge-intervals/\\n\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\n var insert = function(intervals, newInterval) {\\n    const n = intervals.length\\n    // insert interval based on newInterval[0]\\n\\t// note: can be improved by using binary search\\n    let idx = 0\\n    \\n    while (idx < n) {\\n        if (intervals[idx][0] >= newInterval[0]) {\\n            break\\n        }\\n        idx++\\n    }\\n    \\n    intervals.splice(idx, 0, newInterval)\\n    \\n    // after the newInterval is inserted\\n\\t// we need to handle overlapping intervals\\n    let i = 0\\n    \\n\\t// run until i is the last index on intervals\\n    while (i < intervals.length - 1) {\\n       \\n\\t   // does not overlap\\n\\t   if (intervals[i][1] < intervals[i+1][0]) {\\n            i++\\n            continue\\n        }\\n        \\n\\t\\t// overlap\\n        intervals[i][1] = Math.max(intervals[i+1][1], intervals[i][1])\\n        \\n\\t\\t// intervals[i] has absorbed intervals[i+1]\\n\\t\\t// remove intervals[i+1]\\n        intervals.splice(i+1,1)\\n    }\\n    \\n    return intervals\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\n var insert = function(intervals, newInterval) {\\n    const n = intervals.length\\n    // insert interval based on newInterval[0]\\n\\t// note: can be improved by using binary search\\n    let idx = 0\\n    \\n    while (idx < n) {\\n        if (intervals[idx][0] >= newInterval[0]) {\\n            break\\n        }\\n        idx++\\n    }\\n    \\n    intervals.splice(idx, 0, newInterval)\\n    \\n    // after the newInterval is inserted\\n\\t// we need to handle overlapping intervals\\n    let i = 0\\n    \\n\\t// run until i is the last index on intervals\\n    while (i < intervals.length - 1) {\\n       \\n\\t   // does not overlap\\n\\t   if (intervals[i][1] < intervals[i+1][0]) {\\n            i++\\n            continue\\n        }\\n        \\n\\t\\t// overlap\\n        intervals[i][1] = Math.max(intervals[i+1][1], intervals[i][1])\\n        \\n\\t\\t// intervals[i] has absorbed intervals[i+1]\\n\\t\\t// remove intervals[i+1]\\n        intervals.splice(i+1,1)\\n    }\\n    \\n    return intervals\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1319389,
                "title": "python3-1-pass-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        # skip all intervals that are strictly smaller than newInterval\\n        # i.e. interval[1] < newInterval[0]\\n        # after this while loop, `idx` will be the index of first interval that\\'s not strictly smaller than newInterval\\n        idx = 0\\n        while idx < len(intervals) and intervals[idx][1] < newInterval[0]:\\n            idx += 1\\n\\n        for i in range(idx, len(intervals)):\\n            interval = intervals[i]\\n            if interval[0] > newInterval[1]:\\n                # because `intervals` is sorted on start time and is non-overlapping, whenever an interval \\n                # is strictly larger than newInterval, we can skip the rest and return result\\n                return intervals[:idx] + [newInterval] + intervals[i:]\\n            # if interval is not strictly larger than newInterval, we can merge it and update newInterval\\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\\n\\n        return intervals[:idx] + [newInterval]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        # skip all intervals that are strictly smaller than newInterval\\n        # i.e. interval[1] < newInterval[0]\\n        # after this while loop, `idx` will be the index of first interval that\\'s not strictly smaller than newInterval\\n        idx = 0\\n        while idx < len(intervals) and intervals[idx][1] < newInterval[0]:\\n            idx += 1\\n\\n        for i in range(idx, len(intervals)):\\n            interval = intervals[i]\\n            if interval[0] > newInterval[1]:\\n                # because `intervals` is sorted on start time and is non-overlapping, whenever an interval \\n                # is strictly larger than newInterval, we can skip the rest and return result\\n                return intervals[:idx] + [newInterval] + intervals[i:]\\n            # if interval is not strictly larger than newInterval, we can merge it and update newInterval\\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\\n\\n        return intervals[:idx] + [newInterval]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096028,
                "title": "python-easy-solution-with-complete-explanation",
                "content": "The code is pretty staright forward \\nfirstly we are appending the new element in the interval and then sorting the array on ethe basis of first element and that it what lambda x:x[0] is doing. After that we are checking if len< 0 then its empty and returning the new element. Otherwise we are checking for the condtion for merging the intervals. So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index and after this condition is True and the intervals are merged we are just poping out the current i else we will continue till the end.\\n\\n        intervals.append(newInterval)\\n        intervals.sort(key = lambda x:x[0])\\n        print(intervals)\\n        \\n        if len(intervals)<0:\\n            return newInterval\\n        \\n        i = 1\\n\\n        while i < len(intervals):\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n                \\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i)\\n            else:\\n                i+=1\\n                continue\\n                \\n        return intervals\\n\\nUpvote if you find it helful",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The code is pretty staright forward \\nfirstly we are appending the new element in the interval and then sorting the array on ethe basis of first element and that it what lambda x:x[0] is doing. After that we are checking if len< 0 then its empty and returning the new element. Otherwise we are checking for the condtion for merging the intervals. So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index and after this condition is True and the intervals are merged we are just poping out the current i else we will continue till the end.\\n\\n        intervals.append(newInterval)\\n        intervals.sort(key = lambda x:x[0])\\n        print(intervals)\\n        \\n        if len(intervals)<0:\\n            return newInterval\\n        \\n        i = 1\\n\\n        while i < len(intervals):\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n                \\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i)\\n            else:\\n                i+=1\\n                continue\\n                \\n        return intervals\\n\\nUpvote if you find it helful",
                "codeTag": "Python3"
            },
            {
                "id": 741146,
                "title": "swift-simple-steps-o-n-complexity",
                "content": "Time: O(n), Space: O(n)\\n```\\nfunc insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tvar new = newInterval\\n\\tvar index = 0\\n\\n\\t// add the non-conflicting beginning\\n\\twhile index < intervals.count && intervals[index][1] < new[0] {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\t// merge the conflictions\\n\\twhile index < intervals.count && intervals[index][0] <= new[1] {\\n\\t\\tnew[0] = min(intervals[index][0], new[0])\\n\\t\\tnew[1] = max(intervals[index][1], new[1])\\n\\t\\tindex += 1\\n\\t}\\n\\tresult.append(new)\\n\\n\\t// add the rest\\n\\twhile index < intervals.count {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tvar new = newInterval\\n\\tvar index = 0\\n\\n\\t// add the non-conflicting beginning\\n\\twhile index < intervals.count && intervals[index][1] < new[0] {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\t// merge the conflictions\\n\\twhile index < intervals.count && intervals[index][0] <= new[1] {\\n\\t\\tnew[0] = min(intervals[index][0], new[0])\\n\\t\\tnew[1] = max(intervals[index][1], new[1])\\n\\t\\tindex += 1\\n\\t}\\n\\tresult.append(new)\\n\\n\\t// add the rest\\n\\twhile index < intervals.count {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502484,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> resultList = new ArrayList<>();\\n        \\n        for(int[] interval : intervals) {\\n            if(newInterval[0] > interval[1]) {\\n                resultList.add(interval);\\n            }\\n            else if(newInterval[1] < interval[0]) {\\n                resultList.add(newInterval);\\n                newInterval = interval;\\n            }\\n            else {\\n                int[] merged = new int[] {Math.min(newInterval[0], interval[0]), Math.max(newInterval[1], interval[1])};\\n                newInterval = merged;\\n            }\\n        }\\n        resultList.add(newInterval);\\n        \\n        return resultList.toArray(new int[resultList.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> resultList = new ArrayList<>();\\n        \\n        for(int[] interval : intervals) {\\n            if(newInterval[0] > interval[1]) {\\n                resultList.add(interval);\\n            }\\n            else if(newInterval[1] < interval[0]) {\\n                resultList.add(newInterval);\\n                newInterval = interval;\\n            }\\n            else {\\n                int[] merged = new int[] {Math.min(newInterval[0], interval[0]), Math.max(newInterval[1], interval[1])};\\n                newInterval = merged;\\n            }\\n        }\\n        resultList.add(newInterval);\\n        \\n        return resultList.toArray(new int[resultList.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463679,
                "title": "java-10-lines-o-n-1ms",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] next: intervals) {\\n            if (next[1]<newInterval[0]) list.add(next);\\n            else if (newInterval[1]<next[0]) {\\n                list.add(newInterval);\\n                newInterval = next;\\n            }\\n            else newInterval = new int[]{Math.min(newInterval[0], next[0]), Math.max(newInterval[1], next[1])};\\n        }\\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] next: intervals) {\\n            if (next[1]<newInterval[0]) list.add(next);\\n            else if (newInterval[1]<next[0]) {\\n                list.add(newInterval);\\n                newInterval = next;\\n            }\\n            else newInterval = new int[]{Math.min(newInterval[0], next[0]), Math.max(newInterval[1], next[1])};\\n        }\\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689977,
                "title": "easy-to-understand-c-solution-o-n",
                "content": "# Intution & Approach\\n# Use three loops.\\n1.) Insert all the intervals which are strictly lesser than the new Interval.\\n2.)(When the new interval is overlaping) In second loop maintain a start and end variable and find the start point and end point of interval and insert that interval in resultant vector.\\n3.)When the intervals values are strictly greater than the new interval insert all the intervals till end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i=0;\\n        bool flag=false;\\n        int start=newInterval[0];;\\n        int end=newInterval[1];\\n// Insert all the intervals which are strictly lesser than the new Interval.\\n        while(i<intervals.size() && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n// Overlapping intervals\\n        while(i<intervals.size() && intervals[i][0]<=newInterval[1])\\n        {\\n            \\n            start=min(intervals[i][0],start);\\n            end=max(intervals[i][1],end);\\n            i++;\\n        }\\n//Strictly Greater intervals\\n        result.push_back({start,end});\\n        while(i<intervals.size())\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n       \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i=0;\\n        bool flag=false;\\n        int start=newInterval[0];;\\n        int end=newInterval[1];\\n// Insert all the intervals which are strictly lesser than the new Interval.\\n        while(i<intervals.size() && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n// Overlapping intervals\\n        while(i<intervals.size() && intervals[i][0]<=newInterval[1])\\n        {\\n            \\n            start=min(intervals[i][0],start);\\n            end=max(intervals[i][1],end);\\n            i++;\\n        }\\n//Strictly Greater intervals\\n        result.push_back({start,end});\\n        while(i<intervals.size())\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n       \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057287,
                "title": "c-easy-to-understand-beats-75",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& ne) {\\n        intervals.push_back(ne);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int j=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[j][1]>=intervals[i][0]){\\n                intervals[j][1]=max(intervals[j][1],intervals[i][1]);\\n               \\n            }\\n            else{\\n                j++;\\n                intervals[j]=intervals[i];\\n            }\\n        }\\n        \\n       for(int i=0;i<=j;i++){\\n           ans.push_back(intervals[i]);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& ne) {\\n        intervals.push_back(ne);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int j=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[j][1]>=intervals[i][0]){\\n                intervals[j][1]=max(intervals[j][1],intervals[i][1]);\\n               \\n            }\\n            else{\\n                j++;\\n                intervals[j]=intervals[i];\\n            }\\n        }\\n        \\n       for(int i=0;i<=j;i++){\\n           ans.push_back(intervals[i]);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057001,
                "title": "c-easy-solution-using-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\\n        vector<int>a,b;\\n        vector<vector<int>>ans;\\n        for(auto &val:inter){\\n            a.push_back(val[0]);\\n            b.push_back(val[1]);\\n        }\\n        int x=upper_bound(a.begin(),a.end(),nInter[0])-a.begin()-1;\\n        int y=upper_bound(a.begin(),a.end(),nInter[1])-a.begin()-1;\\n        \\n        \\n        if(x==y){\\n            if(x==-1){\\n                ans.push_back(nInter);\\n                for(int i=0;i<inter.size();i++){\\n                    ans.push_back(inter[i]);\\n                    \\n                }\\n                return ans;\\n            }\\n            else{\\n                if(nInter[0]>inter[x][1]){\\n                    for(int i=0;i<inter.size();i++){\\n                        ans.push_back(inter[i]);\\n                        if(i==x){\\n                            ans.push_back(nInter);\\n                        }\\n                        \\n                    }\\n                    return ans;\\n                }\\n            }\\n        }\\n        bool flag=true;\\n        for(int i=0;i<inter.size();i++){\\n            if(flag&&(i==x||x==-1)){\\n                if(x!=-1&&inter[x][1]<nInter[0]){\\n                    ans.push_back(inter[x]);\\n                }\\n                ans.push_back({min(nInter[0],inter[x+(x==-1||inter[x][1]<nInter[0])][0]),max(nInter[1],inter[y][1])});\\n                i=y;\\n                flag=false;\\n            }\\n            else{\\n                ans.push_back(inter[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n**Please Upvote it really Motivates me**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\\n        vector<int>a,b;\\n        vector<vector<int>>ans;\\n        for(auto &val:inter){\\n            a.push_back(val[0]);\\n            b.push_back(val[1]);\\n        }\\n        int x=upper_bound(a.begin(),a.end(),nInter[0])-a.begin()-1;\\n        int y=upper_bound(a.begin(),a.end(),nInter[1])-a.begin()-1;\\n        \\n        \\n        if(x==y){\\n            if(x==-1){\\n                ans.push_back(nInter);\\n                for(int i=0;i<inter.size();i++){\\n                    ans.push_back(inter[i]);\\n                    \\n                }\\n                return ans;\\n            }\\n            else{\\n                if(nInter[0]>inter[x][1]){\\n                    for(int i=0;i<inter.size();i++){\\n                        ans.push_back(inter[i]);\\n                        if(i==x){\\n                            ans.push_back(nInter);\\n                        }\\n                        \\n                    }\\n                    return ans;\\n                }\\n            }\\n        }\\n        bool flag=true;\\n        for(int i=0;i<inter.size();i++){\\n            if(flag&&(i==x||x==-1)){\\n                if(x!=-1&&inter[x][1]<nInter[0]){\\n                    ans.push_back(inter[x]);\\n                }\\n                ans.push_back({min(nInter[0],inter[x+(x==-1||inter[x][1]<nInter[0])][0]),max(nInter[1],inter[y][1])});\\n                i=y;\\n                flag=false;\\n            }\\n            else{\\n                ans.push_back(inter[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056444,
                "title": "daily-leetcoding-challenge-january-day-16",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-interval/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Linear Search\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-interval/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2489404,
                "title": "c-easy-and-concise",
                "content": "```\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto &it : intervals) {\\n            if(it[1] >= newInterval[0] and it[0] <= newInterval[1]) {\\n                newInterval[0] = min(it[0],newInterval[0]);\\n                newInterval[1] = max(it[1],newInterval[1]);\\n            }\\n            else {\\n                if(it[0] > newInterval[0]) \\n                    swap(it,newInterval);\\n                ans.push_back(it);\\n            }\\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto &it : intervals) {\\n            if(it[1] >= newInterval[0] and it[0] <= newInterval[1]) {\\n                newInterval[0] = min(it[0],newInterval[0]);\\n                newInterval[1] = max(it[1],newInterval[1]);\\n            }\\n            else {\\n                if(it[0] > newInterval[0]) \\n                    swap(it,newInterval);\\n                ans.push_back(it);\\n            }\\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2435713,
                "title": "c-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    // merge intervals.\\n    vector<vector<int>> merge(vector<vector<int>>&ans,int n)\\n    {\\n        vector<vector<int>>res;\\n        res.push_back(ans[0]);\\n        int prev=res[0][1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i][0]<=prev)\\n            {\\n                res[res.size()-1][1]=max(res[res.size()-1][1],ans[i][1]);\\n                prev=res[res.size()-1][1];\\n            }\\n            else\\n            {\\n                res.push_back(ans[i]);\\n                prev=ans[i][1];\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n=intervals.size();\\n        // Adding interval \\n        vector<vector<int>>ans;\\n        bool first=false;\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(!first && intervals[i][0]>=newInterval[0])\\n            {\\n                ans.push_back(newInterval);\\n                first=true;\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                i++;\\n            }\\n        }\\n        if(!first)\\n            ans.push_back(newInterval);\\n \\n        // merge intervals\\n        return merge(ans,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // merge intervals.\\n    vector<vector<int>> merge(vector<vector<int>>&ans,int n)\\n    {\\n        vector<vector<int>>res;\\n        res.push_back(ans[0]);\\n        int prev=res[0][1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i][0]<=prev)\\n            {\\n                res[res.size()-1][1]=max(res[res.size()-1][1],ans[i][1]);\\n                prev=res[res.size()-1][1];\\n            }\\n            else\\n            {\\n                res.push_back(ans[i]);\\n                prev=ans[i][1];\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n=intervals.size();\\n        // Adding interval \\n        vector<vector<int>>ans;\\n        bool first=false;\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(!first && intervals[i][0]>=newInterval[0])\\n            {\\n                ans.push_back(newInterval);\\n                first=true;\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                i++;\\n            }\\n        }\\n        if(!first)\\n            ans.push_back(newInterval);\\n \\n        // merge intervals\\n        return merge(ans,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271812,
                "title": "python-simplest-solution-with-explanation-beg-to-adv-interval",
                "content": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        if len(intervals) < 2 and len(newInterval) == 0: # if there is only one element in the provided list and if htere is no element in newInterval\\n            return intervals # then just return interval. \\n      \\n        intervals.append(newInterval) # merging both the lists.\\n        \\n        # Below is the same program for merge interval, as we have to return a list with overlape. \\n        \\n        intervals.sort()# Sorting the list, if we dont then we wont be able to check for the overlapping intervals.\\n        start = intervals[0][0] # saving first element of the sublist in a variable for comparing it. \\n        end = intervals[0][1] # saving second element of the sublist in a variable for comparing it. \\n        res = [] # crerating a empty list for saving the result. \\n        \\n        for i in range(1, len(intervals)):# traversing the list from 1 as 0th element of the list is allocated to the variables, start & end.\\n            interval = intervals[i]# assigning i`th element to the a variable for performing the logic.\\n            if interval[0]<=end: # overlapping intervals\\n                end = max(interval[1], end)\\n            else:  # non-overlapping interval, add the previous interval and reset\\n                res.append([start, end])\\n                start = interval[0] # updating start variable with current interval element.\\n                end = interval[1]# updating end variable with current interval element.\\n        res.append([start, end])  # add the last interval\\n        return res\\n```\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        if len(intervals) < 2 and len(newInterval) == 0: # if there is only one element in the provided list and if htere is no element in newInterval\\n            return intervals # then just return interval. \\n      \\n        intervals.append(newInterval) # merging both the lists.\\n        \\n        # Below is the same program for merge interval, as we have to return a list with overlape. \\n        \\n        intervals.sort()# Sorting the list, if we dont then we wont be able to check for the overlapping intervals.\\n        start = intervals[0][0] # saving first element of the sublist in a variable for comparing it. \\n        end = intervals[0][1] # saving second element of the sublist in a variable for comparing it. \\n        res = [] # crerating a empty list for saving the result. \\n        \\n        for i in range(1, len(intervals)):# traversing the list from 1 as 0th element of the list is allocated to the variables, start & end.\\n            interval = intervals[i]# assigning i`th element to the a variable for performing the logic.\\n            if interval[0]<=end: # overlapping intervals\\n                end = max(interval[1], end)\\n            else:  # non-overlapping interval, add the previous interval and reset\\n                res.append([start, end])\\n                start = interval[0] # updating start variable with current interval element.\\n                end = interval[1]# updating end variable with current interval element.\\n        res.append([start, end])  # add the last interval\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159738,
                "title": "kotlin-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\\n        \\n\\n        var ans = mutableListOf<IntArray>()\\n        \\n        \\n        var start = newInterval[0]\\n        var end = newInterval[1]\\n        \\n        var counter = 0\\n        \\n        // get the intervals which are smaller than the newInterval\\n        while(counter < intervals.size && intervals[counter][1] < start) ans.add(intervals[counter++])\\n        \\n        // check if any overlapping exist and define the boundraies for the merged intervals\\n        while(counter < intervals.size && intervals[counter][0] <= end){\\n            start = Math.min(intervals[counter][0],start)\\n            end = Math.max(intervals[counter++][1],end)\\n        }\\n        \\n        // add the merged intervals\\n        ans.add(intArrayOf(start,end))\\n        \\n        // add the remaining part that its size is larger than the merged part\\n        while(counter < intervals.size) ans.add(intervals[counter++])\\n\\n        return ans.toTypedArray()\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\\n        \\n\\n        var ans = mutableListOf<IntArray>()\\n        \\n        \\n        var start = newInterval[0]\\n        var end = newInterval[1]\\n        \\n        var counter = 0\\n        \\n        // get the intervals which are smaller than the newInterval\\n        while(counter < intervals.size && intervals[counter][1] < start) ans.add(intervals[counter++])\\n        \\n        // check if any overlapping exist and define the boundraies for the merged intervals\\n        while(counter < intervals.size && intervals[counter][0] <= end){\\n            start = Math.min(intervals[counter][0],start)\\n            end = Math.max(intervals[counter++][1],end)\\n        }\\n        \\n        // add the merged intervals\\n        ans.add(intArrayOf(start,end))\\n        \\n        // add the remaining part that its size is larger than the merged part\\n        while(counter < intervals.size) ans.add(intervals[counter++])\\n\\n        return ans.toTypedArray()\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105125,
                "title": "east-to-understand-c-solution-very-intuitive",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &new_interval)\\n    {\\n        vector<vector<int>> res;\\n        int n = intervals.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int low = max(intervals[i][0], new_interval[0]);\\n            int high = min(intervals[i][1], new_interval[1]);\\n\\n            // overlapping condition\\n            if (low <= high)\\n            {\\n                int union_low = min(intervals[i][0], new_interval[0]);\\n                int union_high = max(intervals[i][1], new_interval[1]);\\n\\n                new_interval = {union_low, union_high};\\n            }\\n            else\\n            {\\n                if (intervals[i][1] < new_interval[0])\\n                {\\n                    res.push_back(intervals[i]);\\n                }\\n                else if (new_interval[1] < intervals[i][0])\\n                {\\n                    res.push_back(new_interval);\\n                    new_interval = intervals[i];\\n                }\\n            }\\n        }\\n        res.push_back(new_interval);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &new_interval)\\n    {\\n        vector<vector<int>> res;\\n        int n = intervals.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int low = max(intervals[i][0], new_interval[0]);\\n            int high = min(intervals[i][1], new_interval[1]);\\n\\n            // overlapping condition\\n            if (low <= high)\\n            {\\n                int union_low = min(intervals[i][0], new_interval[0]);\\n                int union_high = max(intervals[i][1], new_interval[1]);\\n\\n                new_interval = {union_low, union_high};\\n            }\\n            else\\n            {\\n                if (intervals[i][1] < new_interval[0])\\n                {\\n                    res.push_back(intervals[i]);\\n                }\\n                else if (new_interval[1] < intervals[i][0])\\n                {\\n                    res.push_back(new_interval);\\n                    new_interval = intervals[i];\\n                }\\n            }\\n        }\\n        res.push_back(new_interval);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075054,
                "title": "c-easy-o-n",
                "content": "\\n\\n```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        int i=0;\\n\\t\\t\\n\\t\\t//Insert the interval in sorted order\\n        while(i<intervals.size() && newInterval[0]>intervals[i][0])\\n            i++;\\n        intervals.insert(intervals.begin()+i,newInterval);\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n\\t\\t/*If end of previous inserted interval end value  is less than next Interval end value then only we have to consider it otherwise \\n\\t\\t\\tdiscard and move ahead . If true check whether the current interval is overlapping with the next then merge and Push . If not just push interval in the ans vector. */\\n            if(ans[j][1] <= intervals[i][1])\\n            if(ans[j][1]>=intervals[i][0])\\n                ans[j][1] = intervals[i][1];\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        int i=0;\\n\\t\\t\\n\\t\\t//Insert the interval in sorted order\\n        while(i<intervals.size() && newInterval[0]>intervals[i][0])\\n            i++;\\n        intervals.insert(intervals.begin()+i,newInterval);\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n\\t\\t/*If end of previous inserted interval end value  is less than next Interval end value then only we have to consider it otherwise \\n\\t\\t\\tdiscard and move ahead . If true check whether the current interval is overlapping with the next then merge and Push . If not just push interval in the ans vector. */\\n            if(ans[j][1] <= intervals[i][1])\\n            if(ans[j][1]>=intervals[i][0])\\n                ans[j][1] = intervals[i][1];\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680989,
                "title": "easy-faster-than-91-72-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto x: intervals){\\n            if(x[1]<newInterval[0]){\\n                ans.push_back(x);\\n            }else if(x[0]>newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = x;\\n            }else{\\n                newInterval[0] = min(x[0],newInterval[0]);\\n                newInterval[1] = max(x[1],newInterval[1]);\\n            }            \\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto x: intervals){\\n            if(x[1]<newInterval[0]){\\n                ans.push_back(x);\\n            }else if(x[0]>newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = x;\\n            }else{\\n                newInterval[0] = min(x[0],newInterval[0]);\\n                newInterval[1] = max(x[1],newInterval[1]);\\n            }            \\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877685,
                "title": "java-solution-with-figures-diagrams-easy-3-step-process-update-with-new-signature",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> out = new ArrayList<>();\\n        int i = 0;\\n        \\n        /*\\n        Step 1.\\n        Add all intervals before newInterval (that don\\'t overlap with newInterval so just 1 in this case\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------        \\n         */\\n        while( i<intervals.length && intervals[i][1] < newInterval[0] ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        // \\n        /*\\n        Step 2.\\n        Now i is at an interval that we merge with OR that we don\\'t merge with (case B)\\n        Case A.\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------   \\n\\n        Case B.\\n            1.                          2.  \\n          -----                       ------\\n                    -------------   \\n                    \\n        \"intervals[i][0] <= newInterval[1]\" below means if the current interval\\'s start is before or \\n\\t\\tat the newIntervals end, it should be part of the merge interval. Look at the diagram,\\n\\t\\tin case A it is easy to see 4. is the last interval we take. In case B. there are no intervals so the while never loops\\n         */\\n        while( i<intervals.length && intervals[i][0] <= newInterval[1] ){\\n            newInterval[0] = Math.min( newInterval[0], intervals[i][0] ); \\n            newInterval[1] = Math.max( newInterval[1], intervals[i][1] ); \\n            i++;\\n        }\\n        \\n\\t\\t// Add the insert interval\\n        out.add(newInterval);\\n        \\n        // Step 3. Add all of the intervals that come after the inserted interval if any\\n        while( i<intervals.length ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        return out.toArray(new int[out.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> out = new ArrayList<>();\\n        int i = 0;\\n        \\n        /*\\n        Step 1.\\n        Add all intervals before newInterval (that don\\'t overlap with newInterval so just 1 in this case\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------        \\n         */\\n        while( i<intervals.length && intervals[i][1] < newInterval[0] ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        // \\n        /*\\n        Step 2.\\n        Now i is at an interval that we merge with OR that we don\\'t merge with (case B)\\n        Case A.\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------   \\n\\n        Case B.\\n            1.                          2.  \\n          -----                       ------\\n                    -------------   \\n                    \\n        \"intervals[i][0] <= newInterval[1]\" below means if the current interval\\'s start is before or \\n\\t\\tat the newIntervals end, it should be part of the merge interval. Look at the diagram,\\n\\t\\tin case A it is easy to see 4. is the last interval we take. In case B. there are no intervals so the while never loops\\n         */\\n        while( i<intervals.length && intervals[i][0] <= newInterval[1] ){\\n            newInterval[0] = Math.min( newInterval[0], intervals[i][0] ); \\n            newInterval[1] = Math.max( newInterval[1], intervals[i][1] ); \\n            i++;\\n        }\\n        \\n\\t\\t// Add the insert interval\\n        out.add(newInterval);\\n        \\n        // Step 3. Add all of the intervals that come after the inserted interval if any\\n        while( i<intervals.length ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        return out.toArray(new int[out.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864312,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        left, merge, right = [], [], []\\n        for x in intervals: # credit to @StefanPochmann\\n            if x[0] > e:\\n                right.append(x)\\n            elif x[1] < s:\\n                left.append(x)\\n            else:\\n                merge.append(x)\\n        if merge:\\n            s = min(merge[0][0], s)\\n            e = max(merge[-1][1], e)\\n            \\n        return left + [[s,e]] + right\\n            \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        left, merge, right = [], [], []\\n        for x in intervals: # credit to @StefanPochmann\\n            if x[0] > e:\\n                right.append(x)\\n            elif x[1] < s:\\n                left.append(x)\\n            else:\\n                merge.append(x)\\n        if merge:\\n            s = min(merge[0][0], s)\\n            e = max(merge[-1][1], e)\\n            \\n        return left + [[s,e]] + right\\n            \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602609,
                "title": "simple-python-o-n-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals, new):\\n        \\n        merged,t,l = [], 0, len(intervals)       \\n        for curr in intervals:\\n            \\n            # If interval[i] completely smaller than new one\\n            if new[0]>curr[1]:\\n                merged.append(curr)\\n             \\n            # If interval[i] completely greater than new\\n            elif curr[0]>new[1]:\\n                break\\n             \\n            # If interval[i] is overlapping with new\\n            else:              \\n                # choose minm and maxm boundaries from both\\n                new[0] = min(new[0], curr[0])\\n                new[1] = max(new[1], curr[1])\\n            \\n            t+=1\\n            \\n        # Apeending last new interval\\n        merged.append(new)\\n        \\n        # Now understand this part\\n        # i) If new part extend till end than simply return merged ones\\n        # ii) If not till end than return merged + remainling intervals\\n        return merged+intervals[t:] if t<l else merged\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, new):\\n        \\n        merged,t,l = [], 0, len(intervals)       \\n        for curr in intervals:\\n            \\n            # If interval[i] completely smaller than new one\\n            if new[0]>curr[1]:\\n                merged.append(curr)\\n             \\n            # If interval[i] completely greater than new\\n            elif curr[0]>new[1]:\\n                break\\n             \\n            # If interval[i] is overlapping with new\\n            else:              \\n                # choose minm and maxm boundaries from both\\n                new[0] = min(new[0], curr[0])\\n                new[1] = max(new[1], curr[1])\\n            \\n            t+=1\\n            \\n        # Apeending last new interval\\n        merged.append(new)\\n        \\n        # Now understand this part\\n        # i) If new part extend till end than simply return merged ones\\n        # ii) If not till end than return merged + remainling intervals\\n        return merged+intervals[t:] if t<l else merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562487,
                "title": "extremely-easy-understanding-java",
                "content": "All the intervals can be classified into three groups:\\n\\n1. non-overlapping interval ends before the `newInterval`\\n2. overlapping intervals\\n2. non-overlapping interval starts after the `newInterval`\\n\\nFor intervals in the first and third group, we don\\'t need to do anything rather than adding them to the result set.\\nFor the second group, we just merge their `startTime` and `endTime`, with our `newInterval`, and add the final merged interval to the result.\\n\\n```java\\nList<int[]> result = new ArrayList<>();\\nint index = 0;\\n// Add all non-overlapping intervals before the \\'newSpan\\'\\nwhile (index < intervals.length && intervals[index][1] < newSpan[0]) {\\n\\tresult.add(intervals[index++]);\\n}\\n// Merge all overlapping intervals into the newSpan\\nwhile (index < intervals.length && intervals[index][0] <= newSpan[1]) {\\n\\tint[] thisSpan = intervals[index++];\\n\\tnewSpan[0] = Math.min(thisSpan[0], newSpan[0]);\\n\\tnewSpan[1] = Math.max(thisSpan[1], newSpan[1]);\\n\\n}\\nresult.add(newSpan);  // return the merged newspan\\n\\n// Add all remaining non-overlapping intervals after the merged newSpan\\nwhile (index < intervals.length) {\\n\\tresult.add(intervals[index++]);\\n}\\n\\nreturn result.toArray(new int[result.size()][]);\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nList<int[]> result = new ArrayList<>();\\nint index = 0;\\n// Add all non-overlapping intervals before the \\'newSpan\\'\\nwhile (index < intervals.length && intervals[index][1] < newSpan[0]) {\\n\\tresult.add(intervals[index++]);\\n}\\n// Merge all overlapping intervals into the newSpan\\nwhile (index < intervals.length && intervals[index][0] <= newSpan[1]) {\\n\\tint[] thisSpan = intervals[index++];\\n\\tnewSpan[0] = Math.min(thisSpan[0], newSpan[0]);\\n\\tnewSpan[1] = Math.max(thisSpan[1], newSpan[1]);\\n\\n}\\nresult.add(newSpan);  // return the merged newspan\\n\\n// Add all remaining non-overlapping intervals after the merged newSpan\\nwhile (index < intervals.length) {\\n\\tresult.add(intervals[index++]);\\n}\\n\\nreturn result.toArray(new int[result.size()][]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499881,
                "title": "python-two-different-solutions",
                "content": "1. Using two pointers\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            return [newInterval]\\n        \\n        x = len(intervals)\\n        i = 0\\n        while(i<x and intervals[i][1]<newInterval[0]):\\n            i += 1\\n            \\n        j = i\\n        while(j<x and intervals[j][0]<=newInterval[1]):\\n            j += 1\\n\\n\\n        if i == j:\\n            ret = newInterval\\n        else:\\n            start = min(intervals[i][0], newInterval[0])\\n            end = max(intervals[j-1][1],newInterval[1])\\n            ret = [start,end]\\n            \\n        return intervals[:i] + [ret] + intervals[j:]\\n```\\n\\n2. Use previous solution\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        \\n        intervals.sort()\\n        \\n        merged=[]\\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0]:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n                \\n        return merged\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            return [newInterval]\\n        \\n        x = len(intervals)\\n        i = 0\\n        while(i<x and intervals[i][1]<newInterval[0]):\\n            i += 1\\n            \\n        j = i\\n        while(j<x and intervals[j][0]<=newInterval[1]):\\n            j += 1\\n\\n\\n        if i == j:\\n            ret = newInterval\\n        else:\\n            start = min(intervals[i][0], newInterval[0])\\n            end = max(intervals[j-1][1],newInterval[1])\\n            ret = [start,end]\\n            \\n        return intervals[:i] + [ret] + intervals[j:]\\n```\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        \\n        intervals.sort()\\n        \\n        merged=[]\\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0]:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n                \\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436879,
                "title": "javascript-solution-o-n",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let results = [];\\n    \\n    let i = 0;\\n    while(i < intervals.length && intervals[i][1] < newInterval[0]) {\\n        results.push(intervals[i]);\\n        i++;\\n    }\\n    \\n    newInterval = [Math.min(newInterval[0], i < intervals.length ? intervals[i][0] : Infinity), newInterval[1]];    \\n                                       \\n    while(i < intervals.length && newInterval[1] >= intervals[i][0]) {\\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n        i++;\\n    }       \\n    results.push(newInterval);\\n   return results.concat(intervals.slice(i, intervals.length));\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let results = [];\\n    \\n    let i = 0;\\n    while(i < intervals.length && intervals[i][1] < newInterval[0]) {\\n        results.push(intervals[i]);\\n        i++;\\n    }\\n    \\n    newInterval = [Math.min(newInterval[0], i < intervals.length ? intervals[i][0] : Infinity), newInterval[1]];    \\n                                       \\n    while(i < intervals.length && newInterval[1] >= intervals[i][0]) {\\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n        i++;\\n    }       \\n    results.push(newInterval);\\n   return results.concat(intervals.slice(i, intervals.length));\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 309024,
                "title": "c-98-beat-o-n-single-pass-looper-lew-pah-luu-purrrrr",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        vector<vector<int>> aResult;\\n        \\n        int aIndex = 0;\\n        while (aIndex < intervals.size() && intervals[aIndex][1] < newInterval[0]) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        while (aIndex < intervals.size() && intervals[aIndex][0] <= newInterval[1]) {\\n            newInterval[1] = max(newInterval[1], intervals[aIndex][1]);\\n            newInterval[0] = min(newInterval[0], intervals[aIndex][0]);\\n            ++aIndex;\\n        }\\n        aResult.push_back(newInterval);\\n        \\n        while (aIndex < intervals.size()) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\n$ Dolla Dolla Plz $$ TY",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        vector<vector<int>> aResult;\\n        \\n        int aIndex = 0;\\n        while (aIndex < intervals.size() && intervals[aIndex][1] < newInterval[0]) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        while (aIndex < intervals.size() && intervals[aIndex][0] <= newInterval[1]) {\\n            newInterval[1] = max(newInterval[1], intervals[aIndex][1]);\\n            newInterval[0] = min(newInterval[0], intervals[aIndex][0]);\\n            ++aIndex;\\n        }\\n        aResult.push_back(newInterval);\\n        \\n        while (aIndex < intervals.size()) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304135,
                "title": "go-8ms-6-2mb",
                "content": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    ret := make([][]int, 0)\\n    for i, v := range intervals {\\n\\t\\tif v[1] < newInterval[0] {\\n\\t\\t\\tret = append(ret, v)\\n            continue\\n\\t\\t}\\n        \\n        if v[0] > newInterval[1] {\\n            ret = append(ret, newInterval)\\n            ret = append(ret, intervals[i:]...)\\n            return ret\\n\\t\\t}\\n        \\n        newInterval[0] = min(newInterval[0], v[0])\\n        newInterval[1] = max(newInterval[1], v[1])\\n\\t}\\n    return append(ret, newInterval)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    ret := make([][]int, 0)\\n    for i, v := range intervals {\\n\\t\\tif v[1] < newInterval[0] {\\n\\t\\t\\tret = append(ret, v)\\n            continue\\n\\t\\t}\\n        \\n        if v[0] > newInterval[1] {\\n            ret = append(ret, newInterval)\\n            ret = append(ret, intervals[i:]...)\\n            return ret\\n\\t\\t}\\n        \\n        newInterval[0] = min(newInterval[0], v[0])\\n        newInterval[1] = max(newInterval[1], v[1])\\n\\t}\\n    return append(ret, newInterval)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279899,
                "title": "java-iteration-new-method-signature",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, size = intervals.length;\\n        while(i< size && intervals[i][1] < newInterval[0]){\\n            res.add(intervals[i]); \\n            i++;\\n        }\\n        while(i < size && intervals[i][0] <=  newInterval[1]){\\n           int[] cur = new int[]{Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])};\\n                newInterval = cur; \\n            i++;\\n        }\\n        res.add(newInterval);\\n        while(i < size){\\n            res.add(intervals[i]);\\n            i++;\\n        }\\n        int[][] insert = new int[res.size()][2];\\n        for(int j = 0; j < res.size(); j++){\\n            insert[j] = res.get(j);\\n        }\\n        return insert;\\n    }\\n}\\n```\\n\\nintervals[i][0] <= newInterval[1] is the key to create newInterval recursively.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, size = intervals.length;\\n        while(i< size && intervals[i][1] < newInterval[0]){\\n            res.add(intervals[i]); \\n            i++;\\n        }\\n        while(i < size && intervals[i][0] <=  newInterval[1]){\\n           int[] cur = new int[]{Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])};\\n                newInterval = cur; \\n            i++;\\n        }\\n        res.add(newInterval);\\n        while(i < size){\\n            res.add(intervals[i]);\\n            i++;\\n        }\\n        int[][] insert = new int[res.size()][2];\\n        for(int j = 0; j < res.size(); j++){\\n            insert[j] = res.get(j);\\n        }\\n        return insert;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180320,
                "title": "python-easy-solution-beat-100-36ms",
                "content": "I extract all the start time points from intervals to a list, all the end time points to another list. Then make use of binary search to check the position of the newInterval. Once I found out the position ( the overlapping duration), then I replace them with the new interval.\\n```\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :type newInterval: Interval\\n        :rtype: List[Interval]\\n        \"\"\"\\n        left, right = newInterval.start, newInterval.end\\n        start = [interval.start for interval in intervals]\\n        end = [interval.end for interval in intervals]\\n        i = bisect.bisect_left(start, left)\\n        j = bisect.bisect(end, right)\\n        if i > 0 and left <= intervals[i-1].end:\\n            left = intervals[i-1].start\\n            i = i - 1\\n        if j < len(intervals) and right >= intervals[j].start:\\n            right = intervals[j].end\\n            j = j + 1\\n        intervals[i:j] = [Interval(left, right)]\\n        return intervals\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :type newInterval: Interval\\n        :rtype: List[Interval]\\n        \"\"\"\\n        left, right = newInterval.start, newInterval.end\\n        start = [interval.start for interval in intervals]\\n        end = [interval.end for interval in intervals]\\n        i = bisect.bisect_left(start, left)\\n        j = bisect.bisect(end, right)\\n        if i > 0 and left <= intervals[i-1].end:\\n            left = intervals[i-1].start\\n            i = i - 1\\n        if j < len(intervals) and right >= intervals[j].start:\\n            right = intervals[j].end\\n            j = j + 1\\n        intervals[i:j] = [Interval(left, right)]\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21676,
                "title": "clean-and-short-java-solution-with-explanation",
                "content": "There are three cases with inserting an interval: \\n\\n 1. the start value of the newInterval < the old interval end:  insert the old interval and increment the index as we will know where this newInterval should be inserted.\\n 2.  the start value of the old interval > newInterval end:  we simply insert the old interval as there is no effect on where the newInterval should be inserted.\\n 3.  Otherwise, we need to merge the interval, simply be getting the min of start and max of end value.\\n\\nIn the end, we insert the newInterval based on the index we get on the fly.\\n\\n\\n    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            List<Interval> res = new ArrayList<>();\\n            int index = 0;\\n            for(int i = 0; i < intervals.size(); i++) {\\n                if(intervals.get(i).end < newInterval.start) {\\n                    res.add(intervals.get(i));\\n                    index++;\\n                } else if(intervals.get(i).start > newInterval.end) {\\n                    res.add(intervals.get(i));\\n                } else {\\n                    newInterval.start = Math.min(intervals.get(i).start, newInterval.start);\\n                    newInterval.end = Math.max(intervals.get(i).end, newInterval.end);\\n                }\\n            }\\n            res.add(index, newInterval);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            List<Interval> res = new ArrayList<>();\\n            int index = 0;\\n            for(int i = 0; i < intervals.size(); i++) {\\n                if(intervals.get(i).end < newInterval.start) {\\n                    res.add(intervals.get(i));\\n                    index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4077652,
                "title": "optimal-solution-o-n-line-by-line-commented-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int i = 0 ;\\n        int n = intervals.size();\\n        vector<vector<int>>result;\\n        while(i < intervals.size()){\\n          if(intervals[i][1] < newInterval[0]){\\n            result.push_back(intervals[i]);\\n          }\\n          else if(intervals[i][0] > newInterval[1]){\\n            break;   \\n          }\\n          else{ // merging step \\n        // newInterval\\'s starting point will be min. of starting point of both newIntervals and intervals\\n               newInterval[0] = min(newInterval[0] , intervals[i][0]);\\n               newInterval[1] = max(newInterval[1] , intervals[i][1]);\\n          }\\n          i++;\\n        }\\n        result.push_back(newInterval);\\n\\n        while(i < n ){ // if newInterval\\'s starting point will be greater than all given intervals\\'s stating point(we pass throuth loop)//\\n          result.push_back(intervals[i]);\\n          i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int i = 0 ;\\n        int n = intervals.size();\\n        vector<vector<int>>result;\\n        while(i < intervals.size()){\\n          if(intervals[i][1] < newInterval[0]){\\n            result.push_back(intervals[i]);\\n          }\\n          else if(intervals[i][0] > newInterval[1]){\\n            break;   \\n          }\\n          else{ // merging step \\n        // newInterval\\'s starting point will be min. of starting point of both newIntervals and intervals\\n               newInterval[0] = min(newInterval[0] , intervals[i][0]);\\n               newInterval[1] = max(newInterval[1] , intervals[i][1]);\\n          }\\n          i++;\\n        }\\n        result.push_back(newInterval);\\n\\n        while(i < n ){ // if newInterval\\'s starting point will be greater than all given intervals\\'s stating point(we pass throuth loop)//\\n          result.push_back(intervals[i]);\\n          i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929854,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        l = []\\n        for i in intervals:\\n            if i[1] < newInterval[0]:\\n                l.append(i)\\n            elif i[0] > newInterval[1]:\\n                l.append(newInterval)\\n                newInterval = i\\n            elif i[1] >= newInterval[0] or i[0] <= newInterval[1]:\\n                newInterval[0] = min(i[0],newInterval[0])\\n                newInterval[1] = max(newInterval[1],i[1])\\n        l.append(newInterval)\\n        return l\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        l = []\\n        for i in intervals:\\n            if i[1] < newInterval[0]:\\n                l.append(i)\\n            elif i[0] > newInterval[1]:\\n                l.append(newInterval)\\n                newInterval = i\\n            elif i[1] >= newInterval[0] or i[0] <= newInterval[1]:\\n                newInterval[0] = min(i[0],newInterval[0])\\n                newInterval[1] = max(newInterval[1],i[1])\\n        l.append(newInterval)\\n        return l\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057652,
                "title": "simple-easy-to-understand",
                "content": "# Complexity\n- Time complexity: **O(N)**\n\n- Space complexity: **O(1)** #if we ignore answer list\n\n# Code\n```\nclass Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res\n```\nIf you have any **doubt** ask me in comments and UpVote, if you like it **:)**",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057584,
                "title": "fastest-python-solution-explained",
                "content": "# Intuition\\nThe intuition is simple we just need to expand the values which come under same component i.e. connected\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind the starting index from where potential connection can occur so if ending value of any given interval is greater than equal to newInterval starting value then they can be connected.\\n\\nSimilarly, if ending index of newInterval is greater than equal to starting value of any given interval then they can be also in potential conection. so change index of end pointer to current index\\n\\nFinally if starting pointer(intially st=-1) has not changed at that means newIntwrval is greatest of all. Similarly if end pointer(initially end=-1) has never changed that means it is before the interval pointed by starting pointer(st) \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        st=-1\\n        end=-1\\n        n=len(intervals)\\n        if n==0:\\n            return [newInterval]\\n        for i in range(n):\\n            if st==-1:\\n                if newInterval[0]<=intervals[i][1]:\\n                    st=i\\n            if st!=-1:\\n                if newInterval[1]>=intervals[i][0]:\\n                    end=i+1\\n        if st==-1:\\n            intervals.append(newInterval)\\n        elif end==-1:\\n            intervals.insert(st,newInterval)\\n        else:\\n            ni=[min(newInterval[0],intervals[st][0]),max(newInterval[1],intervals[end-1][1])]\\n            intervals[st:end]=[ni]\\n        \\n        return intervals\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        st=-1\\n        end=-1\\n        n=len(intervals)\\n        if n==0:\\n            return [newInterval]\\n        for i in range(n):\\n            if st==-1:\\n                if newInterval[0]<=intervals[i][1]:\\n                    st=i\\n            if st!=-1:\\n                if newInterval[1]>=intervals[i][0]:\\n                    end=i+1\\n        if st==-1:\\n            intervals.append(newInterval)\\n        elif end==-1:\\n            intervals.insert(st,newInterval)\\n        else:\\n            ni=[min(newInterval[0],intervals[st][0]),max(newInterval[1],intervals[end-1][1])]\\n            intervals[st:end]=[ni]\\n        \\n        return intervals\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057502,
                "title": "live-coding-0-ms-and-beats-99-with-video-explanation-in-english-and-hindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMy approach in ENGLISH\\n\\nhttps://youtu.be/qTTqgwvfBZs\\n\\nIN HINDI\\n\\nhttps://youtu.be/rDGgpi1HUXk\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        List<int[]>ans = new ArrayList();\\n        for(int i=0;i<n;i++){\\n            if(intervals[i][1]<newInterval[0]){\\n                ans.add(intervals[i]);\\n            }\\n            else if(intervals[i][0]>newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            }else if(intervals[i][1]>=newInterval[0] || intervals[i][0]<=newInterval[1]){\\n                newInterval[0] = Math.min(newInterval[0],intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1],intervals[i][1]);\\n            }\\n        }\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        List<int[]>ans = new ArrayList();\\n        for(int i=0;i<n;i++){\\n            if(intervals[i][1]<newInterval[0]){\\n                ans.add(intervals[i]);\\n            }\\n            else if(intervals[i][0]>newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            }else if(intervals[i][1]>=newInterval[0] || intervals[i][0]<=newInterval[1]){\\n                newInterval[0] = Math.min(newInterval[0],intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1],intervals[i][1]);\\n            }\\n        }\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057466,
                "title": "c-begineer-friendly-easy-understanding-union-find-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BCBBfE0HV_0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n        vector<vector<int>>ans;\\n\\n        // 2 cases.\\n        for(auto currentInterval:intervals){\\n        //case 1 :non overlapping\\n        // new interval is after current interval. add current interval to the ans.\\n        if(currentInterval[1]<newInterval[0]){ans.push_back(currentInterval);}\\n        // if new interval comes before current interval that means we need to make it current interval and check for overlaping with others. And our new interval will also be add to ans.\\n        else if(newInterval[1]<currentInterval[0]){\\n                    ans.push_back(newInterval);\\n                    //update it to new interval for overlapping checking.\\n                    newInterval = currentInterval;\\n        }\\n        // case 2 :overlapping\\n        else{\\n            // update the newInterval for checking overlapping.\\n            newInterval[0] = min(currentInterval[0],newInterval[0]);\\n            newInterval[1] = max(currentInterval[1],newInterval[1]);\\n\\n        }\\n\\n        }\\n        // Add the last non overlaping interval (newInterval)\\n        ans.push_back(newInterval);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sort",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n        vector<vector<int>>ans;\\n\\n        // 2 cases.\\n        for(auto currentInterval:intervals){\\n        //case 1 :non overlapping\\n        // new interval is after current interval. add current interval to the ans.\\n        if(currentInterval[1]<newInterval[0]){ans.push_back(currentInterval);}\\n        // if new interval comes before current interval that means we need to make it current interval and check for overlaping with others. And our new interval will also be add to ans.\\n        else if(newInterval[1]<currentInterval[0]){\\n                    ans.push_back(newInterval);\\n                    //update it to new interval for overlapping checking.\\n                    newInterval = currentInterval;\\n        }\\n        // case 2 :overlapping\\n        else{\\n            // update the newInterval for checking overlapping.\\n            newInterval[0] = min(currentInterval[0],newInterval[0]);\\n            newInterval[1] = max(currentInterval[1],newInterval[1]);\\n\\n        }\\n\\n        }\\n        // Add the last non overlaping interval (newInterval)\\n        ans.push_back(newInterval);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057150,
                "title": "python-solution-using-binary-search-and-simple-merge-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition was to first iterate through the `intervals` and find correct index to insert `newInterval`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this approach I first found the correct index to insert the given interval, and then the key to this question is understanding how to merge the intervals, Thus following are the steps involved in the question:\\n1) find the position where new interval should be inserted based on the end time of the intervals given. (used binary search to optimize time)\\n2) for merging intervals take minimum of ( `intervals[k][0]` and `newInterval[0]` ) and maximum of ( `intervals[k][0]` and `newInterval[0]` )    \\nNote: here `k` is the index found using binary search\\n3) simply store it in new result list and return it.\\n\\nThis approach is quite fast:\\n![asdasd.PNG](https://assets.leetcode.com/users/images/91b1baa7-3f3b-40a4-9895-ea2e219b3134_1673846919.1683147.png)\\n\\n\\nHope it Helps!!\\n\\n# Code\\n```\\ndef binary_search(x, n):\\n    s = 0\\n    e = len(x) - 1\\n    while s<=e:\\n        mid = (s+e)//2\\n        if x[mid] == n:\\n            return mid\\n        elif x[mid] < n:\\n            s  = mid + 1\\n        else:\\n            e = mid - 1\\n    return e+1\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            intervals.append(newInterval)\\n            return intervals\\n        x = []\\n        for i in range(len(intervals)):\\n            x.append(intervals[i][1])\\n\\n        k = binary_search(x,newInterval[0])\\n        res = intervals[:k] #to store intervals till `k`th index\\n        while k < len(intervals) and intervals[k][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[k][0], newInterval[0])\\n            newInterval[1] = max(intervals[k][1], newInterval[1])\\n            k += 1\\n        res.append(newInterval)\\n        #adding remaining elements to the list\\n        res += intervals[k:]  \\n        return res        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\ndef binary_search(x, n):\\n    s = 0\\n    e = len(x) - 1\\n    while s<=e:\\n        mid = (s+e)//2\\n        if x[mid] == n:\\n            return mid\\n        elif x[mid] < n:\\n            s  = mid + 1\\n        else:\\n            e = mid - 1\\n    return e+1\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            intervals.append(newInterval)\\n            return intervals\\n        x = []\\n        for i in range(len(intervals)):\\n            x.append(intervals[i][1])\\n\\n        k = binary_search(x,newInterval[0])\\n        res = intervals[:k] #to store intervals till `k`th index\\n        while k < len(intervals) and intervals[k][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[k][0], newInterval[0])\\n            newInterval[1] = max(intervals[k][1], newInterval[1])\\n            k += 1\\n        res.append(newInterval)\\n        #adding remaining elements to the list\\n        res += intervals[k:]  \\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845908,
                "title": "java-solution-with-simple-explanation",
                "content": "### Simulation\\n\\nIdea: We just need to deal with the insert interval, the intervals outside the range of insert interval, we just put it in the list. For those intervals within the range of insert interval, we need to merge them together.\\n\\n```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ansList = new ArrayList<>();\\n        int i = 0;\\n\\n        // add all the intervals before newInterval starts\\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        // merge intervals with the insert interval\\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        ansList.add(newInterval);\\n\\n        // add the rest of intervals\\n        while (i < intervals.length) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        int[][] ans = new int[ansList.size()][2];\\n        for (int j = 0; j < ansList.size(); j++)\\n            ans[j] = ansList.get(j);\\n\\n        return ans;\\n    }\\n}\\n```\\n\\nComplexity Analysis:\\n\\n- Time Complexity: $O(n)$. $n$ is the length of intervals.\\n- Space Complexity: $O(1)$. We only use extra space for variables.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ansList = new ArrayList<>();\\n        int i = 0;\\n\\n        // add all the intervals before newInterval starts\\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        // merge intervals with the insert interval\\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        ansList.add(newInterval);\\n\\n        // add the rest of intervals\\n        while (i < intervals.length) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        int[][] ans = new int[ansList.size()][2];\\n        for (int j = 0; j < ansList.size(); j++)\\n            ans[j] = ansList.get(j);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710112,
                "title": "java-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) for result array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        int i=0;\\n        while(i<intervals.length && intervals[i][1]< newInterval[0]){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        while(i<intervals.length && newInterval[1] >= intervals[i][0] ){\\n            newInterval[0]= Math.min(newInterval[0],intervals[i][0]);\\n            newInterval[1]= Math.max(newInterval[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.add(newInterval);\\n        while(i<intervals.length){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        int i=0;\\n        while(i<intervals.length && intervals[i][1]< newInterval[0]){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        while(i<intervals.length && newInterval[1] >= intervals[i][0] ){\\n            newInterval[0]= Math.min(newInterval[0],intervals[i][0]);\\n            newInterval[1]= Math.max(newInterval[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.add(newInterval);\\n        while(i<intervals.length){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587472,
                "title": "c-clean-and-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/25238441-3aa0-4ea3-a549-39e8e6ae2ad3_1663422186.4353445.png)\\n\\n\\nThis solution is very easy and begginer friendly.\\n\\nExplanation :\\n\\nI have used two for loops one for inserting the newInterval and the second loop for merging intervals.\\n\\nI have also added 2 edge cases(it is self explanatory)\\n\\nThis is my Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n         vector<vector<int>> output;\\n        if(intervals.size()==0){//edge case1\\n            output.push_back(newInterval);\\n        return output;\\n        }\\n        int flag=1;\\n        for (int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]>newInterval[0]){\\n                intervals.insert(intervals.begin() + i,newInterval);\\n                flag=0;\\n            break;\\n            }\\n        }\\n        if (flag==1)//edge case2\\n            intervals.push_back(newInterval);\\n        \\n        output.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(output.back()[1]>=intervals[i][0])\\n                output.back()[1]=max(output.back()[1],intervals[i][1]);\\n            else\\n                output.push_back(intervals[i]);\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\nIt takes only 1 sec to Upvote!!!\\nThanks in advance.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n         vector<vector<int>> output;\\n        if(intervals.size()==0){//edge case1\\n            output.push_back(newInterval);\\n        return output;\\n        }\\n        int flag=1;\\n        for (int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]>newInterval[0]){\\n                intervals.insert(intervals.begin() + i,newInterval);\\n                flag=0;\\n            break;\\n            }\\n        }\\n        if (flag==1)//edge case2\\n            intervals.push_back(newInterval);\\n        \\n        output.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(output.back()[1]>=intervals[i][0])\\n                output.back()[1]=max(output.back()[1],intervals[i][1]);\\n            else\\n                output.push_back(intervals[i]);\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576902,
                "title": "c-easiest-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size()-1;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < intervals.size(); i++){\\n            if(intervals[i][1] < newInterval[0]){\\n                res.push_back(intervals[i]);\\n            }\\n            \\n            else if(intervals[i][0] > newInterval[1]){\\n                res.push_back(newInterval);\\n                newInterval = intervals[i];\\n            }\\n            \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(intervals[i][1], newInterval[1]);\\n            }\\n        }\\n       res.push_back(newInterval);\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size()-1;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < intervals.size(); i++){\\n            if(intervals[i][1] < newInterval[0]){\\n                res.push_back(intervals[i]);\\n            }\\n            \\n            else if(intervals[i][0] > newInterval[1]){\\n                res.push_back(newInterval);\\n                newInterval = intervals[i];\\n            }\\n            \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(intervals[i][1], newInterval[1]);\\n            }\\n        }\\n       res.push_back(newInterval);\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563315,
                "title": "python-2-different-solutions-with-explanation",
                "content": "# Approach 1: O(nlogn)\\nThis is exactly the same thing as the problem **[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)**, except at the beginning of the we append the new interval into the list.\\n\\nIn the for loop, we check if the intervals are overlapping or not (whether the last interval in the resultant list\\'s end time is greater than the start time of the new interval). If they overlap, we merge them by setting the last interval in the resultant list\\'s end time to be the maximum of the 2 intervals.\\n```py\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        intervals.append(newInterval)\\n        intervals.sort()\\n        merged = []\\n        for interval in intervals:\\n            if merged and merged[-1][1] >= interval[0]:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n            else:\\n                merged.append(interval)\\n        return merged\\n```\\n\\n# Approach 2: O(n)\\nWe cover the 3 basic scenarios:\\n1. The current interval is before the interval we want to add (we just add the current interval)\\n2. The current interval is after the one we want to add (we add the new interval, and update the new interval since it\\'s now added already)\\n3. The intervals overlap (we merge them, and update the new interval. NO ADDING YET)\\n\\n\\n```py \\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        for interval in intervals:\\n            if interval[1] < newInterval[0]:\\n                res.append(interval)\\n            elif interval[0] > newInterval[1]:\\n                res.append(newInterval)\\n                newInterval = interval\\n            else:\\n                newInterval[0] = min(newInterval[0], interval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n        res.append(newInterval)\\n            \\n        return res\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```py\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        intervals.append(newInterval)\\n        intervals.sort()\\n        merged = []\\n        for interval in intervals:\\n            if merged and merged[-1][1] >= interval[0]:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n            else:\\n                merged.append(interval)\\n        return merged\\n```\n```py \\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        for interval in intervals:\\n            if interval[1] < newInterval[0]:\\n                res.append(interval)\\n            elif interval[0] > newInterval[1]:\\n                res.append(newInterval)\\n                newInterval = interval\\n            else:\\n                newInterval[0] = min(newInterval[0], interval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n        res.append(newInterval)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058154,
                "title": "java-simple-solution-with-explanation",
                "content": "Check below solution with explanation\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\n\\t\\t\\t// base condition\\n\\t\\t\\tif(intervals.length == 0)\\n\\t\\t\\t\\treturn new int[][]{newInterval};\\n\\n\\t\\t\\t// define start and end\\n\\t\\t\\tint start  = newInterval[0];\\n\\t\\t\\tint end  = newInterval[1];\\n\\n\\t\\t\\tList<int[]> output = new ArrayList<>();\\n\\n\\t\\t\\t// to insert any interval in sorted array we need to find the place where it needs to be added\\n\\t\\t\\t// to do that we will first add all intervals in output list which has end less than new interval\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < intervals.length && intervals[i][1] < start){\\n\\t\\t\\t\\toutput.add(new int[]{intervals[i][0],intervals[i][1]});\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// once we found the place where new interval should be added using above while loop we will use same logic as merge interval\\n\\t\\t\\t// we will compare new interval and current interval. If merging needed we will merge and add it in the list. \\n\\t\\t\\twhile(i < intervals.length){\\n\\t\\t\\t\\tif(intervals[i][0] <= end){\\n\\t\\t\\t\\t\\tstart = Math.min(start, intervals[i][0]);\\n\\t\\t\\t\\t\\tend = Math.max(end, intervals[i][1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\toutput.add(new int[]{start,end});\\n\\t\\t\\t\\t\\tstart = intervals[i][0];\\n\\t\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add last remaining interval\\n\\t\\t\\toutput.add(new int[]{start, end});\\n\\n\\t\\t\\t// convert list to 2d array\\n\\t\\t\\tint[][] insertInterval = output.toArray(new int[output.size()][]);\\n\\n\\t\\t\\t// return\\n\\t\\t\\treturn insertInterval;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\n\\t\\t\\t// base condition\\n\\t\\t\\tif(intervals.length == 0)\\n\\t\\t\\t\\treturn new int[][]{newInterval}",
                "codeTag": "Java"
            },
            {
                "id": 1742085,
                "title": "c-easy-and-convivence",
                "content": "```\\nbool comp(vector<int>&a,vector<int>&b)\\n{\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newIntervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        vector<vector<int>>ans;\\n        for(auto it:intervals)\\n        {\\n            if(it[1]<newIntervals[0]){\\n                ans.push_back(it);\\n            }\\n            else if(it[0]>newIntervals[1]){\\n                ans.push_back(newIntervals);\\n                newIntervals=it;\\n            }\\n            else{\\n                newIntervals[0]=min(it[0],newIntervals[0]);\\n                newIntervals[1]=max(it[1],newIntervals[1]);\\n            }\\n        }\\n        ans.push_back(newIntervals);\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>&a,vector<int>&b)\\n{\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newIntervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        vector<vector<int>>ans;\\n        for(auto it:intervals)\\n        {\\n            if(it[1]<newIntervals[0]){\\n                ans.push_back(it);\\n            }\\n            else if(it[0]>newIntervals[1]){\\n                ans.push_back(newIntervals);\\n                newIntervals=it;\\n            }\\n            else{\\n                newIntervals[0]=min(it[0],newIntervals[0]);\\n                newIntervals[1]=max(it[1],newIntervals[1]);\\n            }\\n        }\\n        ans.push_back(newIntervals);\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721591,
                "title": "c-visualized-explanation-and-analytics-99-faster-and-clean",
                "content": "**Method 1: Straightforward**\\n\\n```\\n1. \\ninterval     |__|\\nnewInterval       |_____|\\n\\n2.\\ninterval       |__|\\nnewInterval       |_____|\\n\\n3.\\ninterval        |__|\\nnewInterval       |_____|\\n\\n4.\\ninterval          |__|\\nnewInterval       |_____|\\n\\n5.\\ninterval            |__|\\nnewInterval       |_____|\\n\\n6.\\ninterval             |__|\\nnewInterval       |_____|\\n\\n7.\\ninterval                |__|\\nnewInterval       |_____|\\n\\n8.\\ninterval                  |__|\\nnewInterval       |_____|\\n```\\n\\n\\nThere are 8 possible relationships between interval and newInterval.\\n\\n**Goal: \\n1 and 8 are easy, so we have to focus on overlapping (2-7)!**\\n\\n```plain\\ncase 1: \\t       if interval[END] is smaller than newInterval[START], just push_back to ans\\ncase 2-7: \\t       if interval[START] is smaller or equal newInterval[END], \\n(overlapping)        we keep the min and max value as start and end of the newInterval\\ncase 8:            if we encounter the first non-overlapping interval\\n\\t\\t\\t\\t\\t push back newInterval and keep the index, then break\\n\\t\\t\\t\\t\\t we will finish the remaining non-overlapping interval\\n```\\n\\nThe algorithm will fail if the newInterval is non-overlapping and last interval,\\nso if `index` is default value (-1), we push back newInterval.\\n\\n```cpp\\n#define START 0\\n#define END 1\\n\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    int index = -1;\\n    for (int i = 0; i < intervals.size(); i++) {\\n      if (intervals[i][END] < newInterval[START]) {\\n        ans.push_back(intervals[i]);\\n      } else if (intervals[i][START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(intervals[i][START], newInterval[START]);\\n        newInterval[END] = max(intervals[i][END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index == -1) {\\n      // if newInterval is the last interval\\n      ans.push_back(newInterval);\\n    } else {\\n      // finish the non-overlapping interval\\n      for (int i = index; i < intervals.size(); i++)\\n        ans.push_back(intervals[i]);\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\nTime Complexity: O(n), where n is the size of intervals\\nSpace Complexity: O(n)\\nRuntime: 7 ms, faster than 99.17% of C++ online submissions for Insert Interval.\\nMemory Usage: 17.2 MB, less than 40.83% of C++ online submissions for Insert Interval.\\n\\n\\n**Method 2: Clean Version**\\nby reusing the newInterval but more runtime\\n\\n```cpp\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    for (vector<int>& interval: intervals) {\\n      if (interval[END] < newInterval[START]) {\\n        ans.push_back(interval);\\n      } else if (interval[START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(interval[START], newInterval[START]);\\n        newInterval[END] = max(interval[END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        newInterval = interval;\\n      }\\n    }\\n    ans.push_back(newInterval);\\n    return ans;\\n  }\\n};\\n```\\nRuntime: 8 ms, faster than 98.95% of C++ online submissions for Insert Interval.\\nMemory Usage: 16.9 MB, less than 99.47% of C++ online submissions for Insert Interval.\\n\\n**If you have any suggestion or advice, feel free to contact me!**\\n",
                "solutionTags": [],
                "code": "```\\n1. \\ninterval     |__|\\nnewInterval       |_____|\\n\\n2.\\ninterval       |__|\\nnewInterval       |_____|\\n\\n3.\\ninterval        |__|\\nnewInterval       |_____|\\n\\n4.\\ninterval          |__|\\nnewInterval       |_____|\\n\\n5.\\ninterval            |__|\\nnewInterval       |_____|\\n\\n6.\\ninterval             |__|\\nnewInterval       |_____|\\n\\n7.\\ninterval                |__|\\nnewInterval       |_____|\\n\\n8.\\ninterval                  |__|\\nnewInterval       |_____|\\n```\n```plain\\ncase 1: \\t       if interval[END] is smaller than newInterval[START], just push_back to ans\\ncase 2-7: \\t       if interval[START] is smaller or equal newInterval[END], \\n(overlapping)        we keep the min and max value as start and end of the newInterval\\ncase 8:            if we encounter the first non-overlapping interval\\n\\t\\t\\t\\t\\t push back newInterval and keep the index, then break\\n\\t\\t\\t\\t\\t we will finish the remaining non-overlapping interval\\n```\n```cpp\\n#define START 0\\n#define END 1\\n\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    int index = -1;\\n    for (int i = 0; i < intervals.size(); i++) {\\n      if (intervals[i][END] < newInterval[START]) {\\n        ans.push_back(intervals[i]);\\n      } else if (intervals[i][START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(intervals[i][START], newInterval[START]);\\n        newInterval[END] = max(intervals[i][END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index == -1) {\\n      // if newInterval is the last interval\\n      ans.push_back(newInterval);\\n    } else {\\n      // finish the non-overlapping interval\\n      for (int i = index; i < intervals.size(); i++)\\n        ans.push_back(intervals[i]);\\n    }\\n    return ans;\\n  }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    for (vector<int>& interval: intervals) {\\n      if (interval[END] < newInterval[START]) {\\n        ans.push_back(interval);\\n      } else if (interval[START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(interval[START], newInterval[START]);\\n        newInterval[END] = max(interval[END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        newInterval = interval;\\n      }\\n    }\\n    ans.push_back(newInterval);\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515974,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i = 0, n = intervals.size();\\n        while(i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]);\\n        \\n        vector<int> mI = newInterval;\\n        while(i < n && intervals[i][0] <= newInterval[1]){\\n            mI[0] = min(mI[0], intervals[i][0]);\\n            mI[1] = max(mI[1], intervals[i++][1]);\\n        }\\n        result.push_back(mI);\\n        \\n        while(i < n) result.push_back(intervals[i++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i = 0, n = intervals.size();\\n        while(i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]);\\n        \\n        vector<int> mI = newInterval;\\n        while(i < n && intervals[i][0] <= newInterval[1]){\\n            mI[0] = min(mI[0], intervals[i][0]);\\n            mI[1] = max(mI[1], intervals[i++][1]);\\n        }\\n        result.push_back(mI);\\n        \\n        while(i < n) result.push_back(intervals[i++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451390,
                "title": "interval-simple-solution-o-n-time-c",
                "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] ni) {\\n        \\n        int i=0, n=intervals.length;\\n        \\n        LinkedList<int []> res=new LinkedList<>();\\n        \\n        while(i<n && ni[0]>intervals[i][1])\\n        {\\n            res.add(intervals[i++]);\\n        }\\n        \\n        while(i <n && intervals[i][0]<=ni[1])\\n        {\\n            ni[0]=Math.min(intervals[i][0],ni[0]);\\n            ni[1]=Math.max(intervals[i][1],ni[1]);\\n            i++;\\n        }\\n        \\n        res.add(ni);\\n        \\n        while(i<n)\\n        {\\n            res.add(intervals[i++]);\\n        }\\n        \\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] ni) {\\n        \\n        int i=0, n=intervals.length;\\n        \\n        LinkedList<int []> res=new LinkedList<>();\\n        \\n        while(i<n && ni[0]>intervals[i][1])\\n        {\\n            res.add(intervals[i++]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1441307,
                "title": "python3-o-n-concise-solution-99-9-binary-search-merge-intervals",
                "content": "**Explanation**\\nSince the given intervals is already in sorted order, we can use binary search to find the insertion point. Then, merge the interval if necessary.\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i = bisect.bisect_left(intervals, newInterval)\\n        res = intervals[:i]\\n        for interval in [newInterval]+intervals[i:]:\\n            if res and res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i = bisect.bisect_left(intervals, newInterval)\\n        res = intervals[:i]\\n        for interval in [newInterval]+intervals[i:]:\\n            if res and res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347799,
                "title": "java-solution-easy-to-understand",
                "content": "**Runtime: 1 ms\\nMemory Usage: 41.4 MB**\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        LinkedList<int[]> list = new LinkedList();\\n        \\n        int idx = 0;\\n        \\n        while(idx < intervals.length && intervals[idx][0] < newInterval[0]){\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        if(list.size() == 0 || list.getLast()[1] <  newInterval[0]){\\n            list.add(newInterval);\\n        }else{\\n            list.getLast()[1] = Math.max(list.getLast()[1],newInterval[1]);\\n        }\\n        \\n        while(idx < intervals.length){\\n            if(list.getLast()[1] < intervals[idx][0])list.add(intervals[idx]);\\n            else list.getLast()[1] = Math.max(list.getLast()[1],intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        LinkedList<int[]> list = new LinkedList();\\n        \\n        int idx = 0;\\n        \\n        while(idx < intervals.length && intervals[idx][0] < newInterval[0]){\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        if(list.size() == 0 || list.getLast()[1] <  newInterval[0]){\\n            list.add(newInterval);\\n        }else{\\n            list.getLast()[1] = Math.max(list.getLast()[1],newInterval[1]);\\n        }\\n        \\n        while(idx < intervals.length){\\n            if(list.getLast()[1] < intervals[idx][0])list.add(intervals[idx]);\\n            else list.getLast()[1] = Math.max(list.getLast()[1],intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295056,
                "title": "javascript-very-easy-to-understand",
                "content": "```\\nvar insert = function(intervals, newInterval) {\\n    const result = [newInterval];\\n    for (const interval of intervals) {\\n        const last = result.pop();\\n        if (last[1] < interval[0]) {\\n\\t\\t // last comes before current interval\\n            result.push(last);\\n            result.push(interval)\\n        } else if (last[0] > interval[1]) {\\n\\t\\t// last comes after current interval\\n            result.push(interval);\\n            result.push(last)\\n        } else {\\n\\t\\t// intersection\\n            result.push([Math.min(last[0], interval[0]), Math.max(last[1], interval[1])])\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function(intervals, newInterval) {\\n    const result = [newInterval];\\n    for (const interval of intervals) {\\n        const last = result.pop();\\n        if (last[1] < interval[0]) {\\n\\t\\t // last comes before current interval\\n            result.push(last);\\n            result.push(interval)\\n        } else if (last[0] > interval[1]) {\\n\\t\\t// last comes after current interval\\n            result.push(interval);\\n            result.push(last)\\n        } else {\\n\\t\\t// intersection\\n            result.push([Math.min(last[0], interval[0]), Math.max(last[1], interval[1])])\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239530,
                "title": "first-attempt-efficient-solution",
                "content": "First Attempt, which is O(n)\\n```\\nvar insert = function(intervals, newInterval) {\\n    const size = intervals.length;\\n    const [start, end] = newInterval;\\n    \\n    const overlap = (interval) => {\\n        const [first, last] = interval;\\n        //3...5    <-first, last\\n        //  4....8 <-start, end\\n        if(start <= last &&  end >= last) return true;\\n        //1...5 <-first, last\\n        // 2.3  <-start, end\\n        return (first <= end && last >= end);\\n    }\\n    \\n    const overlaps = intervals.map(overlap);\\n    const result = [];\\n\\t\\n\\t//push left\\n    let i = 0;\\n    while(i < size && overlaps[i] === false && intervals[i][0] < end) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n\\t//merge overlaps\\n    let min = start;\\n    let max = end;\\n    while(i < size && overlaps[i]) {\\n        min = Math.min(min, intervals[i][0]);\\n        max = Math.max(max, intervals[i][1]);\\n        i++;\\n    }\\n    \\n    result.push([min, max]);\\n    \\n\\t//push right\\n    while(i < size) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nThis can be solved in one single pass\\n```\\nvar insert = function(intervals, newInterval) {\\n    const [start, end] = newInterval;\\n    const left = [];\\n    const right = [];\\n    let min = start;\\n    let max = end;\\n    \\n    for(const interval of intervals) {\\n        const [first, last] = interval;\\n        if(last < start) {\\n            left.push(interval);\\n        } else if(first > end) {\\n            right.push(interval);\\n        } else {\\n            min = Math.min(min, first);\\n            max = Math.max(max, last);\\n        }\\n    }\\n    \\n    return [...left, [min, max], ...right];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function(intervals, newInterval) {\\n    const size = intervals.length;\\n    const [start, end] = newInterval;\\n    \\n    const overlap = (interval) => {\\n        const [first, last] = interval;\\n        //3...5    <-first, last\\n        //  4....8 <-start, end\\n        if(start <= last &&  end >= last) return true;\\n        //1...5 <-first, last\\n        // 2.3  <-start, end\\n        return (first <= end && last >= end);\\n    }\\n    \\n    const overlaps = intervals.map(overlap);\\n    const result = [];\\n\\t\\n\\t//push left\\n    let i = 0;\\n    while(i < size && overlaps[i] === false && intervals[i][0] < end) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n\\t//merge overlaps\\n    let min = start;\\n    let max = end;\\n    while(i < size && overlaps[i]) {\\n        min = Math.min(min, intervals[i][0]);\\n        max = Math.max(max, intervals[i][1]);\\n        i++;\\n    }\\n    \\n    result.push([min, max]);\\n    \\n\\t//push right\\n    while(i < size) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nvar insert = function(intervals, newInterval) {\\n    const [start, end] = newInterval;\\n    const left = [];\\n    const right = [];\\n    let min = start;\\n    let max = end;\\n    \\n    for(const interval of intervals) {\\n        const [first, last] = interval;\\n        if(last < start) {\\n            left.push(interval);\\n        } else if(first > end) {\\n            right.push(interval);\\n        } else {\\n            min = Math.min(min, first);\\n            max = Math.max(max, last);\\n        }\\n    }\\n    \\n    return [...left, [min, max], ...right];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166865,
                "title": "python-easy-o-n",
                "content": "```\\n        s, e = newInterval[0], newInterval[1]\\n        merge, left, right = [], [], []\\n        \\n        for i in intervals:\\n            if i[1] < s:\\n                left.append(i)\\n            elif e < i[0]:\\n                right.append(i)\\n            else:\\n                merge.append(i)\\n\\n        if merge:\\n            s = min(s, merge[0][0])\\n            e = max(e, merge[-1][1])\\n        return left + [[s,e]]+ right\\n```",
                "solutionTags": [],
                "code": "```\\n        s, e = newInterval[0], newInterval[1]\\n        merge, left, right = [], [], []\\n        \\n        for i in intervals:\\n            if i[1] < s:\\n                left.append(i)\\n            elif e < i[0]:\\n                right.append(i)\\n            else:\\n                merge.append(i)\\n\\n        if merge:\\n            s = min(s, merge[0][0])\\n            e = max(e, merge[-1][1])\\n        return left + [[s,e]]+ right\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140661,
                "title": "java-1ms-99-faster",
                "content": "```\\n public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        \\n        for(int[] interval: intervals){\\n            if(interval[1] < newInterval[0])\\n                list.add(interval);\\n            else if(interval[0] > newInterval[1]){\\n                list.add(newInterval);\\n                newInterval = interval;\\n            }else {\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        \\n        for(int[] interval: intervals){\\n            if(interval[1] < newInterval[0])\\n                list.add(interval);\\n            else if(interval[0] > newInterval[1]){\\n                list.add(newInterval);\\n                newInterval = interval;\\n            }else {\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947241,
                "title": "python3-simple-easy-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals += [newInterval]\\n        intervals.sort()\\n        merge = []\\n        for interval in intervals:\\n            if not merge or merge[-1][1] < interval[0]:\\n                merge.append(interval)\\n            else:\\n                merge[-1][1] = max(merge[-1][1], interval[1])\\n        return merge\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals += [newInterval]\\n        intervals.sort()\\n        merge = []\\n        for interval in intervals:\\n            if not merge or merge[-1][1] < interval[0]:\\n                merge.append(interval)\\n            else:\\n                merge[-1][1] = max(merge[-1][1], interval[1])\\n        return merge\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844488,
                "title": "python-3-o-n-insert-intervals-easy-math-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        leftList, rightList=[],[]\\n        START,END=0,1\\n        \\n        for currentInterval in intervals:\\n            if currentInterval[END]< newInterval[START]:\\n                leftList+= [currentInterval]\\n            \\n            elif currentInterval[START]> newInterval[END]:\\n                rightList+=[currentInterval]\\n            \\n            else:\\n                newInterval[START]= min(currentInterval[START],newInterval[START])\\n                newInterval[END]= max(currentInterval[END], newInterval[END])\\n        \\n        return leftList + [[newInterval[START], newInterval[END]]] + rightList\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        leftList, rightList=[],[]\\n        START,END=0,1\\n        \\n        for currentInterval in intervals:\\n            if currentInterval[END]< newInterval[START]:\\n                leftList+= [currentInterval]\\n            \\n            elif currentInterval[START]> newInterval[END]:\\n                rightList+=[currentInterval]\\n            \\n            else:\\n                newInterval[START]= min(currentInterval[START],newInterval[START])\\n                newInterval[END]= max(currentInterval[END], newInterval[END])\\n        \\n        return leftList + [[newInterval[START], newInterval[END]]] + rightList\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 790477,
                "title": "python-binary-search-o-n-time-o-1-space",
                "content": "Hello,\\n\\nHere are my two solutions. The analysis follows. \\n\\t- Solution 1: `\\u0398(n)`time and `O(1)` space\\n\\t- Solution 2: `O(logn)`best time,`O(n)`worst time and`O(n)`space: see Complexity Analsysis below.\\n\\n- **Intuition**:\\n\\t\\t\\t\\n\\t\\t\\t- Binary Search : find the intervals new_interval overlap with : insert_start=i, insert_end=j :\\n\\t\\t\\tIntervals :              |---0---| ... |--i-1--||---i---|  ... |---j---||--j+1--|  ... |---n---| \\n\\t\\t\\tnew_interval :                                     |--------------|\\n\\t\\t\\t\\n\\t\\t\\t- Update new_interval :\\n\\t\\t\\tIntervals :              |---0---| ... |--i-1--||---i---|  ... |---j---||--j+1--|  ... |---n---| \\n\\t\\t\\tnew_interval :                                  |----------------------|\\n\\t\\t\\t\\n\\t\\t\\t- Return [0 : i[ + new_interval + ]j : n] :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t |---0---| ... |--i-1--||----------------------||--j+1--|  ... |---n---| \\n\\n- **Implementation**:\\n\\n```\\ndef __init__(self):\\n\\tself._start, self._end = 0, 1 # interval start and end indexes\\n\\ndef _binary_search(self, intervals: List[List[int]], val, l=0, r=None):\\n\\tif r is None:\\n\\t\\tr = len(intervals) - 1\\n\\t\\n\\twhile l <= r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tif intervals[mid][self._start] <= val <= intervals[mid][self._end]:\\n\\t\\t\\treturn mid\\n            \\n\\t\\telif val > intervals[mid][self._end]:\\n\\t\\t\\tl = mid + 1\\n                \\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n        \\n\\treturn l\\n\\n# Solution 1:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\n\\tintervals_count = len(intervals)\\n\\t\\n\\t# 1. Search the interval where new_interval.start fits in: O(logn) time\\n\\tval = new_interval[self._start]\\n\\tinsert_start = self._binary_search(intervals, val)\\n\\tif insert_start < intervals_count and intervals[insert_start][self._start] <= val <= intervals[insert_start][self._end]:\\n\\t\\tnew_interval[self._start] = intervals[insert_start][self._start]\\n\\t\\tnew_interval[self._end] = max(intervals[insert_start][self._end], new_interval[self._end])        \\n\\t\\n\\t# 2. Search the interval where new_interval.end fits in: O(logn) time\\n\\tval = new_interval[self._end]\\n\\tinsert_end = self._binary_search(intervals, val, insert_start)\\n\\tif insert_end < intervals_count and intervals[insert_end][self._start] <= val:\\n\\t\\tnew_interval[self._end] = max(intervals[insert_end][self._end], new_interval[self._end])\\n\\t\\tinsert_end += 1\\n\\t\\n\\t# 3. Replace overlapping intervals with new_interval: O(n) time and O(1) space\\n\\tintervals[insert_start:insert_end] = [new_interval]\\n\\t\\n\\treturn intervals\\n\\n```\\n\\n```\\n# Solution 2:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\t# Same as above\\n\\t# ...\\n\\t\\n\\t# 3. Create new merged_intervals list: O(n) time in worst case and O(n) space\\n\\tmerged_intervals = intervals[:insert_start]       # Insert all intervals before insert_start\\n    merged_intervals.append(new_interval)             # Insert new_interval\\n    merged_intervals.extend(intervals[insert_end:])   # Insert all intervals after insert_end\\n\\t\\n\\treturn merged_intervals\\n\\t\\n```\\n\\n- **Complexity Analysis**:\\n\\t- Let\\'s `n` be the length of the input list `intervals`\\n\\t- Let\\'s `m` be the length of the output list\\n\\t- Solution 1:\\n\\t\\t- The input is modified and returned\\n\\t\\t- Space Complexity: `O(1)` \\n\\t\\t- Time Complexity: `O(n)`\\n\\t\\t- It requires to delete from`intervals`all overlapping intervals\\n\\t- Solution 2:\\n\\t\\t- A new list is returned\\n\\t\\t- Space Complexity:`O(m)` \\n\\t\\t- Time Complexity:`\\u0398(max(logn, m)) = O(n)`(here `n` is an upper-bound only)\\n\\t\\t- The worst case time complexity is`O(n)`: happens for example when`new_interval`doesn\\'t overlap with`intervals`\\n\\t\\t- The best case time complexity is`O(logn)`: happens for example when`new_interval`overlaps whith the majority of`intervals`, more than`n - logn`\\n\\t\\t- In practice, this solution is faster than solution 1\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef __init__(self):\\n\\tself._start, self._end = 0, 1 # interval start and end indexes\\n\\ndef _binary_search(self, intervals: List[List[int]], val, l=0, r=None):\\n\\tif r is None:\\n\\t\\tr = len(intervals) - 1\\n\\t\\n\\twhile l <= r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tif intervals[mid][self._start] <= val <= intervals[mid][self._end]:\\n\\t\\t\\treturn mid\\n            \\n\\t\\telif val > intervals[mid][self._end]:\\n\\t\\t\\tl = mid + 1\\n                \\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n        \\n\\treturn l\\n\\n# Solution 1:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\n\\tintervals_count = len(intervals)\\n\\t\\n\\t# 1. Search the interval where new_interval.start fits in: O(logn) time\\n\\tval = new_interval[self._start]\\n\\tinsert_start = self._binary_search(intervals, val)\\n\\tif insert_start < intervals_count and intervals[insert_start][self._start] <= val <= intervals[insert_start][self._end]:\\n\\t\\tnew_interval[self._start] = intervals[insert_start][self._start]\\n\\t\\tnew_interval[self._end] = max(intervals[insert_start][self._end], new_interval[self._end])        \\n\\t\\n\\t# 2. Search the interval where new_interval.end fits in: O(logn) time\\n\\tval = new_interval[self._end]\\n\\tinsert_end = self._binary_search(intervals, val, insert_start)\\n\\tif insert_end < intervals_count and intervals[insert_end][self._start] <= val:\\n\\t\\tnew_interval[self._end] = max(intervals[insert_end][self._end], new_interval[self._end])\\n\\t\\tinsert_end += 1\\n\\t\\n\\t# 3. Replace overlapping intervals with new_interval: O(n) time and O(1) space\\n\\tintervals[insert_start:insert_end] = [new_interval]\\n\\t\\n\\treturn intervals\\n\\n```\n```\\n# Solution 2:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\t# Same as above\\n\\t# ...\\n\\t\\n\\t# 3. Create new merged_intervals list: O(n) time in worst case and O(n) space\\n\\tmerged_intervals = intervals[:insert_start]       # Insert all intervals before insert_start\\n    merged_intervals.append(new_interval)             # Insert new_interval\\n    merged_intervals.extend(intervals[insert_end:])   # Insert all intervals after insert_end\\n\\t\\n\\treturn merged_intervals\\n\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 637718,
                "title": "java-o-n-clean-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        int idx = 0;\\n        \\n        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        int mn = newInterval[0];\\n        int mx = newInterval[1];\\n        \\n        while (idx < intervals.length && mx >= intervals[idx][0]) {\\n            mn = Math.min(mn, intervals[idx][0]);\\n            mx = Math.max(mx, intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        list.add(new int[] { mn, mx });\\n        list.addAll(Arrays.asList(intervals).subList(idx, intervals.length));\\n        \\n        return list.stream().toArray(int[][]::new);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        int idx = 0;\\n        \\n        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        int mn = newInterval[0];\\n        int mx = newInterval[1];\\n        \\n        while (idx < intervals.length && mx >= intervals[idx][0]) {\\n            mn = Math.min(mn, intervals[idx][0]);\\n            mx = Math.max(mx, intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        list.add(new int[] { mn, mx });\\n        list.addAll(Arrays.asList(intervals).subList(idx, intervals.length));\\n        \\n        return list.stream().toArray(int[][]::new);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442034,
                "title": "clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if (intervals == null || newInterval == null || newInterval.length == 0) return null;\\n        if (intervals.length == 0) return new int[][]{newInterval};\\n        \\n        List<int[]> result = new ArrayList<>();\\n        boolean alreadyDone = false;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][1] < newInterval[0]) {\\n                result.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                if (!alreadyDone) {\\n                    result.add(newInterval);\\n                    alreadyDone = true;\\n                }\\n                result.add(intervals[i]);\\n            } else {\\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        \\n        if (!alreadyDone) {\\n            result.add(newInterval);\\n        }\\n        \\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if (intervals == null || newInterval == null || newInterval.length == 0) return null;\\n        if (intervals.length == 0) return new int[][]{newInterval};\\n        \\n        List<int[]> result = new ArrayList<>();\\n        boolean alreadyDone = false;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][1] < newInterval[0]) {\\n                result.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                if (!alreadyDone) {\\n                    result.add(newInterval);\\n                    alreadyDone = true;\\n                }\\n                result.add(intervals[i]);\\n            } else {\\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        \\n        if (!alreadyDone) {\\n            result.add(newInterval);\\n        }\\n        \\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369471,
                "title": "easy-python-solution-insert-and-merge-in-place",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        size = len(intervals)\\n        \\n\\t\\t#Insert newInterval into intervals to keep sorted order\\n        for i, interval in enumerate(intervals):\\n            if newInterval[0] <= interval[0]:\\n                intervals.insert(i, newInterval)\\n                break\\n        \\n        #If the interval hasn\\'t been added yet\\n        if size == len(intervals):\\n            intervals.append(newInterval)\\n        \\n        i = 1\\n        while i < len(intervals):\\n            #Merge if previous interval\\'s end is >= to current interval\\'s start\\n            if intervals[i-1][1] >= intervals[i][0]:\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n\\t\\t\\t\\t#Remove current because it was merged into previous\\n                intervals.pop(i) \\n                i -= 1\\n            i += 1\\n        \\n        return intervals\\n                \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        size = len(intervals)\\n        \\n\\t\\t#Insert newInterval into intervals to keep sorted order\\n        for i, interval in enumerate(intervals):\\n            if newInterval[0] <= interval[0]:\\n                intervals.insert(i, newInterval)\\n                break\\n        \\n        #If the interval hasn\\'t been added yet\\n        if size == len(intervals):\\n            intervals.append(newInterval)\\n        \\n        i = 1\\n        while i < len(intervals):\\n            #Merge if previous interval\\'s end is >= to current interval\\'s start\\n            if intervals[i-1][1] >= intervals[i][0]:\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n\\t\\t\\t\\t#Remove current because it was merged into previous\\n                intervals.pop(i) \\n                i -= 1\\n            i += 1\\n        \\n        return intervals\\n                \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 304030,
                "title": "1ms-simple-java-solution-explained",
                "content": "The principle of this solution is to merge overlapping intervals inside the new one (if needed).\\nThen, the new interval is inserted inside the list only once at the right place.\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tboolean added = false;\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif ((interval[1] < newInterval[0])) {      // Non-overlapping to the left\\n\\t\\t\\t\\t\\tresult.add(interval);                  // We can safely add the interval to the list\\n\\t\\t\\t\\t} else if (interval[0] > newInterval[1]) { // Non-overlapping to the right\\n\\t\\t\\t\\t\\tif (!added) {                          // Add the new interval only once\\n\\t\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tresult.add(interval);\\n\\t\\t\\t\\t} else {                                   // Overlapping, update the new interval\\n\\t\\t\\t\\t\\tnewInterval[0] = Math.min(newInterval[0], interval[0]);\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!added) { // Only happens if newInterval is last\\n\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t}\\n\\t\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tboolean added = false;\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif ((interval[1] < newInterval[0])) {      // Non-overlapping to the left\\n\\t\\t\\t\\t\\tresult.add(interval);                  // We can safely add the interval to the list\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 245084,
                "title": "super-simple-golang-solution-8ms-beats-100",
                "content": "```\\nfunc insert(intervals []Interval, newInterval Interval) []Interval {\\n    var left,right []Interval\\n    for _,v := range intervals {\\n        if v.End < newInterval.Start {\\n            left =  append(left, v)\\n        } else if v.Start > newInterval.End {\\n            right = append(right, v)\\n        } else {\\n            newInterval.Start = min(newInterval.Start, v.Start)\\n            newInterval.End = max(newInterval.End, v.End)\\n        }\\n    }\\n    return append(append(left,newInterval),right...)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insert(intervals []Interval, newInterval Interval) []Interval {\\n    var left,right []Interval\\n    for _,v := range intervals {\\n        if v.End < newInterval.Start {\\n            left =  append(left, v)\\n        } else if v.Start > newInterval.End {\\n            right = append(right, v)\\n        } else {\\n            newInterval.Start = min(newInterval.Start, v.Start)\\n            newInterval.End = max(newInterval.End, v.End)\\n        }\\n    }\\n    return append(append(left,newInterval),right...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21613,
                "title": "my-java-solution-pretty-simple-with-one-treemap",
                "content": "```\\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        TreeMap<Integer, Interval> treeMap = new TreeMap<>();\\n        for(Interval interval : intervals) {\\n            treeMap.put(interval.start, interval);\\n        }\\n        Interval cur = newInterval;\\n        \\n        while(treeMap.floorEntry(cur.end) != null && treeMap.floorEntry(cur.end).getValue().end >= cur.start) {\\n         \\n            if(treeMap.floorEntry(cur.start) != null && treeMap.floorEntry(cur.start).getValue().end >= cur.start) {\\n                Interval out = treeMap.floorEntry(cur.start).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.start));\\n                cur.start = out.start;\\n                cur.end = Math.max(cur.end, out.end);\\n            }else{\\n                Interval out = treeMap.floorEntry(cur.end).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.end));\\n                cur.end = Math.max(cur.end, out.end);\\n                cur.start = Math.min(cur.start, out.start);\\n            }\\n            \\n        }\\n        treeMap.put(cur.start, cur);\\n        return new ArrayList<>(treeMap.values());\\n    }",
                "solutionTags": [],
                "code": "```\\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        TreeMap<Integer, Interval> treeMap = new TreeMap<>();\\n        for(Interval interval : intervals) {\\n            treeMap.put(interval.start, interval);\\n        }\\n        Interval cur = newInterval;\\n        \\n        while(treeMap.floorEntry(cur.end) != null && treeMap.floorEntry(cur.end).getValue().end >= cur.start) {\\n         \\n            if(treeMap.floorEntry(cur.start) != null && treeMap.floorEntry(cur.start).getValue().end >= cur.start) {\\n                Interval out = treeMap.floorEntry(cur.start).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.start));\\n                cur.start = out.start;\\n                cur.end = Math.max(cur.end, out.end);\\n            }else{\\n                Interval out = treeMap.floorEntry(cur.end).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.end));\\n                cur.end = Math.max(cur.end, out.end);\\n                cur.start = Math.min(cur.start, out.start);\\n            }\\n            \\n        }\\n        treeMap.put(cur.start, cur);\\n        return new ArrayList<>(treeMap.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21733,
                "title": "a-very-short-c-solution-with-o-logn-search-is-it-clear-enough",
                "content": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        auto it1 = lower_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        auto it2 = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        vector<Interval> r( intervals.begin(), it1 );\\n        auto it3 = ( it2 == intervals.begin() ) ? it2 : it2 - 1;\\n        Interval m( (it1 == it2) ? newInterval.start : min( it1->start, newInterval.start ),\\n                    (it1 == it2) ? newInterval.end   : max( it3->end, newInterval.end ) );\\n        r.push_back(m);\\n        r.insert(r.end(), it2, intervals.end());\\n        return r;\\n    }\\n\\nIs this C++ solution clear enough?",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        auto it1 = lower_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        auto it2 = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        vector<Interval> r( intervals.begin(), it1 );\\n        auto it3 = ( it2 == intervals.begin() ) ? it2 : it2 - 1;\\n        Interval m( (it1 == it2) ? newInterval.start : min( it1->start, newInterval.start ),\\n                    (it1 == it2) ? newInterval.end   : max( it3->end, newInterval.end ) );\\n        r.push_back(m);\\n        r.insert(r.end(), it2, intervals.end());\\n        return r;\\n    }\\n\\nIs this C++ solution clear enough?",
                "codeTag": "Unknown"
            },
            {
                "id": 21793,
                "title": "easy-java-solution",
                "content": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        int ids = 0;\\n        while (ids < intervals.size() && newInterval.start > intervals.get(ids).start) ids++;\\n        intervals.add(ids, newInterval);\\n        for (int i = 0; i < intervals.size() - 1; ++i) {\\n            if (intervals.get(i).end < intervals.get(i + 1).start) continue;\\n            intervals.get(i).start = Math.min(intervals.get(i).start, intervals.get(i + 1).start);\\n            intervals.get(i).end = Math.max(intervals.get(i).end, intervals.get(i + 1).end);\\n            intervals.remove(i + 1);\\n            i--;\\n        }\\n        return intervals;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        int ids = 0;\\n        while (ids < intervals.size() && newInterval.start > intervals.get(ids).start) ids++;\\n        intervals.add(ids, newInterval);\\n        for (int i = 0; i < intervals.size() - 1; ++i) {\\n            if (intervals.get(i).end < intervals.get(i + 1).start) continue;\\n            intervals.get(i).start = Math.min(intervals.get(i).start, intervals.get(i + 1).start);\\n            intervals.get(i).end = Math.max(intervals.get(i).end, intervals.get(i + 1).end);\\n            intervals.remove(i + 1);\\n            i--;\\n        }\\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21702,
                "title": "c-code-use-binary-search",
                "content": "        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        if(intervals.empty()) {\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        \\n        int first=0, piv=0, count=intervals.size(), step = 0;\\n        while(count > 0) {  // lower bound of ends\\n            step = count/2; piv = first + step;\\n            if(intervals[piv].end < newInterval.start) {\\n                first = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        int last = first;\\n        count = intervals.size() - first;\\n        while(count > 0) {  // upper bound of starts\\n            step = count/2; piv = last + step;\\n            if(intervals[piv].start <= newInterval.end) {\\n                last = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        if(last == first)\\n            intervals.insert(intervals.begin()+first, newInterval);\\n        else {\\n            intervals[first].start = min(newInterval.start, intervals[first].start);\\n            intervals[first].end   = max(newInterval.end,   intervals[last-1].end);\\n            intervals.erase(intervals.begin()+(first+1), intervals.begin()+last);\\n        }\\n        \\n        return intervals;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        if(intervals.empty()) {\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        \\n        int first=0, piv=0, count=intervals.size(), step = 0;\\n        while(count > 0) {  // lower bound of ends\\n            step = count/2; piv = first + step;\\n            if(intervals[piv].end < newInterval.start) {\\n                first = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        int last = first;\\n        count = intervals.size() - first;\\n        while(count > 0) {  // upper bound of starts\\n            step = count/2; piv = last + step;\\n            if(intervals[piv].start <= newInterval.end) {\\n                last = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        if(last == first)\\n            intervals.insert(intervals.begin()+first, newInterval);\\n        else {\\n            intervals[first].start = min(newInterval.start, intervals[first].start);\\n            intervals[first].end   = max(newInterval.end,   intervals[last-1].end);\\n            intervals.erase(intervals.begin()+(first+1), intervals.begin()+last);\\n        }\\n        \\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21810,
                "title": "in-place-solution-ask-for-suggestion",
                "content": "I have done non in place insertion. Just want to try in place version because it seems faster and more memory efficient. Would like to ask for suggestion to see whether I can further improve it. Pass OJ already. But not guarantee it's bug free :P\\n  \\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\\n        //inplace solution for interval insertion\\n        if(intervals.empty()){intervals.insert(intervals.begin(),newInterval);return intervals;}\\n        int l=0,r=(int)intervals.size()-1;\\n        Interval& n=newInterval;\\n    \\n        //binary search for the first interval x, such that x.start is larger than n.start\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].start<=n.start)l=m+1;\\n            else r=m-1;\\n        }\\n        int left=l;\\n        l=0,r=(int)intervals.size()-1;\\n        //binary search for the first interval x such that x.end is smaller than n.end\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].end<n.end)l=m+1;\\n            else r=m-1;\\n        }\\n        int right=r;\\n    \\n        //check right boundary\\n        if(right+1<intervals.size()&&intervals[right+1].start<=n.end)\\n            n.end=max(n.end,intervals[++right].end);\\n    \\n        //check left boundary\\n        if(left-1>=0&&n.start<=intervals[left-1].end)\\n            n.start=min(n.start,intervals[--left].start);\\n    \\n        //check and update\\n        if(right+1>=left){\\n            intervals.insert(intervals.begin()+left,n);\\n            intervals.erase(intervals.begin()+left+1,intervals.begin()+right+2);\\n        }\\n        return intervals;\\n    }",
                "solutionTags": [],
                "code": "I have done non in place insertion. Just want to try in place version because it seems faster and more memory efficient. Would like to ask for suggestion to see whether I can further improve it. Pass OJ already. But not guarantee it's bug free :P\\n  \\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\\n        //inplace solution for interval insertion\\n        if(intervals.empty()){intervals.insert(intervals.begin(),newInterval);return intervals;}\\n        int l=0,r=(int)intervals.size()-1;\\n        Interval& n=newInterval;\\n    \\n        //binary search for the first interval x, such that x.start is larger than n.start\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].start<=n.start)l=m+1;\\n            else r=m-1;\\n        }\\n        int left=l;\\n        l=0,r=(int)intervals.size()-1;\\n        //binary search for the first interval x such that x.end is smaller than n.end\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].end<n.end)l=m+1;\\n            else r=m-1;\\n        }\\n        int right=r;\\n    \\n        //check right boundary\\n        if(right+1<intervals.size()&&intervals[right+1].start<=n.end)\\n            n.end=max(n.end,intervals[++right].end);\\n    \\n        //check left boundary\\n        if(left-1>=0&&n.start<=intervals[left-1].end)\\n            n.start=min(n.start,intervals[--left].start);\\n    \\n        //check and update\\n        if(right+1>=left){\\n            intervals.insert(intervals.begin()+left,n);\\n            intervals.erase(intervals.begin()+left+1,intervals.begin()+right+2);\\n        }\\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4018688,
                "title": "insert-interval-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());   \\n        vector<int> temp = intervals[0];\\n        vector<vector<int> > ans;\\n\\n\\n        for(auto it : intervals)\\n        {\\n            if(temp[1] >= it[0])\\n            {\\n                temp[1] = max(temp[1],it[1]);\\n              \\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp = it;\\n            }\\n        }ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());   \\n        vector<int> temp = intervals[0];\\n        vector<vector<int> > ans;\\n\\n\\n        for(auto it : intervals)\\n        {\\n            if(temp[1] >= it[0])\\n            {\\n                temp[1] = max(temp[1],it[1]);\\n              \\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp = it;\\n            }\\n        }ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795785,
                "title": "very-easy-brute-force-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval[0],newInterval[1]});\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> v;\\n        for(int i = 0 ; i < intervals.size() ; i++)\\n        {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if(!v.empty() && v.back()[1] >= end)\\n            {\\n                continue;\\n            }\\n            for(int j = i+1 ; j < intervals.size() ; j++)\\n            {\\n                if(intervals[j][0] <= end)\\n                {\\n                    end = max(end , intervals[j][1]);\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            v.push_back({start,end});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval[0],newInterval[1]});\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> v;\\n        for(int i = 0 ; i < intervals.size() ; i++)\\n        {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if(!v.empty() && v.back()[1] >= end)\\n            {\\n                continue;\\n            }\\n            for(int j = i+1 ; j < intervals.size() ; j++)\\n            {\\n                if(intervals[j][0] <= end)\\n                {\\n                    end = max(end , intervals[j][1]);\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            v.push_back({start,end});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781818,
                "title": "simple-python-solution-using-insort",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insort(intervals, newInterval)\\n        ans = [intervals[0]]\\n        for s, e in intervals[1:]:\\n            if ans[-1][-1] >= s:\\n                ans[-1][-1] = max(ans[-1][-1], e)\\n            else:\\n                ans.append([s, e])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insort(intervals, newInterval)\\n        ans = [intervals[0]]\\n        for s, e in intervals[1:]:\\n            if ans[-1][-1] >= s:\\n                ans[-1][-1] = max(ans[-1][-1], e)\\n            else:\\n                ans.append([s, e])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766731,
                "title": "simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        Stack<int[]> st = new Stack<>();\\n        int i= 0;\\n        int s = intervals.length;\\n        while(i<s && intervals[i][1]<newInterval[0]) st.push(intervals[i++]);\\n        while(i<s && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        st.push(newInterval);\\n        while(i<s) st.push(intervals[i++]);\\n      int[][] output = new int[st.size()][2];\\n      for(int j = output.length-1; j>=0; j--){\\n          output[j] = st.pop();\\n      }\\n      return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        Stack<int[]> st = new Stack<>();\\n        int i= 0;\\n        int s = intervals.length;\\n        while(i<s && intervals[i][1]<newInterval[0]) st.push(intervals[i++]);\\n        while(i<s && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        st.push(newInterval);\\n        while(i<s) st.push(intervals[i++]);\\n      int[][] output = new int[st.size()][2];\\n      for(int j = output.length-1; j>=0; j--){\\n          output[j] = st.pop();\\n      }\\n      return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492665,
                "title": "simplest-solution-easy-to-understand-c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbreak a problem into parts\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nvector processing\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int n=intervals.size();\\n        int i=0;\\n        while(i<n && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n        vector<int>mi=newInterval;\\n        while(i<n && intervals[i][0]<=newInterval[1])\\n        {\\n            mi[0]=min(mi[0],intervals[i][0]);\\n            mi[1]=max(mi[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.push_back(mi);\\n        while(i<n)\\n        {\\n            result.push_back(intervals[i++]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int n=intervals.size();\\n        int i=0;\\n        while(i<n && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n        vector<int>mi=newInterval;\\n        while(i<n && intervals[i][0]<=newInterval[1])\\n        {\\n            mi[0]=min(mi[0],intervals[i][0]);\\n            mi[1]=max(mi[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.push_back(mi);\\n        while(i<n)\\n        {\\n            result.push_back(intervals[i++]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434453,
                "title": "absolutely-clear-and-simple-python-solution-o-n-beats-over-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need modify intervals when an old interval intersect with new interval, that say in this 2 situations:\\n1. left value of old interval <= right value of new interval\\n2. right value of old interval >= left value of new interval\\n\\nBesides upon 2 situation, we just put old intervals into solutions.\\nHowever, in other cases, we would expand new interval.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nA little thing we sholud pay attention, is whether we met the intersection or not. So I use a variable \\'meet\\' to record it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        #-1: never met\\n        # 0: already interted to result\\n        # 1: met, but not interted to result yet\\n        meet = -1 \\n\\n        left = newInterval[0]\\n        right = newInterval[1]\\n        for interval in intervals:    \\n            if interval[1] < left:\\n                result.append(interval)\\n            elif interval[0] > right:\\n                if meet != 0:\\n                    result.append([left, right])\\n                    meet = 0\\n                result.append(interval)\\n            else:\\n                left = min(interval[0], left)\\n                right = max(interval[1], right)\\n                meet = 1\\n        if meet != 0:\\n            result.append([left, right])\\n        return result\\n```\\n\\nIt\\'s my first post, UPVOTE this if you like :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        #-1: never met\\n        # 0: already interted to result\\n        # 1: met, but not interted to result yet\\n        meet = -1 \\n\\n        left = newInterval[0]\\n        right = newInterval[1]\\n        for interval in intervals:    \\n            if interval[1] < left:\\n                result.append(interval)\\n            elif interval[0] > right:\\n                if meet != 0:\\n                    result.append([left, right])\\n                    meet = 0\\n                result.append(interval)\\n            else:\\n                left = min(interval[0], left)\\n                right = max(interval[1], right)\\n                meet = 1\\n        if meet != 0:\\n            result.append([left, right])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429077,
                "title": "java-solution-beats-100-o-n",
                "content": "\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < n && newInterval[0] > intervals[l][1]) {\\n            l++;\\n        }\\n        while (r >= 0 && newInterval[1] < intervals[r][0]) {\\n            r--;\\n        }\\n        int[][] res = new int[l + n - r][2];\\n        for (int i = 0; i < l; i++) {\\n            res[i] = Arrays.copyOf(intervals[i], intervals[i].length);\\n        }\\n        res[l][0] = Math.min(newInterval[0], l == n ? newInterval[0] : intervals[l][0]);\\n        res[l][1] = Math.max(newInterval[1], r == -1 ? newInterval[1] : intervals[r][1]);\\n        for (int i = l + 1, j = r + 1; j < n; i++, j++) {\\n            res[i] = intervals[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < n && newInterval[0] > intervals[l][1]) {\\n            l++;\\n        }\\n        while (r >= 0 && newInterval[1] < intervals[r][0]) {\\n            r--;\\n        }\\n        int[][] res = new int[l + n - r][2];\\n        for (int i = 0; i < l; i++) {\\n            res[i] = Arrays.copyOf(intervals[i], intervals[i].length);\\n        }\\n        res[l][0] = Math.min(newInterval[0], l == n ? newInterval[0] : intervals[l][0]);\\n        res[l][1] = Math.max(newInterval[1], r == -1 ? newInterval[1] : intervals[r][1]);\\n        for (int i = l + 1, j = r + 1; j < n; i++, j++) {\\n            res[i] = intervals[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142437,
                "title": "easy-python-solution-with-linear-time-complexity-100-working",
                "content": "\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                res.append(newInterval)\\n                return res+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                res.append(intervals[i])\\n            else:\\n                newInterval=(min(intervals[i][0],newInterval[0]),max(intervals[i][1],newInterval[1]))\\n        res.append(newInterval)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                res.append(newInterval)\\n                return res+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                res.append(intervals[i])\\n            else:\\n                newInterval=(min(intervals[i][0],newInterval[0]),max(intervals[i][1],newInterval[1]))\\n        res.append(newInterval)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060958,
                "title": "linear-explained-python3-beats-92-javascript-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intervals are sorted.\\nThere are intervals coming strictly before, after, and intersecting the new interval\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Partition the input intervals into three categories:\\n   - preceeding the new interval\\n   - intersecting the new interval, thus merged into one interval\\n   - following the new interval\\n2. Return these joined interval categories\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$, the space for the resulting intervals is not counted\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Python 3\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        start, end = newInterval\\n        prefix, suffix = [], []\\n        for i in intervals:\\n            if i[1] < start:\\n                prefix.append(i)\\n            elif i[0] > end:\\n                suffix.append(i)\\n            else:\\n                start, end = min(start, i[0]), max(end, i[1])\\n        return prefix + [[start, end]] + suffix\\n```\\n## JavaScript\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let [start, end] = newInterval;\\n    const [prefix, suffix] = [[], []];\\n    for (const i of intervals) {\\n        if (i[1] < start) {\\n            prefix.push(i);\\n        } else if (i[0] > end) {\\n            suffix.push(i);\\n        } else {\\n            start = Math.min(start, i[0]);\\n            end = Math.max(end, i[1]);\\n        }\\n    }\\n    return [...prefix, [start, end], ...suffix];\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        start, end = newInterval\\n        prefix, suffix = [], []\\n        for i in intervals:\\n            if i[1] < start:\\n                prefix.append(i)\\n            elif i[0] > end:\\n                suffix.append(i)\\n            else:\\n                start, end = min(start, i[0]), max(end, i[1])\\n        return prefix + [[start, end]] + suffix\\n```\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let [start, end] = newInterval;\\n    const [prefix, suffix] = [[], []];\\n    for (const i of intervals) {\\n        if (i[1] < start) {\\n            prefix.push(i);\\n        } else if (i[0] > end) {\\n            suffix.push(i);\\n        } else {\\n            start = Math.min(start, i[0]);\\n            end = Math.max(end, i[1]);\\n        }\\n    }\\n    return [...prefix, [start, end], ...suffix];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060893,
                "title": "c-solution-easy-and-simple-explanation-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere Three cases we have to consider \\nCase 1. Insert all the intervals that are non overlapping with the gievn newinterval.\\nCase 2. On finding the overlapping interval merge all the overlappig intervals.\\nCase 3. Insert all the remaining intervals after the overlapping intervals. \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> v;\\n        int n = intervals.size(), i = 0;\\n        // push all the intervals till non overlapping interval\\n        while(i < n && newInterval[0] > intervals[i][1])\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        // merging all the overlapping intervals\\n        while(i < n && newInterval[1] >= intervals[i][0])\\n        {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        v.push_back(newInterval);\\n        // psuh all the remaining intervals after merging \\n        while(i < n)\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> v;\\n        int n = intervals.size(), i = 0;\\n        // push all the intervals till non overlapping interval\\n        while(i < n && newInterval[0] > intervals[i][1])\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        // merging all the overlapping intervals\\n        while(i < n && newInterval[1] >= intervals[i][0])\\n        {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        v.push_back(newInterval);\\n        // psuh all the remaining intervals after merging \\n        while(i < n)\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1759866,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760304,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759735,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1572656,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760461,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760366,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759762,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1567828,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1818723,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760226,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759866,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760304,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759735,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1572656,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760461,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760366,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759762,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1567828,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1818723,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760226,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760727,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1868788,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1762258,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1574365,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1948131,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1761687,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 2062287,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1760761,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1760076,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1568879,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1944081,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760929,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760840,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760409,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759971,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759916,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759732,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759731,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1571142,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760371,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 2069722,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2067271,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2051636,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2045374,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2042915,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2039965,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2033587,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2028140,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2011437,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 1963552,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 1957718,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1954453,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1947263,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1944702,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1941307,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1935767,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1933469,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1921887,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1919335,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1906710,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1905777,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1904235,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1863143,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1832801,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1820519,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1804316,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1801891,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1792060,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1778869,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1766824,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1761800,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761074,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761047,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761039,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760766,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760764,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760746,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760741,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760739,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760738,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760706,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760696,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760675,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760640,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760615,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760579,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760572,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760503,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760476,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760462,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760439,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760396,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760374,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760368,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760298,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760264,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760221,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760218,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760194,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760172,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760159,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760145,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760138,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760100,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760049,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759898,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759890,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759840,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759803,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759802,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            }
        ]
    },
    {
        "title": "Read N Characters Given Read4",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566981,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1570390,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1711494,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1568437,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1781628,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1567532,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1778199,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1773425,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1566981,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1570390,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1711494,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1568437,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1781628,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1567532,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1778199,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1773425,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Paths",
        "question_content": "<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5]\n<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [&quot;1&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 68258,
                "title": "accepted-java-simple-solution-in-8-lines",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> answer = new ArrayList<String>();\\n        if (root != null) searchBT(root, \"\", answer);\\n        return answer;\\n    }\\n    private void searchBT(TreeNode root, String path, List<String> answer) {\\n        if (root.left == null && root.right == null) answer.add(path + root.val);\\n        if (root.left != null) searchBT(root.left, path + root.val + \"->\", answer);\\n        if (root.right != null) searchBT(root.right, path + root.val + \"->\", answer);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> answer = new ArrayList<String>();\\n        if (root != null) searchBT(root, \"\", answer);\\n        return answer;\\n    }\\n    private void searchBT(TreeNode root, String path, List<String> answer) {\\n        if (root.left == null && root.right == null) answer.add(path + root.val);\\n        if (root.left != null) searchBT(root.left, path + root.val + \"->\", answer);\\n        if (root.right != null) searchBT(root.right, path + root.val + \"->\", answer);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68270,
                "title": "c-simple-4ms-recursive-solution",
                "content": "    void binaryTreePaths(vector<string>& result, TreeNode* root, string t) {\\n        if(!root->left && !root->right) {\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        if(root->left) binaryTreePaths(result, root->left, t + \"->\" + to_string(root->left->val));\\n        if(root->right) binaryTreePaths(result, root->right, t + \"->\" + to_string(root->right->val));\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        if(!root) return result;\\n        \\n        binaryTreePaths(result, root, to_string(root->val));\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    void binaryTreePaths(vector<string>& result, TreeNode* root, string t) {\\n        if(!root->left && !root->right) {\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        if(root->left) binaryTreePaths(result, root->left, t + \"->\" + to_string(root->left->val));\\n        if(root->right) binaryTreePaths(result, root->right, t + \"->\" + to_string(root->right->val));\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        if(!root) return result;\\n        \\n        binaryTreePaths(result, root, to_string(root->val));\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68272,
                "title": "python-solutions-dfs-stack-bfs-queue-dfs-recursively",
                "content": "```\\n        \\n    # dfs + stack\\n    def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # bfs + queue\\n    def binaryTreePaths2(self, root):\\n        if not root:\\n            return []\\n        res, queue = [], collections.deque([(root, \"\")])\\n        while queue:\\n            node, ls = queue.popleft()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.left:\\n                queue.append((node.left, ls+str(node.val)+\"->\"))\\n            if node.right:\\n                queue.append((node.right, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # dfs recursively\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, root, ls, res):\\n        if not root.left and not root.right:\\n            res.append(ls+str(root.val))\\n        if root.left:\\n            self.dfs(root.left, ls+str(root.val)+\"->\", res)\\n        if root.right:\\n            self.dfs(root.right, ls+str(root.val)+\"->\", res)\\n\\t\\t\\t\\n    def binaryTreePaths1(self, root):\\n        return self.dfs(root, \"\")\\n    \\n    def dfs(self, root, path):\\n        if not root:\\n            return []\\n        path += str(root.val)\\n        if not root.left and not root.right:\\n            return [path]\\n        path += \"->\"\\n        return self.dfs(root.left, path) + self.dfs(root.right, path)\\n    \\n    def binaryTreePaths(self, root): # inorder\\n        stack, ret = [(root, \"\")], []\\n        while stack:\\n            node, path = stack.pop()\\n            if node:\\n                if not node.left and not node.right:\\n                    ret.append(path+str(node.val))\\n                s = path + str(node.val) + \"->\"\\n                stack.append((node.right, s))\\n                stack.append((node.left, s))    \\n        return ret\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n        \\n    # dfs + stack\\n    def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # bfs + queue\\n    def binaryTreePaths2(self, root):\\n        if not root:\\n            return []\\n        res, queue = [], collections.deque([(root, \"\")])\\n        while queue:\\n            node, ls = queue.popleft()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.left:\\n                queue.append((node.left, ls+str(node.val)+\"->\"))\\n            if node.right:\\n                queue.append((node.right, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # dfs recursively\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, root, ls, res):\\n        if not root.left and not root.right:\\n            res.append(ls+str(root.val))\\n        if root.left:\\n            self.dfs(root.left, ls+str(root.val)+\"->\", res)\\n        if root.right:\\n            self.dfs(root.right, ls+str(root.val)+\"->\", res)\\n\\t\\t\\t\\n    def binaryTreePaths1(self, root):\\n        return self.dfs(root, \"\")\\n    \\n    def dfs(self, root, path):\\n        if not root:\\n            return []\\n        path += str(root.val)\\n        if not root.left and not root.right:\\n            return [path]\\n        path += \"->\"\\n        return self.dfs(root.left, path) + self.dfs(root.right, path)\\n    \\n    def binaryTreePaths(self, root): # inorder\\n        stack, ret = [(root, \"\")], []\\n        while stack:\\n            node, path = stack.pop()\\n            if node:\\n                if not node.left and not node.right:\\n                    ret.append(path+str(node.val))\\n                s = path + str(node.val) + \"->\"\\n                stack.append((node.right, s))\\n                stack.append((node.left, s))    \\n        return ret\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 68278,
                "title": "my-java-solution-in-dfs-bfs-recursion",
                "content": "recursion:\\n\\n    public class Solution {\\n    //Recursion\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> sList=new LinkedList<String>();\\n        //String s=new String();\\n        if (root==null) return sList;\\n        if (root.left==null && root.right==null) {\\n            sList.add(Integer.toString(root.val));\\n            return sList;\\n        }\\n        \\n        for (String s: binaryTreePaths(root.left)) {\\n            sList.add(Integer.toString(root.val)+\"->\"+s);\\n        }\\n        for (String s: binaryTreePaths(root.right)) {\\n            sList.add(Integer.toString(root.val)+\"->\"+s);\\n        }\\n        return sList;\\n    }\\n}\\n\\nBFS  - queue\\n\\n    public class Solution {\\n    //BFS - Queue\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list=new ArrayList<String>();\\n        Queue<TreeNode> qNode=new LinkedList<TreeNode>();\\n        Queue<String> qStr=new LinkedList<String>();\\n        \\n        if (root==null) return list;\\n        qNode.add(root);\\n        qStr.add(\"\");\\n        while(!qNode.isEmpty()) {\\n            TreeNode curNode=qNode.remove();\\n            String curStr=qStr.remove();\\n            \\n            if (curNode.left==null && curNode.right==null) list.add(curStr+curNode.val);\\n            if (curNode.left!=null) {\\n                qNode.add(curNode.left);\\n                qStr.add(curStr+curNode.val+\"->\");\\n            }\\n            if (curNode.right!=null) {\\n                qNode.add(curNode.right);\\n                qStr.add(curStr+curNode.val+\"->\");\\n            }\\n        }\\n        return list;\\n    }\\n    \\nDFS - stack\\n\\n    public class Solution {\\n    //DFS - Stack\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list=new ArrayList<String>();\\n        Stack<TreeNode> sNode=new Stack<TreeNode>();\\n        Stack<String> sStr=new Stack<String>();\\n        \\n        if(root==null) return list;\\n        sNode.push(root);\\n        sStr.push(\"\");\\n        while(!sNode.isEmpty()) {\\n            TreeNode curNode=sNode.pop();\\n            String curStr=sStr.pop();\\n            \\n            if(curNode.left==null && curNode.right==null) list.add(curStr+curNode.val);\\n            if(curNode.left!=null) {\\n                sNode.push(curNode.left);\\n                sStr.push(curStr+curNode.val+\"->\");\\n            }\\n            if(curNode.right!=null) {\\n                sNode.push(curNode.right);\\n                sStr.push(curStr+curNode.val+\"->\");\\n            }\\n        }\\n        return list;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    //Recursion\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> sList=new LinkedList<String>();\\n        //String s=new String();\\n        if (root==null) return sList;\\n        if (root.left==null && root.right==null) {\\n            sList.add(Integer.toString(root.val));\\n            return sList;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68282,
                "title": "clean-java-solution-accepted-without-any-helper-recursive-function",
                "content": "Lot of recursive solutions on this forum involves creating a helper recursive function with added parameters. The added parameter which usually is of the type List<String> , carries the supplementary path information. However, the approach below doesn't use such a helper function.\\n\\n\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n            \\n            List<String> paths = new LinkedList<>();\\n    \\n            if(root == null) return paths;\\n            \\n            if(root.left == null && root.right == null){\\n                paths.add(root.val+\"\");\\n                return paths;\\n            }\\n    \\n             for (String path : binaryTreePaths(root.left)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             for (String path : binaryTreePaths(root.right)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             return paths;\\n            \\n        }",
                "solutionTags": [],
                "code": "Lot of recursive solutions on this forum involves creating a helper recursive function with added parameters. The added parameter which usually is of the type List<String> , carries the supplementary path information. However, the approach below doesn't use such a helper function.\\n\\n\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n            \\n            List<String> paths = new LinkedList<>();\\n    \\n            if(root == null) return paths;\\n            \\n            if(root.left == null && root.right == null){\\n                paths.add(root.val+\"\");\\n                return paths;\\n            }\\n    \\n             for (String path : binaryTreePaths(root.left)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             for (String path : binaryTreePaths(root.right)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             return paths;\\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 671194,
                "title": "c-using-recursion-short-and-easy-to-understand",
                "content": "***Pls upvote if you find this helpful  :)***\\nThe basic idea is to traverse the tree keeping the path in the string **curr** and when you find a leaf then substituting curr in the answer.We need vector **answer** to be same in all the calls in the call stack, therefore we use address operator while we need separate curr for each step,hence not using address operator.\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<string>& answer,string curr){\\n        if(!root)return;\\n        if(root->left||root->right)curr+=(to_string(root->val)+\"->\");\\n        else{\\n            curr+=(to_string(root->val));\\n            answer.push_back(curr);\\n        }\\n        helper(root->left,answer,curr);\\n        helper(root->right,answer,curr);  \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> answer;\\n        string curr=\"\";\\n        helper(root,answer,curr);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<string>& answer,string curr){\\n        if(!root)return;\\n        if(root->left||root->right)curr+=(to_string(root->val)+\"->\");\\n        else{\\n            curr+=(to_string(root->val));\\n            answer.push_back(curr);\\n        }\\n        helper(root->left,answer,curr);\\n        helper(root->right,answer,curr);  \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> answer;\\n        string curr=\"\";\\n        helper(root,answer,curr);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68287,
                "title": "5-lines-recursive-python",
                "content": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        return [str(root.val) + '->' + path\\n                for kid in (root.left, root.right) if kid\\n                for path in self.binaryTreePaths(kid)] or [str(root.val)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        return [str(root.val) + '->' + path\\n                for kid in (root.left, root.right) if kid\\n                for path in self.binaryTreePaths(kid)] or [str(root.val)]",
                "codeTag": "Python3"
            },
            {
                "id": 68265,
                "title": "java-solution-using-stringbuilder-instead-of-string-manipulation",
                "content": "\\n\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rst = new ArrayList<String>();\\n            if(root == null) return rst;\\n            StringBuilder sb = new StringBuilder();\\n            helper(rst, sb, root);\\n            return rst;\\n        }\\n        \\n        public void helper(List<String> rst, StringBuilder sb, TreeNode root){\\n            if(root == null) return;\\n            int tmp = sb.length();\\n            if(root.left == null && root.right == null){\\n                sb.append(root.val);\\n                rst.add(sb.toString());\\n                sb.delete(tmp , sb.length());\\n                return;\\n            }\\n            sb.append(root.val + \"->\");\\n            helper(rst, sb, root.left);\\n            helper(rst, sb, root.right);\\n            sb.delete(tmp , sb.length());\\n            return;\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rst = new ArrayList<String>();\\n            if(root == null) return rst;\\n            StringBuilder sb = new StringBuilder();\\n            helper(rst, sb, root);\\n            return rst;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68279,
                "title": "c-non-recursive-version-and-recursive-version",
                "content": "    /*\\n    follow up: non-recursive version\\n    */\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            stack<TreeNode*> s;\\n            stack<string> pathStack;\\n            s.push(root);\\n            pathStack.push(to_string(root->val));\\n            \\n            while (!s.empty()) {\\n                TreeNode * curNode = s.top(); s.pop();\\n                string tmpPath = pathStack.top(); pathStack.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(tmpPath); continue;\\n                }\\n                \\n                if (curNode->left != NULL) {\\n                    s.push(curNode->left);\\n                    pathStack.push(tmpPath + \"->\" + to_string(curNode->left->val));\\n                }\\n                \\n                if (curNode->right != NULL) {\\n                    s.push(curNode->right);\\n                    pathStack.push(tmpPath + \"->\" + to_string(curNode->right->val));\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };\\n    \\n    //recursive version\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            dfs(root, to_string(root->val), res);\\n            return res;\\n        }\\n        \\n        void dfs(TreeNode* root, string path, vector<string>& res) {\\n            if (root->left == NULL && root->right == NULL) {\\n                res.push_back(path);\\n            }\\n            \\n            if (root->left != NULL)\\n                dfs(root->left, path + \"->\" + to_string(root->left->val), res);\\n            \\n            if (root->right != NULL)\\n                dfs(root->right, path + \"->\" + to_string(root->right->val), res);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            stack<TreeNode*> s;\\n            stack<string> pathStack;\\n            s.push(root);\\n            pathStack.push(to_string(root->val));\\n            \\n            while (!s.empty()) {\\n                TreeNode * curNode = s.top(); s.pop();\\n                string tmpPath = pathStack.top(); pathStack.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(tmpPath); continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 68507,
                "title": "8-lines-in-python-48ms",
                "content": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n        treepaths = [str(root.val)+'->'+path for path in self.binaryTreePaths(root.left)]\\n        treepaths += [str(root.val)+'->'+path for path in self.binaryTreePaths(root.right)]\\n        return treepaths",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n        treepaths = [str(root.val)+'->'+path for path in self.binaryTreePaths(root.left)]\\n        treepaths += [str(root.val)+'->'+path for path in self.binaryTreePaths(root.right)]\\n        return treepaths",
                "codeTag": "Python3"
            },
            {
                "id": 68477,
                "title": "my-concise-java-dfs-solution",
                "content": "**Explanation**\\n\\nThis is just a classic problem to use depth first search algorithm.\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<String> res = new ArrayList<String>();        \\n        DFS(root, \"\", res);\\n        return res;        \\n    }\\n    \\t\\n    public void DFS(TreeNode root, String solution, ArrayList<String> res) {\\n    \\tif (root == null) return;    \\t\\n    \\tif (root.left==null && root.right==null) res.add(solution + root.val);\\n    \\tDFS(root.left, solution + root.val + \"->\", res);    \\t\\n    \\tDFS(root.right, solution + root.val + \"->\", res);    \\t    \\t\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThis is just a classic problem to use depth first search algorithm.\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<String> res = new ArrayList<String>();        \\n        DFS(root, \"\", res);\\n        return res;        \\n    }\\n    \\t\\n    public void DFS(TreeNode root, String solution, ArrayList<String> res) {\\n    \\tif (root == null) return;    \\t\\n    \\tif (root.left==null && root.right==null) res.add(solution + root.val);\\n    \\tDFS(root.left, solution + root.val + \"->\", res);    \\t\\n    \\tDFS(root.right, solution + root.val + \"->\", res);    \\t    \\t\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 68424,
                "title": "java-2ms-solution-using-stringbuilder",
                "content": "The time complexity for the problem should be O(n), since we are basically visiting each node in the tree. Yet an interviewer might ask you for further optimization when he or she saw a string concatenation. A string concatenation is just too costly. A StringBuilder can be used although a bit tricky since it is not immutable like string is.\\n\\nWhen using StringBuilder, We can just keep track of the length of the StringBuilder before we append anything to it before recursion and afterwards set the length back. Another trick is when to append the \"->\", since we don't need the last arrow at the end of the string, we only append it before recurse to the next level of the tree. Hope the solution helps!\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        helper(res, root, sb);\\n        return res;\\n    }\\n\\n    private void helper(List<String> res, TreeNode root, StringBuilder sb) {\\n        if(root == null) {\\n            return;\\n        }\\n        int len = sb.length();\\n        sb.append(root.val);\\n        if(root.left == null && root.right == null) {\\n            res.add(sb.toString());\\n        } else {\\n            sb.append(\"->\");\\n            helper(res, root.left, sb);\\n            helper(res, root.right, sb);\\n        }\\n        sb.setLength(len);\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "The time complexity for the problem should be O(n), since we are basically visiting each node in the tree. Yet an interviewer might ask you for further optimization when he or she saw a string concatenation. A string concatenation is just too costly. A StringBuilder can be used although a bit tricky since it is not immutable like string is.\\n\\nWhen using StringBuilder, We can just keep track of the length of the StringBuilder before we append anything to it before recursion and afterwards set the length back. Another trick is when to append the \"->\", since we don't need the last arrow at the end of the string, we only append it before recurse to the next level of the tree. Hope the solution helps!\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        helper(res, root, sb);\\n        return res;\\n    }\\n\\n    private void helper(List<String> res, TreeNode root, StringBuilder sb) {\\n        if(root == null) {\\n            return;\\n        }\\n        int len = sb.length();\\n        sb.append(root.val);\\n        if(root.left == null && root.right == null) {\\n            res.add(sb.toString());\\n        } else {\\n            sb.append(\"->\");\\n            helper(res, root.left, sb);\\n            helper(res, root.right, sb);\\n        }\\n        sb.setLength(len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 328264,
                "title": "simple-javascript-solution-with-explanation",
                "content": "This code does not pass around data within function parameters and is recursive with no helper functions.\\n\\n```\\nvar binaryTreePaths = function(root) {\\n\\t// If null return an empty array\\n    if (root === null) return [];\\n\\t// If no children return the nodes value itself as a string within an array\\n    else if (root.left === null && root.right === null) return [`${root.val}`];\\n    else {\\n\\t\\t// For all child paths add the root to their head one by one.\\n        let left = binaryTreePaths(root.left).map(x => root.val + \\'->\\' + x);\\n        let right = binaryTreePaths(root.right).map(x => root.val + \\'->\\' + x);\\n\\t\\t\\n\\t\\t// return the array with the root value attached\\n        return [...left, ...right];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n\\t// If null return an empty array\\n    if (root === null) return [];\\n\\t// If no children return the nodes value itself as a string within an array\\n    else if (root.left === null && root.right === null) return [`${root.val}`];\\n    else {\\n\\t\\t// For all child paths add the root to their head one by one.\\n        let left = binaryTreePaths(root.left).map(x => root.val + \\'->\\' + x);\\n        let right = binaryTreePaths(root.right).map(x => root.val + \\'->\\' + x);\\n\\t\\t\\n\\t\\t// return the array with the root value attached\\n        return [...left, ...right];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68443,
                "title": "my-java-and-c-solution-c-4ms",
                "content": " this is a simple dfs+tree question,using preorder to visit tree will be fine.\\n \\nc++:\\n\\n     class Solution {\\n        public:\\n        \\n                vector<string> binaryTreePaths(TreeNode* root) {\\n                    vector<string> v;\\n                    if(root)\\n                        preorder(v,root,\"\");\\n                    return v;\\n                }\\n                void preorder(vector<string>& v,TreeNode* r,string t){\\n                    if(!r)\\n                        return;\\n                    if(!t.empty())\\n                        t+=(\"->\"+to_string(r->val));\\n                    else t+=to_string(r->val);\\n                    if(r->left||r->right){\\n                        preorder(v,r->left,t);\\n                        preorder(v,r->right,t);\\n                    }else{\\n                        v.push_back(t);\\n                    }\\n                }\\n            };\\n\\nmy java:\\n\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> l=new ArrayList<>();\\n            if(root!=null)\\n                pre(l,root,\"\");\\n            return l;\\n        }\\n         void pre(List<String> l,TreeNode r,String s){\\n             if(r==null)return;\\n             if(s.isEmpty())\\n                s+=r.val;\\n            else s+=(\"->\"+r.val);\\n            if(r.left!=null||r.right!=null){\\n                pre(l,r.left,s);\\n                pre(l,r.right,s);\\n            }else\\n                l.add(s);\\n         }\\n    }",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "class Solution {\\n        public:\\n        \\n                vector<string> binaryTreePaths(TreeNode* root) {\\n                    vector<string> v;\\n                    if(root)\\n                        preorder(v,root,\"\");\\n                    return v;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 928068,
                "title": "dfs-js-solution",
                "content": "```\\nUsing String:\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n    \\n    function dfsTraversal(root, cur) {\\n        if (!root) return;\\n        if (!root.left && !root.right) {\\n            paths.push(cur + root.val);\\n            return;\\n        }\\n        dfsTraversal(root.left, cur + root.val + \"->\");\\n        dfsTraversal(root.right, cur + root.val + \"->\");\\n    }\\n    \\n    dfsTraversal(root, \"\");\\n    return paths;\\n    // Time Complexity: O(N), we always visit all nodes\\n    // Space Complexity: O(H) or O(N), height can be at most N (in case of a skewed tree)\\n};\\n```\\n\\n```\\nUsing Array:\\nconst binaryTreePaths = (root) => {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (root === null) {\\n      return;\\n    }\\n    if (root.left === null && root.right === null) {\\n      paths.push([...curPath, root.val]);\\n      return;\\n    }\\n    dfsTraversal([...curPath, root.val], root.left);\\n    dfsTraversal([...curPath, root.val], root.right);\\n  }\\n  dfsTraversal([], root);\\n  return paths.map(path => path.join(\"->\"));\\n};\\n```\\n```\\nUsing only one array:\\nvar binaryTreePaths = function(root) {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (!root) return;\\n    curPath.push(root.val);\\n    if (root.left === null && root.right === null) {\\n      paths.push(curPath.join(\"->\"));\\n    }\\n    dfsTraversal(curPath, root.left);\\n    dfsTraversal(curPath, root.right);\\n    curPath.pop();\\n  }\\n  dfsTraversal([], root);\\n  return paths;\\n  // T.C: O(N)\\n  // S.C: O(H)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nUsing String:\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n    \\n    function dfsTraversal(root, cur) {\\n        if (!root) return;\\n        if (!root.left && !root.right) {\\n            paths.push(cur + root.val);\\n            return;\\n        }\\n        dfsTraversal(root.left, cur + root.val + \"->\");\\n        dfsTraversal(root.right, cur + root.val + \"->\");\\n    }\\n    \\n    dfsTraversal(root, \"\");\\n    return paths;\\n    // Time Complexity: O(N), we always visit all nodes\\n    // Space Complexity: O(H) or O(N), height can be at most N (in case of a skewed tree)\\n};\\n```\n```\\nUsing Array:\\nconst binaryTreePaths = (root) => {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (root === null) {\\n      return;\\n    }\\n    if (root.left === null && root.right === null) {\\n      paths.push([...curPath, root.val]);\\n      return;\\n    }\\n    dfsTraversal([...curPath, root.val], root.left);\\n    dfsTraversal([...curPath, root.val], root.right);\\n  }\\n  dfsTraversal([], root);\\n  return paths.map(path => path.join(\"->\"));\\n};\\n```\n```\\nUsing only one array:\\nvar binaryTreePaths = function(root) {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (!root) return;\\n    curPath.push(root.val);\\n    if (root.left === null && root.right === null) {\\n      paths.push(curPath.join(\"->\"));\\n    }\\n    dfsTraversal(curPath, root.left);\\n    dfsTraversal(curPath, root.right);\\n    curPath.pop();\\n  }\\n  dfsTraversal([], root);\\n  return paths;\\n  // T.C: O(N)\\n  // S.C: O(H)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68536,
                "title": "three-4ms-c-solutions-given-recursion-dfs-stack-based-bfs-queue-based",
                "content": "(1)Recursion, if root is empty, return, if root is a leaf, then return cur+root->val, if root has childrens, then do recursion on each child, with cur updated to cur + root->val +\"->\"\\n\\n    class Solution {\\n        void dfs(vector<string> &res, TreeNode *root, string cur)\\n        {\\n            if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n            else\\n            {\\n                if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n                if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n            }\\n        }\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if(root)  dfs(res, root, \"\");\\n            return res;\\n        }\\n    };\\n\\n(2) DFS Version using a stack\\nUsing a stack (the element is a pair of the current node pointer and the string recording the path from root to the current node). The logic is the same as (1)\\n\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            TreeNode *curNode;\\n            string curPath;\\n            stack<pair<TreeNode*, string>> liveNodes;\\n            if(root) liveNodes.push(make_pair(root, \"\"));\\n            while(!liveNodes.empty())\\n            {\\n                curNode = liveNodes.top().first;\\n                curPath    = liveNodes.top().second;\\n                liveNodes.pop();\\n                if(!curNode->left && !curNode->right)\\n                {\\n                    res.push_back(curPath + std::to_string(curNode->val));\\n                }\\n                else\\n                {\\n                    if(curNode->left)  liveNodes.push(make_pair(curNode->left, curPath + std::to_string(curNode->val)+ \"->\"));\\n                    if(curNode->right) liveNodes.push(make_pair(curNode->right, curPath + std::to_string(curNode->val)+ \"->\"));\\n                }\\n            }\\n            return res;\\n        }\\n    };\\n\\n(3) BFS queue based solution.\\nIt prints all the paths in an ascending order of the path length\\n\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            queue<pair<TreeNode*, string>> liveNodes[2];\\n            int cur=0, next=1;\\n            TreeNode* curNode;\\n            string curPath;\\n            vector<string> res;\\n            \\n            if(root) liveNodes[cur].push(make_pair(root, \"\"));\\n            while(!liveNodes[cur].empty())\\n            {\\n                curNode = liveNodes[cur].front().first;\\n                curPath = liveNodes[cur].front().second;\\n                liveNodes[cur].pop();\\n                if(!curNode->left && !curNode->right) res.push_back(curPath + std::to_string(curNode->val));\\n                else{\\n                    if(curNode->left)  liveNodes[next].push(make_pair(curNode->left,  curPath + std::to_string(curNode->val) + \"->\"));\\n                    if(curNode->right) liveNodes[next].push(make_pair(curNode->right, curPath + std::to_string(curNode->val) + \"->\"));\\n                }\\n                if(liveNodes[cur].empty()) swap(cur, next);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        void dfs(vector<string> &res, TreeNode *root, string cur)\\n        {\\n            if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n            else\\n            {\\n                if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n                if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 68364,
                "title": "4-lines-python-dfs",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        result= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.left)]\\n        result+= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.right)]\\n        return result or [str(root.val)]  # if empty return leaf itself\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        result= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.left)]\\n        result+= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.right)]\\n        return result or [str(root.val)]  # if empty return leaf itself\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 827629,
                "title": "python-o-n-2-by-dfs-w-comment",
                "content": "Python O(n^2) by DFS \\n\\n---\\n\\n**Implementation**:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        \\n        result = []\\n        \\n        # ----------------------------------------\\n        def helper(node, cur):\\n            \\n            if not node:\\n                # base case\\n                return\\n            \\n            \\n            if not node.left and not node.right:\\n                # stop condition\\n                result.append( cur + [str(node.val)] )\\n                \\n            else:\\n                # general case\\n                helper(node.left, cur + [str(node.val)] )\\n                helper(node.right, cur + [str(node.val)] )\\n            \\n            \\n        # ----------------------------------------\\n        \\n        helper(node=root, cur=[])\\n        return [ *map(\\'->\\'.join, result) ]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        \\n        result = []\\n        \\n        # ----------------------------------------\\n        def helper(node, cur):\\n            \\n            if not node:\\n                # base case\\n                return\\n            \\n            \\n            if not node.left and not node.right:\\n                # stop condition\\n                result.append( cur + [str(node.val)] )\\n                \\n            else:\\n                # general case\\n                helper(node.left, cur + [str(node.val)] )\\n                helper(node.right, cur + [str(node.val)] )\\n            \\n            \\n        # ----------------------------------------\\n        \\n        helper(node=root, cur=[])\\n        return [ *map(\\'->\\'.join, result) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68410,
                "title": "short-and-clear-c-dfs-solution",
                "content": "    vector<string> binaryTreePaths(TreeNode* root) {\\n    \\tvector<string> res;\\n    \\thelp(res, root, \"\");\\n    \\treturn res;\\n    }\\n    void help(vector<string>& res, TreeNode* root, string pre) {\\n    \\tif (!root)\\n    \\t\\treturn;\\n    \\tif (!root->left && !root->right) {\\n    \\t\\tres.push_back(pre + to_string(root->val));\\n    \\t\\treturn;\\n    \\t}\\n    \\thelp(res, root->left, pre + to_string(root->val) + \"->\");\\n    \\thelp(res, root->right, pre + to_string(root->val) + \"->\");\\n    }",
                "solutionTags": [],
                "code": "    vector<string> binaryTreePaths(TreeNode* root) {\\n    \\tvector<string> res;\\n    \\thelp(res, root, \"\");\\n    \\treturn res;\\n    }\\n    void help(vector<string>& res, TreeNode* root, string pre) {\\n    \\tif (!root)\\n    \\t\\treturn;\\n    \\tif (!root->left && !root->right) {\\n    \\t\\tres.push_back(pre + to_string(root->val));\\n    \\t\\treturn;\\n    \\t}\\n    \\thelp(res, root->left, pre + to_string(root->val) + \"->\");\\n    \\thelp(res, root->right, pre + to_string(root->val) + \"->\");\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3164442,
                "title": "python-simple-recursive-solution-beats-100",
                "content": "## Upvote if it helps !\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We iterate through left and right nodes until we get to a leaf.\\n    - We construct the string in the recursion. \\n    - During the recursion, we add ```->``` before the value of the node **only if it\\'s not the root**.\\n    - We add the string to the result only when we get to a leaf.  \\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        res = []\\n        \\n        def dfs(node, s):\\n            if s != \"\":\\n                s += \"->\"\\n            s += str(node.val)\\n            if not node.left and not node.right: res.append(s)\\n            if node.left: dfs(node.left, s)\\n            if node.right: dfs(node.right, s)\\n        dfs(root, \"\") \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```->```\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        res = []\\n        \\n        def dfs(node, s):\\n            if s != \"\":\\n                s += \"->\"\\n            s += str(node.val)\\n            if not node.left and not node.right: res.append(s)\\n            if node.left: dfs(node.left, s)\\n            if node.right: dfs(node.right, s)\\n        dfs(root, \"\") \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799051,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234676,
                "title": "c-easy-100-faster",
                "content": "```\\n\\tclass Solution {\\npublic:\\n    vector<string>ans1;\\n    \\n   void recurs(TreeNode* root,string ans)\\n    {\\n       if(root==NULL)\\n       {\\n           return ;\\n       }\\n    \\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=to_string(root->val);\\n            ans1.push_back(ans);\\n            return ;\\n        }\\n\\n            ans+=to_string(root->val)+\"->\";\\n       \\n        recurs(root->left,ans);\\n        recurs(root->right,ans);\\n    }\\n    \\n    \\n    \\n    \\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        recurs(root,\"\");\\n        \\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    vector<string>ans1;\\n    \\n   void recurs(TreeNode* root,string ans)\\n    {\\n       if(root==NULL)\\n       {\\n           return ;\\n       }\\n    \\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=to_string(root->val);\\n            ans1.push_back(ans);\\n            return ;\\n        }\\n\\n            ans+=to_string(root->val)+\"->\";\\n       \\n        recurs(root->left,ans);\\n        recurs(root->right,ans);\\n    }\\n    \\n    \\n    \\n    \\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        recurs(root,\"\");\\n        \\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602321,
                "title": "time-o-n-h-beats-99-43-space-o-h-beats-99-39-python-simple-explanation",
                "content": "**Time Complexity Explanation:** For every path - in the worst case we have (n/2 + 1) paths which happens when the tree is perfect - we iterate through each node in the path once in order to stringify the path. At worst, we will have h nodes in the path - where h is the height of the tree, and n is the total number of nodes in the tree. Therefore we get a time complexity of O((n/2 + 1) * h) = O(n * h).\\n\\n**Space Complexity Explanation:** This is trivial, we are using Depth-First Search, and an extra list which can contain at most h nodes - where h is the height of the tree. Therefore we get a space complexity of O(h).\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def _dfs(self, root: Optional[TreeNode], cur, res) -> None:\\n        \\n        # Base Case\\n        if not root:\\n            return\\n        \\n        # Append node to path\\n        cur.append(str(root.val))\\n        \\n        # If root is a leaf, append path to result\\n        if not root.left and not root.right:\\n            res.append(\\'->\\'.join(cur))\\n            \\n        # Recursive Step\\n        self._dfs(root.left, cur, res)\\n        self._dfs(root.right, cur, res)\\n        \\n        # Backtracking / Post-processing / pop node from path\\n        cur.pop()\\n        \\n        \\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        res = []\\n        self._dfs(root, [], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def _dfs(self, root: Optional[TreeNode], cur, res) -> None:\\n        \\n        # Base Case\\n        if not root:\\n            return\\n        \\n        # Append node to path\\n        cur.append(str(root.val))\\n        \\n        # If root is a leaf, append path to result\\n        if not root.left and not root.right:\\n            res.append(\\'->\\'.join(cur))\\n            \\n        # Recursive Step\\n        self._dfs(root.left, cur, res)\\n        self._dfs(root.right, cur, res)\\n        \\n        # Backtracking / Post-processing / pop node from path\\n        cur.pop()\\n        \\n        \\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        res = []\\n        self._dfs(root, [], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111611,
                "title": "javascript-dfs-solution",
                "content": "```\\nvar binaryTreePaths = function(root) {\\n    if(!root) return [];\\n    var result = [];\\n    function path(root, str){\\n        if(!root.left && !root.right) result.push(str + root.val);\\n        if(root.left) path(root.left, str + root.val + \"->\");\\n        if(root.right) path(root.right, str + root.val + \"->\");\\n    }\\n    path(root, \"\");\\n    return result;\\n};",
                "solutionTags": [],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n    if(!root) return [];\\n    var result = [];\\n    function path(root, str){\\n        if(!root.left && !root.right) result.push(str + root.val);\\n        if(root.left) path(root.left, str + root.val + \"->\");\\n        if(root.right) path(root.right, str + root.val + \"->\");\\n    }\\n    path(root, \"\");\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 68441,
                "title": "python-easy-dfs-recursive-iterative-solution",
                "content": "Recursive:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, node, path, res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path, node.val))\\n        self.dfs(node.left, \"{}{}->\".format(path, node.val), res)\\n        self.dfs(node.right, \"{}{}->\".format(path, node.val), res)\\n\\nIterative:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, \"\")]\\n        while stack:\\n            node, path = stack.pop()\\n            if not node:\\n                continue\\n            if not node.left and not node.right:\\n                res.append(\"{}{}\".format(path,node.val))\\n            stack.append((node.left, \"{}{}->\".format(path,node.val)))\\n            stack.append((node.right, \"{}{}->\".format(path,node.val)))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "Recursive:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, node, path, res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path, node.val))\\n        self.dfs(node.left, \"{}{}->\".format(path, node.val), res)\\n        self.dfs(node.right, \"{}{}->\".format(path, node.val), res)\\n\\nIterative:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, \"\")]\\n        while stack:\\n            node, path = stack.pop()\\n            if not node:\\n                continue\\n            if not node.left and not node.right:\\n                res.append(\"{}{}\".format(path,node.val))\\n            stack.append((node.left, \"{}{}->\".format(path,node.val)))\\n            stack.append((node.right, \"{}{}->\".format(path,node.val)))\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3476527,
                "title": "easy-o-n-c-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Inbuilt Stack for Recursive calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<string>v;\\n    \\n    void solve(TreeNode* root,string s){\\n        if(!root){\\n            if(s!=\"\")\\n            return;\\n            else\\n            v.push_back(s);\\n            return;\\n        }\\n\\n        s=s+to_string(root->val)+\"->\";\\n        if(!root->left and !root->right){\\n            s=s.substr(0,s.size()-2);\\n            v.push_back(s);\\n        }\\n        if(root->left)\\n        solve(root->left,s);\\n        if(root->right)\\n        solve(root->right,s);\\n        \\n       \\n        \\n}\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        solve(root,s);\\n        return v;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<string>v;\\n    \\n    void solve(TreeNode* root,string s){\\n        if(!root){\\n            if(s!=\"\")\\n            return;\\n            else\\n            v.push_back(s);\\n            return;\\n        }\\n\\n        s=s+to_string(root->val)+\"->\";\\n        if(!root->left and !root->right){\\n            s=s.substr(0,s.size()-2);\\n            v.push_back(s);\\n        }\\n        if(root->left)\\n        solve(root->left,s);\\n        if(root->right)\\n        solve(root->right,s);\\n        \\n       \\n        \\n}\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        solve(root,s);\\n        return v;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247162,
                "title": "c-recursive-backtracking-iterative",
                "content": "The recursive idea is to get the paths of the `left` and `right` subtrees and append the `root` to them.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths, left, right;\\n        left = binaryTreePaths(root -> left);\\n        right = binaryTreePaths(root -> right);\\n        for (string l : left) {\\n            paths.push_back(to_string(root -> val) + (l.empty() ? \"\" : \"->\" + l));\\n        }\\n        for (string r : right) {\\n            paths.push_back(to_string(root -> val) + (r.empty() ? \"\" : \"->\" + r));\\n        }\\n        if (paths.empty()) {\\n            paths.push_back(to_string(root -> val));\\n        }\\n        return paths;\\n    }\\n};\\n```\\n\\nBacktracking can also be applied, which is basically a template solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> paths;\\n        string path;\\n        binaryTreePaths(root, path, paths);\\n        return paths;\\n    }\\nprivate:\\n    void binaryTreePaths(TreeNode* root, string path, vector<string>& paths) {\\n        if (!root) {\\n            return;\\n        }\\n        path += (path.empty() ? \"\" : \"->\") + to_string(root -> val);\\n        if (!root -> left && !root -> right) {\\n            paths.push_back(path);\\n        } else {\\n            binaryTreePaths(root -> left, path, paths);\\n            binaryTreePaths(root -> right, path, paths);\\n        }\\n    }\\n};\\n```\\n\\nOr we may solve it iteratively by storing each node and the path to it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths;\\n        queue<pair<TreeNode*, string>> todo;\\n        todo.push({root, to_string(root -> val)});\\n        while (!todo.empty()) {\\n            pair<TreeNode*, string> p = todo.front();\\n            todo.pop();\\n            TreeNode* node = p.first;\\n            string path = p.second;\\n            if (!node -> left && !node -> right) {\\n                paths.push_back(path);\\n            } else {\\n                if (node -> left) {\\n                    todo.push({node -> left, path + \"->\" + to_string(node -> left -> val)});\\n                }\\n                if (node -> right) {\\n                    todo.push({node -> right, path + \"->\" + to_string(node -> right -> val)});\\n                }\\n            }\\n        }\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths, left, right;\\n        left = binaryTreePaths(root -> left);\\n        right = binaryTreePaths(root -> right);\\n        for (string l : left) {\\n            paths.push_back(to_string(root -> val) + (l.empty() ? \"\" : \"->\" + l));\\n        }\\n        for (string r : right) {\\n            paths.push_back(to_string(root -> val) + (r.empty() ? \"\" : \"->\" + r));\\n        }\\n        if (paths.empty()) {\\n            paths.push_back(to_string(root -> val));\\n        }\\n        return paths;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> paths;\\n        string path;\\n        binaryTreePaths(root, path, paths);\\n        return paths;\\n    }\\nprivate:\\n    void binaryTreePaths(TreeNode* root, string path, vector<string>& paths) {\\n        if (!root) {\\n            return;\\n        }\\n        path += (path.empty() ? \"\" : \"->\") + to_string(root -> val);\\n        if (!root -> left && !root -> right) {\\n            paths.push_back(path);\\n        } else {\\n            binaryTreePaths(root -> left, path, paths);\\n            binaryTreePaths(root -> right, path, paths);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths;\\n        queue<pair<TreeNode*, string>> todo;\\n        todo.push({root, to_string(root -> val)});\\n        while (!todo.empty()) {\\n            pair<TreeNode*, string> p = todo.front();\\n            todo.pop();\\n            TreeNode* node = p.first;\\n            string path = p.second;\\n            if (!node -> left && !node -> right) {\\n                paths.push_back(path);\\n            } else {\\n                if (node -> left) {\\n                    todo.push({node -> left, path + \"->\" + to_string(node -> left -> val)});\\n                }\\n                if (node -> right) {\\n                    todo.push({node -> right, path + \"->\" + to_string(node -> right -> val)});\\n                }\\n            }\\n        }\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68453,
                "title": "my-java-non-recursion-solution-using-stack-and-wrapper",
                "content": "    private class Wrapper {\\n    \\t\\tprivate TreeNode node;\\n    \\t\\tprivate String path;\\n    \\n    \\t\\tpublic Wrapper(TreeNode node, String path) {\\n    \\t\\t\\tthis.node = node;\\n    \\t\\t\\tthis.path = path;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\t// non-recursion-version\\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new LinkedList<>();\\n    \\t\\tif (root == null) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tStack<Wrapper> stack = new Stack<>();\\n    \\t\\tstack.add(new Wrapper(root, \"\"+root.val));\\n    \\t\\twhile(!stack.isEmpty()){\\n    \\t\\t\\tWrapper wrapper = stack.pop();\\n    \\t\\t\\tif (wrapper.node.left == null && wrapper.node.right == null) {\\n    \\t\\t\\t\\tres.add(wrapper.path);\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.left != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.left, wrapper.path + \"->\" + wrapper.node.left.val));\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.right != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.right, wrapper.path + \"->\" + wrapper.node.right.val));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\n    \\t}",
                "solutionTags": [],
                "code": "    private class Wrapper {\\n    \\t\\tprivate TreeNode node;\\n    \\t\\tprivate String path;\\n    \\n    \\t\\tpublic Wrapper(TreeNode node, String path) {\\n    \\t\\t\\tthis.node = node;\\n    \\t\\t\\tthis.path = path;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\t// non-recursion-version\\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new LinkedList<>();\\n    \\t\\tif (root == null) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tStack<Wrapper> stack = new Stack<>();\\n    \\t\\tstack.add(new Wrapper(root, \"\"+root.val));\\n    \\t\\twhile(!stack.isEmpty()){\\n    \\t\\t\\tWrapper wrapper = stack.pop();\\n    \\t\\t\\tif (wrapper.node.left == null && wrapper.node.right == null) {\\n    \\t\\t\\t\\tres.add(wrapper.path);\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.left != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.left, wrapper.path + \"->\" + wrapper.node.left.val));\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.right != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.right, wrapper.path + \"->\" + wrapper.node.right.val));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1066377,
                "title": "c-simple-0ms-recursive-solution",
                "content": "#### **Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\n#### Memory Usage: 13.1 MB, less than 67.34% of C++ online submissions for Binary Tree Paths.**\\n\\n```\\nclass Solution {\\npublic:\\n    void binaryTreePaths(TreeNode* root,vector<string>& res,string str){\\n        if(!root->left && !root->right){\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(root->left)\\n            binaryTreePaths(root->left,res,str + \"->\" + to_string(root->left->val));\\n        if(root->right)\\n            binaryTreePaths(root->right,res,str + \"->\" + to_string(root->right->val));\\n        \\n    } \\n        \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if (!root) return res;\\n        \\n        binaryTreePaths(root,res,to_string(root->val));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void binaryTreePaths(TreeNode* root,vector<string>& res,string str){\\n        if(!root->left && !root->right){\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(root->left)\\n            binaryTreePaths(root->left,res,str + \"->\" + to_string(root->left->val));\\n        if(root->right)\\n            binaryTreePaths(root->right,res,str + \"->\" + to_string(root->right->val));\\n        \\n    } \\n        \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if (!root) return res;\\n        \\n        binaryTreePaths(root,res,to_string(root->val));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68420,
                "title": "simple-python-solution-using-dfs-recursion",
                "content": "this solution does not require defining a new helper function. \\n\\n    class Solution:\\n        def binaryTreePaths(self, root):\\n            if not root:\\n                return []\\n            \\n            if not root.left and not root.right:\\n                return [str(root.val)]\\n    \\n            leftPathToLeaf = self.binaryTreePaths(root.left) \\n            rightPathToLeaf = self.binaryTreePaths(root.right)\\n            \\n            left = [str(root.val)+ (\"->\"+lpath ) for lpath in leftPathToLeaf]\\n            right = [str(root.val)+ (\"->\"+rpath) for rpath in rightPathToLeaf]\\n            return left+right",
                "solutionTags": [
                    "Python"
                ],
                "code": "this solution does not require defining a new helper function. \\n\\n    class Solution:\\n        def binaryTreePaths(self, root):\\n            if not root:\\n                return []\\n            \\n            if not root.left and not root.right:\\n                return [str(root.val)]\\n    \\n            leftPathToLeaf = self.binaryTreePaths(root.left) \\n            rightPathToLeaf = self.binaryTreePaths(root.right)\\n            \\n            left = [str(root.val)+ (\"->\"+lpath ) for lpath in leftPathToLeaf]\\n            right = [str(root.val)+ (\"->\"+rpath) for rpath in rightPathToLeaf]\\n            return left+right",
                "codeTag": "Java"
            },
            {
                "id": 701765,
                "title": "c-simple-classic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string ans;\\n        printNodes(root, ans, result);\\n        return result;\\n    }\\n    void printNodes(TreeNode* root, string ans, vector<string>& result)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        ans += to_string(root->val) + \"->\";\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            ans.erase(ans.length()-2, 2);\\n            result.push_back(ans);\\n        }\\n        printNodes(root->left, ans, result);\\n        printNodes(root->right, ans, result);\\n    }\\n};\\n```\\nUpvotes are encouraging!!\\nThank you :D",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string ans;\\n        printNodes(root, ans, result);\\n        return result;\\n    }\\n    void printNodes(TreeNode* root, string ans, vector<string>& result)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        ans += to_string(root->val) + \"->\";\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            ans.erase(ans.length()-2, 2);\\n            result.push_back(ans);\\n        }\\n        printNodes(root->left, ans, result);\\n        printNodes(root->right, ans, result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68427,
                "title": "accepted-0ms-c-solution",
                "content": "    int pathsNum (struct TreeNode* root);\\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex);\\n    char* stringAdd (char* s, int val);\\n    \\n    char** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n      int index = 0;\\n      if (root == NULL)  return NULL;\\n      int paths = *returnSize = pathsNum(root);\\n      char** pathsArray = (char**) calloc (paths, sizeof (char*));\\n      Traverse (root, pathsArray, \"\", &index);\\n      return pathsArray;\\n    }\\n    \\n    int pathsNum (struct TreeNode* root)\\n    {\\n      if (root == NULL)\\n        return 0;\\n      if (root->left == NULL && root->right == NULL)\\n        return 1;\\n      return pathsNum(root->left) + pathsNum(root->right);\\n    }\\n    \\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex)\\n    {\\n      char* s;\\n      if (root->left == NULL && root->right == NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        array[(*pindex)++] = s;\\n      }\\n      if (root->left != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->left, array, s, pindex);\\n        free (s);\\n      }\\n      if (root->right != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->right, array, s, pindex);\\n        free (s);\\n      }\\n    }\\n    \\n    char* stringAdd (char* s, int val)\\n    {\\n      char temp[10];\\n      if (s == \"\")\\n        sprintf (temp,\"%d\", val);\\n      else\\n        sprintf (temp, \"->%d\", val);\\n      char* snew = (char*) calloc (strlen (s) + strlen (temp) + 1, sizeof (char));\\n      strcpy (snew, s);\\n      strcat (snew, temp);\\n      return snew;\\n    }",
                "solutionTags": [],
                "code": "    int pathsNum (struct TreeNode* root);\\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex);\\n    char* stringAdd (char* s, int val);\\n    \\n    char** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n      int index = 0;\\n      if (root == NULL)  return NULL;\\n      int paths = *returnSize = pathsNum(root);\\n      char** pathsArray = (char**) calloc (paths, sizeof (char*));\\n      Traverse (root, pathsArray, \"\", &index);\\n      return pathsArray;\\n    }\\n    \\n    int pathsNum (struct TreeNode* root)\\n    {\\n      if (root == NULL)\\n        return 0;\\n      if (root->left == NULL && root->right == NULL)\\n        return 1;\\n      return pathsNum(root->left) + pathsNum(root->right);\\n    }\\n    \\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex)\\n    {\\n      char* s;\\n      if (root->left == NULL && root->right == NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        array[(*pindex)++] = s;\\n      }\\n      if (root->left != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->left, array, s, pindex);\\n        free (s);\\n      }\\n      if (root->right != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->right, array, s, pindex);\\n        free (s);\\n      }\\n    }\\n    \\n    char* stringAdd (char* s, int val)\\n    {\\n      char temp[10];\\n      if (s == \"\")\\n        sprintf (temp,\"%d\", val);\\n      else\\n        sprintf (temp, \"->%d\", val);\\n      char* snew = (char*) calloc (strlen (s) + strlen (temp) + 1, sizeof (char));\\n      strcpy (snew, s);\\n      strcat (snew, temp);\\n      return snew;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68485,
                "title": "bfs-with-two-queue-java-solution",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<String> path = new LinkedList<>();\\n        path.offer(root.val + \"\");\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            String item = path.poll();\\n            if (cur.left == null && cur.right == null) {\\n                res.add(item);\\n            }\\n            if (cur.left != null) {\\n                queue.offer(cur.left);\\n                path.offer(item + \"->\" + cur.left.val + \"\");\\n            }\\n            if (cur.right != null) {\\n                queue.offer(cur.right);\\n                path.offer(item + \"->\" + cur.right.val + \"\");\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<String> path = new LinkedList<>();\\n        path.offer(root.val + \"\");\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            String item = path.poll();\\n            if (cur.left == null && cur.right == null) {\\n                res.add(item);\\n            }\\n            if (cur.left != null) {\\n                queue.offer(cur.left);\\n                path.offer(item + \"->\" + cur.left.val + \"\");\\n            }\\n            if (cur.right != null) {\\n                queue.offer(cur.right);\\n                path.offer(item + \"->\" + cur.right.val + \"\");\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68461,
                "title": "simple-to-understand-python-solution",
                "content": "    class Solution(object):\\n        def binaryTreePaths(self, root):\\n            if root == None:\\n                return []\\n            return self.constructPaths(root, str(root.val), [])\\n\\n        def constructPaths(self, root, p, paths):\\n            if root.left == None and root.right == None:\\n                paths.append(p)\\n            if root.left:\\n                paths = self.constructPaths(root.left, p + \"->\" + str(root.left.val), paths)\\n            if root.right:\\n                paths = self.constructPaths(root.right, p + \"->\" + str(root.right.val), paths)\\n            return paths",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def binaryTreePaths(self, root):\\n            if root == None:\\n                return []\\n            return self.constructPaths(root, str(root.val), [])\\n\\n        def constructPaths(self, root, p, paths):\\n            if root.left == None and root.right == None:\\n                paths.append(p)\\n            if root.left:\\n                paths = self.constructPaths(root.left, p + \"->\" + str(root.left.val), paths)\\n            if root.right:\\n                paths = self.constructPaths(root.right, p + \"->\" + str(root.right.val), paths)\\n            return paths",
                "codeTag": "Java"
            },
            {
                "id": 68471,
                "title": "java-easy-to-understand-solution-3-line-dfs",
                "content": "Code in Java:\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>(); // stores the final output\\n        if(root==null) return res;\\n        helper(root, \"\", res);\\n        return res;\\n    }\\n    // DFS\\n    private void helper(TreeNode root, String str, List<String> res) {\\n        if(root.left==null && root.right==null) res.add(str + root.val); // reach a leaf node, completes a path\\n        if(root.left!=null)                     helper(root.left, str+root.val+\"->\", res); // recursively checks its left child\\n        if(root.right!=null)                    helper(root.right, str+root.val+\"->\", res); // recursively checks its right child\\n    }\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "Code in Java:\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>(); // stores the final output\\n        if(root==null) return res;\\n        helper(root, \"\", res);\\n        return res;\\n    }\\n    // DFS\\n    private void helper(TreeNode root, String str, List<String> res) {\\n        if(root.left==null && root.right==null) res.add(str + root.val); // reach a leaf node, completes a path\\n        if(root.left!=null)                     helper(root.left, str+root.val+\"->\", res); // recursively checks its left child\\n        if(root.right!=null)                    helper(root.right, str+root.val+\"->\", res); // recursively checks its right child\\n    }\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java",
                "codeTag": "Unknown"
            },
            {
                "id": 3640686,
                "title": "simple-dfs-in-python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find all the root-to-leaf paths, we can use a depth-first search (DFS) algorithm. We\\'ll implement a recursive helper function `solve()` that takes two parameters: the current node and the current path string. The `solve()` function will traverse the tree in a depth-first manner and append the root-to-leaf paths to the `ans` list.\\n\\nIn the `solve()` function:\\n1. Append the string representation of the current node\\'s value to the path string (`s += str(root.val)`).\\n2. Check if the current node is a leaf node (i.e., it has no left or right child). If so, it means we have reached the end of a root-to-leaf path. In this case, append the current path string to the `ans` list and return.\\n3. If the current node has a right child, recursively call `solve()` with the right child and the updated path string (`solve(root.right, s + \"->\")`).\\n4. If the current node has a left child, recursively call `solve()` with the left child and the updated path string (`solve(root.left, s + \"->\")`).\\n\\nAfter defining the `solve()` function, we initialize an empty `ans` list. Then, we call `solve()` with the `root` node and an empty path string (`\"\"`). Finally, we return the `ans` list, which contains all the root-to-leaf paths.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n        def solve(root, s):\\n            s += str(root.val)\\n            if not root.right and not root.left:\\n                ans.append(s)\\n                return\\n            if root.right:\\n                solve(root.right, s+\"->\")\\n            if root.left:\\n                solve(root.left, s+\"->\")\\n        solve(root, \"\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n        def solve(root, s):\\n            s += str(root.val)\\n            if not root.right and not root.left:\\n                ans.append(s)\\n                return\\n            if root.right:\\n                solve(root.right, s+\"->\")\\n            if root.left:\\n                solve(root.left, s+\"->\")\\n        solve(root, \"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323006,
                "title": "simple-c-4ms-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void abc(vector<string>& ans,string s,TreeNode* root){\\n        s+=to_string(root->val);\\n        if(root->left==NULL && root->right==NULL){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(root->left){\\n            abc(ans,s+\"->\",root->left);\\n        }\\n        if(root->right){\\n            // s+=\"->\";\\n            abc(ans,s+\"->\",root->right);\\n        }\\n        return;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string s=\"\";\\n        abc(ans,s,root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void abc(vector<string>& ans,string s,TreeNode* root){\\n        s+=to_string(root->val);\\n        if(root->left==NULL && root->right==NULL){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(root->left){\\n            abc(ans,s+\"->\",root->left);\\n        }\\n        if(root->right){\\n            // s+=\"->\";\\n            abc(ans,s+\"->\",root->right);\\n        }\\n        return;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string s=\"\";\\n        abc(ans,s,root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059553,
                "title": "java-recursive-dfs-explained",
                "content": "# Intuition\\nWe will begin by **Adding values in String ans** (Sublist).And If our LeafNode Condition hits that means **add current SubList In Main** and continue the procedure of Traversing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<String> list=new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String ans=\"\";\\n        path(root,ans);\\n        return list;\\n    }\\n    void path(TreeNode root, String ans) {\\n        if(root==null) return;\\n        ans=ans+root.val;\\n        if(root.left==null && root.right==null){\\n            list.add(ans);\\n            return;\\n        }\\n        ans=ans+\"->\";\\n        path(root.left,ans);\\n        path(root.right,ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<String> list=new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String ans=\"\";\\n        path(root,ans);\\n        return list;\\n    }\\n    void path(TreeNode root, String ans) {\\n        if(root==null) return;\\n        ans=ans+root.val;\\n        if(root.left==null && root.right==null){\\n            list.add(ans);\\n            return;\\n        }\\n        ans=ans+\"->\";\\n        path(root.left,ans);\\n        path(root.right,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484118,
                "title": "python-3-beats-100-nine-lines-dfs",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, R: TreeNode) -> List[str]:\\n        A, P = [], []\\n        def dfs(N):\\n            if N == None: return\\n            P.append(N.val)\\n            if (N.left,N.right) == (None,None): A.append(\\'->\\'.join(map(str,P)))\\n            else: dfs(N.left), dfs(N.right)\\n            P.pop()\\n        dfs(R)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, R: TreeNode) -> List[str]:\\n        A, P = [], []\\n        def dfs(N):\\n            if N == None: return\\n            P.append(N.val)\\n            if (N.left,N.right) == (None,None): A.append(\\'->\\'.join(map(str,P)))\\n            else: dfs(N.left), dfs(N.right)\\n            P.pop()\\n        dfs(R)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 433961,
                "title": "python-solution-dfs-path",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        self.res = []\\n        self.dfs(root, str(root.val))\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if not root.left and not root.right:\\n            self.res.append(path)\\n        if root.left:\\n            self.dfs(root.left, path + \"->\" + str(root.left.val))\\n        if root.right:\\n            self.dfs(root.right, path + \"->\" + str(root.right.val))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        self.res = []\\n        self.dfs(root, str(root.val))\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if not root.left and not root.right:\\n            self.res.append(path)\\n        if root.left:\\n            self.dfs(root.left, path + \"->\" + str(root.left.val))\\n        if root.right:\\n            self.dfs(root.right, path + \"->\" + str(root.right.val))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68423,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // import javafx.util.Pair;\\n    // dfs recursively \\n    public List<String> binaryTreePaths1(TreeNode root) {\\n        List<String> ret = new LinkedList<>();\\n        dfs(new Pair(root, \"\"), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(Pair<TreeNode, String> p, List<String> ret) {\\n        TreeNode n = p.getKey();\\n        String str = p.getValue();\\n        if (n != null) {\\n            if (n.left == null && n.right == null) {\\n                str += n.val;\\n                ret.add(str);\\n                //return;\\n            } \\n            dfs(new Pair(n.left, str+n.val+\"->\"), ret);\\n            dfs(new Pair(n.right, str+n.val+\"->\"), ret);\\n        }\\n    }\\n    \\n    // dfs iteratively\\n    public List<String> binaryTreePaths2(TreeNode root) {\\n        Stack<Pair<TreeNode, String>> stack = new Stack<>();\\n        stack.push(new Pair(root, \"\"));\\n        List<String> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, String> p = stack.pop();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += Integer.toString(n.val);\\n                    ret.add(str);\\n                }\\n                stack.push(new Pair(n.right, str+n.val+\"->\"));\\n                stack.push(new Pair(n.left, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        Queue<Pair<TreeNode, String>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, \"\"));\\n        List<String> ret = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, String> p = queue.poll();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += n.val;\\n                    ret.add(str);\\n                    //continue;\\n                }\\n                queue.add(new Pair(n.left, str+n.val+\"->\"));\\n                queue.add(new Pair(n.right, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // import javafx.util.Pair;\\n    // dfs recursively \\n    public List<String> binaryTreePaths1(TreeNode root) {\\n        List<String> ret = new LinkedList<>();\\n        dfs(new Pair(root, \"\"), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(Pair<TreeNode, String> p, List<String> ret) {\\n        TreeNode n = p.getKey();\\n        String str = p.getValue();\\n        if (n != null) {\\n            if (n.left == null && n.right == null) {\\n                str += n.val;\\n                ret.add(str);\\n                //return;\\n            } \\n            dfs(new Pair(n.left, str+n.val+\"->\"), ret);\\n            dfs(new Pair(n.right, str+n.val+\"->\"), ret);\\n        }\\n    }\\n    \\n    // dfs iteratively\\n    public List<String> binaryTreePaths2(TreeNode root) {\\n        Stack<Pair<TreeNode, String>> stack = new Stack<>();\\n        stack.push(new Pair(root, \"\"));\\n        List<String> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, String> p = stack.pop();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += Integer.toString(n.val);\\n                    ret.add(str);\\n                }\\n                stack.push(new Pair(n.right, str+n.val+\"->\"));\\n                stack.push(new Pair(n.left, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        Queue<Pair<TreeNode, String>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, \"\"));\\n        List<String> ret = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, String> p = queue.poll();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += n.val;\\n                    ret.add(str);\\n                    //continue;\\n                }\\n                queue.add(new Pair(n.left, str+n.val+\"->\"));\\n                queue.add(new Pair(n.right, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3448270,
                "title": "python-3-bfs-getting-list-of-all-paths-and-then-return-in-needed-format",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        paths = []\\n        def dfs(node, path):\\n            if not node: return\\n            path = path + [node.val]\\n            if not (node.left or node.right):\\n                return paths.append(path)\\n            dfs(node.left, path)\\n            dfs(node.right, path)\\n        dfs(root, [])\\n\\n        return [\\'->\\'.join(map(str, path)) for path in paths]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        paths = []\\n        def dfs(node, path):\\n            if not node: return\\n            path = path + [node.val]\\n            if not (node.left or node.right):\\n                return paths.append(path)\\n            dfs(node.left, path)\\n            dfs(node.right, path)\\n        dfs(root, [])\\n\\n        return [\\'->\\'.join(map(str, path)) for path in paths]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231860,
                "title": "257-time-96-78-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Here\\'s a step-by-step explanation:\\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n```\\nThe solution defines a class Solution with a method binaryTreePaths. It takes in the root node of a binary tree, represented as a TreeNode object, and returns a list of strings representing all possible paths from root to leaf nodes.\\n\\nThe variable ans is initialized as an empty list, which will store the answer.\\n\\n```\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n```\\nA depth-first search (DFS) helper function dfs is defined, which takes in a node root and a path represented as a list of strings. If the node root is None, the function returns and does nothing.\\n```\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n```\\nIf root is a leaf node (i.e. has no left or right child), the function appends the current path joined by -> and the value of the leaf node to ans. Then, the function returns and does nothing.\\n\\n```   path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n```\\nIf root is not a leaf node, the function appends the current node value followed by -> to the path. It then recursively calls dfs on the left and right children of the node. After these recursive calls are complete, the current node value is popped from the path.\\n\\n```\\n    dfs(root, [])\\n    return ans\\n```\\n\\nFinally, the dfs function is called on the root node with an empty path list, and ans is returned as the answer to the problem.\\n\\n# Complexity\\n- Time complexity:\\n96.78%\\n\\n- Space complexity:\\n63.68%\\n\\n# Code\\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n\\n      path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n\\n    dfs(root, [])\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n```\n```\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n```\n```\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n```\n```   path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n```\n```\\n    dfs(root, [])\\n    return ans\\n```\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n\\n      path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n\\n    dfs(root, [])\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051305,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string path) {\\n        if(node->left == NULL and node->right == NULL) ans.push_back(path + to_string(node->val));\\n        if(node->left) dfs(node->left, path + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, path + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string path) {\\n        if(node->left == NULL and node->right == NULL) ans.push_back(path + to_string(node->val));\\n        if(node->left) dfs(node->left, path + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, path + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783039,
                "title": "java-backtracking-solution",
                "content": "```\\nRuntime: 5 ms, faster than 70.04% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 43 MB, less than 25.59% of Java online submissions for Binary Tree Paths.\\n```\\n\\n        \\n        public List<String> binaryTreePaths(TreeNode root) {\\n\\t\\t List<String> ans = new ArrayList<>();\\n        List<String> path = new ArrayList<>();\\n        \\n        reserve(root, ans, path);\\n        return ans;\\n    }\\n    \\n    public void reserve(TreeNode root, List<String> ans , List<String> path){\\n        if(root == null) return;\\n        \\n        path.add(root.val + \"\");\\n        if(root.left == null && root.right == null){\\n            ans.add(String.join(\"->\",path));\\n        }\\n        reserve(root.left, ans, path);\\n        reserve(root.right, ans, path);\\n        \\n        path.remove(path.size()-1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nRuntime: 5 ms, faster than 70.04% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 43 MB, less than 25.59% of Java online submissions for Binary Tree Paths.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1438679,
                "title": "99-80-faster-easy-solution",
                "content": "if you found the solution easy, please **Upvote**\\n\\n\\tclass Solution {\\n    List<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) \\n    {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    \\n    \\n    void helper(TreeNode node, StringBuilder slate)\\n    {\\n        if(node==null) return;\\n        \\n        int length = slate.length();\\n        slate.append(node.val);\\n        \\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        \\n        else\\n        {\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    List<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) \\n    {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1188771,
                "title": "c-simple-dfs-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>V;\\n    \\n    void dfs(TreeNode* root, string s)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left == NULL and root->right==NULL)\\n        {\\n            V.push_back(s+to_string(root->val));\\n        }\\n        dfs(root->left, s+to_string(root->val)+\"->\");\\n        \\n        dfs(root->right, s+to_string(root->val)+\"->\");\\n        \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n     \\n        dfs(root, \"\");\\n        return V;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>V;\\n    \\n    void dfs(TreeNode* root, string s)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left == NULL and root->right==NULL)\\n        {\\n            V.push_back(s+to_string(root->val));\\n        }\\n        dfs(root->left, s+to_string(root->val)+\"->\");\\n        \\n        dfs(root->right, s+to_string(root->val)+\"->\");\\n        \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n     \\n        dfs(root, \"\");\\n        return V;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760438,
                "title": "time-complexity-analysis-string-vs-stringbuilder",
                "content": "Time Complexity: number of paths * time complexity for each path.\\n\\n**Using Strings:**\\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,\"\");\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, String str){\\n        str+= (str.length()==0) ? String.valueOf(root.val): \"->\"+String.valueOf(root.val);\\n        if(root.left==null && root.right==null) res.add(str);\\n        if(root.left!=null) binaryTreePaths(root.left,str);\\n        if(root.right!=null) binaryTreePaths(root.right,str);\\n    }\\n    \\n}\\n```\\n\\nWell balanced tree Case:\\n\\nThere will N/2 leaf nodes and max path length would be O(logn).\\nIn every path we traverse, we are adding a char to string, in every such operation a string is allocated (and copied, due to String immutability) for each node in this path, not just the leaves.\\nHence the complexity for a single path would be 1+ 2+ .....+ logn = O((logN)^2).\\nTotal complexity is O(N/2)*O(logN)^2) =  **O(N x (logN)^2).**\\n\\nNodes in Straight Line Case:\\n\\nHere there would be a single leaf path, which is of length N.\\nHence time complexity for this path: 1+2+3+..n = O(N^2).\\nSince we have a single path here, Total Complexity is =  **O(N^2).**\\n\\n**Using String Builder:**\\n\\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,new StringBuilder());\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, StringBuilder sb){        \\n        if(root==null) return;\\n        \\n        int len = sb.length();\\n        sb.append(root.val);\\n        \\n        if(root.left==null && root.right==null) \\n            res.add(sb.toString());\\n        else{\\n            sb.append(\"->\");\\n            binaryTreePaths(root.left,sb);\\n            binaryTreePaths(root.right,sb);\\n        }\\n       sb.setLength(len);\\n    }\\n}\\n```\\n\\nIn this above approach using stringBuilder i\\'m reusing the char array and unlike with string approach, the whole string will not be copied at each node. \\n\\nWell balanced tree Case:\\n\\nThere will N/2 leaf nodes and max path length would be O(logn).\\nIn a single path at every node we would only take O(1) time, so time complexity for a single path would be: O(logn)\\nHence total complexity is O(N/2)*O(logN)) = **O(N x (logN)).**\\n\\nNodes in Straight Line Case:\\n\\nSo here there would be a single leaf path, which is of length N.\\nSo time complexity for this path: O(N)\\nSince we have a single path here, total complexity = **O(N).**\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,\"\");\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, String str){\\n        str+= (str.length()==0) ? String.valueOf(root.val): \"->\"+String.valueOf(root.val);\\n        if(root.left==null && root.right==null) res.add(str);\\n        if(root.left!=null) binaryTreePaths(root.left,str);\\n        if(root.right!=null) binaryTreePaths(root.right,str);\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,new StringBuilder());\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, StringBuilder sb){        \\n        if(root==null) return;\\n        \\n        int len = sb.length();\\n        sb.append(root.val);\\n        \\n        if(root.left==null && root.right==null) \\n            res.add(sb.toString());\\n        else{\\n            sb.append(\"->\");\\n            binaryTreePaths(root.left,sb);\\n            binaryTreePaths(root.right,sb);\\n        }\\n       sb.setLength(len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589072,
                "title": "clear-and-simple-c-solution-100-faster-100-memory",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        insertPaths(root, \"\", &result);\\n        return result;\\n    }\\nprivate:\\n\\t// simple recursive pre-order traversal\\n    void insertPaths(TreeNode* node, string str, vector<string>* res) {\\n        if (!node) return;  // base-case\\n        \\n        str += to_string(node->val);\\n        if (!node->left && !node->right) {\\n\\t\\t\\t// if the current node is a leaf, add string to result\\n            res->emplace_back(str);\\n        }\\n        \\n        insertPaths(node->left, str + \"->\", res);\\n        insertPaths(node->right, str + \"->\", res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        insertPaths(root, \"\", &result);\\n        return result;\\n    }\\nprivate:\\n\\t// simple recursive pre-order traversal\\n    void insertPaths(TreeNode* node, string str, vector<string>* res) {\\n        if (!node) return;  // base-case\\n        \\n        str += to_string(node->val);\\n        if (!node->left && !node->right) {\\n\\t\\t\\t// if the current node is a leaf, add string to result\\n            res->emplace_back(str);\\n        }\\n        \\n        insertPaths(node->left, str + \"->\", res);\\n        insertPaths(node->right, str + \"->\", res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556028,
                "title": "go-recursion-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Tree Paths.\\nMemory Usage: 2.3 MB, less than 100.00% of Go online submissions for Binary Tree Paths.\\n```\\nvar arrow string = \"->\"\\n\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    ans := make([]string, 0)\\n    \\n    paths(root, \"\", &ans)\\n    \\n    return ans\\n}\\n\\nfunc paths(root *TreeNode, prefix string, ans *[]string) {\\n    if root == nil {\\n        return\\n    }\\n    \\n    if len(prefix) == 0 {\\n        prefix += strconv.Itoa(root.Val)\\n    } else {\\n        prefix += \"->\" + strconv.Itoa(root.Val)\\n    }\\n    \\n    if root.Left == nil && root.Right == nil {\\n        *ans = append(*ans, prefix)\\n        return\\n    }\\n    \\n    paths(root.Left, prefix, ans)\\n    paths(root.Right, prefix, ans)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nvar arrow string = \"->\"\\n\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    ans := make([]string, 0)\\n    \\n    paths(root, \"\", &ans)\\n    \\n    return ans\\n}\\n\\nfunc paths(root *TreeNode, prefix string, ans *[]string) {\\n    if root == nil {\\n        return\\n    }\\n    \\n    if len(prefix) == 0 {\\n        prefix += strconv.Itoa(root.Val)\\n    } else {\\n        prefix += \"->\" + strconv.Itoa(root.Val)\\n    }\\n    \\n    if root.Left == nil && root.Right == nil {\\n        *ans = append(*ans, prefix)\\n        return\\n    }\\n    \\n    paths(root.Left, prefix, ans)\\n    paths(root.Right, prefix, ans)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68378,
                "title": "4ms-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n\\n        if(!root) return res;\\n        else if(!root->left && !root->right) res.push_back(to_string(root->val));\\n        \\n        string head = to_string(root->val) + \"->\";\\n        \\n        for(auto item: binaryTreePaths(root->left)) res.push_back(head + item);\\n        for(auto item: binaryTreePaths(root->right)) res.push_back(head + item);\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n\\n        if(!root) return res;\\n        else if(!root->left && !root->right) res.push_back(to_string(root->val));\\n        \\n        string head = to_string(root->val) + \"->\";\\n        \\n        for(auto item: binaryTreePaths(root->left)) res.push_back(head + item);\\n        for(auto item: binaryTreePaths(root->right)) res.push_back(head + item);\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68499,
                "title": "c-a-clean-one-function-approach",
                "content": "    vector<string> binaryTreePaths(TreeNode* root) {\\n      if (root == nullptr)\\n        return {};\\n      if (root->left == nullptr && root->right == nullptr)\\n        return {to_string(root->val)};\\n    \\n      vector<string> left  = binaryTreePaths(root->left);\\n      vector<string> right = binaryTreePaths(root->right);\\n      left.insert(left.end(), begin(right), end(right));\\n      for (auto &e : left)\\n        e = to_string(root->val) + \"->\" + e;\\n      return left;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> binaryTreePaths(TreeNode* root) {\\n      if (root == nullptr)\\n        return {};\\n      if (root->left == nullptr && root->right == nullptr)\\n        return {to_string(root->val)};\\n    \\n      vector<string> left  = binaryTreePaths(root->left);\\n      vector<string> right = binaryTreePaths(root->right);\\n      left.insert(left.end(), begin(right), end(right));\\n      for (auto &e : left)\\n        e = to_string(root->val) + \"->\" + e;\\n      return left;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68526,
                "title": "c-recursive-and-iterative-solutions-with-detailed-comments",
                "content": "The recursive solution is trivial.\\n\\n    class Solution \\n    {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }\\n            \\n            // Get the path vector starting from the left child.\\n            vector<string> leftPaths = binaryTreePaths(root->left);\\n            // Concatenate root with the left paths to generate \\n            // the paths starting from root.\\n            for (auto& lp : leftPaths)\\n            {\\n                paths.push_back(to_string(root->val) + \"->\" + lp);\\n            }\\n            \\n            // Get the path vector starting from the right child.\\n            vector<string> rightPaths = binaryTreePaths(root->right);\\n            // Concatenate root with the right paths to generate \\n            // the paths starting from root.\\n            for (auto& rp : rightPaths)\\n            {\\n                paths.push_back(to_string(root->val) + \"->\" + rp);\\n            }\\n            \\n            // In case that both leftPaths and rightPaths are empty, \\n            // i.e., root is a leaf, root itself is a path.\\n            if (paths.empty())\\n            {\\n                paths.push_back(to_string(root->val));\\n            }\\n            \\n            return paths;\\n        }\\n    };\\n\\nThe iterative solution essentially uses the depth-first search to find all the paths from root to leaves. Compared with the breadth-first search approach, this approach doesn't need to have a vector of vectors to keep the paths from root to the nodes at the current level. Besides the result vector of strings, this approach just needs one vector which keeps one path from root to the current node and one unordered set which keeps all the nodes that have been visited during the depth-first search. Thus, with respect the space complexity, the depth-first search is more efficient than the breadth-first search.\\n\\n    class Solution \\n    {\\n        // Generate the path string from the TreeNode val vector.\\n        string GetPathStringFromNums(vector<int> &pathVal)\\n        {\\n            int n = pathVal.size();\\n            string res;\\n            // For the nodes except the last node, we need to \\n            // append \"->\" to the node values.\\n            for (int i = 0; i < n - 1; i++)\\n            {\\n                res += (to_string(pathVal[i]) + \"->\");\\n            }\\n            \\n            if (n > 0)\\n            {\\n                res += to_string(pathVal[n - 1]);\\n            }\\n            \\n            return res;\\n        }\\n        \\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector immediately.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }\\n            \\n            // pathVal is a vector of TreeNode values along a path \\n            // starting from root.\\n            vector<int> pathVal({root->val});\\n            \\n            // st is the stack used for the depth-first search.\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            \\n            // visitedNodes keeps all the nodes which have been visited \\n            // during the depth-first search. In other words, it keeps \\n            // all the nodes which have ever been pushed into the stack.\\n            unordered_set<TreeNode*> visitedNodes({root});\\n            \\n            // Do the depth-first search until the stack is empty.\\n            while (!st.empty())\\n            {\\n                TreeNode *curr = st.top();\\n    \\n                if ((curr->left == nullptr) && (curr->right == nullptr))\\n                {\\n                    // curr is a leaf, so the current path is a path from \\n                    // root to a leaf and add it to paths.\\n                    paths.push_back(GetPathStringFromNums(pathVal));\\n                    \\n                    // Remove the leaf node from pathVal which will end at \\n                    // the parent node of curr.\\n                    pathVal.pop_back();\\n                    \\n                    st.pop();\\n                }\\n                else \\n                {\\n                    // curr is not leaf, so we need to go down at least one \\n                    // level.\\n                    \\n                    // First we try pushing the left child if it hasn't \\n                    // been visited.\\n                    if (curr->left != nullptr)\\n                    {\\n                        auto itLeft = visitedNodes.find(curr->left);\\n                        if (itLeft == visitedNodes.end())\\n                        {\\n                            st.push(curr->left);\\n                            pathVal.push_back(curr->left->val);\\n                            \\n                            visitedNodes.insert(curr->left);\\n                            continue;\\n                        }\\n                    }\\n                    \\n                    // We reach here because either the left child doesn't \\n                    // exist or the left child has been visited. Then we try \\n                    // pushing the right child if it hasn't been visited.\\n                    if (curr->right != nullptr)\\n                    {\\n                        auto itRight = visitedNodes.find(curr->right);\\n                        if (itRight == visitedNodes.end())\\n                        {\\n                            st.push(curr->right);\\n                            pathVal.push_back(curr->right->val);\\n                            \\n                            visitedNodes.insert(curr->right);\\n                            continue;\\n                        }\\n                    }\\n                    \\n                    // The nodes in the subtree below curr have all been \\n                    // visited, so remove curr from pathVal which will end \\n                    // at the parent node of curr.\\n                    pathVal.pop_back();\\n                    st.pop();\\n                }\\n            }\\n            \\n            return paths;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2781823,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def backtrack(node, path, rst):\\n            children = (node.left, node.right)\\n            \\n            path.append(str(node.val))\\n\\n            if not any(children): # leaf\\n                rst.append(\\'->\\'.join(path))\\n                \\n            for child in filter(None, children):\\n                backtrack(child, path, rst)\\n                \\n            path.pop()\\n                    \\n            return rst\\n        \\n        return backtrack(root, [], [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def backtrack(node, path, rst):\\n            children = (node.left, node.right)\\n            \\n            path.append(str(node.val))\\n\\n            if not any(children): # leaf\\n                rst.append(\\'->\\'.join(path))\\n                \\n            for child in filter(None, children):\\n                backtrack(child, path, rst)\\n                \\n            path.pop()\\n                    \\n            return rst\\n        \\n        return backtrack(root, [], [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509320,
                "title": "java-recursive-solution-dfs",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        List<String>res = new ArrayList<>();\\n        fillPaths(root,\"\",res);\\n        return res;\\n    }\\n    \\n    \\n   public void fillPaths(TreeNode node,String str,List<String> res)\\n    {\\n        if (node == null)\\n            return;\\n        \\n        if(node.left == null && node.right == null)\\n        {\\n            res.add(str+node.val); \\n            return;\\n        }\\n          fillPaths(node.left, str+node.val+\"->\", res); \\n          fillPaths(node.right, str+node.val+\"->\", res); \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        List<String>res = new ArrayList<>();\\n        fillPaths(root,\"\",res);\\n        return res;\\n    }\\n    \\n    \\n   public void fillPaths(TreeNode node,String str,List<String> res)\\n    {\\n        if (node == null)\\n            return;\\n        \\n        if(node.left == null && node.right == null)\\n        {\\n            res.add(str+node.val); \\n            return;\\n        }\\n          fillPaths(node.left, str+node.val+\"->\", res); \\n          fillPaths(node.right, str+node.val+\"->\", res); \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583284,
                "title": "javascript-solution",
                "content": "```\\n\\nvar binaryTreePaths = function(root) {\\n    let result = [];\\n    traverse(root, \"\");\\n    \\n    function traverse(node, path) {\\n        if (!node) \\n            return;\\n \\n        if (!node.left  && !node.right) {\\n            result.push(path + node.val);\\n            return;\\n        }\\n        traverse(node.left, path + node.val + \"->\");\\n        traverse(node.right, path + node.val + \"->\");\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nvar binaryTreePaths = function(root) {\\n    let result = [];\\n    traverse(root, \"\");\\n    \\n    function traverse(node, path) {\\n        if (!node) \\n            return;\\n \\n        if (!node.left  && !node.right) {\\n            result.push(path + node.val);\\n            return;\\n        }\\n        traverse(node.left, path + node.val + \"->\");\\n        traverse(node.right, path + node.val + \"->\");\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237550,
                "title": "python-solution",
                "content": "Time complexity: `O(n + h*m)`, where `n` = # of nodes in the tree, `h` = height of the tree, and `m` = # of leaf nodes of the tree. In worse case, this is `O(n log n)`. Space complexity: `O(h*m)`. In worst case, this is `O(n log n)`.  \\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: \\'TreeNode\\') -> \\'List[str]\\':\\n        def dfs(root):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                tmp.append(str(root.val))\\n                res.append(\"->\".join(tmp))\\n                tmp.pop()\\n                return\\n            tmp.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n            tmp.pop()\\n        tmp = []\\n        res = []\\n        dfs(root)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: \\'TreeNode\\') -> \\'List[str]\\':\\n        def dfs(root):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                tmp.append(str(root.val))\\n                res.append(\"->\".join(tmp))\\n                tmp.pop()\\n                return\\n            tmp.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n            tmp.pop()\\n        tmp = []\\n        res = []\\n        dfs(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68463,
                "title": "2ms-java-recursive-solution-with-explaination",
                "content": "The idea is to perform a dfs, for every node we visit the path up till that node is path + currentNode.val and when we see that a node has no children we know this is one of the valid path.\\n\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> result = new ArrayList<String>();\\n        helper(root, result, \"\");\\n        return result;\\n    }\\n    public void helper(TreeNode root, List<String> result, String path){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left == null && root.right == null){\\n            result.add(path+root.val);\\n            return;\\n        }\\n        \\n        helper(root.left, result, path+root.val+\"->\");\\n        helper(root.right, result, path+root.val+\"->\");\\n        return;\\n    }",
                "solutionTags": [],
                "code": "The idea is to perform a dfs, for every node we visit the path up till that node is path + currentNode.val and when we see that a node has no children we know this is one of the valid path.\\n\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> result = new ArrayList<String>();\\n        helper(root, result, \"\");\\n        return result;\\n    }\\n    public void helper(TreeNode root, List<String> result, String path){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left == null && root.right == null){\\n            result.add(path+root.val);\\n            return;\\n        }\\n        \\n        helper(root.left, result, path+root.val+\"->\");\\n        helper(root.right, result, path+root.val+\"->\");\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68260,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null){\\n            return new ArrayList<>();\\n        }\\n        List<String> returnList = new ArrayList<>();\\n        getBinaryTreePaths(returnList,root,\"\");\\n        return returnList;\\n\\n    }\\n\\n    private void getBinaryTreePaths(List<String> returnList, TreeNode node,String base) {\\n        String current = base.length()==0?node.val+\"\":base+\"->\"+node.val;\\n        if(node.left == null && node.right == null){\\n            returnList.add(current);\\n        }\\n        if (node.left != null){\\n            getBinaryTreePaths(returnList,node.left,current);\\n        }\\n        if (node.right != null){\\n            getBinaryTreePaths(returnList,node.right,current);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null){\\n            return new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3447521,
                "title": "c-accepted-using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryPaths(TreeNode* root) {\\n      vector<string> ans;\\n     // base condition   \\n      if(root==NULL){\\n       return ans;\\n      }\\n        if(root->left ==NULL && root->right ==NULL){\\n          ans.push_back(to_string(root->val));\\n       return ans;\\n      }\\n// recursion for triversing on all node\\n     vector<string> leftt =  binaryPaths(root->left); \\n     vector<string> rightt =  binaryPaths(root->right); \\n //to add root data and -> on all solution under that node    \\n     for(int i=0;i<leftt.size();i++){\\n      ans.push_back (to_string(root->val)+\"->\"+leftt[i]);\\n     }\\n     for(int j=0;j<rightt.size();j++){\\n      ans.push_back (to_string(root->val)+\"->\"+rightt[j]);\\n     }\\n   \\n     return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n    vector<string> ans;   \\n    ans = binaryPaths(root) ;\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryPaths(TreeNode* root) {\\n      vector<string> ans;\\n     // base condition   \\n      if(root==NULL){\\n       return ans;\\n      }\\n        if(root->left ==NULL && root->right ==NULL){\\n          ans.push_back(to_string(root->val));\\n       return ans;\\n      }\\n// recursion for triversing on all node\\n     vector<string> leftt =  binaryPaths(root->left); \\n     vector<string> rightt =  binaryPaths(root->right); \\n //to add root data and -> on all solution under that node    \\n     for(int i=0;i<leftt.size();i++){\\n      ans.push_back (to_string(root->val)+\"->\"+leftt[i]);\\n     }\\n     for(int j=0;j<rightt.size();j++){\\n      ans.push_back (to_string(root->val)+\"->\"+rightt[j]);\\n     }\\n   \\n     return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n    vector<string> ans;   \\n    ans = binaryPaths(root) ;\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072837,
                "title": "back-tracking-4ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void BackTrack(TreeNode* root,string s,vector<string> &v)\\n    {\\n        if(root->left==NULL && root->right==NULL)\\n            s=s+to_string(root->val);\\n            v.push_back(s);\\n            return ;\\n        s=s+to_string(root->val)+\"->\";\\n        if(root->left!=NULL)\\n            BackTrack(root->left,s,v);\\n        if(root->right!=NULL)\\n            BackTrack(root->right,s,v);\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        BackTrack(root,\"\",v);\\n        return v;\\n    }\\n};// UPVOTE PLEASE\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void BackTrack(TreeNode* root,string s,vector<string> &v)\\n    {\\n        if(root->left==NULL && root->right==NULL)\\n            s=s+to_string(root->val);\\n            v.push_back(s);\\n            return ;\\n        s=s+to_string(root->val)+\"->\";\\n        if(root->left!=NULL)\\n            BackTrack(root->left,s,v);\\n        if(root->right!=NULL)\\n            BackTrack(root->right,s,v);\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        BackTrack(root,\"\",v);\\n        return v;\\n    }\\n};// UPVOTE PLEASE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597790,
                "title": "c-dfs-easy-commented-and-readable",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        void solve(TreeNode *root, vector<string> &ans, string s)\\n        {\\n           \\t// if the current node is not having either a left or a right then we are \\n           \\t// done with one root to leaf path so we push it into the answer\\n            if (!root->left && !root->right)\\n            {\\n                ans.push_back(s);\\n                return;\\n            }\\n\\n           \\t// we move towards either left of the root or right of the root, whichever\\n           \\t// suitable adding the current node\\'s value to the string and moving ahead\\n           \\t// this addition to our string goes on until we find our base condition break\\n            if (root->left) solve(root->left, ans, s + \"->\" + to_string(root->left->val));\\n            if (root->right) solve(root->right, ans, s + \"->\" + to_string(root->right->val));\\n        }\\n\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> ans;\\n        if (!root) return ans;\\n       \\t// we make the value of our root node as a string\\n        string s = to_string(root->val);\\n        solve(root, ans, to_string(root->val));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        void solve(TreeNode *root, vector<string> &ans, string s)\\n        {\\n           \\t// if the current node is not having either a left or a right then we are \\n           \\t// done with one root to leaf path so we push it into the answer\\n            if (!root->left && !root->right)\\n            {\\n                ans.push_back(s);\\n                return;\\n            }\\n\\n           \\t// we move towards either left of the root or right of the root, whichever\\n           \\t// suitable adding the current node\\'s value to the string and moving ahead\\n           \\t// this addition to our string goes on until we find our base condition break\\n            if (root->left) solve(root->left, ans, s + \"->\" + to_string(root->left->val));\\n            if (root->right) solve(root->right, ans, s + \"->\" + to_string(root->right->val));\\n        }\\n\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> ans;\\n        if (!root) return ans;\\n       \\t// we make the value of our root node as a string\\n        string s = to_string(root->val);\\n        solve(root, ans, to_string(root->val));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981927,
                "title": "simple-python-recursive-solution-using-preorder-traversal-with-explanation",
                "content": "**VOTE  UP  IF  YOU  LIKE  AND  UNDERSTAND  THE  SOLUTION**\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans=[]           # resultant list containing all paths.\\n        def preorder(root,s):\\n            if not root.left and not root.right:        # If leaf node occurs then path ends here so append the string in \\'ans\\'.\\n                ans.append(s+str(root.val))\\n                return\\n            s+=str(root.val)        # concatenate value of root in the path \\n            if root.left:                # If there is any node in left to traverse\\n                preorder(root.left,s+\"->\")\\n            if root.right:             # If there is any node in right to traverse\\n                preorder(root.right,s+\"->\")\\n            return\\n\\t\\t\\t\\n        preorder(root,\"\")         # main calling of preOrder with empty string\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/9143281d-9a54-419f-84a4-f00740fd4567_1650906957.1431794.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans=[]           # resultant list containing all paths.\\n        def preorder(root,s):\\n            if not root.left and not root.right:        # If leaf node occurs then path ends here so append the string in \\'ans\\'.\\n                ans.append(s+str(root.val))\\n                return\\n            s+=str(root.val)        # concatenate value of root in the path \\n            if root.left:                # If there is any node in left to traverse\\n                preorder(root.left,s+\"->\")\\n            if root.right:             # If there is any node in right to traverse\\n                preorder(root.right,s+\"->\")\\n            return\\n\\t\\t\\t\\n        preorder(root,\"\")         # main calling of preOrder with empty string\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706552,
                "title": "c-simple-using-preorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void preorder(TreeNode* root, string str){\\n        \\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> right == NULL and root -> left  == NULL){\\n            string x = to_string(root -> val);\\n            str.append(x);\\n            ans.push_back(str);\\n        }\\n        string x = to_string(root -> val);\\n        str.append(x);\\n        str.append(\"->\");\\n        preorder(root-> left, str);\\n        preorder(root -> right, str);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void preorder(TreeNode* root, string str){\\n        \\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> right == NULL and root -> left  == NULL){\\n            string x = to_string(root -> val);\\n            str.append(x);\\n            ans.push_back(str);\\n        }\\n        string x = to_string(root -> val);\\n        str.append(x);\\n        str.append(\"->\");\\n        preorder(root-> left, str);\\n        preorder(root -> right, str);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157075,
                "title": "java-clean-code-backtracking-1ms-99-86-38-7mb-96-85",
                "content": "With `List<Integer> tmp`:\\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new ArrayList<>(), new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, List<Integer> tmp, StringBuilder sb) {\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tfor (int val : tmp) {\\n\\t\\t\\tsb.append(val).append(\"->\");\\n\\t\\t}\\n\\t\\tsb.append(node.val);\\n\\t\\tcollector.add(sb.toString());\\n\\t\\tsb.setLength(0);\\n\\t\\treturn;\\n\\t}\\n\\ttmp.add(node.val);\\n\\tif (node.left != null) backTracking(node.left, collector, tmp, sb);\\n\\tif (node.right != null) backTracking(node.right, collector, tmp, sb);\\n\\ttmp.remove(tmp.size()-1);\\n}\\n```\\n\\n\\n---\\nWithout `List<Integer> tmp`:\\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, StringBuilder sb) {\\n\\tint len = sb.length();\\n\\tsb.append(node.val);\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tcollector.add(sb.toString());\\n\\t} else {\\n\\t\\tsb.append(\"->\");\\n\\t\\tif (node.left != null) backTracking(node.left, collector, sb);\\n\\t\\tif (node.right != null) backTracking(node.right, collector, sb);\\n\\t}\\n\\tsb.setLength(len);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new ArrayList<>(), new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, List<Integer> tmp, StringBuilder sb) {\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tfor (int val : tmp) {\\n\\t\\t\\tsb.append(val).append(\"->\");\\n\\t\\t}\\n\\t\\tsb.append(node.val);\\n\\t\\tcollector.add(sb.toString());\\n\\t\\tsb.setLength(0);\\n\\t\\treturn;\\n\\t}\\n\\ttmp.add(node.val);\\n\\tif (node.left != null) backTracking(node.left, collector, tmp, sb);\\n\\tif (node.right != null) backTracking(node.right, collector, tmp, sb);\\n\\ttmp.remove(tmp.size()-1);\\n}\\n```\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, StringBuilder sb) {\\n\\tint len = sb.length();\\n\\tsb.append(node.val);\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tcollector.add(sb.toString());\\n\\t} else {\\n\\t\\tsb.append(\"->\");\\n\\t\\tif (node.left != null) backTracking(node.left, collector, sb);\\n\\t\\tif (node.right != null) backTracking(node.right, collector, sb);\\n\\t}\\n\\tsb.setLength(len);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520487,
                "title": "c-faster-than-97-10-less-than-16-67-mem-o-n",
                "content": "Runtime: 236 ms\\nMemory Usage: 31.6 MB\\n\\n```\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        IList<string> result = new List<string>();\\n        StringBuilder st = new StringBuilder();\\n        BuildPath(root, st, result);\\n        return result;\\n    }\\n    \\n    private void BuildPath(TreeNode root, StringBuilder st, IList<string> result)\\n    {\\n        if (root == null) { return; }\\n        \\n        int len = st.Length; \\n        \\n        st.Append(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            result.Add(st.ToString());\\n        }\\n        else\\n        {\\n            st.Append(\"->\");\\n            BuildPath(root.left, st, result);\\n            BuildPath(root.right, st, result);\\n        }\\n        \\n        st.Length = len;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Runtime: 236 ms\\nMemory Usage: 31.6 MB\\n\\n```\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        IList<string> result = new List<string>();\\n        StringBuilder st = new StringBuilder();\\n        BuildPath(root, st, result);\\n        return result;\\n    }\\n    \\n    private void BuildPath(TreeNode root, StringBuilder st, IList<string> result)\\n    {\\n        if (root == null) { return; }\\n        \\n        int len = st.Length; \\n        \\n        st.Append(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            result.Add(st.ToString());\\n        }\\n        else\\n        {\\n            st.Append(\"->\");\\n            BuildPath(root.left, st, result);\\n            BuildPath(root.right, st, result);\\n        }\\n        \\n        st.Length = len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68437,
                "title": "my-java-solution-with-stringbuilder-may-help-u",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public void help(List<String> list, TreeNode node, StringBuilder sb) {\\n    \\t\\tif (node == null)\\n    \\t\\t\\treturn;\\n    \\t\\tint len=sb.length();\\n    \\t\\tsb.append(node.val);\\n    \\t\\tif (node.left == null && node.right == null) {\\t\\t\\t\\t\\n    \\t\\t\\tlist.add(sb.toString());\\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tsb.append(\"->\");\\n    \\t\\thelp(list, node.left, sb);\\n    \\t\\thelp(list, node.right, sb);\\n    \\t\\tsb.setLength(len);\\n    \\t}\\n    \\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new ArrayList<String>();\\n    \\t\\thelp(res, root, new StringBuilder());\\n    \\t\\treturn res;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void help(List<String> list, TreeNode node, StringBuilder sb) {\\n    \\t\\tif (node == null)\\n    \\t\\t\\treturn;\\n    \\t\\tint len=sb.length();\\n    \\t\\tsb.append(node.val);\\n    \\t\\tif (node.left == null && node.right == null) {\\t\\t\\t\\t\\n    \\t\\t\\tlist.add(sb.toString());\\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 68489,
                "title": "my-recursive-javascript-solution",
                "content": "     /**\\n     * Definition for a binary tree node.\\n     * function TreeNode(val) {\\n     *     this.val = val;\\n     *     this.left = this.right = null;\\n     * }\\n     */\\n    /**\\n     * @param {TreeNode} root\\n     * @return {string[]}\\n     */\\n    var binaryTreePaths = function(root) {\\n        var result = [];\\n    \\n        var findPath = function(node, path) {\\n            if(!node) {\\n                return;\\n            } else {\\n                path += node.val;\\n            }\\n            \\n            if(!node.left && !node.right) {\\n                return result.push(path);\\n            } else {\\n                path += \"->\";\\n            }\\n            \\n            if(node.left) {\\n                findPath(node.left, path);\\n            }\\n            \\n            if(node.right) {\\n                findPath(node.right, path);\\n            }\\n        }\\n        \\n        findPath(root, \"\");\\n        return result;\\n    };",
                "solutionTags": [],
                "code": "     /**\\n     * Definition for a binary tree node.\\n     * function TreeNode(val) {\\n     *     this.val = val;\\n     *     this.left = this.right = null;\\n     * }\\n     */\\n    /**\\n     * @param {TreeNode} root\\n     * @return {string[]}\\n     */\\n    var binaryTreePaths = function(root) {\\n        var result = [];\\n    \\n        var findPath = function(node, path) {\\n            if(!node) {\\n                return;\\n            } else {\\n                path += node.val;\\n            }\\n            \\n            if(!node.left && !node.right) {\\n                return result.push(path);\\n            } else {\\n                path += \"->\";\\n            }\\n            \\n            if(node.left) {\\n                findPath(node.left, path);\\n            }\\n            \\n            if(node.right) {\\n                findPath(node.right, path);\\n            }\\n        }\\n        \\n        findPath(root, \"\");\\n        return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 68520,
                "title": "myjavaeasysolution",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<String>();\\n        if(root != null){\\n            res.addAll(binaryTreePaths(root.left));\\n            res.addAll(binaryTreePaths(root.right));\\n            for(int i=0; i < res.size();i++){\\n                String path = root.val+\"->\"+res.get(i);\\n                res.set(i,path);\\n            }\\n            \\n            if(res.size()==0) res.add(String.valueOf(root.val));\\n        }\\n        return res;\\n         \\n    }",
                "solutionTags": [],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<String>();\\n        if(root != null){\\n            res.addAll(binaryTreePaths(root.left));\\n            res.addAll(binaryTreePaths(root.right));\\n            for(int i=0; i < res.size();i++){\\n                String path = root.val+\"->\"+res.get(i);\\n                res.set(i,path);\\n            }\\n            \\n            if(res.size()==0) res.add(String.valueOf(root.val));\\n        }\\n        return res;\\n         \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3654265,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520019,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode * root, vector<string>&ans, string s)\\n    {\\n        if(!root)return;\\n        if(!root->left && !root->right)\\n        {\\n            s += to_string(root->val);\\n            ans.push_back(s);\\n        }\\n        s += to_string(root->val);\\n        solve(root->left, ans, s+\"->\");\\n        solve(root->right, ans, s+\"->\");\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string s = \"\";\\n        vector<string>ans;\\n        solve(root, ans, s);    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode * root, vector<string>&ans, string s)\\n    {\\n        if(!root)return;\\n        if(!root->left && !root->right)\\n        {\\n            s += to_string(root->val);\\n            ans.push_back(s);\\n        }\\n        s += to_string(root->val);\\n        solve(root->left, ans, s+\"->\");\\n        solve(root->right, ans, s+\"->\");\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string s = \"\";\\n        vector<string>ans;\\n        solve(root, ans, s);    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168127,
                "title": "binary-tree-path-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPre-order traversal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0. Do the pre-order traversal.\\n1. Kepp collecting the node values in an array.\\n2. As soon as get the leaf child, push the current collection of nodes in the answer array.\\n3. At end just convert all the paths as per output requirement\\n4. Return you final collection of paths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(no. of nodes in widest level)$$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {string[]}\\n */\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n\\n    function preOrder(node,currPath){\\n        if(node){\\n            currPath.push(node.val);\\n            if(node.left==null && node.right==null){\\n                paths.push([...currPath]);\\n            }\\n            preOrder(node.left,[...currPath]);\\n            preOrder(node.right,[...currPath]);\\n        }\\n    }\\n    preOrder(root,[]);\\n    let ans = paths.map(path => path.join(\"->\"))\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {string[]}\\n */\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n\\n    function preOrder(node,currPath){\\n        if(node){\\n            currPath.push(node.val);\\n            if(node.left==null && node.right==null){\\n                paths.push([...currPath]);\\n            }\\n            preOrder(node.left,[...currPath]);\\n            preOrder(node.right,[...currPath]);\\n        }\\n    }\\n    preOrder(root,[]);\\n    let ans = paths.map(path => path.join(\"->\"))\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642914,
                "title": "python-recursive-approach-easy-to-understand",
                "content": "**Approach 1:**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        result = []\\n        def dfs(temp, root):\\n            if root:\\n                temp = temp + str(root.val) + \\'->\\'\\n                if not root.left and not root.right:\\n                    result.append(temp[:-2])\\n                dfs(temp, root.left)\\n                dfs(temp, root.right)\\n        dfs(\\'\\', root)\\n        return result\\n```\\n**Approach 2:**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return []\\n        result, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.right and not node.left:\\n                result.append(ls+str(node.val))\\n            if node.right:\\n                stack.append([node.right, ls + str(node.val) + \\'->\\'])\\n            if node.left:\\n                stack.append([node.left, ls + str(node.val) + \\'->\\'])\\n        return result\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        result = []\\n        def dfs(temp, root):\\n            if root:\\n                temp = temp + str(root.val) + \\'->\\'\\n                if not root.left and not root.right:\\n                    result.append(temp[:-2])\\n                dfs(temp, root.left)\\n                dfs(temp, root.right)\\n        dfs(\\'\\', root)\\n        return result\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return []\\n        result, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.right and not node.left:\\n                result.append(ls+str(node.val))\\n            if node.right:\\n                stack.append([node.right, ls + str(node.val) + \\'->\\'])\\n            if node.left:\\n                stack.append([node.left, ls + str(node.val) + \\'->\\'])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584597,
                "title": "java-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> list = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        dfs(root,s);\\n        return list;\\n    }\\n    public void dfs(TreeNode root, String s){\\n        if(root!=null){\\n            if(root.left==null && root.right==null){\\n                list.add(s+root.val);\\n            }\\n            dfs(root.left,s+root.val+\"->\");\\n            dfs(root.right,s+root.val+\"->\");\\n        }\\n    }\\n}\\n```\\n# upvote if u found it useful",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> list = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        dfs(root,s);\\n        return list;\\n    }\\n    public void dfs(TreeNode root, String s){\\n        if(root!=null){\\n            if(root.left==null && root.right==null){\\n                list.add(s+root.val);\\n            }\\n            dfs(root.left,s+root.val+\"->\");\\n            dfs(root.right,s+root.val+\"->\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523403,
                "title": "python-solutions-using-dfs-and-bfs",
                "content": "## DFS with Recursion\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n    \\n        res = []\\n        def paths(root, path):\\n            if not any([root.left, root.right]):\\n                res.append(path)\\n                \\n            paths(root.left, path + \\'->\\' + str(root.left.val)) if root.left else None\\n            paths(root.right, path + \\'->\\' + str(root.right.val)) if root.right else None\\n        \\n        paths(root, str(root.val))\\n        return res\\n```\\n\\n## BFS Iterative Solution\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n        \\n        q=[(root, str(root.val))]\\n        res = []\\n        \\n        while q:\\n            \\n            node, path_upto_node = q.pop()\\n            \\n            if not any([node.left, node.right]):\\n                res.append(path_upto_node)\\n            \\n            else:\\n                q.append((node.left, path_upto_node + \\'->\\' + str(node.left.val))) if node.left else None\\n                q.append((node.right, path_upto_node + \\'->\\' + str(node.right.val))) if node.right else None\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n    \\n        res = []\\n        def paths(root, path):\\n            if not any([root.left, root.right]):\\n                res.append(path)\\n                \\n            paths(root.left, path + \\'->\\' + str(root.left.val)) if root.left else None\\n            paths(root.right, path + \\'->\\' + str(root.right.val)) if root.right else None\\n        \\n        paths(root, str(root.val))\\n        return res\\n```\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n        \\n        q=[(root, str(root.val))]\\n        res = []\\n        \\n        while q:\\n            \\n            node, path_upto_node = q.pop()\\n            \\n            if not any([node.left, node.right]):\\n                res.append(path_upto_node)\\n            \\n            else:\\n                q.append((node.left, path_upto_node + \\'->\\' + str(node.left.val))) if node.left else None\\n                q.append((node.right, path_upto_node + \\'->\\' + str(node.right.val))) if node.right else None\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335365,
                "title": "c-easy-beats-100",
                "content": "\\n    vector<string> ans; \\n    \\n    void treePath(TreeNode* root, string s){\\n        if(!root) return; // Base case\\n        s += to_string(root->val); // Adding the current node\\'s value to string\\n\\t\\t\\n\\t\\t// if root has any of the the child present then only add \"->\" to current string\\n        if(root->left || root->right){ \\n            s += \"->\";\\n        }\\n\\t\\t\\n\\t\\t// if current node has no children then push the current string to ans vector\\n        if(!root->left && !root->right){\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t// recursive call\\n        treePath(root->left,s);\\n        treePath(root->right,s);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        treePath(root,\"\");\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "\\n    vector<string> ans; \\n    \\n    void treePath(TreeNode* root, string s){\\n        if(!root) return; // Base case\\n        s += to_string(root->val); // Adding the current node\\'s value to string\\n\\t\\t\\n\\t\\t// if root has any of the the child present then only add \"->\" to current string\\n        if(root->left || root->right){ \\n            s += \"->\";\\n        }\\n\\t\\t\\n\\t\\t// if current node has no children then push the current string to ans vector\\n        if(!root->left && !root->right){\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t// recursive call\\n        treePath(root->left,s);\\n        treePath(root->right,s);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        treePath(root,\"\");\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1650763,
                "title": "java-dfs-short-simple-100-faster",
                "content": "```\\nclass Solution {\\n    List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new LinkedList<>();\\n        paths(root,\"\");\\n        return ans;\\n    }\\n    void paths(TreeNode root, String s){\\n        if(root==null){\\n            return;\\n        }\\n        if(root.left==null && root.right==null){\\n            ans.add(s.concat(String.valueOf(root.val)));\\n        }\\n        paths(root.left, s.concat(String.valueOf(root.val).concat(\"->\")));\\n        paths(root.right, s.concat(String.valueOf(root.val).concat(\"->\")));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new LinkedList<>();\\n        paths(root,\"\");\\n        return ans;\\n    }\\n    void paths(TreeNode root, String s){\\n        if(root==null){\\n            return;\\n        }\\n        if(root.left==null && root.right==null){\\n            ans.add(s.concat(String.valueOf(root.val)));\\n        }\\n        paths(root.left, s.concat(String.valueOf(root.val).concat(\"->\")));\\n        paths(root.right, s.concat(String.valueOf(root.val).concat(\"->\")));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625427,
                "title": "c-understanble-recursion",
                "content": "**_Upvote if you found solution useful_**\\n\\n---\\n```C++\\nclass Solution\\n{\\npublic:\\n    void solve(TreeNode *root, vector<string> &res, string curr)\\n    {\\n        if (root->left == NULL and root->right == NULL)\\n        {\\n            curr += to_string(root->val);\\n            res.push_back(curr);\\n            return;\\n        }\\n        string s = to_string(root->val) + \"->\";\\n        if (root->left and !root->right)\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n        }\\n        else if (root->right and !root->left)\\n        {\\n            curr += s;\\n            solve(root->right, res, curr);\\n        }\\n        else\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n            solve(root->right, res, curr);\\n        }\\n    }\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> res;\\n        solve(root, res, \"\");\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    void solve(TreeNode *root, vector<string> &res, string curr)\\n    {\\n        if (root->left == NULL and root->right == NULL)\\n        {\\n            curr += to_string(root->val);\\n            res.push_back(curr);\\n            return;\\n        }\\n        string s = to_string(root->val) + \"->\";\\n        if (root->left and !root->right)\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n        }\\n        else if (root->right and !root->left)\\n        {\\n            curr += s;\\n            solve(root->right, res, curr);\\n        }\\n        else\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n            solve(root->right, res, curr);\\n        }\\n    }\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> res;\\n        solve(root, res, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590704,
                "title": "simple-c-soln-using-preorder-traversal",
                "content": "Please upvote if found useful! :))\\nNew suggestions are welcome!\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    void preorder(TreeNode *root,string temp){       \\n        if(!root)\\n            return;\\n        //add the current node value\\n        if(temp == \"\") temp += to_string(root->val);\\n        else temp += \"->\"+to_string(root->val);\\n        //if the current node is leaf, then add it to the answer array\\n        if(root->left==NULL && root->right==NULL)\\n            ans.push_back(temp);\\n        //perform preorder traversal\\n        preorder(root->left,temp);\\n        preorder(root->right,temp);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(!root) return ans;\\n        preorder(root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    void preorder(TreeNode *root,string temp){       \\n        if(!root)\\n            return;\\n        //add the current node value\\n        if(temp == \"\") temp += to_string(root->val);\\n        else temp += \"->\"+to_string(root->val);\\n        //if the current node is leaf, then add it to the answer array\\n        if(root->left==NULL && root->right==NULL)\\n            ans.push_back(temp);\\n        //perform preorder traversal\\n        preorder(root->left,temp);\\n        preorder(root->right,temp);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(!root) return ans;\\n        preorder(root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470608,
                "title": "c-0ms-100-beats",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void fun(TreeNode* root,string s)\\n    {\\n        if(!root->left && !root->right) ans.push_back(s);\\n        if(root->left) fun(root->left,s+\"->\"+to_string(root->left->val));\\n        if(root->right) fun(root->right,s+\"->\"+to_string(root->right->val));\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        s+=to_string(root->val);\\n        fun(root,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void fun(TreeNode* root,string s)\\n    {\\n        if(!root->left && !root->right) ans.push_back(s);\\n        if(root->left) fun(root->left,s+\"->\"+to_string(root->left->val));\\n        if(root->right) fun(root->right,s+\"->\"+to_string(root->right->val));\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        s+=to_string(root->val);\\n        fun(root,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367748,
                "title": "java-stringbuilder-recursion-preorder-easy-1ms-solution",
                "content": "Create a String or StringBuilder(mutable) traverse the tree in preOrder, add node Values until you find a null & at leaf add the node and return.\\n```\\n List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new ArrayList<>();\\n        solve(root, new StringBuilder());\\n        return ans;\\n    }\\n    public void solve(TreeNode root, StringBuilder res){\\n        if(root == null)\\n            return;\\n        \\n        int len = res.length();\\n        res.append(root.val);\\n        if(root.left == null && root.right == null){\\n            ans.add(res.toString());\\n        }\\n        else{\\n            res.append(\"->\");\\n            if(root.left != null)\\n                solve(root.left, res);\\n            if(root.right != null)\\n                solve(root.right, res);\\n        }\\n        res.setLength(len);\\n    }\\n```\\nTime Complexity : `O(N)`\\nN number of nodes\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new ArrayList<>();\\n        solve(root, new StringBuilder());\\n        return ans;\\n    }\\n    public void solve(TreeNode root, StringBuilder res){\\n        if(root == null)\\n            return;\\n        \\n        int len = res.length();\\n        res.append(root.val);\\n        if(root.left == null && root.right == null){\\n            ans.add(res.toString());\\n        }\\n        else{\\n            res.append(\"->\");\\n            if(root.left != null)\\n                solve(root.left, res);\\n            if(root.right != null)\\n                solve(root.right, res);\\n        }\\n        res.setLength(len);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574735,
                "title": "java-dfs-recursive-easy-to-understand-with-explaination",
                "content": "The template function is quite straightforward.\\nIn the recursive function, we first check if the root is null, then it will return without doing anything (this covers the original test case of root being null, as the empty res will be returned). Now, we add the value of the root to the current path string value.\\nbecause we need the path with arrows, pass the string with arrows in the dfs recursion calls.\\nNo need to check for empty root.left or root.right, because it is taken care of at the start of the recursive function.\\nAt the end, check if both children are null. If so, add the current string to the res list.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        writePaths(root, res, \"\");\\n        return res;\\n    }\\n    public void writePaths(TreeNode root, List<String> res, String curr){\\n        if(root == null) return;\\n        curr += root.val;\\n        writePaths(root.left, res, curr+\"->\");\\n        writePaths(root.right, res, curr+\"->\");\\n        if(root.left == null && root.right == null) res.add(curr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        writePaths(root, res, \"\");\\n        return res;\\n    }\\n    public void writePaths(TreeNode root, List<String> res, String curr){\\n        if(root == null) return;\\n        curr += root.val;\\n        writePaths(root.left, res, curr+\"->\");\\n        writePaths(root.right, res, curr+\"->\");\\n        if(root.left == null && root.right == null) res.add(curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299070,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        var result = new List<string>();\\n        DFS(root, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(TreeNode root, IList<string> oneResult, IList<string> result) {\\n        if (root == null) return;\\n        oneResult.Add($\"{root.val}\");\\n        if (root.left == null && root.right == null) {\\n            // leaf\\n            result.Add(string.Join(\"->\", oneResult));\\n        } else {\\n            DFS(root.left, oneResult, result);\\n            DFS(root.right, oneResult, result);\\n        }\\n        oneResult.RemoveAt(oneResult.Count - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        var result = new List<string>();\\n        DFS(root, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(TreeNode root, IList<string> oneResult, IList<string> result) {\\n        if (root == null) return;\\n        oneResult.Add($\"{root.val}\");\\n        if (root.left == null && root.right == null) {\\n            // leaf\\n            result.Add(string.Join(\"->\", oneResult));\\n        } else {\\n            DFS(root.left, oneResult, result);\\n            DFS(root.right, oneResult, result);\\n        }\\n        oneResult.RemoveAt(oneResult.Count - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131174,
                "title": "7-lines-in-kotlin-easy-to-understand",
                "content": "```\\nfun binaryTreePaths(root: TreeNode?): List<String> {\\n        if (root == null)\\n            return emptyList()\\n\\n        if (root.left == null && root.right == null)\\n            return listOf(root.`val`.toString())\\n\\n        val left = binaryTreePaths(root.left)\\n        val right = binaryTreePaths(root.right)\\n\\n        return (left + right).map { root.`val`.toString() + \"->\" + it }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun binaryTreePaths(root: TreeNode?): List<String> {\\n        if (root == null)\\n            return emptyList()\\n\\n        if (root.left == null && root.right == null)\\n            return listOf(root.`val`.toString())\\n\\n        val left = binaryTreePaths(root.left)\\n        val right = binaryTreePaths(root.right)\\n\\n        return (left + right).map { root.`val`.toString() + \"->\" + it }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68333,
                "title": "c-solution-0ms-using-asprintf-to-dynamically-grow-the-path-buffer",
                "content": "```\\nvoid binaryTreePathsHelper(struct TreeNode *node, char ***result, int *resultSize, char *path) {\\n    if (!node) return;\\n    char *newPath = NULL;\\n    if (node->left == NULL && node->right == NULL) {\\n        asprintf(&newPath, \"%s%d\", path, node->val);\\n        *result = realloc(*result, ++(*resultSize) * sizeof(char **));\\n        (*result)[*resultSize - 1] = newPath;\\n        return;   \\n    }\\n    asprintf(&newPath, \"%s%d->\", path, node->val);\\n    binaryTreePathsHelper(node->left, result, resultSize, newPath);\\n    binaryTreePathsHelper(node->right, result, resultSize, newPath);\\n    free(newPath);\\n}\\n\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    if (!root) return NULL;\\n    char **result = NULL;\\n    binaryTreePathsHelper(root, &result, returnSize, \"\");\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid binaryTreePathsHelper(struct TreeNode *node, char ***result, int *resultSize, char *path) {\\n    if (!node) return;\\n    char *newPath = NULL;\\n    if (node->left == NULL && node->right == NULL) {\\n        asprintf(&newPath, \"%s%d\", path, node->val);\\n        *result = realloc(*result, ++(*resultSize) * sizeof(char **));\\n        (*result)[*resultSize - 1] = newPath;\\n        return;   \\n    }\\n    asprintf(&newPath, \"%s%d->\", path, node->val);\\n    binaryTreePathsHelper(node->left, result, resultSize, newPath);\\n    binaryTreePathsHelper(node->right, result, resultSize, newPath);\\n    free(newPath);\\n}\\n\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    if (!root) return NULL;\\n    char **result = NULL;\\n    binaryTreePathsHelper(root, &result, returnSize, \"\");\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68466,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> vecRet;\\n            if (root == NULL) return vecRet;\\n            string s = \"\";\\n            getTreePaths(vecRet, s, root);\\n            \\n            return vecRet;\\n        }\\n        void getTreePaths(vector<string> &vecRet, string s, TreeNode *root) {\\n            if (root == NULL) return;\\n            \\n            s += to_string(root->val);\\n            if (root->left == NULL && root->right == NULL)//the current node is leaf,then put s into vecRet\\n                vecRet.push_back(s);\\n            else\\n                s += \"->\";\\n    \\n            getTreePaths(vecRet, s, root->left);//recur in left subtree\\n            getTreePaths(vecRet, s, root->right);//recur in right subtree\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> vecRet;\\n            if (root == NULL) return vecRet;\\n            string s = \"\";\\n            getTreePaths(vecRet, s, root);\\n            \\n            return vecRet;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68398,
                "title": "binary-tree-paths-dfs-java-solution",
                "content": "\\npublic class Solution {\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n\\n        List<String> ret = new ArrayList<String>();\\n        \\n        if(root == null){\\n            return ret;\\n        }\\n        \\n        dfs(root, new StringBuilder(), ret);\\n        \\n        return ret;\\n    }\\n    \\n    public void dfs(TreeNode root, StringBuilder sb, List<String> ret){\\n\\n       if(root.left == null && root.right == null){\\n           sb.append(root.val);\\n           ret.add(sb.toString());\\n           return;\\n       }\\n        \\n       sb.append(root.val);\\n       sb.append(\"->\");\\n       \\n       if(root.left != null){\\n           dfs(root.left, new StringBuilder(sb), ret);\\n       }\\n       \\n       if(root.right != null){\\n           dfs(root.right, new StringBuilder(sb), ret);\\n       }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n\\n        List<String> ret = new ArrayList<String>();\\n        \\n        if(root == null){\\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3832627,
                "title": "java-short-easy-recursive-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) stack space in memory\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n      List<String> ans = new ArrayList<>();\\n      if(root != null) dfs(root, \"\", ans);\\n      return ans;   \\n    }\\n    public void dfs(TreeNode root, String path, List<String> ans) {\\n        if(root.left == null && root.right == null) ans.add(path + root.val);\\n        if(root.left != null) dfs(root.left, path + root.val + \"->\", ans);\\n        if(root.right != null) dfs(root.right, path + root.val + \"->\", ans);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n      List<String> ans = new ArrayList<>();\\n      if(root != null) dfs(root, \"\", ans);\\n      return ans;   \\n    }\\n    public void dfs(TreeNode root, String path, List<String> ans) {\\n        if(root.left == null && root.right == null) ans.add(path + root.val);\\n        if(root.left != null) dfs(root.left, path + root.val + \"->\", ans);\\n        if(root.right != null) dfs(root.right, path + root.val + \"->\", ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619326,
                "title": "java-program-to-get-all-possible-path-of-tree",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `binaryTreePath` method takes three parameters: `root` (the current node in the binary tree), `path` (a string representing the path from the root to the current node), and `list` (a list to store all the paths).\\n   \\n2. The first condition checks if the `root` is null, which means we have reached the end of a path. In this case, it simply returns the `list` as it is.\\n\\n3. The second condition checks if the current node is a leaf node (i.e., it doesn\\'t have any left or right child). If it is a leaf node, it means we have reached the end of a path, so we add the current path (`path + root.val`) to the `list` and return the updated `list`.\\n\\n4. If the above conditions are not met, it means we are still traversing the tree. We recursively call the `binaryTreePath` method for the left child of the current node, passing the updated `path` (including the current node value and an arrow \"->\") and the same `list`.\\n\\n5. Similarly, we recursively call the `binaryTreePath` method for the right child of the current node, passing the updated `path` and the same `list`.\\n\\n6. Finally, after traversing all the paths, we return the `list` containing all the paths.\\n\\n7. The `binaryTreePaths` method is the public interface for this functionality. It initializes an empty list (`list`) and calls the `binaryTreePath` method with the `root` of the binary tree, an empty string as the initial path, and the `list`.\\n\\n8. It returns the `list` containing all the paths from the root to the leaf nodes in the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePath(TreeNode root,String path,List<String> list){\\n        if(root == null){\\n            return list;\\n        }\\n        if(root.left == null && root.right == null){\\n            list.add(path + root.val);\\n            return list;\\n        }\\n        binaryTreePath(root.left,(path + root.val + \"->\"),list);\\n        binaryTreePath(root.right,(path + root.val + \"->\"),list);\\n        return list;\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        binaryTreePath(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePath(TreeNode root,String path,List<String> list){\\n        if(root == null){\\n            return list;\\n        }\\n        if(root.left == null && root.right == null){\\n            list.add(path + root.val);\\n            return list;\\n        }\\n        binaryTreePath(root.left,(path + root.val + \"->\"),list);\\n        binaryTreePath(root.right,(path + root.val + \"->\"),list);\\n        return list;\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        binaryTreePath(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432756,
                "title": "binbin-s-another-brilliant-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if root.left is None and root.right is None:\\n            return [str(root.val)]\\n        def findpath(node,l,L):\\n            if node.left is None and node.right is None:\\n                l += str(node.val)\\n                L.append(l)\\n            if node.left is not None:\\n                findpath(node.left,l+str(node.val)+\"->\",L)\\n            if node.right is not None:\\n                findpath(node.right,l+str(node.val)+\"->\",L)\\n            return L      \\n       \\n        return findpath(root,\"\",[])\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if root.left is None and root.right is None:\\n            return [str(root.val)]\\n        def findpath(node,l,L):\\n            if node.left is None and node.right is None:\\n                l += str(node.val)\\n                L.append(l)\\n            if node.left is not None:\\n                findpath(node.left,l+str(node.val)+\"->\",L)\\n            if node.right is not None:\\n                findpath(node.right,l+str(node.val)+\"->\",L)\\n            return L      \\n       \\n        return findpath(root,\"\",[])\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338140,
                "title": "most-simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        List l=new ArrayList<>();\\n        return solve(root,l,s);\\n    }\\n    public List<String> solve(TreeNode root,List l, String s){\\n        if(root==null) return l;\\n        if(root.left==null && root.right==null){    //if it is a leaf node\\n            l.add(s+root.val);\\n            return l;\\n        }\\n        s= s+root.val+\"->\";\\n        solve(root.left, l, s);\\n        solve(root.right, l, s);\\n        return l;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        List l=new ArrayList<>();\\n        return solve(root,l,s);\\n    }\\n    public List<String> solve(TreeNode root,List l, String s){\\n        if(root==null) return l;\\n        if(root.left==null && root.right==null){    //if it is a leaf node\\n            l.add(s+root.val);\\n            return l;\\n        }\\n        s= s+root.val+\"->\";\\n        solve(root.left, l, s);\\n        solve(root.right, l, s);\\n        return l;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296439,
                "title": "java-recursive-solution",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    List<String> li = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        helper(root, \"\");\\n        for(int i=0;i<li.size();i++)\\n        li.set(i, li.get(i).substring(2));\\n        return li;\\n    }\\n    void helper(TreeNode root , String curr)\\n    {\\n        if(root == null)\\n        return;\\n\\n        if(root.left == null && root.right == null)\\n        li.add(curr + \"->\" + root.val );\\n        \\n        helper(root.left, curr + \"->\" + root.val);\\n        helper(root.right, curr + \"->\" + root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<String> li = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        helper(root, \"\");\\n        for(int i=0;i<li.size();i++)\\n        li.set(i, li.get(i).substring(2));\\n        return li;\\n    }\\n    void helper(TreeNode root , String curr)\\n    {\\n        if(root == null)\\n        return;\\n\\n        if(root.left == null && root.right == null)\\n        li.add(curr + \"->\" + root.val );\\n        \\n        helper(root.left, curr + \"->\" + root.val);\\n        helper(root.right, curr + \"->\" + root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042190,
                "title": "c-easy-and-fast-solution-recursion",
                "content": "TC:O(N)\\nSC: Auxilairy Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<string> solve(TreeNode* &root){\\n        //base case\\n        if(root==NULL)return {};\\n        \\n        vector<string>ans;\\n        string root_val = to_string(root->val);\\n        vector<string>left  = solve(root->left);\\n        vector<string>right = solve(root->right);\\n        for(auto it:left)ans.push_back(root_val + \"->\" + it);\\n        for(auto it:right)ans.push_back(root_val + \"->\" + it);\\n        \\n        if(ans.size()==0)return{root_val};\\n        return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        return solve(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> solve(TreeNode* &root){\\n        //base case\\n        if(root==NULL)return {};\\n        \\n        vector<string>ans;\\n        string root_val = to_string(root->val);\\n        vector<string>left  = solve(root->left);\\n        vector<string>right = solve(root->right);\\n        for(auto it:left)ans.push_back(root_val + \"->\" + it);\\n        for(auto it:right)ans.push_back(root_val + \"->\" + it);\\n        \\n        if(ans.size()==0)return{root_val};\\n        return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        return solve(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042042,
                "title": "java-simple-easy-and-fast-solution",
                "content": "\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        DFS(root,\"\",list);\\n        return list ;\\n    }\\n    \\n    public void DFS(TreeNode root , String ans , List<String> list){\\n        if(root == null){\\n            return ;\\n        }\\n        if(root.left==null && root.right==null){\\n            list.add(ans+root.val);\\n            return ;\\n        }\\n        \\n        DFS(root.left,ans+root.val+\"->\",list);\\n        DFS(root.right,ans+root.val+\"->\",list);\\n    }\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        DFS(root,\"\",list);\\n        return list ;\\n    }\\n    \\n    public void DFS(TreeNode root , String ans , List<String> list){\\n        if(root == null){\\n            return ;\\n        }\\n        if(root.left==null && root.right==null){\\n            list.add(ans+root.val);\\n            return ;\\n        }\\n        \\n        DFS(root.left,ans+root.val+\"->\",list);\\n        DFS(root.right,ans+root.val+\"->\",list);\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3013848,
                "title": "using-reccursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n         List<string> paths = new List<string>();\\n        string s = \"\";\\n        FindPath(root, s);\\n        void FindPath(TreeNode root,string s1)\\n        {\\n            if (root != null)\\n            {\\n                if (root.left == null && root.right == null)\\n                {\\n                    s1 = s1 + root.val;\\n                    paths.Add(s1);\\n                }\\n                else\\n                {\\n                    s1 = s1 + root.val + \"->\";\\n                    FindPath(root.left, s1);\\n                    FindPath(root.right, s1);\\n\\n                }\\n            }\\n        }\\n        return paths;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n         List<string> paths = new List<string>();\\n        string s = \"\";\\n        FindPath(root, s);\\n        void FindPath(TreeNode root,string s1)\\n        {\\n            if (root != null)\\n            {\\n                if (root.left == null && root.right == null)\\n                {\\n                    s1 = s1 + root.val;\\n                    paths.Add(s1);\\n                }\\n                else\\n                {\\n                    s1 = s1 + root.val + \"->\";\\n                    FindPath(root.left, s1);\\n                    FindPath(root.right, s1);\\n\\n                }\\n            }\\n        }\\n        return paths;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680229,
                "title": "python-dfs-easy-to-understand-faster-than-81",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        \\n        res = []\\n        \\n        def dfs(root,s):\\n            \\n            if not root.left and not root.right:\\n                s = s + str(root.val)\\n                res.append(s)\\n                \\n            s = s+ str(root.val)+\"->\"    \\n            \\n            if root.left:\\n                left = dfs(root.left,s)\\n            \\n            if root.right:\\n                right = dfs(root.right,s)\\n            \\n            \\n        dfs(root,\"\")\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        \\n        res = []\\n        \\n        def dfs(root,s):\\n            \\n            if not root.left and not root.right:\\n                s = s + str(root.val)\\n                res.append(s)\\n                \\n            s = s+ str(root.val)+\"->\"    \\n            \\n            if root.left:\\n                left = dfs(root.left,s)\\n            \\n            if root.right:\\n                right = dfs(root.right,s)\\n            \\n            \\n        dfs(root,\"\")\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662822,
                "title": "java-easy-recursive-solution",
                "content": "```\\nclass Solution {\\n    void traverse(TreeNode root,String str,List<String> list ){\\n        if(root!=null){\\n            str+= (root.val+\"\");\\n            if(root.left==null && root.right==null){\\n                list.add(str);\\n            }\\n            str+=\"->\";\\n            traverse(root.left,str,list);\\n            traverse(root.right,str,list);\\n        }\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        String str = \"\";\\n        traverse(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void traverse(TreeNode root,String str,List<String> list ){\\n        if(root!=null){\\n            str+= (root.val+\"\");\\n            if(root.left==null && root.right==null){\\n                list.add(str);\\n            }\\n            str+=\"->\";\\n            traverse(root.left,str,list);\\n            traverse(root.right,str,list);\\n        }\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        String str = \"\";\\n        traverse(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581377,
                "title": "super-simple-dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root)\\n            return {};\\n        if (!root->left && !root->right)\\n            return {to_string(root->val)};\\n\\n        vector<string> output;\\n        for (auto node : binaryTreePaths(root->left))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n        for (auto node : binaryTreePaths(root->right))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root)\\n            return {};\\n        if (!root->left && !root->right)\\n            return {to_string(root->val)};\\n\\n        vector<string> output;\\n        for (auto node : binaryTreePaths(root->left))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n        for (auto node : binaryTreePaths(root->right))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455753,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        dfs(root, \"\", ans);\\n        return ans;\\n    }\\n\\n    private void dfs(TreeNode root, String s, List<String> ans){\\n        \\n        if (root == null) return;\\n\\n        if (root.left == null && root.right == null){\\n            s += root.val;\\n            ans.add(s);\\n        }\\n\\n        s += \"\" + root.val + \"->\";\\n\\n        dfs(root.left, s, ans);\\n        dfs(root.right, s,ans);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2449587,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q257. Binary Tree Paths***\\nGiven the `root` of a binary tree, return all root-to-leaf paths in **any order.**\\n\\nA **leaf**  is a node with no children.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return\\n        res =[]\\n        self.preorder(root,\"\",res)\\n        return res\\n    def preorder(self,node,path,res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path,node.val))\\n        self.preorder(node.left,\"{}{}->\".format(path,node.val),res)\\n        self.preorder(node.right,\"{}{}->\".format(path,node.val),res)\\n        \\n```\\n**Runtime:**  54 ms\\t\\n**Memory Usage:**  13.8 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> v=new ArrayList<>();\\n        if(root!=null)\\n            preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode r,List<String> v,String s)\\n    {\\n        if(r==null)\\n            return;\\n        if(s.isEmpty())\\n            s+=r.val;\\n        else s+=(\"->\"+r.val);\\n        if(r.left!=null||r.right!=null)\\n        {\\n            preorder(r.left,v,s);\\n            preorder(r.right,v,s);\\n        }\\n        else\\n            v.add(s);\\n    }\\n}\\n```\\n**Runtime:**  12 ms\\t4\\n**Memory Usage:**  43.3 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nlass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        if(root)\\n         preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode* r,vector<string>&v,string s)\\n    {\\n        if (!r)\\n            return ;\\n        if(!s.empty())\\n            s+=(\"->\"+to_string(r->val));\\n        else s+=to_string(r->val);\\n        if(r->left||r->right)\\n        {\\n            preorder(r->left,v,s);\\n            preorder(r->right,v,s);\\n        }\\n        else\\n            v.push_back(s);\\n        \\n    }\\n};\\n```\\n**Runtime:** 3 ms\\t\\t\\n**Memory Usage:**  13.3 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return\\n        res =[]\\n        self.preorder(root,\"\",res)\\n        return res\\n    def preorder(self,node,path,res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path,node.val))\\n        self.preorder(node.left,\"{}{}->\".format(path,node.val),res)\\n        self.preorder(node.right,\"{}{}->\".format(path,node.val),res)\\n        \\n```\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> v=new ArrayList<>();\\n        if(root!=null)\\n            preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode r,List<String> v,String s)\\n    {\\n        if(r==null)\\n            return;\\n        if(s.isEmpty())\\n            s+=r.val;\\n        else s+=(\"->\"+r.val);\\n        if(r.left!=null||r.right!=null)\\n        {\\n            preorder(r.left,v,s);\\n            preorder(r.right,v,s);\\n        }\\n        else\\n            v.add(s);\\n    }\\n}\\n```\n```\\nlass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        if(root)\\n         preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode* r,vector<string>&v,string s)\\n    {\\n        if (!r)\\n            return ;\\n        if(!s.empty())\\n            s+=(\"->\"+to_string(r->val));\\n        else s+=to_string(r->val);\\n        if(r->left||r->right)\\n        {\\n            preorder(r->left,v,s);\\n            preorder(r->right,v,s);\\n        }\\n        else\\n            v.push_back(s);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253948,
                "title": "java-100-faster-solution-1ms-easy",
                "content": "# Please Upvote Bro \\uD83E\\uDD7A\\n\\n```\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 42.2 MB, less than 96.55% of Java online submissions for Binary Tree Paths.\\n```\\n\\n```\\nList<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    void helper(TreeNode node, StringBuilder slate){\\n        if(node==null) return;\\n        int length = slate.length();\\n        slate.append(node.val);\\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        else{\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 42.2 MB, less than 96.55% of Java online submissions for Binary Tree Paths.\\n```\n```\\nList<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    void helper(TreeNode node, StringBuilder slate){\\n        if(node==null) return;\\n        int length = slate.length();\\n        slate.append(node.val);\\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        else{\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192255,
                "title": "c-dfs-recursion-100-faster-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,string s,vector<string>&ans)\\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans.push_back(s);\\n            return ;\\n        }\\n        s+=\"->\";\\n        dfs(root->left,s,ans);\\n        dfs(root->right,s,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string>ans;\\n        dfs(root,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,string s,vector<string>&ans)\\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans.push_back(s);\\n            return ;\\n        }\\n        s+=\"->\";\\n        dfs(root->left,s,ans);\\n        dfs(root->right,s,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string>ans;\\n        dfs(root,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138269,
                "title": "c-easy-to-understand-3ms-solution-recursion-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void TreePaths(TreeNode* root, string path, vector<string> &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            path += to_string(root->val);\\n            ans.push_back(path);\\n            return;\\n            \\n        }\\n        path += (to_string(root->val)) + \"->\";\\n        TreePaths(root->left,path,ans);\\n        TreePaths(root->right,path,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        vector<string> ans;\\n        TreePaths(root,\"\", ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void TreePaths(TreeNode* root, string path, vector<string> &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            path += to_string(root->val);\\n            ans.push_back(path);\\n            return;\\n            \\n        }\\n        path += (to_string(root->val)) + \"->\";\\n        TreePaths(root->left,path,ans);\\n        TreePaths(root->right,path,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        vector<string> ans;\\n        TreePaths(root,\"\", ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778386,
                "title": "c-backtracking",
                "content": "My answer for this problem.\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<string> vs; \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root == nullptr) return vs;\\n        string rootStr = to_string(root->val); \\n        btp(root, rootStr);\\n        return vs;\\n    }\\n    void btp(TreeNode* root, string &str) {\\n        if(root->left == nullptr && root->right == nullptr) { \\n            vs.push_back(str);\\n        }\\n        if(root->left != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->left->val);\\n            btp(root->left, newstr);\\n        } \\n        if(root->right != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->right->val);\\n            btp(root->right, newstr);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<string> vs; \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root == nullptr) return vs;\\n        string rootStr = to_string(root->val); \\n        btp(root, rootStr);\\n        return vs;\\n    }\\n    void btp(TreeNode* root, string &str) {\\n        if(root->left == nullptr && root->right == nullptr) { \\n            vs.push_back(str);\\n        }\\n        if(root->left != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->left->val);\\n            btp(root->left, newstr);\\n        } \\n        if(root->right != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->right->val);\\n            btp(root->right, newstr);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630587,
                "title": "82-runtime-99-92-memory-a-simple-way-to-improve-the-memory-usage",
                "content": "C formatting functions (`printf`, `snprintf`, `fprintf`) are still widely used in production codes over the C++ streams. In anycase, the idea below generalizes to any programming language. \\n\\n- Allocate a static character buffer\\n- Keep a variable to track the number of characters written to the buffer during tree-traversal\\n\\n```\\nstatic char buffer[1000];\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\n        \\nclass Solution {\\npublic:\\n    \\n    vector<string> ret;        \\n    void iter(TreeNode* root, int len) {\\n        if(!root) { return; }\\n        if(root && !root->left && !root->right) {\\n            snprintf(&buffer[len], sizeof(buffer)-len, \"%d\", root->val);\\n            ret.emplace_back(buffer);\\n            return;\\n        }\\n\\n        int n = snprintf(&buffer[len], sizeof(buffer)-len, \"%d->\", root->val);\\n        iter(root->left, len+n);\\n        iter(root->right, len+n);            \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {        \\n        iter(root, 0);        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic char buffer[1000];\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\n        \\nclass Solution {\\npublic:\\n    \\n    vector<string> ret;        \\n    void iter(TreeNode* root, int len) {\\n        if(!root) { return; }\\n        if(root && !root->left && !root->right) {\\n            snprintf(&buffer[len], sizeof(buffer)-len, \"%d\", root->val);\\n            ret.emplace_back(buffer);\\n            return;\\n        }\\n\\n        int n = snprintf(&buffer[len], sizeof(buffer)-len, \"%d->\", root->val);\\n        iter(root->left, len+n);\\n        iter(root->right, len+n);            \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {        \\n        iter(root, 0);        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560520,
                "title": "c-100-faster-solution-binary-tree-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n         if(root == nullptr){\\n            vector<string> v;    return v;\\n        } else if(root->left == nullptr && root->right == nullptr){\\n            vector<string> v;\\n            v.push_back(to_string(root->val));        return v;\\n        }\\n        \\n        vector<string> left = binaryTreePaths(root->left);\\n        for(int i = 0; i < left.size(); ++i){\\n            left[i] = to_string(root->val) + \"->\" + left[i];\\n        }\\n        \\n        vector<string> right = binaryTreePaths(root->right);\\n        for(int i = 0; i < right.size(); ++i){\\n            right[i] = to_string(root->val) + \"->\" + right[i];  \\n        }\\n        \\n        vector<string> res;\\n        for(auto x: left)       res.push_back(x);\\n        for(auto x: right)       res.push_back(x);\\n        return res;\\n    }\\n};\\n```\\n\\n**Result-**\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\nMemory Usage: 13.8 MB, less than 17.49% of C++ online submissions for Binary Tree Paths.\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n         if(root == nullptr){\\n            vector<string> v;    return v;\\n        } else if(root->left == nullptr && root->right == nullptr){\\n            vector<string> v;\\n            v.push_back(to_string(root->val));        return v;\\n        }\\n        \\n        vector<string> left = binaryTreePaths(root->left);\\n        for(int i = 0; i < left.size(); ++i){\\n            left[i] = to_string(root->val) + \"->\" + left[i];\\n        }\\n        \\n        vector<string> right = binaryTreePaths(root->right);\\n        for(int i = 0; i < right.size(); ++i){\\n            right[i] = to_string(root->val) + \"->\" + right[i];  \\n        }\\n        \\n        vector<string> res;\\n        for(auto x: left)       res.push_back(x);\\n        for(auto x: right)       res.push_back(x);\\n        return res;\\n    }\\n};\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\nMemory Usage: 13.8 MB, less than 17.49% of C++ online submissions for Binary Tree Paths.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528336,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        if(root != null)    path(root,\"\",list);\\n        return list;\\n    }\\n    private void path(TreeNode root, String pth, List<String> list){\\n        if(root.left == null && root.right == null)     list.add(pth+root.val);\\n        if(root.left != null)   path(root.left, pth+root.val+\"->\", list);\\n        if(root.right != null)   path(root.right, pth+root.val+\"->\", list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        if(root != null)    path(root,\"\",list);\\n        return list;\\n    }\\n    private void path(TreeNode root, String pth, List<String> list){\\n        if(root.left == null && root.right == null)     list.add(pth+root.val);\\n        if(root.left != null)   path(root.left, pth+root.val+\"->\", list);\\n        if(root.right != null)   path(root.right, pth+root.val+\"->\", list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516595,
                "title": "javascript-100-simple-dfs-backtracking-solution",
                "content": "```\\nconst binaryTreePaths = (root, paths = [], path = []) => {\\n  path.push(root.val);\\n  if (!root.right && !root.left) paths.push(path.join(\\'->\\'));\\n  root.left && binaryTreePaths(root.left, paths, path);\\n  root.right && binaryTreePaths(root.right, paths, path);\\n  path.pop();\\n  return paths;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst binaryTreePaths = (root, paths = [], path = []) => {\\n  path.push(root.val);\\n  if (!root.right && !root.left) paths.push(path.join(\\'->\\'));\\n  root.left && binaryTreePaths(root.left, paths, path);\\n  root.right && binaryTreePaths(root.right, paths, path);\\n  path.pop();\\n  return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277191,
                "title": "c-easy-solution-recursive",
                "content": "``` \\n void helper(TreeNode* root ,string c,vector<string> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else if(!root->left&&!root->right){\\n            c+=to_string(root->val);\\n            v.push_back(c);\\n            return;\\n        }\\n        c+=to_string(root->val);\\n        c+=\"->\";\\n        helper(root->left,c,v);\\n        helper(root->right,c,v);\\n       \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n       vector<string> v;\\n        \\n        helper(root,\"\",v);\\n        \\n        return v;\\n    }\\n\\t\\n\\t``` \\n\\n",
                "solutionTags": [],
                "code": "``` \\n void helper(TreeNode* root ,string c,vector<string> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else if(!root->left&&!root->right){\\n            c+=to_string(root->val);\\n            v.push_back(c);\\n            return;\\n        }\\n        c+=to_string(root->val);\\n        c+=\"->\";\\n        helper(root->left,c,v);\\n        helper(root->right,c,v);\\n       \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n       vector<string> v;\\n        \\n        helper(root,\"\",v);\\n        \\n        return v;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167548,
                "title": "javascript-recursion-stack-easy-understand",
                "content": "Recursion\\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var travel = function(node, path) {\\n        if(!node.left && !node.right) result.push(path.join(\\'->\\')); //reach leaf\\n        if(node.left) travel(node.left, [...path, node.left.val]); // left child exists, keep going\\n        if(node.right) travel(node.right, [...path, node.right.val]); //right child exists, keep going\\n    }\\n    travel(root, [root.val]);\\n    return result;\\n};\\n```\\n\\nStack\\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var stack = [[root, [root.val]]];\\n    while(stack.length) {\\n        var element = stack.pop();\\n        var node = element[0];\\n        if(!node.left && !node.right) result.push(element[1].join(\\'->\\'));\\n        if(node.left) stack.push([node.left, [...element[1], node.left.val]]);\\n        if(node.right) stack.push([node.right, [...element[1], node.right.val]]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var travel = function(node, path) {\\n        if(!node.left && !node.right) result.push(path.join(\\'->\\')); //reach leaf\\n        if(node.left) travel(node.left, [...path, node.left.val]); // left child exists, keep going\\n        if(node.right) travel(node.right, [...path, node.right.val]); //right child exists, keep going\\n    }\\n    travel(root, [root.val]);\\n    return result;\\n};\\n```\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var stack = [[root, [root.val]]];\\n    while(stack.length) {\\n        var element = stack.pop();\\n        var node = element[0];\\n        if(!node.left && !node.right) result.push(element[1].join(\\'->\\'));\\n        if(node.left) stack.push([node.left, [...element[1], node.left.val]]);\\n        if(node.right) stack.push([node.right, [...element[1], node.right.val]]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114192,
                "title": "python-solutions-dfs-recursive-and-iterative",
                "content": "dfs recursive:\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs recursive\\n        res = []\\n        def dfs(root,string):\\n            if not root: return\\n            if not (root.left or root.right):\\n                res.append(string+str(root.val))\\n            if root.left:\\n                dfs(root.left,string+str(root.val)+\"->\")\\n            if root.right:\\n                dfs(root.right,string+str(root.val)+\"->\")\\n        dfs(root,\"\")\\n        return res\\n```\\n\\ndfs iterative:\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs iterative\\n        stack,res = [(root,\"\")],[]\\n        while stack:\\n            node,path = stack.pop()\\n            if not (node.left or node.right):\\n                res.append(path+str(node.val))\\n            if node.left:\\n                stack.append((node.left,path+str(node.val)+\"->\"))\\n            if node.right:\\n                stack.append((node.right,path+str(node.val)+\"->\"))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs recursive\\n        res = []\\n        def dfs(root,string):\\n            if not root: return\\n            if not (root.left or root.right):\\n                res.append(string+str(root.val))\\n            if root.left:\\n                dfs(root.left,string+str(root.val)+\"->\")\\n            if root.right:\\n                dfs(root.right,string+str(root.val)+\"->\")\\n        dfs(root,\"\")\\n        return res\\n```\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs iterative\\n        stack,res = [(root,\"\")],[]\\n        while stack:\\n            node,path = stack.pop()\\n            if not (node.left or node.right):\\n                res.append(path+str(node.val))\\n            if node.left:\\n                stack.append((node.left,path+str(node.val)+\"->\"))\\n            if node.right:\\n                stack.append((node.right,path+str(node.val)+\"->\"))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931366,
                "title": "backtrack-beat-99-58-and-100",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #backtracking\\n        path,values = [], []\\n        if not root:\\n            return path\\n        self.backtracking(root, values, path)\\n        return path\\n    \\n    def isLeaf(self, node):    #determine if leaf node\\n        return not node.left and not node.right\\n    \\n    def buildPath(self, values):\\n        string = \\'\\'\\n        for i in range(len(values)):\\n            string += str(values[i])\\n            if i != len(values)-1:\\n                string += \\'->\\'    #add -> beteween 2 numbers\\n        return string\\n    \\n    def backtracking(self, node, values, path):\\n        if not node:\\n            return \\n        values.append(node.val)\\n        if self.isLeaf(node):\\n            path.append(self.buildPath(values))     #find a path, add it to the answer\\n        else:\\n            self.backtracking(node.left, values, path)    #goto left  leaf\\n            self.backtracking(node.right, values, path)  #goto right leaf\\n        values.pop()    #backtrack to the origin to find another solution\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #backtracking\\n        path,values = [], []\\n        if not root:\\n            return path\\n        self.backtracking(root, values, path)\\n        return path\\n    \\n    def isLeaf(self, node):    #determine if leaf node\\n        return not node.left and not node.right\\n    \\n    def buildPath(self, values):\\n        string = \\'\\'\\n        for i in range(len(values)):\\n            string += str(values[i])\\n            if i != len(values)-1:\\n                string += \\'->\\'    #add -> beteween 2 numbers\\n        return string\\n    \\n    def backtracking(self, node, values, path):\\n        if not node:\\n            return \\n        values.append(node.val)\\n        if self.isLeaf(node):\\n            path.append(self.buildPath(values))     #find a path, add it to the answer\\n        else:\\n            self.backtracking(node.left, values, path)    #goto left  leaf\\n            self.backtracking(node.right, values, path)  #goto right leaf\\n        values.pop()    #backtrack to the origin to find another solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900188,
                "title": "best-easiest-solution-for-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if root is None:return \\n        paths = []\\n        \\n        if root.left is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.left)]\\n        \\n        if root.right is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.right)]\\n    \\n        \\n        return paths if paths != [] else [str(root.val)]\\n        \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if root is None:return \\n        paths = []\\n        \\n        if root.left is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.left)]\\n        \\n        if root.right is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.right)]\\n    \\n        \\n        return paths if paths != [] else [str(root.val)]\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 887855,
                "title": "rust-0ms-100",
                "content": "```rust\\n/*\\nlearn a lot from\\nhttps://leetcode.com/problems/binary-tree-paths/discuss/733347/Rust-cheapest-and-best\\n */\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn binary_tree_paths(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<String> {\\n        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\\n            let mut ans = vec![];\\n            if let Some(node) = root {\\n                let node = node.borrow();\\n                let (left, right) = (&node.left, &node.right);\\n                if left.is_none() && right.is_none() {\\n                    ans.push(vec![node.val]);\\n                } else {\\n                    [left, right].iter().for_each(|&branch| {\\n                        ans.extend(dfs(branch).into_iter().map(|mut p| {\\n                            p.push(node.val);\\n                            p\\n                        }))\\n                    });\\n                }\\n            }\\n            ans\\n        }\\n\\n        dfs(&root)\\n            .iter()\\n            .map(|v| {\\n                v.iter()\\n                    .rev()\\n                    .map(|i| i.to_string())\\n                    .collect::<Vec<String>>()\\n                    .join(\"->\")\\n            })\\n            .collect()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_binary_tree_paths() {\\n        let root = Some(Rc::new(RefCell::new(TreeNode {\\n            val: 1,\\n            left: Some(Rc::new(RefCell::new(TreeNode {\\n                val: 2,\\n                left: None,\\n                right: Some(Rc::new(RefCell::new(TreeNode::new(5)))),\\n            }))),\\n            right: Some(Rc::new(RefCell::new(TreeNode::new(3)))),\\n        })));\\n        assert_eq!(\\n            Solution::binary_tree_paths(root),\\n            vec![\"1->2->5\".to_owned(), \"1->3\".to_owned()]\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n/*\\nlearn a lot from\\nhttps://leetcode.com/problems/binary-tree-paths/discuss/733347/Rust-cheapest-and-best\\n */\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn binary_tree_paths(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<String> {\\n        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\\n            let mut ans = vec![];\\n            if let Some(node) = root {\\n                let node = node.borrow();\\n                let (left, right) = (&node.left, &node.right);\\n                if left.is_none() && right.is_none() {\\n                    ans.push(vec![node.val]);\\n                } else {\\n                    [left, right].iter().for_each(|&branch| {\\n                        ans.extend(dfs(branch).into_iter().map(|mut p| {\\n                            p.push(node.val);\\n                            p\\n                        }))\\n                    });\\n                }\\n            }\\n            ans\\n        }\\n\\n        dfs(&root)\\n            .iter()\\n            .map(|v| {\\n                v.iter()\\n                    .rev()\\n                    .map(|i| i.to_string())\\n                    .collect::<Vec<String>>()\\n                    .join(\"->\")\\n            })\\n            .collect()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_binary_tree_paths() {\\n        let root = Some(Rc::new(RefCell::new(TreeNode {\\n            val: 1,\\n            left: Some(Rc::new(RefCell::new(TreeNode {\\n                val: 2,\\n                left: None,\\n                right: Some(Rc::new(RefCell::new(TreeNode::new(5)))),\\n            }))),\\n            right: Some(Rc::new(RefCell::new(TreeNode::new(3)))),\\n        })));\\n        assert_eq!(\\n            Solution::binary_tree_paths(root),\\n            vec![\"1->2->5\".to_owned(), \"1->3\".to_owned()]\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765151,
                "title": "c-faster-than-100-preorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    void preorder(TreeNode* root, string add)\\n    {\\n        if(!root)\\n            return;\\n        if(add.size() != 0)\\n            add += \"->\";\\n        add += to_string(root -> val);\\n        if(root -> left == nullptr and root -> right == nullptr)\\n            ans.push_back(add);\\n        preorder(root -> left, add);\\n        preorder(root -> right, add);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        preorder(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    void preorder(TreeNode* root, string add)\\n    {\\n        if(!root)\\n            return;\\n        if(add.size() != 0)\\n            add += \"->\";\\n        add += to_string(root -> val);\\n        if(root -> left == nullptr and root -> right == nullptr)\\n            ans.push_back(add);\\n        preorder(root -> left, add);\\n        preorder(root -> right, add);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        preorder(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677005,
                "title": "java-recursion-2ms-top-99-94-memory-solution-based-on-strignbuilder",
                "content": "```\\n\\tpublic List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        final List<String> result = new ArrayList<>();\\n        binaryTreePathsRec(root, new StringBuilder(), result);\\n        return result;\\n    }\\n    \\n    private void binaryTreePathsRec(TreeNode root, StringBuilder currentPath, List<String> output) {\\n        if (root.left == null && root.right == null) {\\n            output.add(new StringBuilder(currentPath).append(root.val).toString());\\n            return;\\n        }\\n        \\n        if (root.left != null) {\\n            binaryTreePathsRec(root.left, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n        \\n        if (root.right != null) {\\n            binaryTreePathsRec(root.right, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        final List<String> result = new ArrayList<>();\\n        binaryTreePathsRec(root, new StringBuilder(), result);\\n        return result;\\n    }\\n    \\n    private void binaryTreePathsRec(TreeNode root, StringBuilder currentPath, List<String> output) {\\n        if (root.left == null && root.right == null) {\\n            output.add(new StringBuilder(currentPath).append(root.val).toString());\\n            return;\\n        }\\n        \\n        if (root.left != null) {\\n            binaryTreePathsRec(root.left, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n        \\n        if (root.right != null) {\\n            binaryTreePathsRec(root.right, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566039,
                "title": "python-dfs-recursive-and-bfs-queue",
                "content": "DFS Recursive \\n\\n```\\n   def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        self.paths = []\\n        \\n        def dfs(root, path):\\n            path += str(root.val)\\n            if not root.left and not root.right:\\n                self.paths.append(path)\\n            \\n            if root.left:\\n                dfs(root.left, path + \\'->\\')\\n            if root.right:\\n                dfs(root.right, path + \\'->\\')\\n            return\\n        \\n        if root:\\n            dfs(root, \\'\\')\\n        return self.paths\\n\\n```\\n\\nBFS + Queue\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        \\n        paths, start = [str(root.val)], 0\\n        layer = [root]  # queue\\n        \\n        while layer:\\n            root = layer.pop(0)\\n            if root.left:\\n                paths.append(paths[start] + \\'->\\' + str(root.left.val))\\n                layer.append(root.left)\\n            if root.right:\\n                paths.append(paths[start] + \\'->\\' +  str(root.right.val))\\n                layer.append(root.right)\\n            if not root.left and not root.right:\\n                start += 1\\n            else:\\n                paths.pop(start)\\n        \\n        return paths\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        self.paths = []\\n        \\n        def dfs(root, path):\\n            path += str(root.val)\\n            if not root.left and not root.right:\\n                self.paths.append(path)\\n            \\n            if root.left:\\n                dfs(root.left, path + \\'->\\')\\n            if root.right:\\n                dfs(root.right, path + \\'->\\')\\n            return\\n        \\n        if root:\\n            dfs(root, \\'\\')\\n        return self.paths\\n\\n```\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        \\n        paths, start = [str(root.val)], 0\\n        layer = [root]  # queue\\n        \\n        while layer:\\n            root = layer.pop(0)\\n            if root.left:\\n                paths.append(paths[start] + \\'->\\' + str(root.left.val))\\n                layer.append(root.left)\\n            if root.right:\\n                paths.append(paths[start] + \\'->\\' +  str(root.right.val))\\n                layer.append(root.right)\\n            if not root.left and not root.right:\\n                start += 1\\n            else:\\n                paths.pop(start)\\n        \\n        return paths\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 550969,
                "title": "go",
                "content": "```\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    if root == nil {\\n        return nil\\n    }\\n    result := []string{}\\n    helper(root, strconv.Itoa(root.Val), &result)\\n    return result\\n}\\n\\nfunc helper(root *TreeNode, str string, result *[]string) {\\n    if root.Left == nil && root.Right == nil {\\n        *result = append(*result, str)\\n        return\\n    }\\n    if root.Left != nil {\\n        helper(root.Left, str +\"->\" + strconv.Itoa(root.Left.Val), result)\\n    }\\n    if root.Right != nil {\\n        helper(root.Right, str +\"->\" + strconv.Itoa(root.Right.Val), result)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    if root == nil {\\n        return nil\\n    }\\n    result := []string{}\\n    helper(root, strconv.Itoa(root.Val), &result)\\n    return result\\n}\\n\\nfunc helper(root *TreeNode, str string, result *[]string) {\\n    if root.Left == nil && root.Right == nil {\\n        *result = append(*result, str)\\n        return\\n    }\\n    if root.Left != nil {\\n        helper(root.Left, str +\"->\" + strconv.Itoa(root.Left.Val), result)\\n    }\\n    if root.Right != nil {\\n        helper(root.Right, str +\"->\" + strconv.Itoa(root.Right.Val), result)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535561,
                "title": "simple-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<String>();\\n        helper(root, \"\", ans);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root, String temp, List<String> ans) {\\n        if(root == null) return;\\n        else if(root.left == null && root.right == null) {\\n            ans.add(temp + root.val);\\n            return;\\n        } else {\\n            helper(root.left, temp + root.val + \"->\", ans);\\n            helper(root.right, temp + root.val + \"->\", ans);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<String>();\\n        helper(root, \"\", ans);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root, String temp, List<String> ans) {\\n        if(root == null) return;\\n        else if(root.left == null && root.right == null) {\\n            ans.add(temp + root.val);\\n            return;\\n        } else {\\n            helper(root.left, temp + root.val + \"->\", ans);\\n            helper(root.right, temp + root.val + \"->\", ans);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432674,
                "title": "very-simple-and-easy-ruby-solution-using-stack-beats-100",
                "content": "```\\ndef binary_tree_paths(root)\\n  @stack = []\\n  @result = []\\n  preorder(root)\\n  @result\\nend\\n\\ndef preorder(node)\\n  return if node.nil?\\n  @stack.push(node.val)\\n  preorder(node.left)\\n  preorder(node.right)\\n  @result << @stack.join(\"->\") if !node.left && !node.right\\n  @stack.pop\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\ndef binary_tree_paths(root)\\n  @stack = []\\n  @result = []\\n  preorder(root)\\n  @result\\nend\\n\\ndef preorder(node)\\n  return if node.nil?\\n  @stack.push(node.val)\\n  preorder(node.left)\\n  preorder(node.right)\\n  @result << @stack.join(\"->\") if !node.left && !node.right\\n  @stack.pop\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 426760,
                "title": "simple-dfs-javascript-readable-code-for-humans-both-recursive-iterative",
                "content": "simpler recursive code\\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```\\nIterative\\n```js\\n// iterative\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    let stack = [root]\\n    let pathStack = [\"\"]\\n    while(stack.length !== 0) {\\n        let node = stack.pop()\\n        let path = pathStack.pop()\\n        path += node.val\\n        if(!node.left && !node.right) {\\n            paths.push(path)            \\n        }\\n        path += \\'->\\'\\n        if(node.left) {\\n            stack.push(node.left) \\n            pathStack.push(path)\\n        }\\n        if(node.right) {\\n            stack.push(node.right) \\n            pathStack.push(path)\\n        }\\n    }\\n    return paths\\n};\\n```\\nless simple recursive\\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```\n```js\\n// iterative\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    let stack = [root]\\n    let pathStack = [\"\"]\\n    while(stack.length !== 0) {\\n        let node = stack.pop()\\n        let path = pathStack.pop()\\n        path += node.val\\n        if(!node.left && !node.right) {\\n            paths.push(path)            \\n        }\\n        path += \\'->\\'\\n        if(node.left) {\\n            stack.push(node.left) \\n            pathStack.push(path)\\n        }\\n        if(node.right) {\\n            stack.push(node.right) \\n            pathStack.push(path)\\n        }\\n    }\\n    return paths\\n};\\n```\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158022,
                "title": "python-dfs",
                "content": "### 257. Binary Tree Paths\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386 | \\u5206\\u5236\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS\\u904D\\u5386\\n\\n\\u8FD9\\u91CC\\u5229\\u7528str\\u662Fimmutable\\u7684\\u7279\\u6027\\uFF0C\\u4E0D\\u9700\\u8981\\u8003\\u8651\\u6BCF\\u6B21backtrack\\u65F6\\u5019\\u5BF9temp\\u6570\\u7EC4\\u7684\\u66F4\\u6539\\u3002\\n\\u9012\\u5F52\\u601D\\u8DEF\\u4E09\\u79CD\\uFF1A\\n1. \\u5982\\u679C\\u6CA1\\u6709\\u5DE6\\u53F3\\u5B69\\u5B50\\uFF1A\\u5C06`temp`\\u5B58\\u5165\\u8FD4\\u56DE\\u6570\\u7EC4`res`\\n2/3: \\u5982\\u679C\\u6709\\u5DE6\\u6216\\u8005\\u53F3\\uFF0C\\u9012\\u5F52\\u5E76\\u4E14\\u66F4\\u65B0`temp`\\n\\n```python\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        self.dfs(root, res, \\'\\')\\n        return res\\n    \\n    def dfs(self, root, res, temp):\\n        temp += str(root.val)\\n        if not root.left and not root.right:\\n            res.append(temp)\\n        if root.left:\\n            self.dfs(root.left, res, temp + \\'->\\')\\n        if root.right:\\n            self.dfs(root.right, res, temp + \\'->\\')\\n```\\n\\n#### DFS\\u5206\\u5236\\n\\n\\u8FD9\\u91CC\\u6BD4\\u8F83Tricky\\uFF0C\\u5148\\u904D\\u5386\\u5230\\u6700\\u4E0B\\u7AEF\\uFF0C\\u6BCF\\u6B21\\u5F80\\u4E0A\\u8FD4\\u56DE\\u7684\\u662F\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u6570\\u7EC4\\u91CC\\u9762\\u5305\\u542B\\u4E86\\u6240\\u6709\\u5DE6\\u8FB9\\u6216\\u8005\\u53F3\\u8FB9\\u4F20\\u4E0A\\u53BB\\u7684\\u5404\\u79CD`path`\\uFF0C\\u5728\\u4E0A\\u4F20\\u5230parent\\u8282\\u70B9\\u7684\\u65F6\\u5019\\uFF0Cparent\\u5728\\u6240\\u6709\\u7684`path`\\u91CC\\u9762\\u8FED\\u4EE3\\u4E00\\u6B21\\uFF0C\\u53CD\\u5411\\u52A0\\u4E0A\\u5F53\\u524D`root.val`\\uFF0C\\u7136\\u540E\\u7EE7\\u7EED\\u5F80\\u4E0A\\u53CD\\u3002\\u56E0\\u4E3A\\u8FD9\\u91CC\\u6CA1\\u6709\\u7528\\u5168\\u5C40\\u7684return value\\uFF0C\\u6BCF\\u6B21\\u5728\\u5411\\u4E0A\\u4F20\\u9012\\u7684\\u65F6\\u5019\\uFF0C\\u8981\\u91CD\\u65B0\\u518D\\u5BF9return value\\u8FDB\\u884Cappend\\u3002\\n\\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        left_path = self.binaryTreePaths(root.left)\\n        right_path = self.binaryTreePaths(root.right)\\n        \\n        if not root.left and not root.right:\\n            res.append(str(root.val))\\n        \\n        if root.left:\\n            for path in left_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        if root.right:\\n            for path in right_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386 | \\u5206\\u5236\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        self.dfs(root, res, \\'\\')\\n        return res\\n    \\n    def dfs(self, root, res, temp):\\n        temp += str(root.val)\\n        if not root.left and not root.right:\\n            res.append(temp)\\n        if root.left:\\n            self.dfs(root.left, res, temp + \\'->\\')\\n        if root.right:\\n            self.dfs(root.right, res, temp + \\'->\\')\\n```\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        left_path = self.binaryTreePaths(root.left)\\n        right_path = self.binaryTreePaths(root.right)\\n        \\n        if not root.left and not root.right:\\n            res.append(str(root.val))\\n        \\n        if root.left:\\n            for path in left_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        if root.right:\\n            for path in right_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68261,
                "title": "accepted-javascript-stack-solution",
                "content": "#### Approach Vertical Tree Walk\\n\\n**Intuition**\\n\\nTo avoid stack overflow problems on big datasets we will use stack data structure for saving state and walking through a tree.\\n\\n**Algorithm**\\n\\n* Initialize stack with *root* node and empty *path*;\\n* Iterate while *stack* has at least one element;\\n* Take last element from *stack*;\\n* Ensure element is not null;\\n* Initialize *children* with non-null right and left nodes;\\n* Concatenate stack item *path* and current node *path* and put it to *path*;\\n* Add result row if *children* is empty;\\n* Add each *child* with *path* to the *stack*.\\n\\n**Javascript**\\n\\n```javascript\\nvar binaryTreePaths = function(root) {\\n    let result = [];    \\n    let stack = [{node: root, path: []}];\\n    \\n    while (stack.length > 0) {\\n        let item = stack.pop();\\n        if (item.node === null) {\\n            continue;\\n        }\\n        \\n        let children = [item.node.right, item.node.left].filter(child => child !== null);\\n        let path = item.path.concat([item.node.val]);\\n\\n        if (children.length === 0) {\\n            result.push(path.join(\"->\"));\\n        }\\n\\n        children.forEach(child => stack.push({node: child, path: path}));\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity : *O(n)*.\\n\\nTo find all necessary paths we need to visit each node only once.\\n\\n* Space complexity : *O(m * 2)*\\n\\nWe need *O(m * 2)* space in worst case, where *m* is the depth of the tree.",
                "solutionTags": [],
                "code": "```javascript\\nvar binaryTreePaths = function(root) {\\n    let result = [];    \\n    let stack = [{node: root, path: []}];\\n    \\n    while (stack.length > 0) {\\n        let item = stack.pop();\\n        if (item.node === null) {\\n            continue;\\n        }\\n        \\n        let children = [item.node.right, item.node.left].filter(child => child !== null);\\n        let path = item.path.concat([item.node.val]);\\n\\n        if (children.length === 0) {\\n            result.push(path.join(\"->\"));\\n        }\\n\\n        children.forEach(child => stack.push({node: child, path: path}));\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68263,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nvoid copy(int *a,char *b,int temp)\\n{\\n    int j=0;\\n    for(int i=0;i<temp;i++)\\n    {j+=sprintf(b+j,\"%d->\",a[i]);}\\n    b[j-2]='\\\\0';\\n}\\nvoid order(struct TreeNode* root,int* returnSize,char** result,int *a,int *temp)\\n{\\n    if(root==NULL)\\n    {return ;}\\n    a[(*temp)++]=root->val;  \\n    if(root->left==NULL&&root->right==NULL)\\n    {\\n        result[*returnSize]=(char*)malloc(sizeof(char)*100);\\n        copy(a,result[*returnSize],*temp);\\n        (*returnSize)++;   \\n        (*temp)--;\\n        return;\\n    }\\n    order(root->left,returnSize,result,a,temp);\\n    order(root->right,returnSize,result,a,temp);\\n    (*temp)--;\\n}\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    int *temp=(int*)malloc(sizeof(int));\\n    *temp=0;\\n    int *a=(int*)malloc(sizeof(int)*100);\\n    char** result=(char**)malloc(sizeof(char*)*100);\\n    *returnSize=0;\\n    if(root==NULL)\\n    {return NULL;}\\n    order(root,returnSize,result,a,temp);  \\n    return result;   \\n}\\n````",
                "solutionTags": [],
                "code": "```\\nvoid copy(int *a,char *b,int temp)\\n{\\n    int j=0;\\n    for(int i=0;i<temp;i++)\\n    {j+=sprintf(b+j,\"%d->\",a[i]);}\\n    b[j-2]='\\\\0';\\n}\\nvoid order(struct TreeNode* root,int* returnSize,char** result,int *a,int *temp)\\n{\\n    if(root==NULL)\\n    {return ;}\\n    a[(*temp)++]=root->val;  \\n    if(root->left==NULL&&root->right==NULL)\\n    {\\n        result[*returnSize]=(char*)malloc(sizeof(char)*100);\\n        copy(a,result[*returnSize],*temp);\\n        (*returnSize)++;   \\n        (*temp)--;\\n        return;\\n    }\\n    order(root->left,returnSize,result,a,temp);\\n    order(root->right,returnSize,result,a,temp);\\n    (*temp)--;\\n}\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    int *temp=(int*)malloc(sizeof(int));\\n    *temp=0;\\n    int *a=(int*)malloc(sizeof(int)*100);\\n    char** result=(char**)malloc(sizeof(char*)*100);\\n    *returnSize=0;\\n    if(root==NULL)\\n    {return NULL;}\\n    order(root,returnSize,result,a,temp);  \\n    return result;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68407,
                "title": "java-solution-with-recursive-easy-to-understand",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res=new ArrayList<String>();\\n        if(root==null)  return res;\\n        String s=root.val+\"\";\\n        getPaths(res,root,s);\\n        return res;\\n    }\\n    private void getPaths(List<String> res,TreeNode root,String s){\\n        if(root.left==null&&root.right==null){\\n               res.add(s);\\n               return;\\n        }\\n        if(root.left!=null)\\n            getPaths(res,root.left,s+\"->\"+root.left.val);\\n        if(root.right!=null)\\n            getPaths(res,root.right,s+\"->\"+root.right.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res=new ArrayList<String>();\\n        if(root==null)  return res;\\n        String s=root.val+\"\";\\n        getPaths(res,root,s);\\n        return res;\\n    }\\n    private void getPaths(List<String> res,TreeNode root,String s){\\n        if(root.left==null&&root.right==null){\\n               res.add(s);\\n               return;\\n        }\\n        if(root.left!=null)\\n            getPaths(res,root.left,s+\"->\"+root.left.val);\\n        if(root.right!=null)\\n            getPaths(res,root.right,s+\"->\"+root.right.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68415,
                "title": "dfs-python-solution-very-easy-to-understand",
                "content": "    class Solution:\\n    # @param {TreeNode} root\\n    # @return {string[]}\\n    def binaryTreePaths(self, root):\\n        if not root:return []\\n        stack,res=[(root,[str(root.val)])],[]\\n        while stack:\\n            temp,val=stack.pop()\\n            if not temp.left and not temp.right:\\n                res.append('->'.join(val))\\n            if temp.left:\\n                stack.append((temp.left,val+[str(temp.left.val)]))\\n            if temp.right:\\n                stack.append((temp.right,val+[str(temp.right.val)]))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 68369,
                "title": "binary-tree-paths-bfs-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            // Write your code here\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            queue<pair<string, TreeNode*>> Q;\\n            Q.push({to_string(root->val), root});\\n            \\n            while (!Q.empty()) {\\n                string curStr = Q.front().first;\\n                TreeNode* curNode = Q.front().second;\\n                Q.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(curStr);\\n                } else {\\n                    if (curNode->left != NULL)\\n                        Q.push({curStr + \"->\" + to_string(curNode->left->val), curNode->left});\\n                    if (curNode->right != NULL)\\n                        Q.push({curStr + \"->\" + to_string(curNode->right->val), curNode->right});\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            // Write your code here\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            queue<pair<string, TreeNode*>> Q;\\n            Q.push({to_string(root->val), root}",
                "codeTag": "Java"
            },
            {
                "id": 68465,
                "title": "share-my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> ret;\\n            if(root) dfs(ret, \"\", root);\\n            return ret;\\n        }\\n        \\n        void dfs(vector<string> &ret, string path, TreeNode* root){\\n            path += to_string(root->val);\\n            if(!root->left && !root->right){\\n                ret.push_back(path);\\n            }else{\\n                if(root->left) dfs(ret, path + \"->\", root->left);\\n                if(root->right) dfs(ret, path + \"->\", root->right);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> ret;\\n            if(root) dfs(ret, \"\", root);\\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68474,
                "title": "my-concise-c-solution-neat-and-short",
                "content": "    \\n\\n    class Solution {\\n            void treeHelper(vector<string>& result, string temp, TreeNode* root){\\n                if(!root) return;\\n                if(!root -> left && !root -> right){\\n                    temp += to_string(root -> val);\\n                    result.push_back(temp);\\n                    return ;\\n                }\\n                temp += to_string(root -> val);\\n                treeHelper(result, temp + \"->\", root -> left);\\n                treeHelper(result, temp + \"->\", root -> right);\\n            }\\n        public:\\n            vector<string> binaryTreePaths(TreeNode* root) {\\n                vector<string> result;\\n                string temp = \"\";\\n                treeHelper(result, temp, root);\\n                return result;\\n            }\\n        };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n            void treeHelper(vector<string>& result, string temp, TreeNode* root){\\n                if(!root) return;\\n                if(!root -> left && !root -> right){\\n                    temp += to_string(root -> val);\\n                    result.push_back(temp);\\n                    return ;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 68500,
                "title": "java-solution-dfs",
                "content": "\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rootLeafPath = new ArrayList<String>();\\n            if (root == null) return rootLeafPath;\\n            \\n            List<TreeNode> path = new LinkedList<TreeNode>();\\n            DFS(root, path , rootLeafPath);\\n            return rootLeafPath;\\n        }\\n        \\n        private void DFS(TreeNode root, List<TreeNode> path,   List<String> rootLeafPath){\\n            path.add(root);\\n            if (root.left != null) DFS(root.left, path, rootLeafPath);\\n            if (root.right != null) DFS(root.right, path, rootLeafPath);\\n            if (root.left == null && root.right == null) {\\n                StringBuilder sb = new StringBuilder();\\n                // print all value in current path\\n                for (int i = 0; i < path.size(); i++){\\n                    sb.append(path.get(i).val);\\n                    if (i != path.size()-1) sb.append(\"->\");\\n                }\\n                rootLeafPath.add(sb.toString());\\n            }\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rootLeafPath = new ArrayList<String>();\\n            if (root == null) return rootLeafPath;\\n            \\n            List<TreeNode> path = new LinkedList<TreeNode>();\\n            DFS(root, path , rootLeafPath);\\n            return rootLeafPath;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68530,
                "title": "simple-binary-tree-paths-solution",
                "content": "    class Solution {\\n    public:\\n    \\n        using Elem = pair<TreeNode*, string>;\\n        using Stack = stack<Elem>;\\n    \\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            \\n            vector<string> paths;\\n            \\n            if(root)\\n            {\\n                Stack pool;\\n                pool.push(Elem(root, to_string(root->val)));\\n                \\n                while(!pool.empty())\\n                {\\n                    auto p = pool.top();\\n                    pool.pop();\\n                    \\n                    if(!p.first->left && !p.first->right)\\n                        paths.push_back(p.second);\\n                    \\n                    if(p.first->left)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->left->val);\\n                        pool.push(Elem(p.first->left, nstring));\\n                    }\\n                    \\n                    if(p.first->right)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->right->val);\\n                        pool.push(Elem(p.first->right, nstring));\\n                    }\\n                }\\n            }\\n            \\n            return paths;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        using Elem = pair<TreeNode*, string>;\\n        using Stack = stack<Elem>;\\n    \\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            \\n            vector<string> paths;\\n            \\n            if(root)\\n            {\\n                Stack pool;\\n                pool.push(Elem(root, to_string(root->val)));\\n                \\n                while(!pool.empty())\\n                {\\n                    auto p = pool.top();\\n                    pool.pop();\\n                    \\n                    if(!p.first->left && !p.first->right)\\n                        paths.push_back(p.second);\\n                    \\n                    if(p.first->left)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->left->val);\\n                        pool.push(Elem(p.first->left, nstring));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3941880,
                "title": "c-clean-and-modular-code-using-backtracking-detailed-comments",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H) due to path string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector <string> res; //store result\\n\\n    void addToPath(int val, string &path){\\n        path += \"->\" + to_string(val);\\n    }\\n\\n    void removeFromPath(int val, string &path){\\n        int len = to_string(val).length() + 2; // +2 due to \"->\"\\n        while(len--) path.pop_back(); \\n    }\\n\\n    void traverse(TreeNode* root, string &path){\\n        if(!root) return;\\n        if(!root->left && !root->right){ //reached leaf node\\n            addToPath(root->val, path); //do\\n            res.push_back(path); //add path \\n            removeFromPath(root->val, path); //undo\\n            return;\\n        }\\n\\n        addToPath(root->val, path); //do\\n        traverse(root->left, path); //recurse\\n        traverse(root->right, path);\\n        removeFromPath(root->val, path); //undo \\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        res.clear(); // clear result first\\n        string path = to_string(root->val); initialise path with root\\n        if(!root->left && !root->right) return {path};\\n        //check wether head itself is not a root if yes then return head value as only path\\n\\n        traverse(root->left, path); //recurse left subtree\\n        traverse(root->right, path); //recurse right subtree\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector <string> res; //store result\\n\\n    void addToPath(int val, string &path){\\n        path += \"->\" + to_string(val);\\n    }\\n\\n    void removeFromPath(int val, string &path){\\n        int len = to_string(val).length() + 2; // +2 due to \"->\"\\n        while(len--) path.pop_back(); \\n    }\\n\\n    void traverse(TreeNode* root, string &path){\\n        if(!root) return;\\n        if(!root->left && !root->right){ //reached leaf node\\n            addToPath(root->val, path); //do\\n            res.push_back(path); //add path \\n            removeFromPath(root->val, path); //undo\\n            return;\\n        }\\n\\n        addToPath(root->val, path); //do\\n        traverse(root->left, path); //recurse\\n        traverse(root->right, path);\\n        removeFromPath(root->val, path); //undo \\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        res.clear(); // clear result first\\n        string path = to_string(root->val); initialise path with root\\n        if(!root->left && !root->right) return {path};\\n        //check wether head itself is not a root if yes then return head value as only path\\n\\n        traverse(root->left, path); //recurse left subtree\\n        traverse(root->right, path); //recurse right subtree\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917896,
                "title": "python-easy-solution-100-recursion-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.res=[]\\n\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        arr=\\'\\'\\n        if not root:\\n            return []\\n        self.checkSm(root, arr)\\n        return self.res\\n    \\n    def checkSm(self, node, arr):\\n        newarr=arr+str(node.val)\\n        if not node.left and not node.right:\\n            self.res.append(newarr)\\n            return\\n        else:\\n            newarr=newarr+\\'->\\'\\n            if node.left:\\n                self.checkSm(node.left, newarr)\\n            if node.right:\\n                self.checkSm(node.right, newarr)\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.res=[]\\n\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        arr=\\'\\'\\n        if not root:\\n            return []\\n        self.checkSm(root, arr)\\n        return self.res\\n    \\n    def checkSm(self, node, arr):\\n        newarr=arr+str(node.val)\\n        if not node.left and not node.right:\\n            self.res.append(newarr)\\n            return\\n        else:\\n            newarr=newarr+\\'->\\'\\n            if node.left:\\n                self.checkSm(node.left, newarr)\\n            if node.right:\\n                self.checkSm(node.right, newarr)\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879045,
                "title": "accepted-java-simple-solution-recursive-dfs",
                "content": "# Intuition\\n\\n# Approach\\nWe simply create a helper function and simply perform inorder traversal while adding the values to a string and add the string to the arraylist as soon as we encounter a leaf node and empty the string for the next path.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> s=new ArrayList<>();\\n     String ss=\"\";\\n     helper(root,s,ss);\\n    return s;\\n    }\\n    public static void helper(TreeNode root , List<String> s,String ss)\\n    {   \\n        if(root==null)\\n        {return ;}\\n        if(root.left==null && root.right==null)\\n        {\\n            ss+=root.val;\\n            s.add(ss);\\n            ss=\"\";\\n            return ;\\n        }\\n        ss+=root.val+\"->\";\\n        helper(root.left,s,ss);\\n        helper(root.right,s,ss);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> s=new ArrayList<>();\\n     String ss=\"\";\\n     helper(root,s,ss);\\n    return s;\\n    }\\n    public static void helper(TreeNode root , List<String> s,String ss)\\n    {   \\n        if(root==null)\\n        {return ;}\\n        if(root.left==null && root.right==null)\\n        {\\n            ss+=root.val;\\n            s.add(ss);\\n            ss=\"\";\\n            return ;\\n        }\\n        ss+=root.val+\"->\";\\n        helper(root.left,s,ss);\\n        helper(root.right,s,ss);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863269,
                "title": "preorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        helper(root,\"\",ans);\\n        return ans;\\n        \\n    }\\n    private void helper(TreeNode root,String up,List<String> ans){\\n        if(root == null)\\n         return;\\n\\n        if (root.left == null && root.right == null){\\n            ans.add(up+Integer.toString(root.val));\\n            return;\\n        }\\n\\n        helper(root.left,up + Integer.toString(root.val)+\"->\",ans);\\n        helper(root.right,up +Integer.toString(root.val)+\"->\",ans);\\n\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        helper(root,\"\",ans);\\n        return ans;\\n        \\n    }\\n    private void helper(TreeNode root,String up,List<String> ans){\\n        if(root == null)\\n         return;\\n\\n        if (root.left == null && root.right == null){\\n            ans.add(up+Integer.toString(root.val));\\n            return;\\n        }\\n\\n        helper(root.left,up + Integer.toString(root.val)+\"->\",ans);\\n        helper(root.right,up +Integer.toString(root.val)+\"->\",ans);\\n\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820624,
                "title": "simple-and-easy-traversal-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        solve(root,arr);\\n        return ans;\\n    }\\n    public Boolean solve(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) {\\n            return false;\\n        }\\n\\n        arr.add(root.val);\\n        Boolean left = solve(root.left,arr);\\n        Boolean right = solve(root.right,arr);\\n        if(left==true || right== true){\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        if(left==false && right==false){\\n            String s = \"\";\\n            for(int i=0;i<arr.size();i++){\\n                s+= arr.get(i)+\"\";\\n                if(i<arr.size()-1){\\n                    s+= \"->\";\\n                }\\n            }\\n            ans.add(s);\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        solve(root,arr);\\n        return ans;\\n    }\\n    public Boolean solve(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) {\\n            return false;\\n        }\\n\\n        arr.add(root.val);\\n        Boolean left = solve(root.left,arr);\\n        Boolean right = solve(root.right,arr);\\n        if(left==true || right== true){\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        if(left==false && right==false){\\n            String s = \"\";\\n            for(int i=0;i<arr.size();i++){\\n                s+= arr.get(i)+\"\";\\n                if(i<arr.size()-1){\\n                    s+= \"->\";\\n                }\\n            }\\n            ans.add(s);\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788869,
                "title": "easiest-way-to-solve-to-solve-binary-tree-path-java",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> lis = new ArrayList<>();\\n        dfs(root, lis, \"\");\\n        for(int i = 0; i < lis.size(); i++)\\n            lis.set(i, lis.get(i).substring(2));\\n        return lis;\\n    }\\n    public void dfs(TreeNode node, List<String> lis, String s){\\n        if(node == null) return;\\n        if(node.left == null && node.right == null)\\n            lis.add(s + \"->\" + node.val);\\n        s += \"->\" + node.val;\\n        dfs(node.left, lis, s);\\n        dfs(node.right, lis, s);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> lis = new ArrayList<>();\\n        dfs(root, lis, \"\");\\n        for(int i = 0; i < lis.size(); i++)\\n            lis.set(i, lis.get(i).substring(2));\\n        return lis;\\n    }\\n    public void dfs(TreeNode node, List<String> lis, String s){\\n        if(node == null) return;\\n        if(node.left == null && node.right == null)\\n            lis.add(s + \"->\" + node.val);\\n        s += \"->\" + node.val;\\n        dfs(node.left, lis, s);\\n        dfs(node.right, lis, s);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677320,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root) {\\n        if(!root->left && !root->right) return true;\\n\\n        return false;\\n    }\\n\\n    void getPath(TreeNode* root, vector<int>& temp, vector<string>& ans) {\\n        if(root == NULL) return ;\\n\\n        temp.push_back(root -> val);\\n\\n        if(isLeaf(root)) {\\n            string s = \"\";\\n            for(int i : temp) {\\n                s += to_string(i) + \"->\";\\n            }\\n            s = s.substr(0, s.length()-2);\\n            ans.push_back(s);\\n        }\\n\\n        getPath(root->left, temp, ans);\\n        getPath(root->right, temp, ans);\\n\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        if(root == NULL) return ans;\\n\\n        vector<int> temp;\\n        getPath(root, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root) {\\n        if(!root->left && !root->right) return true;\\n\\n        return false;\\n    }\\n\\n    void getPath(TreeNode* root, vector<int>& temp, vector<string>& ans) {\\n        if(root == NULL) return ;\\n\\n        temp.push_back(root -> val);\\n\\n        if(isLeaf(root)) {\\n            string s = \"\";\\n            for(int i : temp) {\\n                s += to_string(i) + \"->\";\\n            }\\n            s = s.substr(0, s.length()-2);\\n            ans.push_back(s);\\n        }\\n\\n        getPath(root->left, temp, ans);\\n        getPath(root->right, temp, ans);\\n\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        if(root == NULL) return ans;\\n\\n        vector<int> temp;\\n        getPath(root, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597335,
                "title": "c-recursive-dfs-beats-100",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string path = \"\";\\n        backtrack(result, path, root); \\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(vector<string>& result, string path, TreeNode*& root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            path += to_string(root->val);\\n            result.emplace_back(path);\\n            return;\\n        }\\n\\n        path += to_string(root->val) + \"->\";\\n        backtrack(result, path, root->left);\\n        backtrack(result, path, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string path = \"\";\\n        backtrack(result, path, root); \\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(vector<string>& result, string path, TreeNode*& root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            path += to_string(root->val);\\n            result.emplace_back(path);\\n            return;\\n        }\\n\\n        path += to_string(root->val) + \"->\";\\n        backtrack(result, path, root->left);\\n        backtrack(result, path, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584312,
                "title": "recursive-solution-by-leo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n\\n        paths = []\\n        if root.left:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.left)]\\n        if root.right:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.right)]\\n\\n        return paths\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n\\n        paths = []\\n        if root.left:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.left)]\\n        if root.right:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.right)]\\n\\n        return paths\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576001,
                "title": "100-accepted-c-solution-easy-dfs",
                "content": "\\n```\\nclass Solution {\\n    private:\\n    vector<string>ans;\\n    void fun(TreeNode *root,string str)\\n    {\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val)+\"->\";\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            str.pop_back();\\n            str.pop_back();\\n            ans.push_back(str);\\n        }\\n        fun(root->left,str);\\n        fun(root->right,str);\\n        str.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string str =  \"\";\\n        fun(root,str);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    vector<string>ans;\\n    void fun(TreeNode *root,string str)\\n    {\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val)+\"->\";\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            str.pop_back();\\n            str.pop_back();\\n            ans.push_back(str);\\n        }\\n        fun(root->left,str);\\n        fun(root->right,str);\\n        str.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string str =  \"\";\\n        fun(root,str);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480135,
                "title": "binary-tree-paths-c-java-recursive-and-iterative-approach",
                "content": "# **Recursive: (faster)**\\nC++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        vector<int> path;\\n        vector<vector<int>> allPaths;\\n        getAllPaths(root,path,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nJava\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        getAllPaths(root,path,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# **Iterative**\\n\\nc++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\n    void lvlOrder(TreeNode* node,vector<vector<int>> &allPaths){\\n        queue<pair<TreeNode*,vector<int>>>q;\\n        q.push({node,{}});\\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            node=ele.first;\\n            if(node->left==NULL && node->right==NULL){\\n                ele.second.push_back(node->val);\\n                allPaths.push_back(ele.second);\\n            }\\n            ele.second.push_back(node->val);\\n            if(node->left!=NULL) q.push({node->left,ele.second});\\n            if(node->right!=NULL) q.push({node->right,ele.second});\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        // vector<int> path;\\n        vector<vector<int>> allPaths;\\n        lvlOrder(root,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nJava\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Pair{\\n    TreeNode node;\\n    List<Integer> list;\\n    public Pair(TreeNode node,List<Integer> list){\\n        this.node=node;\\n        this.list=list;\\n    }\\n}\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    private void lvlOrder(TreeNode node,List<List<Integer>> allPaths){\\n        Queue<Pair>q= new LinkedList<>();\\n        q.add(new Pair(node,new ArrayList<>()));\\n        while(!q.isEmpty()){\\n            Pair ele=q.peek();\\n            q.remove();\\n            node=ele.node;\\n            if(node.left==null && node.right==null){\\n                ele.list.add(node.val);\\n                allPaths.add(new ArrayList<>(ele.list));\\n            }\\n            ele.list.add(node.val);\\n            if(node.left!=null) q.add(new Pair(node.left,new ArrayList<>(ele.list)));\\n            if(node.right!=null) q.add(new Pair(node.right,new ArrayList<>(ele.list)));\\n        }\\n    }\\n        \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        // List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        lvlOrder(root,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        vector<int> path;\\n        vector<vector<int>> allPaths;\\n        getAllPaths(root,path,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        getAllPaths(root,path,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\n    void lvlOrder(TreeNode* node,vector<vector<int>> &allPaths){\\n        queue<pair<TreeNode*,vector<int>>>q;\\n        q.push({node,{}});\\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            node=ele.first;\\n            if(node->left==NULL && node->right==NULL){\\n                ele.second.push_back(node->val);\\n                allPaths.push_back(ele.second);\\n            }\\n            ele.second.push_back(node->val);\\n            if(node->left!=NULL) q.push({node->left,ele.second});\\n            if(node->right!=NULL) q.push({node->right,ele.second});\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        // vector<int> path;\\n        vector<vector<int>> allPaths;\\n        lvlOrder(root,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Pair{\\n    TreeNode node;\\n    List<Integer> list;\\n    public Pair(TreeNode node,List<Integer> list){\\n        this.node=node;\\n        this.list=list;\\n    }\\n}\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    private void lvlOrder(TreeNode node,List<List<Integer>> allPaths){\\n        Queue<Pair>q= new LinkedList<>();\\n        q.add(new Pair(node,new ArrayList<>()));\\n        while(!q.isEmpty()){\\n            Pair ele=q.peek();\\n            q.remove();\\n            node=ele.node;\\n            if(node.left==null && node.right==null){\\n                ele.list.add(node.val);\\n                allPaths.add(new ArrayList<>(ele.list));\\n            }\\n            ele.list.add(node.val);\\n            if(node.left!=null) q.add(new Pair(node.left,new ArrayList<>(ele.list)));\\n            if(node.right!=null) q.add(new Pair(node.right,new ArrayList<>(ele.list)));\\n        }\\n    }\\n        \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        // List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        lvlOrder(root,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432558,
                "title": "this-is-the-shortest-ans-for-the-this-question",
                "content": "# Intuition\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string str) {\\n        if(node->left == NULL &&  node->right == NULL) ans.push_back(str + to_string(node->val));\\n        if(node->left) dfs(node->left, str + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, str + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string str) {\\n        if(node->left == NULL &&  node->right == NULL) ans.push_back(str + to_string(node->val));\\n        if(node->left) dfs(node->left, str + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, str + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393713,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<string>& ans, string temp){\\n        if (root==NULL)return;\\n        string node= to_string(root->val);\\n        temp+= node;\\n        if (root->left==NULL && root->right==NULL){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        else temp+= \"->\";\\n        if (root->left) dfs(root->left,ans,temp);\\n        if (root->right) dfs(root->right,ans,temp);\\n        //temp.pop_back();\\n        //temp.pop_back();\\n        //temp.pop_back();\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string temp=\"\";\\n        dfs(root,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<string>& ans, string temp){\\n        if (root==NULL)return;\\n        string node= to_string(root->val);\\n        temp+= node;\\n        if (root->left==NULL && root->right==NULL){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        else temp+= \"->\";\\n        if (root->left) dfs(root->left,ans,temp);\\n        if (root->right) dfs(root->right,ans,temp);\\n        //temp.pop_back();\\n        //temp.pop_back();\\n        //temp.pop_back();\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string temp=\"\";\\n        dfs(root,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188529,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root , vector<int> &temp , vector<vector<int> > &ans){\\n        if(root == NULL){\\n            // ans.push_back(s);\\n            return ;\\n        }\\n        if(root -> left == NULL && root -> right == NULL){\\n           temp.push_back(root -> val);\\n           ans.push_back(temp);\\n           temp.pop_back();\\n           return;\\n        }\\n        // cout << root -> val << endl;\\n        temp.push_back(root->val);\\n        helper(root->left, temp,ans);\\n        helper(root->right, temp,ans);\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        helper(root, temp, ans);\\n        vector<string> sol;\\n        for(auto v:ans){\\n            string t = \"\";\\n            for(int i=0;i<v.size()-1;i++){\\n                t += to_string(v[i]);\\n                t += \"->\";\\n            }\\n            t += to_string(v[v.size()-1]);\\n            sol.push_back(t);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root , vector<int> &temp , vector<vector<int> > &ans){\\n        if(root == NULL){\\n            // ans.push_back(s);\\n            return ;\\n        }\\n        if(root -> left == NULL && root -> right == NULL){\\n           temp.push_back(root -> val);\\n           ans.push_back(temp);\\n           temp.pop_back();\\n           return;\\n        }\\n        // cout << root -> val << endl;\\n        temp.push_back(root->val);\\n        helper(root->left, temp,ans);\\n        helper(root->right, temp,ans);\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        helper(root, temp, ans);\\n        vector<string> sol;\\n        for(auto v:ans){\\n            string t = \"\";\\n            for(int i=0;i<v.size()-1;i++){\\n                t += to_string(v[i]);\\n                t += \"->\";\\n            }\\n            t += to_string(v[v.size()-1]);\\n            sol.push_back(t);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3184409,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public List<string> ans;\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        ans=new();\\n        if(root.left==null&&root.right==null){\\n                ans.Add(root.val.ToString());\\n                return ans;\\n            }\\n        StringBuilder sb=new();\\n        dfs(root,sb);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root,StringBuilder sb){\\n        if(root!=null){\\n            sb.Append(root.val);\\n            if(root.left==null&&root.right==null){\\n                ans.Add(sb.ToString());\\n            }\\n            else{\\n            sb.Append(\"->\");\\n            }\\n            StringBuilder sbl=new();\\n            StringBuilder sbr=new();\\n            sbl.Append(sb.ToString());\\n            sbr.Append(sb.ToString());\\n            dfs(root.left,sbl);\\n            dfs(root.right,sbr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<string> ans;\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        ans=new();\\n        if(root.left==null&&root.right==null){\\n                ans.Add(root.val.ToString());\\n                return ans;\\n            }\\n        StringBuilder sb=new();\\n        dfs(root,sb);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root,StringBuilder sb){\\n        if(root!=null){\\n            sb.Append(root.val);\\n            if(root.left==null&&root.right==null){\\n                ans.Add(sb.ToString());\\n            }\\n            else{\\n            sb.Append(\"->\");\\n            }\\n            StringBuilder sbl=new();\\n            StringBuilder sbr=new();\\n            sbl.Append(sb.ToString());\\n            sbr.Append(sb.ToString());\\n            dfs(root.left,sbl);\\n            dfs(root.right,sbr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823810,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n public List<String> binaryTreePaths(TreeNode root) {\\n  List<String> paths = new ArrayList<>();\\n  if (root == null) return paths;\\n\\n  Stack<TreeNode> stackNode = new Stack<>();\\n  Stack<String> stackInt = new Stack<>();\\n  stackNode.push(root);\\n  stackInt.push(Integer.toString(root.val));\\n\\n  while (!stackNode.empty()) {\\n   TreeNode node = stackNode.pop();\\n   String num = stackInt.pop();\\n\\n   if (node.left == null && node.right == null) {\\n    paths.add(num);\\n   }\\n\\n   if (node.left != null) {\\n    stackNode.push(node.left);\\n    stackInt.push(num + \"->\" + node.left.val);\\n   }\\n\\n   if (node.right != null) {\\n    stackNode.push(node.right);\\n    stackInt.push(num + \"->\" + node.right.val);\\n   }\\n  }\\n\\n  return paths;\\n }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n public List<String> binaryTreePaths(TreeNode root) {\\n  List<String> paths = new ArrayList<>();\\n  if (root == null) return paths;\\n\\n  Stack<TreeNode> stackNode = new Stack<>();\\n  Stack<String> stackInt = new Stack<>();\\n  stackNode.push(root);\\n  stackInt.push(Integer.toString(root.val));\\n\\n  while (!stackNode.empty()) {\\n   TreeNode node = stackNode.pop();\\n   String num = stackInt.pop();\\n\\n   if (node.left == null && node.right == null) {\\n    paths.add(num);\\n   }\\n\\n   if (node.left != null) {\\n    stackNode.push(node.left);\\n    stackInt.push(num + \"->\" + node.left.val);\\n   }\\n\\n   if (node.right != null) {\\n    stackNode.push(node.right);\\n    stackInt.push(num + \"->\" + node.right.val);\\n   }\\n  }\\n\\n  return paths;\\n }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2823001,
                "title": "python3-using-queue-level-order-traversal",
                "content": "```\\nclass Node:\\n    def __init__(self, value):\\n        self.value = value\\n        self.next = None\\n    \\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self.length = 0\\n\\n    def __len__(self):\\n        return self.length\\n\\n    def add(self, value):\\n        node = Node(value)\\n        if self.head:\\n            self.tail.next = node\\n            self.tail = node\\n        else:\\n            self.head = node\\n            self.tail = node\\n        self.length += 1\\n\\n    def remove_first(self):\\n        if self.head:\\n            value = self.head.value\\n            self.head = self.head.next\\n            self.length -= 1\\n            return value\\n\\nclass Queue:\\n    def __init__(self, size = 0):\\n        self.list = LinkedList()\\n        self.size = size\\n\\n    def enqueue(self, value):\\n        self.list.add(value)\\n\\n    def dequeue(self):\\n        return self.list.remove_first()\\n    \\n    def is_empty(self):\\n        return self.list.head == None\\n\\nclass Solution:\\n    def binaryTreePaths(self, rootNode: Optional[TreeNode]) -> List[str]:\\n        if not rootNode:\\n            return\\n        else:\\n            queue = Queue()\\n            queue.enqueue(rootNode)\\n            paths = {\\n                f\"0-{rootNode.val}\": str(rootNode.val)\\n            }\\n            next_counter = 0\\n            current_counter = 0\\n            while not queue.is_empty():\\n                current = queue.dequeue()\\n                current_parent = paths[f\"{current_counter}-{current.val}\"]\\n                if current.left:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.left.val}\\'] = f\\'{current_parent}->{current.left.val}\\'\\n                    queue.enqueue(current.left)\\n                if current.right:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.right.val}\\'] = f\\'{current_parent}->{current.right.val}\\'\\n                    queue.enqueue(current.right)\\n                if current.right or current.left:    \\n                    del paths[f\"{current_counter}-{current.val}\"]\\n                current_counter += 1\\n            return list(paths.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, value):\\n        self.value = value\\n        self.next = None\\n    \\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self.length = 0\\n\\n    def __len__(self):\\n        return self.length\\n\\n    def add(self, value):\\n        node = Node(value)\\n        if self.head:\\n            self.tail.next = node\\n            self.tail = node\\n        else:\\n            self.head = node\\n            self.tail = node\\n        self.length += 1\\n\\n    def remove_first(self):\\n        if self.head:\\n            value = self.head.value\\n            self.head = self.head.next\\n            self.length -= 1\\n            return value\\n\\nclass Queue:\\n    def __init__(self, size = 0):\\n        self.list = LinkedList()\\n        self.size = size\\n\\n    def enqueue(self, value):\\n        self.list.add(value)\\n\\n    def dequeue(self):\\n        return self.list.remove_first()\\n    \\n    def is_empty(self):\\n        return self.list.head == None\\n\\nclass Solution:\\n    def binaryTreePaths(self, rootNode: Optional[TreeNode]) -> List[str]:\\n        if not rootNode:\\n            return\\n        else:\\n            queue = Queue()\\n            queue.enqueue(rootNode)\\n            paths = {\\n                f\"0-{rootNode.val}\": str(rootNode.val)\\n            }\\n            next_counter = 0\\n            current_counter = 0\\n            while not queue.is_empty():\\n                current = queue.dequeue()\\n                current_parent = paths[f\"{current_counter}-{current.val}\"]\\n                if current.left:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.left.val}\\'] = f\\'{current_parent}->{current.left.val}\\'\\n                    queue.enqueue(current.left)\\n                if current.right:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.right.val}\\'] = f\\'{current_parent}->{current.right.val}\\'\\n                    queue.enqueue(current.right)\\n                if current.right or current.left:    \\n                    del paths[f\"{current_counter}-{current.val}\"]\\n                current_counter += 1\\n            return list(paths.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816197,
                "title": "java-dfs-solution-in-6-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        goDFS(root, list, result);\\n        StringBuilder sb = new StringBuilder();\\n        List<String> strings = new ArrayList<>();\\n        for (List<Integer> l : result) {\\n            for (int i = 0; i < l.size() - 1; i++) {\\n                sb.append(l.get(i)).append(\"->\");\\n            }\\n            sb.append(l.get(l.size() - 1));\\n            strings.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n        return strings;\\n    }\\n\\n    private void goDFS(TreeNode node, List<Integer> list, List<List<Integer>> result) {\\n        if (node == null) return;\\n        list.add(node.val);\\n        if (node.left == null && node.right == null) {\\n            result.add(new ArrayList<>(list));\\n        }\\n        goDFS(node.left, list, result);\\n        goDFS(node.right, list, result);\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        goDFS(root, list, result);\\n        StringBuilder sb = new StringBuilder();\\n        List<String> strings = new ArrayList<>();\\n        for (List<Integer> l : result) {\\n            for (int i = 0; i < l.size() - 1; i++) {\\n                sb.append(l.get(i)).append(\"->\");\\n            }\\n            sb.append(l.get(l.size() - 1));\\n            strings.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n        return strings;\\n    }\\n\\n    private void goDFS(TreeNode node, List<Integer> list, List<List<Integer>> result) {\\n        if (node == null) return;\\n        list.add(node.val);\\n        if (node.left == null && node.right == null) {\\n            result.add(new ArrayList<>(list));\\n        }\\n        goDFS(node.left, list, result);\\n        goDFS(node.right, list, result);\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812095,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isleaf(TreeNode* root){\\n\\t\\t\\treturn (!root->left && !root->right);\\n\\t\\t}\\n\\t\\tvoid chk(vector<vector<int>>&v, vector<int>&a, TreeNode* root){\\n\\t\\t\\tif(!root){return;}\\n\\t\\t\\ta.push_back(root->val);\\n\\t\\t\\tif(isleaf(root)){v.push_back(a);}\\n\\t\\t\\tchk(v, a, root->left);\\n\\t\\t\\tchk(v, a, root->right);\\n\\t\\t\\ta.pop_back();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<string> binaryTreePaths(TreeNode* root) {\\n\\t\\t\\tvector<vector<int>>v;\\n\\t\\t\\tvector<int>a;\\n\\t\\t\\tchk(v, a, root);\\n\\t\\t\\t// for(int i=0; i<v.size(); i++){\\n\\t\\t\\t//     for(int j=0; j<v[i].size(); j++){\\n\\t\\t\\t//         cout<<v[i][j]<<\" \";\\n\\t\\t\\t//     }cout<<endl;\\n\\t\\t\\t// }\\n\\t\\t\\tvector<string>ans;\\n\\t\\t\\tfor(int i=0; i<v.size(); i++){\\n\\t\\t\\t\\tstring x=\"\";\\n\\t\\t\\t\\tfor(int j=0; j<v[i].size(); j++){\\n\\t\\t\\t\\t\\tx+=to_string(v[i][j]);\\n\\t\\t\\t\\t\\tx+=\\'-\\'; x+=\\'>\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx.pop_back();\\n\\t\\t\\t\\tx.pop_back();\\n\\t\\t\\t\\tans.push_back(x);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isleaf(TreeNode* root){\\n\\t\\t\\treturn (!root->left && !root->right);\\n\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1863853,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1738339,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1866733,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1573978,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1950610,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1934897,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1785347,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1728220,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1571497,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 2066813,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1863853,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1738339,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1866733,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1573978,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1950610,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1934897,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1785347,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1728220,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1571497,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 2066813,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Numbers with Unique Digits",
        "question_content": "<p>Given an integer <code>n</code>, return the count of all numbers with unique digits, <code>x</code>, where <code>0 &lt;= x &lt; 10<sup>n</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 91\n<strong>Explanation:</strong> The answer should be the total numbers in the range of 0 &le; x &lt; 100, excluding 11,22,33,44,55,66,77,88,99\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 83041,
                "title": "java-dp-o-1-solution",
                "content": " Following the hint. Let f(n) = count of number with unique digits of length n.\\n\\nf(1) = 10.  (0, 1, 2, 3, ...., 9)\\n\\nf(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.  \\n\\nf(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j  for k to choose from.\\n\\nSimilarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....\\n\\n...\\n\\nf(10) = 9 * 9 * 8 * 7 * 6 * ... * 1\\n\\nf(11) = 0 = f(12) = f(13)....\\n\\nany number with length > 10  couldn't be unique digits number.\\n\\nThe problem is asking for numbers from 0 to 10^n. Hence return f(1) + f(2) + .. + f(n)\\n\\n\\nAs @4acreg suggests,  There are only 11 different ans. You can create a lookup table for it. This problem is O(1) in essence.\\n\\n      public int countNumbersWithUniqueDigits(int n) {\\n            if (n == 0)     return 1;\\n            \\n            int res = 10;\\n            int uniqueDigits = 9;\\n            int availableNumber = 9;\\n            while (n-- > 1 && availableNumber > 0) {\\n                uniqueDigits = uniqueDigits * availableNumber;\\n                res += uniqueDigits;\\n                availableNumber--;\\n            }\\n            return res;\\n        }",
                "solutionTags": [],
                "code": " Following the hint. Let f(n) = count of number with unique digits of length n.\\n\\nf(1) = 10.  (0, 1, 2, 3, ...., 9)\\n\\nf(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.  \\n\\nf(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j  for k to choose from.\\n\\nSimilarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....\\n\\n...\\n\\nf(10) = 9 * 9 * 8 * 7 * 6 * ... * 1\\n\\nf(11) = 0 = f(12) = f(13)....\\n\\nany number with length > 10  couldn't be unique digits number.\\n\\nThe problem is asking for numbers from 0 to 10^n. Hence return f(1) + f(2) + .. + f(n)\\n\\n\\nAs @4acreg suggests,  There are only 11 different ans. You can create a lookup table for it. This problem is O(1) in essence.\\n\\n      public int countNumbersWithUniqueDigits(int n) {\\n            if (n == 0)     return 1;\\n            \\n            int res = 10;\\n            int uniqueDigits = 9;\\n            int availableNumber = 9;\\n            while (n-- > 1 && availableNumber > 0) {\\n                uniqueDigits = uniqueDigits * availableNumber;\\n                res += uniqueDigits;\\n                availableNumber--;\\n            }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 83061,
                "title": "java-o-1-with-explanation",
                "content": "This is a digit combination problem. Can be solved in at most 10 loops.\\n\\nWhen n == 0, return 1. I got this answer from the test case.\\n\\nWhen n == 1, _ can put 10 digit in the only position. [0, ... , 10]. Answer is 10.\\n\\nWhen n == 2, _ _ first digit has 9 choices [1, ..., 9], second one has 9 choices excluding the already chosen one. So totally 9 * 9 = 81. answer should be 10 + 81 = 91\\n\\nWhen n == 3, _ _ _ total choice is 9 * 9 * 8 = 684. answer is 10 + 81 + 648 = 739\\n\\nWhen n == 4, _ _ _ _ total choice is 9 * 9 * 8 * 7.\\n\\n...\\n\\nWhen n == 10, _ _ _ _ _ _ _ _ _ _ total choice is 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\\n\\nWhen n == 11,  _ _ _ _ _ _ _ _ _ _ _ total choice is 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 * 0 = 0\\n\\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        int ans = 10, base = 9;\\n        for (int i = 2; i <= n && i <= 10; i++) {\\n            base = base * (9 - i + 2);\\n            ans += base;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "This is a digit combination problem. Can be solved in at most 10 loops.\\n\\nWhen n == 0, return 1. I got this answer from the test case.\\n\\nWhen n == 1, _ can put 10 digit in the only position. [0, ... , 10]. Answer is 10.\\n\\nWhen n == 2, _ _ first digit has 9 choices [1, ..., 9], second one has 9 choices excluding the already chosen one. So totally 9 * 9 = 81. answer should be 10 + 81 = 91\\n\\nWhen n == 3, _ _ _ total choice is 9 * 9 * 8 = 684. answer is 10 + 81 + 648 = 739\\n\\nWhen n == 4, _ _ _ _ total choice is 9 * 9 * 8 * 7.\\n\\n...\\n\\nWhen n == 10, _ _ _ _ _ _ _ _ _ _ total choice is 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\\n\\nWhen n == 11,  _ _ _ _ _ _ _ _ _ _ _ total choice is 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 * 0 = 0\\n\\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        int ans = 10, base = 9;\\n        for (int i = 2; i <= n && i <= 10; i++) {\\n            base = base * (9 - i + 2);\\n            ans += base;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 83056,
                "title": "share-my-0ms-c-solution-with-proof-and-explanation",
                "content": "Q: Given a **non-negative** integer n, count all numbers with **unique digits**, x, where 0 \\u2264 x < 10^n\\n\\nA: Here I choose a math solution based on **permutation**:\\n\\n - **P(n, r) = n * (n - 1) * (n - 2) * ... * (n - r + 1)**\\n\\n----------\\n## Just take a try\\n\\n 1. When **n = 0**, ***0 \\u2264 x < 1*** with **unique digits** is 0, ***A(0) = 1***\\n\\n 2. When **n = 1**, ***0 \\u2264 x < 10*** can be divided into \\n\\n      - ***0 \\u2264 x < 1*** (calculated in 1): ***A(0) = 1***\\n\\n      - ***1 \\u2264 x < 10*** (all numbers with **ONLY 1** digit)\\n\\n      As they are **all unique**: ***A(1) = P(10,1) - 1***\\n\\n 3. When **n = 2**, ***0 \\u2264 x < 100*** with **unique digits** can be divided into\\n\\n      - ***0 \\u2264 x < 1*** (calculated in 1): ***A(0) = 1***\\n\\n      - ***1 \\u2264 x < 10*** (all numbers with **ONLY 1** digit): ***A(1) = P(10,1) - 1***\\n\\n      - ***10 \\u2264 x < 100*** (all numbers with **ONLY 2** digits)\\n\\n      As the numbers have **ONLY 2** digits, if they are with **unique digits**:\\n\\n      We need to choose **2 different digits** from **{1,2,3,4,5,6,7,8,9,0}**: ***P(10,2)***\\n\\n      And we must **filter out** the permutations **started by 0**: ***P(9,1)***\\n\\n     ***A(2) = P(10,2) - P(9,1)***\\n\\n----------\\n## Think about A(n)\\n\\n 1. When **n > 10**, ***10^(n-1) \\u2264 x < 10^n*** **MUST** have **MORE THAN 10** digits.\\n\\n  As the [Pigeonhole principle][1] says, there **MUST** be **AT LEAST N - 9** repeating numbers.\\n\\n  All numbers should be ignored, which means ***A(n) = 0 (n  > 10)***.\\n\\n 2. When **n \\u2264 10**, ***10^(n-1) \\u2264 x < 10^n*** (all numbers with **ONLY n** digits) have **unique digits** :\\n\\n - **Choose n different digits** from **{1,2,3,4,5,6,7,8,9,0}**: ***P(10,n)***\\n\\n - **Filter out** the permutations **started by 0**: ***P(9,n-1)***\\n\\n - Get **A(n) = P(10,n) - P(9,n-1) = 9 * P(9,n-1)**\\n\\n----------\\n## Combine all Intervals\\n\\n - As\\n\\n    - ***A(n) = 1 (n = 0)***\\n\\n    - ***A(n) = 9 * P(9,n-1) (0 < n \\u2264 10)***\\n\\n    -  ***A(n) = 0 (n > 10)***\\n\\n - Since we need to count all **x (0 \\u2264 x < 10^n)** with **unique digits** , we can just combine all Intervals:\\n\\n    - ***S(n) = A(0) + A(1) + A(2) + .....+ A(n)***\\n\\n - S(n) is the final answer.\\n\\n----------\\n## Code\\n\\n    class Solution {\\n    public:\\n        int permutation(int n, int r)\\n        {\\n            if(r == 0)\\n            {\\n                return 1;\\n            }else{\\n                return n * permutation(n - 1, r - 1);\\n            }\\n        }\\n        int countNumbersWithUniqueDigits(int n) {\\n            int sum = 1;\\n            if(n > 0)\\n            {\\n               int end = (n > 10)? 10 : n;\\n               for(int i = 0; i < end; i++)\\n               {\\n                   sum += 9 * permutation(9, i);\\n               }\\n            }\\n            return sum;\\n        }\\n    };\\n\\n----------\\n  [1]: https://en.wikipedia.org/wiki/Pigeonhole_principle",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n        int permutation(int n, int r)\\n        {\\n            if(r == 0)\\n            {\\n                return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 83040,
                "title": "simple-python-solution-90",
                "content": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        choices = [9, 9, 8, 7, 6, 5, 4, 3, 2, 1]\\n        ans, product = 1, 1\\n        \\n        for i in range(n if n <= 10 else 10):\\n            product *= choices[i]\\n            ans += product\\n            \\n        return ans\\n```\\n\\nFor the first (most left) digit, we have 9 options (no zero); for the second digit we used one but we can use 0 now, so 9 options; and we have 1 less option for each following digits. Number can not be longer than 10 digits.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        choices = [9, 9, 8, 7, 6, 5, 4, 3, 2, 1]\\n        ans, product = 1, 1\\n        \\n        for i in range(n if n <= 10 else 10):\\n            product *= choices[i]\\n            ans += product\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83054,
                "title": "backtracking-solution",
                "content": "The idea is to append one digit at a time recursively (only append digits that has not been appended before). Number zero is a special case, because we don't want to deal with the leading zero, so it is counted separately at the beginning of the program. The running time for this program is O(10!) worst case, or O(n!) if n < 10.\\n\\nThe OJ gives wrong answer when n = 0 and n = 1. The correct answer should be:\\n\\n> 0, 1 \\n\\n> 1, 10\\n\\n> 2, 91\\n\\n> 3, 739\\n\\n>4, 5275\\n\\n>5, 32491\\n\\n> 6, 168571\\n\\n> 7, 712891\\n\\n> 8, 2345851\\n\\n> 9, 5611771\\n\\n> 10 and beyond, 8877691\\n\\n\\n----------\\n\\n\\n    public class Solution {\\n    \\tpublic static int countNumbersWithUniqueDigits(int n) {\\n    \\t\\tif (n > 10) {\\n    \\t\\t\\treturn countNumbersWithUniqueDigits(10);\\n    \\t\\t}\\n    \\t\\tint count = 1; // x == 0\\n    \\t\\tlong max = (long) Math.pow(10, n);\\n    \\n    \\t\\tboolean[] used = new boolean[10];\\n    \\n    \\t\\tfor (int i = 1; i < 10; i++) {\\n    \\t\\t\\tused[i] = true;\\n    \\t\\t\\tcount += search(i, max, used);\\n    \\t\\t\\tused[i] = false;\\n    \\t\\t}\\n    \\n    \\t\\treturn count;\\n    \\t}\\n    \\n    \\tprivate static int search(long prev, long max, boolean[] used) {\\n    \\t\\tint count = 0;\\n    \\t\\tif (prev < max) {\\n    \\t\\t\\tcount += 1;\\n    \\t\\t} else {\\n    \\t\\t\\treturn count;\\n    \\t\\t}\\n    \\n    \\t\\tfor (int i = 0; i < 10; i++) {\\n    \\t\\t\\tif (!used[i]) {\\n    \\t\\t\\t\\tused[i] = true;\\n    \\t\\t\\t\\tlong cur = 10 * prev + i;\\n    \\t\\t\\t\\tcount += search(cur, max, used);\\n    \\t\\t\\t\\tused[i] = false;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\treturn count;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    \\tpublic static int countNumbersWithUniqueDigits(int n) {\\n    \\t\\tif (n > 10) {\\n    \\t\\t\\treturn countNumbersWithUniqueDigits(10);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1210498,
                "title": "simple-c-solution-with-comments-beats-100-dp-permutations-and-combinations",
                "content": "```\\n/*\\nFor n = 0, ans = 1\\nFor n = 1, ans = 10\\nIf we take 2 digit number, we have 9 options for first digit (1 - 9)\\nand 9 options for second digit(0 & all other digits except the one taken as first digit (to keep digits unique)) therefore ans += (9 * 9)\\nSimilarly if we take 3 digit number we have 8 options for third digit, therefore ans += (9 * 9 * 8)\\n*/\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)\\n            return 1;\\n        int ans = 10, calc = 9, temp = 9;\\n        for(int i = 0; i < n - 1; i++) {\\n            calc *= temp;\\n            ans += calc;\\n            temp--;\\n        }\\n        return ans;\\n    }\\n};\\n//Do upvote if you are helped by the solution to help others\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nFor n = 0, ans = 1\\nFor n = 1, ans = 10\\nIf we take 2 digit number, we have 9 options for first digit (1 - 9)\\nand 9 options for second digit(0 & all other digits except the one taken as first digit (to keep digits unique)) therefore ans += (9 * 9)\\nSimilarly if we take 3 digit number we have 8 options for third digit, therefore ans += (9 * 9 * 8)\\n*/\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)\\n            return 1;\\n        int ans = 10, calc = 9, temp = 9;\\n        for(int i = 0; i < n - 1; i++) {\\n            calc *= temp;\\n            ans += calc;\\n            temp--;\\n        }\\n        return ans;\\n    }\\n};\\n//Do upvote if you are helped by the solution to help others\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83052,
                "title": "clear-c-explanation-of-combinatorics-using-dp-method",
                "content": "when n is 0, it is clear that there is just one number 0.\\n\\nwhen n is 1, it is trivial that there are 10 numbers: 0,1,2...9.\\n\\nwhen n is 2, the range is [0, 99]. The total unique digits is divided to two part: just one digit or two digit.\\n\\n              **dp[2]  = dp[1] + the combination with  two digits.** \\n\\n'0' could only be at unit digit. so when '0' is at unit digit, there are 9 kinds of. when there is no '0', there are 9 kinds of numbers at tens digit, and 8 kinds of numbers at unit digit. So the combination with two digits are: 9 + 9*8  is equal to \\n\\n                                       9 * (1+8) = 9 * 9.\\n\\nwhen n is 3, the range is [0, 999]. The total unique digits is divided to two part: less than 3 digit or 3 digit.\\n\\n              **dp[3]  = dp[2] + the combination with  3 digits.** \\n\\n'0' could only be at unit digit and ten's digit.\\n\\nWhen '0' is at unit digit, there are 9 * 8 kind of numbers(9 is the kind of numbers at hundred's digit, 8 is the kind of numbers at ten's digit);\\n\\nWhen '0' is at ten's digit, there are 9 * 8 kind of numbers(9 is the kind of numbers at hundred's digit, 8 is the kind of numbers at unit digit);\\n\\nWhen there is no '0', there are 9 * 8 * 7 kinds of numbers(9 is the kind of numbers at hundred's digit, 8 is the kind of numbers at ten's digit, 7 is the kind of numbers at unit digit).\\n\\nSo there are:\\n\\n                 9 * 8  + 9 * 8 + 9 * 8 * 7  = 9 * 8 * (1 + 1 + 8 ) = 9 * 9 * 8 \\n\\nkinds of combinations with three digits.\\n\\n.........\\n\\nThan it is easy to understand the DP solution of this problem.\\n\\n\\n    class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            dp[1] = 10;\\n            for(int i = 2;i<=n;i++){\\n                dp[i] = 9;\\n                int k = 9;\\n                int count = 1;\\n                while( count <i){\\n                    dp[i] *= k;\\n                    k--;\\n                    count++;\\n                }\\n                dp[i] +=dp[i-1];\\n            }\\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            dp[1] = 10;\\n            for(int i = 2;i<=n;i++){\\n                dp[i] = 9;\\n                int k = 9;\\n                int count = 1;\\n                while( count <i){\\n                    dp[i] *= k;\\n                    k--;\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 374777,
                "title": "python-o-1-99-80-math-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def count(k):\\n            if k == max(10 - n, 0):\\n                return 0\\n            return k*(1 + count(k - 1))\\n        if n == 0:\\n            return 1\\n        return 9*count(9) + 10\\n```\\n![image](https://assets.leetcode.com/users/denyscoder/image_1567948498.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def count(k):\\n            if k == max(10 - n, 0):\\n                return 0\\n            return k*(1 + count(k - 1))\\n        if n == 0:\\n            return 1\\n        return 9*count(9) + 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83037,
                "title": "very-simple-15-line-backtrack-solution",
                "content": "Re: [Backtracking solution](/topic/48001/backtracking-solution)\\n\\nThanks for sharing. I think it could be simplified further. This problem is kind of like permutation + subset, so we start from 0 every recursion and count through the path. Forgive me if anything unclear, here is the code:\\n\\n```java\\n    public int countNumbersWithUniqueDigits(int n) {\\n        return doCount(n, new boolean[10], 0);\\n    }\\n    \\n    private int doCount(int n, boolean[] used, int d) {\\n        if (d == n) return 1;\\n        int total = 1;\\n        for (int i = (d == 0) ? 1 : 0; i <= 9; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                total += doCount(n, used, d + 1);\\n                used[i] = false;\\n            }\\n        }\\n        return total;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int countNumbersWithUniqueDigits(int n) {\\n        return doCount(n, new boolean[10], 0);\\n    }\\n    \\n    private int doCount(int n, boolean[] used, int d) {\\n        if (d == n) return 1;\\n        int total = 1;\\n        for (int i = (d == 0) ? 1 : 0; i <= 9; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                total += doCount(n, used, d + 1);\\n                used[i] = false;\\n            }\\n        }\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201226,
                "title": "what-s-the-point-of-this",
                "content": "I can list all possible results using simple arithmetics...\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n>10:\\n            n=10\\n        l = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\\n        return l[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n>10:\\n            n=10\\n        l = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\\n        return l[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83094,
                "title": "simple-java-solution-with-explanation",
                "content": "The problem is a simple Math problem:\\n\\nLet res[i] represents the number of unique numbers among i-digit numbers.\\nFor example:\\n\\n* res[0] = 1, since there is only 0.\\n* res[1] = 9, because all one-digit numbers are unique : 1,2,3,4,5,6,7,8,9.\\n* res[2] = 81, \\nBecause among all two-digit numbers (10 - 99), the number with unique digits = 9 * 9.\\nThe first digit is chosen from (1,2,3,4,5,6,7,8,9), so there are 9 choices,\\nThe second digit is chosen from (0,1,2,3,4,5,6,7,8,9) except the one has been chosen as the first digit, so there are 9 choices.\\n\\n* res[3] = 9 * 9 * 8 = 648.\\n\\n* res[4] = 9 * 9 * 8 * 7.\\n\\nAnd so on so forth.\\nThe result is the sum from res[0] to res[n].\\n\\nWe can notice that:\\nres[0] = 1,\\nres[1] = 9,\\nres[2] = 9 * 9           = 9 * res[1],\\nres[3] = 9 * 9 * 8      = 8 * res[2],\\nres[4] = 9 * 9 * 8 * 7 = 7 * res[3].\\n\\nApparently, we can compute the latter one using DP.\\n\\nCode:\\n\\n```\\npublic class Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int res[] = new int[n + 1];\\n        res[0] = 1;\\n        int sum = 1;\\n        int k = 9;\\n        for(int i = 1; i <= n && k > 0; i++){\\n               if(i == 1) res[i] += res[i - 1] * 9;\\n               else res[i] += res[i - 1] * k--;\\n               sum += res[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int res[] = new int[n + 1];\\n        res[0] = 1;\\n        int sum = 1;\\n        int k = 9;\\n        for(int i = 1; i <= n && k > 0; i++){\\n               if(i == 1) res[i] += res[i - 1] * 9;\\n               else res[i] += res[i - 1] * k--;\\n               sum += res[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440515,
                "title": "100-faster-c-just-use-common-sense",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int dp[10];\\n        memset(dp,0,sizeof(dp));\\n        dp[0] = 1;\\n        dp[1] = 9;\\n        dp[2] = 9*9;\\n        dp[3] = 9*9*8;\\n        dp[4] = 9*9*8*7;\\n        dp[5] = 9*9*8*7*6;\\n        dp[6] = 9*9*8*7*6*5;\\n        dp[7] = 9*9*8*7*6*5*4;\\n        dp[8] = 9*9*8*7*6*5*4*3;\\n        int ans = 0;\\n        for(int i=0;i<=n;i++)\\n            ans += dp[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int dp[10];\\n        memset(dp,0,sizeof(dp));\\n        dp[0] = 1;\\n        dp[1] = 9;\\n        dp[2] = 9*9;\\n        dp[3] = 9*9*8;\\n        dp[4] = 9*9*8*7;\\n        dp[5] = 9*9*8*7*6;\\n        dp[6] = 9*9*8*7*6*5;\\n        dp[7] = 9*9*8*7*6*5*4;\\n        dp[8] = 9*9*8*7*6*5*4*3;\\n        int ans = 0;\\n        for(int i=0;i<=n;i++)\\n            ans += dp[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83065,
                "title": "two-c-solutions-backtracking-and-dp-4-lines-only",
                "content": "DP solution:\\n\\n    class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            vector<int> tbl(min(n,10)+1, 1);\\n            for (int i = 1; i <= min(n,10); i++)\\n                tbl[i] = tbl[i-1] * (i == 1? 9: (9-i+2));\\n            return accumulate(tbl.begin(), tbl.end(), 0);\\n        }\\n    };\\n\\nBacktracking solution\\n\\n    class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            bool visit[10] = {false};\\n            int count = 0;\\n            for (int i = 0; i <= min(10,n); i++)\\n                count += DFS(i, 0, visit);\\n            return count;\\n        }\\n    private:\\n        int DFS(int target, int idx, bool* visit) {\\n            if (idx == target)\\n                return 1;\\n    \\n            int count = 0;\\n            for (int i = idx?0:1; i < 10; i++) {\\n                if (!visit[i]) {\\n                    visit[i] = true;\\n                    count += DFS(target, idx+1, visit);\\n                    visit[i] = false;\\n                }\\n            }\\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        int countNumbersWithUniqueDigits(int n) {\\n            vector<int> tbl(min(n,10)+1, 1);\\n            for (int i = 1; i <= min(n,10); i++)\\n                tbl[i] = tbl[i-1] * (i == 1? 9: (9-i+2));\\n            return accumulate(tbl.begin(), tbl.end(), 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 83167,
                "title": "11-lines-c-solution-with-detailed-explanation",
                "content": " It's a statistical solution.\\n\\nSay we have an i-bit-number, the MSB is not 0. \\n\\nFor the MSB, we can put 1 ~ 9, that is **9** options. \\n\\nAnd for the second MSB, we can put 0 ~ 9 exclude the digit we already used for the MSB, so that should be **9** options.\\n\\nThen, the third MSB, put 0 ~ 9 exclude the digits we used for the left two bits. That's **8** options.\\n\\n...\\n\\nTotally, we have **9 * 9 * 8 * 7 * ...** till the LSB.\\n\\nConsider numbers with 1 to n digits. Then I came into the following solution.\\n\\n\\n\\n       int countNumbersWithUniqueDigits(int n) \\n            {\\n                int num = 0;\\n                for(int i = n; i >= 1; --i)\\n                {\\n                    int part = 9;\\n                    for(int j = 0; j < i - 1; ++j)\\n                    {\\n                        part *= 9 - j;\\n                    }\\n                    num += part; \\n                }\\n                return num + 1;  //Include 0.\\n            }",
                "solutionTags": [],
                "code": " It's a statistical solution.\\n\\nSay we have an i-bit-number, the MSB is not 0. \\n\\nFor the MSB, we can put 1 ~ 9, that is **9** options. \\n\\nAnd for the second MSB, we can put 0 ~ 9 exclude the digit we already used for the MSB, so that should be **9** options.\\n\\nThen, the third MSB, put 0 ~ 9 exclude the digits we used for the left two bits. That's **8** options.\\n\\n...\\n\\nTotally, we have **9 * 9 * 8 * 7 * ...** till the LSB.\\n\\nConsider numbers with 1 to n digits. Then I came into the following solution.\\n\\n\\n\\n       int countNumbersWithUniqueDigits(int n) \\n            {\\n                int num = 0;\\n                for(int i = n; i >= 1; --i)\\n                {\\n                    int part = 9;\\n                    for(int j = 0; j < i - 1; ++j)\\n                    {\\n                        part *= 9 - j;\\n                    }\\n                    num += part; \\n                }\\n                return num + 1;  //Include 0.\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 83072,
                "title": "java-simple-code-o-1-space-o-n-time-with-combinatorics-knowledge",
                "content": "test case is wrong when n==1, it should be 11 instead of 10, from 0 to 10 inclusively \\n\\nn=2  10+9 * 9\\n\\nn=3  10+9 * 9+9 * 9 * 8 \\n\\nn=4  10+9 * 9+9 * 9 * 8+9 * 9 * 8 * 7\\n\\n...\\n\\nwhen n > 10, the total number won't increase any more, so we set n=10 in that case \\n\\n    public class Solution {\\n        public int countNumbersWithUniqueDigits(int n) {\\n            if (n == 0) {\\n                return 2;\\n            }\\n            if (n == 1) {\\n                return 10; // should be 11\\n            }\\n            n = Math.min(n, 10);\\n            int sum = 10;\\n            int tmp = 9;\\n            for (int i = 1; i < n; i++) {\\n                tmp *= 10 - i;\\n                sum += tmp;\\n            }\\n            return sum;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int countNumbersWithUniqueDigits(int n) {\\n            if (n == 0) {\\n                return 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2582540,
                "title": "java-0ms-fastest-solution",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) \\n    {\\n\\t/*\\n\\t    9 * 9 + 10 for n = 2\\n        9 * 9 * 8 + 10 for n = 3\\n        9 * 9 * 8 * 7 + 10 for n = 4\\n        9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n\\t*/\\t\\n        if(n == 0)\\n            return 1;\\n        \\n        if(n == 1)\\n            return 10;\\n        \\n        int product =9;\\n        int result = 10;\\n        \\n        for(int i=2; i<=n; i++)\\n        {\\n            product = product * (11-i);\\n            result += product;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) \\n    {\\n\\t/*\\n\\t    9 * 9 + 10 for n = 2\\n        9 * 9 * 8 + 10 for n = 3\\n        9 * 9 * 8 * 7 + 10 for n = 4\\n        9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n\\t*/\\t\\n        if(n == 0)\\n            return 1;\\n        \\n        if(n == 1)\\n            return 10;\\n        \\n        int product =9;\\n        int result = 10;\\n        \\n        for(int i=2; i<=n; i++)\\n        {\\n            product = product * (11-i);\\n            result += product;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897117,
                "title": "o-1-space-the-most-easy-and-intuitive-solution-for-this-problem-guarenteed",
                "content": "We need to find out the count of unique digit numbers. Let\\'s first go through some cases and try to build some relation if it exists.\\n\\n**Case 1:** if (n == 0) then we will only have 1 unique digit number that is 0 itself so the answer is 1\\n\\n![image](https://assets.leetcode.com/users/images/69cd40d9-3596-4648-9bab-bfec5d7bdfb1_1648633516.4528067.png)\\n\\n**Case 2:** if (n == 1) that is we need to find the count of all the single digit unique numbers which obviously will be equal to 9 {1, 2, 3, 4, 5, 6, 7, 8, 9}. However the final answer will be 10[Since we have 1 unique number when n = 0]\\n\\n![image](https://assets.leetcode.com/users/images/d5ae7ee3-d5b2-4508-b575-47af0c2a82d0_1648633494.3350484.png)\\n\\n**Case 3:** For n = 2 let\\'s first find the duplicate digits numbers because now we can have duplicates in digits. \\n\\n![image](https://assets.leetcode.com/users/images/3816d6a9-77d5-428b-b278-dcf569832242_1648634038.8533676.png)\\n\\n![image](https://assets.leetcode.com/users/images/41148bbc-4844-499e-9b06-a186d4dd7621_1648634103.517041.png)\\n\\nSimilarly For n = 3:\\n\\n![image](https://assets.leetcode.com/users/images/d8b473fe-9c99-40c6-a20c-6b7fd3438a99_1648633651.0510612.png)\\n\\nNow we can code it up very easily we just need to keep track of the previous size duplicate and non duplicate count and first calculate current duplicate and then non duplicate count and then add the non duplicate count to our answer.\\n\\nThe code for c++ and java will be the same except the class declaration part. \\n\\n**Code C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int d = 0, nd = 1, tot = 9, ans = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            d = nd * (i - 1) + d * 10;\\n            nd = tot - d;\\n            ans += nd;\\n            tot *= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time complexity:** O(n)\\n**Space complexity:** O(4) which is constant space",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int d = 0, nd = 1, tot = 9, ans = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            d = nd * (i - 1) + d * 10;\\n            nd = tot - d;\\n            ans += nd;\\n            tot *= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174608,
                "title": "using-permutations-and-combinations-simple-o-n-solution",
                "content": "\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        dp=[9]*(n+1) #always avoiding 0 at start for every value of i.\\n        dp[0]=1 # we know for n=0, x=1\\n        for i in range(1,n+1): # this is to calculate for every i the posibilities, that is for i digit number,\\n\\t\\t                                  #how many  possibilities are there for non repeaing digits\\n            for j in range(9,9-i+1,-1): \\n                dp[i]*=j\\n        for i in range(0,n):\\n            dp[n]+=dp[i] #to get value for n, we will add all i\\'s before n to n.\\n        return dp[n]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        dp=[9]*(n+1) #always avoiding 0 at start for every value of i.\\n        dp[0]=1 # we know for n=0, x=1\\n        for i in range(1,n+1): # this is to calculate for every i the posibilities, that is for i digit number,\\n\\t\\t                                  #how many  possibilities are there for non repeaing digits\\n            for j in range(9,9-i+1,-1): \\n                dp[i]*=j\\n        for i in range(0,n):\\n            dp[n]+=dp[i] #to get value for n, we will add all i\\'s before n to n.\\n        return dp[n]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1319594,
                "title": "java-pure-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n         return recursion(n,0,new boolean[10]);\\n    }\\n    int recursion(int n,int curr,boolean[] vis)\\n    {\\n        if(curr == n)\\n            return 1;\\n        int res = 1;\\n        for(int i=(curr == 0 ? 1 : 0);i<=9;i++)\\n        {\\n            if(vis[i])\\n                continue;\\n            vis[i] = true;\\n            res+=recursion(n,curr+1,vis);\\n            vis[i] = false;\\n        }\\n        return res;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n         return recursion(n,0,new boolean[10]);\\n    }\\n    int recursion(int n,int curr,boolean[] vis)\\n    {\\n        if(curr == n)\\n            return 1;\\n        int res = 1;\\n        for(int i=(curr == 0 ? 1 : 0);i<=9;i++)\\n        {\\n            if(vis[i])\\n                continue;\\n            vis[i] = true;\\n            res+=recursion(n,curr+1,vis);\\n            vis[i] = false;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898568,
                "title": "c-simple-solution-faster-than-100-without-using-extra-memory-10-lines",
                "content": "Lets explain code with some example,lets take n==3\\nWe will have range [0,1000),or we can say we have all numbers with 1,2 and 3 digits.\\nSo we will split it in those categories.\\nIf you have numbers with 3 digits,to describe unique number,we can make pattern:\\n* First,or most left or highes digit can be 1,2,3,...,9 (we can not start number with 0),so we have **9** options\\n* Second digit can be 0,1,2,3,...,9,but we must exclude **first** chosen digit,so have **9** options\\n* Third digit can be 0,1,2,3,...,9,but we must exclude **first** and **second** chosen digits,so we have **8** options\\n* If we have four digits,fourth digit will have **7** options.\\nSo we can figure out that we can choose 9x9x8 3-digit number\\nThat pattern can be applied for any n>=1\\nIf n==0,than only number we can choose is 0,and if we have n==1,we have 9 digits,and also 0\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n<=1) return pow(10,n);\\n        int n1 = n-1;\\n        int product = 9;\\n        int curr = 9;\\n        while (n>1) {\\n            product*=curr;\\n            n--;\\n            curr--;\\n        }\\n        return product+countNumbersWithUniqueDigits(n1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n<=1) return pow(10,n);\\n        int n1 = n-1;\\n        int product = 9;\\n        int curr = 9;\\n        while (n>1) {\\n            product*=curr;\\n            n--;\\n            curr--;\\n        }\\n        return product+countNumbersWithUniqueDigits(n1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883424,
                "title": "c-0ms-clean-solution-with-explanation",
                "content": "For a given number n, we have to find all i-digit numbers where ```0 <= i <= n``` . For example for n = 3, final answer = 0-digit unique numbers + 1-digit unique numbers + 2-digit unique numbers + 3-digit unique numbers.\\nAnd i-digit unique numbers = ```9x9x8x7x...i-places``` using combinatrics because for 1st position we have 9 choices ( except 0 ) and then subsequently 9 , 8 , 7 for 1st, 2nd and 3rd positions.\\n\\nHere is the code.\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int ans = 1;\\n        for(int i = 1;i <= n;i++){\\n            int iDigitNumbers = 9;\\n            for(int j = 9; j>= 10 - i + 1;j--){\\n                iDigitNumbers *= j;\\n            }\\n            ans += iDigitNumbers;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```0 <= i <= n```\n```9x9x8x7x...i-places```\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int ans = 1;\\n        for(int i = 1;i <= n;i++){\\n            int iDigitNumbers = 9;\\n            for(int j = 9; j>= 10 - i + 1;j--){\\n                iDigitNumbers *= j;\\n            }\\n            ans += iDigitNumbers;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248582,
                "title": "357-time-95-29-and-space-94-84-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if n is equal to 0. If it is, then there is only 1 possible number with unique digits, which is 0. Return 1 as the result.\\n2. If n is greater than 10, then the count will be the same as countNumbersWithUniqueDigits(10) because for n > 10, there will be repetition, and the count will not change anymore. Therefore, set n to min(n, 10).\\n3. Start with a base count of 10, since we can always have 0 to 9 as the first digit. We will add more numbers to this count as we go along.\\n4. For the second digit, we can have 9 choices, since 0 is already used. For the third digit, we can have 9 choices again, since we cannot repeat the first or second digit. For the fourth digit, we can have 8 choices, and so on. The total count is the product of the number of choices for each digit.\\n5. Therefore, for i from 2 to n, compute the number of choices for each digit and add it to the count.\\n6. Return the count as the result.\\n\\n# Complexity\\n- Time complexity:\\n95.29%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        # The maximum number of unique digits we can have is 10, since we have 10 digits in base 10\\n        # For n > 10, there will be repetition, so the count will be the same as countNumbersWithUniqueDigits(10)\\n        n = min(n, 10)\\n        \\n        # Start with a base count of 10, since we can always have 0 to 9 as the first digit\\n        count = 10\\n        \\n        # For the second digit, we can have 9 choices, since 0 is already used\\n        # For the third digit, we can have 9 choices again, since we cannot repeat the first or second digit\\n        # For the fourth digit, we can have 8 choices, and so on\\n        # The total count is the product of the number of choices for each digit\\n        for i in range(2, n + 1):\\n            choices = 9\\n            for j in range(i - 1):\\n                choices *= 9 - j\\n            count += choices\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        # The maximum number of unique digits we can have is 10, since we have 10 digits in base 10\\n        # For n > 10, there will be repetition, so the count will be the same as countNumbersWithUniqueDigits(10)\\n        n = min(n, 10)\\n        \\n        # Start with a base count of 10, since we can always have 0 to 9 as the first digit\\n        count = 10\\n        \\n        # For the second digit, we can have 9 choices, since 0 is already used\\n        # For the third digit, we can have 9 choices again, since we cannot repeat the first or second digit\\n        # For the fourth digit, we can have 8 choices, and so on\\n        # The total count is the product of the number of choices for each digit\\n        for i in range(2, n + 1):\\n            choices = 9\\n            for j in range(i - 1):\\n                choices *= 9 - j\\n            count += choices\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582326,
                "title": "dp-solution-c-beats-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int sum=1,c=9;\\n        vector<int> dp(n+2);\\n        dp[0]=1,dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*c+sum;\\n            sum+=dp[i-1];\\n            c--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int sum=1,c=9;\\n        vector<int> dp(n+2);\\n        dp[0]=1,dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*c+sum;\\n            sum+=dp[i-1];\\n            c--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172040,
                "title": "python-solution",
                "content": "The variable `tmp` at iteration `i` denotes the number of i-digit integers with unique digits. It\\'s easy to see that `tmp = 9` when `i = 1` (excluding 0), `tmp = 9 * 9` when `i = 2`, `tmp = 9 * 9 * 8` when `i = 3`, ..., `tmp = 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1` when `i = 10`. When `i > 10`, every integer with `i` digits must have duplicated digits. The solution `res` can be constructed iteratively by adding up the `tmp` from each iteration. Finally we return `res + 1` to include 0.\\n```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        tmp = 1\\n        for i in range(1,min(n,10)+1):\\n            if i == 1:\\n                tmp *= 9\\n            else:\\n                tmp *= 10-i+1\\n            res += tmp\\n        return res+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        tmp = 1\\n        for i in range(1,min(n,10)+1):\\n            if i == 1:\\n                tmp *= 9\\n            else:\\n                tmp *= 10-i+1\\n            res += tmp\\n        return res+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910861,
                "title": "c-dp-math-derived-o-1-time-solution-for-arbitrary-base",
                "content": "\\n# Approach 1: Backtracking\\n\\nLet\\'s first think about the nature of the problem. For simplicity, suppose $n = 3$. Then we\\'re searching for the amount of numbers in the range $[0, 10^3) = [0, 999]$ with distinct digits. Let\\'s call any number with distinct digits a \"unique number\". Notice that all $3$-digit unique numbers are of the form $d_3d_2d_1$ ($3$ digit slots to place a distinct digit). For example, for the unique number $123$, $d_3 = 1$, $d_2 = 2$, and $d_1 = 3$. So for any $d_i$, $d_i$ is in the range $[0, 9]$. However, $d_3$ cannot be $0$ because then our number does not have $3$ digits (e.g. $023 = 23$ is a $2$-digit number). So to be more specific, $d_n \\\\in \\\\{1,..., 9\\\\}$ and $d_i \\\\in \\\\{0,..., 9\\\\}$ where $i \\\\in \\\\{1, ...,n - 1\\\\}$. With this in mind, let\\'s think about how we might construct a $3$-digit unique number in the range $[0, 999]$ from left to right. If we fix $d_3$ as some integer $k \\\\in \\\\{1,..., 9\\\\}$, then our options for $d_2$ are limited to $\\\\{0,...,9\\\\} \\\\setminus\\\\{k\\\\}$. And if we fix $d_2$ as some integer $m \\\\in \\\\{0,...,9\\\\} \\\\setminus\\\\{k\\\\}$, then our options for $d_1$ are limited to $\\\\{0,...,9\\\\} \\\\setminus \\\\{k, m\\\\}$. \\n\\nNow let\\'s generalize this to an $n$-digit unique number. Suppose we\\'re choosing the digit to fill $d_i$ ($i \\\\in \\\\{1,...,n - 1\\\\}$). Then we must choose some $k \\\\in \\\\{0,...,9\\\\} \\\\setminus \\\\{d_n,...,d_{i + 1}\\\\}$ and set $d_i = k$. After fixing $d_i$, note that the possible choices for any of the digits to the right of $d_i$ is limited to $\\\\{1,...,9\\\\} \\\\setminus \\\\{d_{n}, ..., d_{i}\\\\}$. So if we track which digits we\\'ve added to our unique number we can construct and count all possible unique numbers.\\n\\nThus, to count all possible unique numbers in the range $[0, 10^n)$, we will individually construct and count all $i$-digit unique numbers for all $i \\\\in \\\\{0,...,n\\\\}$. (We consider $0$ as the only $0$-digit number).\\n\\nSomething else we can notice is that the count of unique numbers is bounded. It turns out that for all $i > 10$, $countNumberWithUniqueDigits(i) = countNumberWithUniqueDigits(10)$. This is because for any $i$-digit number where $i > 10$, there are $11$ or more slots for digits in the number, however, we only have $10$ distinct digits ($\\\\{0,...,9\\\\}$) to incorporate into our unique number, so we could never create an $i$-digit unique number. This is why in all implementations, we set `n = min(10, n)`, however, this is not necessary to pass the test cases as `n` is bounded by $8$ for the test cases.\\n\\n## Algorithm\\n1. Initialize a boolean array `chosen` of length `10` to `false`. `chosen[j]` denotes that `j` already occupies a digit slot $d_i$ ($i \\\\in \\\\{n, ...,i + 1\\\\}$) in our unique number.\\n2. Set $n = min(10, n)$ since we\\'ve established that the number of unique numbers is bounded.\\n3. Create a `backtrack` function that takes `chosen`, `n`, and`k` as arguments. `backtrack` counts the number of $n$-digit unique numbers less than $10^n$ and `k` denotes the digit slot currently being fixed in our unique number:\\n    - If `k == 0`, then return `1` because there are no digits left to fix, and we have a unique number.\\n    - Maintain a variable `numUnique` that counts how many unique numbers exist such that $d_{n},...,d_{k + 1}$ are fixed according to `chosen`.\\n    - Iterate over `chosen`. For each `chosen[i]`, if `chosen[i] == false`, then `i` can occupy slot $d_k$, and we set `chosen[i] = true` and add the result of `backtrack(chosen, k - 1)` to `numUnique`. After, we set `chosen[i] = false` for future calls to `backtrack`. Note that we cannot choose `0` if `k == n` as explained previously. \\n    - Return `numUnique`\\n4. Maintain a variable `count` initialized to `0` that tracks the total count of unique numbers less than $10^n$. Iterate from $0$ to $n$ and add the result of `backtrack(chosen, i)` to `count`.\\n5. Return `count`.\\n\\n## Complexity\\n- Time Complexity: $O(10 * 10!)$ \\n\\n- Space Complexity: $O(10)$ \\n\\n## Code\\n```\\nclass Solution { \\nprivate:\\n    int backtrack(vector<bool>& chosen, int k, int n) {\\n        \\n        if (k < 1)\\n            return 1;\\n\\n        int numUnique = 0;\\n\\n        for (int j = 0; j <= 9; ++j)\\n        {\\n            if ((chosen[j] == false) && (j != 0 || k != n))\\n            {\\n                chosen[j] = true;\\n                numUnique += backtrack(chosen, k - 1, n);\\n                chosen[j] = false;\\n            }\\n        }\\n\\n        return numUnique;\\n    }\\n\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int count = 0;\\n        vector<bool> chosen(10, false);\\n\\n        for (int i = 0; i <= n; ++i)\\n            count += backtrack(chosen, i, i);\\n\\n        return count;\\n    }\\n};\\n```\\n\\n# Approach 2: Math + Dynamic Programming\\n\\nWhile the backtracking algorithm technically has constant time complexity, the time complexity constant is very large. There are two observations we can make to improve the time complexity:\\n\\n1. Optimal substructure: one important thing to notice is that we\\'re performing a lot of redundant computations. When we count the number of $i$-digit unique numbers, we end up reconstructing many of the ($i - 1$)-digit unique numbers, as well as the ($i - 2$)-digit unique numbers and so forth. For example, $4321$\\u2014a $4$-digit unique number\\u2014can be constructed by prepending $4$ to the $3$-digit unique number $321$, and we ended up constructing the unique number $321$ in both the call to `backtrack(chosen, 3, 3)` and `backtrack(chosen, 4, 4)`. This suggests that we can use the result of a previous call like $countNumberWithUniqueDigits(i - 1)$ to solve the current problem $countNumberWithUniqueDigits(i)$.\\n2. The illusion of distinct subproblems: another thing that may be a bit more difficult to notice is that some subproblems appear as distinct in our backtracking solution, but in reality, they\\'re not. For example, suppose $n = 3$ and we fix $d_n = 3$. Then our options for all other digit slots are limited to $\\\\{1,2,4,...,9\\\\}$. Now suppose we fix $d_n = 2$. Then our options for all other digit slots are limited to $\\\\{1,3,4,...,9\\\\}$. While $\\\\{1,2,4,...,9\\\\} \\\\neq \\\\{1,3,4,...,9\\\\}$, the number of ways we can choose the remaining two digits for our unique number from either set and arrange the chosen digits is ultimately the same. This realization will allow us to use combinatorial techniques in deriving a more efficient solution.\\n\\nLet $f(n) = countNumberWithUniqueDigits(n)$. Note that $f(0) = 1$ because the only unique number less than $10^0 = 1$ is $0$. We\\'re going to try to define $f(n)$. \\n\\nFor right now, suppose $g(n)$ is a function that counts how many $n$-digit unique numbers less than $10^n$ exist. Notice the difference between $g$ and $f$. $g(n)$ only counts the number of $n$-digit numbers less than $10^n$ whereas $f(n)$ counts the number of $i$-digit unique numbers less than $10^n$ ***for all*** $$i \\\\in \\\\{0,...,n\\\\}$$. Can you compute $f(n)$ using just $g$ and $f$? Well the formula actually follows the approach we were using before. We still want to count all $i$-digit unique numbers for all $i \\\\in \\\\{0,...,n\\\\}$, so we can just merge the two functions to get:\\n\\n> $f(n) = g(n) + f(n - 1)$\\n\\nNow the main trouble comes with defining $g(n)$\\n\\n\\nBefore we get into some math, let\\'s think intuitively how we could define $g(n)$. Well, remember that for each digit slot we can choose from a set of $10$ digits. We have $n$ digit slots, so we\\'re really focused on choosing $n$ distinct digits from the $10$ available digits. Additionally, we can order the chosen distint digits in any order to form a unique number. So if $waysToChoose_n$ is the number of ways to choose $n$ distinct digits from the $10$ available digits and $waysToOrder_n$ is the number of ways we can order the $n$ chosen digits, the total number of $n$-digit unique numbers that we can form should be $waysToChoose_n \\\\cdot waysToOrder_n$. But there\\'s one slight problem: what if we choose $0$ as one of the $n$ distinct digits. Can you think of how this might become a problem? The issue is that one of the possible ways we can order our distinct digits is by setting $d_{n} = 0$ followed by some ordering of our other $n - 1$ digits. For example, if $n = 4$ and we choose $1$, $0$, $3$, and $4$, one possible ordering is $0123$. But this isn\\'t a $4$-digit unique number but rather a $3$-digit unique number so we need to account for this. Notice that because $0$ is fixed in slot $d_{n}$, the following digits form an $(n - 1)$-digit unique number that doesn\\'t contain a $0$. So it turns out that if $withoutZero_{n - 1}$ denotes the number of $(n - 1)$-digit unique numbers that don\\'t contain a $0$, \\n\\n> $g(n) = (waysToChoose_n \\\\cdot waysToOrder_n) - withoutZero_{n - 1}$\\n\\nNow to mathematically define these variables. Remember that $waysToChoose_n$ is just the number of ways to choose $n$ distinct digits from the $10$ available digits, so $waysToChoose_n = {10 \\\\choose n}$. Additionally, $waysToOrder_n$ is simply the number of ways to order the $n$ distinct digits (i.e. number of permutations), which is $n!$. \\n\\nSo far, we have \\n\\n> $g(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - withoutZero_{n - 1}$\\n\\nRemember that $withoutZero_{n - 1}$ denotes the number of $(n - 1)$-digit numbers that don\\'t contain a $0$. Since the unique number can\\'t contain $0$, we construct a number of this form by choosing $(n - 1)$ digits from the following $9$ non-zero digits: $\\\\{1,...,9\\\\}$ and order the chosen $n - 1$ digits in any way. So if $waysToChooseNoZero_{n - 1}$ denotes the number of ways to choose $n - 1$ distinct digits from the $9$ available non-zero digits and $waysToOrderNoZero_{n - 1}$ denotes the number of ways to order the chosen distinct digits, \\n\\n$withoutZero_{n - 1} = waysToChooseNoZero_{n - 1} \\\\cdot waysToOrderNoZero_{n - 1}$\\n\\nOnce again, $waysToChooseNoZero_{n - 1}$ is just the number of ways to chose $n - 1$ distinct digits from the $9$ available non-zero digits, so $waysToChooseNoZero_{n - 1} = {9 \\\\choose n - 1}$. And $waysToOrderNoZero_{n - 1}$ is simply the number of ways to order the $n - 1$ distinct digits, which is $(n - 1)!$.\\n\\nPutting this altogether, we get\\n> $g(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {9 \\\\choose n - 1}\\\\right)$\\n\\n> $f(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {9 \\\\choose n - 1}\\\\right) + f(n - 1)$\\n\\nTo avoid computing these binomial coefficients, we can simplify our expression\\n\\n$$f(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {9 \\\\choose n - 1}\\\\right) + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{n! \\\\cdot 10!}{n! \\\\cdot (10 - n!)} - \\\\dfrac{(n - 1)! \\\\cdot 9!}{(n - 1)! \\\\cdot (9 - (n - 1))!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{10!}{(10 - n)!} - \\\\dfrac{9!}{(10 - n)!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{(10 - 1) \\\\cdot 9!}{(10 - n)!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{9 \\\\cdot 9!}{(10 - n)!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\dfrac{9 \\\\cdot 9!}{(10 - n)!} + f(n - 1)$$\\n\\n$$ f(n) = \\\\displaystyle\\\\left(9 \\\\cdot \\\\prod_{j = 10 - n + 1}^{9} j\\\\right) + f(n - 1)$$\\n\\n$$ f(n) = \\\\displaystyle\\\\left(9 \\\\cdot \\\\prod_{j = 11 - n}^{9} j\\\\right) + f(n - 1)$$\\n\\nWe now have a much simpler recurrence that can be implemented using constant space dynamic programming since we need only save the result of $f(n - 1)$.\\n\\n## Algorithm\\n1. Initialize `dpOneBack = 1` as $1$. `dpOneBack` represents $f(n - 1)$. Recall that $f(0) = 1$.\\n2. Iterate from `i = 1` to `i = n` and initialize `prod = 1` at the start of the iteration. At any point in the iteration, `prod` $= \\\\displaystyle\\\\prod_{j = 11 - i}^{9} j$. \\n    - At each step of the iteration, we compute $f(i)$ by simply applying the formula: $f(i) = \\\\displaystyle\\\\left(9 \\\\cdot \\\\prod_{j = 11 - i}^{9} j\\\\right) + f(i - 1)$, which is realized as `dpOneBack = (9 * prod) + dpOneBack` since the current $f(i)$ will be $f(i - 1)$ in the next iteration.\\n3. Return `dpOneBack`.\\n\\n## Complexity\\n- Time Complexity: $O(10)$\\n- Space Complexity: $O(1)$\\n\\n## Code\\n```\\nclass Solution { \\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (11 - i))\\n            dpOneBack += (9 * prod);\\n\\n        return dpOneBack;\\n    }\\n};\\n```\\n\\nNote that small changes in the combinatorial expression can not only reduce runtime, but completely change the ease and clarity of your implementation. For example, here is a different implementation with the same runtime but utilizes a different expression:\\n\\n$$ f(n) = \\\\dfrac{9 \\\\cdot 9!}{(10 - n)!} + f(n - 1) = \\\\dfrac{3,265,920}{(10 - n)!} + f(n - 1)$$\\n\\n## Alternate Solution 1\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        long long factorial;\\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        factorial = 1;\\n        dpOneBack = 1;\\n\\n        for (int i = 2; i <= 9; ++i)\\n            factorial *= i;\\n        \\n        for (int i = 1, j = 9; i <= n; ++i)\\n        {\\n            dpOneBack += (3265920 / factorial);\\n            if (factorial > 1)\\n            {\\n                factorial /= j;\\n                --j;\\n            }\\n        }\\n\\n        return dpOneBack;\\n    }\\n};\\n```\\n\\nHere\\'s another solution utilizing our original formula that runs in $O(10^2)$ time:\\n\\n$f(n) = \\\\displaystyle\\\\left(n! \\\\cdot {10 \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {9 \\\\choose n - 1}\\\\right) + f(n - 1)$\\n\\n## Alternate Solution 2\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n\\n        long long prevFactorial, curFactorial;\\n        vector<vector<int>> nCk(11, vector<int>(11));\\n        int dpOneBack;\\n\\n        dpOneBack = 1;\\n        curFactorial = 1;\\n        nCk[0][0] = 1;\\n\\n        for (int i = 1; i < 11; ++i)\\n            for (int k = 0; k <= i; ++k)\\n                nCk[i][k] = ((k == 0 || k >= i) ? 1 : nCk[i - 1][k - 1] + nCk[i - 1][k]);\\n        \\n        for (int i = 1; i <= n; ++i)\\n        {\\n            prevFactorial = curFactorial;\\n            curFactorial = i * prevFactorial;\\n            dpOneBack = (((curFactorial * nCk[10][i]) - (prevFactorial * nCk[9][i - 1])) + dpOneBack);\\n        }\\n\\n        return dpOneBack;\\n    }\\n};\\n```\\n---\\n# Further Thoughts\\n\\nTry the following problem:\\n\\nGiven an integer $n$ and an integer $k$, return the count of all numbers, $x$, in base $k$ with unique digits where $0 \\\\leq x < k^n$.\\n\\n### Example 1\\n**Input:** `n = 2`, `k = 8`\\n**Output:** `57`\\n**Explanation:** There are $57$ numbers with distinct digits in base $8$ less than $8^2 = 64$. Written in base $8$, they are `0, 1, 2, 3, 4, 5, 6, 7, 10, 12, 13, 14, 15, 16, 17, 20, 21, 23, 24, 25, 26, 27, 30, 31, 32, 34, 35, 36, 37, 40, 41, 42, 43, 45, 46, 47, 50, 51, 52, 53, 54, 56, 57, 60, 61, 62, 63, 64, 65, 67, 70, 71, 72, 73, 74, 75, 76`.\\n\\n### Example 2\\n\\n**Input:** `n = 3`, `k = 4`\\n**Output:** `31` \\n**Explanation:** There are $31$ numbers with distinct digits in base $4$ less than $4^3 = 64$. Written in base $4$, they are `0, 1, 2, 3, 10, 12, 13, 20, 21, 23, 30, 31, 32, 102, 103, 120, 123, 130, 132, 201, 203, 210, 213, 230, 231, 301, 302, 310, 312, 320, 321`.\\n\\n### Solution:\\n\\nIf you follow the same reasoning that we did previously, you\\'ll get\\n> $f(0, k) = 1$\\n$f(n, k) = \\\\displaystyle\\\\left(n! \\\\cdot {k \\\\choose n}\\\\right) - \\\\left((n - 1)! \\\\cdot {k - 1 \\\\choose n - 1}\\\\right) + f(n - 1, k)$\\n\\nwhich we can ultimately simplify to $f(n, k) =\\\\displaystyle\\\\left((k - 1) \\\\cdot \\\\prod_{j = k - n + 1}^{k - 1} j\\\\right) + f(n - 1, k)$\\n\\n## Complexity \\n- Time Complexity: $O(k)$\\n- Space Complexity: $O(1)$\\n## Code \\n```\\nunsigned long long countNumbersWithUniqueDigits(int n, int k) {\\n        \\n        unsigned long long dpOneBack;\\n        \\n        n = min(n, k);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (k - i + 1))\\n            dpOneBack += ((k - 1) * prod);\\n\\n        return dpOneBack;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution { \\nprivate:\\n    int backtrack(vector<bool>& chosen, int k, int n) {\\n        \\n        if (k < 1)\\n            return 1;\\n\\n        int numUnique = 0;\\n\\n        for (int j = 0; j <= 9; ++j)\\n        {\\n            if ((chosen[j] == false) && (j != 0 || k != n))\\n            {\\n                chosen[j] = true;\\n                numUnique += backtrack(chosen, k - 1, n);\\n                chosen[j] = false;\\n            }\\n        }\\n\\n        return numUnique;\\n    }\\n\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int count = 0;\\n        vector<bool> chosen(10, false);\\n\\n        for (int i = 0; i <= n; ++i)\\n            count += backtrack(chosen, i, i);\\n\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution { \\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (11 - i))\\n            dpOneBack += (9 * prod);\\n\\n        return dpOneBack;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        long long factorial;\\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        factorial = 1;\\n        dpOneBack = 1;\\n\\n        for (int i = 2; i <= 9; ++i)\\n            factorial *= i;\\n        \\n        for (int i = 1, j = 9; i <= n; ++i)\\n        {\\n            dpOneBack += (3265920 / factorial);\\n            if (factorial > 1)\\n            {\\n                factorial /= j;\\n                --j;\\n            }\\n        }\\n\\n        return dpOneBack;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n\\n        long long prevFactorial, curFactorial;\\n        vector<vector<int>> nCk(11, vector<int>(11));\\n        int dpOneBack;\\n\\n        dpOneBack = 1;\\n        curFactorial = 1;\\n        nCk[0][0] = 1;\\n\\n        for (int i = 1; i < 11; ++i)\\n            for (int k = 0; k <= i; ++k)\\n                nCk[i][k] = ((k == 0 || k >= i) ? 1 : nCk[i - 1][k - 1] + nCk[i - 1][k]);\\n        \\n        for (int i = 1; i <= n; ++i)\\n        {\\n            prevFactorial = curFactorial;\\n            curFactorial = i * prevFactorial;\\n            dpOneBack = (((curFactorial * nCk[10][i]) - (prevFactorial * nCk[9][i - 1])) + dpOneBack);\\n        }\\n\\n        return dpOneBack;\\n    }\\n};\\n```\n```\\nunsigned long long countNumbersWithUniqueDigits(int n, int k) {\\n        \\n        unsigned long long dpOneBack;\\n        \\n        n = min(n, k);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (k - i + 1))\\n            dpOneBack += ((k - 1) * prod);\\n\\n        return dpOneBack;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591981,
                "title": "pure-math-o-1-detail-explanation",
                "content": "Let me ask you a question: \\n\\n**How many 4 digit numbers are there with all unique digit (No digit repeated) ?**\\n\\n* **First digit** can be among **[(1\\u20139)]**, 0 can\\u2019t be there at the first place, as it will become a 3 digit number.Thus,total possibilities=9, for e.g., say 5 is at the first place.\\n\\n* **Second digit** can be among **[(0\\u20139) excluding 5]** (as 5 is taken at the first place(assuming)).Thus total possibilities=9. Say, 0 is placed at second place.\\n\\n* **Third digit** can be among **[(0\\u20139) excluding 0 and 5]** (since 0 and 5 has already been taken). Thus, total possibilities=8. Say, 3 is placed at third place.\\n\\n* Similarly,  **Fourth digit** can be among **[(0\\u20139) excluding 0, 3 and 5]** (since 0, 3 and 5 has already been taken). Thus, total possibilities=7.\\n\\n**Thus, total possibilities= 9\\xD79\\xD78\\xD77=4536 [4 digit number with all unique digit]**\\n\\n------------------------------------------------------------------------------------------------------------------------------------------------\\nNow, coming back to the actual question:\\n\\n**Let ```n=5```, that means give me the count of all numbers in range 0 <= x < 100000 with all unique digit**\\n* So, our probable answer set will contain 1 digit, 2 digit, 3 digit, 4 digit and 5 digit numbers.\\n* So, we will ask the question : \"**How many \\'d\\' digit number are there with all unique digit**\" in a loop which runs from d=1 to d=5. \\n* Add the count of every iteration and get the actual answer.\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    long long uniqueDigitNum(int digit){ // How many \\'d\\' digit number are there with all unique digit\\n        int totalNum=1; int temp=9;\\n        for(int i=1; i<=digit; i++){\\n            if(i==1){ totalNum*=9; } // [1-9] possibility\\n            else{ totalNum*=temp; temp--; }\\n        }\\n        return totalNum;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){ return 1; } // only 0\\n        if(n==1){ return 10; } // all num in range [0-9] are unique digit num\\n        \\n        long long total=10; // every one digit number is unique\\n        for(int i=2; i<=n; i++){\\n            total+=uniqueDigitNum(i);\\n        }\\n        return (int)total;\\n    }\\n};\\n```\\nWorst case time complexity: O(8*8) OR  [O(1)]\\n\\nThanks. Hope it helps !",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```n=5```\n```\\nclass Solution {\\npublic:\\n    long long uniqueDigitNum(int digit){ // How many \\'d\\' digit number are there with all unique digit\\n        int totalNum=1; int temp=9;\\n        for(int i=1; i<=digit; i++){\\n            if(i==1){ totalNum*=9; } // [1-9] possibility\\n            else{ totalNum*=temp; temp--; }\\n        }\\n        return totalNum;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){ return 1; } // only 0\\n        if(n==1){ return 10; } // all num in range [0-9] are unique digit num\\n        \\n        long long total=10; // every one digit number is unique\\n        for(int i=2; i<=n; i++){\\n            total+=uniqueDigitNum(i);\\n        }\\n        return (int)total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067399,
                "title": "simple-compact-fast-and-recursive",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n        return 1;\\n        int p=9,q=9,r=n;\\n        while(n-->1)\\n        p*=q--;     \\n        return p+countNumbersWithUniqueDigits(r-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n        return 1;\\n        int p=9,q=9,r=n;\\n        while(n-->1)\\n        p*=q--;     \\n        return p+countNumbersWithUniqueDigits(r-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636422,
                "title": "easy-to-understand-in-c-math-d-p",
                "content": "class Solution {\\npublic:\\n\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 10;\\n        }\\n        vector<int>dp(9,0);\\n        int sum=1;\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*(10-i+1)+sum;\\n            sum+=dp[i-1];\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 830173,
                "title": "c-digit-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int digitDp(int pos,string visited,unordered_map<int,unordered_map<string,int>>& dp, int n,bool tight){\\n        if(n==pos)\\n            return 1;\\n        if(dp.count(pos) && dp[pos].count(visited))\\n                return dp[pos][visited];\\n        int count=0;\\n        for(int i=0;i<=9;i++){\\n            if(i==0 && tight)\\n                count+=digitDp(pos+1,visited,dp,n,true);\\n            else if(visited[i]==\\'0\\'){\\n                visited[i]=\\'1\\';\\n                count+=digitDp(pos+1,visited,dp,n,false);\\n                visited[i]=\\'0\\';\\n            }\\n        } \\n        return dp[pos][visited]=count;\\n            \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n         unordered_map<int,unordered_map<string,int>> dp; // pos,visited,count\\n        //tight parameter is for handling cases like 0031,0002,00.. these numbers won\\'t be counted if tight isn\\'t used \\n        string visited=\"0000000000\";\\n        int ans=digitDp(0,visited,dp,n,true); // if tight\\'s true then we consider our current number has only zeros till pos-1 so we still have an option to choose zero after pos\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digitDp(int pos,string visited,unordered_map<int,unordered_map<string,int>>& dp, int n,bool tight){\\n        if(n==pos)\\n            return 1;\\n        if(dp.count(pos) && dp[pos].count(visited))\\n                return dp[pos][visited];\\n        int count=0;\\n        for(int i=0;i<=9;i++){\\n            if(i==0 && tight)\\n                count+=digitDp(pos+1,visited,dp,n,true);\\n            else if(visited[i]==\\'0\\'){\\n                visited[i]=\\'1\\';\\n                count+=digitDp(pos+1,visited,dp,n,false);\\n                visited[i]=\\'0\\';\\n            }\\n        } \\n        return dp[pos][visited]=count;\\n            \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n         unordered_map<int,unordered_map<string,int>> dp; // pos,visited,count\\n        //tight parameter is for handling cases like 0031,0002,00.. these numbers won\\'t be counted if tight isn\\'t used \\n        string visited=\"0000000000\";\\n        int ans=digitDp(0,visited,dp,n,true); // if tight\\'s true then we consider our current number has only zeros till pos-1 so we still have an option to choose zero after pos\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700854,
                "title": "python3-math-solution-count-numbers-with-unique-digits",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if not n: return 1\\n        ans, start = 10, 9\\n        for i in range(1, min(10, n)):\\n            start *= (10 - i)\\n            ans += start\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if not n: return 1\\n        ans, start = 10, 9\\n        for i in range(1, min(10, n)):\\n            start *= (10 - i)\\n            ans += start\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508367,
                "title": "deatiled-easy-understand-fastest-solution-beats-100-0-ms-dp-c",
                "content": "# Intuition\\nCalculate all possible combinations with intially 9 digits and for all values of n store it in the dp table\\n\\n# Approach\\nKeeping the base case dp[0] = 0; as for 0 we can have only digit as unique;\\n\\nWe cannot have 0 as the starting digit in any of the numbers\\nso initially we can have 9 digits out of then and then we will have 9 digits , then 8 digits and so on .\\n\\nFor example , if start with 1 then i can combine 2,3,4,5,6,7,8,9,0 with 1 as 12 13 14 15 16 17 18 19 10.\\n\\n\\nThis way I have 9 options to combine with 9 numbers (1,2,3,4,5,6,7,8,9) .\\n\\nThen for n = 3 \\nif start with 17 i can i combine it with all the other digits excluding 1 and 7 i,e with 2,3,4,5,6,8,9 so i have 8 options and so on ..\\n\\n# Complexity\\n- Time complexity:\\nO(n * n) --> O(1) as the maximum value of n is 8\\n- Space complexity:\\nO(9) --> O(1) for storing all possible answers\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0)\\n            return 1;\\n        vector<int> dp(9);\\n        dp[0] = 1;\\n        vector<int> temp = {9, 9, 8, 7, 6, 5, 4, 3, 2, 1};\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1];\\n            int prod = 1;\\n            for(int j = 0; j < i; j++)\\n                prod = prod * temp[j];\\n            dp[i] += prod; \\n        }\\n        return dp[n]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0)\\n            return 1;\\n        vector<int> dp(9);\\n        dp[0] = 1;\\n        vector<int> temp = {9, 9, 8, 7, 6, 5, 4, 3, 2, 1};\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1];\\n            int prod = 1;\\n            for(int j = 0; j < i; j++)\\n                prod = prod * temp[j];\\n            dp[i] += prod; \\n        }\\n        return dp[n]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146694,
                "title": "very-simple-maths-c",
                "content": "# Intuition\\nArrangements of digits\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if(n==0) return 1;\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        dp[1]=10;\\n        int p=9;\\n        int i=9;\\n        for(int x=2; x<=n; x++)\\n        {\\n            p*=i;\\n            dp[x]=dp[x-1]+p;\\n            i--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if(n==0) return 1;\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        dp[1]=10;\\n        int p=9;\\n        int i=9;\\n        for(int x=2; x<=n; x++)\\n        {\\n            p*=i;\\n            dp[x]=dp[x-1]+p;\\n            i--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012058,
                "title": "python-o-1-solution-both-math-dp-explained",
                "content": "n = 2\\nFrom 11 -> 20 => 11,22,33,..99 excluded. \\nso ans = 10(for 1->10) + 9*9(as 1 element excluded in each 10 range). = 10 + 81 = 91\\n\\nn = 3\\nfor 1 -> 100 => ans = 91\\nFrom 101 -> 200 => (100,101), (110,112,113...119), (121,122),..(191,199) excluded.\\nans(100, 199) = 8*9\\nFrom 201 -> 300 => (200,202), (211,212), (220,221,222...229),..(292,299) excluded.\\nans(200, 299) = 8*9\\n.\\n.\\nans(100, 1000) = 8*9*9\\nTotal ans = 10 + 8*9*9 = 739\\n\\nSo Pattern = ans + 9*(11-i) ans i = [2,n]\\n\\n```python\\n# Math \\n\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n == 0: return 1\\n        if n == 1: return 10\\n        \\n        ans = 10\\n        tmp = 9\\n        for i in range(2, n+1):\\n            tmp *= (11 - i)\\n            ans += tmp\\n            \\n        return ans\\n```\\n\\n```python\\n# Dynamic Programming\\n\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        dp = [1, 10]\\n        for i in range(2, n+1):\\n            tmp = 81\\n            for j in range(1, i-1):\\n                tmp *= (9 - j)\\n            ans = dp[i-1] + tmp\\n            dp.append(ans)\\n        \\n        return dp[n]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```python\\n# Math \\n\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n == 0: return 1\\n        if n == 1: return 10\\n        \\n        ans = 10\\n        tmp = 9\\n        for i in range(2, n+1):\\n            tmp *= (11 - i)\\n            ans += tmp\\n            \\n        return ans\\n```\n```python\\n# Dynamic Programming\\n\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        dp = [1, 10]\\n        for i in range(2, n+1):\\n            tmp = 81\\n            for j in range(1, i-1):\\n                tmp *= (9 - j)\\n            ans = dp[i-1] + tmp\\n            dp.append(ans)\\n        \\n        return dp[n]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609586,
                "title": "scam-solution-python-o-1",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n==0:\\n            return 1\\n        elif n == 1 :\\n            return 10\\n        elif n == 2 :\\n            return 91\\n        elif n== 3:\\n            return 739\\n        elif n == 4 :\\n            return 5275\\n        elif n==5 :\\n            return 32491\\n        elif n==6:\\n            return 168571\\n        elif n==7 :\\n            return 712891\\n        else :\\n            return 2345851\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n==0:\\n            return 1\\n        elif n == 1 :\\n            return 10\\n        elif n == 2 :\\n            return 91\\n        elif n== 3:\\n            return 739\\n        elif n == 4 :\\n            return 5275\\n        elif n==5 :\\n            return 32491\\n        elif n==6:\\n            return 168571\\n        elif n==7 :\\n            return 712891\\n        else :\\n            return 2345851\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528511,
                "title": "python-simple-solution-permutation",
                "content": "\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = 1\\n        temp = 1\\n        for i in range(1,n+1):\\n            ans = 9*temp + ans\\n            temp = temp*(10-i)\\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = 1\\n        temp = 1\\n        for i in range(1,n+1):\\n            ans = 9*temp + ans\\n            temp = temp*(10-i)\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2403235,
                "title": "python-o-n-tc-o-1-sc-fastest-solution-simple-code",
                "content": "The efficient solution is based on combinatorics, but don\\'t worry as it\\'s very easy to understand =).\\n\\nLet\\'s look at a few examples based on different values of `n`:\\n`n = 0` => possible numbers are `[0]` => answer is `1` - this will be a degenerate case\\n`n = 1` => possible numbers are `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]` => answer is `10`\\n\\nFor every value of `n` greater than `1` the numbers will have a varying number of digits, going from 1 to `n`. Let\\'s define `f(x)` as a function that takes in the value of `n` and returns the answer to the problem, the amount of unique numbers from `[0, 10 ** n)`.\\n\\nAs an example, let\\'s assume `n = 2`. The numbers that belong to the range `[0, 10 ** 2)` can have either one or two digits. It\\'s easy to see that all the single digit numbers are the ones that were counted by `f(1)`:\\n```\\nf(2) = f(1) + len([all numbers with exactly two non-matching digits])\\n```\\nIn fact, it\\'s easy to see that a general statement is true:\\n```\\nf(n) = f(n-1) + len([all the numbers with exactly n unique digits])\\n```\\nTo count those unique digit numbers of length `n` we can use a bit of combinatorics.\\nIndeed, all the digits from `0` to `9` form a set of length 10. For the 1st digit we have `10` options to pick from, for the 2nd digit we have `9` (minus the previously picked option), and so on:\\n```\\nNumber of unique digit numbers of length n = 10! / (10 - n)! = 10 * 9 * ... * (10 - n + 1)\\n```\\nHowever, it\\'s slightly more tricky than that. Because, when we pick the 1st digit, we can\\'t really pick `0`, since prefix zeros don\\'t count and we\\'d in fact end up with a number of length `n-1`, which was already counted by `f(n-1)`. So for the 1st digit we only have nine options, however for the 2nd digit we have *nine options again* (because `0` is now allowed), for the 3rd digit eight options and so on:\\n```\\nNumber of unique digit numbers of length n = 9 * 9! / (10 - n)!\\nexcept for n = 0 and n = 1, for which we have special answers\\n```\\nThis concludes the explanation of the algo itself. Now, to implement it efficiently, we can reuse the previously calculated product of `9 * 8 * ... * (10 - n + 1)` and only grow it by performing a single multiplication by `10 - n` on the next iteration:\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        res = 1  # will be used if n = 0, equals to sum(f(i) for i in range(n))\\n        product_accum = 1  # will be used to accumulate the product of 9 * 8 * ...\\n\\n        for i in range(n):\\n            res += product_accum * 9\\n            product_accum *= (10 - i - 1)\\n        \\n        return res\\n```\\nPlease upvote this post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nf(2) = f(1) + len([all numbers with exactly two non-matching digits])\\n```\n```\\nf(n) = f(n-1) + len([all the numbers with exactly n unique digits])\\n```\n```\\nNumber of unique digit numbers of length n = 10! / (10 - n)! = 10 * 9 * ... * (10 - n + 1)\\n```\n```\\nNumber of unique digit numbers of length n = 9 * 9! / (10 - n)!\\nexcept for n = 0 and n = 1, for which we have special answers\\n```\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        res = 1  # will be used if n = 0, equals to sum(f(i) for i in range(n))\\n        product_accum = 1  # will be used to accumulate the product of 9 * 8 * ...\\n\\n        for i in range(n):\\n            res += product_accum * 9\\n            product_accum *= (10 - i - 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001725,
                "title": "solution-using-basic-maths-explained-beats-100",
                "content": "**IDEA** basic idea behind the solution is permutations. \\n1. Ask yourself how many unique numbers we can form with a single digit number ? answer is 9 as` _` can be filled with digits 1 to 9. (0 is not valid here)\\n2. Ask yourself how many unique numbers we can form with a two digit number ? answer is 81. two digit number like ` _ _ ` - first place can be filled with 9 digits(1-9) and second place can also be filled with 9 digits(including 0 this time and excluding the digit used previously) , so `9*9=81`\\n3. Ask yourself how many unique numbers we can form with a three digit number ? answer is 648. three digit number like `_ _ _ ` - first place can be filled with 9 digits(1-9) and second place can also be filled with 9 digits(including 0 this time and excluding the digit used previously) and third place can be filled with 8 digits (0-9 excluding the last two digits used), so `9*9*8=648`\\n\\ni hope you can see the pattern here. we can clearly see that with 4 digits, we will have `9*9*8*7` total unique numbers.\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n       \\n\\t   int[] counts = new int[n+1];\\n        counts[0]=1; // only 0\\n        counts[1]=9; // digits 1-9\\n        int multiplier=9;\\n        for(int i=2;i<=n;i++){\\n            counts[i]=counts[i-1]*multiplier; // counts[2]=9*9 / counts[3]=9*9*8 / counts[4]=9*9*8*7 and so on\\n            multiplier--;\\n        }\\n        \\n        int res=0; // now we gotta add em all up(one digit, two digit...nth digit unique numbers) and return\\n        for(int i:counts)\\n            res+=i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n       \\n\\t   int[] counts = new int[n+1];\\n        counts[0]=1; // only 0\\n        counts[1]=9; // digits 1-9\\n        int multiplier=9;\\n        for(int i=2;i<=n;i++){\\n            counts[i]=counts[i-1]*multiplier; // counts[2]=9*9 / counts[3]=9*9*8 / counts[4]=9*9*8*7 and so on\\n            multiplier--;\\n        }\\n        \\n        int res=0; // now we gotta add em all up(one digit, two digit...nth digit unique numbers) and return\\n        for(int i:counts)\\n            res+=i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701638,
                "title": "c-recursive-solution",
                "content": "* **F** is a flag variable for recursion to know whether number made till now has leading zeroes beacuse if it has leading zeroes it means we can use zero at ith index otherwise we can\\'t . Dis is a kind of visited array made using nits , it states if jth bit is set means jth digit is already used.And recursion is called for next index.\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\t\\n\\tint rec(int i,int n,int dis,int f)\\n    {\\n        if(i>n)\\n            return 1;\\n        \\n        int cnt=0;\\n        for(int j=0;j<=9;j++)\\n        {\\n            if((1<<j) & dis)\\n                continue;\\n            if(i==1 && j==0)\\n            {\\n                cnt+=rec(i+1,n,dis,1);\\n            }\\n            else if(f==1 && j==0)\\n                cnt+=rec(i+1,n,dis,f);\\n            else\\n            cnt+=rec(i+1,n,dis | (1<<j),0);\\n        }\\n        \\n        return cnt;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        return rec(1,n,0,0);\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\n\\tint rec(int i,int n,int dis,int f)\\n    {\\n        if(i>n)\\n            return 1;\\n        \\n        int cnt=0;\\n        for(int j=0;j<=9;j++)\\n        {\\n            if((1<<j) & dis)\\n                continue;\\n            if(i==1 && j==0)\\n            {\\n                cnt+=rec(i+1,n,dis,1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1691130,
                "title": "c-maths-p-c-0-ms-faster-than-100-00",
                "content": "*Please **upvote** if you find it helpful :)*\\n```\\nclass Solution {\\npublic:\\n    int totalUnique(int n) {\\n        if(n==1)\\n            return 10;\\n        int ans=9,k=9;\\n        for(int i=2;i<=n;i++) {\\n            ans*=k;\\n            k--;\\n        }\\n        return ans;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        int sum = 0;\\n        for(int i=1;i<=n;i++) {\\n            sum += totalUnique(i);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalUnique(int n) {\\n        if(n==1)\\n            return 10;\\n        int ans=9,k=9;\\n        for(int i=2;i<=n;i++) {\\n            ans*=k;\\n            k--;\\n        }\\n        return ans;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        int sum = 0;\\n        for(int i=1;i<=n;i++) {\\n            sum += totalUnique(i);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354910,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int res=10,temp=9;\\n        for(int i=2;i<=n;++i){\\n            temp=temp*(11-i);   \\n            res+=temp;\\n        }    \\n     return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int res=10,temp=9;\\n        for(int i=2;i<=n;++i){\\n            temp=temp*(11-i);   \\n            res+=temp;\\n        }    \\n     return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309489,
                "title": "dp-top-down-approach",
                "content": "\\n\\t\\t// THE possibilties of a 3 digit number with all digitis unique is 9*9*8\\n\\t\\t// for 4 digits it is 9*9*8*7  .. for 5 digit 9*9*8*7*6 and so on .. construct a dp table by using this logic//\\n        int countNumbersWithUniqueDigits(int n) {\\n      if(n ==1){return 10;}\\n        if(n ==0){return 1;}\\n        if(n ==2){return 91;}\\n        vector<int>dp(n-1);\\n        dp[0] =91;\\n        int x = 81 , y= 8;\\n        for(int i=1;i<=n-2;i++){\\n              x = x*y;\\n            dp[i] = dp[i-1] +x;\\n            y--;\\n                \\n            \\n        }\\n        return dp[n-2];\\n        \\n        \\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\n\\t\\t// THE possibilties of a 3 digit number with all digitis unique is 9*9*8\\n\\t\\t// for 4 digits it is 9*9*8*7  .. for 5 digit 9*9*8*7*6 and so on .. construct a dp table by using this logic//\\n        int countNumbersWithUniqueDigits(int n) {\\n      if(n ==1){return 10;}\\n        if(n ==0){return 1;}\\n        if(n ==2){return 91;}\\n        vector<int>dp(n-1);\\n        dp[0] =91;\\n        int x = 81 , y= 8;\\n        for(int i=1;i<=n-2;i++){\\n              x = x*y;\\n            dp[i] = dp[i-1] +x;\\n            y--;\\n                \\n            \\n        }\\n        return dp[n-2];\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1277883,
                "title": "c-dynamic-programming-o-n-space-time-100-faster-than-other-c",
                "content": "Explaination:\\ndp for this question can be traced trying out some example\\nf(0) = 1;\\nf(1) = 10;\\nf(2)= 91;\\n\\nf(3) = (10 -3 + 1)* f(2) + f(1) + f(0);\\nf(4) = (10-4+1)*f(3) + f(2) + f(1)+f(0);\\n\\n\\nsimilarly f(i) = (10 - i + 1) * f(i-1) + f(i-2)..............+f(0);\\nbelow is the implementation:\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        \\n        vector<int> dp(9,0);\\n            int sum = 1;\\n        dp[0]= 1;\\n        dp[1] = 10;\\n            \\n            for(int i =2;i<=n;i++)\\n            {\\n                dp[i] = (10-i+1)*dp[i-1] + sum;\\n                sum+=dp[i-1];\\n            }\\n      return dp[n];  \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        \\n        vector<int> dp(9,0);\\n            int sum = 1;\\n        dp[0]= 1;\\n        dp[1] = 10;\\n            \\n            for(int i =2;i<=n;i++)\\n            {\\n                dp[i] = (10-i+1)*dp[i-1] + sum;\\n                sum+=dp[i-1];\\n            }\\n      return dp[n];  \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131381,
                "title": "python-solution-using-combinations",
                "content": "Here we can choose prev = 9, because we have 9 choices for first place from the left beacause we do not use 0 at first place e.g 01, 02, 03, 04, etc. and ans = 10 because if we have only 1 digit then we have 10 choices.\\nWe have 9 choices for the first place and 9 choices for the second place beacause if we use any no from (1,9) then we have 9 choices left, E.g if we choose 1 then we have choices (0, 2, 3, 4, 5, 6, 7, 8, 9).\\nAfterwards, choices are decreasing at every level like 9 x 9 x 8 x 7 x 6 x ........ and so on.  \\n\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:        \\n        prev, ans = 9, 10\\n        for i in range(1, n):\\n            prev *= 10-i\\n            ans += prev\\n        \\n        return ans if n else 1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:        \\n        prev, ans = 9, 10\\n        for i in range(1, n):\\n            prev *= 10-i\\n            ans += prev\\n        \\n        return ans if n else 1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001549,
                "title": "java-very-easy-0ms-faster-than-100-o-1-time-and-space-7-lines-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\tif(n==0)    return 1;\\n\\t\\t\\tint ans=10,t=9;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tt*=(9-i);\\n\\t\\t\\t\\tans+=t;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\tif(n==0)    return 1;\\n\\t\\t\\tint ans=10,t=9;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tt*=(9-i);\\n\\t\\t\\t\\tans+=t;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 993375,
                "title": "python-only-simple-math-pattern",
                "content": "```\\n# Written by : Dhruv Vavliya\\ndef cnwud(n):\\n    if n==0:\\n        return 1\\n    if n==1:\\n        return 10\\n\\n    ans = 10\\n\\ttemp =9\\n\\tfor i in range(2,n+1):\\n\\t\\ttemp *=(11-i)\\n\\t\\tans+=temp\\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n# Written by : Dhruv Vavliya\\ndef cnwud(n):\\n    if n==0:\\n        return 1\\n    if n==1:\\n        return 10\\n\\n    ans = 10\\n\\ttemp =9\\n\\tfor i in range(2,n+1):\\n\\t\\ttemp *=(11-i)\\n\\t\\tans+=temp\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 292916,
                "title": "python3-dp-with-explanation",
                "content": "This question is how to change the 0 to the number[0-9]\\n2 situation:\\n1. first is 0\\n\\tthis situation is same as n - 1\\n2. first not 0\\n\\tfirst select 1 - 9 -----> have 9 ways (10 - 1)\\n\\tsecond select 0 - 9 exclude first -------> have 9 ways (10 - 1)\\n\\tthen select 0-9 exclude first and second ----------> 10 - 2\\n\\tuntil all the 0 fixed with 0 - 9\\n\\t\\n\\t\\n\\t\\n\\tn = 0     |    just 0       |  1\\n\\tn = 1     |    0            |   10 (select from 0 - 9 )\\n\\tn = 2     |    00           |   10 + 9 * 9 (1 situation: if first 0 fixed with 0, this is same as n - 1. 2 situation: first select from 1-9 ,then 0 - 9 exclude first ,then the rest ..... \\n\\tn = 3     |    000          | 10 + 9 * 9 + 9 * 9 * 8\\n\\n```python3\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n         dp = [1, 10]\\n         for i in range(2, n+1):\\n             res = 81\\n             for j in range(1, i-1):\\n                 res = res * (9 - j)\\n             dp.append(dp[i - 1] + res)\\n        \\n         return dp[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python3\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n         dp = [1, 10]\\n         for i in range(2, n+1):\\n             res = 81\\n             for j in range(1, i-1):\\n                 res = res * (9 - j)\\n             dp.append(dp[i - 1] + res)\\n        \\n         return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209719,
                "title": "python-backtracking",
                "content": "```\\nclass Solution(object):    \\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.counter = 0\\n        self.n = n\\n        ran = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return len(ran)\\n        self.helper(n, ran, [])\\n        return self.counter + 10\\n\\n    def helper(self, n, r, c):\\n        if len(c) > 1 and c[0] != 0:\\n            self.counter += 1\\n        if n == 0:\\n            return\\n        for j in range(len(r)):\\n            self.helper(n-1, r[:j]+r[j+1:], c+[r[j]])\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):    \\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.counter = 0\\n        self.n = n\\n        ran = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return len(ran)\\n        self.helper(n, ran, [])\\n        return self.counter + 10\\n\\n    def helper(self, n, r, c):\\n        if len(c) > 1 and c[0] != 0:\\n            self.counter += 1\\n        if n == 0:\\n            return\\n        for j in range(len(r)):\\n            self.helper(n-1, r[:j]+r[j+1:], c+[r[j]])\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 207792,
                "title": "java-9-lines-beats-100-with-explanation",
                "content": "1. if n = 0, then return 1 = 1;\\n2. if n = 1, then return 1 + 9 = 10;\\n3. if n = 2, then return 1 + 9 + (9 * 8 + 9 * 1) = 91;\\n4. So we can use the mathematical way of arranging combinations. if the length of number is n, then we can get two case:\\n\\ta. the number does not include char \\'0\\'\\uFF0Ctotal number of combinations is \\n\\t\\t ----A(9, n) = 9 * \\xB7\\xB7\\xB7 * (9 - n + 1);\\n\\tb. the number includes char \\'0\\', total number of combinations is \\n\\t\\t----A(9, n - 1) * (n - 1) = 9 * \\xB7\\xB7\\xB7 * (9 - n + 2) * (n - 1);\\n\\tso the total of two case is 9 * A(9, n - 1).\\n5. So we can get the transfer equation\\uFF0Cdp[i] = dp[i - 1] + 9 * A(9, n - 1).\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            int product = 9;\\n            for (int j = 0; j < i - 1; j++) {\\n                product *= (9 - j);\\n            }\\n            dp[i] = dp[i - 1] + product;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            int product = 9;\\n            for (int j = 0; j < i - 1; j++) {\\n                product *= (9 - j);\\n            }\\n            dp[i] = dp[i - 1] + product;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83122,
                "title": "python-solution-with-explanation-in-comment",
                "content": "```\\n    def countNumbersWithUniqueDigits(self, n):\\n        # n can not be greater than 10 as it must exist two of the digit share same number\\n        # f(n) = 1-digits unique num combination + 2-digits unique num combination + ...\\n        # f(n) = 10 + 9 * 9 + 9 * 9 * 8 + ...\\n        # f(n) = g(0) + g(1) + g(2) + ... + g(n)\\n        # g(0) = 10\\n        # g(1) = 9 * 9\\n        # g(2) = 9 * 9 * 8\\n        # g(k) = 9 * (10 - 1) * (10 - 2) * ... * (10 - k)\\n        if n == 0: return 1\\n        if n == 1: return 10\\n        n = min(10, n)\\n        res = 10\\n        for n in range(1, n):\\n            g = 9\\n            for i in range(1, n+1):\\n                g *= (10 - i)\\n            res += g\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def countNumbersWithUniqueDigits(self, n):\\n        # n can not be greater than 10 as it must exist two of the digit share same number\\n        # f(n) = 1-digits unique num combination + 2-digits unique num combination + ...\\n        # f(n) = 10 + 9 * 9 + 9 * 9 * 8 + ...\\n        # f(n) = g(0) + g(1) + g(2) + ... + g(n)\\n        # g(0) = 10\\n        # g(1) = 9 * 9\\n        # g(2) = 9 * 9 * 8\\n        # g(k) = 9 * (10 - 1) * (10 - 2) * ... * (10 - k)\\n        if n == 0: return 1\\n        if n == 1: return 10\\n        n = min(10, n)\\n        res = 10\\n        for n in range(1, n):\\n            g = 9\\n            for i in range(1, n+1):\\n                g *= (10 - i)\\n            res += g\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 83146,
                "title": "simple-c-recursive-solution-using-combinatorics",
                "content": "**Idea:** \\n\\nWithin range [1 ... 10), there are totally 9 numbers with unique digits.\\n\\nWithin range [10 ... 100), there are totally 9 * 9 numbers with unique digits.\\n\\nWithin range [100 ... 1000), there are totally 9 * 9 * 8 numbers with unique digits.\\n\\n\\n**Pattern:**\\n\\nWithin range [10^(n-1) ... 10^n) where n>=2, there are totally 9 * (9 - 0) * (9 - 1) * (9 - 2) ... * (9 - (n - 2)) numbers with unique digits\\n\\n    // top-down recursive\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0)\\n            return 1;\\n    \\n        int sum = 9;\\n        for (int i = 0; i <= n - 2; ++i)\\n            sum *= (9 - i);\\n        \\n        return sum + countNumbersWithUniqueDigits(n - 1);\\n    }\\n\\n    // bottom-up DP\\n    int countNumbersWithUniqueDigits(int n) {\\n        vector<int> dp (n + 1);\\n        dp[0] = 1;\\n        dp[1] = 10;\\n\\n        for (int i = 2; i <= n; ++i)\\n        {\\n            int sum = 9;\\n            for (int j = 0; j <= i - 2; ++j)\\n                sum *= (9 - j);\\n            dp[i] = sum + dp[i - 1];\\n        }       \\n        return dp[n];\\n    }",
                "solutionTags": [],
                "code": "**Idea:** \\n\\nWithin range [1 ... 10), there are totally 9 numbers with unique digits.\\n\\nWithin range [10 ... 100), there are totally 9 * 9 numbers with unique digits.\\n\\nWithin range [100 ... 1000), there are totally 9 * 9 * 8 numbers with unique digits.\\n\\n\\n**Pattern:**\\n\\nWithin range [10^(n-1) ... 10^n) where n>=2, there are totally 9 * (9 - 0) * (9 - 1) * (9 - 2) ... * (9 - (n - 2)) numbers with unique digits\\n\\n    // top-down recursive\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0)\\n            return 1;\\n    \\n        int sum = 9;\\n        for (int i = 0; i <= n - 2; ++i)\\n            sum *= (9 - i);\\n        \\n        return sum + countNumbersWithUniqueDigits(n - 1);\\n    }\\n\\n    // bottom-up DP\\n    int countNumbersWithUniqueDigits(int n) {\\n        vector<int> dp (n + 1);\\n        dp[0] = 1;\\n        dp[1] = 10;\\n\\n        for (int i = 2; i <= n; ++i)\\n        {\\n            int sum = 9;\\n            for (int j = 0; j <= i - 2; ++j)\\n                sum *= (9 - j);\\n            dp[i] = sum + dp[i - 1];\\n        }       \\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 83148,
                "title": "combination-java-solution",
                "content": "    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)    return 1;\\n        int total = 10;\\n        while(n>1){\\n            int r=9;\\n            for(int i=1;i<n;i++)\\n                r*=10-i;\\n            total+=r;\\n            n--;\\n        }\\n        return total;\\n    }",
                "solutionTags": [],
                "code": "    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)    return 1;\\n        int total = 10;\\n        while(n>1){\\n            int r=9;\\n            for(int i=1;i<n;i++)\\n                r*=10-i;\\n            total+=r;\\n            n--;\\n        }\\n        return total;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3559666,
                "title": "357-count-numbers-with-unique-digits-java",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        int sta=9,cur=9,ans=10;\\n        while(sta>0&&n>1)\\n        {\\n            cur*=sta;\\n            sta--;\\n            ans+=cur;\\n            n--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        int sta=9,cur=9,ans=10;\\n        while(sta>0&&n>1)\\n        {\\n            cur*=sta;\\n            sta--;\\n            ans+=cur;\\n            n--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957098,
                "title": "java-100-faster-solution",
                "content": "# Approach\\nI noted the following pattern when took a pen and paper.\\n\\n1. n = 0 => 1\\n2. n = 1 => 10. Since 10 unique numbers 0-9.\\n3. n = 2 => 9 * 9 + 10 => 91. Since first num can be 1-9, second num can be 0-9, but except one. And plus previuos unique nums.\\n4. n = 3 => 9 * 9 * 8 + 91 = 648 + 91 = 739 and so on.\\n\\nAnd I used static array as a cache for optimization purposes.\\n\\n# Code\\n```\\nclass Solution {\\n    static int[] res;\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (res == null) initArray();\\n        return res[n];\\n    }\\n\\n    private static void initArray() {\\n        res = new int[9];\\n        res[0] = 1;\\n        res[1] = 10;\\n        for (int i = 2; i < res.length; i++) {\\n            int mult = 9;\\n            for (int j = 9; j > 9 - i + 1; j--) {\\n                mult *= j;\\n            }\\n            res[i] = mult + res[i - 1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] res;\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (res == null) initArray();\\n        return res[n];\\n    }\\n\\n    private static void initArray() {\\n        res = new int[9];\\n        res[0] = 1;\\n        res[1] = 10;\\n        for (int i = 2; i < res.length; i++) {\\n            int mult = 9;\\n            for (int j = 9; j > 9 - i + 1; j--) {\\n                mult *= j;\\n            }\\n            res[i] = mult + res[i - 1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956193,
                "title": "max-test-case-n-is-8-then-o-1-would-work",
                "content": "Have fun :)\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countNumbersWithUniqueDigits = function(n) {\\n    return [1,10,91,739,5275,32491,168571,712891,2345851][n]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countNumbersWithUniqueDigits = function(n) {\\n    return [1,10,91,739,5275,32491,168571,712891,2345851][n]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2860452,
                "title": "cheating-java-solution-0ms-100-fast",
                "content": "```\\nclass Solution \\n{\\n    \\n    public int countNumbersWithUniqueDigits(int n) \\n    {\\n      if(n==0)\\n          return 1;\\n        int a1=10;\\n        int a2=9*9;\\n        int a3=a2*8;\\n        int a4=a3*7;\\n        int a5=a4*6;\\n        int a6=a5*5;\\n        int a7=a6*4;\\n        int a8=a7*3;\\n        int a9=a8*2;\\n        int arr[]={a1,a2,a3,a4,a5,a6,a7,a8,a9};\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           sum+=arr[i]; \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\n    \\n    public int countNumbersWithUniqueDigits(int n) \\n    {\\n      if(n==0)\\n          return 1;\\n        int a1=10;\\n        int a2=9*9;\\n        int a3=a2*8;\\n        int a4=a3*7;\\n        int a5=a4*6;\\n        int a6=a5*5;\\n        int a7=a6*4;\\n        int a8=a7*3;\\n        int a9=a8*2;\\n        int arr[]={a1,a2,a3,a4,a5,a6,a7,a8,a9};\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           sum+=arr[i]; \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763119,
                "title": "100-simple-loop-one-line-c",
                "content": "**\\nafter 2 digits it\\'s just (10-number of digits used) to be added at the end\\nEX-\\n\\tif u got a 2 digit number 12\\n\\tYou can add digits 3,4,5.......9,0 at end to create new 3 digit number \\n**\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        if(n==2) return 91;\\n        \\n        int count=91,digits=81;\\n        \\n        for(int i=3;i<=n;i++){\\n            count+=(digits*=(10-i+1));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        if(n==2) return 91;\\n        \\n        int count=91,digits=81;\\n        \\n        for(int i=3;i<=n;i++){\\n            count+=(digits*=(10-i+1));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726133,
                "title": "java-0-1-100-bettter-runtime-solution",
                "content": "java solution without using extra space:\\n\\nclass Solution {\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)return 1;\\n        int count = 0;\\n        int prev2 = 1;\\n        int prev1 = 10;\\n        int freq = 9;\\n        for(int i=2; i<=n; i++){\\n            int temp = prev1;\\n            prev1 = prev1+(prev1 - prev2)*freq;\\n            prev2 = temp;\\n            freq--;\\n        }\\n        return prev1;\\n    }\\n}\\nplz upvote if u like it->",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)return 1;\\n        int count = 0;\\n        int prev2 = 1;\\n        int prev1 = 10;\\n        int freq = 9;\\n        for(int i=2; i<=n; i++){\\n            int temp = prev1;\\n            prev1 = prev1+(prev1 - prev2)*freq;\\n            prev2 = temp;\\n            freq--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2684811,
                "title": "faster-than-100-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0)\\n            return 1;\\n        \\n        int p=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i==1||i==2)\\n                p=p*9;\\n            else\\n                p=p*(9+2-i);\\n        }\\n        int ans=p+countNumbersWithUniqueDigits(n-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0)\\n            return 1;\\n        \\n        int p=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i==1||i==2)\\n                p=p*9;\\n            else\\n                p=p*(9+2-i);\\n        }\\n        int ans=p+countNumbersWithUniqueDigits(n-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424333,
                "title": "faster-than-100-cpp-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        long long int ans=10;\\n        \\n        for(int i=2;i<=n;i++){\\n            long long int ct=9,t=i-1,j=9;\\n            while(t--){\\n                ct*=j;\\n                j--;\\n            }\\n            ans+=ct;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        long long int ans=10;\\n        \\n        for(int i=2;i<=n;i++){\\n            long long int ct=9,t=i-1,j=9;\\n            while(t--){\\n                ct*=j;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2121045,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        int ans=9;\\n        int d=9;\\n        int k=n-1;\\n        while(k--)\\n        {\\n            ans*=d;\\n            d--;\\n        }\\n        return ans + countNumbersWithUniqueDigits(n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        int ans=9;\\n        int d=9;\\n        int k=n-1;\\n        while(k--)\\n        {\\n            ans*=d;\\n            d--;\\n        }\\n        return ans + countNumbersWithUniqueDigits(n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962969,
                "title": "count-numbers-with-unique-digits-c-0ms-100-faster-easy-to-understand",
                "content": "This question is quite simple if you know some basic maths topic \\'Permutations\\' and basic dp\\nIn this question we have to find out the 10^n unqiue digits generate, break this question as\\nwe have to find the solution for \\n**10^1 + 10^2  +  10^3 +  ....., +  10^n;**\\nthat\\'s it. Your questions is solve HaHa\\nBut here come a part how we solve **10^2, 10^3**, or so on\\n**For that you can convert the question as you have to find out the permutation generated having 10 different digits(0, 1, 2, 3, ... , 9) without repetation.**\\ne.g:\\nSo for three digits number we have  (_ _ _ ) three different positon and for first position i.e unit digit we have 10 options and for second digits we have 9 options and for third digit we have 8 and so on..  so this process gives a total number generated into 10^3 with repetation but their is edge case we can\\'t fix zero at the last position. \\nTo solve this edge case we simply find out the numbers of permutation generated when we fix the last position i.e (0, _ , _) after that we have only 9 option for unit digit and 8 option of the second digit and so on..\\nand to get the answer we substract the **(totat number generated without repeation - total number generated with fixing the last postion with zero)**\\n\\n```\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans = 1;\\n        for(int i  = 1; i<=n; i++)\\n        {\\n            // first find the number which is generated by 0-9\\n            int ctn = 1;\\n            int temp = i;\\n            for(int j = 10; temp!=0; j--)\\n            {\\n                ctn*=j;\\n                temp--;\\n            }\\n            // number which is genrated when we fix 0 at the last position\\n            temp = i-1;\\n            int ctn2 = 1;\\n            for(int j = 9; temp!=0; j--)\\n            {\\n                ctn2*=j;\\n                temp--;\\n            }\\n            ans+=(ctn - ctn2);\\n        }\\n\\t\\t\\treturn ans;```\\n\\n}\\n\\nIf you able to understand the solution hit the upvote button",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans = 1;\\n        for(int i  = 1; i<=n; i++)\\n        {\\n            // first find the number which is generated by 0-9\\n            int ctn = 1;\\n            int temp = i;\\n            for(int j = 10; temp!=0; j--)\\n            {\\n                ctn*=j;\\n                temp--;\\n            }\\n            // number which is genrated when we fix 0 at the last position\\n            temp = i-1;\\n            int ctn2 = 1;\\n            for(int j = 9; temp!=0; j--)\\n            {\\n                ctn2*=j;\\n                temp--;\\n            }\\n            ans+=(ctn - ctn2);\\n        }\\n\\t\\t\\treturn ans;```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753716,
                "title": "0-ms-faster-than-100-00-c",
                "content": "1. n = 1\\nall possible numbers are 0 to 9, the answer will be 10  \\n\\n2. n = 4, consider our number is look like \"ABCD\"\\n\\tthere are 9 choices for digit A (since the first digit cannot be 0)\\n\\tthere are 9 choices for B (since it should be different from A, but we may use 0)\\n\\tthe same way for C are 8 choices and 7 choices for D\\n\\n\\tSo in total there are 9\\u22179\\u22178\\u22177=4536  possible numbers.\\n\\nI calculate all possible combinations for each number of digits (starting from 1 to n) and sum them together\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)\\n            return 1;\\n        \\n        int sum = 10;\\n        int curr = 9;\\n        int count = 9;\\n        \\n        while(n > 1)\\n        {\\n            curr *= count--;\\n            sum += curr;\\n            n--;\\n        } \\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0)\\n            return 1;\\n        \\n        int sum = 10;\\n        int curr = 9;\\n        int count = 9;\\n        \\n        while(n > 1)\\n        {\\n            curr *= count--;\\n            sum += curr;\\n            n--;\\n        } \\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739148,
                "title": "super-simple-python-solution-with-explanation",
                "content": "```py\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n\\n        ans, choices, k = 10, 9, 9\\n\\n        for m in range(2, n + 1):\\n            choices *= k\\n            ans += choices\\n            k -= 1\\n\\n        return ans\\n```\\n\\nThe problem is just simple combinatorics. It\\'s basic counting with the only slight modification being that the first digit cannot be a zero, except for 1 digit numbers where the number of choices is 10.\\n\\nSo for the first digit we have 9 choices (1-9), for the second we have 9 choices again (0-9 excluding the first digit choice), for the third we have 8 choices and so on.\\n\\nWe need to compute the number of choices for an `m` digit number for all `m` from 1 to `n` and return their sum as the result.\\n\\nHowever, the number of choices for an `m + 1` digit number builds up on the number of choices for an `m` digit number so we can store the previous result to speed things up.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```py\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n\\n        ans, choices, k = 10, 9, 9\\n\\n        for m in range(2, n + 1):\\n            choices *= k\\n            ans += choices\\n            k -= 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701861,
                "title": "easiest-c-solution-simple-maths-0ms-explained",
                "content": "This problem is a simple Permutaions and COmbinations sum. We know that from 0-9 there are 10 numbers with unique digits. When n>1 we can calcualte the numbers with unique digits through this :\\n![image](https://assets.leetcode.com/users/images/e6da6106-dcc0-41cb-85a8-6f165c3e0b62_1642584666.9986122.jpeg)\\n\\nOnce we get the factorials, We just keep finding the sum.\\n\\n```\\nclass Solution {\\npublic:\\n    int count(int n)\\n    {\\n        int ans=1,k=9;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans*=k;\\n            if(i!=1)\\n                k--;\\n        }\\n        return ans;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        int ans=10;\\n        for(int i=2;i<=n;i++)        \\n            ans+=count(i);\\n        return ans;        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(int n)\\n    {\\n        int ans=1,k=9;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans*=k;\\n            if(i!=1)\\n                k--;\\n        }\\n        return ans;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 10;\\n        int ans=10;\\n        for(int i=2;i<=n;i++)        \\n            ans+=count(i);\\n        return ans;        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665664,
                "title": "c-clean-solution-recursive-to-dp-optimal-solution",
                "content": "**\\uD83D\\uDE4FPlease Upvote\\uD83D\\uDE4F**\\n- Solution approach explanation link [CLICK HERE](https://hjweds.gitbooks.io/leetcode/content/count-numbers-with-unique-digits.html)\\n<br>\\n**RECURSIVE APPROACH**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isDuplicate(int n){\\n        unordered_set<int> digits;\\n        while(n>0){\\n            int d = n%10;\\n            if(digits.find(d) != digits.end()){\\n                return true;\\n            }\\n            digits.insert(d);\\n            n = n/10;\\n        }\\n        \\n        return false;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1)return 10;\\n        \\n        n = pow(10,n);\\n        int countDuplicate = 0;\\n        for(int i=0; i<n; ++i){\\n            if(isDuplicate(i)){\\n                countDuplicate++;\\n            }\\n        }\\n        return ((n - countDuplicate));\\n    }\\n};\\n```\\n\\n**DP SOLUTION**\\n- Space :O(n)\\n```\\nclass Solution {\\npublic:\\n    int countNumberHelper(int n){\\n        int ans = 9;// first postion 9 choices always\\n        int choices = 9;// second position 9 choices always\\n\\n        for(int pos = 2; pos<=n; ++pos){\\n            ans = ans * choices;\\n            choices--;\\n        }\\n        \\n        return ans;\\n    }\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        int totalNumbersOfZeroChoices = 1;\\n        int totalNumbersOfTenChoices = 10;\\n        vector<int> computedNumbers(n+1, 0);\\n        \\n        // base case\\n        computedNumbers[0] = totalNumbersOfZeroChoices;\\n        computedNumbers[1] = totalNumbersOfTenChoices;\\n        \\n        for(int i=2; i<=n; ++i){\\n            computedNumbers[i] = computedNumbers[i-1] + countNumberHelper(i);\\n        } \\n        return computedNumbers[n];\\n    }\\n};\\n```\\n\\n**DP SOLUTION**\\n- Space: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumberHelper(int n){\\n        int ans = 9;// first postion 9 choices always\\n        int choices = 9;// second position 9 choices always\\n\\n        for(int pos = 2; pos<=n; ++pos){\\n            ans = ans * choices;\\n            choices--;\\n        }\\n        \\n        return ans;\\n    }\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        int totalNumbersOfZeroChoices = 1;\\n        int totalNumbersOfTenChoices = 10;\\n        \\n        // case for n==1\\n        int prevComputedNumbers = totalNumbersOfTenChoices; \\n        \\n        for(int i=2; i<=n; ++i){\\n            prevComputedNumbers = prevComputedNumbers + countNumberHelper(i);\\n        } \\n        \\n        return prevComputedNumbers;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isDuplicate(int n){\\n        unordered_set<int> digits;\\n        while(n>0){\\n            int d = n%10;\\n            if(digits.find(d) != digits.end()){\\n                return true;\\n            }\\n            digits.insert(d);\\n            n = n/10;\\n        }\\n        \\n        return false;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1)return 10;\\n        \\n        n = pow(10,n);\\n        int countDuplicate = 0;\\n        for(int i=0; i<n; ++i){\\n            if(isDuplicate(i)){\\n                countDuplicate++;\\n            }\\n        }\\n        return ((n - countDuplicate));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNumberHelper(int n){\\n        int ans = 9;// first postion 9 choices always\\n        int choices = 9;// second position 9 choices always\\n\\n        for(int pos = 2; pos<=n; ++pos){\\n            ans = ans * choices;\\n            choices--;\\n        }\\n        \\n        return ans;\\n    }\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        int totalNumbersOfZeroChoices = 1;\\n        int totalNumbersOfTenChoices = 10;\\n        vector<int> computedNumbers(n+1, 0);\\n        \\n        // base case\\n        computedNumbers[0] = totalNumbersOfZeroChoices;\\n        computedNumbers[1] = totalNumbersOfTenChoices;\\n        \\n        for(int i=2; i<=n; ++i){\\n            computedNumbers[i] = computedNumbers[i-1] + countNumberHelper(i);\\n        } \\n        return computedNumbers[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countNumberHelper(int n){\\n        int ans = 9;// first postion 9 choices always\\n        int choices = 9;// second position 9 choices always\\n\\n        for(int pos = 2; pos<=n; ++pos){\\n            ans = ans * choices;\\n            choices--;\\n        }\\n        \\n        return ans;\\n    }\\n   \\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        int totalNumbersOfZeroChoices = 1;\\n        int totalNumbersOfTenChoices = 10;\\n        \\n        // case for n==1\\n        int prevComputedNumbers = totalNumbersOfTenChoices; \\n        \\n        for(int i=2; i<=n; ++i){\\n            prevComputedNumbers = prevComputedNumbers + countNumberHelper(i);\\n        } \\n        \\n        return prevComputedNumbers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663543,
                "title": "cpp-mathematical-explanation",
                "content": "the trick is that suppose u need to from number of 4 digit with all being unique \\n\\n\\t1.   for the first digit u have 9 choices (1<=choice_1<=9) (0 is not included ,coz any 4 digit number starting with zero will be considered as 3 digit coz 0\\'s at front don\\'t add any value for example like [0345==345])\\n\\t\\n\\t2.   for the second digit u still have 9 choices (0<=choice_2<=9 and choice_2!=choice_1) ( except for the previously choosen digit all others can come and no ambiguity for 0 here coz [90!=9] as trailing zero\\'s before decimal is important)\\n\\n\\t3.   for the third digit u  have 8 choices (0<=choice_3<=9 and choice_3!=choice_1 and choice_3!=choice_2) ( except for the previously chosen digits all others can come )\\n\\n\\t4.   *similar explanation to 3rd now u have 7 choices*\\n\\nso in short all_unique _four digits_numbers(4)=9x9x8x7 \\n\\nbut in this question we need to tell numbers till n digits which means \\n```\\n\\ncountNumbersWithUniqueDigits(n) = all_unique _ digits_numbers(n) + all_unique _ digits_numbers(n-1) + all_unique _ digits_numbers(n-2) + ..........+  all_unique _ digits_numbers(1) +1\\n\\n```\\n+1 because our algo will never consider 0 at most significant digit but just 0 is a valid case so include that\\n\\nnow below is the code for general (n) digits num\\n\\n\\n\\n```\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        while(n){\\n            int t=(n--),start=9,nans=0;\\n            while(t--){\\n                if(nans==0)nans=9;\\n                else nans*=(start--);\\n            }\\n            ans+=nans;\\n        }\\n        \\n        return ans+1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n\\ncountNumbersWithUniqueDigits(n) = all_unique _ digits_numbers(n) + all_unique _ digits_numbers(n-1) + all_unique _ digits_numbers(n-2) + ..........+  all_unique _ digits_numbers(1) +1\\n\\n```\n```\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        while(n){\\n            int t=(n--),start=9,nans=0;\\n            while(t--){\\n                if(nans==0)nans=9;\\n                else nans*=(start--);\\n            }\\n            ans+=nans;\\n        }\\n        \\n        return ans+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527995,
                "title": "java-easy-with-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/ae18fb1b-f882-43a3-af38-e144e5957baf_1634559536.799327.png)\\n\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        \\n        if(n==1){\\n            return 10;\\n        }else{\\n            //calculating for n digit number\\n            int current=9;\\n            int temp=9;\\n            for(int i=1;i<n;i++){\\n                current*=temp;\\n                temp--;\\n            }\\n            return current+countNumbersWithUniqueDigits(n-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        \\n        if(n==1){\\n            return 10;\\n        }else{\\n            //calculating for n digit number\\n            int current=9;\\n            int temp=9;\\n            for(int i=1;i<n;i++){\\n                current*=temp;\\n                temp--;\\n            }\\n            return current+countNumbersWithUniqueDigits(n-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401825,
                "title": "scala-one-liner-100",
                "content": "```\\nobject Solution {\\n    def countNumbersWithUniqueDigits(d: Int): Int = {\\n        if (d==0) return 1\\n        1.to(d-1).map(10 - _).scanLeft(9)(_ * _).reduce(_ + _) + 1\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def countNumbersWithUniqueDigits(d: Int): Int = {\\n        if (d==0) return 1\\n        1.to(d-1).map(10 - _).scanLeft(9)(_ * _).reduce(_ + _) + 1\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1392244,
                "title": "0-ms-100-faster-solution",
                "content": "* if (n>10) it is impossible to have all digits unique\\n* f(1) =10 ,i.e, all numbers from 0 to 9\\n* f(2) =f(1) + 9*9 (as first digit can be anything between 1 and 9, 2nd digit anything between 0 and 9 except first digit)\\n* f(3)= f(2) +9*(9)*8 (as first digit can be anything between 1 and 9, 2nd digit anything between 0 and 9 except first digit, 3rd digit anything between 0 and 9 except 1st and 2nd digit)\\n* therfeore f(n)=f(n-1)+9*(9*8*....(10-i+1))\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n>10)\\n            return 0;\\n        int dp[11],x=9;\\n        dp[0]=1;dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            x*=(10-i+1);\\n            dp[i]=dp[i-1]+x;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n>10)\\n            return 0;\\n        int dp[11],x=9;\\n        dp[0]=1;dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            x*=(10-i+1);\\n            dp[i]=dp[i-1]+x;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343206,
                "title": "faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        //9 * 9 + 10 for n = 2\\n        //9 * 9 * 8 + 10 for n = 3\\n        //9 * 9 * 8 * 7 + 10 for n = 4\\n        //9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n        \\n        int ans = 10;\\n        if(n == 0){\\n            return 1;\\n        }else if(n == 1){\\n            return 10;\\n        }else{\\n            int product = 9;\\n            for(int i = 2; i <= n; i++){\\n                product = product * (11 - i);\\n                ans += product;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        //9 * 9 + 10 for n = 2\\n        //9 * 9 * 8 + 10 for n = 3\\n        //9 * 9 * 8 * 7 + 10 for n = 4\\n        //9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n        \\n        int ans = 10;\\n        if(n == 0){\\n            return 1;\\n        }else if(n == 1){\\n            return 10;\\n        }else{\\n            int product = 9;\\n            for(int i = 2; i <= n; i++){\\n                product = product * (11 - i);\\n                ans += product;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324440,
                "title": "for-better-visualization-i-made-all-the-cases",
                "content": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 10;\\n        }\\n        if(n==2){\\n            return 91;\\n        }\\n        if(n==3){\\n            return 9*9*8 + 91;\\n        }\\n        if(n==4){\\n            return 9*9*8*7 + 9*9*8 + 91;\\n        }\\n        if(n==5){\\n            return 9*9*8*7*6 + 9*9*8*7 + 9*9*8 + 91;\\n        }\\n        if(n==6){\\n            return 9*9*8*7*6*5+ 9*9*8*7*6 + 9*9*8*7 + 9*9*8 + 91;            \\n        }\\n        if(n==7){\\n            return 9*9*8*7*6*5*4 + 9*9*8*7*6*5+ 9*9*8*7*6 + 9*9*8*7 + 9*9*8 + 91;               \\n        }\\n        if(n==8){\\n            return 9*9*8*7*6*5*4*3 + 9*9*8*7*6*5*4 + 9*9*8*7*6*5+ 9*9*8*7*6 + 9*9*8*7 + 9*9*8 + 91;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1102403,
                "title": "java-easy-to-understand-solution-with-comments",
                "content": "I Was having tough time to understand any solution, after spending lot of time I got to know about the soultion.\\nHear is my approach:\\n\\n```\\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        if (n > 10) return countNumbersWithUniqueDigits(10);\\n//        Now calculate the possible ways a number can be formed with n digits.\\n        int poss = 9, count = 1;\\n        for (int digit = 0; digit < n; digit++) {\\n//            You start with 9 possibilities (0 cannot be placed, because 01 is not a number with 2 digit it is number with 1 digit),\\n//              After get the number of possibilities you can place a number, you need to keep reducing a possibility,\\n//              because the number that was used in in current position should not be used again.\\n            if (digit == 0) count *= 9;\\n            else count *= poss--;\\n//            Other key thing to consider, is that first digit and second digit can have 9, possibilities.\\n//              Because 0 is not a valid number for first digit,\\n//              But 0 is a valid number for all digits after 1 to n.\\n        }\\n        System.out.println(\"Count at \" + n + \" digits is : \" + count);\\n//        Now, count will have the number of ways to form n digit, add that to number of ways we can form an (n-1)  digit.\\n        return count + countNumbersWithUniqueDigits(n - 1);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        if (n > 10) return countNumbersWithUniqueDigits(10);\\n//        Now calculate the possible ways a number can be formed with n digits.\\n        int poss = 9, count = 1;\\n        for (int digit = 0; digit < n; digit++) {\\n//            You start with 9 possibilities (0 cannot be placed, because 01 is not a number with 2 digit it is number with 1 digit),\\n//              After get the number of possibilities you can place a number, you need to keep reducing a possibility,\\n//              because the number that was used in in current position should not be used again.\\n            if (digit == 0) count *= 9;\\n            else count *= poss--;\\n//            Other key thing to consider, is that first digit and second digit can have 9, possibilities.\\n//              Because 0 is not a valid number for first digit,\\n//              But 0 is a valid number for all digits after 1 to n.\\n        }\\n        System.out.println(\"Count at \" + n + \" digits is : \" + count);\\n//        Now, count will have the number of ways to form n digit, add that to number of ways we can form an (n-1)  digit.\\n        return count + countNumbersWithUniqueDigits(n - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063446,
                "title": "basic-maths-solution-o-1-space-and-time",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        \\n        # Use basic permutation\\n        # for 0 <= x < 10 : Nos. with unique digits = 9\\n        # for 10 <= x < 100 : Nos. with unique digits = 9 x 9\\n        # for 100 <= x < 1000 : Nos. with unique digits = 9 x 9 x 8\\n        # for 1000 <= x < 10000 : Nos. with unique digits = 9 x 9 x 8 x 7\\n        # for 10000 <= x < 100000 : Nos. with unique digits = 9 x 9 x 8 x 7 x 6\\n        # for 100000 <= x < 1000000 : Nos. with unique digits = 9 x 9 x 8 x 7 x 6 x 5\\n        \\n        # And so on ...\\n        # Then add all the values and make the following dictionary\\n\\t\\t\\n\\t\\t# While calculating 0 <= x < 10 the case of n = 0 is already covered in it so no need to add n = 0 when adding all other values\\n            \\n        dic = {\\n            0 : 1,\\n            1 : 10,\\n            2 : 91,\\n            3 : 739,\\n            4 : 5275,\\n            5 : 32491,\\n            6 : 168571,\\n            7 : 712891,\\n            8 : 2345851\\n        }\\n        \\n        return dic[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        \\n        # Use basic permutation\\n        # for 0 <= x < 10 : Nos. with unique digits = 9\\n        # for 10 <= x < 100 : Nos. with unique digits = 9 x 9\\n        # for 100 <= x < 1000 : Nos. with unique digits = 9 x 9 x 8\\n        # for 1000 <= x < 10000 : Nos. with unique digits = 9 x 9 x 8 x 7\\n        # for 10000 <= x < 100000 : Nos. with unique digits = 9 x 9 x 8 x 7 x 6\\n        # for 100000 <= x < 1000000 : Nos. with unique digits = 9 x 9 x 8 x 7 x 6 x 5\\n        \\n        # And so on ...\\n        # Then add all the values and make the following dictionary\\n\\t\\t\\n\\t\\t# While calculating 0 <= x < 10 the case of n = 0 is already covered in it so no need to add n = 0 when adding all other values\\n            \\n        dic = {\\n            0 : 1,\\n            1 : 10,\\n            2 : 91,\\n            3 : 739,\\n            4 : 5275,\\n            5 : 32491,\\n            6 : 168571,\\n            7 : 712891,\\n            8 : 2345851\\n        }\\n        \\n        return dic[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995001,
                "title": "100-faster-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    //its a permutation problem we all solved in our schools\\n    //here we need all the unique digit number \\n    // the idea is to store the unique digit numbers for that size of digits\\n    // the first digit of a say 3 digit number can not be 0\\n    // so for filling first didgit of three digit number we havve 9 options\\n    //for the second digit also we have 9 options to fill it as 0 is now included\\n    // for the third digit we have only 8 options to fill as we can not use same digit twice\\n    int dp[];\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n>9) n=8;\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        dp= new int[n+1];\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            int prod=1;\\n            int counter=9;\\n            for(int j=i;j>1;j--){\\n                prod = prod*counter;\\n                counter--;\\n            }\\n            prod= 9*prod;\\n            dp[i]=dp[i-1]+prod;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //its a permutation problem we all solved in our schools\\n    //here we need all the unique digit number \\n    // the idea is to store the unique digit numbers for that size of digits\\n    // the first digit of a say 3 digit number can not be 0\\n    // so for filling first didgit of three digit number we havve 9 options\\n    //for the second digit also we have 9 options to fill it as 0 is now included\\n    // for the third digit we have only 8 options to fill as we can not use same digit twice\\n    int dp[];\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n>9) n=8;\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        dp= new int[n+1];\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            int prod=1;\\n            int counter=9;\\n            for(int j=i;j>1;j--){\\n                prod = prod*counter;\\n                counter--;\\n            }\\n            prod= 9*prod;\\n            dp[i]=dp[i-1]+prod;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658564,
                "title": "most-detailed-explanation-c-100-time-space",
                "content": "**Problem Solution Approach**\\n \\n*  If number of digits is 0, then unique numbers that can be formed is 0\\n*  If number of digits is 1, then unique numbers that can be formed is 10 ->  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\n*  If number of digits is 2,\\n   Then for the first digit (from left), we have 9 choices (excluding 0) [1 to 9]\\n   And for second digit we have 9 choices (0 to 10 except the previous digit) \\n   So basically, the number is:\\n   ij where i=[1,9] and j=[0,9]and i\\u2260j\\n   So, total number possible are 9*9=81\\n*  If number of digits is 3,\\n   Then for first digit (from left), we have 9 choices (excluding 0) [1 to 9]\\n   And for second digit we have 9 choices (0 to 10 except the previous digit)\\n  And for third digit we have 8 choices (0 to 10 except the previous two digits)\\n  So basically, the number is:\\n  ijk where i=[1,9] and j,k=[0,9]and i\\u2260j & j\\u2260k,i\\n  So, total number possible are 9*9*8=648\\n* So, if number of digits is i, then the ith digit will have (10-i+1) choices\\n\\n**Implementation**\\n```\\nint countNumbersWithUniqueDigits(int n)\\n{\\n    //base cases\\n    if (n == 0)\\n        return 0;\\n    if (n == 1)\\n        return 10;\\n    if (n == 2)\\n        return 91;\\n\\n    //base value\\n    long long int DP[n + 1];\\n    DP[0] = 0;\\n    DP[1] = 10;\\n    DP[2] = 81;\\n    long long int res = 91;\\n\\n    for (int i = 3; i <= n; i++) {\\n        //compute f(i)\\n        DP[i] = DP[i - 1] * (10 - i + 1);\\n        res += DP[i]; //add f(i)\\n    }\\n    //result\\n    return res;\\n}\\n```\\n[References]\\n(https://www.includehelp.com/icp/count-numbers-with-unique-digits.aspx)",
                "solutionTags": [],
                "code": "```\\nint countNumbersWithUniqueDigits(int n)\\n{\\n    //base cases\\n    if (n == 0)\\n        return 0;\\n    if (n == 1)\\n        return 10;\\n    if (n == 2)\\n        return 91;\\n\\n    //base value\\n    long long int DP[n + 1];\\n    DP[0] = 0;\\n    DP[1] = 10;\\n    DP[2] = 81;\\n    long long int res = 91;\\n\\n    for (int i = 3; i <= n; i++) {\\n        //compute f(i)\\n        DP[i] = DP[i - 1] * (10 - i + 1);\\n        res += DP[i]; //add f(i)\\n    }\\n    //result\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616503,
                "title": "javascript-easy-understand-dynamic-programming-solution",
                "content": "```js\\n/*\\n * @lc app=leetcode id=357 lang=javascript\\n *\\n * [357] Count Numbers with Unique Digits\\n */\\n\\n// @lc code=start\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countNumbersWithUniqueDigits = function(n) {\\n    var dp = [1, 10];\\n    var sum = [1, 11];\\n    for (var i = 2; i <= n; i++) {\\n        dp[i] = sum[i - 1] + (10 - i) * (dp[i - 1]);\\n        sum[i] = sum[i - 1] + dp[i];\\n    }\\n    return dp[n];\\n};\\n// @lc code=end\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```js\\n/*\\n * @lc app=leetcode id=357 lang=javascript\\n *\\n * [357] Count Numbers with Unique Digits\\n */\\n\\n// @lc code=start\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countNumbersWithUniqueDigits = function(n) {\\n    var dp = [1, 10];\\n    var sum = [1, 11];\\n    for (var i = 2; i <= n; i++) {\\n        dp[i] = sum[i - 1] + (10 - i) * (dp[i - 1]);\\n        sum[i] = sum[i - 1] + dp[i];\\n    }\\n    return dp[n];\\n};\\n// @lc code=end\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612428,
                "title": "c-o-1",
                "content": "There is one thing we should know, since the integer has unique digits, so, the number has at most **10 digits**, so n is at most 10, so, the running time of algorithm is O(1).\\n```\\nclass Solution {\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if(n == 0)\\n            return 1;\\n\\t\\t\\t\\n        int res = 10, tmp = 9;\\n        for(int i = 1; i < n; i++)\\n            res += (tmp *= (10 - i));\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if(n == 0)\\n            return 1;\\n\\t\\t\\t\\n        int res = 10, tmp = 9;\\n        for(int i = 1; i < n; i++)\\n            res += (tmp *= (10 - i));\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281367,
                "title": "java-o-1-clean-solution-beat-100",
                "content": "\\n\\'\\'\\'\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n\\t  \\n        if (n == 0) return 1;\\n\\t\\t\\n        int uniqueDigits = 9;\\n        int res = 10;\\n        int digitNumber = 1;\\n        \\n        while(digitNumber<n){\\n            uniqueDigits = uniqueDigits*(10-digitNumber);\\n            res += uniqueDigits;\\n            digitNumber++;\\n        }\\n        return res;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n\\t  \\n        if (n == 0) return 1;\\n\\t\\t\\n        int uniqueDigits = 9;\\n        int res = 10;\\n        int digitNumber = 1;\\n        \\n        while(digitNumber<n){\\n            uniqueDigits = uniqueDigits*(10-digitNumber);\\n            res += uniqueDigits;\\n            digitNumber++;\\n        }\\n        return res;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 262907,
                "title": "java-iterative-solution",
                "content": "```java\\nclass Solution {\\n    \\n    // Let F(n) be count of numbers with unique digits such that 0 <= x < 10^n\\n    \\n    // n = 0\\n    // numbers = 0\\n    // F(n) = 1\\n    \\n    // n = 1\\n    // numbers = 0 1 2 ... 9\\n    // F(n) = 10\\n    \\n    // n = 2, \\n    // numbers = 0 1 2 ..9 ... 98\\n    // For each of the number other than 0 from n = 1, we append a differnt number, also add number from n = 2\\n    // F(n) = F(n-1) + 9 * 9\\n    \\n    // n = 3\\n    // F(n) = F(n-1) + 9 * 9 * 8\\n    \\n    // n = 4\\n    // F(n) = F(n-1) + 9*9*8*...*(10-n + 1)\\n    \\n    \\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        \\n        if (n == 1) {\\n            return 10;\\n        }\\n        \\n        if (n > 10) {\\n            n = 10;\\n        }\\n        int answer = 10;\\n        int product = 9;\\n        for (int i = 2; i <= n; i++) {\\n            product = product * (10 - i + 1);\\n            answer = answer + product;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    // Let F(n) be count of numbers with unique digits such that 0 <= x < 10^n\\n    \\n    // n = 0\\n    // numbers = 0\\n    // F(n) = 1\\n    \\n    // n = 1\\n    // numbers = 0 1 2 ... 9\\n    // F(n) = 10\\n    \\n    // n = 2, \\n    // numbers = 0 1 2 ..9 ... 98\\n    // For each of the number other than 0 from n = 1, we append a differnt number, also add number from n = 2\\n    // F(n) = F(n-1) + 9 * 9\\n    \\n    // n = 3\\n    // F(n) = F(n-1) + 9 * 9 * 8\\n    \\n    // n = 4\\n    // F(n) = F(n-1) + 9*9*8*...*(10-n + 1)\\n    \\n    \\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        \\n        if (n == 1) {\\n            return 10;\\n        }\\n        \\n        if (n > 10) {\\n            n = 10;\\n        }\\n        int answer = 10;\\n        int product = 9;\\n        for (int i = 2; i <= n; i++) {\\n            product = product * (10 - i + 1);\\n            answer = answer + product;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190630,
                "title": "why-my-solution-is-not-the-fastest",
                "content": "as we can know, when the lengthen of an integer is larger than 10, the num must have at least two locations who have the same digit,so the total posibilities is  finite,then we can list all the posibilitise in a list,while the list is:\n[1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\nif the n is larger than 10,then we only return the last element in the list;\nelse get the corresponding element.\nthe time complexity is o(1), very very small,but why this solution takes 32 ms ,too slow.\n```\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        results = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\n        if n >= 11:\n            return results[-1]\n        return results[n]\n\n```\n",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        results = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691]\n        if n >= 11:\n            return results[-1]\n        return results[n]\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 83067,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Count Numbers with Unique Digits** https://leetcode.com/problems/count-numbers-with-unique-digits/?tab=Description\\n\\n**Brute Force**\\n* Brute force will be to generate each number and test whether it has unique digits or not.\\n* Boundary Condition: What happens when n is more than 10? Unique numbers are limited to the case of n = 10.\\n* Split the problem in this view. Say N = 4. 0<=x<=9999. \\n* This means that: [0, 1 to 9, 10 to 99, 100 to 999, 1000 to 9999].\\n* Now implement backtracking for each of these ranges and keep adding to count.\\n```\\nclass Solution(object):\\n    def helper(self, i, dedup, n):\\n        if i == n:\\n            return 1\\n        else:\\n            count = 0\\n            start = 1 if i == 0 else 0\\n            for x in range(start,10):\\n                if x not in dedup:\\n                    dedup.add(x)\\n                    count = count + self.helper(i+1, dedup, n)\\n                    dedup.remove(x)\\n        return count\\n    \\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for j in range(0, n+1):\\n            count = count + self.helper(0, set([]), j)\\n        return count\\n```\\n\\n**Dynamic Programming**\\n* Next you can improve backtracking by dynamic programming. Assume you want to know all unique digit numbers from 100 to 999. First place can take 9 (1 to 9). Second place can take 9 (0 to 9 but not what we took in first place). Last place can take only 8.\\nhttps://goo.gl/photos/oLz3dmPimXBgWWsDA\\n\\nExample: n=4\\n* n = 1  temp = 9\\n* n = 2  temp = 9 * 9\\n* n=3 temp = 9 * 9 * 8\\n* n=4 temp = 9 * 9 * 8 * 7\\n\\n```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        soln, temp, factor = 1, 1, 9\\n        for i in range(n):\\n            temp = temp * factor\\n            soln = soln + temp\\n            factor = factor-1 if i!=0 else factor\\n        return soln\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, i, dedup, n):\\n        if i == n:\\n            return 1\\n        else:\\n            count = 0\\n            start = 1 if i == 0 else 0\\n            for x in range(start,10):\\n                if x not in dedup:\\n                    dedup.add(x)\\n                    count = count + self.helper(i+1, dedup, n)\\n                    dedup.remove(x)\\n        return count\\n    \\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for j in range(0, n+1):\\n            count = count + self.helper(0, set([]), j)\\n        return count\\n```\n```\\nclass Solution(object):\\n    def countNumbersWithUniqueDigits(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        soln, temp, factor = 1, 1, 9\\n        for i in range(n):\\n            temp = temp * factor\\n            soln = soln + temp\\n            factor = factor-1 if i!=0 else factor\\n        return soln\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83108,
                "title": "super-short-simple-c-0ms-solution",
                "content": "```\\nint countNumbersWithUniqueDigits(int n)\\n{\\n  if (n<1) return 1;\\n  // For single digit, we have 10 numbers with unique digits\\n  int totalUnique = 10;\\n  //After first digit, the choice for first digit is only 9 digits,\\n  int prevMultiplier = 9;\\n  for (int i = 1; i < n; i++)\\n  {\\n    prevMultiplier *= (10-i);\\n    totalUnique += prevMultiplier;\\n  }\\n  return totalUnique;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countNumbersWithUniqueDigits(int n)\\n{\\n  if (n<1) return 1;\\n  // For single digit, we have 10 numbers with unique digits\\n  int totalUnique = 10;\\n  //After first digit, the choice for first digit is only 9 digits,\\n  int prevMultiplier = 9;\\n  for (int i = 1; i < n; i++)\\n  {\\n    prevMultiplier *= (10-i);\\n    totalUnique += prevMultiplier;\\n  }\\n  return totalUnique;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 83139,
                "title": "my-simple-c-math-solution-nothing-fancy",
                "content": "    class Solution {\\n    public:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1)return 10;\\n        if(n==2)return 91;\\n        \\n        int base=81, count=91;\\n        for(int i=3; i <=min(10,n); i++){\\n            base=base * (10-i+1);\\n            count+=base;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1)return 10;\\n        if(n==2)return 91;\\n        \\n        int base=81, count=91;\\n        for(int i=3; i <=min(10,n); i++){\\n            base=base * (10-i+1);\\n            count+=base;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 83159,
                "title": "dp-python-solution",
                "content": "    def countNumbersWithUniqueDigits(self, n):\\n        if not n:\\n            return 1\\n        dp = [0]*(n)\\n        dp[0] = 9\\n        for i in range(1,n):\\n            dp[i] = dp[i-1]*(10-i)\\n        return sum(dp)+1\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def countNumbersWithUniqueDigits(self, n):\\n        if not n:\\n            return 1\\n        dp = [0]*(n)\\n        dp[0] = 9\\n        for i in range(1,n):\\n            dp[i] = dp[i-1]*(10-i)\\n        return sum(dp)+1\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 83176,
                "title": "java-concise-dp-solution",
                "content": "        \\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        } \\n        int ret = 10, count = 9;\\n        for (int i = 2; i <= n; i++) {\\n            count *= 9-i+2;\\n            ret += count;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "        \\n    public int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        } \\n        int ret = 10, count = 9;\\n        for (int i = 2; i <= n; i++) {\\n            count *= 9-i+2;\\n            ret += count;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 83179,
                "title": "dp-solution-using-hint",
                "content": "\\n    class Solution {\\n    public:\\n    \\tint countNumbersWithUniqueDigits(int n) {\\n    \\t\\tvector<int> f(11, 0);\\n    \\t\\tfor (int k = 1; k <= 10; ++k) {\\n    \\t\\t\\tif (k == 1)\\n    \\t\\t\\t\\tf[k] = 10;\\n    \\t\\t\\telse if (k == 2)\\n    \\t\\t\\t\\tf[k] = 9 * 9;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tf[k] = f[k - 1] * (9 - k + 2);\\n    \\t\\t}\\n    \\t\\tvector<int> s(11, 0);\\n    \\t\\tfor (int j = 1; j < 11; ++j)\\n    \\t\\t\\ts[j] = s[j - 1] + f[j];\\n    \\t\\tif (n <= 0) return 1;\\n    \\t\\tif (n >= 1 && n <= 10) return s[n];\\n    \\t\\treturn s[10];\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    \\tint countNumbersWithUniqueDigits(int n) {\\n    \\t\\tvector<int> f(11, 0);\\n    \\t\\tfor (int k = 1; k <= 10; ++k) {\\n    \\t\\t\\tif (k == 1)\\n    \\t\\t\\t\\tf[k] = 10;\\n    \\t\\t\\telse if (k == 2)\\n    \\t\\t\\t\\tf[k] = 9 * 9;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tf[k] = f[k - 1] * (9 - k + 2);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4014692,
                "title": "0ms-maths-rust-solution",
                "content": "# Expression\\nLet $f:\\\\mathbb{N}\\\\rightarrow\\\\mathbb{N}$, where $n\\\\in\\\\mathbb{N}$ $f(n)$ gives the count of the number with unique digits less than equals to $10^n$. Expression for $f(n)$ is,\\n\\n$$\\\\displaystyle f(n):=1+9\\\\sum_{k=1}^{\\\\min\\\\{n,9\\\\}}\\\\frac{9!}{(10-k)!}$$\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_numbers_with_unique_digits(n: i32) -> i32 {\\n        let mut fact: [i32; 10] = [1; 10];\\n\\n        for i in 0..9 {\\n            fact[i+1] = ((i+1) as i32) * fact[i];\\n        }\\n\\n        let mut total: i32 = 1;\\n\\n        for k in 1..=n {\\n            total += 9 * fact[9] / fact[(10-k) as usize];\\n        }\\n\\n        total\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_numbers_with_unique_digits(n: i32) -> i32 {\\n        let mut fact: [i32; 10] = [1; 10];\\n\\n        for i in 0..9 {\\n            fact[i+1] = ((i+1) as i32) * fact[i];\\n        }\\n\\n        let mut total: i32 = 1;\\n\\n        for k in 1..=n {\\n            total += 9 * fact[9] / fact[(10-k) as usize];\\n        }\\n\\n        total\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985886,
                "title": "python-backtracking-slow-but-mine",
                "content": "\\n\\n# Approach\\nUse backtracking and search for all possible results and increment count whenever we find the legal number.\\nTip : look out for numbers involving 0\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        self.count = 0\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return 10\\n        \\n        searchSpace = [0,1,2,3,4,5,6,7,8,9]\\n\\n        def backTrack(path):\\n            if len(path) <= n:\\n                if path:\\n                    if path[0] != 0:\\n                        self.count += 1\\n            else:\\n                return\\n            for num in searchSpace:\\n                if num not in path:\\n                    path.append(num)\\n                    backTrack(path)\\n                    path.pop()\\n\\n        backTrack([])\\n        return self.count + 1\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        self.count = 0\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return 10\\n        \\n        searchSpace = [0,1,2,3,4,5,6,7,8,9]\\n\\n        def backTrack(path):\\n            if len(path) <= n:\\n                if path:\\n                    if path[0] != 0:\\n                        self.count += 1\\n            else:\\n                return\\n            for num in searchSpace:\\n                if num not in path:\\n                    path.append(num)\\n                    backTrack(path)\\n                    path.pop()\\n\\n        backTrack([])\\n        return self.count + 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362293,
                "title": "simple-using-permutation-mathematics-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int count=10;\\n        for(int i=2 ;i<=n ;i++){\\n           int ch=i-1;\\n           int y=9;\\n           int u=9;\\n           while(ch>0){\\n               y=y*u;\\n               ch--;\\n               u--;\\n           }\\n           count+=y;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int count=10;\\n        for(int i=2 ;i<=n ;i++){\\n           int ch=i-1;\\n           int y=9;\\n           int u=9;\\n           while(ch>0){\\n               y=y*u;\\n               ch--;\\n               u--;\\n           }\\n           count+=y;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266788,
                "title": "100-faster-then-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n == 0)\\n           return 1;\\n\\n        int ans= 10;\\n        int start = 9;\\n        int current = 9;\\n\\n        for(int i = 2;i<=n;i++){\\n            current *= (start--);\\n            ans += current;\\n        }   \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n == 0)\\n           return 1;\\n\\n        int ans= 10;\\n        int start = 9;\\n        int current = 9;\\n\\n        for(int i = 2;i<=n;i++){\\n            current *= (start--);\\n            ans += current;\\n        }   \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201128,
                "title": "solution-with-dynamic-programming-t-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n\\n        dp[0] = 1;\\n        dp[1] = 10;\\n\\n        int i = 9;\\n        int prod = 9;\\n\\n        for(int x = 2;x<=n;x++){\\n            prod *=i;\\n            dp[x] = dp[x-1]+prod;\\n            i--;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0){\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n\\n        dp[0] = 1;\\n        dp[1] = 10;\\n\\n        int i = 9;\\n        int prod = 9;\\n\\n        for(int x = 2;x<=n;x++){\\n            prod *=i;\\n            dp[x] = dp[x-1]+prod;\\n            i--;\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165079,
                "title": "simple-for-loop-with-step-by-step-explanation",
                "content": "for i=0 as 10^0 = 1 -> for 1 it has 1 number\\nfor i=1 -> 10 it has 9+1 numbers\\nfor i=2 -> 100 has (9 * 9) + 9 + 1 numbers\\nfor i=3 -> 1000 has (9 * 9 * 8) + (9 * 9) + 9 + 1 numbers\\n```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n       \\n        if(n == 0)\\n            return 1;\\n        \\n        int count = 9;\\n        int ans = 9;\\n        \\n        int prev = ans;\\n        \\n        for(int i = 2; i <= n; i++){\\n            ans += prev*count;  // prev = 9*9 * count = 8\\n            prev = prev*count;\\n            count--;\\n        } \\n        \\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n       \\n        if(n == 0)\\n            return 1;\\n        \\n        int count = 9;\\n        int ans = 9;\\n        \\n        int prev = ans;\\n        \\n        for(int i = 2; i <= n; i++){\\n            ans += prev*count;  // prev = 9*9 * count = 8\\n            prev = prev*count;\\n            count--;\\n        } \\n        \\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030269,
                "title": "python-solution-easy-to-understand-no-backtracking-dp-permutation-and-combinations",
                "content": "* how many numbers will be there if n==1 that is 10 (0-9)\\n* how many numbers will be there if n==2 that is 81 but we need all numbers from 0 so that are previous result + current i.e. 81+10 = 91\\n* Now suppose we are forming a 5 digit number using permutation we have numbers from 0 to 9 to fill the place and the point to remember is we can\\'t have a duplicate entry i.e. each number can be used at most 1 time.\\n* since we can\\'t use digit 0 as first digit we have 9 entries to fill up for the first position. i.e. (1 to 9)\\n* now we have to fill the second digit which can be filled up with any digit between 0 to 9 except the number \\nwhich we\\'ve filled at first place. we have 9 entries to do the job.\\n* for third place we have 8 entries, for fourth place we have 7 and for fifth place we have 6 entries and so on.\\n* Total 5 digit number which have unique digits are:- 9\\\\*9\\\\*8\\\\*7\\\\*6.\\n* Now use the concept and built an algorithm :-)\\n\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = 0\\n        if n == 0:\\n            return 1\\n        if n>=1:\\n            ans += 10\\n        while n>1:\\n            c = 9\\n            built = c\\n            for i in range(n-1):\\n                built *= c\\n                c -= 1\\n            ans += built\\n            n -= 1\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = 0\\n        if n == 0:\\n            return 1\\n        if n>=1:\\n            ans += 10\\n        while n>1:\\n            c = 9\\n            built = c\\n            for i in range(n-1):\\n                built *= c\\n                c -= 1\\n            ans += built\\n            n -= 1\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755817,
                "title": "javascript-solution-with-recursion",
                "content": "```\\nconst countNumbersWithUniqueDigits = function (n) {\\n  if (n == 0) return 1;\\n  if (n == 1) return 10;\\n  let k = 9;\\n  for (let i = 0; i < n - 1; i++) {\\n    k *= (9 - i);\\n  }\\n  return k + countNumbersWithUniqueDigits(n - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nconst countNumbersWithUniqueDigits = function (n) {\\n  if (n == 0) return 1;\\n  if (n == 1) return 10;\\n  let k = 9;\\n  for (let i = 0; i < n - 1; i++) {\\n    k *= (9 - i);\\n  }\\n  return k + countNumbersWithUniqueDigits(n - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2752980,
                "title": "c-recursion-observation-based-math-problem-full-explanation",
                "content": "```\\n/*\\nThis problem is completely based on combinatorics.\\nFor n=1, the ans is clearly all one digit no.s.\\nFor n=2, we have 9 options (exclude 0) for the first place and another 9 options for the second.\\nSo, for n=2 -> ans(1) + 9*9.\\nFor n=3, we have 9 options (exclude 0) for the place and another 9 and 8 options for the second and third place respectively.\\nSo, for n=3 -> ans(2) + 9*9*8.\\nTherefore, it goes like ans(n-1) + 9*9*8*...*(9-n+2) which can be convert by the property \\nof factorial into further simplified expression.\\n*/\\nint f(int n) {  //Calculates factorial\\n        if(n<=1) return 1;\\n        else return n*f(n-1);\\n    }\\n    int call(int n) {\\n        if(n==0) return 1;\\n        else return (call(n-1) + (9* (f(9)/f(10-n))));\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return call(n);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\n/*\\nThis problem is completely based on combinatorics.\\nFor n=1, the ans is clearly all one digit no.s.\\nFor n=2, we have 9 options (exclude 0) for the first place and another 9 options for the second.\\nSo, for n=2 -> ans(1) + 9*9.\\nFor n=3, we have 9 options (exclude 0) for the place and another 9 and 8 options for the second and third place respectively.\\nSo, for n=3 -> ans(2) + 9*9*8.\\nTherefore, it goes like ans(n-1) + 9*9*8*...*(9-n+2) which can be convert by the property \\nof factorial into further simplified expression.\\n*/\\nint f(int n) {  //Calculates factorial\\n        if(n<=1) return 1;\\n        else return n*f(n-1);\\n    }\\n    int call(int n) {\\n        if(n==0) return 1;\\n        else return (call(n-1) + (9* (f(9)/f(10-n))));\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return call(n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2730443,
                "title": "my-java-solution-recursion-bottom-up-approach-beats-100-in-tc-readable-clean-code",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0) return 1;\\n        if(n == 1) return 10;\\n        \\n        int curr = 1, k = 8;\\n        for(int i = 1; i <= n; ++i) {\\n            if(i <= 2) {\\n                curr = curr * 9;\\n            }\\n            else {\\n                curr = curr * (k--);\\n            }\\n        }\\n\\n        return curr + countNumbersWithUniqueDigits(n - 1);\\n    }\\n}\\n```\\n\\n```\\nPlease up vote if you find my code helpful.\\nThanks \\uD83D\\uDC4D\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0) return 1;\\n        if(n == 1) return 10;\\n        \\n        int curr = 1, k = 8;\\n        for(int i = 1; i <= n; ++i) {\\n            if(i <= 2) {\\n                curr = curr * 9;\\n            }\\n            else {\\n                curr = curr * (k--);\\n            }\\n        }\\n\\n        return curr + countNumbersWithUniqueDigits(n - 1);\\n    }\\n}\\n```\n```\\nPlease up vote if you find my code helpful.\\nThanks \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546571,
                "title": "cpp-solution-using-maths-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n == 0) return 1;\\n        int ans = 10;\\n        int start = 9;\\n        int cur = 9;\\n        while(n-->1 and start){\\n            cur = cur * (start--);\\n            ans += cur;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n/*\\n\\nLet\\'s take exp : n = 3;\\n\\nNow for n = 0 ans would be 1 same , for n = 1 ans would be 10 How ?\\nfor n = 1 we need to check from 0 to n so it will be 10 now\\n\\nfor n = 2 there are two place _ _ , in first we have choice [1,9] and for second we have choice from [0,9] - {first choice} for 2 digits ubique number would be 9*9 and we know for n = 1 we have 10 so in totale we have 91 unique numbers.\\n\\nfor n=3 , we have _ _ _ place and in first place we have choice [1,9] means 9 for second we have 9 choice and for 3 we have 8 choice so it will be 9*9*8 , in total 1 + 9 + 9*9 + 9*9*8.\\n\\n*/",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n == 0) return 1;\\n        int ans = 10;\\n        int start = 9;\\n        int cur = 9;\\n        while(n-->1 and start){\\n            cur = cur * (start--);\\n            ans += cur;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541777,
                "title": "5-line-code",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if(n==0):\\n            return 1\\n        s,st=10,9\\n        for i in range(0,n-1):\\n            st*=9-i\\n            s+=st\\n        return(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if(n==0):\\n            return 1\\n        s,st=10,9\\n        for i in range(0,n-1):\\n            st*=9-i\\n            s+=st\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452906,
                "title": "python-simple-recursive-solution",
                "content": "```\\ndef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\n        def solve(n):\\n            if n == 0: return 1\\n            if n == 1: return 9\\n            if n == 2: return 81\\n            \\n            return (10 - n + 1) * solve(n - 1)\\n \\n        ans = 0 \\n        for i in range(n + 1):\\n            ans += solve(i)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\n        def solve(n):\\n            if n == 0: return 1\\n            if n == 1: return 9\\n            if n == 2: return 81\\n            \\n            return (10 - n + 1) * solve(n - 1)\\n \\n        ans = 0 \\n        for i in range(n + 1):\\n            ans += solve(i)\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2424195,
                "title": "c-linear-time-solution-tabulation-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n     \\n          vector<long long int>dp(n+1);\\n          if(n==0)\\n          {\\n              return 1;\\n          }\\n          if(n==1)\\n          {\\n              return 1+9;   \\n          }\\n          dp[0]=1;\\n          dp[1]=dp[0]+9;\\n        \\n          int val=9;\\n          int counter=9;\\n        \\n          for(int i=2;i<=n;i++)\\n          {\\n              dp[i]=(dp[i-1]+0LL+(val*counter));\\n              val=val*counter;\\n              counter--;\\n          }\\n          return dp[n];\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n     \\n          vector<long long int>dp(n+1);\\n          if(n==0)\\n          {\\n              return 1;\\n          }\\n          if(n==1)\\n          {\\n              return 1+9;   \\n          }\\n          dp[0]=1;\\n          dp[1]=dp[0]+9;\\n        \\n          int val=9;\\n          int counter=9;\\n        \\n          for(int i=2;i<=n;i++)\\n          {\\n              dp[i]=(dp[i-1]+0LL+(val*counter));\\n              val=val*counter;\\n              counter--;\\n          }\\n          return dp[n];\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378407,
                "title": "all-4-solutions-recursion-memoization-dynamic-programming",
                "content": "```\\n// Recursion \\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if (n==0)  return 1; \\n        int tmp =9 ; \\n        int ans = 9 ;\\n        for ( int i =1 ; i<n ; i++)\\n            ans*=tmp--; \\n        return dp[n]=ans + solve(n-1); \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return solve(n); \\n    }\\n};\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    int dp[9]={1};\\n    int solve(int n){\\n        if ( n==0 || dp[n]!=0) return dp[n]; \\n        int tmp =9 ; \\n        int ans = 9 ;\\n        for ( int i =1 ; i<n ; i++)\\n            ans*=tmp--; \\n        return dp[n]=ans + solve(n-1); \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return solve(n); \\n    }\\n};\\n//Dynamic Programming\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int sum=1,c=9;\\n        vector<int> dp(n+2);\\n        dp[0]=1,dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*c+sum;\\n            sum+=dp[i-1];\\n            c--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursion \\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if (n==0)  return 1; \\n        int tmp =9 ; \\n        int ans = 9 ;\\n        for ( int i =1 ; i<n ; i++)\\n            ans*=tmp--; \\n        return dp[n]=ans + solve(n-1); \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return solve(n); \\n    }\\n};\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    int dp[9]={1};\\n    int solve(int n){\\n        if ( n==0 || dp[n]!=0) return dp[n]; \\n        int tmp =9 ; \\n        int ans = 9 ;\\n        for ( int i =1 ; i<n ; i++)\\n            ans*=tmp--; \\n        return dp[n]=ans + solve(n-1); \\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        return solve(n); \\n    }\\n};\\n//Dynamic Programming\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int sum=1,c=9;\\n        vector<int> dp(n+2);\\n        dp[0]=1,dp[1]=10;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]*c+sum;\\n            sum+=dp[i-1];\\n            c--;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336932,
                "title": "0-ms-faster-than-100-00-using-simple-iteration-and-permutations-logic",
                "content": "```\\n\\t/*\\n\\t\\t Consider numbers with  some length say strictly 4 e.g.  i.e. their range would be 1000-9999\\n\\t\\t consider 1st Digit is left most difit\\n\\t\\t 1st digit can take 9 possible values ( 1-9) since there are no leading 0s \\n\\t\\t 2nd digit can take 9 possible values (0-9 except the one taken in 1st digit) \\n\\t\\t 3rd digit can take 8 possible values \\n\\t\\t 4th digit can take 7 possible values \\n\\t\\t so total number of unique numbers in this range would be 9*9*8*7 \\n\\t\\t use this approach to calculate the final value in the problem statement \\n\\t\\t * \\t\\t0 -> 1 \\n\\t\\t *  1-9 -> 9\\n\\t\\t *  10-99-> 9*9 = 81\\n\\t\\t    100-999 -> 9 * 9 * 8 + 9 * 9 + 9 + 1\\n\\t\\t    1000-9999 -> 9 * 9 * 8 * 7 +  9 * 9 * 8 + 9 * 9 + 9 + 1\\n\\t\\t*/\\n\\t\\t\\n\\t\\t\\n\\t\\tint t=1;\\n\\t\\twhile(n>0){\\n\\t\\t\\tint s=9;\\n\\t\\t\\tint x=9;\\n\\t\\t\\tint k=n;\\n\\t\\t\\twhile(k>1){\\n\\t\\t\\t\\ts= s* x;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tx--;\\n\\t\\t\\t}\\n\\t\\t\\tt=t+s;\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t\\treturn t;\\n\\t }",
                "solutionTags": [],
                "code": "```\\n\\t/*\\n\\t\\t Consider numbers with  some length say strictly 4 e.g.  i.e. their range would be 1000-9999\\n\\t\\t consider 1st Digit is left most difit\\n\\t\\t 1st digit can take 9 possible values ( 1-9) since there are no leading 0s \\n\\t\\t 2nd digit can take 9 possible values (0-9 except the one taken in 1st digit) \\n\\t\\t 3rd digit can take 8 possible values \\n\\t\\t 4th digit can take 7 possible values \\n\\t\\t so total number of unique numbers in this range would be 9*9*8*7 \\n\\t\\t use this approach to calculate the final value in the problem statement \\n\\t\\t * \\t\\t0 -> 1 \\n\\t\\t *  1-9 -> 9\\n\\t\\t *  10-99-> 9*9 = 81\\n\\t\\t    100-999 -> 9 * 9 * 8 + 9 * 9 + 9 + 1\\n\\t\\t    1000-9999 -> 9 * 9 * 8 * 7 +  9 * 9 * 8 + 9 * 9 + 9 + 1\\n\\t\\t*/\\n\\t\\t\\n\\t\\t\\n\\t\\tint t=1;\\n\\t\\twhile(n>0){\\n\\t\\t\\tint s=9;\\n\\t\\t\\tint x=9;\\n\\t\\t\\tint k=n;\\n\\t\\t\\twhile(k>1){\\n\\t\\t\\t\\ts= s* x;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t\\tx--;\\n\\t\\t\\t}\\n\\t\\t\\tt=t+s;\\n\\t\\t\\tn--;\\n\\t\\t}\\n\\t\\treturn t;\\n\\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 2316654,
                "title": "c-100-dp-math-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        vector<int> dp(n+2);\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=9;\\n            int k=9;\\n            int count=1;\\n            while(count<i)\\n            {\\n                dp[i]*=k;\\n                k--;\\n                count++;\\n            }\\n            dp[i]+=dp[i-1];\\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        vector<int> dp(n+2);\\n        dp[0]=1;\\n        dp[1]=10;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=9;\\n            int k=9;\\n            int count=1;\\n            while(count<i)\\n            {\\n                dp[i]*=k;\\n                k--;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2249198,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int count=1;\\n        while(n-- > 0)\\n        {\\n            count=count*(min(9,10-n))+1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int count=1;\\n        while(n-- > 0)\\n        {\\n            count=count*(min(9,10-n))+1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139982,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1 << 10];\\n    int solve(int pos, bool bound,  int mask, string s) {\\n        if (pos == s.length()) return 1;\\n        if (dp[pos][bound][mask] != -1) return dp[pos][bound][mask];\\n\\n        int ans = 0;\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (mask == 0 && digit == 0) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), mask, s);\\n            else if (!(mask & (1 << digit))) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), mask | (1 << digit), s);\\n        }\\n\\n        return dp[pos][bound][mask] = ans;\\n\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        // string s = to_string(pow(10, n) - 1);\\n        int num = 1;\\n        for (int i = 0; i < n; i++) num *= 10;\\n\\n        num--;\\n        string s = to_string(num);\\n        return solve(0, true, 0, s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1 << 10];\\n    int solve(int pos, bool bound,  int mask, string s) {\\n        if (pos == s.length()) return 1;\\n        if (dp[pos][bound][mask] != -1) return dp[pos][bound][mask];\\n\\n        int ans = 0;\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (mask == 0 && digit == 0) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), mask, s);\\n            else if (!(mask & (1 << digit))) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), mask | (1 << digit), s);\\n        }\\n\\n        return dp[pos][bound][mask] = ans;\\n\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        // string s = to_string(pow(10, n) - 1);\\n        int num = 1;\\n        for (int i = 0; i < n; i++) num *= 10;\\n\\n        num--;\\n        string s = to_string(num);\\n        return solve(0, true, 0, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134770,
                "title": "java-dp-beats-1000",
                "content": "class Solution {\\n    \\n    public int fac(int nn,int i){\\n        int u=9;\\n        for(int j=1;j<=i;j++)\\n            nn=nn*(u-j);\\n        return nn;\\n    }\\n    public int countNumbersWithUniqueDigits(int n) {\\n          int[] dp=new int[9];\\n    dp[0]=1;\\n    dp[1]=10;\\n    \\n        \\n        int sum=1;\\n    for(int i=2;i<9;i++){\\n        sum=1;\\n        dp[i]=dp[i-1]+81*fac(sum,i-2);\\n    }\\n    return dp[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int fac(int nn,int i){\\n        int u=9;\\n        for(int j=1;j<=i;j++)\\n            nn=nn*(u-j);\\n        return nn;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2119091,
                "title": "using-maths-dp",
                "content": "Upvote if it helps :)\\n\\nGenerate 1,2,3..  n digit number using the permutation method, and add them together.\\n1 digit number (0-9) -> 10\\n2 digit number (1-9)(0-9 expect the previous one) -> 9 * 9 = 81\\n3 digit number (1-9) (0-9 unique)(0-9, unique) -> 9 * 9 * 8 = 648 \\nand so on .... \\n..\\nn digit number -> 9 * 9 * 8 * 7 * 6 * 5.....* 1  \\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i]=fun(i)+dp[i-1];\\n        }\\n        return dp[n];\\n    }\\n    int fun(int i)\\n    {\\n        int res=9;\\n        i--;\\n        int n=9;\\n        while(i--)\\n        {\\n            res*=n;\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i]=fun(i)+dp[i-1];\\n        }\\n        return dp[n];\\n    }\\n    int fun(int i)\\n    {\\n        int res=9;\\n        i--;\\n        int n=9;\\n        while(i--)\\n        {\\n            res*=n;\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117164,
                "title": "c-faster-than-100-using-formula",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int n){\\n\\t\\t\\t\\tint res = 1;\\n\\t\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\t\\tres = res*i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\t\\tres += (9*f(9))/f(10-i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res+1;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int n){\\n\\t\\t\\t\\tint res = 1;\\n\\t\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\t\\tres = res*i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2059209,
                "title": "c-o-1-direct-formula",
                "content": "Total count of n digit number with all unique digits=9 * 9!/(10-n)!\\nclass Solution {\\npublic:\\n    int factorial(int n){\\n        int i,p=1;\\n        for(i=1;i<=n;i++){\\n          p*=i;  \\n        }\\n        return p;\\n    }\\n    int countNumbersWithUniqueDigits(int n) {\\n        int i,ans=0;\\n        for(i=1;i<=n;i++){\\n        ans+=(9*factorial(9)/(factorial(10-i)));\\n        }\\n        return ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int factorial(int n){\\n        int i,p=1;\\n        for(i=1;i<=n;i++){\\n          p*=i;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1933890,
                "title": "python3-math-solution",
                "content": "```\\n\\n@cache\\ndef fact(n):\\n    if n == 0:\\n        return 1\\n    else:\\n        return n * fact(n-1)\\n\\n@cache\\ndef P(a, b):\\n    return (int) (fact(a) / fact(a-b))\\n\\nclass Solution:    \\n        \\n    @cache\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        else:\\n            return P(10, n) - P(9, n-1) + self.countNumbersWithUniqueDigits(n-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\n@cache\\ndef fact(n):\\n    if n == 0:\\n        return 1\\n    else:\\n        return n * fact(n-1)\\n\\n@cache\\ndef P(a, b):\\n    return (int) (fact(a) / fact(a-b))\\n\\nclass Solution:    \\n        \\n    @cache\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        else:\\n            return P(10, n) - P(9, n-1) + self.countNumbersWithUniqueDigits(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928818,
                "title": "easy-dp-solution-time-o-n-and-space-o-1",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n)\\n    {\\n        int dp[9][2] = {0};\\n        dp[0][0] = 0;\\n        dp[0][1] = 1;\\n        for (int i = 1; i < 9; i++)\\n        {\\n            int x = 10 * dp[i - 1][0];\\n            int y = (i - 1) * dp[i - 1][1];\\n            dp[i][0] = x + y;\\n            dp[i][1] = pow(10, i) - pow(10, i - 1) - dp[i][0];\\n        }\\n        for (int i = 1; i < 9; i++)\\n            dp[i][1] += dp[i - 1][1];\\n        return dp[n][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n)\\n    {\\n        int dp[9][2] = {0};\\n        dp[0][0] = 0;\\n        dp[0][1] = 1;\\n        for (int i = 1; i < 9; i++)\\n        {\\n            int x = 10 * dp[i - 1][0];\\n            int y = (i - 1) * dp[i - 1][1];\\n            dp[i][0] = x + y;\\n            dp[i][1] = pow(10, i) - pow(10, i - 1) - dp[i][0];\\n        }\\n        for (int i = 1; i < 9; i++)\\n            dp[i][1] += dp[i - 1][1];\\n        return dp[n][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778411,
                "title": "c-solution-100-fast-0ms-using-probability-concepts",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        if(n==0)\\n            return 1;\\n        else if(n==1)\\n            return 10;\\n        else if(n==2)\\n            return 91;\\n        else\\n        {\\n            int dp[9];\\n            dp[0]=1;\\n            dp[1]=10;\\n            dp[2]=91;\\n            \\n            int cnt=0;\\n            int i,j;\\n            int co=9;\\n            for(i=3;i<=n;i++)\\n            {\\n                cnt=9;\\n                j=i-1;\\n                co=9;\\n                for(;j>=1;j--)\\n                {\\n                    cnt=cnt*co;\\n                    co--;\\n                }\\n                dp[i]=cnt+dp[i-1];\\n            }\\n            ans=dp[n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        if(n==0)\\n            return 1;\\n        else if(n==1)\\n            return 10;\\n        else if(n==2)\\n            return 91;\\n        else\\n        {\\n            int dp[9];\\n            dp[0]=1;\\n            dp[1]=10;\\n            dp[2]=91;\\n            \\n            int cnt=0;\\n            int i,j;\\n            int co=9;\\n            for(i=3;i<=n;i++)\\n            {\\n                cnt=9;\\n                j=i-1;\\n                co=9;\\n                for(;j>=1;j--)\\n                {\\n                    cnt=cnt*co;\\n                    co--;\\n                }\\n                dp[i]=cnt+dp[i-1];\\n            }\\n            ans=dp[n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725620,
                "title": "java-dp-solution-explained",
                "content": "```\\n/*\\n\\tif n =1 , then we have 10 choices to fill the answer, ( 0 can be used here at the most significant place)\\n\\tbut for n = 2,3,4.... , we have only 9 choices out of 10 at the largest place , \\n\\t9 on the 2nd largest ( 0 was not included in first so we still have 9 more ), \\n\\tthen 8 choices for the 3rd place ans so on\\n\\t\\n\\tn=1  , ans =10\\n\\tn=2  , ans = 9*9+10 = 91\\n\\tn=3  , ans(3) = 9*9*8+ 91 = 739\\n\\tn=4  , ans(4)= 9*9*8*7 + 739\\n\\t\\n\\tand so on\\n*/\\n\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0) return 1;\\n        int []dp = new int[n+1];\\n        \\n        dp[1]=10;\\n        int prod =9;\\n        \\n        for(int i=2;i<=n;i++){\\n            dp[i]=prod*(11-i)+dp[i-1];\\n            prod*=(11-i);\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n/*\\n\\tif n =1 , then we have 10 choices to fill the answer, ( 0 can be used here at the most significant place)\\n\\tbut for n = 2,3,4.... , we have only 9 choices out of 10 at the largest place , \\n\\t9 on the 2nd largest ( 0 was not included in first so we still have 9 more ), \\n\\tthen 8 choices for the 3rd place ans so on\\n\\t\\n\\tn=1  , ans =10\\n\\tn=2  , ans = 9*9+10 = 91\\n\\tn=3  , ans(3) = 9*9*8+ 91 = 739\\n\\tn=4  , ans(4)= 9*9*8*7 + 739\\n\\t\\n\\tand so on\\n*/\\n\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        if(n==0) return 1;\\n        int []dp = new int[n+1];\\n        \\n        dp[1]=10;\\n        int prod =9;\\n        \\n        for(int i=2;i<=n;i++){\\n            dp[i]=prod*(11-i)+dp[i-1];\\n            prod*=(11-i);\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701610,
                "title": "simple-solution-using-factorials",
                "content": "A key to this problem is to know what kind of digits do we have:\\n1. Single digit numbers: can be `0..9` \\n2. Double digits numbers: first digit can not be `0` and number of second unique digits numbers would be 9 i.e. we use `0..9` digits. \\n\\nSo, `[ ] [ ]` In the first digits, we have 9 digits to fill `1..9` but in the 2nd also we have 9 to fill i.e. `0..9` (because zero is valid as a non 1st digit), so `[9 digits][9 digits]` i.e. 9*9 = 81 total numbers with two digits but total combined would be `10 + 81`\\n\\n3. Three digits numbers can build on the same logic.. however now in the 3rd digit we can not repeat the previous digits so our number of available digits will be one less than the previous digit.. i.e. `[9 digits][9 digits][8 digits]`\\n\\nTo generalize further the rest of the digits can just be a factorial up to digit depth. In the above case, it would be `10*9` and then add the first digit numbers so, `10 + 9*9 + 9*9*8 = 739`.\\n\\n\\n\\n```\\nclass Solution {\\n\\n    private int factorial(int n, int depth) {\\n        int f = 1;\\n        while(depth-- > 0) {\\n            f *= n--;\\n        }\\n        return f;\\n    }\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int ans = 0;\\n\\n        if(n==0) return 1;\\n\\n        for(int i=1; i<=n; i++) {\\n            if(i==1) ans += 10; // digits 0..9 (single digit number) \\n            else {  \\n                // more than 1 digits, first can\\'t be zero so, 9 * factorial(9, <remaining number of digits>)\\n                ans += 9 * factorial(9, i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private int factorial(int n, int depth) {\\n        int f = 1;\\n        while(depth-- > 0) {\\n            f *= n--;\\n        }\\n        return f;\\n    }\\n\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int ans = 0;\\n\\n        if(n==0) return 1;\\n\\n        for(int i=1; i<=n; i++) {\\n            if(i==1) ans += 10; // digits 0..9 (single digit number) \\n            else {  \\n                // more than 1 digits, first can\\'t be zero so, 9 * factorial(9, <remaining number of digits>)\\n                ans += 9 * factorial(9, i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691055,
                "title": "c-backtracking-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<bool>generateCandForZero(){\\n        vector<bool>ans(10,false);\\n        ans[0]=true;\\n        return ans;\\n    }\\n    vector<bool>generate(string &num){\\n        vector<bool>ans(10,false);\\n        for(int i=0;i<num.size();i++){\\n            ans[num[i]-\\'0\\']=true;\\n        }\\n        return ans;\\n    }\\n    void backtrack(int &ans,string &num,int n){\\n        if(num.size()==n){\\n            return;\\n        } else {\\n            vector<bool>cnds;\\n            if(num==\"\"){\\n                cnds=generateCandForZero();\\n            } else {\\n                cnds=generate(num);\\n            }\\n            for(int i=0;i<10;i++){\\n                if(!cnds[i]){\\n                    num.push_back(i+\\'0\\');\\n                    ans++;\\n                    backtrack(ans,num,n);\\n                    num.pop_back();\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans=0;\\n        string num=\"\";\\n        backtrack(ans,num,n);\\n        return ans+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<bool>generateCandForZero(){\\n        vector<bool>ans(10,false);\\n        ans[0]=true;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1669639,
                "title": "python-c-2-solutions-dp",
                "content": "1)Python Recursion (2945 ms)\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n==0: return 1\\n        if n==1: return 10\\n        def dp(no):\\n            if len(no)==n: return 0\\n            ans=0\\n            for i in range(10):\\n                s=no\\n                if str(i) not in no: \\n                    s+=str(i)\\n                    ans+=dp(s)+1\\n            return ans\\n        res=10\\n        for i in range(1,10):\\n            res+=dp(str(i))\\n        return res\\n        \\n        \\n                \\n```\\n2)C++  Combinatorial (0 ms)\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        int x=9,y=9,ans=1;\\n        for (int i=0;i<n;i++){\\n            ans+=x;\\n            x*=(y-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n==0: return 1\\n        if n==1: return 10\\n        def dp(no):\\n            if len(no)==n: return 0\\n            ans=0\\n            for i in range(10):\\n                s=no\\n                if str(i) not in no: \\n                    s+=str(i)\\n                    ans+=dp(s)+1\\n            return ans\\n        res=10\\n        for i in range(1,10):\\n            res+=dp(str(i))\\n        return res\\n        \\n        \\n                \\n```\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        int x=9,y=9,ans=1;\\n        for (int i=0;i<n;i++){\\n            ans+=x;\\n            x*=(y-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596253,
                "title": "c-back-tracking-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n   int steps;\\n    int dp[10];\\n\\n   int count(int n , unordered_map<int ,int>& map)\\n   {\\n       \\n       if(n == 0 ) return 1;\\n       \\n       if(dp[n] != -1) return dp[n];\\n       \\n       int ans = 0 ;\\n       \\n       for(int i = 0 ; i < 10; i++)\\n       {\\n           if(i == 0 && n == steps) continue ; //leading 0\\'s in  _Steps_ | _step - 1_| \\n           \\n           if(map[i] ==  1)\\n           {\\n               map[i] = 0;\\n               ans += count(n-1 , map);\\n               map[i] = 1;\\n           }\\n            \\n       }\\n\\n       return dp[n] = ans;\\n   }\\n   \\n    \\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        unordered_map<int ,int> map;\\n        for(int i = 0 ; i < 10; i++)\\n        {\\n            map[i] = 1;\\n        }\\n       \\n        int ans = 0;\\n        for(int i = 1; i <= n ; i++)\\n        {\\n            steps = i;\\n            memset(dp , -1 , sizeof(dp));\\n            ans += count(i,map);\\n        }\\n        \\n        return ans+1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int steps;\\n    int dp[10];\\n\\n   int count(int n , unordered_map<int ,int>& map)\\n   {\\n       \\n       if(n == 0 ) return 1;\\n       \\n       if(dp[n] != -1) return dp[n];\\n       \\n       int ans = 0 ;\\n       \\n       for(int i = 0 ; i < 10; i++)\\n       {\\n           if(i == 0 && n == steps) continue ; //leading 0\\'s in  _Steps_ | _step - 1_| \\n           \\n           if(map[i] ==  1)\\n           {\\n               map[i] = 0;\\n               ans += count(n-1 , map);\\n               map[i] = 1;\\n           }\\n            \\n       }\\n\\n       return dp[n] = ans;\\n   }\\n   \\n    \\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        unordered_map<int ,int> map;\\n        for(int i = 0 ; i < 10; i++)\\n        {\\n            map[i] = 1;\\n        }\\n       \\n        int ans = 0;\\n        for(int i = 1; i <= n ; i++)\\n        {\\n            steps = i;\\n            memset(dp , -1 , sizeof(dp));\\n            ans += count(i,map);\\n        }\\n        \\n        return ans+1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592967,
                "title": "o-n-python",
                "content": "\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        result = 1\\n        k = 9\\n        m = 9  # The number of unique n-digit numbers will be recorded here\\n        for i in range(n):\\n            result += m\\n            m *= (k - i)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        result = 1\\n        k = 9\\n        m = 9  # The number of unique n-digit numbers will be recorded here\\n        for i in range(n):\\n            result += m\\n            m *= (k - i)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590214,
                "title": "java-dp-approach",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        return countUnique(n);\\n        \\n    }\\n    \\n    public int countUnique(int n)\\n    {\\n        if(n==0)\\n            return 1;\\n        \\n        if(n==1)\\n        {\\n            return 10;//0 to 9 \\n        }\\n        \\n        \\n        int dp[]=new int[n+1];\\n        dp[0]=0;\\n        dp[1]=9;\\n        \\n        int res=10;//for n=1 10 combinations \\n        \\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=dp[i-1]*(10-i+1);\\n            res=res+dp[i];\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        return countUnique(n);\\n        \\n    }\\n    \\n    public int countUnique(int n)\\n    {\\n        if(n==0)\\n            return 1;\\n        \\n        if(n==1)\\n        {\\n            return 10;//0 to 9 \\n        }\\n        \\n        \\n        int dp[]=new int[n+1];\\n        dp[0]=0;\\n        dp[1]=9;\\n        \\n        int res=10;//for n=1 10 combinations \\n        \\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=dp[i-1]*(10-i+1);\\n            res=res+dp[i];\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488469,
                "title": "python3-easy-o-1-solution-with-permutation",
                "content": "If n=1 then 0-9 total digits will be there so answer is 10, if n=0 then only 0 will be there so the answer is 1. For any value of n more than 1 the following rule will be applied. \\n\\nFor example if n=3 then all n=1, n=2 and n=3 digits will be counted. \\nSo far we know for one digit numbers total digits are 10, \\nfor two digit numbers: we can pick the first digit from 1-9 in total 9 ways(cause 0 cannot be the first digit), for every first digit total number of available digits where two digits are not similar are (10-1)=9 so the total permutation is 9*9\\n\\nfor three digit numbers the first digit can be picked in 9 ways as previously mentioned way, for each of the 9 first digits the second digits will be picked in 9 ways(exclusive of the first digit and inclusive of 0), for each of 9 second digits the third digits will be picked in 9-1=8 ways so the total ways are=9x9x8\\n\\nSo the answer for n=3 is : 10+ 9x9 +9x9x8 = 10+9x(9+9x8)\\nfor n=4 it will be : 10+ 9x(9+9x8+9x8x7)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\t\\t\\tif not n:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif n==1:\\n\\t\\t\\t\\treturn 10\\n\\n\\t\\t\\tmyList=[9]\\n\\t\\t\\tfor i in range(1,n-1):\\n\\t\\t\\t\\tmyList.append(myList[-1]*(9-i))\\n\\t\\t\\treturn 10+ 9*sum(myList)",
                "solutionTags": [],
                "code": "If n=1 then 0-9 total digits will be there so answer is 10, if n=0 then only 0 will be there so the answer is 1. For any value of n more than 1 the following rule will be applied. \\n\\nFor example if n=3 then all n=1, n=2 and n=3 digits will be counted. \\nSo far we know for one digit numbers total digits are 10, \\nfor two digit numbers: we can pick the first digit from 1-9 in total 9 ways(cause 0 cannot be the first digit), for every first digit total number of available digits where two digits are not similar are (10-1)=9 so the total permutation is 9*9\\n\\nfor three digit numbers the first digit can be picked in 9 ways as previously mentioned way, for each of the 9 first digits the second digits will be picked in 9 ways(exclusive of the first digit and inclusive of 0), for each of 9 second digits the third digits will be picked in 9-1=8 ways so the total ways are=9x9x8\\n\\nSo the answer for n=3 is : 10+ 9x9 +9x9x8 = 10+9x(9+9x8)\\nfor n=4 it will be : 10+ 9x(9+9x8+9x8x7)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\t\\t\\tif not n:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif n==1:\\n\\t\\t\\t\\treturn 10\\n\\n\\t\\t\\tmyList=[9]\\n\\t\\t\\tfor i in range(1,n-1):\\n\\t\\t\\t\\tmyList.append(myList[-1]*(9-i))\\n\\t\\t\\treturn 10+ 9*sum(myList)",
                "codeTag": "Java"
            },
            {
                "id": 1482842,
                "title": "simplest-c-solution-0ms-fastest-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int nonDup[n+1];\\n        nonDup[0]=1;\\n        int dpPrev=0;\\n        int powerof10=10;\\n        for(int i=1;i<=n;i++)\\n        { dpPrev=dpPrev*10 +(i-1)*nonDup[i-1];\\n          nonDup[i]= powerof10 -(powerof10/10)-dpPrev;\\n         powerof10*=10;\\n            \\n        }\\n         \\n        int total[n+1];\\n        total[0]=1;\\n        for(int i=1;i<=n;i++)\\n        { total[i]=total[i-1]+nonDup[i];\\n            \\n        }\\n        return total[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int nonDup[n+1];\\n        nonDup[0]=1;\\n        int dpPrev=0;\\n        int powerof10=10;\\n        for(int i=1;i<=n;i++)\\n        { dpPrev=dpPrev*10 +(i-1)*nonDup[i-1];\\n          nonDup[i]= powerof10 -(powerof10/10)-dpPrev;\\n         powerof10*=10;\\n            \\n        }\\n         \\n        int total[n+1];\\n        total[0]=1;\\n        for(int i=1;i<=n;i++)\\n        { total[i]=total[i-1]+nonDup[i];\\n            \\n        }\\n        return total[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480320,
                "title": "easy-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return 10;\\n        vector<int> dp(n+1, 0);\\n        dp[0] = 1; dp[1] = 10;\\n        \\n        for (int i = 2; i <= n; ++i) {\\n            int a = dp[i-1] - dp[i-2]; // count of nums with unique digits having i-1 total digits\\n            dp[i] = a * (10 - i + 1) + dp[i-1];\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return 10;\\n        vector<int> dp(n+1, 0);\\n        dp[0] = 1; dp[1] = 10;\\n        \\n        for (int i = 2; i <= n; ++i) {\\n            int a = dp[i-1] - dp[i-2]; // count of nums with unique digits having i-1 total digits\\n            dp[i] = a * (10 - i + 1) + dp[i-1];\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416500,
                "title": "python-3-math-dp-explanation",
                "content": "### Explanation\\n- `f(0) = 1`\\n- `f(1) = 9 + f(0) = 10`\\n- `f(2) = 9 * 9 + f(1) = 91`\\n- `f(3) = 9 * 9 * 8 + f(2) = 739`\\n- `...`\\n- You got the idea \\n### Implementation\\n```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = [1]\\n        for k in range(1, n+1):\\n            base = available = 9\\n            for _ in range(k-1):\\n                base *= available \\n                available -= 1\\n            ans.append(base+ans[-1])    \\n        return ans[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        ans = [1]\\n        for k in range(1, n+1):\\n            base = available = 9\\n            for _ in range(k-1):\\n                base *= available \\n                available -= 1\\n            ans.append(base+ans[-1])    \\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351199,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n>10)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        int ans=10;\\n        int digitAvailable=9;\\n        int count=9;\\n        while(n>1 && digitAvailable>0){\\n            count=count*digitAvailable;\\n            ans+=count;\\n            digitAvailable--;\\n            n--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n>10)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        int ans=10;\\n        int digitAvailable=9;\\n        int count=9;\\n        while(n>1 && digitAvailable>0){\\n            count=count*digitAvailable;\\n            ans+=count;\\n            digitAvailable--;\\n            n--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337070,
                "title": "faster-than-100-00-of-c-online-submissions",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n\\t\\t//9 * 9 + 10 for n = 2\\n        //9 * 9 * 8 + 10 for n = 3\\n        //9 * 9 * 8 * 7 + 10 for n = 4\\n        //9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n\\t\\t\\n\\t\\t\\n        int ans = 10;\\n        if(n==0){\\n            return 1;\\n        }else if(n==1){\\n            return 10;\\n        }else{\\n            int sum =9;\\n            for(int i =2;i<=n;i++){\\n                sum*=(11-i);\\n                ans=ans+sum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n\\t\\t//9 * 9 + 10 for n = 2\\n        //9 * 9 * 8 + 10 for n = 3\\n        //9 * 9 * 8 * 7 + 10 for n = 4\\n        //9 * 9 * 8 * 7 * 6 + 10 for n = 5\\n\\t\\t\\n\\t\\t\\n        int ans = 10;\\n        if(n==0){\\n            return 1;\\n        }else if(n==1){\\n            return 10;\\n        }else{\\n            int sum =9;\\n            for(int i =2;i<=n;i++){\\n                sum*=(11-i);\\n                ans=ans+sum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279712,
                "title": "java-o-1-100",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int prod=9;\\n        int i=1;\\n        int total=10;\\n        while(n>=2){\\n            prod=prod*(10-i);\\n            total+=prod;\\n            i++;\\n            n--;\\n        }\\n        return total;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        if(n==1) return 10;\\n        int prod=9;\\n        int i=1;\\n        int total=10;\\n        while(n>=2){\\n            prod=prod*(10-i);\\n            total+=prod;\\n            i++;\\n            n--;\\n        }\\n        return total;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276638,
                "title": "c-100-faster-o-n-tc-0ms",
                "content": "Using Combination\\n\\n```\\nclass Solution {\\npublic:\\n    //In this problem, for 1st position we have 9 option(1,2,...,8,9)( becoz we cann\\'t use 0 at 1st position)\\n    //for 2nd position again we have 9 option(0,1,2...,8,9 excluding that digit which we have used in previous position)\\n    //for 3rd --> 8 option and so on........\\n    //so answer is 9*9*8*...*(9-k+2);\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans = 1;\\n        int k = 9,res = 1;\\n        for(int i = 1;i <= n;i++){\\n            res *= k;\\n            ans += res;\\n            if(i != 1){\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //In this problem, for 1st position we have 9 option(1,2,...,8,9)( becoz we cann\\'t use 0 at 1st position)\\n    //for 2nd position again we have 9 option(0,1,2...,8,9 excluding that digit which we have used in previous position)\\n    //for 3rd --> 8 option and so on........\\n    //so answer is 9*9*8*...*(9-k+2);\\n    int countNumbersWithUniqueDigits(int n) {\\n        int ans = 1;\\n        int k = 9,res = 1;\\n        for(int i = 1;i <= n;i++){\\n            res *= k;\\n            ans += res;\\n            if(i != 1){\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270104,
                "title": "c-faster-than-100-solns",
                "content": "```\\nclass Solution {\\npublic:\\n    int binomialCoeff(int n, int k)\\n    {\\n        int C[n + 1][k + 1];\\n        int i, j;\\n\\n        for (i = 0; i <= n; i++) {\\n            for (j = 0; j <= min(i, k); j++) {\\n                \\n                if (j == 0 || j == i)\\n                    C[i][j] = 1;\\n\\n                else\\n                    C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\\n            }\\n        }\\n\\n        return C[n][k];\\n    }\\n    \\n    \\n    \\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        vector<int> dp(n+5,0);\\n        dp[0] = 1;\\n        vector<int> fact(n+3);\\n        \\n        fact[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            fact[i] = i*fact[i-1];\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = (binomialCoeff(10,i)*fact[i]-binomialCoeff(9,i-1)*fact[i-1]);\\n            dp[i] += dp[i-1];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binomialCoeff(int n, int k)\\n    {\\n        int C[n + 1][k + 1];\\n        int i, j;\\n\\n        for (i = 0; i <= n; i++) {\\n            for (j = 0; j <= min(i, k); j++) {\\n                \\n                if (j == 0 || j == i)\\n                    C[i][j] = 1;\\n\\n                else\\n                    C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\\n            }\\n        }\\n\\n        return C[n][k];\\n    }\\n    \\n    \\n    \\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        vector<int> dp(n+5,0);\\n        dp[0] = 1;\\n        vector<int> fact(n+3);\\n        \\n        fact[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            fact[i] = i*fact[i-1];\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = (binomialCoeff(10,i)*fact[i]-binomialCoeff(9,i-1)*fact[i-1]);\\n            dp[i] += dp[i-1];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266900,
                "title": "oops",
                "content": "* class Solution {\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n) {\\n        int dp[10];\\n        int ans = 0;\\n        int sum[10];\\n        sum[0] = 1;\\n        sum[1] = 10;\\n        for(int i = 0;i <= n;i++)\\n        {\\n            if(i == 0)\\n            {\\n              dp[i] = 1;\\n              \\n            }\\n            else if(i == 1)\\n            {\\n              dp[i] = 9;\\n            }\\n            else\\n            {\\n                dp[i] = dp[i-1]*(10-i+1);\\n                sum[i] = sum[i-1]+dp[i];\\n            }\\n        }\\n        return sum[n];\\n    }\\n    \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int countNumbersWithUniqueDigits(int n) {\\n        int dp[10];\\n        int ans = 0;\\n        int sum[10];\\n        sum[0] = 1;\\n        sum[1] = 10;\\n        for(int i = 0;i <= n;i++)\\n        {\\n            if(i == 0)\\n            {\\n              dp[i] = 1;\\n              \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1232009,
                "title": "simple-python-o-1-with-explaination",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        def val(x):\\n            \"\"\"\\n            1 digit : 10\\n            2 digit : 9*9\\n            3 digit : 9*9*8\\n            4 digit : 9*9*8*7\\n            ....\\n            n digit : 9*9*8......\\n                      --n times--\\n            \"\"\"\\n            if x == 1:\\n                return 10\\n            s=9\\n            for i in range(0, x-1):\\n                s *= (9-i)\\n            return s\\n        res=0\\n        for i in range(1, n+1):\\n            res += val(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        def val(x):\\n            \"\"\"\\n            1 digit : 10\\n            2 digit : 9*9\\n            3 digit : 9*9*8\\n            4 digit : 9*9*8*7\\n            ....\\n            n digit : 9*9*8......\\n                      --n times--\\n            \"\"\"\\n            if x == 1:\\n                return 10\\n            s=9\\n            for i in range(0, x-1):\\n                s *= (9-i)\\n            return s\\n        res=0\\n        for i in range(1, n+1):\\n            res += val(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225640,
                "title": "c-combinatorics-o-n-runtime-o-1-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        int sum = 10;\\n        int unique = 9;\\n        for (int i = 1, m = 9; i < n && m > 0; i++, m--) {\\n            unique *= m;\\n            sum += unique;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        int sum = 10;\\n        int unique = 9;\\n        for (int i = 1, m = 9; i < n && m > 0; i++, m--) {\\n            unique *= m;\\n            sum += unique;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164782,
                "title": "java-0ms-100-95-space-no-dp-no-backtracking-pure-math-no-extra-space",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int duplicate=0;\\n        int nonduplicate=1;\\n        if(n==0){\\n            return 1;\\n        }\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            duplicate=10*duplicate+(i-1)*nonduplicate;\\n            nonduplicate=((int)(Math.pow(10,i)))-((int)(Math.pow(10,i-1)))-duplicate;\\n            sum+=nonduplicate;\\n        }\\n        return sum+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        int duplicate=0;\\n        int nonduplicate=1;\\n        if(n==0){\\n            return 1;\\n        }\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            duplicate=10*duplicate+(i-1)*nonduplicate;\\n            nonduplicate=((int)(Math.pow(10,i)))-((int)(Math.pow(10,i-1)))-duplicate;\\n            sum+=nonduplicate;\\n        }\\n        return sum+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133879,
                "title": "c-dp-0-ms-faster-than-100-00-5-8-mb-less-than-95-50",
                "content": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1) return 10;\\n        \\n        int prev=9;\\n         int sum=10;\\n        for(int i=2;i<=n;i++){\\n            prev = prev*(10-i+1);\\n            sum+= prev;\\n        }\\n        return sum;\\n    }\\n};\\n```\\nDo upvote if you liked the code :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)return 1;\\n        if(n==1) return 10;\\n        \\n        int prev=9;\\n         int sum=10;\\n        for(int i=2;i<=n;i++){\\n            prev = prev*(10-i+1);\\n            sum+= prev;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080087,
                "title": "java-math-solution-beats-100-w-commented-explanation",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        // edge cases\\n        if (n == 0) return 1;\\n        else if (n == 1) return 10;\\n        else {\\n            // final digit place we can choose from 1-9 excluding 0\\n            int res = 9;\\n            int nums_taken = 0;\\n            \\n            // for each subsequent digit place, we can choose 0-9, but\\n            // each time we remove a number to ensure uniqueness\\n            for (int i = 1; i < n; i++) {\\n                res *= 9 - nums_taken;\\n                nums_taken += 1;\\n            }\\n            \\n            // return total number of unique number digits of length n + what is returned from \\n            // making a recursive call for n - 1\\n            return res + countNumbersWithUniqueDigits(n - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        // edge cases\\n        if (n == 0) return 1;\\n        else if (n == 1) return 10;\\n        else {\\n            // final digit place we can choose from 1-9 excluding 0\\n            int res = 9;\\n            int nums_taken = 0;\\n            \\n            // for each subsequent digit place, we can choose 0-9, but\\n            // each time we remove a number to ensure uniqueness\\n            for (int i = 1; i < n; i++) {\\n                res *= 9 - nums_taken;\\n                nums_taken += 1;\\n            }\\n            \\n            // return total number of unique number digits of length n + what is returned from \\n            // making a recursive call for n - 1\\n            return res + countNumbersWithUniqueDigits(n - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068103,
                "title": "faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n        {\\n        \\treturn 1;\\n        }\\n        int sum=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n        \\tint prod=1;\\n        \\tint num=9;\\n        \\tfor(int j=0;j<i;j++)\\n        \\t{\\n        \\t\\tprod=prod*num;\\n        \\t\\tif(j==0)\\n        \\t\\t{\\n        \\t\\t\\tnum++;\\n        \\t\\t}\\n        \\t\\tnum--;\\n        \\t}\\n        \\tsum=sum+prod;\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n        {\\n        \\treturn 1;\\n        }\\n        int sum=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n        \\tint prod=1;\\n        \\tint num=9;\\n        \\tfor(int j=0;j<i;j++)\\n        \\t{\\n        \\t\\tprod=prod*num;\\n        \\t\\tif(j==0)\\n        \\t\\t{\\n        \\t\\t\\tnum++;\\n        \\t\\t}\\n        \\t\\tnum--;\\n        \\t}\\n        \\tsum=sum+prod;\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050551,
                "title": "c",
                "content": "```\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if (n<=1) return pow(10,n);\\n        int sum=9;\\n        int cn=sum;\\n        for (int i=0;i<n-1;i++) sum*=(cn-i);\\n        return sum+countNumbersWithUniqueDigits(n-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int countNumbersWithUniqueDigits(int n) \\n    {\\n        if (n<=1) return pow(10,n);\\n        int sum=9;\\n        int cn=sum;\\n        for (int i=0;i<n-1;i++) sum*=(cn-i);\\n        return sum+countNumbersWithUniqueDigits(n-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047757,
                "title": "java-combinatorics-dp",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n){\\n        if(n==0) return 1;\\n        int[]dp = new int[n+1];\\n        dp[1] = 10; //for n==1 there are 10 unique numbes {0 to 9}\\n        int[]prefix = new int[10];\\n        prefix[0] = 9;\\n        int curr = 9;\\n        for(int i=1;i<prefix.length;i++){\\n            prefix[i] = prefix[i-1] * curr--;\\n        }\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-1] + prefix[i-1];   \\n        }\\n        return dp[n];\\n    }\\n}\\n\\n/**\\n1 -> {_} 1st-slot 10 possibilities (0-9) \\n2 -> {1} + {9(0 cant be 1st) * 9(0 can be used here)} \\n3 -> {1} + {9 * 9} + {9 * 9 * 8}\\n4 -> {1} + {9 * 9} + {9 * 9 * 8} + {9 * 9 * 8 * 7}\\n5 -> (n==4) + {9*9*8*7*6}\\n6 -> (n==5) + {9*9*8.......5}\\n7 -> (n==6) + {9*9*8.......4}\\n.\\n.\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n){\\n        if(n==0) return 1;\\n        int[]dp = new int[n+1];\\n        dp[1] = 10; //for n==1 there are 10 unique numbes {0 to 9}\\n        int[]prefix = new int[10];\\n        prefix[0] = 9;\\n        int curr = 9;\\n        for(int i=1;i<prefix.length;i++){\\n            prefix[i] = prefix[i-1] * curr--;\\n        }\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-1] + prefix[i-1];   \\n        }\\n        return dp[n];\\n    }\\n}\\n\\n/**\\n1 -> {_} 1st-slot 10 possibilities (0-9) \\n2 -> {1} + {9(0 cant be 1st) * 9(0 can be used here)} \\n3 -> {1} + {9 * 9} + {9 * 9 * 8}\\n4 -> {1} + {9 * 9} + {9 * 9 * 8} + {9 * 9 * 8 * 7}\\n5 -> (n==4) + {9*9*8*7*6}\\n6 -> (n==5) + {9*9*8.......5}\\n7 -> (n==6) + {9*9*8.......4}\\n.\\n.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031785,
                "title": "solution-with-basic-combinatorics-and-fast-computation-beats-100",
                "content": "The requirements of this problem is that we need to exclude the numbers having repeated digits. There are two ways to do this:\\n\\n1. Calculate total possible numbers having digits *less than or equal to* 10<sup>n</sup> and subtract the number of numbers having repeated digits. This is a tedious process because we need to count the numbers by keeping two same digits, then three same digits and so on.\\n2. Build the number by filling each digit place. For instance, consider in a 5 digit number. First position (ten thousands place) can be taken by 9 digits (1-9, can\\'t include 0 here). Fill it and continue for next place. This place can be taken by 9 digits (excluding the digit we placed in previous position, including 0). And continue doing this unitl all positions are filled. Total number of such numbers are 9 * 9 * 8 * 7 * 6 = 9 * (9!) / (10-5)! In general for **i** digit number, total count of numbers having unique digits = **9 * (9!)/ (10-i)!**. But for the solution of this problem, we also need to add such (i-1) digit numbers, (i-2) digit numbers and so on. To do that, we will use a table ```nums``` to store the numbers with unique digits. ```nums[i]``` will represent number of \\'i\\' digit numbers having unique digits. Hence, ```nums[i] = nums[i-1] + (9 * fact(9)/fact(10-i));``` fact(x) = x! where x >= 0 and x is an integer.\\n\\nA prime aspect of this solution is the necessity of factorial values. If we exclude the factorial values, we will have to recompute the product for every test case and iteration. So we will keep the factorials precomputed and we will just refer to them when needed.\\n\\nFollowing is the code:\\n\\n```\\nclass Solution {\\n    private int[] factorials = null; // array to store factorials\\n    private void computeFactorials(){\\n        if(this.factorials == null){\\n            this.factorials = new int[11];\\n            factorials[0] = 1;\\n            for(int i = 1; i < 11; i++){\\n                factorials[i] = i * factorials[i-1];\\n            }\\n        }else{\\n            return;\\n        }\\n    }\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0){\\n            return 1;\\n        }\\n        computeFactorials(); // Computes the factorials only once\\n        int[] nums = new int[n+1];\\n        nums[0] = 1;\\n        nums[1] = 10; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 -> 10\\n        for(int i = 2; i <= n; i++){\\n            nums[i] = nums[i-1] + (9 * factorials[9]/factorials[10-i]);\\n        }\\n        return nums[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```nums```\n```nums[i]```\n```nums[i] = nums[i-1] + (9 * fact(9)/fact(10-i));```\n```\\nclass Solution {\\n    private int[] factorials = null; // array to store factorials\\n    private void computeFactorials(){\\n        if(this.factorials == null){\\n            this.factorials = new int[11];\\n            factorials[0] = 1;\\n            for(int i = 1; i < 11; i++){\\n                factorials[i] = i * factorials[i-1];\\n            }\\n        }else{\\n            return;\\n        }\\n    }\\n    public int countNumbersWithUniqueDigits(int n) {\\n        if(n == 0){\\n            return 1;\\n        }\\n        computeFactorials(); // Computes the factorials only once\\n        int[] nums = new int[n+1];\\n        nums[0] = 1;\\n        nums[1] = 10; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 -> 10\\n        for(int i = 2; i <= n; i++){\\n            nums[i] = nums[i-1] + (9 * factorials[9]/factorials[10-i]);\\n        }\\n        return nums[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017024,
                "title": "100-faster-c-sol",
                "content": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        //using permutation concept for finding unique digits for 2, 3, 4 ... digits characters\\n\\t\\t// eg. for 2 digit numbers we have 2 spaces _ _ . for 1st space we have choices 1...9 -> total 9 ans for         //second we have 0...9 excluding the digit we would have used for first place -> 10 - 1 = 9\\n\\t\\t//therfore total 2 digit numbers are 9X9 \\n\\t\\t//similarly for 3 _ _ _ we have 9 X 9 X 8 ans so on ...\\n\\t\\t\\n        int dp[n+1];\\n        if(n==0){\\n            return 1 ;\\n        }\\n        dp[1] = 10 ;\\n        int t = 9  ;\\n        for(int i=2 ; i<=n ; i++){\\n            for(int j=0 ; j<i-1 ; j++){\\n                t = t*(9-j);\\n            }\\n            dp[i] = dp[i-1] + t ;\\n            t = 9 ;\\n        }\\n        \\n        return dp[n];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        //using permutation concept for finding unique digits for 2, 3, 4 ... digits characters\\n\\t\\t// eg. for 2 digit numbers we have 2 spaces _ _ . for 1st space we have choices 1...9 -> total 9 ans for         //second we have 0...9 excluding the digit we would have used for first place -> 10 - 1 = 9\\n\\t\\t//therfore total 2 digit numbers are 9X9 \\n\\t\\t//similarly for 3 _ _ _ we have 9 X 9 X 8 ans so on ...\\n\\t\\t\\n        int dp[n+1];\\n        if(n==0){\\n            return 1 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1006302,
                "title": "js-o-n-analytical-solution",
                "content": "The general Idea is behind the probstat  math. So, when n === 0, then we have only one number 0. If n === 1, then we have 10 unique values. When we have n > 1, then simple combinatorics go into the game:\\n\\n2 digit number with unique digits can be created by 9 * 9 possible ways:\\n1-9 - first digit, because 2 digit number cannot start with 0, and 10 - first number => 9 second digit.\\n\\n3 digit number with unique digits can be created by 9 * 9 * 8 ways.\\n4 digit number with unique digits can be created by 9 * 9 * 8 * 7 ways.\\n\\nand so on.\\n\\nSo, we calculate the result value recursively from n to 1. Also, solution can be easily rewritten in non-recursive style.\\n\\n```\\nvar countNumbersWithUniqueDigits = function func(n) {\\n    if (n === 0) {\\n        return 1;\\n    }\\n    \\n    if (n === 1) {\\n        return 10;\\n    }\\n    \\n    let res = 9;\\n    for (let i = 0; i < n - 1; i++) {\\n        res *= 9 - i;\\n    }\\n    \\n    return res + func(n - 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countNumbersWithUniqueDigits = function func(n) {\\n    if (n === 0) {\\n        return 1;\\n    }\\n    \\n    if (n === 1) {\\n        return 10;\\n    }\\n    \\n    let res = 9;\\n    for (let i = 0; i < n - 1; i++) {\\n        res *= 9 - i;\\n    }\\n    \\n    return res + func(n - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979398,
                "title": "math",
                "content": "Base case: there is only one valid number when n == 0.\\nGeneral case: At the first step you can choose one of the digits 1-9. Then, at each following step you can choose one of the digits 0-9 that is not in the set of digits you have already chosen.\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        int sum = 10, c = 9, t = 9;\\n        for (int i = 2; i <= n; i++) {\\n            sum += (c *= t--);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) return 1;\\n        int sum = 10, c = 9, t = 9;\\n        for (int i = 2; i <= n; i++) {\\n            sum += (c *= t--);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940231,
                "title": "java-100-hopefully-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        \\n        int result = 1;\\n        for(int i=1;i<=n;i++) {\\n            int value = 9;\\n            for(int j=1;j<i;j++) {\\n                value = value * (10-j);\\n            }\\n            result = result + value;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countNumbersWithUniqueDigits(int n) {\\n        \\n        \\n        int result = 1;\\n        for(int i=1;i<=n;i++) {\\n            int value = 9;\\n            for(int j=1;j<i;j++) {\\n                value = value * (10-j);\\n            }\\n            result = result + value;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932009,
                "title": "c-0ms-just-few-lines",
                "content": "```\\nclass Solution {\\n   \\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int cur = 9, res = 1;\\n        for(int i = 0; i < n; i ++) {\\n            res += cur;\\n            cur *= (9 - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        int cur = 9, res = 1;\\n        for(int i = 0; i < n; i ++) {\\n            res += cur;\\n            cur *= (9 - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921072,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        self.res = 0\\n        str_num = [str(i) for i in range(10)]\\n        def backtrack(n, path):\\n            if n == 0:\\n                self.res += 1\\n                return\\n            for num in str_num:\\n                # try to get rid of leading zero\\n                nlz_path = str(int(path))\\n                if num not in nlz_path or nlz_path==\"0\":\\n                    backtrack(n-1, nlz_path+num)\\n        backtrack(n, \"0\")\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\\n        self.res = 0\\n        str_num = [str(i) for i in range(10)]\\n        def backtrack(n, path):\\n            if n == 0:\\n                self.res += 1\\n                return\\n            for num in str_num:\\n                # try to get rid of leading zero\\n                nlz_path = str(int(path))\\n                if num not in nlz_path or nlz_path==\"0\":\\n                    backtrack(n-1, nlz_path+num)\\n        backtrack(n, \"0\")\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916907,
                "title": "python-java-backtracking",
                "content": "\\tclass Solution:\\n\\t\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tself.res = 0\\n\\t\\t\\tseen = set()\\n\\t\\t\\tdef helper(s):\\n\\t\\t\\t\\tif len(s) > n or (len(s) > 1 and s[0] == \"0\"):\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif s:\\n\\t\\t\\t\\t\\tself.res += 1\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif i not in seen:\\n\\t\\t\\t\\t\\t\\tseen.add(i)\\n\\t\\t\\t\\t\\t\\thelper(s + str(i))\\n\\t\\t\\t\\t\\t\\tseen.remove(i)\\n\\t\\t\\thelper(\"\")\\n\\t\\t\\treturn self.res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tint res = 0;\\n\\t\\tpublic int countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\tif (n == 0) return 1;\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\thelper(n, \"\", seen);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tprivate void helper(int n, String s, Set<Integer> seen){        \\n\\t\\t\\tif (s.length() > n || (s.length() > 1 && s.charAt(0) == \\'0\\')) return;\\n\\t\\t\\tif (s != \"\") res ++;\\n\\t\\t\\tfor (int i = 0; i < 10; i ++){\\n\\t\\t\\t\\tif (!seen.contains(i)){\\n\\t\\t\\t\\t\\tseen.add(i);\\n\\t\\t\\t\\t\\thelper(n, s + String.valueOf(i), seen);\\n\\t\\t\\t\\t\\tseen.remove(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef countNumbersWithUniqueDigits(self, n: int) -> int:\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tself.res = 0\\n\\t\\t\\tseen = set()\\n\\t\\t\\tdef helper(s):\\n\\t\\t\\t\\tif len(s) > n or (len(s) > 1 and s[0] == \"0\"):\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif s:\\n\\t\\t\\t\\t\\tself.res += 1\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif i not in seen:\\n\\t\\t\\t\\t\\t\\tseen.add(i)\\n\\t\\t\\t\\t\\t\\thelper(s + str(i))\\n\\t\\t\\t\\t\\t\\tseen.remove(i)\\n\\t\\t\\thelper(\"\")\\n\\t\\t\\treturn self.res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tint res = 0;\\n\\t\\tpublic int countNumbersWithUniqueDigits(int n) {\\n\\t\\t\\tif (n == 0) return 1;\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\thelper(n, \"\", seen);\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 916559,
                "title": "scala-solution-with-explanation",
                "content": "First let\\'s set the mental map. What the question is asking is how many nums with unique digits we can construct if we are givin n digit position to play with. So in our head we can imagine something like this:\\n\\nFor n = 1: _\\nFor n = 2: _ _\\nfor n = 3: _ _ _ and so on.\\n\\nLet\\'s first consider the case where n is 1: _\\n\\nThe range of digits to choose from 0 <= x <= 10 ^ 1 so 10 ways 0 to 9\\n\\nNow let\\'s consider the case where n is 2: _ _\\n\\n0 <= x <= 10 ^ 2, so 10 ways to do 1 digit number + y ways to do 2 digit numbers\\n\\n_ _ we can do the first digit 9 ways (can\\'t be 0) we can do the second digit 9 ways (0 + remaining 8 numbers)\\n\\nso 10 + (9 * 9) = 10 + 81 = 91 ways\\n\\nNow let\\'s consider hte case where n is 3: _ _ _ \\n\\n0 <= x <= 10 ^ 3, so 10 ways to do 1 digit number + 81 ways to do 2 digit numbers + y ways to do a 3 digit number\\n\\n_ _  _ we can do the first digit 9 ways (can\\'t be 0) we can do the second digit 9 ways (0 + remaining 8 numbers) and the third can only be 8 digits (to keep the digits unique once one is chosen it cannot be chosen again)\\n\\nso 91 + (9 * 9 * 8) = 91 + 648 = 739\\n\\nYou can figure out the rest on your own.\\n\\n```\\nobject Solution {\\n  def countNumbersWithUniqueDigits(n: Int): Int = {\\n    if (n == 0) 1 // special case\\n    else {\\n      val sum_ = (9 until 10 - n by -1).foldLeft((10, 9)) { // max we can have ever is 9 digits see expl above\\n        case ((count, product), digit) => {\\n          val cCount = product * digit\\n          (count + cCount, cCount)\\n        }\\n      }\\n\\n      sum_._1\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  def countNumbersWithUniqueDigits(n: Int): Int = {\\n    if (n == 0) 1 // special case\\n    else {\\n      val sum_ = (9 until 10 - n by -1).foldLeft((10, 9)) { // max we can have ever is 9 digits see expl above\\n        case ((count, product), digit) => {\\n          val cCount = product * digit\\n          (count + cCount, cCount)\\n        }\\n      }\\n\\n      sum_._1\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 913145,
                "title": "recursive-solution-using-concept-of-combination",
                "content": "\\tpublic int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        // first digit can have 9 possibilities excluding 0\\n        // second digit will also have 9 possibilities excluding first digit\\n        int number = 9, comp = 9;\\n        for(int i = n-1; i>0 ;i--) {\\n            comp = comp * number;\\n            number--;\\n        }\\n        return comp+countNumbersWithUniqueDigits(n-1);\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int countNumbersWithUniqueDigits(int n) {\\n        if(n==0)\\n            return 1;\\n        // first digit can have 9 possibilities excluding 0\\n        // second digit will also have 9 possibilities excluding first digit\\n        int number = 9, comp = 9;\\n        for(int i = n-1; i>0 ;i--) {\\n            comp = comp * number;\\n            number--;\\n        }\\n        return comp+countNumbersWithUniqueDigits(n-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 897879,
                "title": "combinatorics-solution-explained-faster-than-100-no-extra-memory",
                "content": "**Understanding the basic combinatorics approch**\\nSuppose we want to create a 3-digit number with unique digits   _ _ _\\nFor the first _ i have 9 options out of the 10 valid digits (0 cannot be used as the number must have strictly 3 digits). For the second _ I have 9 options again(0+ remaining 8 unique digits after filling first _) \\nFor the last _ we have 8 options.\\nhence for n=3 _ _ _ : 9*9*8\\nfor n=4 _ _ _ _: 9*9*8*7=>(value for3)*7\\nand so on for bigger n.\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        int ans=1;\\n        int place=9;\\n            int temp=place;\\n        ans+=temp;\\n        for(int i=2;i<=n;i++)\\n        {  \\n            temp*=place;\\n            ans+=temp;\\n            place--;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        if(n==0) return 1;\\n        int ans=1;\\n        int place=9;\\n            int temp=place;\\n        ans+=temp;\\n        for(int i=2;i<=n;i++)\\n        {  \\n            temp*=place;\\n            ans+=temp;\\n            place--;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854141,
                "title": "c-solution-combinatorics-math-beats-time-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count Numbers with Unique Digits.\\nMemory Usage: 5.9 MB, less than 90.84% of C++ online submissions for Count Numbers with Unique Digits.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int arr[] = {1,9,9,8,7,6,5,4,3,2,1};\\n        int num = 1;\\n        int result = 0;    \\n        for(int i=0;i<=n;i++)\\n        {\\n            num = num * arr[i];\\n            result += num;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countNumbersWithUniqueDigits(int n) {\\n        \\n        int arr[] = {1,9,9,8,7,6,5,4,3,2,1};\\n        int num = 1;\\n        int result = 0;    \\n        for(int i=0;i<=n;i++)\\n        {\\n            num = num * arr[i];\\n            result += num;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822555,
                "title": "dynamic-programming-intuition-explanation",
                "content": "First question you might ask yourself is how/why is this problems even dynamic programming?\\n\\n**Intuition:**\\nGenerally speaking if there\\'s any problem which asks for count/number of ways, there\\'s a high chance the problem can be solved by dynamic programming. While definitely there are exceptions, however, the former statement at least gives you a direction to think if you\\'re completely blanked out.\\n\\nNow that we feel that the problem might be solved by DP, let\\'s go ahead and think about what the dp table would store.\\n\\n```Let dp[i] be the count of unique digits from 0 to i digits.```\\n\\nWhere would the answer lie? \\n```Ans: dp[n]```\\n\\nWhat would the base case be?\\n* ``` if i = 0, dp[0] = 1.```\\n* ```if i = 1, dp[1] = 10.```\\n\\nNow that we\\'ve got most of the things out of the way, let\\'s go ahead and take a look at the recurrence relation:\\nIf you\\'re little bit familiar with DP, you can kind of guess that for i > 1, it would be:\\n```dp[i] = dp[i - 1] + solve(i);```\\n\\nNow the important part is the ```solve(i) ``` function.\\nLet\\'s run through a couple of examples to figure out how ```solve(i)``` would work.\\n\\n```\\nsolve(i):\\n\\tif i = 2, what would be the count for unique 2 digits numbers\\n\\n\\t[pos1] [pos2] \\n\\t______ _______\\n\\n\\tSince [pos1] is MSB, we can have only digits from 1 to 9, thus there are 9 digits we can fill in [pos1]\\n\\tFor [pos2] we can ideally have 10 digits from 0 to 9 but since it has to be unique we can \\n\\thave 10 - (j - 1) digits, where j > 1 and j <= i in this case.\\n\\tThus for i = 2, we get [pos1] x [pos2] = 9 x 9 = 81.\\n\\n\\tHomework, Try i = 3 on your own, ans should be : 9 x 9 x 8. Why?\\n\\n```\\n\\nNow that we know what solve(i = 2) returns, plug it in ```dp[i] = dp[i - 1] + solve(i);``` and voila you\\'re done!\\n\\n```\\nC++ code:\\n\\nint solve(int n) {\\n int prod = 1;\\n for(int i = 1; i <= n; ++i) {\\n\\tif(i == 1)\\n\\t\\tprod *= 9;\\n\\telse\\n\\t\\tprod *= (10 - (i - 1));\\n  }\\n  return prod;\\n}\\n\\nint countNumbersWithUniqueDigits(int n) {\\n\\tvector < int > dp(n + 1);\\n\\tdp[0] = 1;\\n\\tif(n == 0)\\n\\t\\treturn dp[0];\\n\\tdp[1] = 10;\\n\\tfor(int i = 2; i <= n; ++i) {\\n\\t  int curr_sum = solve(i);\\n\\t  dp[i] = curr_sum + dp[i - 1];\\n\\t}\\n\\treturn dp[n];\\n}\\n```",
                "solutionTags": [],
                "code": "```Let dp[i] be the count of unique digits from 0 to i digits.```\n```Ans: dp[n]```\n``` if i = 0, dp[0] = 1.```\n```if i = 1, dp[1] = 10.```\n```dp[i] = dp[i - 1] + solve(i);```\n```solve(i) ```\n```solve(i)```\n```\\nsolve(i):\\n\\tif i = 2, what would be the count for unique 2 digits numbers\\n\\n\\t[pos1] [pos2] \\n\\t______ _______\\n\\n\\tSince [pos1] is MSB, we can have only digits from 1 to 9, thus there are 9 digits we can fill in [pos1]\\n\\tFor [pos2] we can ideally have 10 digits from 0 to 9 but since it has to be unique we can \\n\\thave 10 - (j - 1) digits, where j > 1 and j <= i in this case.\\n\\tThus for i = 2, we get [pos1] x [pos2] = 9 x 9 = 81.\\n\\n\\tHomework, Try i = 3 on your own, ans should be : 9 x 9 x 8. Why?\\n\\n```\n```dp[i] = dp[i - 1] + solve(i);```\n```\\nC++ code:\\n\\nint solve(int n) {\\n int prod = 1;\\n for(int i = 1; i <= n; ++i) {\\n\\tif(i == 1)\\n\\t\\tprod *= 9;\\n\\telse\\n\\t\\tprod *= (10 - (i - 1));\\n  }\\n  return prod;\\n}\\n\\nint countNumbersWithUniqueDigits(int n) {\\n\\tvector < int > dp(n + 1);\\n\\tdp[0] = 1;\\n\\tif(n == 0)\\n\\t\\treturn dp[0];\\n\\tdp[1] = 10;\\n\\tfor(int i = 2; i <= n; ++i) {\\n\\t  int curr_sum = solve(i);\\n\\t  dp[i] = curr_sum + dp[i - 1];\\n\\t}\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1833875,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1725454,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1825571,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1818030,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1571632,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2075658,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2014809,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1977316,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1953104,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2038376,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1833875,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1725454,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1825571,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1818030,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1571632,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2075658,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2014809,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1977316,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 1953104,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            },
            {
                "id": 2038376,
                "content": [
                    {
                        "username": "2003a54015",
                        "content": "Explanation:\\n\\nWe can solve this problem by using a simple mathematical formula. The formula is:\\n\\nf(0) = 1\\nf(1) = 10\\nf(2) = 9 * 9 + f(1)\\nf(3) = 9 * 9 * 8 + f(2)\\n...\\nf(n) = 9 * 9 * 8 * ... * (11 - n) + f(n-1)\\n\\nThe above formula calculates the number of unique digits that can be formed using n digits. We start with n=0 and return 1, as there is only one number with 0 digits (i.e., 0). For n=1, there are 10 unique digits (0-9). For n>1, we use the above formula to calculate the number of unique digits.\\n\\nThe Java code implementation follows the above formula. We start with ans=10, which is the number of unique digits for n=1. We then use a while loop to calculate the number of unique digits for n>1. We keep track of the number of unique digits and the number of available digits (9 for the first digit, 8 for the second digit, and so on). We then use the above formula to calculate the number of unique digits for n. Finally, we return the answer.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "use if conditions  \\n\\nif(n==1){\\nreturn 10;}\\nif(n==2) return 91;\\nif(n==3) return 739;\\nif(n==4) return 5275;\\nif(n==5) return 32491;\\nif(n==6) return 168571;\\nif(n==7) return 712891;\\nif(n==8) return 2345851;\\nreturn 1;"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "IQ>0^\\u221E"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "lol :)"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah bro question testcases :(;"
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "too much jugaad. :P"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Try to spot the pattern in the answers and write a short algorithm to add the required number to your answer for each power of 10"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "did not understand the problem can anyone elaborate it more. Like why we need n\\n "
                    },
                    {
                        "username": "albertfromsd",
                        "content": "take 10 to the power of n. Return the amount of numbers that do not have repeating digits.\\n\\nn=2 means 10^2 = 100.\\n\\nThe amount of numbers without repeated digits within the range of 1 to 100 is 91."
                    },
                    {
                        "username": "buaawjw",
                        "content": "There are only 9 test cases, which don't include cases when n >= 10."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "btw this question is little lame to be asked see the no. of testcases are so small that you can use else if ladder but I would say we should use some logic instead"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "there are no more unique numbers past n = 10"
                    },
                    {
                        "username": "papera",
                        "content": "and even if n>=10 its hard bounded at the result of n=9 anyways"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The hint is a total rubbish that puzzles you even more."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Full mathematical derivation and formula: https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3910861/c-dp-math-derived-o-1-time-two-solutions/"
                    },
                    {
                        "username": "MossTheBryophyter",
                        "content": "For the second example, why does n = 0 have an output of 1? I thought the output would be 0"
                    },
                    {
                        "username": "nzholdoshov",
                        "content": "10^0 is 1 so from 0 to 1 only one number - 0 (1 is excluded). The result will be only 1 unique number: 0."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3707748/approach-explained-memoization/\\nmathematically explained why the code works"
                    },
                    {
                        "username": "blvckmarker",
                        "content": "should be marked as easy"
                    }
                ]
            }
        ]
    },
    {
        "title": "Circular Array Loop",
        "question_content": "<p>You are playing a game involving a <strong>circular</strong> array of non-zero integers <code>nums</code>. Each <code>nums[i]</code> denotes the number of indices forward/backward you must move if you are located at index <code>i</code>:</p>\n\n<ul>\n\t<li>If <code>nums[i]</code> is positive, move <code>nums[i]</code> steps <strong>forward</strong>, and</li>\n\t<li>If <code>nums[i]</code> is negative, move <code>nums[i]</code> steps <strong>backward</strong>.</li>\n</ul>\n\n<p>Since the array is <strong>circular</strong>, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.</p>\n\n<p>A <strong>cycle</strong> in the array consists of a sequence of indices <code>seq</code> of length <code>k</code> where:</p>\n\n<ul>\n\t<li>Following the movement rules above results in the repeating index sequence <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code></li>\n\t<li>Every <code>nums[seq[j]]</code> is either <strong>all positive</strong> or <strong>all negative</strong>.</li>\n\t<li><code>k &gt; 1</code></li>\n</ul>\n\n<p>Return <code>true</code><em> if there is a <strong>cycle</strong> in </em><code>nums</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img1.jpg\" style=\"width: 402px; height: 289px;\" />\n<pre>\n<strong>Input:</strong> nums = [2,-1,1,2,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nWe can see the cycle 0 --&gt; 2 --&gt; 3 --&gt; 0 --&gt; ..., and all of its nodes are white (jumping in the same direction).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img2.jpg\" style=\"width: 402px; height: 390px;\" />\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3,-4,-5,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nThe only cycle is of size 1, so we return false.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img3.jpg\" style=\"width: 497px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,-1,5,1,4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nWe can see the cycle 0 --&gt; 1 --&gt; 0 --&gt; ..., and while it is of size &gt; 1, it has a node jumping forward and a node jumping backward, so <strong>it is not a cycle</strong>.\nWe can see the cycle 3 --&gt; 4 --&gt; 3 --&gt; ..., and all of its nodes are white (jumping in the same direction).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums[i] != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it in <code>O(n)</code> time complexity and <code>O(1)</code> extra space complexity?</p>\n",
        "solutions": [
            {
                "id": 94148,
                "title": "java-slow-fast-pointer-solution",
                "content": "Just think it as finding a loop in Linkedlist, except that loops with only 1 element do not count. Use a slow and fast pointer, slow pointer moves 1 step a time while fast pointer moves 2 steps a time. If there is a loop (fast == slow), we return true, else if we meet element with different directions, then the search fail, we set all elements along the way to 0. Because 0 is fail for sure so when later search meet 0 we know the search will fail.\\n\\n```java\\npublic class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            // slow/fast pointer\\n            int j = i, k = getIndex(i, nums);\\n            while (nums[k] * nums[i] > 0 && nums[getIndex(k, nums)] * nums[i] > 0) {\\n                if (j == k) {\\n                    // check for loop with only one element\\n                    if (j == getIndex(j, nums)) {\\n                        break;\\n                    }\\n                    return true;\\n                }\\n                j = getIndex(j, nums);\\n                k = getIndex(getIndex(k, nums), nums);\\n            }\\n            // loop not found, set all element along the way to 0\\n            j = i;\\n            int val = nums[i];\\n            while (nums[j] * val > 0) {\\n                int next = getIndex(j, nums);\\n                nums[j] = 0;\\n                j = next;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int getIndex(int i, int[] nums) {\\n        int n = nums.length;\\n        return i + nums[i] >= 0? (i + nums[i]) % n: n + ((i + nums[i]) % n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            // slow/fast pointer\\n            int j = i, k = getIndex(i, nums);\\n            while (nums[k] * nums[i] > 0 && nums[getIndex(k, nums)] * nums[i] > 0) {\\n                if (j == k) {\\n                    // check for loop with only one element\\n                    if (j == getIndex(j, nums)) {\\n                        break;\\n                    }\\n                    return true;\\n                }\\n                j = getIndex(j, nums);\\n                k = getIndex(getIndex(k, nums), nums);\\n            }\\n            // loop not found, set all element along the way to 0\\n            j = i;\\n            int val = nums[i];\\n            while (nums[j] * val > 0) {\\n                int next = getIndex(j, nums);\\n                nums[j] = 0;\\n                j = next;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int getIndex(int i, int[] nums) {\\n        int n = nums.length;\\n        return i + nums[i] >= 0? (i + nums[i]) % n: n + ((i + nums[i]) % n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395670,
                "title": "java-simple-dfs-o-n-beat-100-time-and-space",
                "content": "directed graph detect circle.\\nsimple DFS.\\nBecuase each node has only 1 child and each node is visited only once. The complexity is O(n).\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int[] color = new int[nums.length];\\n        for(int i = 0 ; i < nums.length ; i++) {\\n            if(color[i] == 0 && DFS(nums, color, i)) return true;\\n        }\\n        return false;\\n    }\\n    private boolean DFS(int[] nums, int[] color, int start) {\\n        //return true if find cycle\\n        if(color[start] == 2) return false;\\n        color[start] = 1;\\n        int next = start + nums[start];\\n        next = next % nums.length + nums.length;\\n        next %= nums.length;\\n        if(next == start || nums[next] * nums[start] < 0) {\\n            color[start] = 2;\\n            return false;\\n        }\\n        if(color[next] == 1) {\\n            color[start] = 2;\\n            return true;\\n        }\\n        if(DFS(nums, color, next)) return true;\\n        color[start] = 2;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int[] color = new int[nums.length];\\n        for(int i = 0 ; i < nums.length ; i++) {\\n            if(color[i] == 0 && DFS(nums, color, i)) return true;\\n        }\\n        return false;\\n    }\\n    private boolean DFS(int[] nums, int[] color, int start) {\\n        //return true if find cycle\\n        if(color[start] == 2) return false;\\n        color[start] = 1;\\n        int next = start + nums[start];\\n        next = next % nums.length + nums.length;\\n        next %= nums.length;\\n        if(next == start || nums[next] * nums[start] < 0) {\\n            color[start] = 2;\\n            return false;\\n        }\\n        if(color[next] == 1) {\\n            color[start] = 2;\\n            return true;\\n        }\\n        if(DFS(nums, color, next)) return true;\\n        color[start] = 2;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307542,
                "title": "c-too-much-confusion-right-see-this",
                "content": "I would like to share my approach.\\n**457. Circular Array Loop**\\nAs name suggest we have to find loop that exists in array, but the **loop exist** in **two direction** i.e., either in **left-to-right** or **right-to-left** direction.\\n\\nWell, we know there is one common algorithm to test whether a LinkedList / Array contains loop or not.\\n\\n``Slow & Fast pointer`` or ``Hare & Tortoise `` or ``Floyd\\'s cylce detection``, \\nfor more details [Click here](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_Tortoise_and_Hare)\\n\\nOur code starts with as usual like checking for loop in linked list.\\n```\\n/// linked list template\\n... \\nwhile(fast && fast->next){ \\n\\t/// both go in one direction, for this case left-to-right\\n\\tslow = slow->next;\\n\\tfast = fast->next->next;\\n\\tif(slow == fast){\\n\\t\\t/// loop exists\\n\\t}\\n}\\n...\\n```\\n\\n\\nNow we got the glimpse of ``slow & fast`` pointer.\\n**Note:** loop exists in both direction, we have to check this as well in while loop condition.\\n**Condition:** \\n``nums[slow]*nums[next(nums,fast)]>0 && nums[slow]*nums[next(nums,next(nums,fast))]>0``\\n\\nSee below code (Incomplete):\\n```\\n...\\n/// the condition for both direction\\nwhile(nums[slow]*nums[next(nums,fast)]>0 && nums[slow]*nums[next(nums,next(nums,fast))]>0){\\n\\tslow = next(nums,slow);\\n\\tfast = next(nums,next(nums,fast));int next(vector<int>& nums, int i){\\n        int n = nums.size();\\n        return (n+nums[i]+i)%n;\\n    }\\n\\tif(slow==fast){\\n\\t\\tif(slow==next(nums,slow)) // single length\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n}\\n...\\n```\\n**Note** above, ``next(nums, i) `` is defined as `` (n + nums[i] + i)%n ``. Here ``n`` is added extra to handle negative numbers (nums[i]).\\n\\nNow complete code is below, with some pre-processing of input array element, to handle cases\\nlike, \\n`` lengthOfArray = 4, and nums[i] = -9``\\nOR\\n`` lengthOfArray = 4, and nums[i] = 12``\\nNote: values are random.\\n\\n\\nNow **COMPLETE CODE:**\\n```\\nclass Solution {\\npublic:\\n    \\n    int next(vector<int>& nums, int i){\\n        int n = nums.size();\\n        return (n+nums[i]+i)%n;\\n    }\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        // we can use slow and fast pointer to check whether there is loop or not\\n        for(int &num: nums)\\n            num %= n;\\n        for(int i=0;i<n;i++){\\n            int slow = i,\\n                fast = i;\\n            while(nums[slow]*nums[next(nums,fast)]>0 && nums[slow]*nums[next(nums,next(nums,fast))]>0){\\n                slow = next(nums,slow);\\n                fast = next(nums,next(nums,fast));\\n                if(slow==fast){\\n                    if(slow==next(nums,slow)) // single length\\n                        return false;\\n                    return true;\\n                }\\n            }\\n\\t\\t\\t/// DONOT TRAVERSE WHERE THERE IS NO PATH TO GET LOOP.\\n            int j = i;\\n            int val = nums[i];\\n            while (nums[j] * val > 0) {\\n                int nexx = next(nums,j);\\n                nums[j] = 0;\\n                j = nexx;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**Note:** Please pardon my English.\\nThank you!",
                "solutionTags": [],
                "code": "```\\n/// linked list template\\n... \\nwhile(fast && fast->next){ \\n\\t/// both go in one direction, for this case left-to-right\\n\\tslow = slow->next;\\n\\tfast = fast->next->next;\\n\\tif(slow == fast){\\n\\t\\t/// loop exists\\n\\t}\\n}\\n...\\n```\n```\\n...\\n/// the condition for both direction\\nwhile(nums[slow]*nums[next(nums,fast)]>0 && nums[slow]*nums[next(nums,next(nums,fast))]>0){\\n\\tslow = next(nums,slow);\\n\\tfast = next(nums,next(nums,fast));int next(vector<int>& nums, int i){\\n        int n = nums.size();\\n        return (n+nums[i]+i)%n;\\n    }\\n\\tif(slow==fast){\\n\\t\\tif(slow==next(nums,slow)) // single length\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n}\\n...\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int next(vector<int>& nums, int i){\\n        int n = nums.size();\\n        return (n+nums[i]+i)%n;\\n    }\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        // we can use slow and fast pointer to check whether there is loop or not\\n        for(int &num: nums)\\n            num %= n;\\n        for(int i=0;i<n;i++){\\n            int slow = i,\\n                fast = i;\\n            while(nums[slow]*nums[next(nums,fast)]>0 && nums[slow]*nums[next(nums,next(nums,fast))]>0){\\n                slow = next(nums,slow);\\n                fast = next(nums,next(nums,fast));\\n                if(slow==fast){\\n                    if(slow==next(nums,slow)) // single length\\n                        return false;\\n                    return true;\\n                }\\n            }\\n\\t\\t\\t/// DONOT TRAVERSE WHERE THERE IS NO PATH TO GET LOOP.\\n            int j = i;\\n            int val = nums[i];\\n            while (nums[j] * val > 0) {\\n                int nexx = next(nums,j);\\n                nums[j] = 0;\\n                j = nexx;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167525,
                "title": "python-1-pointer-o-n-time-o-1-space",
                "content": "not a real O(1) space solution if modifying input is not allowed.\\n```\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums or len(nums) < 2:\\n            return False\\n        \\n        n = len(nums)\\n        for i in range(n):           \\n            if type(nums[i]) != int: # visited element\\n                continue\\n            if nums[i] % n == 0: # self-loop\\n                continue\\n            \\n            direction = (nums[i] > 0) # loop direction, cannot be changed midway\\n            \\n            mark = str(i)\\n            while (type(nums[i]) == int) and (direction ^ (nums[i] < 0)) and (nums[i] % n != 0):\\n                jump = nums[i]\\n                nums[i] = mark\\n                i = (i + jump) % n\\n                \\n            if nums[i] == mark:\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums or len(nums) < 2:\\n            return False\\n        \\n        n = len(nums)\\n        for i in range(n):           \\n            if type(nums[i]) != int: # visited element\\n                continue\\n            if nums[i] % n == 0: # self-loop\\n                continue\\n            \\n            direction = (nums[i] > 0) # loop direction, cannot be changed midway\\n            \\n            mark = str(i)\\n            while (type(nums[i]) == int) and (direction ^ (nums[i] < 0)) and (nums[i] % n != 0):\\n                jump = nums[i]\\n                nums[i] = mark\\n                i = (i + jump) % n\\n                \\n            if nums[i] == mark:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784810,
                "title": "python-fast-slow-pointers-o-n-time-o-1-space",
                "content": "Hello,\\n\\nHere is my solution.\\n\\nIntuition:\\n* Scan all cells of the list\\n* For each cell `i`, \\n\\t* Use `Fast-Slow Pointers` to check if there is a cycle starting from `i`\\n\\t* If there is no cycle from cell `i`, mark visited (nums[j] = 0) all cells that belong to the path starting from cell `i`\\n\\nComplexity Analysis:\\n* Time Complexity: O(|nums|):\\n\\t* Each cell is visited at most twice\\n\\t* The 1st. visit is while we\\'re checking if there is a cycle\\n\\t* The 2nd. visit is when we mark `visited` cells that do no belong to a cycle\\n            \\n* Space Complexity: O(1)\\n\\n```python\\ndef __init__(self):\\n        self.__visited = lambda x: not x # a cell i is visited when nums[i] = 0\\n\\ndef circularArrayLoop(self, nums: List[int]) -> bool:\\n        \\n        for i in range(len(nums)):\\n            if self.__visited(nums[i]):\\n                continue\\n            \\n            direction = nums[i] > 0\\n            \\n            # 1. Check if there is a cycle starting from i\\n            slow = fast = i\\n            while not (self.__visited(nums[slow]) or self.__visited(nums[fast])):\\n                \\n                slow = self.__next(nums, slow, direction)\\n                fast = self.__next(nums, self.__next(nums, fast, direction), direction)\\n                \\n                if slow == -1 or fast == -1:\\n                    break\\n                \\n                elif slow == fast:\\n                    return True\\n            \\n            # 2. Mark visited all cells that belong to the path starting from i\\n            slow = i\\n            while self.__next(nums, slow, direction) != -1:\\n                nums[slow], slow = 0, self.__next(nums, slow, direction)\\n            \\n        return False\\n        \\n    def __next(self, nums, idx, direction):\\n        if idx == -1: # To handle the case of next(next(fast)) = next(-1) = -1\\n            return -1\\n                \\n        elif (nums[idx] > 0) != direction: # check the direction\\n            return -1\\n        \\n        next_idx = (idx + nums[idx]) % len(nums)\\n        if next_idx < 0:\\n            next_idx += len(nums)\\n        \\n        return -1 if next_idx == idx else next_idx\\n    \\t\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef __init__(self):\\n        self.__visited = lambda x: not x # a cell i is visited when nums[i] = 0\\n\\ndef circularArrayLoop(self, nums: List[int]) -> bool:\\n        \\n        for i in range(len(nums)):\\n            if self.__visited(nums[i]):\\n                continue\\n            \\n            direction = nums[i] > 0\\n            \\n            # 1. Check if there is a cycle starting from i\\n            slow = fast = i\\n            while not (self.__visited(nums[slow]) or self.__visited(nums[fast])):\\n                \\n                slow = self.__next(nums, slow, direction)\\n                fast = self.__next(nums, self.__next(nums, fast, direction), direction)\\n                \\n                if slow == -1 or fast == -1:\\n                    break\\n                \\n                elif slow == fast:\\n                    return True\\n            \\n            # 2. Mark visited all cells that belong to the path starting from i\\n            slow = i\\n            while self.__next(nums, slow, direction) != -1:\\n                nums[slow], slow = 0, self.__next(nums, slow, direction)\\n            \\n        return False\\n        \\n    def __next(self, nums, idx, direction):\\n        if idx == -1: # To handle the case of next(next(fast)) = next(-1) = -1\\n            return -1\\n                \\n        elif (nums[idx] > 0) != direction: # check the direction\\n            return -1\\n        \\n        next_idx = (idx + nums[idx]) % len(nums)\\n        if next_idx < 0:\\n            next_idx += len(nums)\\n        \\n        return -1 if next_idx == idx else next_idx\\n    \\t\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 232417,
                "title": "python-simple-solution-beats-100-with-o-1-space",
                "content": "When we start a loop, as the problem description says, every item in the loop should have same sign, and when some loop have length more than `len(nums)` then it\\'s indeed a circular loop, then we can avoid to have auxiliary storage\\n\\n```python\\nclass Solution:\\n    def circularArrayLoop(self, nums: \\'List[int]\\') -> \\'bool\\':\\n        n = len(nums)\\n        for i, num in enumerate(nums):\\n            linkLength = 0\\n            j = i\\n            forward = nums[j] > 0\\n            while True:\\n                if (forward and nums[j] < 0) or (not forward and nums[j] > 0):\\n                    break\\n                nextj = (j + nums[j] + n) % n\\n                if nextj == j:\\n                    break\\n                j = nextj\\n                linkLength += 1\\n                if linkLength > n:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def circularArrayLoop(self, nums: \\'List[int]\\') -> \\'bool\\':\\n        n = len(nums)\\n        for i, num in enumerate(nums):\\n            linkLength = 0\\n            j = i\\n            forward = nums[j] > 0\\n            while True:\\n                if (forward and nums[j] < 0) or (not forward and nums[j] > 0):\\n                    break\\n                nextj = (j + nums[j] + n) % n\\n                if nextj == j:\\n                    break\\n                j = nextj\\n                linkLength += 1\\n                if linkLength > n:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393852,
                "title": "0ms-c-o-n-time-o-1-extra-space-short-and-clean",
                "content": "To get O(1) extra space, I modified the array to mark the visited elements. But it\\'s not that naive, some creativity is indeed needed.\\n\\nThe algorithm simply starts at each index, and then starts jumping based on the value as the problem states, until it finds a loop or becomes an invalid path.\\nTo detect a loop, visited index are marked by a number designated as the \"visited marker\". If the algo meets the \"visited marker\" again, that means a loop is detected.\\n\\nHowever, it won\\'t work in this naive way. Why? \\nLet\\'s say you use 0 as the \"visited marker\", that means if you see 0 again, that means a loop is dected. It sounds good, but what if no loop is found?\\nYou need to find the next non-0 element (unvisited elements from last round of path tracing) and start tracing the path again, but this time, when you see a 0, you don\\'t know this is the \"visited marker\" from last round or this is the one you used in this round. And this matters:\\nIf this is the \"visited marker\" from last round, then you are on the bad path, no need to continue, you can conclude no loop is found in this round. \\nIf this is the \"visited marker\" from this round\\'s previous steps, then that means you detect a loop, and you should return true!\\n\\nSo you need a \"visited marker\" for each round. And all \"visited markers\" from earlier rounds should be considered on an invalid path. \\nHow? The input number can be any positive and negative number, you have only 0 to use as the \"visited marker\".\\nSolution:\\nmake all nums[i] %= n; It won\\'t affect the result.\\nSo all numbers <= -n or >= n are free, and you can use them as the \"visited number\".\\nTo make the code simpler, I decided to use n, 2n, 3n, ..., i * n as the \"visited number\" for each round. In i th round, only revisiting a value i * n means a loop.\\nAnd at i\\'s round, revisiting any previous j * n (j < i) means running back on an invalid path.\\n\\nSince everything is done in place, it\\'s O(1) extra space.\\nSince all numbers are only marked by \"visited markers\" once, it\\'s O(n) time. \\n\\n```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int j = 0; j < n; ++ j) \\n            nums[j] %= n; // After this, no number is > n or < -n.\\n        for (int j = 0; j < n; ++ j) {\\n            int i = j, last_i = 0;\\n            bool is_forward = nums[i] > 0;\\n            while (nums[i] % n != 0 && nums[i] > 0 == is_forward) {\\n                last_i = i;\\n                i = (i + nums[i] + n) % n;\\n                nums[last_i] = (j + 1) * n;\\n                if (nums[i] == (j + 1) * n) //each round, use a different number as the \"visited marker\".\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int j = 0; j < n; ++ j) \\n            nums[j] %= n; // After this, no number is > n or < -n.\\n        for (int j = 0; j < n; ++ j) {\\n            int i = j, last_i = 0;\\n            bool is_forward = nums[i] > 0;\\n            while (nums[i] % n != 0 && nums[i] > 0 == is_forward) {\\n                last_i = i;\\n                i = (i + nums[i] + n) % n;\\n                nums[last_i] = (j + 1) * n;\\n                if (nums[i] == (j + 1) * n) //each round, use a different number as the \"visited marker\".\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525908,
                "title": "simple-o-n-python-solution-8-lines-without-spacing-wrapping",
                "content": "My tripping points finding this solution, mostly from me not reading the question throughly enough:\\n* Cycles can start at any index\\n* Cycles of one element to itself don\\'t count\\n\\nKey tricks that make this work:\\n* Store the mapping from each index to its next one to save computing every time\\n* Compute the path starting at each index in increments\\n* Filter out an index in a given increment if the direction changes or the next index is already filtered out\\n* Filter out 1 element cycles as part of defining the first increment\\n\\n```\\nclass Solution: \\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n            \\n        numLength = len(nums)\\n        indexToNext = {index: (index + value) % numLength for index, value in enumerate(nums)}\\n        increment = {key: value for key, value in indexToNext.items() if key != value}\\n          \\n        while len(increment) > 0:\\n            \\n            if any(index == nextIndex for index, nextIndex in increment.items()):\\n                return True\\n            \\n            increment = {index: indexToNext[nextIndex] \\n                         for index, nextIndex in increment.items() \\n                         if nums[index] * nums[nextIndex] > 0 and nextIndex in increment}            \\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution: \\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n            \\n        numLength = len(nums)\\n        indexToNext = {index: (index + value) % numLength for index, value in enumerate(nums)}\\n        increment = {key: value for key, value in indexToNext.items() if key != value}\\n          \\n        while len(increment) > 0:\\n            \\n            if any(index == nextIndex for index, nextIndex in increment.items()):\\n                return True\\n            \\n            increment = {index: indexToNext[nextIndex] \\n                         for index, nextIndex in increment.items() \\n                         if nums[index] * nums[nextIndex] > 0 and nextIndex in increment}            \\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94187,
                "title": "java-solution-easy-to-follow",
                "content": "This algo divides responsibilities in a way that I believe makes it easier to follow.  It is also non-destructive to the input data.  The \"next\" function detects cases that we can abandon, while the main code focuses on finding a loop.\\n\\nThe main loop is a simple slow/fast pointer search to find loops.  The next function uses Integer object, so that it can pass or return null as an end case.  And null returns end the search.\\n\\nNull can be returned from next in the following cases:\\n1.  When input pos value is null (fast pointer that double-calls would cause this)\\n2.  When direction changes.  Direction is captured on the first step in the \"dir\" value, and then passed to all follow-on calls to next.  So the first time the product of dir and num[pos] is less than zero, we know we've changed direction, so return null.\\n3.  When a \"self pointer\" is found, meaning the next value from pos is the same index as pos.\\n\\n```\\npublic class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        boolean found = false;\\n\\n        for ( int n=0; n<nums.length; n++ ) {\\n            Integer ps = n;\\n            Integer pf = next(nums, 0, n);\\n            int dir = nums[n];\\n\\n            while ( ps != null && pf != null && ps != pf ) {\\n                ps = next(nums, dir, ps);\\n                pf = next(nums, dir, next(nums, dir, pf));\\n            }\\n\\n            if ( ps != null && ps == pf ) {\\n                found = true;\\n                break;\\n            }\\n        }\\n\\n        return found;\\n    }\\n\\n    Integer next(int[] nums, int dir, Integer pos) {\\n        if ( pos == null ) return null; // null, return null\\n        if ( dir * nums[pos] < 0 ) return null; // change in direction, return null\\n\\n        Integer next = (pos + nums[pos]) % nums.length;\\n        if ( next < 0 ) next += nums.length; // wrap negative\\n\\n        if ( next == pos ) next = null; // self-pointer, return null\\n        return next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        boolean found = false;\\n\\n        for ( int n=0; n<nums.length; n++ ) {\\n            Integer ps = n;\\n            Integer pf = next(nums, 0, n);\\n            int dir = nums[n];\\n\\n            while ( ps != null && pf != null && ps != pf ) {\\n                ps = next(nums, dir, ps);\\n                pf = next(nums, dir, next(nums, dir, pf));\\n            }\\n\\n            if ( ps != null && ps == pf ) {\\n                found = true;\\n                break;\\n            }\\n        }\\n\\n        return found;\\n    }\\n\\n    Integer next(int[] nums, int dir, Integer pos) {\\n        if ( pos == null ) return null; // null, return null\\n        if ( dir * nums[pos] < 0 ) return null; // change in direction, return null\\n\\n        Integer next = (pos + nums[pos]) % nums.length;\\n        if ( next < 0 ) next += nums.length; // wrap negative\\n\\n        if ( next == pos ) next = null; // self-pointer, return null\\n        return next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354601,
                "title": "java-3-progressive-methods-to-o-n-o-1-memory-beats-98",
                "content": "**Method 1:** Floyd\\'s Cycle Detection Algorithm. Fast and Slow pointers\\n**T/S:** O(n\\xB2)/O(1)\\n```\\npublic boolean circularArrayLoop(int[] nums) {\\n\\tfor (var i = 0; i < nums.length; i++) {\\n\\t\\tvar direction = Math.signum(nums[i]);\\n\\t\\tvar slow = i;\\n\\t\\tvar fast = i;\\n\\n\\t\\tdo {\\n\\t\\t\\tslow = getNextIndex(nums, direction, slow);\\n\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (fast != -1)\\n\\t\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t} while (slow != -1 && fast != -1 && slow != fast);\\n\\n\\t\\tif (slow != -1 && slow == fast)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\n/**\\n* Math.signum(x) will return 1, -1, 0 depending on whether x is positive, negative or zero.\\n* value of currentDirection * direction can be:\\n* < 0, means that currentDirection and direction are of opposite signs, and thus opposite in nature, e.g. left/right, right/left\\n* > 0, means they\\'re of the same sign, e.g. left/left, right/right\\n*  0, means at least one of them is zero. For this problem, its not a possibility to have 0 as direction\\n*/\\nprivate int getNextIndex(int[] nums, float direction, int i) {\\n\\tvar currentDirection = Math.signum(nums[i]);\\n\\tif (currentDirection * direction < 0)\\n\\t\\treturn -1;\\n\\tvar n = nums.length;\\n\\tvar nextIndex = (i + nums[i]) % n;\\n\\tif (nextIndex < 0)\\n\\t\\tnextIndex += n;\\n\\treturn nextIndex == i ? -1 : nextIndex;\\n}\\n```\\n\\n**Method 2:** Inject memoization in method 1. Each index will thus be evaluated for cycle just once.\\n**T/S:** O(n)/O(n)\\n```\\npublic boolean circularArrayLoop(int[] nums) {    \\n    var n = nums.length;\\n\\tvar notCycles = new HashSet<Integer>(n); \\n\\t\\n\\tfor (var i = 0; i < n; i++) {\\n\\t\\tvar direction = Math.signum(nums[i]);\\n\\t\\tvar slow = i;\\n\\t\\tvar fast = i;\\n\\n\\t\\tdo {\\n\\t\\t\\tslow = getNextIndex(nums, direction, slow);\\n\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (fast != -1)\\n\\t\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (notCycles.contains(slow) || notCycles.contains(fast))\\n\\t\\t\\t\\tbreak;\\n\\t\\t} while (slow != -1 && fast != -1 && slow != fast);\\n\\n\\t\\tif (slow != -1 && slow == fast)\\n\\t\\t\\treturn true;\\n\\t\\tnotCycles.add(i);\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Method 3:** Use input array for memoization. I think its O(n) but feel free to chime in.\\n**T/S:** O(n)/O(1). Memory beats 98%\\n```\\npublic boolean circularArrayLoop(int[] nums) {\\n\\tfor (var i = 0; i < nums.length; i++) {\\n\\t\\tvar direction = Math.signum(nums[i]);\\n\\t\\tvar slow = i;\\n\\t\\tvar fast = i;\\n\\n\\t\\tdo {\\n\\t\\t\\tslow = getNextIndex(nums, direction, slow);\\n\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (fast != -1)\\n\\t\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (fast == -1 || nums[slow] == 0 || nums[fast] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t} while (slow != fast);\\n\\n\\t\\tif (slow != -1 && slow == fast) \\n\\t\\t\\treturn true;\\n\\t\\tnums[i] = 0;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\npublic boolean circularArrayLoop(int[] nums) {\\n\\tfor (var i = 0; i < nums.length; i++) {\\n\\t\\tvar direction = Math.signum(nums[i]);\\n\\t\\tvar slow = i;\\n\\t\\tvar fast = i;\\n\\n\\t\\tdo {\\n\\t\\t\\tslow = getNextIndex(nums, direction, slow);\\n\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (fast != -1)\\n\\t\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t} while (slow != -1 && fast != -1 && slow != fast);\\n\\n\\t\\tif (slow != -1 && slow == fast)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\n/**\\n* Math.signum(x) will return 1, -1, 0 depending on whether x is positive, negative or zero.\\n* value of currentDirection * direction can be:\\n* < 0, means that currentDirection and direction are of opposite signs, and thus opposite in nature, e.g. left/right, right/left\\n* > 0, means they\\'re of the same sign, e.g. left/left, right/right\\n*  0, means at least one of them is zero. For this problem, its not a possibility to have 0 as direction\\n*/\\nprivate int getNextIndex(int[] nums, float direction, int i) {\\n\\tvar currentDirection = Math.signum(nums[i]);\\n\\tif (currentDirection * direction < 0)\\n\\t\\treturn -1;\\n\\tvar n = nums.length;\\n\\tvar nextIndex = (i + nums[i]) % n;\\n\\tif (nextIndex < 0)\\n\\t\\tnextIndex += n;\\n\\treturn nextIndex == i ? -1 : nextIndex;\\n}\\n```\n```\\npublic boolean circularArrayLoop(int[] nums) {    \\n    var n = nums.length;\\n\\tvar notCycles = new HashSet<Integer>(n); \\n\\t\\n\\tfor (var i = 0; i < n; i++) {\\n\\t\\tvar direction = Math.signum(nums[i]);\\n\\t\\tvar slow = i;\\n\\t\\tvar fast = i;\\n\\n\\t\\tdo {\\n\\t\\t\\tslow = getNextIndex(nums, direction, slow);\\n\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (fast != -1)\\n\\t\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (notCycles.contains(slow) || notCycles.contains(fast))\\n\\t\\t\\t\\tbreak;\\n\\t\\t} while (slow != -1 && fast != -1 && slow != fast);\\n\\n\\t\\tif (slow != -1 && slow == fast)\\n\\t\\t\\treturn true;\\n\\t\\tnotCycles.add(i);\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\npublic boolean circularArrayLoop(int[] nums) {\\n\\tfor (var i = 0; i < nums.length; i++) {\\n\\t\\tvar direction = Math.signum(nums[i]);\\n\\t\\tvar slow = i;\\n\\t\\tvar fast = i;\\n\\n\\t\\tdo {\\n\\t\\t\\tslow = getNextIndex(nums, direction, slow);\\n\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (fast != -1)\\n\\t\\t\\t\\tfast = getNextIndex(nums, direction, fast);\\n\\t\\t\\tif (fast == -1 || nums[slow] == 0 || nums[fast] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t} while (slow != fast);\\n\\n\\t\\tif (slow != -1 && slow == fast) \\n\\t\\t\\treturn true;\\n\\t\\tnums[i] = 0;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1317119,
                "title": "python-3-short-python-set-explanation",
                "content": "### Explanation\\n- Not the most efficient solution, but it\\'s one of the cleanest\\n- Time: `O(n)`, Space `O(n)`\\n- Note: **The starting index can be any index, NOT zero only**\\n- Take each unvisited index and start traverse, mark as visited at the meantime\\n- If sign changes or cycle at itself, break the loop; otherwise, if revisited an index, return True\\n### Implementation\\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        n, visited = len(nums), set()\\n        for i in range(n):\\n            if i not in visited:\\n                local_s = set()\\n                while True:\\n                    if i in local_s: return True\\n                    if i in visited: break          # credit to @crazyhyz, add this condition to avoid revisited\\n                    visited.add(i)\\n                    local_s.add(i)\\n                    prev, i = i, (i + nums[i]) % n\\n                    if prev == i or (nums[i] > 0) != (nums[prev] > 0): break\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        n, visited = len(nums), set()\\n        for i in range(n):\\n            if i not in visited:\\n                local_s = set()\\n                while True:\\n                    if i in local_s: return True\\n                    if i in visited: break          # credit to @crazyhyz, add this condition to avoid revisited\\n                    visited.add(i)\\n                    local_s.add(i)\\n                    prev, i = i, (i + nums[i]) % n\\n                    if prev == i or (nums[i] > 0) != (nums[prev] > 0): break\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94155,
                "title": "two-pass-o-n-solution-by-marking-failed-loop-by-zero",
                "content": "hopefully this isn't too slow, haven't spent much time improving it. The basic idea is to detect a loop by maintaining a one-step and a two-step pointers, just like an old problem from leetcode. And each time a possible attempt failed we mark every index on the path by zero, since zero is guaranteed  to fail. Since the problem asks only forward of backward solution we simply run it for positive indices and negative indices twice.\\n\\nBy the way, the problem states that the array has only pos and neg numbers, which is apparently a little inaccurate. The presence of zero though doesn't seem to cause much problem.\\n\\n\\n\\n      class Solution {\\n      public:\\n          bool circularArrayLoop(vector<int>& nums) {\\n      \\t\\tint n = nums.size();\\n\\n                    // check for zero\\n                    for(auto i : nums) if(i==0) return false;\\n\\n      \\t\\t// forward:\\n      \\t\\tfor(int i = 0; i < n; i++) {\\n      \\t\\t\\tif(nums[i] <= 0 || nums[i] == n) continue;\\n      \\t\\t\\tint one = i;\\n      \\t\\t\\tint two = i;\\n      \\t\\t\\tint m = 2*n;\\n      \\t\\t\\twhile(m-- > 0) {\\n      \\t\\t\\t\\tint jump_one = (one + nums[one]) % n;\\n      \\t\\t\\t\\tif(nums[jump_one] <= 0 || jump_one == one){\\n      \\t\\t\\t\\t\\tbreak;\\n      \\t\\t\\t\\t}\\n      \\t\\t\\t\\tone = jump_one;\\n      \\n      \\t\\t\\t\\tint jump_two = (two+nums[two]) % n;\\n      \\t\\t\\t\\tif(nums[jump_two] <= 0 || jump_two == two) {\\n      \\t\\t\\t\\t\\tbreak;\\n      \\t\\t\\t\\t}\\n      \\t\\t\\t\\ttwo = jump_two;\\n      \\n      \\t\\t\\t\\tjump_two = (two+nums[two]) % n;\\n      \\t\\t\\t\\tif(nums[jump_two] <= 0 || jump_two == two) {\\n      \\t\\t\\t\\t\\tbreak;\\n      \\t\\t\\t\\t}\\n      \\t\\t\\t\\ttwo = jump_two;\\n      \\n      \\t\\t\\t\\tif(one == two) return true;\\n      \\t\\t\\t}\\n      \\t\\t\\t// no forward for this chain\\n      \\t\\t\\tone = i;\\n      \\t\\t\\twhile(nums[one] > 0) {\\n      \\t\\t\\t\\tint t = nums[one];\\n      \\t\\t\\t\\tnums[one] = 0;\\n      \\t\\t\\t\\tone = (one + t) % n;\\n      \\t\\t\\t}\\n      \\t\\t}\\n      \\n      \\n      \\t\\t// backward:\\n      \\t\\tfor(int i = n-1; i >= 0; i--) {\\n      \\t\\t\\tif(nums[i] >= 0 || nums[i] == n) continue;\\n      \\t\\t\\tint one = i;\\n      \\t\\t\\tint two = i;\\n      \\t\\t\\tint m = 2*n;\\n      \\t\\t\\twhile(m-- > 0) {\\n      \\t\\t\\t\\tint jump_one = ((one + nums[one]) % n + n) % n;\\n      \\t\\t\\t\\tif(nums[jump_one] >= 0 || jump_one == one){\\n      \\t\\t\\t\\t\\tbreak;\\n      \\t\\t\\t\\t}\\n      \\t\\t\\t\\tone = jump_one;\\n      \\n      \\t\\t\\t\\tint jump_two = ((two+nums[two]) % n + n) % n;\\n      \\t\\t\\t\\tif(nums[jump_two] >= 0 || jump_two == two) {\\n      \\t\\t\\t\\t\\tbreak;\\n      \\t\\t\\t\\t}\\n      \\t\\t\\t\\ttwo = jump_two;\\n      \\n      \\t\\t\\t\\tjump_two = ((two+nums[two]) % n + n ) % n;\\n      \\t\\t\\t\\tif(nums[jump_two] >= 0 || jump_two == two) {\\n      \\t\\t\\t\\t\\tbreak;\\n      \\t\\t\\t\\t}\\n      \\t\\t\\t\\ttwo = jump_two;\\n      \\n      \\t\\t\\t\\tif(one == two) return true;\\n      \\t\\t\\t}\\n      \\t\\t\\t// no backward for this chain\\n      \\t\\t\\tone = i;\\n      \\t\\t\\twhile(nums[one] < 0) {\\n      \\t\\t\\t\\tint t  = nums[one];\\n      \\t\\t\\t\\tnums[one] = 0;\\n      \\t\\t\\t\\tone = ((one + t) % n + n) % n;\\n      \\t\\t\\t}\\n      \\t\\t}\\n      \\n      \\t\\treturn false;\\n          }\\n      };",
                "solutionTags": [],
                "code": "class Solution {\\n      public:\\n          bool circularArrayLoop(vector<int>& nums) {\\n      \\t\\tint n = nums.size();\\n\\n                    // check for zero\\n                    for(auto i : nums) if(i==0) return false;\\n\\n      \\t\\t// forward:\\n      \\t\\tfor(int i = 0; i < n; i++) {\\n      \\t\\t\\tif(nums[i] <= 0 || nums[i] == n) continue;\\n      \\t\\t\\tint one = i;\\n      \\t\\t\\tint two = i;\\n      \\t\\t\\tint m = 2*n;\\n      \\t\\t\\twhile(m-- > 0) {\\n      \\t\\t\\t\\tint jump_one = (one + nums[one]) % n;\\n      \\t\\t\\t\\tif(nums[jump_one] <= 0 || jump_one == one){\\n      \\t\\t\\t\\t\\tbreak;\\n      \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 637800,
                "title": "javascript-solution-easy-to-understand-with-comments",
                "content": "Check for every index if loop exist using slow and fast ptr, getNextPosition returns the next position. If a cycle condition breaks, it returns -1\\n\\n```\\n//Returns -1 for exit condition\\nfunction getNextPosition(arr, index, isForward) {\\n    //movements in a cycle must all follow a single direction. Cycle must not consist of both forward and backward movements.\\n    let direction = arr[index] >= 0;\\n    if(direction !== isForward) return -1;\\n\\n    let nextIndex = (arr[index] + index)% arr.length;\\n    \\n    //handle -ve\\n    if(nextIndex < 0) nextIndex = nextIndex + arr.length;\\n    \\n    //one element loop\\n    if(nextIndex === index) return -1;\\n    return nextIndex;\\n}\\n\\nvar circularArrayLoop = function(nums) {\\n    let n = nums.length;\\n    if(n <= 1) return false;\\n    let i = 0;\\n    let j = 0;\\n    for(let i = 0; i< n; i++) {\\n        let slow, fast;\\n        slow = fast = i;\\n        let isForward = nums[i] > 0 ? true : false\\n        while(true) {\\n            slow = getNextPosition(nums, slow, isForward)\\n            if(slow === -1) break;\\n\\n            fast = getNextPosition(nums, fast, isForward)\\n            if(fast === -1) break;\\n            \\n            fast = getNextPosition(nums, fast, isForward)\\n            if(fast === -1) break;\\n            \\n            if(slow === fast) return true;\\n        }\\n    }\\n    return false;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Check for every index if loop exist using slow and fast ptr, getNextPosition returns the next position. If a cycle condition breaks, it returns -1\\n\\n```\\n//Returns -1 for exit condition\\nfunction getNextPosition(arr, index, isForward) {\\n    //movements in a cycle must all follow a single direction. Cycle must not consist of both forward and backward movements.\\n    let direction = arr[index] >= 0;\\n    if(direction !== isForward) return -1;\\n\\n    let nextIndex = (arr[index] + index)% arr.length;\\n    \\n    //handle -ve\\n    if(nextIndex < 0) nextIndex = nextIndex + arr.length;\\n    \\n    //one element loop\\n    if(nextIndex === index) return -1;\\n    return nextIndex;\\n}\\n\\nvar circularArrayLoop = function(nums) {\\n    let n = nums.length;\\n    if(n <= 1) return false;\\n    let i = 0;\\n    let j = 0;\\n    for(let i = 0; i< n; i++) {\\n        let slow, fast;\\n        slow = fast = i;\\n        let isForward = nums[i] > 0 ? true : false\\n        while(true) {\\n            slow = getNextPosition(nums, slow, isForward)\\n            if(slow === -1) break;\\n\\n            fast = getNextPosition(nums, fast, isForward)\\n            if(fast === -1) break;\\n            \\n            fast = getNextPosition(nums, fast, isForward)\\n            if(fast === -1) break;\\n            \\n            if(slow === fast) return true;\\n        }\\n    }\\n    return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 246640,
                "title": "python-simple-o-n-by-union-find-set",
                "content": "1. by union-find: for each edge (i,j), we union them when both i and j are in the same direction; if there\\'s a loop, there must be an edge(i, j) where j and i have already been connected.\\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: \\'List[int]\\') -> \\'bool\\':\\n        n = len(nums)\\n        parent = dict((i, i) for i in range(n))\\n\\n        def find(i):\\n            if parent[i] != i:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n        for i, v in enumerate(nums):\\n            j = (i + v) % n\\n            if i != j and nums[j]*nums[i] > 0:\\n                ri, rj = find(i), find(j)\\n                if ri == rj:\\n                    return True\\n                parent[ri] = rj\\n        return False\\n```\\n\\n\\n2. another alternative: walk along and use set to check directly\\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: \\'List[int]\\') -> \\'bool\\':\\n        n, done = len(nums), set()\\n        for i in range(n):\\n            if i in done: continue\\n            j, cur = i, set()\\n            while j not in cur and j not in done and nums[i]*nums[j] > 0:\\n                cur.add(j)\\n                j = (j+nums[j]) % n\\n            if j in cur and nums[j] % n != 0:\\n                return True\\n            done = done.union(cur)\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: \\'List[int]\\') -> \\'bool\\':\\n        n = len(nums)\\n        parent = dict((i, i) for i in range(n))\\n\\n        def find(i):\\n            if parent[i] != i:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n        for i, v in enumerate(nums):\\n            j = (i + v) % n\\n            if i != j and nums[j]*nums[i] > 0:\\n                ri, rj = find(i), find(j)\\n                if ri == rj:\\n                    return True\\n                parent[ri] = rj\\n        return False\\n```\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: \\'List[int]\\') -> \\'bool\\':\\n        n, done = len(nums), set()\\n        for i in range(n):\\n            if i in done: continue\\n            j, cur = i, set()\\n            while j not in cur and j not in done and nums[i]*nums[j] > 0:\\n                cur.add(j)\\n                j = (j+nums[j]) % n\\n            if j in cur and nums[j] % n != 0:\\n                return True\\n            done = done.union(cur)\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94233,
                "title": "0ms-c-sol",
                "content": "j1 is slow pointer, j2 is fast pointer.\\n\\nfor each element, check if j1 and j2 can meet again. dir variable is to record the loop direction.\\n\\n```\\n    bool circularArrayLoop(vector<int>& nums) {\\n        bool loop = false;\\n        for (int i = 0; i < nums.size() && !loop; i++)\\n            if (nums[i]) {\\n                int j1 = i, j2 = i, dir = nums[i];\\n                do {\\n                    j1 = advanceBy(1, j1, nums, dir);\\n                    j2 = advanceBy(2, j2, nums, dir);\\n                } while (j1 >= 0 && j2 >= 0 && j1 != j2);\\n                \\n                if (j1 >= 0 && j2 >= 0 && j1 == j2) {\\n                    if (j1 == advanceBy(1, j1, nums, dir))\\n                        nums[j1] = 0;\\n                    else\\n                        loop = true;\\n                }\\n                \\n                nums[i] = 0;\\n            }\\n        return loop;\\n    }\\n    \\n    int advanceBy(int step, int j, vector<int>& nums, int dir) {\\n        int n = nums.size();\\n        for (; step > 0; step--) {\\n            j = (j + nums[j] + n) % n;\\n            if (nums[j] * dir <= 0)\\n                return -1;\\n        }\\n        return j;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool circularArrayLoop(vector<int>& nums) {\\n        bool loop = false;\\n        for (int i = 0; i < nums.size() && !loop; i++)\\n            if (nums[i]) {\\n                int j1 = i, j2 = i, dir = nums[i];\\n                do {\\n                    j1 = advanceBy(1, j1, nums, dir);\\n                    j2 = advanceBy(2, j2, nums, dir);\\n                } while (j1 >= 0 && j2 >= 0 && j1 != j2);\\n                \\n                if (j1 >= 0 && j2 >= 0 && j1 == j2) {\\n                    if (j1 == advanceBy(1, j1, nums, dir))\\n                        nums[j1] = 0;\\n                    else\\n                        loop = true;\\n                }\\n                \\n                nums[i] = 0;\\n            }\\n        return loop;\\n    }\\n    \\n    int advanceBy(int step, int j, vector<int>& nums, int dir) {\\n        int n = nums.size();\\n        for (; step > 0; step--) {\\n            j = (j + nums[j] + n) % n;\\n            if (nums[j] * dir <= 0)\\n                return -1;\\n        }\\n        return j;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561395,
                "title": "o-n-time-and-o-1-space-simple-small-lines-code-c-with-explanation",
                "content": "nums[x]=1001+i will take care of unique chain of visited as visited index can mean two things\\n1. it is visited in this traversal ( means loop exist)\\n2.  it is visited in another traversal ( which will lead to failure otherwise we have returned true)\\n\\nprev!=x take care of loop with size>1\\n\\n```\\nbool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=1001) continue;\\n            int x=i,prev;\\n            int sign=nums[i];\\n            while(nums[x]<=1000&&(sign*nums[x]>0)){\\n                int val=nums[x]%n;\\n                nums[x]=1001+i;\\n                prev=x;\\n                x=((x+val+n)%n);\\n            }\\n            if((nums[x]==(1001+i))&&x!=prev) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=1001) continue;\\n            int x=i,prev;\\n            int sign=nums[i];\\n            while(nums[x]<=1000&&(sign*nums[x]>0)){\\n                int val=nums[x]%n;\\n                nums[x]=1001+i;\\n                prev=x;\\n                x=((x+val+n)%n);\\n            }\\n            if((nums[x]==(1001+i))&&x!=prev) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712379,
                "title": "java-simple-check-if-visited",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int n = nums.length;\\n        boolean[] vs = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            if (bfs(nums, n, i, vs)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean bfs(int[] nums, int n, int i, boolean[] vs) {\\n        if (vs[i]) return false;\\n        int len = 0, j = i, cnt = 0;\\n        Map<Integer, Integer> cnts = new HashMap<>();\\n        boolean forward = nums[i] > 0, res = true;\\n        Set<Integer> visited = new HashSet<>();\\n        while (!cnts.containsKey(i)) {\\n            cnts.put(i, cnt);\\n            i = (nums[i] % n + i+ n) % n;\\n            if ((forward && nums[i] < 0) || (!forward && nums[i] > 0) || vs[i]) res = false;\\n            cnt++;\\n        }\\n        if (res) for (int key : cnts.keySet()) vs[key] = true;\\n        return res && cnt - cnts.get(i) > 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int n = nums.length;\\n        boolean[] vs = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            if (bfs(nums, n, i, vs)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean bfs(int[] nums, int n, int i, boolean[] vs) {\\n        if (vs[i]) return false;\\n        int len = 0, j = i, cnt = 0;\\n        Map<Integer, Integer> cnts = new HashMap<>();\\n        boolean forward = nums[i] > 0, res = true;\\n        Set<Integer> visited = new HashSet<>();\\n        while (!cnts.containsKey(i)) {\\n            cnts.put(i, cnt);\\n            i = (nums[i] % n + i+ n) % n;\\n            if ((forward && nums[i] < 0) || (!forward && nums[i] > 0) || vs[i]) res = false;\\n            cnt++;\\n        }\\n        if (res) for (int key : cnts.keySet()) vs[key] = true;\\n        return res && cnt - cnts.get(i) > 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556819,
                "title": "c-100-time-100-space-2-pointers-well-commented-code",
                "content": "```\\nclass Solution {\\n    // next function makes one move\\n    int next(vector<int>& nums, int i){\\n        int n = nums.size();\\n        return (n+nums[i]+i)%n;\\n    }\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        // visited array for making sure we visit every element just once\\n        vector<bool> visited(n, 0);\\n        // steps of size greater than n circle back, so taking remainder\\n        for(int i=0; i<n; i++)\\n            nums[i]=nums[i]%n;\\n        for(int i=0;i<n;i++){\\n            // initializing slow and fast\\n            int slow = i, fast = i;\\n            // already visited, no point running slow-fast algorithm again\\n            if(visited[slow]) continue;\\n            // condition inside ensures that all elements are positive or all negative\\n            // 2 negatives / 2 positives multilplied will give +ve as output\\n            // we need to ensure all elements slow, next(fast), next(next(fast)) are same sign\\n            // we don\\'t need to check next(slow) because it is some previous fast (so already checked)\\n            while(nums[slow]*nums[next(nums,fast)]>0 && nums[slow]*nums[next(nums,next(nums,fast))]>0){\\n                // one step for slow\\n                slow = next(nums,slow);\\n                // two steps for fast\\n                fast = next(nums,next(nums,fast));\\n                // if already visited break\\n                if(visited[slow]) break;\\n                visited[slow]=1;\\n                if(slow==fast){\\n                    if(slow==next(nums,slow)) // single length\\n                        return false;\\n                    return true; // found a loop\\n                }\\n            }\\n        }\\n        return false; //no loop found\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // next function makes one move\\n    int next(vector<int>& nums, int i){\\n        int n = nums.size();\\n        return (n+nums[i]+i)%n;\\n    }\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        // visited array for making sure we visit every element just once\\n        vector<bool> visited(n, 0);\\n        // steps of size greater than n circle back, so taking remainder\\n        for(int i=0; i<n; i++)\\n            nums[i]=nums[i]%n;\\n        for(int i=0;i<n;i++){\\n            // initializing slow and fast\\n            int slow = i, fast = i;\\n            // already visited, no point running slow-fast algorithm again\\n            if(visited[slow]) continue;\\n            // condition inside ensures that all elements are positive or all negative\\n            // 2 negatives / 2 positives multilplied will give +ve as output\\n            // we need to ensure all elements slow, next(fast), next(next(fast)) are same sign\\n            // we don\\'t need to check next(slow) because it is some previous fast (so already checked)\\n            while(nums[slow]*nums[next(nums,fast)]>0 && nums[slow]*nums[next(nums,next(nums,fast))]>0){\\n                // one step for slow\\n                slow = next(nums,slow);\\n                // two steps for fast\\n                fast = next(nums,next(nums,fast));\\n                // if already visited break\\n                if(visited[slow]) break;\\n                visited[slow]=1;\\n                if(slow==fast){\\n                    if(slow==next(nums,slow)) // single length\\n                        return false;\\n                    return true; // found a loop\\n                }\\n            }\\n        }\\n        return false; //no loop found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481341,
                "title": "c-soln-with-comment-100-fast-o-n-time-and-o-1-space",
                "content": "PLZ UPVOTE\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size(); //size of nums\\n        for(int i=0;i<n;i++){    \\n            if(nums[i]>-10000){   // we are giving value to index which we are visiting and value will be less than equal to -10000\\n            int ind=i,val=-10000-i,pos=nums[i]/abs(nums[i]),count=0;   // ind is starting index .... val which we be giving now .... pos be its negative or positive  // count to find out self loop\\n            while(nums[ind]>-9999){    // if value is less than -9999 means already visited there for no need to visit \\n                if(pos*nums[ind]<0)break;    // checking if it have same sign number or not if not then there is no need to check loop\\n                int pos=((nums[ind]+ind)%n+n)%n;  // pos of next pointer the ind index is pointing \\n                nums[ind]=val;   // we will give it specific value so we can recognize if it is visited in this loop or previous \\n                if(ind==pos)count=1;   // for self loop .. it is to check if node is pointing in itself \\n                ind=pos;  // if not self loop then next node \\n            }\\n            if(nums[ind]==val && count!=1)return true;         // if the next node is visited in this  loop means we visited this in this loop and we check if it contain self loop if not return true\\n            }\\n        }\\n        return false;  // if no loop found\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size(); //size of nums\\n        for(int i=0;i<n;i++){    \\n            if(nums[i]>-10000){   // we are giving value to index which we are visiting and value will be less than equal to -10000\\n            int ind=i,val=-10000-i,pos=nums[i]/abs(nums[i]),count=0;   // ind is starting index .... val which we be giving now .... pos be its negative or positive  // count to find out self loop\\n            while(nums[ind]>-9999){    // if value is less than -9999 means already visited there for no need to visit \\n                if(pos*nums[ind]<0)break;    // checking if it have same sign number or not if not then there is no need to check loop\\n                int pos=((nums[ind]+ind)%n+n)%n;  // pos of next pointer the ind index is pointing \\n                nums[ind]=val;   // we will give it specific value so we can recognize if it is visited in this loop or previous \\n                if(ind==pos)count=1;   // for self loop .. it is to check if node is pointing in itself \\n                ind=pos;  // if not self loop then next node \\n            }\\n            if(nums[ind]==val && count!=1)return true;         // if the next node is visited in this  loop means we visited this in this loop and we check if it contain self loop if not return true\\n            }\\n        }\\n        return false;  // if no loop found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277387,
                "title": "457-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the length of the input list is less than 2. If so, return False as there can\\'t be any loops with less than 2 elements.\\n\\n2. Loop through each element in the input list using the enumerate() function to keep track of the index.\\n\\n3. If the current element is 0, skip to the next element as it can\\'t be part of a loop.\\n\\n4. Initialize two pointers: slow and fast. Set both pointers to the current index i.\\n\\n5. While the product of the current element and the element at the index pointed to by fast is greater than 0, and the product of the current element and the element at the index pointed to by the next position of fast (using the _advance() function) is also greater than 0, advance the slow pointer by one position using the _advance() function and the fast pointer by two positions using the _advance() function twice.\\n\\n6. Check if the slow pointer and fast pointer have met. If so, we\\'ve found a loop.\\n\\n7. If the slow pointer and fast pointer are equal to the next position of slow pointer, we\\'ve found a loop of length 1. In this case, break out of the loop and continue to the next element in the input list.\\n\\n8. Set all elements in the loop to 0 by starting at the current index i and moving through the loop using the _advance() function until we reach an element with a different sign than the current element.\\n\\n9. Continue to the next element in the input list and repeat steps 3-8 until all elements have been processed.\\n\\n10. If no loops have been found, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return False\\n\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                continue\\n\\n            # initialize slow and fast pointers\\n            slow, fast = i, i\\n\\n            # move slow and fast pointers until they meet or go out of bounds\\n            while num * nums[fast] > 0 and num * nums[self._advance(nums, fast)] > 0:\\n                slow = self._advance(nums, slow)\\n                fast = self._advance(nums, self._advance(nums, fast))\\n\\n                if slow == fast:\\n                    if slow == self._advance(nums, slow):\\n                        break\\n                    return True\\n\\n            # set all elements in the cycle to 0\\n            slow, sign = i, num\\n            while sign * nums[slow] > 0:\\n                next = self._advance(nums, slow)\\n                nums[slow] = 0\\n                slow = next\\n\\n        return False\\n\\n    def _advance(self, nums: List[int], i: int) -> int:\\n        return (i + nums[i]) % len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return False\\n\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                continue\\n\\n            # initialize slow and fast pointers\\n            slow, fast = i, i\\n\\n            # move slow and fast pointers until they meet or go out of bounds\\n            while num * nums[fast] > 0 and num * nums[self._advance(nums, fast)] > 0:\\n                slow = self._advance(nums, slow)\\n                fast = self._advance(nums, self._advance(nums, fast))\\n\\n                if slow == fast:\\n                    if slow == self._advance(nums, slow):\\n                        break\\n                    return True\\n\\n            # set all elements in the cycle to 0\\n            slow, sign = i, num\\n            while sign * nums[slow] > 0:\\n                next = self._advance(nums, slow)\\n                nums[slow] = 0\\n                slow = next\\n\\n        return False\\n\\n    def _advance(self, nums: List[int], i: int) -> int:\\n        return (i + nums[i]) % len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948438,
                "title": "c-dfs-dp-solution-easy-to-understand-and-intuitive",
                "content": "```class Solution {\\nbool dfs(int node,unordered_map< int,int> &vis,vector< int>&nums,bool neg,int n,vector< int>&dp){\\n        if(vis[node]==1){\\n            return true;\\n        }\\n    \\n        if(dp[node]==0) return false;\\n        \\n        vis[node]=1;\\n        if(neg && nums[(node+nums[node]+n)%n]<0 && node!=(node+nums[node]+n)%n){\\n            if(dfs((node+nums[node]+n)%n,vis,nums,neg,n,dp)){\\n                return true;\\n            }\\n        }\\n        if(!neg && nums[(node+nums[node]+n)%n]>0 && node!=(node+nums[node]+n)%n){\\n            if(dfs((node+nums[node]+n)%n,vis,nums,neg,n,dp)){\\n                return true;\\n            }\\n        }\\n        vis[node]=0;\\n        dp[node]=0;\\n        return false;\\n    }\\npublic:\\n    bool circularArrayLoop(vector< int>& nums) {\\n        int n=nums.size();\\n        unordered_map< int,int>vis;\\n\\t\\t\\n        for( int i=0; i < n ; i++){\\n            nums[i ]% = n;\\n        }\\n        \\n        vector< int >dp(n,-1);\\n\\t\\t\\n        for (  int i=0; i < n; i++){\\n            if( ! vis[i]){\\n                if( dfs (i,vis,nums,nums[i]<0,n,dp)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\nbool dfs(int node,unordered_map< int,int> &vis,vector< int>&nums,bool neg,int n,vector< int>&dp){\\n        if(vis[node]==1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1873232,
                "title": "self-understandable-python-explained-code-98-faster",
                "content": "**Bruteforce Approach :**\\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            seen=set()\\n            while True:\\n                if i in seen:               # if index already exist in set means, array is circular \\n                    return True\\n                seen.add(i)\\n                prev=i\\n                i=(i+nums[i])%len(nums)        # index position for next element\\n                if prev==i or (nums[i]>0)!=(nums[prev]>0):         # checks whether all the elements in circular subset have same sign\\n                    break       \\n        return False\\n```\\n**Optimised Solution :**\\nIf the index visited prior ,not formed cycle then don\\'t traverse throght it as initial index because it will never form cycle.\\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        seen=set()\\n        for i in range(len(nums)):\\n            if i not in seen:\\n                local=set()\\n                while True:\\n                    if i in local:\\n                        return True\\n                    if i in seen:\\n                        break\\n                    local.add(i)\\n                    seen.add(i)\\n                    prev=i\\n                    i=(i+nums[i])%len(nums)\\n                    if prev==i or (nums[i]>0)!=(nums[prev]>0):\\n                        break     \\n        return False      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            seen=set()\\n            while True:\\n                if i in seen:               # if index already exist in set means, array is circular \\n                    return True\\n                seen.add(i)\\n                prev=i\\n                i=(i+nums[i])%len(nums)        # index position for next element\\n                if prev==i or (nums[i]>0)!=(nums[prev]>0):         # checks whether all the elements in circular subset have same sign\\n                    break       \\n        return False\\n```\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        seen=set()\\n        for i in range(len(nums)):\\n            if i not in seen:\\n                local=set()\\n                while True:\\n                    if i in local:\\n                        return True\\n                    if i in seen:\\n                        break\\n                    local.add(i)\\n                    seen.add(i)\\n                    prev=i\\n                    i=(i+nums[i])%len(nums)\\n                    if prev==i or (nums[i]>0)!=(nums[prev]>0):\\n                        break     \\n        return False      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228631,
                "title": "easy-c-soln-floyd-s-turtoise-and-hare-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    //floyd\\'s turtoise and hare algorithm\\n    int nextpos(vector<int>& nums, bool dir, int pos){\\n        int n=nums.size();\\n        bool dirtmp=nums[pos]>=0;\\n        if(dirtmp!=dir)return -1;\\n        int nextind=(pos+nums[pos]%n+n)%n;\\n        if(nextind==pos)nextind=-1;\\n        return nextind;\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        for(int start=0;start<nums.size();start++){\\n            bool dir=nums[start]>=0?true:false;\\n            int p1=start,p2=start;     //p1 p2 will be index\\n            do{\\n                p1=nextpos(nums,dir,p1);\\n                p2=nextpos(nums,dir,p2);\\n                if(p2!=-1){\\n                    p2=nextpos(nums,dir,p2);\\n                }\\n            }\\n            while(p1!=-1 && p2!=-1 && p1!=p2);\\n            if(p1!=-1 && p1==p2)return true;\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //floyd\\'s turtoise and hare algorithm\\n    int nextpos(vector<int>& nums, bool dir, int pos){\\n        int n=nums.size();\\n        bool dirtmp=nums[pos]>=0;\\n        if(dirtmp!=dir)return -1;\\n        int nextind=(pos+nums[pos]%n+n)%n;\\n        if(nextind==pos)nextind=-1;\\n        return nextind;\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        for(int start=0;start<nums.size();start++){\\n            bool dir=nums[start]>=0?true:false;\\n            int p1=start,p2=start;     //p1 p2 will be index\\n            do{\\n                p1=nextpos(nums,dir,p1);\\n                p2=nextpos(nums,dir,p2);\\n                if(p2!=-1){\\n                    p2=nextpos(nums,dir,p2);\\n                }\\n            }\\n            while(p1!=-1 && p2!=-1 && p1!=p2);\\n            if(p1!=-1 && p1==p2)return true;\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313618,
                "title": "python-6-liner-easy-to-understand-o-1-space-o-n-time",
                "content": "In this solution, we simply iterate through the list. We can think of this list representation as a graph of sorts. `pos` tells us if a number is positive or not. If it changes during our loop, we terminate our loop. You can think of the positive or negative numbers are two directions, so this list representation can be thought of as a directional graph. \\n\\nFor each number we visit we mark it as str(i), with i being the start index of our current loop. If we see the value for the current index we\\'re on is str(i) after we\\'re done traversing through this node in the graph, we will know that it\\'s a loop. \\n\\nWe use % n because if the node has a value of 0, i + n, or i - n, you\\'ll end up at the same node, and %n is an easy way to represent those 3 possibilites with 2 easy characters. n is the length of list. \\n\\nYou could also use the fast/slow pointer technique that is commonly used for finding cycles in linked lists. \\n\\n```\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n\\t\\tfor i, num in enumerate(nums):\\n            pos, group = num > 0, str(i)\\n            while type(nums[i]) != str and pos == (nums[i] > 0) and nums[i] % len(nums) != 0:\\n                nxt, nums[i]= nums[i], group\\n                i = (i + nxt) % len(nums)\\n            if nums[i] == group: return True\\n        return False \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n\\t\\tfor i, num in enumerate(nums):\\n            pos, group = num > 0, str(i)\\n            while type(nums[i]) != str and pos == (nums[i] > 0) and nums[i] % len(nums) != 0:\\n                nxt, nums[i]= nums[i], group\\n                i = (i + nxt) % len(nums)\\n            if nums[i] == group: return True\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 247005,
                "title": "cpp-100-faster",
                "content": "#### \\u601D\\u8DEF\\n\\u5BF9\\u6BCF\\u4E2A\\u5143\\u7D20\\u67E5\\u627E\\u662F\\u5426\\u6709\\u73AF\\uFF0C\\u7EC8\\u6B62\\u6761\\u4EF6\\u5982\\u4E0B\\uFF1A\\n1. \\u5982\\u679C\\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u662F\\u672C\\u8EAB\\uFF0C\\u5219\\u4E0D\\u53EF\\u80FD\\u6709\\u73AF\\uFF1B\\n2. \\u5982\\u679C\\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u5728\\u672C\\u6B21\\u67E5\\u627E\\u4E2D\\u51FA\\u73B0\\u8FC7\\uFF0C\\u5219\\u6709\\u73AF\\uFF1B\\n3. \\u5982\\u679C\\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u7684\\u6B63\\u8D1F\\u53F7\\u76F8\\u53CD\\uFF0C\\u5219\\u4E0D\\u53EF\\u80FD\\u6709\\u73AF\\u3002\\n\\n#### \\u5B9E\\u73B0\\n\\u5173\\u952E\\u70B9\\n1. \\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u4E0B\\u6807\\u8BA1\\u7B97\\uFF1B\\n2. \\u7EC8\\u6B62\\u6761\\u4EF6\\u7684\\u5224\\u65AD\\u987A\\u5E8F\\uFF1B\\n3. \\u4E0D\\u9700\\u8981\\u91CD\\u590D\\u5224\\u5B9A\\u67E5\\u627E\\u8FC7\\u7684\\u5143\\u7D20\\u3002\\n\\n```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n    \\t// \\u8BB0\\u5F55\\u54EA\\u4E9B\\u5143\\u7D20\\u88AB\\u67E5\\u627E\\u8FC7\\uFF0C\\u5DF2\\u67E5\\u627E\\u8FC7\\u7684\\u4E0D\\u518D\\u67E5\\u627E\\n    \\tvector<int> visited(nums.size(), 0);\\n\\t\\tfor(int i=0;i<nums.size();i++) {\\n\\t\\t\\tif(visited[i]) continue;\\n\\t\\t\\tvector<int> vs(nums.size(), 0);\\n\\t\\t\\t// \\u5BF9\\u6BCF\\u4E2A\\u5143\\u7D20\\u5224\\u65AD\\u662F\\u5426\\u6709\\u73AF\\n\\t\\t\\tif(has_circular(nums, vs, i)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// \\u5C06\\u672C\\u6B21\\u67E5\\u627E\\u8FC7\\u7684\\u5143\\u7D20\\u52A0\\u5165\\u65E0\\u9700\\u627E\\u627E\\u7684\\u5217\\u8868\\n\\t\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t\\t\\tif(vs[i]) visited[i] = vs[i];\\n\\t\\t\\t}\\n\\t\\t}        \\n\\t\\treturn false;\\n    }\\n    // \\u53D6\\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u7684\\u4E0B\\u6807\\n    int get_index(vector<int>& nums, int i) {\\n    \\tint res = i+nums[i];\\n    \\twhile(res<0) res+= nums.size();\\n    \\treturn res%nums.size();\\n    }\\n\\n    bool has_circular(vector<int>& nums, vector<int>& visited, int i) {\\n    \\tint next = get_index(nums, i);\\n    \\t// \\u5148\\u5224\\u5B9A\\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u662F\\u5426\\u662F\\u81EA\\u5DF1\\n    \\tif(next==i) {\\n    \\t\\tvisited[i] = true;\\n    \\t\\treturn false;\\n    \\t}\\n    \\t// \\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u51FA\\u73B0\\u5728\\u5F53\\u6B21\\u904D\\u5386\\uFF0C\\u5219\\u6210\\u529F\\u627E\\u5230\\u73AF\\n    \\tif(visited[next]) return true;\\n    \\t// \\u7B26\\u53F7\\u76F8\\u53CD\\u4E0D\\u53EF\\u80FD\\u6709\\u73AF\\n    \\tif(nums[next]>0 != nums[i]>0) return false;\\n    \\tvisited[next] = true;\\n    \\t// \\u7EE7\\u7EED\\u67E5\\u627E\\n    \\treturn has_circular(nums, visited, next);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n    \\t// \\u8BB0\\u5F55\\u54EA\\u4E9B\\u5143\\u7D20\\u88AB\\u67E5\\u627E\\u8FC7\\uFF0C\\u5DF2\\u67E5\\u627E\\u8FC7\\u7684\\u4E0D\\u518D\\u67E5\\u627E\\n    \\tvector<int> visited(nums.size(), 0);\\n\\t\\tfor(int i=0;i<nums.size();i++) {\\n\\t\\t\\tif(visited[i]) continue;\\n\\t\\t\\tvector<int> vs(nums.size(), 0);\\n\\t\\t\\t// \\u5BF9\\u6BCF\\u4E2A\\u5143\\u7D20\\u5224\\u65AD\\u662F\\u5426\\u6709\\u73AF\\n\\t\\t\\tif(has_circular(nums, vs, i)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// \\u5C06\\u672C\\u6B21\\u67E5\\u627E\\u8FC7\\u7684\\u5143\\u7D20\\u52A0\\u5165\\u65E0\\u9700\\u627E\\u627E\\u7684\\u5217\\u8868\\n\\t\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t\\t\\tif(vs[i]) visited[i] = vs[i];\\n\\t\\t\\t}\\n\\t\\t}        \\n\\t\\treturn false;\\n    }\\n    // \\u53D6\\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u7684\\u4E0B\\u6807\\n    int get_index(vector<int>& nums, int i) {\\n    \\tint res = i+nums[i];\\n    \\twhile(res<0) res+= nums.size();\\n    \\treturn res%nums.size();\\n    }\\n\\n    bool has_circular(vector<int>& nums, vector<int>& visited, int i) {\\n    \\tint next = get_index(nums, i);\\n    \\t// \\u5148\\u5224\\u5B9A\\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u662F\\u5426\\u662F\\u81EA\\u5DF1\\n    \\tif(next==i) {\\n    \\t\\tvisited[i] = true;\\n    \\t\\treturn false;\\n    \\t}\\n    \\t// \\u4E0B\\u4E00\\u4E2A\\u5143\\u7D20\\u51FA\\u73B0\\u5728\\u5F53\\u6B21\\u904D\\u5386\\uFF0C\\u5219\\u6210\\u529F\\u627E\\u5230\\u73AF\\n    \\tif(visited[next]) return true;\\n    \\t// \\u7B26\\u53F7\\u76F8\\u53CD\\u4E0D\\u53EF\\u80FD\\u6709\\u73AF\\n    \\tif(nums[next]>0 != nums[i]>0) return false;\\n    \\tvisited[next] = true;\\n    \\t// \\u7EE7\\u7EED\\u67E5\\u627E\\n    \\treturn has_circular(nums, visited, next);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171428,
                "title": "how-can-1-2-3-4-5-be-false-but-3-1-2-be-true",
                "content": "When I failed on  `[-1, -2, -3, -4, -5]`, which is expected to be `false`. I told myself: a loop need maybe **at least TWO numbers**.\\n\\nIf so, why `[3, 1, 2]` is expected to be `true`, which always loops on `3`.\\n\\nSo i guess something they called **\"loop\"** here **must go back to the first element** of the loop chain? \\nIf anything wrong plz let me know.\\n\\nHere is the version that pass all 10 test cases. But I m still confused about the definition.\\n```java\\nclass Solution {\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        if (nums == null || nums.length == 0) { return false; }\\n        localNums = nums;\\n        size = nums.length;\\n        isForward = (nums[0] > 0);\\n        int slow = 0, fast = 0;\\n        do {\\n            for (int i = 0; i < 2; i++) {\\n                if (isCrossward(fast)) return false;\\n                fast = skip(fast);\\n            }\\n            slow = skip(slow);\\n        } while (slow != fast);\\n        return fast == 0; // something they called loop here must go back to the first element\\n    }\\n\\n    // environment\\n    private int[] localNums;\\n    private int size;\\n    private boolean isForward;\\n\\n    private int skip(int index) {\\n        index += localNums[index];\\n        if (isForward && index >= size) {\\n            index %= size;\\n        } else if (!isForward && index < 0) {\\n            index = index % size + size;\\n        }\\n        return index;\\n    }      \\n    \\n    private boolean isCrossward(int index) {\\n        return (isForward && localNums[index] < 0) || (!isForward && localNums[index] > 0);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        if (nums == null || nums.length == 0) { return false; }\\n        localNums = nums;\\n        size = nums.length;\\n        isForward = (nums[0] > 0);\\n        int slow = 0, fast = 0;\\n        do {\\n            for (int i = 0; i < 2; i++) {\\n                if (isCrossward(fast)) return false;\\n                fast = skip(fast);\\n            }\\n            slow = skip(slow);\\n        } while (slow != fast);\\n        return fast == 0; // something they called loop here must go back to the first element\\n    }\\n\\n    // environment\\n    private int[] localNums;\\n    private int size;\\n    private boolean isForward;\\n\\n    private int skip(int index) {\\n        index += localNums[index];\\n        if (isForward && index >= size) {\\n            index %= size;\\n        } else if (!isForward && index < 0) {\\n            index = index % size + size;\\n        }\\n        return index;\\n    }      \\n    \\n    private boolean isCrossward(int index) {\\n        return (isForward && localNums[index] < 0) || (!isForward && localNums[index] > 0);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132746,
                "title": "c-code-with-simple-explanation",
                "content": "# Intuition\\n- Slow and Fast concept like we used in Linked list. \\nWe want the direction should be constant so if there is change in direction break and check further.\\n# Approach\\n- Move slow 1 step and fast 2 steps according to their index\\'s value and check if slow==fast so it means there is a circle present and return true.\\n- We also have to see if our current direction is forward so during the process if there is negative number, it will lead to backward direction which will not be the ans so we will break. \\n- For finding nextIndex:\\nint nextIndex= ((idx+nums[idx])%n+n)%n;\\n- If nextIndex==idx, we will return -1 cause we want circle having size more than 1.\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextPosition(vector<int> &nums, int idx, bool &isForward) {\\n        \\n        int n=nums.size();\\n        bool direction= (nums[idx]>=0) ? true : false;\\n\\n        if(direction != isForward)\\n            return -1;\\n\\n        int nextIndex= ((idx+nums[idx])%n+n)%n;\\n\\n        if(nextIndex==idx)\\n            return -1;\\n        \\n        return nextIndex;\\n\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n\\n        bool isForward;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            \\n            int slow, fast;\\n            slow=fast=i;\\n\\n            isForward=(nums[i]>0) ? true: false;\\n\\n            while(true){\\n                slow= nextPosition(nums, slow, isForward);\\n                if(slow==-1)\\n                    break;\\n                \\n                fast= nextPosition(nums, fast, isForward);\\n                if(fast==-1)\\n                    break;\\n\\n                fast= nextPosition(nums, fast, isForward);\\n                if(fast==-1)\\n                    break;\\n                \\n                if(slow==fast)\\n                    return true;\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextPosition(vector<int> &nums, int idx, bool &isForward) {\\n        \\n        int n=nums.size();\\n        bool direction= (nums[idx]>=0) ? true : false;\\n\\n        if(direction != isForward)\\n            return -1;\\n\\n        int nextIndex= ((idx+nums[idx])%n+n)%n;\\n\\n        if(nextIndex==idx)\\n            return -1;\\n        \\n        return nextIndex;\\n\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n\\n        bool isForward;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            \\n            int slow, fast;\\n            slow=fast=i;\\n\\n            isForward=(nums[i]>0) ? true: false;\\n\\n            while(true){\\n                slow= nextPosition(nums, slow, isForward);\\n                if(slow==-1)\\n                    break;\\n                \\n                fast= nextPosition(nums, fast, isForward);\\n                if(fast==-1)\\n                    break;\\n\\n                fast= nextPosition(nums, fast, isForward);\\n                if(fast==-1)\\n                    break;\\n                \\n                if(slow==fast)\\n                    return true;\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721606,
                "title": "dfs-easiest-solution-brute-force-with-explanation",
                "content": "```\\nvector<int> graph;\\n    bool dfs(vector<int> &visit,int node,int sign)\\n    {\\n\\t\\t/*this method using mod wil always give the required next node*/\\n        int next=(node+graph[node]+graph.size())%(graph.size());\\n\\t\\t/*next==node is for node not being a self loop \\n\\t\\tgraph[node]*sign is for condition (5)*(1)>0 and (-5)*(-1)>0 where it will be less than 0 it means\\n\\t\\tthat condition voilated hence answer not possible*/\\n        if(next==node||graph[node]*sign<0)\\n            return false;\\n\\t\\t/*if node visited more than once than it means loop*/\\n        if(visit[node]==1)\\n            return true;\\n        visit[node]=1;\\n        return dfs(visit,next,sign);\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        graph=nums;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> visit(n,0);\\n            int sign=graph[i]>0?1:-1;\\n\\t\\t\\t//sign is used to always check we have nums[i] always same\\n            if(dfs(visit,i,sign))\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nvector<int> graph;\\n    bool dfs(vector<int> &visit,int node,int sign)\\n    {\\n\\t\\t/*this method using mod wil always give the required next node*/\\n        int next=(node+graph[node]+graph.size())%(graph.size());\\n\\t\\t/*next==node is for node not being a self loop \\n\\t\\tgraph[node]*sign is for condition (5)*(1)>0 and (-5)*(-1)>0 where it will be less than 0 it means\\n\\t\\tthat condition voilated hence answer not possible*/\\n        if(next==node||graph[node]*sign<0)\\n            return false;\\n\\t\\t/*if node visited more than once than it means loop*/\\n        if(visit[node]==1)\\n            return true;\\n        visit[node]=1;\\n        return dfs(visit,next,sign);\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        graph=nums;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> visit(n,0);\\n            int sign=graph[i]>0?1:-1;\\n\\t\\t\\t//sign is used to always check we have nums[i] always same\\n            if(dfs(visit,i,sign))\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2242470,
                "title": "slow-and-fast-pointer-python",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            slow = fast = i\\n            is_forward = nums[slow] >= 0\\n            \\n            while True:\\n                slow = self.findNextIndex(nums, is_forward, slow)\\n                fast = self.findNextIndex(nums, is_forward, fast)\\n                if fast != -1:\\n                    fast = self.findNextIndex(nums, is_forward, fast)\\n                if slow == -1 or fast == -1 or slow == fast:\\n                    break\\n                    \\n            if slow == fast and slow != -1:\\n                return True\\n        return False\\n        \\n    \\n    def findNextIndex(self, arr, is_forward, index):\\n        direction = arr[index] >= 0\\n        if direction != is_forward:\\n            return -1\\n        next_index = (index+arr[index]) % len(arr)\\n        if next_index == index:\\n            return -1\\n        return next_index\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            slow = fast = i\\n            is_forward = nums[slow] >= 0\\n            \\n            while True:\\n                slow = self.findNextIndex(nums, is_forward, slow)\\n                fast = self.findNextIndex(nums, is_forward, fast)\\n                if fast != -1:\\n                    fast = self.findNextIndex(nums, is_forward, fast)\\n                if slow == -1 or fast == -1 or slow == fast:\\n                    break\\n                    \\n            if slow == fast and slow != -1:\\n                return True\\n        return False\\n        \\n    \\n    def findNextIndex(self, arr, is_forward, index):\\n        direction = arr[index] >= 0\\n        if direction != is_forward:\\n            return -1\\n        next_index = (index+arr[index]) % len(arr)\\n        if next_index == index:\\n            return -1\\n        return next_index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175086,
                "title": "commented-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    \\n    \\n// we are on ith index of the array. next() return the index we land on after making jump from ith index.\\nint next(vector<int> nums, int i){\\n\\n    return (i+nums[i] + nums.size())%nums.size();\\n}\\n\\n\\n\\n\\nbool circularArrayLoop(vector<int>& nums){\\n    \\n    int n = nums.size();\\n\\n    for(int i=0; i<n; i++){\\n        int slow = i;\\n        int fast = i;\\n\\n        if(nums[i] == 0){\\n            continue;\\n        }\\n\\n        while(nums[slow]*nums[next(nums,slow)]>0 && \\n            nums[fast]*nums[next(nums,fast)]>0 && \\n            nums[fast]*nums[next(nums,next(nums,fast))]>0){\\n            \\n            // we can make jumps. so make slow take 1 jump and make fast take 2 jumps\\n            slow = next(nums, slow);\\n            fast = next(nums, next(nums, fast));\\n\\n\\n                if(slow == fast){\\n                    // cycle is present. check if the length of the cycle is more than 1\\n                    if(slow == next(nums, slow)){\\n                        break;\\n                    }\\n                    // return true cuz valid cycle is present.\\n                    return true;\\n                }\\n        \\n        }\\n\\n\\n        // if cycle cannot be formed from the ith index, then we need to make some updations:\\n        // make the values before the point where cycle broke and whos sign is same as sarting value sign as 0.\\n\\n        slow = i;  // again start slow from i\\n        int val = nums[slow];\\n        // slow is used to iterate over the numbers uptil the number where cycle was broken\\n        while(val*nums[slow]>0){   // while current ele has same magnitude as 1st element\\n            int x = slow;\\n            slow = next(nums, slow);\\n            nums[x] = 0;\\n        }\\n    }\\n\\n    return false;\\n\\n\\n}\\n\\n};\\n\\n\\n\\n```\\n\\nUpvote if you found it helpful :)",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    \\n    \\n// we are on ith index of the array. next() return the index we land on after making jump from ith index.\\nint next(vector<int> nums, int i){\\n\\n    return (i+nums[i] + nums.size())%nums.size();\\n}\\n\\n\\n\\n\\nbool circularArrayLoop(vector<int>& nums){\\n    \\n    int n = nums.size();\\n\\n    for(int i=0; i<n; i++){\\n        int slow = i;\\n        int fast = i;\\n\\n        if(nums[i] == 0){\\n            continue;\\n        }\\n\\n        while(nums[slow]*nums[next(nums,slow)]>0 && \\n            nums[fast]*nums[next(nums,fast)]>0 && \\n            nums[fast]*nums[next(nums,next(nums,fast))]>0){\\n            \\n            // we can make jumps. so make slow take 1 jump and make fast take 2 jumps\\n            slow = next(nums, slow);\\n            fast = next(nums, next(nums, fast));\\n\\n\\n                if(slow == fast){\\n                    // cycle is present. check if the length of the cycle is more than 1\\n                    if(slow == next(nums, slow)){\\n                        break;\\n                    }\\n                    // return true cuz valid cycle is present.\\n                    return true;\\n                }\\n        \\n        }\\n\\n\\n        // if cycle cannot be formed from the ith index, then we need to make some updations:\\n        // make the values before the point where cycle broke and whos sign is same as sarting value sign as 0.\\n\\n        slow = i;  // again start slow from i\\n        int val = nums[slow];\\n        // slow is used to iterate over the numbers uptil the number where cycle was broken\\n        while(val*nums[slow]>0){   // while current ele has same magnitude as 1st element\\n            int x = slow;\\n            slow = next(nums, slow);\\n            nums[x] = 0;\\n        }\\n    }\\n\\n    return false;\\n\\n\\n}\\n\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937741,
                "title": "js-fast-and-slow-pointer",
                "content": "```\\n//approach: Fast & Slow Pointer (Floyd\\'s Algo)\\n//since it is to find the cycle\\n\\n//Things to keep in mind: \\n//cycle should contain only one movement either positive(right side) only or negative(left side) only\\n//cycle sequence should involve more than one element \\n\\n//we loop for each element to check for their cycle\\n//we check their direction (if number > 0 (positive direction), if number < 0 (negative direction))\\n//we will move slow to each index one time, but fast moves two times\\n//however, while moving, slow and fast, if their is a direction mismatch or single element cycle, we break\\n//TC: O(n^2) --> since we visit each element and we try to find cycle for it from all the elements\\n//SC: O(1)\\nvar circularArrayLoop = function(nums) {\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        \\n        let moveForward = nums[i] >= 0; //this determines the original direction \\n        let slow = i;\\n        let fast = i;\\n        \\n        while(true){\\n            \\n            slow = nextIndex(nums, moveForward, slow);\\n            if(slow === -1)\\n                break;\\n            \\n            fast = nextIndex(nums, moveForward, fast);\\n            if(fast === -1)\\n                break;\\n            fast = nextIndex(nums, moveForward, fast);\\n            if(fast === -1)\\n                break;\\n            \\n            if(slow === fast) \\n                return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction nextIndex(arr, movement, currentIndex){\\n    //this is necessary to catch if the actual(original iterated index) index direction matches\\n    //with moving(when fast and slow keep moving) index direction, like when fast and slow moves\\n    let direction = arr[currentIndex] >= 0;  //this determines moving direction\\n    \\n    if(movement !== direction)\\n        return -1;\\n    \\n    let nextIdx = (currentIndex + arr[currentIndex]) % arr.length;\\n    \\n    //this is necessary to keep the nextIdx positive\\n    //sometimes, when you are adding [-2,2,3] --> (index + index value) % array length, we get negative value\\n    //so to actually move to a correct index, we just add that remainder with array length\\n    if(nextIdx < 0)\\n        nextIdx += arr.length;   \\n    \\n    //when moving, if the index we passed in matches the calculated index that pointer should be\\n    //then we know, we cycled back all the way to where we started the cycle without touching another element, \\n    //so this tells us there\\'s a single element cycle\\n    if(nextIdx === currentIndex)  //one element cycle\\n        nextIdx = -1;\\n    \\n    return nextIdx;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n//approach: Fast & Slow Pointer (Floyd\\'s Algo)\\n//since it is to find the cycle\\n\\n//Things to keep in mind: \\n//cycle should contain only one movement either positive(right side) only or negative(left side) only\\n//cycle sequence should involve more than one element \\n\\n//we loop for each element to check for their cycle\\n//we check their direction (if number > 0 (positive direction), if number < 0 (negative direction))\\n//we will move slow to each index one time, but fast moves two times\\n//however, while moving, slow and fast, if their is a direction mismatch or single element cycle, we break\\n//TC: O(n^2) --> since we visit each element and we try to find cycle for it from all the elements\\n//SC: O(1)\\nvar circularArrayLoop = function(nums) {\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        \\n        let moveForward = nums[i] >= 0; //this determines the original direction \\n        let slow = i;\\n        let fast = i;\\n        \\n        while(true){\\n            \\n            slow = nextIndex(nums, moveForward, slow);\\n            if(slow === -1)\\n                break;\\n            \\n            fast = nextIndex(nums, moveForward, fast);\\n            if(fast === -1)\\n                break;\\n            fast = nextIndex(nums, moveForward, fast);\\n            if(fast === -1)\\n                break;\\n            \\n            if(slow === fast) \\n                return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction nextIndex(arr, movement, currentIndex){\\n    //this is necessary to catch if the actual(original iterated index) index direction matches\\n    //with moving(when fast and slow keep moving) index direction, like when fast and slow moves\\n    let direction = arr[currentIndex] >= 0;  //this determines moving direction\\n    \\n    if(movement !== direction)\\n        return -1;\\n    \\n    let nextIdx = (currentIndex + arr[currentIndex]) % arr.length;\\n    \\n    //this is necessary to keep the nextIdx positive\\n    //sometimes, when you are adding [-2,2,3] --> (index + index value) % array length, we get negative value\\n    //so to actually move to a correct index, we just add that remainder with array length\\n    if(nextIdx < 0)\\n        nextIdx += arr.length;   \\n    \\n    //when moving, if the index we passed in matches the calculated index that pointer should be\\n    //then we know, we cycled back all the way to where we started the cycle without touching another element, \\n    //so this tells us there\\'s a single element cycle\\n    if(nextIdx === currentIndex)  //one element cycle\\n        nextIdx = -1;\\n    \\n    return nextIdx;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1754321,
                "title": "javascript-hashmap-98ms",
                "content": "```\\nconst circularArrayLoop = (a) => {\\n    let n = a.length, visit = Array(n).fill(0);\\n    for (let i = 0; i < n; ++i) {\\n        if (visit[i]) continue;\\n        visit[i] = true;\\n        let m = new Map();\\n        let cur = i;\\n        while (true) {\\n            let next = ((cur + a[cur]) % n + n) % n;\\n            if (next == cur || a[next] * a[cur] < 0) break;\\n            if (m.has(next)) return true;\\n            m.set(cur, next);\\n            cur = next;\\n            visit[next] = true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst circularArrayLoop = (a) => {\\n    let n = a.length, visit = Array(n).fill(0);\\n    for (let i = 0; i < n; ++i) {\\n        if (visit[i]) continue;\\n        visit[i] = true;\\n        let m = new Map();\\n        let cur = i;\\n        while (true) {\\n            let next = ((cur + a[cur]) % n + n) % n;\\n            if (next == cur || a[next] * a[cur] < 0) break;\\n            if (m.has(next)) return true;\\n            m.set(cur, next);\\n            cur = next;\\n            visit[next] = true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673185,
                "title": "simple-java-code-with-explanation",
                "content": "```\\nclass Solution {\\n    public int getNextIndex(int[]arr, int index, boolean iForward){\\n        //compare current direction with incoming direction\\n        boolean direction = arr[index]>=0;\\n        \\n        //return -1 if the direction rule breaks\\n        if(direction!=iForward)\\n            return -1;\\n        int n = arr.length;\\n        \\n        //calculate nextIndex\\n        int nextIndex = (((index + arr[index])%n)+n)%n;\\n        \\n        //One member containing cycle\\n        if(nextIndex==index)return -1;\\n        return nextIndex;\\n    }\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            int slow,fast;\\n            \\n            //fix starting point\\n            slow=fast=i;\\n            boolean iForward = (nums[i]>0?true:false);\\n            \\n            while(true){\\n                \\n                //move slow by one step and fast by two steps\\n                //if same direction rule breaks, break out of loop and return false\\n                \\n                slow = getNextIndex(nums,slow,iForward);\\n                if(slow==-1)break;\\n                \\n                fast = getNextIndex(nums,fast,iForward);\\n                if(fast==-1)break;\\n                fast = getNextIndex(nums,fast,iForward);\\n                if(fast==-1)break;\\n                \\n                //found a loop\\n                if(slow==fast)return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getNextIndex(int[]arr, int index, boolean iForward){\\n        //compare current direction with incoming direction\\n        boolean direction = arr[index]>=0;\\n        \\n        //return -1 if the direction rule breaks\\n        if(direction!=iForward)\\n            return -1;\\n        int n = arr.length;\\n        \\n        //calculate nextIndex\\n        int nextIndex = (((index + arr[index])%n)+n)%n;\\n        \\n        //One member containing cycle\\n        if(nextIndex==index)return -1;\\n        return nextIndex;\\n    }\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            int slow,fast;\\n            \\n            //fix starting point\\n            slow=fast=i;\\n            boolean iForward = (nums[i]>0?true:false);\\n            \\n            while(true){\\n                \\n                //move slow by one step and fast by two steps\\n                //if same direction rule breaks, break out of loop and return false\\n                \\n                slow = getNextIndex(nums,slow,iForward);\\n                if(slow==-1)break;\\n                \\n                fast = getNextIndex(nums,fast,iForward);\\n                if(fast==-1)break;\\n                fast = getNextIndex(nums,fast,iForward);\\n                if(fast==-1)break;\\n                \\n                //found a loop\\n                if(slow==fast)return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567412,
                "title": "python-solution-o-n-time-and-o-1-space",
                "content": "...\\n\\n    def circularArrayLoop(self, nums: List[int]) -> bool:        \\n        def findloop(index): # find the loop \\n            slow = fast = index\\n            inde = nums[index]\\n            while True:\\n                for _ in range(2):\\n                    fast = (fast + nums[fast]) % len(nums)\\n                    if inde * nums[fast] <= 0:\\n                        return False\\n                slow = (slow + nums[slow]) % len(nums)\\n                \\n                if slow == fast:\\n                    return True\\n        \\n        def changeToZero(index): # change non-loop index to zero\\n            inde = nums[index]\\n            temp = (index + nums[index]) % len(nums)\\n            nums[index] = 0\\n            while inde * nums[temp] > 0:\\n                index = temp\\n                temp = (index + nums[index]) % len(nums)\\n                nums[index] = 0\\n                \\n        for index in range(len(nums)): # change self loop index to zero\\n            if (index + nums[index]) % len(nums) == index:\\n                nums[index] = 0\\n        \\n        for index in range(len(nums)):\\n            if nums[index] != 0:\\n                if findloop(index):\\n                    return True\\n                else:\\n                    changeToZero(index)\\n        \\n        return False\\n...",
                "solutionTags": [
                    "Python"
                ],
                "code": "...\\n\\n    def circularArrayLoop(self, nums: List[int]) -> bool:        \\n        def findloop(index): # find the loop \\n            slow = fast = index\\n            inde = nums[index]\\n            while True:\\n                for _ in range(2):\\n                    fast = (fast + nums[fast]) % len(nums)\\n                    if inde * nums[fast] <= 0:\\n                        return False\\n                slow = (slow + nums[slow]) % len(nums)\\n                \\n                if slow == fast:\\n                    return True\\n        \\n        def changeToZero(index): # change non-loop index to zero\\n            inde = nums[index]\\n            temp = (index + nums[index]) % len(nums)\\n            nums[index] = 0\\n            while inde * nums[temp] > 0:\\n                index = temp\\n                temp = (index + nums[index]) % len(nums)\\n                nums[index] = 0\\n                \\n        for index in range(len(nums)): # change self loop index to zero\\n            if (index + nums[index]) % len(nums) == index:\\n                nums[index] = 0\\n        \\n        for index in range(len(nums)):\\n            if nums[index] != 0:\\n                if findloop(index):\\n                    return True\\n                else:\\n                    changeToZero(index)\\n        \\n        return False\\n...",
                "codeTag": "Python3"
            },
            {
                "id": 1388596,
                "title": "topological-sort-c",
                "content": "We could treat the `index` : `i` , and `num[i]` : j as a directed edge if they meet the following conditions:\\n> 1.  `nums[i] != j` : the cycle\\'s length is greater than 1;\\n> 2. `nums[i] * nums[j] > 0`:  i and j have the same direction, forward or backward.\\n\\nHence we can build a graph, then we can processing our `Topological Sort` to detect if there was a cycle.\\n\\n \\n```C++\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> g(n);\\n        vector<int> inD(n);\\n        for (int i = 0; i < n; i++) {\\n            int p = ((i + nums[i]) % n + n) % n;\\n            if (p == i || nums[i] * nums[p] < 0) continue;\\n            g[i].push_back(p);\\n            inD[p]++;\\n        }\\n        deque<int> collec;\\n        for (int v = 0; v < n; v++)\\n            if (inD[v] == 0) collec.push_back(v);\\n        int cnt = 0;\\n        while (!collec.empty()) {\\n            auto v = collec.front();\\n            collec.pop_front();\\n            for (auto & node : g[v])\\n                if (--inD[node] == 0) \\n                    collec.push_back(node);\\n            cnt++;\\n        }\\n        return !(cnt == n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> g(n);\\n        vector<int> inD(n);\\n        for (int i = 0; i < n; i++) {\\n            int p = ((i + nums[i]) % n + n) % n;\\n            if (p == i || nums[i] * nums[p] < 0) continue;\\n            g[i].push_back(p);\\n            inD[p]++;\\n        }\\n        deque<int> collec;\\n        for (int v = 0; v < n; v++)\\n            if (inD[v] == 0) collec.push_back(v);\\n        int cnt = 0;\\n        while (!collec.empty()) {\\n            auto v = collec.front();\\n            collec.pop_front();\\n            for (auto & node : g[v])\\n                if (--inD[node] == 0) \\n                    collec.push_back(node);\\n            cnt++;\\n        }\\n        return !(cnt == n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169995,
                "title": "java-dfs-beats-100-0ms-t-c-o-n-s-c-o-1",
                "content": "\\n    public boolean circularArrayLoop(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] != Integer.MIN_VALUE) {\\n\\t\\t\\t\\tboolean flag = circularArrayLoopHelper(nums, i, getIndex(nums, i, len), len);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpublic boolean circularArrayLoopHelper(int[] nums, int curr, int next, int len) {\\n\\n        if (nums[curr] == 0)\\n\\t\\t\\treturn true;\\n        \\n\\t\\tif (curr == next || nums[curr] == Integer.MIN_VALUE || nums[curr] * nums[next] < 0)\\n\\t\\t\\treturn false;\\n\\n        nums[curr] = 0;\\n\\t\\tint nextJump = getIndex(nums, next, len);\\n\\t\\tboolean flag = circularArrayLoopHelper(nums, next, nextJump, len);\\n\\t\\tif (flag)\\n\\t\\t\\treturn true;\\n\\t\\tnums[curr] = Integer.MIN_VALUE;\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpublic int getIndex(int[] nums, int idx, int len) {\\n\\t\\tint temp = idx + nums[idx];\\n\\t\\ttemp %= len;\\n\\t\\tif (temp < 0)\\n\\t\\t\\ttemp += len;\\n\\t\\treturn temp;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public boolean circularArrayLoop(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] != Integer.MIN_VALUE) {\\n\\t\\t\\t\\tboolean flag = circularArrayLoopHelper(nums, i, getIndex(nums, i, len), len);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpublic boolean circularArrayLoopHelper(int[] nums, int curr, int next, int len) {\\n\\n        if (nums[curr] == 0)\\n\\t\\t\\treturn true;\\n        \\n\\t\\tif (curr == next || nums[curr] == Integer.MIN_VALUE || nums[curr] * nums[next] < 0)\\n\\t\\t\\treturn false;\\n\\n        nums[curr] = 0;\\n\\t\\tint nextJump = getIndex(nums, next, len);\\n\\t\\tboolean flag = circularArrayLoopHelper(nums, next, nextJump, len);\\n\\t\\tif (flag)\\n\\t\\t\\treturn true;\\n\\t\\tnums[curr] = Integer.MIN_VALUE;\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpublic int getIndex(int[] nums, int idx, int len) {\\n\\t\\tint temp = idx + nums[idx];\\n\\t\\ttemp %= len;\\n\\t\\tif (temp < 0)\\n\\t\\t\\ttemp += len;\\n\\t\\treturn temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1116055,
                "title": "easy-understand-java-solution-by-using-two-sets-with-explanation",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        // record elements showed in all loops\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i = 0; i <= nums.length - 1; i++){\\n            // jump elements tested before\\n            if(set.contains(i)) continue;\\n            \\n            // record elements showed in the current loop\\n            Set<Integer> cset = new HashSet<>();\\n            \\n            // record the previous index. \\n            int index = i, prev = i - 1;\\n            while(nums[i] * nums[index] > 0){\\n\\t\\t\\t\\t// If the previous index is same as the current index, return false. Because the sequence\\'s length must be greater than 1 to be a cycle.\\n                if(index == prev) break;\\n                else prev = index;\\n\\n                //if the element show twice in the loop, it\\'s cycle.\\n                if(cset.contains(index)) return true;\\n                else cset.add(index);\\n\\n                //covert new index to the valid range\\n                index += nums[index];\\n                index = index % nums.length;\\n                if(index < 0) index += nums.length;\\n            }\\n            \\n\\t\\t\\tset.addAll(cset);\\n            if(set.size() == nums.length) return false;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        // record elements showed in all loops\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i = 0; i <= nums.length - 1; i++){\\n            // jump elements tested before\\n            if(set.contains(i)) continue;\\n            \\n            // record elements showed in the current loop\\n            Set<Integer> cset = new HashSet<>();\\n            \\n            // record the previous index. \\n            int index = i, prev = i - 1;\\n            while(nums[i] * nums[index] > 0){\\n\\t\\t\\t\\t// If the previous index is same as the current index, return false. Because the sequence\\'s length must be greater than 1 to be a cycle.\\n                if(index == prev) break;\\n                else prev = index;\\n\\n                //if the element show twice in the loop, it\\'s cycle.\\n                if(cset.contains(index)) return true;\\n                else cset.add(index);\\n\\n                //covert new index to the valid range\\n                index += nums[index];\\n                index = index % nums.length;\\n                if(index < 0) index += nums.length;\\n            }\\n            \\n\\t\\t\\tset.addAll(cset);\\n            if(set.size() == nums.length) return false;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060346,
                "title": "python-simple-two-pointers",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            st = i\\n            k = i\\n            f = nums[i] > 0\\n            j = 0\\n            while j < len(nums):\\n                step = nums[k]\\n                if f and step < 0:break\\n                if not f and step > 0:break\\n                    \\n                k += step\\n                k %= len(nums)\\n                j += 1\\n                \\n                if k == st and j > 1:return True\\n                elif k == st and j <= 1:break\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            st = i\\n            k = i\\n            f = nums[i] > 0\\n            j = 0\\n            while j < len(nums):\\n                step = nums[k]\\n                if f and step < 0:break\\n                if not f and step > 0:break\\n                    \\n                k += step\\n                k %= len(nums)\\n                j += 1\\n                \\n                if k == st and j > 1:return True\\n                elif k == st and j <= 1:break\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035543,
                "title": "solution-with-explanation-using-hashset-if-you-find-slow-fast-pointers-idea-is-too-complicated",
                "content": "Idea is simple. For every index we create empty Set of indexes, fixing starting index & its sign and iterate over array advancing using our move. If we face starting index after more than 1 move then we return true. If we face previously seen index (by checking it in our Set) or index with different sign than starting point sign, then we proceed to next index. Also the problem of multiplication overflow is excluded in case of large numbers\\n\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int length = nums.length;\\n        for (int start = 0; start < length; ++start) {\\n            Set<Integer> checked = new HashSet<>();  //for saving previously visited elements during current traversal\\n            int cur = start, count = 0, sign = nums[start] > 0 ? 1 : -1;\\n            while (!checked.contains(cur) && nums[cur] * sign > 0) {\\n                checked.add(cur);\\n                cur = ((cur + nums[cur]) % length + length) % length;\\n                ++count;\\n                if (cur == start && count > 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nTime Complexity: O(N^2) worst case.\\nSpace: O(N). Set can contain up to number of elements in an array.\\n\\nThis idea can be improved to Time Complexity O(N) and Space Complexity O(N) or Space Complexity O(1) by modifying array.\\n\\nBy implementing one more HashSet for indexes finished:\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int length = nums.length;\\n        Set<Integer> finished = new HashSet<>();\\n        for (int i = 0; i < length; ++i) {\\n            Set<Integer> checked = new HashSet<>();\\n            int startIndex = i, curIndex = i, count = 0, sign = nums[i] > 0 ? 1 : -1;\\n            while (!finished.contains(curIndex) && !checked.contains(curIndex)) {\\n                if (nums[curIndex] * sign < 0 || Math.abs(nums[curIndex]) == length) {\\n                    finished.addAll(checked);\\n                    break;\\n                }\\n                checked.add(curIndex);\\n                curIndex = ((curIndex + nums[curIndex]) % length + length) % length;\\n                ++count;\\n                if (checked.contains(curIndex)) {\\n                    if (count > 1) return true;\\n                    else break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nTime Complexity: O(N).\\nSpace: O(N).\\n\\nAnd finally using the fact that numbers are less than 1001:\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int length = nums.length, inc = 1001;\\n        for (int startIndex = 0; startIndex < length; ++startIndex) {\\n            int curIndex = startIndex, count = 0, sign = nums[startIndex] > 0 ? 1 : -1;\\n            while (nums[curIndex] <= 1000) {\\n                if (nums[curIndex] * sign < 0 || Math.abs(nums[curIndex]) == length) {\\n                    ++inc;\\n                    break;\\n                }\\n                int prev = curIndex;\\n                curIndex = ((curIndex + nums[curIndex]) % length + length) % length;\\n                nums[prev] = inc;\\n                ++count;\\n                if (nums[curIndex] == inc) {\\n                    if (count > 1) return true;\\n                    ++inc;\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nTime Complexity: O(N).\\nSpace: O(1).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int length = nums.length;\\n        for (int start = 0; start < length; ++start) {\\n            Set<Integer> checked = new HashSet<>();  //for saving previously visited elements during current traversal\\n            int cur = start, count = 0, sign = nums[start] > 0 ? 1 : -1;\\n            while (!checked.contains(cur) && nums[cur] * sign > 0) {\\n                checked.add(cur);\\n                cur = ((cur + nums[cur]) % length + length) % length;\\n                ++count;\\n                if (cur == start && count > 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int length = nums.length;\\n        Set<Integer> finished = new HashSet<>();\\n        for (int i = 0; i < length; ++i) {\\n            Set<Integer> checked = new HashSet<>();\\n            int startIndex = i, curIndex = i, count = 0, sign = nums[i] > 0 ? 1 : -1;\\n            while (!finished.contains(curIndex) && !checked.contains(curIndex)) {\\n                if (nums[curIndex] * sign < 0 || Math.abs(nums[curIndex]) == length) {\\n                    finished.addAll(checked);\\n                    break;\\n                }\\n                checked.add(curIndex);\\n                curIndex = ((curIndex + nums[curIndex]) % length + length) % length;\\n                ++count;\\n                if (checked.contains(curIndex)) {\\n                    if (count > 1) return true;\\n                    else break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int length = nums.length, inc = 1001;\\n        for (int startIndex = 0; startIndex < length; ++startIndex) {\\n            int curIndex = startIndex, count = 0, sign = nums[startIndex] > 0 ? 1 : -1;\\n            while (nums[curIndex] <= 1000) {\\n                if (nums[curIndex] * sign < 0 || Math.abs(nums[curIndex]) == length) {\\n                    ++inc;\\n                    break;\\n                }\\n                int prev = curIndex;\\n                curIndex = ((curIndex + nums[curIndex]) % length + length) % length;\\n                nums[prev] = inc;\\n                ++count;\\n                if (nums[curIndex] == inc) {\\n                    if (count > 1) return true;\\n                    ++inc;\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029163,
                "title": "c-100-faster-than-other-c-only-arrays",
                "content": "```\\n// Intuition :\\n// for negative numbers , cycle is  clockwise \\n// for positive numbers , cycle is anti clock wise\\n\\n// For negative numbers :\\n// loop through the array , as u encounter negative number ....\\n// Find the next position to move .\\n// step 1: j = (j + nums[j] + n)%n will give us next position .\\n// Go to that position and repeat step 1.\\n\\n// Now comes the tricky part , how to detect the cycle . \\n// keep a visited array ? \\n// Yes, why not ? but we want o(1) Space complexity ?\\n// Use input array as visited array, but how ?\\n// See the constraints , it is givem nums[i] < 1000 && > -1000\\n// so mark our input array with this numbers .\\n// I used -1000-i , for clockwise cycle. \\n//  y -1001-i , y not -1001 ?\\n// well, we want a cycle when visited through starting for that i.\\n// Do some paper work to get this point .\\n// Or try with -10001 as marking,, failed testcases will explain u better.\\n\\n// Same reasoning holds for anticlock wise cycle.\\n\\n\\n\\n#define N 10001\\nclass Solution {\\npublic:\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        \\n        int  n = nums.size();\\n        int len = 0;\\n        // anticlockwise\\n        \\n        \\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] <= -1001){continue;}\\n            int j = i, prev_j;\\n            len = 0;\\n            while(nums[j] < 0)\\n            {\\n                if(nums[j] <= -1001){\\n                     if(nums[j] == -1001-i && len > 1 && prev_j != j){\\n                    return true;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                \\n                int temp = nums[j];\\n                nums[j] = -1001-i;\\n                prev_j = j;\\n                if(temp < (-1 * n))\\n                {\\n                    temp = temp/n;\\n                }\\n                j = (j + temp + n)%n;\\n                len++;\\n                \\n            }\\n        }\\n         // clockwise\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] >= 1001){continue;}\\n            int j = i,prev_j;\\n            len = 0;\\n            while(nums[j] > 0)\\n            {\\n                if(nums[j] >= 1001 ){\\n                    if(nums[j] == 1001+i && len > 1 && j != prev_j){\\n                    return true;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                \\n                int temp = nums[j];\\n                nums[j] = 1001+i;\\n                prev_j = j;\\n                j = (j + temp )%n;\\n                len++;\\n                \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n// Intuition :\\n// for negative numbers , cycle is  clockwise \\n// for positive numbers , cycle is anti clock wise\\n\\n// For negative numbers :\\n// loop through the array , as u encounter negative number ....\\n// Find the next position to move .\\n// step 1: j = (j + nums[j] + n)%n will give us next position .\\n// Go to that position and repeat step 1.\\n\\n// Now comes the tricky part , how to detect the cycle . \\n// keep a visited array ? \\n// Yes, why not ? but we want o(1) Space complexity ?\\n// Use input array as visited array, but how ?\\n// See the constraints , it is givem nums[i] < 1000 && > -1000\\n// so mark our input array with this numbers .\\n// I used -1000-i , for clockwise cycle. \\n//  y -1001-i , y not -1001 ?\\n// well, we want a cycle when visited through starting for that i.\\n// Do some paper work to get this point .\\n// Or try with -10001 as marking,, failed testcases will explain u better.\\n\\n// Same reasoning holds for anticlock wise cycle.\\n\\n\\n\\n#define N 10001\\nclass Solution {\\npublic:\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        \\n        int  n = nums.size();\\n        int len = 0;\\n        // anticlockwise\\n        \\n        \\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] <= -1001){continue;}\\n            int j = i, prev_j;\\n            len = 0;\\n            while(nums[j] < 0)\\n            {\\n                if(nums[j] <= -1001){\\n                     if(nums[j] == -1001-i && len > 1 && prev_j != j){\\n                    return true;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                \\n                int temp = nums[j];\\n                nums[j] = -1001-i;\\n                prev_j = j;\\n                if(temp < (-1 * n))\\n                {\\n                    temp = temp/n;\\n                }\\n                j = (j + temp + n)%n;\\n                len++;\\n                \\n            }\\n        }\\n         // clockwise\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] >= 1001){continue;}\\n            int j = i,prev_j;\\n            len = 0;\\n            while(nums[j] > 0)\\n            {\\n                if(nums[j] >= 1001 ){\\n                    if(nums[j] == 1001+i && len > 1 && j != prev_j){\\n                    return true;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                \\n                int temp = nums[j];\\n                nums[j] = 1001+i;\\n                prev_j = j;\\n                j = (j + temp )%n;\\n                len++;\\n                \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971359,
                "title": "java-faster-than-100-o-n-time-and-o-1-space-easy-interview-tip",
                "content": "**Note:** we can do *O(1)* space in this problem because the *limits* were given in the problem: **from -1000 to 1000** and we always increase/decrease the visited value to know if the visited position was visited in the current iteration or not. Ex: [-1,-1,1,-1,1,5] the final array would be [-1001, -1002, 1001, -1003, 1002, 1002] having the cycle at indexes 4 and 5.\\n\\nOn a real interview if you don\\'t have an explicit limit confirm with the interviewer first otherwise you will need to use an extra array to compute the visited and hence space complexity goes to O(n) instead of O(1).\\n\\nYou could use this same approach with **slow** and **fast** pointers but you would need to use the extra array because until the pointers meet, your **fast** pointer will reach already **visited** positions so you won\\'t be able to know which position to go next to meet slow pointer if you change the values in the original array. Also with **fast** and **slow** pointers approach, you just need to check if the position was visited **before** in the **first loop** and skip that position in case it was visited. If you have a cycle, **slow** and **fast** pointers will meet eventually.\\n\\n```\\nclass Solution {\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        \\n        final int limit = 1000;\\n        int visitedForward = limit;\\n        int visitedBackward = -limit;\\n        \\n        for(int i = 0; i< nums.length; i++) {\\n            if(isVisited(nums[i], limit)) // already visited\\n                continue;\\n            \\n            boolean isForward = nums[i] > 0;\\n            int nextPos = i;\\n            int visitFlag = isForward ? ++visitedForward : --visitedBackward; \\n            //keep the sign in the flag to know the direction\\n            \\n            do {\\n                nextPos = getNextPos(nums, nextPos, isForward, visitFlag);\\n            } while (nextPos > -1 && \\n                     nextPos != i && \\n                     !isVisited(nums[nextPos], limit));\\n            \\n            if(nextPos > -1 && (nextPos == i || nums[nextPos] == visitFlag))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean isVisited (int val, int limit) {\\n        return Math.abs(val) > limit;\\n    }\\n    \\n    // return -1 if invalid pos\\n    private int getNextPos(int[] nums, int i, boolean isForward, int visitFlag) {\\n        boolean direction = nums[i] > 0;\\n        \\n        if(direction != isForward) \\n            return -1;\\n        \\n        int next = (i + nums[i]) % nums.length;\\n        \\n        if (next < 0) \\n            next += nums.length; // in case it\\'s negative counterbalance with the array size to know the real position\\n        \\n        nums[i] = visitFlag;\\n        \\n        return next == i ? -1 : next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        \\n        final int limit = 1000;\\n        int visitedForward = limit;\\n        int visitedBackward = -limit;\\n        \\n        for(int i = 0; i< nums.length; i++) {\\n            if(isVisited(nums[i], limit)) // already visited\\n                continue;\\n            \\n            boolean isForward = nums[i] > 0;\\n            int nextPos = i;\\n            int visitFlag = isForward ? ++visitedForward : --visitedBackward; \\n            //keep the sign in the flag to know the direction\\n            \\n            do {\\n                nextPos = getNextPos(nums, nextPos, isForward, visitFlag);\\n            } while (nextPos > -1 && \\n                     nextPos != i && \\n                     !isVisited(nums[nextPos], limit));\\n            \\n            if(nextPos > -1 && (nextPos == i || nums[nextPos] == visitFlag))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean isVisited (int val, int limit) {\\n        return Math.abs(val) > limit;\\n    }\\n    \\n    // return -1 if invalid pos\\n    private int getNextPos(int[] nums, int i, boolean isForward, int visitFlag) {\\n        boolean direction = nums[i] > 0;\\n        \\n        if(direction != isForward) \\n            return -1;\\n        \\n        int next = (i + nums[i]) % nums.length;\\n        \\n        if (next < 0) \\n            next += nums.length; // in case it\\'s negative counterbalance with the array size to know the real position\\n        \\n        nums[i] = visitFlag;\\n        \\n        return next == i ? -1 : next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813722,
                "title": "two-o-n-python-solutions-and-thought-process",
                "content": "***O(N) Time, O(N) Space***\\nSimple thought process:\\n\\n1. We *could* check for a cycle for every `i` in `range(len(nums))` but that would be quite slow.  The redundancy comes from the fact that paths can be subsets of other paths, so we\\'d be checking a maximum of `len(nums)` nodes for every single starting node.  This would be brute force and would be` O(n^2)`.\\n2. Instead let\\'s trade some space for time.  Let\\'s track all nodes we\\'ve seen so far for each path.  When we find that the path **isn\\'t** in cycle, we can store all nodes in that path in global `set` which tracks all nodes **not** in a cycle.\\n3. On the next iterations, we can just check if we\\'ve already visited this node by checking our global `set` and skipping if necessary.\\n4. During any of these iterations we can `return True` immediately once we find a cycle.\\n\\n\\n```\\nclass Solution(object):\\n  def circularArrayLoop(self, nums):\\n    N = len(nums)\\n    notcycle = set()\\n    for i in range(N):\\n      if i in notcycle: continue\\n      inpath = set()\\n      j, last = i, -1\\n      while (nums[i]>0) == (nums[j]>0):\\n        if j in inpath:\\n          if last==j:\\n            break\\n          return True\\n        inpath.add(j)\\n        last = j\\n        j = (j+nums[j])%N\\n      notcycle = notcycle.union(inpath)\\n    return False\\n```\\n\\n***O(N) Time, O(1) Space***\\n\\nEvolving from O(N) Space solution:\\n1. Realize that instead of keeping a separate map to store all nodes that aren\\'t in cycles, we can just use the array we already have.  We will set an element\\'s value to `0` to indicate it has already been checked and is not in a cycle.\\n2. To use constant space, we also need to sacrifice our set that tracks a current path.  Instead, we can use the common slow/fast pointer pattern to check for cycles.\\n3. Since we\\'re no longer tracking path nodes in a set, we need to run through identified non-cycle paths and set all values to zero. \\n4. We also need to carefully make sure we are tracking every node along our path and checking validity.  If we see a violating node at any point (`0` or different polarity), we can exit immediately.\\n\\n```\\nclass Solution(object):\\n  def circularArrayLoop(self, nums):\\n    N = len(nums)\\n    def next(x):\\n      return (x+nums[x])%N\\n    \\n    for i in range(N):\\n      if nums[i]==0: continue\\n      slow = fast = i\\n      last = -1\\n      forward = nums[i]>0\\n      \\n      # Make sure we never encounter invalid cycle nodes\\n      while ((nums[fast]>0) == (nums[last]>0) == forward) and nums[fast]!=0 and nums[last]!=0:\\n        \\n        # Possible cycle\\n        if last!= -1 and fast == slow:\\n          if last == fast:\\n            break\\n          return True\\n        \\n        # Increment our pointers\\n        slow = next(slow)\\n        last = fast = next(fast)\\n        fast = next(fast)\\n      \\n      # Lastly, save invalid nodes\\n      curr = i\\n      while nums[curr] != 0 and (nums[curr]>0) == forward:\\n        temp = curr\\n        curr = next(fast)\\n        nums[temp] = 0\\n    \\n    return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n  def circularArrayLoop(self, nums):\\n    N = len(nums)\\n    notcycle = set()\\n    for i in range(N):\\n      if i in notcycle: continue\\n      inpath = set()\\n      j, last = i, -1\\n      while (nums[i]>0) == (nums[j]>0):\\n        if j in inpath:\\n          if last==j:\\n            break\\n          return True\\n        inpath.add(j)\\n        last = j\\n        j = (j+nums[j])%N\\n      notcycle = notcycle.union(inpath)\\n    return False\\n```\n```\\nclass Solution(object):\\n  def circularArrayLoop(self, nums):\\n    N = len(nums)\\n    def next(x):\\n      return (x+nums[x])%N\\n    \\n    for i in range(N):\\n      if nums[i]==0: continue\\n      slow = fast = i\\n      last = -1\\n      forward = nums[i]>0\\n      \\n      # Make sure we never encounter invalid cycle nodes\\n      while ((nums[fast]>0) == (nums[last]>0) == forward) and nums[fast]!=0 and nums[last]!=0:\\n        \\n        # Possible cycle\\n        if last!= -1 and fast == slow:\\n          if last == fast:\\n            break\\n          return True\\n        \\n        # Increment our pointers\\n        slow = next(slow)\\n        last = fast = next(fast)\\n        fast = next(fast)\\n      \\n      # Lastly, save invalid nodes\\n      curr = i\\n      while nums[curr] != 0 and (nums[curr]>0) == forward:\\n        temp = curr\\n        curr = next(fast)\\n        nums[temp] = 0\\n    \\n    return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746342,
                "title": "java-simple-solution-fast-slow-pointer",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for (int i=0; i<nums.length; i++) {\\n            boolean isForward = nums[i] > 0;\\n            int slow = i;\\n            int fast = i;\\n            \\n            do {\\n                slow = findNextIndex(nums, isForward, slow);\\n                fast = findNextIndex(nums, isForward, fast);\\n            \\n                if (fast != -1) {\\n                    fast = findNextIndex(nums, isForward, fast);\\n                }\\n            } while (slow != -1 && fast != -1 && slow != fast);\\n            \\n            if (slow != -1 && slow == fast) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int findNextIndex(int[] arr, boolean isForward, int currentIndex) {\\n        boolean direction = arr[currentIndex] >= 0;\\n        \\n        if (isForward != direction) {\\n            return -1;\\n        }\\n        \\n        int nextIndex = (currentIndex + arr[currentIndex]) % arr.length;\\n        \\n        if (nextIndex < 0) {\\n            nextIndex += arr.length;\\n        }\\n        \\n        if (nextIndex == currentIndex) {\\n            nextIndex = -1;\\n        }\\n        \\n        return nextIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for (int i=0; i<nums.length; i++) {\\n            boolean isForward = nums[i] > 0;\\n            int slow = i;\\n            int fast = i;\\n            \\n            do {\\n                slow = findNextIndex(nums, isForward, slow);\\n                fast = findNextIndex(nums, isForward, fast);\\n            \\n                if (fast != -1) {\\n                    fast = findNextIndex(nums, isForward, fast);\\n                }\\n            } while (slow != -1 && fast != -1 && slow != fast);\\n            \\n            if (slow != -1 && slow == fast) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int findNextIndex(int[] arr, boolean isForward, int currentIndex) {\\n        boolean direction = arr[currentIndex] >= 0;\\n        \\n        if (isForward != direction) {\\n            return -1;\\n        }\\n        \\n        int nextIndex = (currentIndex + arr[currentIndex]) % arr.length;\\n        \\n        if (nextIndex < 0) {\\n            nextIndex += arr.length;\\n        }\\n        \\n        if (nextIndex == currentIndex) {\\n            nextIndex = -1;\\n        }\\n        \\n        return nextIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409910,
                "title": "ac-readable-python-12-lines",
                "content": "```\\ndef circularArrayLoop(self, nums: List[int]) -> bool:        \\n\\ts, l = [], len(nums)\\n\\tfor i, n in enumerate(nums):\\n\\t\\tif i in s: continue                 # check repeated i\\n\\t\\td = []\\n\\t\\twhile n*nums[i]>0:                  # forward or backward movements only\\n\\t\\t\\tif i in d:\\n\\t\\t\\t\\tif d[-1]!=i: return True    # the cycle\\'s length must be greater than 1\\n\\t\\t\\t\\telse: break\\n\\t\\t\\td.append(i)                     # store i for a cycle\\n\\t\\t\\ts.append(i)                     # store i without checking the repetition in the following\\n\\t\\t\\ti = (i+nums[i])%l\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef circularArrayLoop(self, nums: List[int]) -> bool:        \\n\\ts, l = [], len(nums)\\n\\tfor i, n in enumerate(nums):\\n\\t\\tif i in s: continue                 # check repeated i\\n\\t\\td = []\\n\\t\\twhile n*nums[i]>0:                  # forward or backward movements only\\n\\t\\t\\tif i in d:\\n\\t\\t\\t\\tif d[-1]!=i: return True    # the cycle\\'s length must be greater than 1\\n\\t\\t\\t\\telse: break\\n\\t\\t\\td.append(i)                     # store i for a cycle\\n\\t\\t\\ts.append(i)                     # store i without checking the repetition in the following\\n\\t\\t\\ti = (i+nums[i])%l\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 94226,
                "title": "solution-for-2-1-1-2-2",
                "content": "How come the solution for array [-2, 1, -1, -2, -2] is false?\\nFrom element 1 we go to element 2, from element 2 back to 1, that's a loop.\\nWhat am I missing here?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2820902,
                "title": "circular-array-problem-solved-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo pointer approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i=0; i<nums.length; i++) {\\n            boolean frontDirection = nums[i]>=0;\\n            \\n            int currentPosition = i;\\n            int fastPosition = i;\\n            \\n            while(true) {\\n                currentPosition = getNextPosition(nums, currentPosition, frontDirection);\\n                \\n                if(currentPosition==-1) {\\n                    break;\\n                }\\n                \\n                fastPosition = getNextPosition(nums, fastPosition, frontDirection);\\n                \\n                if(fastPosition==-1) {\\n                    break;\\n                }\\n                \\n                fastPosition = getNextPosition(nums, fastPosition, frontDirection);\\n                \\n                if(fastPosition==-1) {\\n                    break;\\n                }\\n                \\n                if(currentPosition == fastPosition) {\\n                    return true;\\n                }\\n                \\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n    public  int getNextPosition(int[] nums, int index, boolean frontDirection) {\\n        \\n        \\n        int nextIndex = (nums[index] + index)%nums.length;\\n        if(nextIndex<0) {\\n            nextIndex = nums.length + nextIndex;\\n        }\\n        \\n        if(index==nextIndex) {\\n            return -1;\\n        }\\n        \\n        boolean direction =  nums[nextIndex]>=0;\\n        \\n        if(direction!=frontDirection) {\\n            return -1;\\n        }\\n        \\n        return nextIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i=0; i<nums.length; i++) {\\n            boolean frontDirection = nums[i]>=0;\\n            \\n            int currentPosition = i;\\n            int fastPosition = i;\\n            \\n            while(true) {\\n                currentPosition = getNextPosition(nums, currentPosition, frontDirection);\\n                \\n                if(currentPosition==-1) {\\n                    break;\\n                }\\n                \\n                fastPosition = getNextPosition(nums, fastPosition, frontDirection);\\n                \\n                if(fastPosition==-1) {\\n                    break;\\n                }\\n                \\n                fastPosition = getNextPosition(nums, fastPosition, frontDirection);\\n                \\n                if(fastPosition==-1) {\\n                    break;\\n                }\\n                \\n                if(currentPosition == fastPosition) {\\n                    return true;\\n                }\\n                \\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n    public  int getNextPosition(int[] nums, int index, boolean frontDirection) {\\n        \\n        \\n        int nextIndex = (nums[index] + index)%nums.length;\\n        if(nextIndex<0) {\\n            nextIndex = nums.length + nextIndex;\\n        }\\n        \\n        if(index==nextIndex) {\\n            return -1;\\n        }\\n        \\n        boolean direction =  nums[nextIndex]>=0;\\n        \\n        if(direction!=frontDirection) {\\n            return -1;\\n        }\\n        \\n        return nextIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473124,
                "title": "3-1-2-expected-output-true-how-loop-0-0-0-thus-k-1",
                "content": "Can someone please explain me how [3,1,2] gives true output as from 0th index we always jump to 0th index and then length of loop will be 1.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2140422,
                "title": "my-acc-c-code",
                "content": "```\\n bool circularArrayLoop(vector<int>& nums) {\\n        int n= nums.size(),len;\\n        vector<int> done(n,0); bool sign, s2;\\n        \\n        if(n==1)return false;\\n        \\n        for(int i=0;i<n; i++){\\n            \\n            int j=i;\\n            sign = nums[i]>0; \\n            len = 0;\\n            \\n            while(len<n){\\n                j = j + nums[j];\\n                if(j>=n)\\n                    j = j%n;\\n                else if(j<0)\\n                    j = n + (j%n);\\n                \\n                s2 = nums[j]>0;\\n                \\n                if(sign!=s2)\\n                    break;\\n                \\n                if(j==i and len == 0){\\n                    break;\\n                }\\n                \\n                if(j==i)return true;\\n                \\n                len++;\\n            }\\n            \\n        }\\n    \\n    return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool circularArrayLoop(vector<int>& nums) {\\n        int n= nums.size(),len;\\n        vector<int> done(n,0); bool sign, s2;\\n        \\n        if(n==1)return false;\\n        \\n        for(int i=0;i<n; i++){\\n            \\n            int j=i;\\n            sign = nums[i]>0; \\n            len = 0;\\n            \\n            while(len<n){\\n                j = j + nums[j];\\n                if(j>=n)\\n                    j = j%n;\\n                else if(j<0)\\n                    j = n + (j%n);\\n                \\n                s2 = nums[j]>0;\\n                \\n                if(sign!=s2)\\n                    break;\\n                \\n                if(j==i and len == 0){\\n                    break;\\n                }\\n                \\n                if(j==i)return true;\\n                \\n                len++;\\n            }\\n            \\n        }\\n    \\n    return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909771,
                "title": "java-o-n-fast-and-slow-pointer-solution-clear-code-successor-graph-problem",
                "content": "Please upvote if you find it helpful! Or leave comment and suggestions below! \\nI will try my best to answer them! Thank you for being supportive!\\n\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited.contains(i)) continue;\\n            if (hasLoop(nums, i, visited)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean hasLoop(int[] nums, int start, Set<Integer> visited) {\\n        int n = nums.length;\\n        int fast = succ(nums, start, 1, n), slow = start;\\n        while (fast != slow) {\\n            visited.add(slow);\\n            visited.add(fast);\\n            fast = succ(nums, fast, 2, n);\\n            slow = succ(nums, slow, 1, n);\\n        }\\n\\t\\t\\n        int startPoint = fast;\\n        fast = succ(nums, fast, 1, n);\\n        if (fast == slow) return false;\\n        \\n        while (fast != startPoint) {\\n            if ((nums[slow] ^ nums[fast]) < 0) {\\n                return false;\\n            }\\n            slow = fast;\\n            fast = succ(nums, fast, 1, n);\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int succ(int[] nums, int idx, int k, int n) {\\n        while (k > 0) {\\n            idx = (n + (nums[idx] + idx) % n) % n;\\n            k--;\\n        }\\n        return idx;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited.contains(i)) continue;\\n            if (hasLoop(nums, i, visited)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean hasLoop(int[] nums, int start, Set<Integer> visited) {\\n        int n = nums.length;\\n        int fast = succ(nums, start, 1, n), slow = start;\\n        while (fast != slow) {\\n            visited.add(slow);\\n            visited.add(fast);\\n            fast = succ(nums, fast, 2, n);\\n            slow = succ(nums, slow, 1, n);\\n        }\\n\\t\\t\\n        int startPoint = fast;\\n        fast = succ(nums, fast, 1, n);\\n        if (fast == slow) return false;\\n        \\n        while (fast != startPoint) {\\n            if ((nums[slow] ^ nums[fast]) < 0) {\\n                return false;\\n            }\\n            slow = fast;\\n            fast = succ(nums, fast, 1, n);\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int succ(int[] nums, int idx, int k, int n) {\\n        while (k > 0) {\\n            idx = (n + (nums[idx] + idx) % n) % n;\\n            k--;\\n        }\\n        return idx;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861696,
                "title": "c-easy-simple-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int j = 0; j < n;j++){nums[j] %= n;}\\n        for (int j = 0; j < n;j++){\\n            int i = j, last_i = 0;\\n            bool f = nums[i] > 0;\\n            while (nums[i] % n != 0 && nums[i] > 0 == f) {\\n                last_i = i;\\n                i = (i + nums[i] + n) % n;\\n                nums[last_i] = (j + 1) * n;\\n                if (nums[i] == (j + 1) * n) \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int j = 0; j < n;j++){nums[j] %= n;}\\n        for (int j = 0; j < n;j++){\\n            int i = j, last_i = 0;\\n            bool f = nums[i] > 0;\\n            while (nums[i] % n != 0 && nums[i] > 0 == f) {\\n                last_i = i;\\n                i = (i + nums[i] + n) % n;\\n                nums[last_i] = (j + 1) * n;\\n                if (nums[i] == (j + 1) * n) \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685965,
                "title": "simple-easy-to-understand-c-solution-in-o-n-2",
                "content": "Approch is simple or we can say it as a brute force approch . So , what we are gonna do is , we just traverse whole the array / vector , and check for each element if it is able to form a cycle starting from this element or not .\\n```\\nclass Solution\\n{\\npublic:\\n\\tbool circularArrayLoop(vector<int> &nums)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tint x = nums[i];\\n\\t\\t\\tvector<int> v(n, 0);   // Vector to store the occurence of a given element while traversing a cycle\\n\\t\\t\\t// int c = 1;\\n\\t\\t\\tint count = 0;   // For calculate the no. of elements in cycle\\n\\t\\t\\tint y = i;\\n\\t\\t\\t// int j = i;\\n\\t\\t\\twhile (x != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (x > 0)   // For dealing with positive elements seperately\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ty = (y + nums[y]) % n;\\n\\t\\t\\t\\t\\t// j = y;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif (nums[y] < 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n                        if (y == i && count > 1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (y == i && count < 2)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (v[y] == 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tv[y] = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse     //For negetive elements \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ty = (y + nums[y] + n)%n;\\n                    if(y<0){\\n                        while(y<0){\\n                          y = (y+n)%n;\\n                        }\\n                    }\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif (nums[y] > 0)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n                        if (y == i && count > 1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (y == i && count < 2)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (v[y] == 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tv[y] = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n```\\nHope this is helpfull for u all : )",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tbool circularArrayLoop(vector<int> &nums)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tint x = nums[i];\\n\\t\\t\\tvector<int> v(n, 0);   // Vector to store the occurence of a given element while traversing a cycle\\n\\t\\t\\t// int c = 1;\\n\\t\\t\\tint count = 0;   // For calculate the no. of elements in cycle\\n\\t\\t\\tint y = i;\\n\\t\\t\\t// int j = i;\\n\\t\\t\\twhile (x != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (x > 0)   // For dealing with positive elements seperately\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ty = (y + nums[y]) % n;\\n\\t\\t\\t\\t\\t// j = y;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif (nums[y] < 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n                        if (y == i && count > 1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (y == i && count < 2)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (v[y] == 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tv[y] = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse     //For negetive elements \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ty = (y + nums[y] + n)%n;\\n                    if(y<0){\\n                        while(y<0){\\n                          y = (y+n)%n;\\n                        }\\n                    }\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif (nums[y] > 0)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n                        if (y == i && count > 1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (y == i && count < 2)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (v[y] == 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tv[y] = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568628,
                "title": "python-graph-finding-cycle-100-20ms",
                "content": "```\\nimport collections\\ndef dfs(cur,visit,g):\\n    # In visit list, 0 means unvisited, 1 means visited, -1 means we are currently recursing and encountered this element, \\n\\t# so we set -1 to 1 after completely searching through all possibilites from that element without finding a cycle else\\n\\t# If we encounter an element with -1 value in visit, then it implies we have found a cycle.\\n    if visit[cur]==(-1):\\n        return True\\n    if visit[cur]==1:\\n        return False\\n    visit[cur]=(-1)\\n    for i in g[cur]:\\n        if dfs(i,visit,g):\\n            return True\\n    visit[cur]=1\\n    return False\\nclass Solution:\\n    def circularArrayLoop(self, a: List[int]) -> bool:\\n        g=collections.defaultdict(list) #adjacency list\\n        n=len(a)\\n\\t\\t#creating edges from current index to where is it possible to jump\\n        for i in range(n):  \\n            x=i+a[i]\\n\\t\\t    #In case of x crosses the range [0,n-1]\\n            x = x%n  \\n\\t\\t\\t#Making sure self edges do not form and edges are formed only between elements of same sign\\n            if x!=i and a[i]*a[x]>=0: \\n                g[i].append(x)\\n        visit=[0]*n\\n\\t\\t#Function to find cycles in a graph\\n        for i in range(n):\\n            if dfs(i,visit,g):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\nimport collections\\ndef dfs(cur,visit,g):\\n    # In visit list, 0 means unvisited, 1 means visited, -1 means we are currently recursing and encountered this element, \\n\\t# so we set -1 to 1 after completely searching through all possibilites from that element without finding a cycle else\\n\\t# If we encounter an element with -1 value in visit, then it implies we have found a cycle.\\n    if visit[cur]==(-1):\\n        return True\\n    if visit[cur]==1:\\n        return False\\n    visit[cur]=(-1)\\n    for i in g[cur]:\\n        if dfs(i,visit,g):\\n            return True\\n    visit[cur]=1\\n    return False\\nclass Solution:\\n    def circularArrayLoop(self, a: List[int]) -> bool:\\n        g=collections.defaultdict(list) #adjacency list\\n        n=len(a)\\n\\t\\t#creating edges from current index to where is it possible to jump\\n        for i in range(n):  \\n            x=i+a[i]\\n\\t\\t    #In case of x crosses the range [0,n-1]\\n            x = x%n  \\n\\t\\t\\t#Making sure self edges do not form and edges are formed only between elements of same sign\\n            if x!=i and a[i]*a[x]>=0: \\n                g[i].append(x)\\n        visit=[0]*n\\n\\t\\t#Function to find cycles in a graph\\n        for i in range(n):\\n            if dfs(i,visit,g):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565620,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public bool CircularArrayLoop(int[] nu``ms) {\\n        int n = nums.Length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sign = nums[i];\\n            int next = (i+nums[i]%n+n)%n;\\n            int count =1; //number of element in the sequence\\n            if(i==next) //only one element\\n            {\\n                continue;\\n            }\\n            while(nums[next]*sign>0)\\n            {\\n                if(count>n) \\n                {\\n                    break;\\n                }\\n                if(next==i)\\n                {\\n                    return true;\\n                }\\n                next = (next+nums[next]%n+n)%n;\\n                count++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CircularArrayLoop(int[] nu``ms) {\\n        int n = nums.Length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sign = nums[i];\\n            int next = (i+nums[i]%n+n)%n;\\n            int count =1; //number of element in the sequence\\n            if(i==next) //only one element\\n            {\\n                continue;\\n            }\\n            while(nums[next]*sign>0)\\n            {\\n                if(count>n) \\n                {\\n                    break;\\n                }\\n                if(next==i)\\n                {\\n                    return true;\\n                }\\n                next = (next+nums[next]%n+n)%n;\\n                count++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521362,
                "title": "c-solution-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxPositive = 1e5;\\n        int fl = 0;\\n        int ct = 0;\\n        \\n        for(int i = 0;i < n;i++){\\n            if(nums[i] > maxPositive || nums[i] < maxPositive*-1)continue;\\n            int x = nums[i] + i;\\n            while(x < n)x += n;\\n            x%=n;\\n            if(x == i)continue;\\n            \\n            ct++;\\n            if(nums[i] > 0)fl = 1;\\n            else fl = -1;\\n            int val = fl*(maxPositive + ct);\\n            \\n            nums[i] = val;\\n            \\n            while(true){\\n                if(nums[x] == val)return true;\\n                if(nums[x] > maxPositive || nums[x] < maxPositive*-1)break;\\n                if(nums[x]*val <= 0)break;\\n                int y = nums[x] + x;\\n                while(y < n)y += n;\\n                y%=n;\\n                nums[x] = val;\\n                if(y == x)break;\\n                x = y;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxPositive = 1e5;\\n        int fl = 0;\\n        int ct = 0;\\n        \\n        for(int i = 0;i < n;i++){\\n            if(nums[i] > maxPositive || nums[i] < maxPositive*-1)continue;\\n            int x = nums[i] + i;\\n            while(x < n)x += n;\\n            x%=n;\\n            if(x == i)continue;\\n            \\n            ct++;\\n            if(nums[i] > 0)fl = 1;\\n            else fl = -1;\\n            int val = fl*(maxPositive + ct);\\n            \\n            nums[i] = val;\\n            \\n            while(true){\\n                if(nums[x] == val)return true;\\n                if(nums[x] > maxPositive || nums[x] < maxPositive*-1)break;\\n                if(nums[x]*val <= 0)break;\\n                int y = nums[x] + x;\\n                while(y < n)y += n;\\n                y%=n;\\n                nums[x] = val;\\n                if(y == x)break;\\n                x = y;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092712,
                "title": "python-two-pointers-o-n-2-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        def get_next_index(nums, cur_index, is_positive):\\n            direction = nums[cur_index] >= 0\\n            if direction != is_positive:\\n                return -1\\n            \\n            next_index = (cur_index+nums[cur_index])%len(nums)\\n            if next_index < 0:\\n                next_index = len(nums) - next_index \\n                \\n            if next_index == cur_index:\\n                next_index = -1\\n                \\n            return next_index\\n        \\n        for index in range(len(nums)):\\n            is_positive = nums[index] >= 0\\n            fast, slow, = index, index\\n            while True:\\n                slow = get_next_index(nums, slow, is_positive)\\n                fast = get_next_index(nums, fast, is_positive)\\n                \\n                if fast != -1:\\n                    fast = get_next_index(nums, fast, is_positive)\\n                if slow == -1 or fast == -1:\\n                    break\\n                if slow == fast:\\n                    return True\\n        return False\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        def get_next_index(nums, cur_index, is_positive):\\n            direction = nums[cur_index] >= 0\\n            if direction != is_positive:\\n                return -1\\n            \\n            next_index = (cur_index+nums[cur_index])%len(nums)\\n            if next_index < 0:\\n                next_index = len(nums) - next_index \\n                \\n            if next_index == cur_index:\\n                next_index = -1\\n                \\n            return next_index\\n        \\n        for index in range(len(nums)):\\n            is_positive = nums[index] >= 0\\n            fast, slow, = index, index\\n            while True:\\n                slow = get_next_index(nums, slow, is_positive)\\n                fast = get_next_index(nums, fast, is_positive)\\n                \\n                if fast != -1:\\n                    fast = get_next_index(nums, fast, is_positive)\\n                if slow == -1 or fast == -1:\\n                    break\\n                if slow == fast:\\n                    return True\\n        return False\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039552,
                "title": "python3-two-pointers-o-n-time-o-1-memory-with-comments",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        \\n        # Example: [2,-1,1,2,2]\\n        # from 2 go to 1, from 1 go to 2, from 2 got to first 2 -> Cycle \\n        \\n\\t\\t # [-2,1,-1,-2,-2]\\n        # this is a directed graph: 0->3, 1->2, 2->1, 3->1, 4->2\\n\\t\\t# since every node has an outward edge to another node -> cycle (in the graph sense) is always present\\n\\n        # caveat: cycle\\'s length must be greater than 1\\n        # all movements in the cycle must be in the same direction. \\n\\t\\t\\n        # use Floyd\\'s cycle-finding algorithm: fast pointer makes two jumps for each jump the slow pointer makes\\n        # cycle detected if pointer slow == pointer fast\\n\\t\\t# then verify whether the cycle meets the conditions \\n\\t\\t\\n        # O(n) time and O(1) space\\n      \\n        # edge case: graph consists of two separate cycles: 0->1, 1->0 & 2->3->4, 4->2\\n        # but we want to detect the second cycle \\n        # if cycle of length 1 detected: skip and update slow and fast pointers \\n        \\n        # cycle length: have to compute by traversing the cycle again since we can\\'t save anything extra\\n        # if more memory allowed: keep a counter for jumps taken, save a \"last seen at\" number in an array of the same size\\n        \\n        N = len(nums)\\n        \\n        if N < 2:\\n            return False\\n        \\n        slow = 0 \\n        \\n        # fast pointer takes two steps\\n        fast = nums[0] % N \\n        fast = (fast + nums[fast]) % N \\n        count = 0\\n        \\n        while count < N:\\n            \\n            # print(count, nums[slow], nums[fast])\\n            count += 1\\n            \\n            if slow == fast:\\n                # cycle detected, check length, validate direction\\n                l = 0 \\n                step = nums[slow]\\n                ptr = (nums[slow] + slow) % N # take a step  \\n                \\n                while ptr != slow:\\n                    \\n                    # check if diff direction \\n                    if nums[ptr] * step < 0:\\n                        break\\n                    \\n                    ptr = (ptr + nums[ptr]) % N\\n                    l += 1\\n                    \\n                if l > 0 and ptr == slow:\\n                    return True \\n                \\n                else: # Must be careful about this update to get out of bad cycles\\n                    \\n                    # choose a different starting position (1 jump away from current slow pointer)\\n                    # consider the fast pointer as also starting from this position, but update it twice \\n                    slow = (slow + 1) % N \\n                    fast = (slow + nums[slow]) % N \\n                    fast = (fast + nums[fast]) % N  \\n              \\n            else:\\n                slow = (slow + nums[slow]) % N \\n                fast = (fast + nums[fast]) % N \\n                fast = (fast + nums[fast]) % N \\n            \\n        return False \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        \\n        # Example: [2,-1,1,2,2]\\n        # from 2 go to 1, from 1 go to 2, from 2 got to first 2 -> Cycle \\n        \\n\\t\\t # [-2,1,-1,-2,-2]\\n        # this is a directed graph: 0->3, 1->2, 2->1, 3->1, 4->2\\n\\t\\t# since every node has an outward edge to another node -> cycle (in the graph sense) is always present\\n\\n        # caveat: cycle\\'s length must be greater than 1\\n        # all movements in the cycle must be in the same direction. \\n\\t\\t\\n        # use Floyd\\'s cycle-finding algorithm: fast pointer makes two jumps for each jump the slow pointer makes\\n        # cycle detected if pointer slow == pointer fast\\n\\t\\t# then verify whether the cycle meets the conditions \\n\\t\\t\\n        # O(n) time and O(1) space\\n      \\n        # edge case: graph consists of two separate cycles: 0->1, 1->0 & 2->3->4, 4->2\\n        # but we want to detect the second cycle \\n        # if cycle of length 1 detected: skip and update slow and fast pointers \\n        \\n        # cycle length: have to compute by traversing the cycle again since we can\\'t save anything extra\\n        # if more memory allowed: keep a counter for jumps taken, save a \"last seen at\" number in an array of the same size\\n        \\n        N = len(nums)\\n        \\n        if N < 2:\\n            return False\\n        \\n        slow = 0 \\n        \\n        # fast pointer takes two steps\\n        fast = nums[0] % N \\n        fast = (fast + nums[fast]) % N \\n        count = 0\\n        \\n        while count < N:\\n            \\n            # print(count, nums[slow], nums[fast])\\n            count += 1\\n            \\n            if slow == fast:\\n                # cycle detected, check length, validate direction\\n                l = 0 \\n                step = nums[slow]\\n                ptr = (nums[slow] + slow) % N # take a step  \\n                \\n                while ptr != slow:\\n                    \\n                    # check if diff direction \\n                    if nums[ptr] * step < 0:\\n                        break\\n                    \\n                    ptr = (ptr + nums[ptr]) % N\\n                    l += 1\\n                    \\n                if l > 0 and ptr == slow:\\n                    return True \\n                \\n                else: # Must be careful about this update to get out of bad cycles\\n                    \\n                    # choose a different starting position (1 jump away from current slow pointer)\\n                    # consider the fast pointer as also starting from this position, but update it twice \\n                    slow = (slow + 1) % N \\n                    fast = (slow + nums[slow]) % N \\n                    fast = (fast + nums[fast]) % N  \\n              \\n            else:\\n                slow = (slow + nums[slow]) % N \\n                fast = (fast + nums[fast]) % N \\n                fast = (fast + nums[fast]) % N \\n            \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037326,
                "title": "java-two-pointers-solution-with-explaination-beat-100-time",
                "content": "```\\nclass Solution {\\n        public boolean circularArrayLoop(int[] nums) {\\n            // Why need i<nums.length-1 ?\\n            // Because nums.length should be larger than 2 to maintain a loop\\n            for (int i = 0; i < nums.length - 1; i++) {\\n                // Set fast and slow pointer ,and save the first number to check direction later\\n                int slow = i, fast = i, firstNum = nums[i];\\n\\n                // While making sure loop exists, move the two pointers until they meet each other\\n                do {\\n                    // Check and move the fast pointer twice\\n                    fast = findNextIndex(nums, firstNum, fast);\\n                    if (fast != -1) {\\n                        fast = findNextIndex(nums, firstNum, fast);\\n                        if (fast != -1) {\\n                            // Check and move the slow pointer once\\n                            slow = findNextIndex(nums, firstNum, slow);\\n                        }\\n                    }\\n                } while (slow != -1 && fast != -1 && slow != fast);\\n\\n                if (slow != -1 && slow == fast) {\\n                    // If fast and slow pointer have met each other, loop exists\\n                    return true;\\n                } else {\\n                    // If there is no loop in this route, abandon all elements along the route by setting them to 0\\n                    slow = i;\\n                    while (firstNum * nums[slow] > 0) {\\n                        int next = (slow + nums[slow]) >= 0 ?\\n                                (slow + nums[slow]) % nums.length : (slow + nums[slow]) % nums.length + nums.length;\\n                        nums[slow] = 0;\\n                        slow = next;\\n                    }\\n                }\\n            }\\n\\n            return false;\\n        }\\n\\n        private int findNextIndex(int[] arr, int firstNum, int currentIndex) {\\n            // If the direction changes or this element has been abandoned, return\\n            if (arr[currentIndex] * firstNum <= 0) {\\n                return -1;\\n            }\\n\\n            // Get next index\\n            int nextIndex = (currentIndex + arr[currentIndex]) >= 0 ?\\n                    (currentIndex + arr[currentIndex]) % arr.length : (currentIndex + arr[currentIndex]) % arr.length + arr.length;\\n\\n            // If Loop.length = 1, return\\n            if (nextIndex == currentIndex) {\\n                return -1;\\n            }\\n\\n            return nextIndex;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n        public boolean circularArrayLoop(int[] nums) {\\n            // Why need i<nums.length-1 ?\\n            // Because nums.length should be larger than 2 to maintain a loop\\n            for (int i = 0; i < nums.length - 1; i++) {\\n                // Set fast and slow pointer ,and save the first number to check direction later\\n                int slow = i, fast = i, firstNum = nums[i];\\n\\n                // While making sure loop exists, move the two pointers until they meet each other\\n                do {\\n                    // Check and move the fast pointer twice\\n                    fast = findNextIndex(nums, firstNum, fast);\\n                    if (fast != -1) {\\n                        fast = findNextIndex(nums, firstNum, fast);\\n                        if (fast != -1) {\\n                            // Check and move the slow pointer once\\n                            slow = findNextIndex(nums, firstNum, slow);\\n                        }\\n                    }\\n                } while (slow != -1 && fast != -1 && slow != fast);\\n\\n                if (slow != -1 && slow == fast) {\\n                    // If fast and slow pointer have met each other, loop exists\\n                    return true;\\n                } else {\\n                    // If there is no loop in this route, abandon all elements along the route by setting them to 0\\n                    slow = i;\\n                    while (firstNum * nums[slow] > 0) {\\n                        int next = (slow + nums[slow]) >= 0 ?\\n                                (slow + nums[slow]) % nums.length : (slow + nums[slow]) % nums.length + nums.length;\\n                        nums[slow] = 0;\\n                        slow = next;\\n                    }\\n                }\\n            }\\n\\n            return false;\\n        }\\n\\n        private int findNextIndex(int[] arr, int firstNum, int currentIndex) {\\n            // If the direction changes or this element has been abandoned, return\\n            if (arr[currentIndex] * firstNum <= 0) {\\n                return -1;\\n            }\\n\\n            // Get next index\\n            int nextIndex = (currentIndex + arr[currentIndex]) >= 0 ?\\n                    (currentIndex + arr[currentIndex]) % arr.length : (currentIndex + arr[currentIndex]) % arr.length + arr.length;\\n\\n            // If Loop.length = 1, return\\n            if (nextIndex == currentIndex) {\\n                return -1;\\n            }\\n\\n            return nextIndex;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029672,
                "title": "fast-slow-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int next(vector<int>& nums, int idx, bool dir){\\n        bool x=(nums[idx]>=0);\\n        if(x!=dir)\\n            return INT_MIN;\\n        int n=nums.size();\\n        int v=(idx+nums[idx])%n;\\n        if(v<0){\\n           v=v+nums.size();\\n        }\\n        if(v==idx)\\n            return INT_MIN;\\n        return v;\\n    }\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums.size()<2)\\n\\t\\t   return false;\\n        for(int i=0;i<n;i++){\\n            int slow=i,fast=i;\\n            bool dir=nums[i]>0;\\n            while(true){\\n                slow=next(nums,slow,dir);\\n                if(slow==INT_MIN)\\n                    break;\\n                fast=next(nums,fast,dir);\\n                if(fast==INT_MIN)\\n                    break;\\n                fast=next(nums,fast,dir);\\n                if(fast==INT_MIN)\\n                    break;\\n                if(slow==fast)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int next(vector<int>& nums, int idx, bool dir){\\n        bool x=(nums[idx]>=0);\\n        if(x!=dir)\\n            return INT_MIN;\\n        int n=nums.size();\\n        int v=(idx+nums[idx])%n;\\n        if(v<0){\\n           v=v+nums.size();\\n        }\\n        if(v==idx)\\n            return INT_MIN;\\n        return v;\\n    }\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums.size()<2)\\n\\t\\t   return false;\\n        for(int i=0;i<n;i++){\\n            int slow=i,fast=i;\\n            bool dir=nums[i]>0;\\n            while(true){\\n                slow=next(nums,slow,dir);\\n                if(slow==INT_MIN)\\n                    break;\\n                fast=next(nums,fast,dir);\\n                if(fast==INT_MIN)\\n                    break;\\n                fast=next(nums,fast,dir);\\n                if(fast==INT_MIN)\\n                    break;\\n                if(slow==fast)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001028,
                "title": "python-28ms-o-n-surpass-94-two-pointer",
                "content": "By keeping track of indexes visted during a search, avoid repeated operations.\\n```\\nclass Solution:\\n    def nextind(self,arr, forward, cind):\\n        direction = arr[cind]>=0\\n        if direction!= forward:\\n            return -1\\n        nexti = (cind+arr[cind])%len(arr)\\n        if cind==nexti:\\n            return -1\\n        return nexti\\n    \\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        visited=set()\\n        for i in range(len(nums)):\\n            cv=[]\\n            if i in visited:\\n                continue\\n            forward = nums[i] >= 0\\n            slow, fast = i, i\\n            while True:\\n                slow = self.nextind(nums,forward,slow)\\n                fast = self.nextind(nums,forward,fast)\\n                if fast!=-1:\\n                    fast = self.nextind(nums,forward,fast)\\n                cv.append(slow)\\n                cv.append(fast)\\n                if fast==-1 or slow==-1 or slow==fast:\\n                    break\\n            if slow != -1 and slow == fast:\\n                return True\\n            for x in cv:\\n                visited.add(x)\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def nextind(self,arr, forward, cind):\\n        direction = arr[cind]>=0\\n        if direction!= forward:\\n            return -1\\n        nexti = (cind+arr[cind])%len(arr)\\n        if cind==nexti:\\n            return -1\\n        return nexti\\n    \\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        visited=set()\\n        for i in range(len(nums)):\\n            cv=[]\\n            if i in visited:\\n                continue\\n            forward = nums[i] >= 0\\n            slow, fast = i, i\\n            while True:\\n                slow = self.nextind(nums,forward,slow)\\n                fast = self.nextind(nums,forward,fast)\\n                if fast!=-1:\\n                    fast = self.nextind(nums,forward,fast)\\n                cv.append(slow)\\n                cv.append(fast)\\n                if fast==-1 or slow==-1 or slow==fast:\\n                    break\\n            if slow != -1 and slow == fast:\\n                return True\\n            for x in cv:\\n                visited.add(x)\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 977568,
                "title": "simple-c-using-fast-and-slow-pointers",
                "content": "```\\nint getpos(vector<int> &nums,int i,int direction)\\n{\\n\\tint curr_direction=nums[i]>=0;\\n\\tif(curr_direction!=direction)\\n\\t\\treturn -1;\\n\\tint index=(nums[i]+i);\\n\\tint n=nums.size();\\n\\tindex=index%n;\\n\\tif(index<0)\\n\\t\\tindex=nums.size()+index;\\n\\tif(index==i)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\treturn index;\\n}\\nbool circularArrayLoop(vector<int>& nums) {\\n\\tif(nums.size()<2)\\n\\t\\treturn false;\\n\\tfor(int i=0;i<nums.size();i++)\\n\\t{\\n\\t\\tint fast=i,slow=i,direction=nums[i]>=0;\\n\\t\\twhile(1)\\n\\t\\t{\\n\\t\\t\\tslow=getpos(nums,slow,direction);\\n\\t\\t\\tif(slow==-1)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tfast=getpos(nums,fast,direction);\\n\\t\\t\\tif(fast==-1)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tfast=getpos(nums,fast,direction);\\n\\t\\t\\tif(fast==-1)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif(slow==fast)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint getpos(vector<int> &nums,int i,int direction)\\n{\\n\\tint curr_direction=nums[i]>=0;\\n\\tif(curr_direction!=direction)\\n\\t\\treturn -1;\\n\\tint index=(nums[i]+i);\\n\\tint n=nums.size();\\n\\tindex=index%n;\\n\\tif(index<0)\\n\\t\\tindex=nums.size()+index;\\n\\tif(index==i)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\treturn index;\\n}\\nbool circularArrayLoop(vector<int>& nums) {\\n\\tif(nums.size()<2)\\n\\t\\treturn false;\\n\\tfor(int i=0;i<nums.size();i++)\\n\\t{\\n\\t\\tint fast=i,slow=i,direction=nums[i]>=0;\\n\\t\\twhile(1)\\n\\t\\t{\\n\\t\\t\\tslow=getpos(nums,slow,direction);\\n\\t\\t\\tif(slow==-1)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tfast=getpos(nums,fast,direction);\\n\\t\\t\\tif(fast==-1)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tfast=getpos(nums,fast,direction);\\n\\t\\t\\tif(fast==-1)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif(slow==fast)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 958415,
                "title": "c-faster-than-100-00-o-1-extra-space-o-n-time-solution-with-explaination",
                "content": "**algorithm**\\nthe idea is easy, from start we visit each element nums[i] and change it to a circle id, then jump, if the element we jump to has been visited or is opposite sign, we know the element is not ok, so we stop and visit nums[i+1]. if the element we jump to is same sign, we change the element to a circle id. if we jump to the same id we can return true.\\n**example**\\nwe have an array :\\n```\\n[2,1,1,-1,7,1,6]\\n```\\nthen we visit from start, and we name the first circle 3000(because the nums[i] will not exceed 1000):\\n```\\n[3000,1,1,-1,7,1,6]\\n```\\nwe jump to next and change:\\n```\\n[3000,1,3000,-1,7,1,6]\\n```\\njump and we find -1 is not the same sign, so we stop and visit nums[1].\\n```\\n[3000,1,3000,-1,7,1,6]\\n```\\nwe find nums[1] is not visited(because abs(1)<=1000),we change it to 3001:\\n```\\n[3000,3001,3000,-1,7,1,6]\\n```\\njump and we find we meet a 3000! now that 3000 chain is not ok, so the 3001 chain is not ok,so we stop and visit nums[2]:\\n```\\n[3000,3001,3000,-1,7,1,6]\\n```\\nthe nums[2] is 3000 ,so we pass it and visit nums[3]. nums[3] is negative so we change it to -3000(why negative? because when we visit an element which has been changed, we still want to know its original sign):\\n```\\n[3000,3001,3000,-3000,7,1,6]\\n```\\nwe jump -1 and find nums[2] is 3000, so we stop and visited nums[4],we change it to 3002 and jump:\\n```\\n[3000,3001,3000,-3000,3002,1,6]\\n```\\nwe find we jump to a 3002, which means there is a circle! But we jump from 4 to 4, however the length must be > 1 ,so not ok. and we visit nums[5] and change it to 3003:\\n```\\n[3000,3001,3000,-3000,3002,3003,6]\\n```\\njump, and change it:\\n```\\n[3000,3001,3000,-3000,3002,3003,3003]\\n```\\njump from 6 to 5, and we meet a 3003! so the circle exists and length>1, so we return true.\\n**code:**\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool circularArrayLoop(vector<int>& nums) {\\n\\t\\t\\t\\t\\tint up=3000,down=-3000,i=0,j=0,temp=0,len=nums.size(),origin=0,pos=0,flag=0;\\n\\t\\t\\t\\t\\tfor (int i=0;i<len;++i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\torigin=nums[i];//record origin to check the sign \\n\\t\\t\\t\\t\\t\\ttemp=nums[i];\\n\\t\\t\\t\\t\\t\\tpos=i;\\n\\t\\t\\t\\t\\t\\tnums[i]=(origin>0? up :down);\\n\\t\\t\\t\\t\\t\\tif (abs(origin)>2000) continue;\\n\\t\\t\\t\\t\\t\\twhile(1)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tflag=pos; // record the last position\\n\\t\\t\\t\\t\\t\\t\\tpos=((pos+temp+1)%len)-1;\\n\\t\\t\\t\\t\\t\\t\\tif (pos<0) pos+=len;\\n\\t\\t\\t\\t\\t\\t\\tif (pos==flag) break; // jump from i to i, length==1,so break\\n\\t\\t\\t\\t\\t\\t\\ttemp=nums[pos];\\n\\t\\t\\t\\t\\t\\t\\tif (temp*origin<0) break; // opposite sign, break\\n\\t\\t\\t\\t\\t\\t\\tif (temp==(origin>0? up : down)) return true; //find the same circle and return true\\n\\t\\t\\t\\t\\t\\t\\tif (abs(temp)>2000) break; //find the failed circle id, so we also fail\\n\\t\\t\\t\\t\\t\\t\\tnums[pos]= origin>0? up : down;//change the element\\'s value\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (origin>0) // update the chain id\\n\\t\\t\\t\\t\\t\\t\\tup++;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tdown--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [],
                "code": "```\\n[2,1,1,-1,7,1,6]\\n```\n```\\n[3000,1,1,-1,7,1,6]\\n```\n```\\n[3000,1,3000,-1,7,1,6]\\n```\n```\\n[3000,1,3000,-1,7,1,6]\\n```\n```\\n[3000,3001,3000,-1,7,1,6]\\n```\n```\\n[3000,3001,3000,-1,7,1,6]\\n```\n```\\n[3000,3001,3000,-3000,7,1,6]\\n```\n```\\n[3000,3001,3000,-3000,3002,1,6]\\n```\n```\\n[3000,3001,3000,-3000,3002,3003,6]\\n```\n```\\n[3000,3001,3000,-3000,3002,3003,3003]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932327,
                "title": "java-straightforward-approach-clean-easy-to-understand",
                "content": "Comments in the code explain the approach.\\n\\n```\\nclass Solution {\\n    private boolean cycleFound;\\n    private int[] inputArray;\\n    private int arrLength;\\n\\n    public boolean circularArrayLoop(int[] nums) {\\n        cycleFound = false;\\n        inputArray = nums;\\n        arrLength = nums.length;\\n\\n        // we search for a cycle starting at every index in the array\\n        for (int s = 0; s < arrLength; s++) {\\n            findCycle(s);\\n\\n            if (cycleFound) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private void findCycle(int currentIndex) {\\n\\n        // store all the indexes we landed at while searching for the cycle\\n        Set<Integer> pastIndexes = new HashSet<>();\\n\\n        // remember the starting index, we\\'ll use it later to check if we landed at the same index\\n        int firstIndex = currentIndex;\\n\\n        boolean goingRight = inputArray[currentIndex] > 0;\\n\\n        while (!pastIndexes.contains(currentIndex)) {\\n            pastIndexes.add(currentIndex);\\n\\n            int nextIndex = currentIndex + inputArray[currentIndex];\\n\\n            // if there is a change of direction, there is no cycle.\\n            if (nextIndex < currentIndex && goingRight || nextIndex > currentIndex && !goingRight) {\\n                return;\\n            }\\n\\n            nextIndex %= arrLength;\\n\\n            if (nextIndex < 0) {\\n                nextIndex = arrLength + nextIndex;\\n            }\\n\\n            // we move to the next index\\n            currentIndex = nextIndex;\\n        }\\n\\n        // if we landed at the index where we started and the size of the loop is > 1, the it is a cycle\\n        if (firstIndex == currentIndex && pastIndexes.size() > 1) {\\n            cycleFound = true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private boolean cycleFound;\\n    private int[] inputArray;\\n    private int arrLength;\\n\\n    public boolean circularArrayLoop(int[] nums) {\\n        cycleFound = false;\\n        inputArray = nums;\\n        arrLength = nums.length;\\n\\n        // we search for a cycle starting at every index in the array\\n        for (int s = 0; s < arrLength; s++) {\\n            findCycle(s);\\n\\n            if (cycleFound) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private void findCycle(int currentIndex) {\\n\\n        // store all the indexes we landed at while searching for the cycle\\n        Set<Integer> pastIndexes = new HashSet<>();\\n\\n        // remember the starting index, we\\'ll use it later to check if we landed at the same index\\n        int firstIndex = currentIndex;\\n\\n        boolean goingRight = inputArray[currentIndex] > 0;\\n\\n        while (!pastIndexes.contains(currentIndex)) {\\n            pastIndexes.add(currentIndex);\\n\\n            int nextIndex = currentIndex + inputArray[currentIndex];\\n\\n            // if there is a change of direction, there is no cycle.\\n            if (nextIndex < currentIndex && goingRight || nextIndex > currentIndex && !goingRight) {\\n                return;\\n            }\\n\\n            nextIndex %= arrLength;\\n\\n            if (nextIndex < 0) {\\n                nextIndex = arrLength + nextIndex;\\n            }\\n\\n            // we move to the next index\\n            currentIndex = nextIndex;\\n        }\\n\\n        // if we landed at the index where we started and the size of the loop is > 1, the it is a cycle\\n        if (firstIndex == currentIndex && pastIndexes.size() > 1) {\\n            cycleFound = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839954,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int id=1001, MAX=1000, n = nums.size();\\n        \\n        #define next(j) (j+nums[j]%n + n)%n\\n        \\n        for(int i=0;i<n; i++){\\n            if(nums[i]>MAX) continue; // already visited \\n            bool Positive = (nums[i]>0);\\n            int j = i;\\n            while(true){\\n                if(nums[j] == id) return true;\\n                if((Positive && nums[j]<0) || (!Positive && nums[j]>0))break;\\n                if(nums[j]>MAX) break; // already visited\\n                int jj = j;\\n                j = next(j);\\n                if(jj==j) break; // cycle len < 2\\n                nums[jj] = id;\\n            }\\n            id++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int id=1001, MAX=1000, n = nums.size();\\n        \\n        #define next(j) (j+nums[j]%n + n)%n\\n        \\n        for(int i=0;i<n; i++){\\n            if(nums[i]>MAX) continue; // already visited \\n            bool Positive = (nums[i]>0);\\n            int j = i;\\n            while(true){\\n                if(nums[j] == id) return true;\\n                if((Positive && nums[j]<0) || (!Positive && nums[j]>0))break;\\n                if(nums[j]>MAX) break; // already visited\\n                int jj = j;\\n                j = next(j);\\n                if(jj==j) break; // cycle len < 2\\n                nums[jj] = id;\\n            }\\n            id++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762893,
                "title": "java-two-ways-to-solve-it-with-two-pointers-time-complexity-o-n-2-and-o-n-respecitvely",
                "content": "Took me two evenings to think about how to solve it and improve its runtime.\\nThe first thing we need to know is that given an index idx in the array, the next index will be\\n`(i+nums[i])%n       when i+nums[i] >= 0`\\nand \\n`n+(i+nums[i])%n       when i+nums[i] < 0`\\n\\n**Solution 1: (runtime O(n^2), space complexity O(n))**\\nIt\\'s kind of like a smarter brute force method for me. I\\'ll have two pointers i and j, which i will be the \\'start\\' of the cycle and j will be iterating the next indices starting from index i. In each loop (fixed i value) we will keep a set to save all the iterated j value in that path forming a cycle. The condition for a path to possibly form a cycle is\\n`nums[j] * nums[next(j)] >0  // path in the same direction`\\nand \\n`j != next(j)`\\n(length is larger than 1)\\nWhen moving the pointer j if we have set.contains(j) ==  true, we know that a cycle is formed. Return true. Otherwise we know that starting from i will not from a cycle, then let i++ and reset set = new Hashset<Integer>(). The max value of i is n-1, if i is larger than that means there is no cycle in that array, return false.\\n\\n```\\nclass Solution {\\n    private int[] nums;\\n    public boolean circularArrayLoop(int[] nums) {\\n        this.nums = nums;\\n        int n = this.nums.length;\\n        if(n<=1)\\n            return false;\\n        \\n        int i=0;\\n        while(i<n){\\n             Set<Integer> set = new HashSet<>();\\n\\n                set.add(i);\\n\\n                int j = i;\\n\\n                while(nums[j]*nums[next(j)] > 0 && j!=next(j)){   // j!=next(j) ensures that  length >1\\n                    j= next(j);\\n           \\n                    if(set.contains(j)){\\n                   \\n                        return true;\\n                    }\\n                        set.add(j);\\n\\n                }\\n            \\n                i++;         \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int next(int i){\\n        if(i+nums[i] >= 0)\\n            return (i+nums[i]) % nums.length;\\n        return nums.length + (i+nums[i])% nums.length;\\n    }\\n}\\n```\\n**Time complexity:**\\nWe have nested loops, i will iterate n times and j will iterate at most n times, so runtime complexity will be O(n^2).\\n**Space complexity:**\\nWe keep a set to record the iterated indices in the path forming a cycle, and I have a private nums[] as the field, so space complexity is O(2n) -> O(n)\\n\\n**Solution 2: (runtime O(n), space complexity O(n))**\\n![image](https://assets.leetcode.com/users/images/6be93da9-81df-4870-95f6-cf2309c8f281_1596081306.3514953.png)\\n\\nWhile drafting the illustrating graph in solution 1, I realized that solution 1 can be improved. For a fixed point i value, if we have point j interated some indices and found out they cannot form a cycle; then in the next i value, if the point j is to be iterating on the same index that we have already examined in the last run, we know that those indices will not form a cycle that pointer j doesn\\'t need to iterate on them again. In other words, if we keep another set to save all the interated indices before the current j interation(under current i value), only when both pointer i and j are not in that set, that it\\'s possible to form a cycle.\\n```\\nclass Solution {\\n    private int[] nums;\\n    public boolean circularArrayLoop(int[] nums) {\\n        this.nums = nums;\\n        int n = this.nums.length;\\n        if(n<=1)\\n            return false;\\n        \\n        Set<Integer> set = new HashSet<>();  // keep a set to record all the iterated indices before the current cycle finding\\n        int i=0;\\n        while(i<n){\\n            \\n            if(!set.contains(i)){  // any indices in the set means we have iterated on them and they will not form a cycle\\n                \\n                int j = i;\\n                \\n                Set<Integer> currCycle = new HashSet<>();  // same as solution 1, we have a set, currCycle to record the current iterated indices\\n                currCycle.add(j);\\n                \\n                while(nums[j]*nums[next(j)] > 0 && j!=next(j) && !set.contains(j)){  //  j must not occur during the previous cycle finding\\n                    \\n                    j= next(j);\\n                    if(currCycle.contains(j)){   // the problems lies here\\n                        return true;\\n                    }else{\\n                        currCycle.add(j);\\n                    \\n                    }\\n                }\\n                      set.addAll(currCycle);   // when the current cycle finding fails, add all the interated indices into set\\n                      i++;\\n                \\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int next(int i){\\n        if(i+nums[i] >= 0)\\n            return (i+nums[i]) % nums.length;\\n        return nums.length + (i+nums[i])% nums.length;\\n    }\\n}\\n```\\n**Time comlexity:**\\nWe also have nested loops in this case, the total iteration can be expressed as \\n![image](https://assets.leetcode.com/users/images/139882b2-8f2f-45cd-9709-4c23cf6155d4_1596080550.3005905.png)\\nwhere Nj,i means the iteration times of pointer j with specfic i value. Since j will only explore the indices which are not in the set(which saves all the failed indices), the summation can only to n at largest. Therefore, the runtime is O(n).\\n\\n**Space complexity**: two sets used, one field nums[] used, O(3n) -> O(n)\\n\\n=====================\\nMy description may not be that accurate but I hope it would help !!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] nums;\\n    public boolean circularArrayLoop(int[] nums) {\\n        this.nums = nums;\\n        int n = this.nums.length;\\n        if(n<=1)\\n            return false;\\n        \\n        int i=0;\\n        while(i<n){\\n             Set<Integer> set = new HashSet<>();\\n\\n                set.add(i);\\n\\n                int j = i;\\n\\n                while(nums[j]*nums[next(j)] > 0 && j!=next(j)){   // j!=next(j) ensures that  length >1\\n                    j= next(j);\\n           \\n                    if(set.contains(j)){\\n                   \\n                        return true;\\n                    }\\n                        set.add(j);\\n\\n                }\\n            \\n                i++;         \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int next(int i){\\n        if(i+nums[i] >= 0)\\n            return (i+nums[i]) % nums.length;\\n        return nums.length + (i+nums[i])% nums.length;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[] nums;\\n    public boolean circularArrayLoop(int[] nums) {\\n        this.nums = nums;\\n        int n = this.nums.length;\\n        if(n<=1)\\n            return false;\\n        \\n        Set<Integer> set = new HashSet<>();  // keep a set to record all the iterated indices before the current cycle finding\\n        int i=0;\\n        while(i<n){\\n            \\n            if(!set.contains(i)){  // any indices in the set means we have iterated on them and they will not form a cycle\\n                \\n                int j = i;\\n                \\n                Set<Integer> currCycle = new HashSet<>();  // same as solution 1, we have a set, currCycle to record the current iterated indices\\n                currCycle.add(j);\\n                \\n                while(nums[j]*nums[next(j)] > 0 && j!=next(j) && !set.contains(j)){  //  j must not occur during the previous cycle finding\\n                    \\n                    j= next(j);\\n                    if(currCycle.contains(j)){   // the problems lies here\\n                        return true;\\n                    }else{\\n                        currCycle.add(j);\\n                    \\n                    }\\n                }\\n                      set.addAll(currCycle);   // when the current cycle finding fails, add all the interated indices into set\\n                      i++;\\n                \\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int next(int i){\\n        if(i+nums[i] >= 0)\\n            return (i+nums[i]) % nums.length;\\n        return nums.length + (i+nums[i])% nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722517,
                "title": "java-o-n-solution-with-linkedlist-cocept",
                "content": "```java\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            int slow = i;\\n            int fast = index(nums, i);\\n            // fast != null && fast.next != null\\n            // if nums[fast] * nums[i] > 0 is true means either we are moving strictly\\n            // forward or we are moving strictly backward\\n            while(nums[fast] * nums[i] > 0 && nums[index(nums, fast)] * nums[i] > 0) {\\n                if (slow == fast) {\\n                    // single element loop detection\\n                    if (slow == index(nums, slow)) {\\n                        break;\\n                    }\\n                    return true;\\n                }\\n                slow = index(nums, slow);\\n                fast = index(nums, index(nums, fast));\\n            }\\n            // in order to avoid further computation, set all nodes in the path to zero\\n            slow = i;\\n            int val = nums[i];\\n            while (nums[slow] * val > 0) {\\n                int advance = index(nums, slow);\\n                nums[slow] = 0;\\n                slow = advance;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private int index(int[] nums, int index) {\\n        int n = nums.length;\\n        return (n + (nums[index] + index) % n) % n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            int slow = i;\\n            int fast = index(nums, i);\\n            // fast != null && fast.next != null\\n            // if nums[fast] * nums[i] > 0 is true means either we are moving strictly\\n            // forward or we are moving strictly backward\\n            while(nums[fast] * nums[i] > 0 && nums[index(nums, fast)] * nums[i] > 0) {\\n                if (slow == fast) {\\n                    // single element loop detection\\n                    if (slow == index(nums, slow)) {\\n                        break;\\n                    }\\n                    return true;\\n                }\\n                slow = index(nums, slow);\\n                fast = index(nums, index(nums, fast));\\n            }\\n            // in order to avoid further computation, set all nodes in the path to zero\\n            slow = i;\\n            int val = nums[i];\\n            while (nums[slow] * val > 0) {\\n                int advance = index(nums, slow);\\n                nums[slow] = 0;\\n                slow = advance;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private int index(int[] nums, int index) {\\n        int n = nums.length;\\n        return (n + (nums[index] + index) % n) % n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534428,
                "title": "o-1-space-solution",
                "content": "class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        \\n       \\n        for(int i=0;i<nums.length;i++){\\n           int jump=nums[i];\\n            int sign = jump>0?1:-1;\\n            int level =1;\\n            \\n            if(jump==0)\\n                continue;\\n           while(level<=nums.length){\\n               int index;\\n               if(jump+i <0){\\n                   index=(nums.length + (jump+i)%nums.length)%nums.length;\\n               }\\n               else{\\n                   index = (jump+i)%nums.length;\\n               }\\n               \\n               if(nums[index]==0|| sign*nums[index] <0)\\n               {\\n                    \\n                   break;\\n               }\\n                  \\n               \\n               if(index==i && level>1)\\n               {\\n                   \\n                   return true;\\n                   \\n               }\\n               else if(index ==i){\\n                   break;\\n               }\\n                   \\n             \\n               jump += nums[index];\\n              \\n               level++;\\n               \\n           }\\n            \\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        \\n       \\n        for(int i=0;i<nums.length;i++){\\n           int jump=nums[i];\\n            int sign = jump>0?1:-1;\\n            int level =1;\\n            \\n            if(jump==0)\\n                continue;\\n           while(level<=nums.length){\\n               int index;\\n               if(jump+i <0){\\n                   index=(nums.length + (jump+i)%nums.length)%nums.length;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 286806,
                "title": "clean-readable-python-9-line-solution-with-explanation",
                "content": "Cleamed up solution from this [post](https://leetcode.com/problems/circular-array-loop/discuss/167525/python-1-pointer-O(n)-time-O(1)-space)\\n```Python\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i, num in enumerate(nums):\\n            # use a distinct marker for each starting point\\n            mark = str(i)\\n            \\n            # explore while node is new, direction is same, and is not self loop\\n            # note: if node has been marked by a different marker, no need to proceed. This gives O(n) time.\\n            while (type(nums[i]) == int) and (num * nums[i] > 0) and (nums[i] % len(nums) != 0):\\n                jump = nums[i] \\n                nums[i] = mark\\n                i = (i + jump) % len(nums)\\n            \\n            # if self loop, nums[i] is never marked\\n            # if nums[i] is marked, a cycle is found\\n            if nums[i] == mark:\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i, num in enumerate(nums):\\n            # use a distinct marker for each starting point\\n            mark = str(i)\\n            \\n            # explore while node is new, direction is same, and is not self loop\\n            # note: if node has been marked by a different marker, no need to proceed. This gives O(n) time.\\n            while (type(nums[i]) == int) and (num * nums[i] > 0) and (nums[i] % len(nums) != 0):\\n                jump = nums[i] \\n                nums[i] = mark\\n                i = (i + jump) % len(nums)\\n            \\n            # if self loop, nums[i] is never marked\\n            # if nums[i] is marked, a cycle is found\\n            if nums[i] == mark:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253126,
                "title": "python-slow-fast-pointer-solution",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        if len(nums)<2:return False\\n        def getIndex(i):\\n            n=len(nums)\\n            if i + nums[i] >= 0:\\n                return (i + nums[i]) % n\\n            return n -(abs(i + nums[i]) % n)\\n        for i in range(len(nums)):\\n            if nums[i]==0:continue\\n            j,k=i,getIndex(i)\\n            while nums[k]*nums[i]>0 and nums[getIndex(k)]*nums[i]>0:\\n                if j==k:\\n                    if j==getIndex(j):\\n                        break\\n                    return True\\n                j=getIndex(j)\\n                k=getIndex(getIndex(k))\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        if len(nums)<2:return False\\n        def getIndex(i):\\n            n=len(nums)\\n            if i + nums[i] >= 0:\\n                return (i + nums[i]) % n\\n            return n -(abs(i + nums[i]) % n)\\n        for i in range(len(nums)):\\n            if nums[i]==0:continue\\n            j,k=i,getIndex(i)\\n            while nums[k]*nums[i]>0 and nums[getIndex(k)]*nums[i]>0:\\n                if j==k:\\n                    if j==getIndex(j):\\n                        break\\n                    return True\\n                j=getIndex(j)\\n                k=getIndex(getIndex(k))\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 240842,
                "title": "python2-o-n-solution",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: \\'List[int]\\') -> \\'bool\\':\\n        N = len(nums)\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                continue\\n            cur = i\\n            flag = num / abs(num)\\n            seen = set()\\n            while nums[cur]*flag > 0:\\n                nx = (cur + nums[cur]) % N\\n                nums[cur] = 0\\n                seen.add(cur)\\n                if nx in seen and cur != nx:\\n                    return True\\n                cur = nx\\n        return False\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: \\'List[int]\\') -> \\'bool\\':\\n        N = len(nums)\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                continue\\n            cur = i\\n            flag = num / abs(num)\\n            seen = set()\\n            while nums[cur]*flag > 0:\\n                nx = (cur + nums[cur]) % N\\n                nums[cur] = 0\\n                seen.add(cur)\\n                if nx in seen and cur != nx:\\n                    return True\\n                cur = nx\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 193189,
                "title": "c-o-n-time-o-1-space-0-ms",
                "content": "This solution does not use slow/fast pointer and achieve true O(n) time O(1) space.\\n\\nBasic idea is to mark/change visited elements/indexes to prevent duplcate search and using extra space.\\n\\n3 steps:\\n1. Change all initial values %= n (n is array length) so they are within [-n, n] range but the \"jump information\" (the next index it is pointing to) is not changed;\\n2. Use every index as starting index and judge if there is a loop in this path. Mark all visited elements in current path +n or -n depending on current direction. In this way, the \"jump information\" is not changed but we know if it is already visited or not in current path search. During the search, if we find a 0 or direction change, terminate the search; or if we find a value which abs > n, we know it is already visited in current path and we found a loop.\\n3. If we didn\\'t find a loop in current path, mark all visited elements in current path as 0, and 0 will be skipped in future search to prevent duplicate search.\\n\\nIn this way, each element is visited/changed constant times for the following cases: 1. initially %= n, 2. used as termination point for a search, 3. mark as visited in current path, 4. mark as 0.\\n\\nThe condition in the orginal problem \"there is no initial 0\" can be deleted.\\n\\nBe sure to test these 2 cases for your code as OJ will not test them:\\n[1,2,1,2]\\n[2,1,1,-1]\\n\\nThanks to ArizonaTea so I can finish this complete solution.\\n\\n```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        // first limit all initall values to [-n, n] range\\n        for (int i = 0; i < n; ++i) {\\n            nums[i] %= n;\\n        }\\n        \\n        // mark all current path visited as abs > n, and all previous (failed) paths visited as 0\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (nums[i] % n == 0) {\\n                continue; // self-loop or previously failed\\n            }\\n            \\n            bool direction = (nums[i] > 0); // current path direction + or -\\n            int j = i;        \\n            do {\\n                nums[j] += (2 *direction - 1) * n; // mark current-path visited index\\n                j = (j + nums[j]) % n;\\n                if (j < 0) {\\n                    j += n;\\n                }\\n                if (abs(nums[j]) > n) { // loop found\\n                    return true;\\n                }                \\n            } while (nums[j] != 0 && direction == (nums[j] > 0)); // while no self-loop or direction change\\n            \\n            // if no loop is found in current path, mark all visited in this path as 0:\\n            j = i;\\n            do {\\n                nums[j] = 0;\\n                j = (j + nums[j]) % n;\\n                if (j < 0) {\\n                    j += n;\\n                }                \\n            } while (abs(nums[j]) > n);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        // first limit all initall values to [-n, n] range\\n        for (int i = 0; i < n; ++i) {\\n            nums[i] %= n;\\n        }\\n        \\n        // mark all current path visited as abs > n, and all previous (failed) paths visited as 0\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (nums[i] % n == 0) {\\n                continue; // self-loop or previously failed\\n            }\\n            \\n            bool direction = (nums[i] > 0); // current path direction + or -\\n            int j = i;        \\n            do {\\n                nums[j] += (2 *direction - 1) * n; // mark current-path visited index\\n                j = (j + nums[j]) % n;\\n                if (j < 0) {\\n                    j += n;\\n                }\\n                if (abs(nums[j]) > n) { // loop found\\n                    return true;\\n                }                \\n            } while (nums[j] != 0 && direction == (nums[j] > 0)); // while no self-loop or direction change\\n            \\n            // if no loop is found in current path, mark all visited in this path as 0:\\n            j = i;\\n            do {\\n                nums[j] = 0;\\n                j = (j + nums[j]) % n;\\n                if (j < 0) {\\n                    j += n;\\n                }                \\n            } while (abs(nums[j]) > n);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136393,
                "title": "very-short-java-code",
                "content": "```\\nclass Solution {\\n    \\n    public boolean recursiveFunc(int[] nums, int index, boolean isLoop){\\n        if(index < nums.length){\\n            index += nums[index];\\n            if(index == nums.length) isLoop = true;\\n            else if(index > 0 && index < nums.length) isLoop = recursiveFunc(nums,index,false);\\n            else if(index > nums.length) isLoop = recursiveFunc(nums,index-nums.length,false);\\n            else return false;\\n        }\\n        return isLoop;\\n    }\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        if(nums.length > 0){\\n            if(nums[0] < 0) return false;\\n            else return recursiveFunc(nums,0,false);\\n        }else return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public boolean recursiveFunc(int[] nums, int index, boolean isLoop){\\n        if(index < nums.length){\\n            index += nums[index];\\n            if(index == nums.length) isLoop = true;\\n            else if(index > 0 && index < nums.length) isLoop = recursiveFunc(nums,index,false);\\n            else if(index > nums.length) isLoop = recursiveFunc(nums,index-nums.length,false);\\n            else return false;\\n        }\\n        return isLoop;\\n    }\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        if(nums.length > 0){\\n            if(nums[0] < 0) return false;\\n            else return recursiveFunc(nums,0,false);\\n        }else return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94248,
                "title": "o-n-time-o-1-space-python-clean-code",
                "content": "Start from every number, visit trough the loop process, if we can find a loop all positive or negative and the length of loop is bigger than n, then we find a loop. \\n\\nOr we can just set all numbers in this failed \"loop\" path, marking we have already visited, and find the next non-zero number.\\n\\n```\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        length = len(nums)\\n        \\n        # set all numbers to zero in the failed \"loop\" path\\n        def set_zero_loop(nums, i):\\n            while 1:\\n                newIdx = (nums[i] + i + length) % length\\n                if newNum * nums[i] > 0:\\n                    nums[i], i = 0, newIdx\\n                else:\\n                    break\\n        \\n        for i in range(length):\\n            if nums[i] != 0:\\n                cnt, tempI = 0, i\\n                while cnt < length:\\n                    newIdx = (nums[tempI] + tempI + length) % length\\n                    newNum = nums[newIdx]\\n                    # if only one number in the loop or differ in direction\\n                    if tempI == newIdx or newNum * nums[i] <= 0:  \\n                        set_zero_loop(nums, i)\\n                        break\\n                    tempI = newIdx\\n                    cnt += 1\\n                if cnt == length:\\n                    return True\\n                        \\n        return False\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        length = len(nums)\\n        \\n        # set all numbers to zero in the failed \"loop\" path\\n        def set_zero_loop(nums, i):\\n            while 1:\\n                newIdx = (nums[i] + i + length) % length\\n                if newNum * nums[i] > 0:\\n                    nums[i], i = 0, newIdx\\n                else:\\n                    break\\n        \\n        for i in range(length):\\n            if nums[i] != 0:\\n                cnt, tempI = 0, i\\n                while cnt < length:\\n                    newIdx = (nums[tempI] + tempI + length) % length\\n                    newNum = nums[newIdx]\\n                    # if only one number in the loop or differ in direction\\n                    if tempI == newIdx or newNum * nums[i] <= 0:  \\n                        set_zero_loop(nums, i)\\n                        break\\n                    tempI = newIdx\\n                    cnt += 1\\n                if cnt == length:\\n                    return True\\n                        \\n        return False\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 94259,
                "title": "java-solution-similar-to-finding-linkedlist-cycle",
                "content": "Start from any index, move to the next index by function `f(i)=((i+nums[i])%len+len)%len` where `len` is the length of array `nums`. and follow the chain. We are guaranteed there is a cycle in this chaining process. check if all the numbers in the cycle are backward or forward. Remember to exclude the one element cycle cases.\\n\\n```java\\npublic class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        if(nums==null||nums.length==0) return false;\\n        for(int a:nums){\\n            if(a==0) return false;\\n        }\\n        int len=nums.length;\\n        for(int i=0;i<len;i++){\\n            if(checkCycle(nums,i)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean checkCycle(int[] nums, int start){\\n        int len=nums.length;\\n        int slow=((start+nums[start])%len+len)%len;\\n        int fast=((slow+nums[slow])%len+len)%len;\\n        while(slow!=fast){\\n            slow=((slow+nums[slow])%len+len)%len;\\n            fast=((fast+nums[fast])%len+len)%len;\\n            fast=((fast+nums[fast])%len+len)%len;\\n        }\\n        if(slow==((slow+nums[slow])%len+len)%len) return false;//one element loop\\n        boolean forward_backward=nums[slow]>0;//forward or backword\\n        int ptr=((slow+nums[slow])%len+len)%len;\\n        while(ptr!=slow){\\n            if(nums[ptr]>0!=forward_backward) return false;\\n            ptr=((ptr+nums[ptr])%len+len)%len;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        if(nums==null||nums.length==0) return false;\\n        for(int a:nums){\\n            if(a==0) return false;\\n        }\\n        int len=nums.length;\\n        for(int i=0;i<len;i++){\\n            if(checkCycle(nums,i)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean checkCycle(int[] nums, int start){\\n        int len=nums.length;\\n        int slow=((start+nums[start])%len+len)%len;\\n        int fast=((slow+nums[slow])%len+len)%len;\\n        while(slow!=fast){\\n            slow=((slow+nums[slow])%len+len)%len;\\n            fast=((fast+nums[fast])%len+len)%len;\\n            fast=((fast+nums[fast])%len+len)%len;\\n        }\\n        if(slow==((slow+nums[slow])%len+len)%len) return false;//one element loop\\n        boolean forward_backward=nums[slow]>0;//forward or backword\\n        int ptr=((slow+nums[slow])%len+len)%len;\\n        while(ptr!=slow){\\n            if(nums[ptr]>0!=forward_backward) return false;\\n            ptr=((ptr+nums[ptr])%len+len)%len;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94261,
                "title": "what-is-the-result-for-test-case-1-2-0-3-4",
                "content": "according to the example:\\n\\n```\\nExample 3: Given the array [2, 0, 2, 1, 3], return false since 0 is not supposed to appear in the array.\\n```\\n\\nI conclude that, if there is an zero in the array, the answer should be false; but the test case 1, 2, 0, 3, 4 expect true.\\n\\nIs the example wrong? or the test case?",
                "solutionTags": [],
                "code": "```\\nExample 3: Given the array [2, 0, 2, 1, 3], return false since 0 is not supposed to appear in the array.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853371,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for (int i=0; i<nums.length; i++) {\\n            boolean isForward = nums[i] > 0;\\n            int slow = i;\\n            int fast = i; \\n            do {\\n                slow = findNextIndex(nums, isForward, slow);\\n                fast = findNextIndex(nums, isForward, fast);\\n                if (fast != -1) {\\n                    fast = findNextIndex(nums, isForward, fast);\\n                }\\n            } while (slow != -1 && fast != -1 && slow != fast);\\n            if (slow != -1 && slow == fast) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private int findNextIndex(int[] arr, boolean isForward, int currentIndex) {\\n        boolean direction = arr[currentIndex] >= 0;\\n        if (isForward != direction) {\\n            return -1;\\n        }\\n        int nextIndex = (currentIndex + arr[currentIndex]) % arr.length;\\n        if (nextIndex < 0) {\\n            nextIndex += arr.length;\\n        }\\n        if (nextIndex == currentIndex) {\\n            nextIndex = -1;\\n        }\\n        return nextIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for (int i=0; i<nums.length; i++) {\\n            boolean isForward = nums[i] > 0;\\n            int slow = i;\\n            int fast = i; \\n            do {\\n                slow = findNextIndex(nums, isForward, slow);\\n                fast = findNextIndex(nums, isForward, fast);\\n                if (fast != -1) {\\n                    fast = findNextIndex(nums, isForward, fast);\\n                }\\n            } while (slow != -1 && fast != -1 && slow != fast);\\n            if (slow != -1 && slow == fast) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private int findNextIndex(int[] arr, boolean isForward, int currentIndex) {\\n        boolean direction = arr[currentIndex] >= 0;\\n        if (isForward != direction) {\\n            return -1;\\n        }\\n        int nextIndex = (currentIndex + arr[currentIndex]) % arr.length;\\n        if (nextIndex < 0) {\\n            nextIndex += arr.length;\\n        }\\n        if (nextIndex == currentIndex) {\\n            nextIndex = -1;\\n        }\\n        return nextIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758059,
                "title": "c-visited-array-with-comments",
                "content": "# Intuition\\nUsed visited array with backtracking to tackle if it is the same loop that reaches an index again while traversing.\\n- Also the all loop index should point to same directions i.e either forward or backward.\\n- And there should be no self loops\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool ans = false;\\n\\n    int toind(int i, vector<int>& nums)\\n    {\\n        int jump = nums[i];\\n\\n        if(jump < 0)\\n        {\\n            if(i+jump < 0)\\n            {\\n                return nums.size() - (abs(i+jump)%nums.size());\\n            }\\n            else\\n            {\\n                return i+jump;\\n            }\\n        }\\n\\n        return ((i + jump) % nums.size());\\n    }\\n\\n    void visit(int i, vector<bool> &vis, vector<int>& nums, int startsign, int cycle)\\n    {\\n        //base cases\\n        //if already visited then we found loop\\n        if(vis[i] == true)\\n        {\\n            if(cycle > 1)\\n            {\\n                ans = true;\\n                return;\\n            }\\n            //cycle size should be more than 1\\n            else return;\\n        }\\n\\n        //all directions should be same i.e. either forward or backward\\n        if(nums[i] >0 and startsign == -1) return;\\n        if(nums[i] <0 and startsign == 1) return;\\n\\n\\n        int ind = toind(i,nums);\\n\\n        //same loop is not valid\\n        if(i == ind) return;\\n\\n        //marking visited index positive\\n        vis[i] = true;\\n        visit(ind, vis, nums, startsign, cycle+1);\\n        //should not collide with other loops therefore backtracked\\n        vis[i] = false;\\n\\n        return;\\n    }\\n\\n\\n    bool circularArrayLoop(vector<int>& nums) {\\n\\n       //let us use array method to check if there is a cycle or not\\n       int n = nums.size();\\n\\n       if(n <= 1) return false;\\n       vector<bool> vis(n,false);\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           int startsign = nums[i] > 0 ? 1 : -1;\\n           if(!ans) visit(i,vis,nums, startsign , 0);\\n       }\\n\\n        return ans;       \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool ans = false;\\n\\n    int toind(int i, vector<int>& nums)\\n    {\\n        int jump = nums[i];\\n\\n        if(jump < 0)\\n        {\\n            if(i+jump < 0)\\n            {\\n                return nums.size() - (abs(i+jump)%nums.size());\\n            }\\n            else\\n            {\\n                return i+jump;\\n            }\\n        }\\n\\n        return ((i + jump) % nums.size());\\n    }\\n\\n    void visit(int i, vector<bool> &vis, vector<int>& nums, int startsign, int cycle)\\n    {\\n        //base cases\\n        //if already visited then we found loop\\n        if(vis[i] == true)\\n        {\\n            if(cycle > 1)\\n            {\\n                ans = true;\\n                return;\\n            }\\n            //cycle size should be more than 1\\n            else return;\\n        }\\n\\n        //all directions should be same i.e. either forward or backward\\n        if(nums[i] >0 and startsign == -1) return;\\n        if(nums[i] <0 and startsign == 1) return;\\n\\n\\n        int ind = toind(i,nums);\\n\\n        //same loop is not valid\\n        if(i == ind) return;\\n\\n        //marking visited index positive\\n        vis[i] = true;\\n        visit(ind, vis, nums, startsign, cycle+1);\\n        //should not collide with other loops therefore backtracked\\n        vis[i] = false;\\n\\n        return;\\n    }\\n\\n\\n    bool circularArrayLoop(vector<int>& nums) {\\n\\n       //let us use array method to check if there is a cycle or not\\n       int n = nums.size();\\n\\n       if(n <= 1) return false;\\n       vector<bool> vis(n,false);\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           int startsign = nums[i] > 0 ? 1 : -1;\\n           if(!ans) visit(i,vis,nums, startsign , 0);\\n       }\\n\\n        return ans;       \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531321,
                "title": "c-brute-force-two-pointers-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        auto chk=[&](int i, int dir, vector<int>&nums)->int{\\n            if((nums[i]>0 && dir<0) || (nums[i]<0 && dir>0)){\\n                return -1;\\n            }\\n            int pos=(i+nums[i]+nums.size())%nums.size();\\n            if(pos==i){\\n                return -1;\\n            }\\n            return pos;\\n        };\\n        for(int i=0; i<nums.size(); i++){\\n            int st=i, en=i;\\n            int dir;\\n            if(nums[i]>=0){dir=1;}\\n            else{dir=-1;}\\n            while(1){\\n                st=chk(st, dir, nums);\\n                if(st==-1){break;}\\n                en=chk(en, dir, nums);\\n                if(en==-1){break;}\\n                en=chk(en, dir, nums);\\n                if(en==-1){break;}\\n                if(st==en){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        auto chk=[&](int i, int dir, vector<int>&nums)->int{\\n            if((nums[i]>0 && dir<0) || (nums[i]<0 && dir>0)){\\n                return -1;\\n            }\\n            int pos=(i+nums[i]+nums.size())%nums.size();\\n            if(pos==i){\\n                return -1;\\n            }\\n            return pos;\\n        };\\n        for(int i=0; i<nums.size(); i++){\\n            int st=i, en=i;\\n            int dir;\\n            if(nums[i]>=0){dir=1;}\\n            else{dir=-1;}\\n            while(1){\\n                st=chk(st, dir, nums);\\n                if(st==-1){break;}\\n                en=chk(en, dir, nums);\\n                if(en==-1){break;}\\n                en=chk(en, dir, nums);\\n                if(en==-1){break;}\\n                if(st==en){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363968,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  bool circularArrayLoop(vector<int>& nums) {\\n    const int n = nums.size();\\n    if (n < 2)\\n      return false;\\n    auto advance = [&](int i) {\\n      const int val = (i + nums[i]) % n;\\n      return i + nums[i] >= 0 ? val : n + val;\\n    };\\n    for (int i = 0; i < n; ++i) {\\n      if (nums[i] == 0)\\n        continue;\\n      int slow = i;\\n      int fast = advance(slow);\\n      while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(fast)] > 0) {\\n        if (slow == fast) {\\n          if (slow == advance(slow))\\n            break;\\n          return true;\\n        }\\n        slow = advance(slow);\\n        fast = advance(advance(fast));\\n      }\\n      slow = i;\\n      const int sign = nums[i];\\n      while (sign * nums[slow] > 0) {\\n        const int next = advance(slow);\\n        nums[slow] = 0;\\n        slow = next;\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i, num in enumerate(nums):\\n            mark = str(i)\\n            \\n            while isinstance(nums[i] ,int) and (num * nums[i] > 0) and (nums[i] % len(nums) != 0):\\n                jump = nums[i] \\n                nums[i] = mark\\n                i = (i + jump) % len(nums)\\n            \\n            if nums[i] == mark:\\n                return True\\n            \\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n    public static boolean circularArrayLoop(int[] nums) {\\n    int slow = 0, fast = 0;\\n    int size = nums.length;\\n    for (int i = 1; i <= size; i++) {\\n      int prev = slow;\\n      slow = nextStep(slow, nums[slow], size);\\n      if (isNotCycle(nums, prev, slow)) {\\n        fast = i;\\n        slow = i;\\n        continue;\\n      }\\n      boolean nextIter = false;\\n      int moves = 2;\\n      for (int j = 0; j < moves; j++) {\\n        prev = fast;\\n        fast = nextStep(fast, nums[fast], size);\\n        if (isNotCycle(nums, prev, fast)) {\\n          fast = i;\\n          slow = i;\\n          nextIter = true;\\n          break;\\n        }\\n      }\\n      if (nextIter) {\\n        continue;\\n      }\\n      if (slow == fast) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  private static int nextStep(int pointer, int value, int size) {\\n    int result = (pointer + value) % size;\\n    if (result < 0) {\\n      result += size;\\n    }\\n    return result;\\n  }\\n  private static boolean isNotCycle(int[] nums, int prev, int pointer) {\\n    if ((nums[prev] >= 0 && nums[pointer] < 0) || (Math.abs(nums[pointer] % nums.length) == 0)) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  bool circularArrayLoop(vector<int>& nums) {\\n    const int n = nums.size();\\n    if (n < 2)\\n      return false;\\n    auto advance = [&](int i) {\\n      const int val = (i + nums[i]) % n;\\n      return i + nums[i] >= 0 ? val : n + val;\\n    };\\n    for (int i = 0; i < n; ++i) {\\n      if (nums[i] == 0)\\n        continue;\\n      int slow = i;\\n      int fast = advance(slow);\\n      while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(fast)] > 0) {\\n        if (slow == fast) {\\n          if (slow == advance(slow))\\n            break;\\n          return true;\\n        }\\n        slow = advance(slow);\\n        fast = advance(advance(fast));\\n      }\\n      slow = i;\\n      const int sign = nums[i];\\n      while (sign * nums[slow] > 0) {\\n        const int next = advance(slow);\\n        nums[slow] = 0;\\n        slow = next;\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i, num in enumerate(nums):\\n            mark = str(i)\\n            \\n            while isinstance(nums[i] ,int) and (num * nums[i] > 0) and (nums[i] % len(nums) != 0):\\n                jump = nums[i] \\n                nums[i] = mark\\n                i = (i + jump) % len(nums)\\n            \\n            if nums[i] == mark:\\n                return True\\n            \\n        return False\\n```\n```Java []\\nclass Solution {\\n    public static boolean circularArrayLoop(int[] nums) {\\n    int slow = 0, fast = 0;\\n    int size = nums.length;\\n    for (int i = 1; i <= size; i++) {\\n      int prev = slow;\\n      slow = nextStep(slow, nums[slow], size);\\n      if (isNotCycle(nums, prev, slow)) {\\n        fast = i;\\n        slow = i;\\n        continue;\\n      }\\n      boolean nextIter = false;\\n      int moves = 2;\\n      for (int j = 0; j < moves; j++) {\\n        prev = fast;\\n        fast = nextStep(fast, nums[fast], size);\\n        if (isNotCycle(nums, prev, fast)) {\\n          fast = i;\\n          slow = i;\\n          nextIter = true;\\n          break;\\n        }\\n      }\\n      if (nextIter) {\\n        continue;\\n      }\\n      if (slow == fast) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  private static int nextStep(int pointer, int value, int size) {\\n    int result = (pointer + value) % size;\\n    if (result < 0) {\\n      result += size;\\n    }\\n    return result;\\n  }\\n  private static boolean isNotCycle(int[] nums, int prev, int pointer) {\\n    if ((nums[prev] >= 0 && nums[pointer] < 0) || (Math.abs(nums[pointer] % nums.length) == 0)) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120490,
                "title": "javascript-explained-easy-to-understand",
                "content": "# Intuition\\n- The code is checking if there\\'s a cycle in an array of integers, where movement in the cycle can only follow a single direction (forward or backward) and a cycle can not consist of both forward and backward movements.\\n\\n\\n# Explaination\\n\\n\\n- The main logic is implemented in the function circularArrayLoop(nums) where nums is the input array. First, the length of the array n is calculated, and if n is less than or equal to 1, the function returns false because a cycle requires at least 2 elements.\\n\\n- Next, there are two pointers slow and fast initialized with the same starting position i. The direction of movement (forward or backward) is determined by checking if the element at index i is positive or negative.\\n\\n- A while loop is used to traverse the array. \\n- At each iteration, the position of the slow pointer is updated by calling the getNextPosition(nums, slow, isForward) function, which calculates the next position in the cycle. \\n- The function returns -1 if the movement direction is different than isForward, or if the next position is the same as the current position (indicating a one-element loop). \\n- If the function returns -1, the loop breaks.\\n\\n- The position of the fast pointer is updated twice in each iteration of the while loop, so it moves faster than the slow pointer. If the slow and fast pointers ever end up at the same position, it means there\\'s a cycle and the function returns true.\\n\\n- Finally, if the while loop ends without the slow and fast pointers ever being equal, the function returns false, indicating that there\\'s no cycle in the array.\\n\\nI hope this explanation helps clarify the code!\\n\\n# Code\\n```\\nvar circularArrayLoop = function(nums) {\\n    let n = nums.length;\\n    if(n <= 1) return false;\\n    for(let i = 0; i < n; i++) {\\n        let slow = i;\\n        let fast = i;\\n        let direction = nums[i] > 0 ? 1 : -1;\\n        \\n        while(true) {\\n            slow = findNext(nums, slow, direction);\\n            fast = findNext(nums, fast, direction);\\n            if(fast !== -1) fast = findNext(nums, fast, direction);\\n            if(slow === -1 || fast === -1) break;\\n            if(slow === fast) return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction findNext(nums, current, direction) {\\n    let next = (current + nums[current]) % nums.length;\\n    if(next < 0) next += nums.length;\\n    if(next === current || nums[next] * direction < 0) return -1;\\n    return next;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nvar circularArrayLoop = function(nums) {\\n    let n = nums.length;\\n    if(n <= 1) return false;\\n    for(let i = 0; i < n; i++) {\\n        let slow = i;\\n        let fast = i;\\n        let direction = nums[i] > 0 ? 1 : -1;\\n        \\n        while(true) {\\n            slow = findNext(nums, slow, direction);\\n            fast = findNext(nums, fast, direction);\\n            if(fast !== -1) fast = findNext(nums, fast, direction);\\n            if(slow === -1 || fast === -1) break;\\n            if(slow === fast) return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nfunction findNext(nums, current, direction) {\\n    let next = (current + nums[current]) % nums.length;\\n    if(next < 0) next += nums.length;\\n    if(next === current || nums[next] * direction < 0) return -1;\\n    return next;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3000114,
                "title": "python-fast-slow-pointers-o-n-time-o-1-space",
                "content": "# Intuition\\nCycle -> Fast & slow pointer\\n\\n# Complexity\\n- Time complexity: `O(n)` because of iteration over array and ignoring \\'visited\\' elements\\n\\n- Space complexity: `O(1)`\\n\\n# Code\\n```\\nclass Solution:\\n    def circularArrayLoop(self, A: List[int]) -> bool:\\n        def next_of(i):\\n            # Many solutions use (i + A[i] % n + n) % n,\\n            # but this works just fine\\n            return (i + A[i]) % n\\n\\n        n = len(A)\\n\\n        for i in range(n):\\n            # Skip if already visited\\n            if A[i] == 0: continue\\n\\n            fast = slow = i\\n    \\n            # Condition: fast and fast_next and fast_next_next travel at same direction (either positive or negative)\\n            while A[fast] * A[next_of(fast)] > 0 and \\\\\\n                  A[next_of(fast)] * A[next_of(next_of(fast))] > 0:\\n                fast = next_of(next_of(fast))\\n                slow = next_of(slow)\\n                if slow == fast:\\n                    if slow == next_of(slow):\\n                        break \\n                    return True\\n            \\n            # Condition: slow and slow_next travel at same direction (either positive or negative)\\n            # Mark \\'visited\\' by assigning 0\\n            slow = i\\n            while slow * A[next_of(slow)] > 0:\\n                next_slow = next_of(slow) # preserve next value\\n                A[slow] = 0 # mark \\'visited\\'\\n                slow = next_slow # move to next\\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, A: List[int]) -> bool:\\n        def next_of(i):\\n            # Many solutions use (i + A[i] % n + n) % n,\\n            # but this works just fine\\n            return (i + A[i]) % n\\n\\n        n = len(A)\\n\\n        for i in range(n):\\n            # Skip if already visited\\n            if A[i] == 0: continue\\n\\n            fast = slow = i\\n    \\n            # Condition: fast and fast_next and fast_next_next travel at same direction (either positive or negative)\\n            while A[fast] * A[next_of(fast)] > 0 and \\\\\\n                  A[next_of(fast)] * A[next_of(next_of(fast))] > 0:\\n                fast = next_of(next_of(fast))\\n                slow = next_of(slow)\\n                if slow == fast:\\n                    if slow == next_of(slow):\\n                        break \\n                    return True\\n            \\n            # Condition: slow and slow_next travel at same direction (either positive or negative)\\n            # Mark \\'visited\\' by assigning 0\\n            slow = i\\n            while slow * A[next_of(slow)] > 0:\\n                next_slow = next_of(slow) # preserve next value\\n                A[slow] = 0 # mark \\'visited\\'\\n                slow = next_slow # move to next\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521625,
                "title": "easy-to-understand-slow-and-fast-pointer-floyd-s-tortoise-and-hare-algorithm",
                "content": "Please upvote this post if you find this solution helpful in any way.\\n\\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        \\n        def next_step(ind,val_ch):\\n            new_ind=(ind+nums[ind])%n\\n            new_val_ch=1 if nums[new_ind]>0 else 0\\n            if new_val_ch!=val_ch:\\n                return -4\\n            if new_ind==ind:\\n                return -4\\n            \\n            return new_ind\\n            \\n        \\n        for i in range(n):\\n            slow=i\\n            fast=i\\n            val_i=1 if nums[i]>0 else 0\\n            \\n            while True:\\n                slow=next_step(slow,val_i)\\n                fast=next_step(fast,val_i)\\n                if fast!=-4:\\n                    fast=next_step(fast,val_i)\\n                    \\n                if slow==-4 or fast==-4 or slow==fast:\\n                    break\\n                \\n            if slow!=-4 and slow==fast:\\n                print(slow)\\n                return True\\n            \\n        return False\\n     \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        \\n        def next_step(ind,val_ch):\\n            new_ind=(ind+nums[ind])%n\\n            new_val_ch=1 if nums[new_ind]>0 else 0\\n            if new_val_ch!=val_ch:\\n                return -4\\n            if new_ind==ind:\\n                return -4\\n            \\n            return new_ind\\n            \\n        \\n        for i in range(n):\\n            slow=i\\n            fast=i\\n            val_i=1 if nums[i]>0 else 0\\n            \\n            while True:\\n                slow=next_step(slow,val_i)\\n                fast=next_step(fast,val_i)\\n                if fast!=-4:\\n                    fast=next_step(fast,val_i)\\n                    \\n                if slow==-4 or fast==-4 or slow==fast:\\n                    break\\n                \\n            if slow!=-4 and slow==fast:\\n                print(slow)\\n                return True\\n            \\n        return False\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239322,
                "title": "slow-and-fast-pointer",
                "content": "```\\n    int findn(vector<int>&nums, bool isf, int ci){\\n        bool dir=nums[ci]>=0;\\n        if(isf!=dir){\\n            return -1;\\n        }\\n        int ni=(ci+nums[ci]+nums.size())%nums.size();\\n        \\n        if(ni==ci){\\n            ni=-1;\\n        }\\n        \\n        return  ni;\\n            \\n            \\n            \\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            bool isf=nums[i]>0;\\n            int slow=i,fast=i;\\n            do{\\n                slow=findn(nums,isf,slow);\\n                fast=findn(nums,isf,fast);\\n                if(fast!=-1){\\n                    fast=findn(nums,isf,fast);\\n                }\\n                \\n            }while(slow!=-1 and fast!=-1 and slow!=fast);\\n            \\n          if(slow!=-1 and slow==fast){\\n              return true;\\n          }  \\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findn(vector<int>&nums, bool isf, int ci){\\n        bool dir=nums[ci]>=0;\\n        if(isf!=dir){\\n            return -1;\\n        }\\n        int ni=(ci+nums[ci]+nums.size())%nums.size();\\n        \\n        if(ni==ci){\\n            ni=-1;\\n        }\\n        \\n        return  ni;\\n            \\n            \\n            \\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            bool isf=nums[i]>0;\\n            int slow=i,fast=i;\\n            do{\\n                slow=findn(nums,isf,slow);\\n                fast=findn(nums,isf,fast);\\n                if(fast!=-1){\\n                    fast=findn(nums,isf,fast);\\n                }\\n                \\n            }while(slow!=-1 and fast!=-1 and slow!=fast);\\n            \\n          if(slow!=-1 and slow==fast){\\n              return true;\\n          }  \\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161640,
                "title": "python-floyd-s-hare-and-tortoise-cycle-detection-faster-than-97",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        # Floyd\\'s Hare and Tortoise algorithm for cycle detection\\n        def check_cycle(start, seen):\\n            n = len(nums)\\n            slow = fast = start\\n            while True:\\n                slow = (slow + nums[slow]) % n\\n                seen.add(slow)\\n                fast = (fast + nums[fast]) % n\\n                fast = (fast + nums[fast]) % n                \\n                seen.add(fast)\\n                if slow == fast:\\n                    break\\n\\n            lam = 0    \\n            while True:\\n                if nums[slow] * nums[fast] <= 0:\\n                    return False\\n                lam += 1\\n                fast = (fast + nums[fast]) % n\\n                seen.add(fast)                \\n                if slow == fast:\\n                    break\\n            \\n            return lam > 1\\n        \\n        n = len(nums)\\n        seen = set()        \\n        for i in range(n):\\n            if i not in seen:\\n                if check_cycle(i, seen):\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        # Floyd\\'s Hare and Tortoise algorithm for cycle detection\\n        def check_cycle(start, seen):\\n            n = len(nums)\\n            slow = fast = start\\n            while True:\\n                slow = (slow + nums[slow]) % n\\n                seen.add(slow)\\n                fast = (fast + nums[fast]) % n\\n                fast = (fast + nums[fast]) % n                \\n                seen.add(fast)\\n                if slow == fast:\\n                    break\\n\\n            lam = 0    \\n            while True:\\n                if nums[slow] * nums[fast] <= 0:\\n                    return False\\n                lam += 1\\n                fast = (fast + nums[fast]) % n\\n                seen.add(fast)                \\n                if slow == fast:\\n                    break\\n            \\n            return lam > 1\\n        \\n        n = len(nums)\\n        seen = set()        \\n        for i in range(n):\\n            if i not in seen:\\n                if check_cycle(i, seen):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088486,
                "title": "accepted-solution-for-java-fast-slow-pointers-clean-code",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n      boolean isForward = nums[i] >= 0; // if we are moving forward or not\\n      int slow = i, fast = i;\\n\\n      // if slow or fast becomes \\'-1\\' this means we can\\'t find cycle for this number\\n      do {\\n        slow = findNextIndex(nums, isForward, slow); // move one step for slow pointer\\n        fast = findNextIndex(nums, isForward, fast); // move one step for fast pointer\\n        if (fast != -1)\\n          fast = findNextIndex(nums, isForward, fast); // move another step for fast pointer\\n      } while (slow != -1 && fast != -1 && slow != fast);\\n\\n      if (slow != -1 && slow == fast)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  private static int findNextIndex(int[] arr, boolean isForward, int currentIndex) {\\n    boolean direction = arr[currentIndex] >= 0;\\n    if (isForward != direction)\\n      return -1; // change in direction, return -1\\n\\n    int nextIndex = (currentIndex + arr[currentIndex]) % arr.length;\\n    if (nextIndex < 0)\\n      nextIndex += arr.length; // wrap around for negative numbers\\n\\n    // one element cycle, return -1 \\n    if (nextIndex == currentIndex)\\n      nextIndex = -1;\\n\\n    return nextIndex;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n      boolean isForward = nums[i] >= 0; // if we are moving forward or not\\n      int slow = i, fast = i;\\n\\n      // if slow or fast becomes \\'-1\\' this means we can\\'t find cycle for this number\\n      do {\\n        slow = findNextIndex(nums, isForward, slow); // move one step for slow pointer\\n        fast = findNextIndex(nums, isForward, fast); // move one step for fast pointer\\n        if (fast != -1)\\n          fast = findNextIndex(nums, isForward, fast); // move another step for fast pointer\\n      } while (slow != -1 && fast != -1 && slow != fast);\\n\\n      if (slow != -1 && slow == fast)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  private static int findNextIndex(int[] arr, boolean isForward, int currentIndex) {\\n    boolean direction = arr[currentIndex] >= 0;\\n    if (isForward != direction)\\n      return -1; // change in direction, return -1\\n\\n    int nextIndex = (currentIndex + arr[currentIndex]) % arr.length;\\n    if (nextIndex < 0)\\n      nextIndex += arr.length; // wrap around for negative numbers\\n\\n    // one element cycle, return -1 \\n    if (nextIndex == currentIndex)\\n      nextIndex = -1;\\n\\n    return nextIndex;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056100,
                "title": "kotlin-readable-slow-and-fast-pointers-o-nk-o-1",
                "content": "```\\nclass Solution {\\n    // time: O(NK) N = nums.size, k = loop size\\n    // space: O(1)\\n    fun circularArrayLoop(nums: IntArray): Boolean {\\n        for (i in 0 until nums.size - 1) {\\n            if (hasCycle(nums, i)) return true\\n        }\\n        return false\\n    }\\n\\n    fun hasCycle(nums: IntArray, start: Int): Boolean {\\n        var slow = start\\n        var fast = next(nums, slow)\\n        while (slow != fast) {\\n            if (slow == -1 || fast == -1) return false\\n            slow = next(nums, slow)\\n            fast = next(nums, next(nums, fast))\\n        }\\n        return slow != -1\\n    }\\n\\n    fun next(nums: IntArray, curr: Int): Int {\\n        return if (curr != -1) {\\n            var new = (curr + nums[curr]) % nums.size\\n            if (new < 0) new += nums.size\\n            if (new != curr && sameSign(nums[curr], nums[new])) new else -1\\n        } else -1\\n    }\\n    \\n    fun sameSign(a: Int, b: Int) = a >= 0 == b >= 0\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    // time: O(NK) N = nums.size, k = loop size\\n    // space: O(1)\\n    fun circularArrayLoop(nums: IntArray): Boolean {\\n        for (i in 0 until nums.size - 1) {\\n            if (hasCycle(nums, i)) return true\\n        }\\n        return false\\n    }\\n\\n    fun hasCycle(nums: IntArray, start: Int): Boolean {\\n        var slow = start\\n        var fast = next(nums, slow)\\n        while (slow != fast) {\\n            if (slow == -1 || fast == -1) return false\\n            slow = next(nums, slow)\\n            fast = next(nums, next(nums, fast))\\n        }\\n        return slow != -1\\n    }\\n\\n    fun next(nums: IntArray, curr: Int): Int {\\n        return if (curr != -1) {\\n            var new = (curr + nums[curr]) % nums.size\\n            if (new < 0) new += nums.size\\n            if (new != curr && sameSign(nums[curr], nums[new])) new else -1\\n        } else -1\\n    }\\n    \\n    fun sameSign(a: Int, b: Int) = a >= 0 == b >= 0\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726628,
                "title": "java-o-n-time-o-1-space",
                "content": "Not smart enough to come up with the slow fast pointer method, here\\'s how I start from O(n) space to O(1) space.\\n\\nO(n) space is relatively straightforard: \\nUsing a helper array to keep track which element has been visited, skip it when we iterate the nums array and the element has been visited, then during each iteration, using a Set to store all the values for the current round, then use a variable pre to record the last value so that we can decide whether the cycle only contains one element.\\n\\n```\\npublic boolean circularArrayLoop(int[] nums) {\\n        int len = nums.length;\\n        boolean[] used = new boolean[len];\\n        for(int i = 0; i < len; i++){\\n            if(used[i]){\\n                continue;\\n            }\\n            Set<Integer> set = new HashSet<>();\\n            int dir = nums[i] > 0 ? 1 : -1;\\n            int index = i;\\n            int pre = i;\\n            while(true){\\n                pre = index;\\n                set.add(index);\\n                used[index] = true;\\n                index = (len+(index+nums[index])%len)%len;\\n                if(!used[index]){\\n                    int newDir = nums[index] > 0 ? 1 : -1;\\n                    if(newDir != dir){\\n                        break;\\n                    }\\n                }else{\\n                    if(!set.contains(index)){\\n                        break;\\n                    }else{\\n                        if(index != pre){\\n                            return true;\\n                        }\\n                        break;\\n                    }\\n                    \\n                }\\n\\n            }\\n        }\\n        return false;\\n    }\\n```\\nThere\\'s obviously a long way to go to reduce space to O(1) cuz I used an auxiliary array and also a Set. My first thought is that I can just use the original nums array to keep the used array information, I set the element to 0 whenever it\\'s used.  This removed the auxililary array but still kept the Set cuz I don\\'t know how to differentiate the elements visited between this round and previous rounds. \\n\\n```\\npublic boolean circularArrayLoop(int[] nums) {\\n        int len = nums.length;\\n        for(int i = 0; i < len; i++){\\n            if(nums[i] == 0){\\n                continue;\\n            }\\n            Set<Integer> set = new HashSet<>();\\n            int dir = nums[i];\\n            int index = i;\\n            while(true){\\n                int pre = index;\\n                set.add(index);\\n                int newIndex = (len+(index+nums[index])%len)%len;\\n                nums[index] = 0;\\n                index = newIndex;\\n                if(nums[index] != 0){\\n                    if(nums[index]*dir < 0){\\n                        break;\\n                    }\\n                }else{\\n                    if(set.contains(index) && index != pre){\\n                        return true;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\nBut since there\\'s lower & upper boundaries for the nums array, and we can use this boundary to help us remove the extra Set used. Instead of setting the visited element to 0, we can set it to 1001 for first round and then 1002 for second round, so that now we can easily tell a visited element is visited in this round or in previous rounds.\\n```\\npublic boolean circularArrayLoop(int[] nums) {\\n        int len = nums.length;\\n        int max = 1001;\\n        for(int i = 0; i < len; i++){\\n            if(nums[i] > 1000){\\n                continue;\\n            }\\n            int dir = nums[i];\\n            int index = i;\\n            while(true){\\n                int pre = index;\\n                int newIndex = (len+(index+nums[index])%len)%len;\\n                nums[index] = max;\\n                index = newIndex;\\n                if(nums[index] < 1001){\\n                    if(nums[index]*dir < 0){\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[index] == max && index != pre){\\n                        return true;\\n                    }\\n                    break;\\n                }\\n            }\\n            max++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean circularArrayLoop(int[] nums) {\\n        int len = nums.length;\\n        boolean[] used = new boolean[len];\\n        for(int i = 0; i < len; i++){\\n            if(used[i]){\\n                continue;\\n            }\\n            Set<Integer> set = new HashSet<>();\\n            int dir = nums[i] > 0 ? 1 : -1;\\n            int index = i;\\n            int pre = i;\\n            while(true){\\n                pre = index;\\n                set.add(index);\\n                used[index] = true;\\n                index = (len+(index+nums[index])%len)%len;\\n                if(!used[index]){\\n                    int newDir = nums[index] > 0 ? 1 : -1;\\n                    if(newDir != dir){\\n                        break;\\n                    }\\n                }else{\\n                    if(!set.contains(index)){\\n                        break;\\n                    }else{\\n                        if(index != pre){\\n                            return true;\\n                        }\\n                        break;\\n                    }\\n                    \\n                }\\n\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean circularArrayLoop(int[] nums) {\\n        int len = nums.length;\\n        for(int i = 0; i < len; i++){\\n            if(nums[i] == 0){\\n                continue;\\n            }\\n            Set<Integer> set = new HashSet<>();\\n            int dir = nums[i];\\n            int index = i;\\n            while(true){\\n                int pre = index;\\n                set.add(index);\\n                int newIndex = (len+(index+nums[index])%len)%len;\\n                nums[index] = 0;\\n                index = newIndex;\\n                if(nums[index] != 0){\\n                    if(nums[index]*dir < 0){\\n                        break;\\n                    }\\n                }else{\\n                    if(set.contains(index) && index != pre){\\n                        return true;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean circularArrayLoop(int[] nums) {\\n        int len = nums.length;\\n        int max = 1001;\\n        for(int i = 0; i < len; i++){\\n            if(nums[i] > 1000){\\n                continue;\\n            }\\n            int dir = nums[i];\\n            int index = i;\\n            while(true){\\n                int pre = index;\\n                int newIndex = (len+(index+nums[index])%len)%len;\\n                nums[index] = max;\\n                index = newIndex;\\n                if(nums[index] < 1001){\\n                    if(nums[index]*dir < 0){\\n                        break;\\n                    }\\n                }else{\\n                    if(nums[index] == max && index != pre){\\n                        return true;\\n                    }\\n                    break;\\n                }\\n            }\\n            max++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686706,
                "title": "python3-use-different-markers-for-each-traversal",
                "content": "```python\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        \"\"\"So we have been having trouble finding a decent way to tell the size\\n        of the loop and reject a loop if its size is 1. This solution\\n\\n        Ref: https://leetcode.com/problems/circular-array-loop/discuss/232417/Python-simple-solution-beats-100-with-O(1)-space\\n\\n        offers a simple idea to identify a size-one loop: check whether the\\n        next index is the same as the current one. This way, we don\\'t have to\\n        keep record of the link size. We can return true for all loops except\\n        those whose next index is the same as the current.\\n\\n        We also create a marker for each traversal. Once we hit an index with\\n        the same marker of the current traversal, we know for sure that a loop\\n        of size larger than one has been found.\\n\\n        O(N) time, O(1) space. 51 ms, 63% ranking.\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(N):\\n            marker, j, direction = 1001 + i, i, nums[i]\\n            while -1000 <= nums[j] <= 1000:\\n                if direction * nums[j] > 0:  # point to same direction\\n                    next_j = (j + nums[j] + N) % N\\n                    if next_j == j:  # loop of size 1, do not assign marker\\n                        break\\n                    nums[j], j = marker, next_j\\n                else:\\n                    break\\n            if nums[j] == marker:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        \"\"\"So we have been having trouble finding a decent way to tell the size\\n        of the loop and reject a loop if its size is 1. This solution\\n\\n        Ref: https://leetcode.com/problems/circular-array-loop/discuss/232417/Python-simple-solution-beats-100-with-O(1)-space\\n\\n        offers a simple idea to identify a size-one loop: check whether the\\n        next index is the same as the current one. This way, we don\\'t have to\\n        keep record of the link size. We can return true for all loops except\\n        those whose next index is the same as the current.\\n\\n        We also create a marker for each traversal. Once we hit an index with\\n        the same marker of the current traversal, we know for sure that a loop\\n        of size larger than one has been found.\\n\\n        O(N) time, O(1) space. 51 ms, 63% ranking.\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(N):\\n            marker, j, direction = 1001 + i, i, nums[i]\\n            while -1000 <= nums[j] <= 1000:\\n                if direction * nums[j] > 0:  # point to same direction\\n                    next_j = (j + nums[j] + N) % N\\n                    if next_j == j:  # loop of size 1, do not assign marker\\n                        break\\n                    nums[j], j = marker, next_j\\n                else:\\n                    break\\n            if nums[j] == marker:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447592,
                "title": "using-slow-and-fast-pointers-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int next(vector<int>a,int i){\\n        return (i+a[i]+a.size())%a.size();\\n    }\\n    bool circularArrayLoop(vector<int>& v) {\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            int slow=i;\\n            int fast=i;\\n            if(v[i]==0)\\n                continue;\\n            while(v[slow]*v[next(v,slow)]>0\\n                 and\\n                 v[fast]*v[next(v,fast)]>0\\n                 and\\n                 v[fast]*v[next(v,next(v,fast))]>0\\n                 ){\\n                slow=next(v,slow);\\n                fast=next(v,next(v,fast));\\n                if(slow==fast){\\n                    //That means cycle is presentbut cycle length should be greater than 1\\n                    if(slow==next(v,slow)){\\n                        break;\\n                    }\\n                    return true;\\n                }\\n            }\\n            slow=i;\\n            int val=v[slow];\\n            while(val*v[slow]>0){\\n                int x=slow;\\n                slow=next(v,slow);\\n                v[x]=0;\\n            }\\n        }\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int next(vector<int>a,int i){\\n        return (i+a[i]+a.size())%a.size();\\n    }\\n    bool circularArrayLoop(vector<int>& v) {\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            int slow=i;\\n            int fast=i;\\n            if(v[i]==0)\\n                continue;\\n            while(v[slow]*v[next(v,slow)]>0\\n                 and\\n                 v[fast]*v[next(v,fast)]>0\\n                 and\\n                 v[fast]*v[next(v,next(v,fast))]>0\\n                 ){\\n                slow=next(v,slow);\\n                fast=next(v,next(v,fast));\\n                if(slow==fast){\\n                    //That means cycle is presentbut cycle length should be greater than 1\\n                    if(slow==next(v,slow)){\\n                        break;\\n                    }\\n                    return true;\\n                }\\n            }\\n            slow=i;\\n            int val=v[slow];\\n            while(val*v[slow]>0){\\n                int x=slow;\\n                slow=next(v,slow);\\n                v[x]=0;\\n            }\\n        }\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376516,
                "title": "succinct-java-solution",
                "content": "```\\nclass Solution {\\n  public boolean circularArrayLoop(int ... nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n      if (loop(nums, i)) return true;\\n    }\\n    return false;\\n  }\\n\\n  boolean loop(int[] nums, int i) {\\n    int sign = (nums[i] > 0) ? 1 : -1;\\n    for (int k = 0; k < nums.length; k++) {\\n      if (nums[i] * sign < 0) return false;\\n      int next = (i + nums[i] + nums.length * 1000) % nums.length;\\n      if (next == i) return false;\\n      i = next;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public boolean circularArrayLoop(int ... nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n      if (loop(nums, i)) return true;\\n    }\\n    return false;\\n  }\\n\\n  boolean loop(int[] nums, int i) {\\n    int sign = (nums[i] > 0) ? 1 : -1;\\n    for (int k = 0; k < nums.length; k++) {\\n      if (nums[i] * sign < 0) return false;\\n      int next = (i + nums[i] + nums.length * 1000) % nums.length;\\n      if (next == i) return false;\\n      i = next;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312630,
                "title": "c-o-n-time-complexity-beats-100-time-complexity-with-explanation-comments",
                "content": "The trickiest part for me is that one has to proceed to the next element when we encounter a \\' *bad cycle* \\'\\n\\n```\\nclass Solution \\n{ \\n    int debug=0; //for turning on debug mode\\n\\t\\n\\t // this function handles computing the next element esp. when i+nums <0 or >n\\n    int acp(int i, int add, int n) \\n    {\\n        if (i+add>=n) return (i+add)%n;\\n        while (i+add<0) i+=n;\\n            \\n        return i+add;    \\n    }\\n\\t\\n\\t// when a cycle is encountered, this func checks whether it is a \\'good one\\'  ( length>1 and only +ve/-ve )\\n    bool cyclecheck(int *lol, int n, vector<int> nums, int i)\\n    {\\n        int x = acp(i,nums[i],n);\\n        while(x!=i)\\n        {\\n            if(lol[x]==-1) return false;\\n            x= acp(x,nums[x],n);\\n        }\\n        return true;\\n    }\\n\\t\\n\\t// our driver function\\n    public:bool circularArrayLoop(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n\\t\\tint *lol = new int[n];     // to mark whether the element is visited (pardon me for the silly naming)\\n        fill_n(lol, n, 0);\\n        int i=0;\\n        while(1)\\n        {\\n\\t\\t\\t// debugging statements (currently turned off)\\n            if(debug) cout<<nums[i]<<endl;\\n            if(debug) cout<<i<<\" \"<<acp(i,nums[i],n)<<endl<<endl;\\n\\t\\t\\t\\n\\t\\t\\t// checks for cycle_length == 1, if true, proceeds to next element (check for other cycles)\\n            if (acp(i,nums[i],n)==i) \\n            {\\n                if(lol[i]==-1)\\n                    return false;\\n                lol[i]=-1;\\n                i = acp(i,1,n);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// this element was being encountered for second time and is a part of \\'bad cycle\\'\\n            if(lol[i]==-1) return false;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t//+ve product implies that the path consists of similar signed elements\\n\\t\\t\\tif (nums[i]*nums[acp(i,nums[i],n)]>0)       \\n            {\\n\\t\\t\\t\\t// we might have stumbled upon a \\'good cycle\\'. We will have to check the entire cycle anyway \\n\\t\\t\\t\\tif(lol[i]==1) return cyclecheck(lol,n,nums,i);             \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// marking that the \\n                else          lol[i]=1;\\n            }\\n            else    lol[i]=-1;\\n            \\n\\t\\t\\t// as mentioned before the start of code, if a bad cycle encountered \\'for the 1st time\\', we will proceed to next element\\n            if(lol[acp(i,nums[i],n)]==-1) i = acp(i,1,n);\\n            else i = acp(i,nums[i],n);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{ \\n    int debug=0; //for turning on debug mode\\n\\t\\n\\t // this function handles computing the next element esp. when i+nums <0 or >n\\n    int acp(int i, int add, int n) \\n    {\\n        if (i+add>=n) return (i+add)%n;\\n        while (i+add<0) i+=n;\\n            \\n        return i+add;    \\n    }\\n\\t\\n\\t// when a cycle is encountered, this func checks whether it is a \\'good one\\'  ( length>1 and only +ve/-ve )\\n    bool cyclecheck(int *lol, int n, vector<int> nums, int i)\\n    {\\n        int x = acp(i,nums[i],n);\\n        while(x!=i)\\n        {\\n            if(lol[x]==-1) return false;\\n            x= acp(x,nums[x],n);\\n        }\\n        return true;\\n    }\\n\\t\\n\\t// our driver function\\n    public:bool circularArrayLoop(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n\\t\\tint *lol = new int[n];     // to mark whether the element is visited (pardon me for the silly naming)\\n        fill_n(lol, n, 0);\\n        int i=0;\\n        while(1)\\n        {\\n\\t\\t\\t// debugging statements (currently turned off)\\n            if(debug) cout<<nums[i]<<endl;\\n            if(debug) cout<<i<<\" \"<<acp(i,nums[i],n)<<endl<<endl;\\n\\t\\t\\t\\n\\t\\t\\t// checks for cycle_length == 1, if true, proceeds to next element (check for other cycles)\\n            if (acp(i,nums[i],n)==i) \\n            {\\n                if(lol[i]==-1)\\n                    return false;\\n                lol[i]=-1;\\n                i = acp(i,1,n);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// this element was being encountered for second time and is a part of \\'bad cycle\\'\\n            if(lol[i]==-1) return false;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t//+ve product implies that the path consists of similar signed elements\\n\\t\\t\\tif (nums[i]*nums[acp(i,nums[i],n)]>0)       \\n            {\\n\\t\\t\\t\\t// we might have stumbled upon a \\'good cycle\\'. We will have to check the entire cycle anyway \\n\\t\\t\\t\\tif(lol[i]==1) return cyclecheck(lol,n,nums,i);             \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// marking that the \\n                else          lol[i]=1;\\n            }\\n            else    lol[i]=-1;\\n            \\n\\t\\t\\t// as mentioned before the start of code, if a bad cycle encountered \\'for the 1st time\\', we will proceed to next element\\n            if(lol[acp(i,nums[i],n)]==-1) i = acp(i,1,n);\\n            else i = acp(i,nums[i],n);\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1261483,
                "title": "javascript-a-dfs-approach",
                "content": "```\\nvar circularArrayLoop = function(nums) {\\n    const n = nums.length;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (detectCycleDFS(i, i, nums[i] > 0)) return true;\\n    }\\n    \\n    return false;\\n    \\n    \\n    function detectCycleDFS(currIndex, prevIndex, isPos) {\\n        if (nums[currIndex] === 0) {\\n            return currIndex != prevIndex; // If there is a self-repeating cycle, we return false\\n        }\\n        \\n        // Return false if there is a mismatch of directions\\n        if (isPos != (nums[currIndex] > 0)) return false;\\n        \\n        const moves = nums[currIndex];\\n        \\n        nums[currIndex] = 0; // mark the index as being visited\\n        \\n        const nextIndex = (currIndex + (moves % n) + n) % n;\\n        const isCycle = detectCycleDFS(nextIndex, currIndex, isPos);\\n        \\n        nums[currIndex] = moves;\\n        \\n        return isCycle;    \\n    }\\n};  \\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar circularArrayLoop = function(nums) {\\n    const n = nums.length;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (detectCycleDFS(i, i, nums[i] > 0)) return true;\\n    }\\n    \\n    return false;\\n    \\n    \\n    function detectCycleDFS(currIndex, prevIndex, isPos) {\\n        if (nums[currIndex] === 0) {\\n            return currIndex != prevIndex; // If there is a self-repeating cycle, we return false\\n        }\\n        \\n        // Return false if there is a mismatch of directions\\n        if (isPos != (nums[currIndex] > 0)) return false;\\n        \\n        const moves = nums[currIndex];\\n        \\n        nums[currIndex] = 0; // mark the index as being visited\\n        \\n        const nextIndex = (currIndex + (moves % n) + n) % n;\\n        const isCycle = detectCycleDFS(nextIndex, currIndex, isPos);\\n        \\n        nums[currIndex] = moves;\\n        \\n        return isCycle;    \\n    }\\n};  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1245298,
                "title": "simple-c-o-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)     return false;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int val = nums[i];\\n            bool positive = (val > 0);\\n            unordered_map<int, bool> vmap;\\n            int id = i;\\n            bool flag = true;\\n            while (flag || id != i) {\\n                if (positive && nums[id] < 0)   break;\\n                if (!positive && nums[id] > 0)  break;\\n                if (vmap[id])  break;\\n                vmap[id] = true;\\n                int step = nums[id] % n;\\n                id += step;\\n                if (id >= n)    id -= n;\\n                else if (id < 0)    id = n + id;\\n                flag = false;\\n            }\\n            if (id == i && vmap.size() > 1)  return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)     return false;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int val = nums[i];\\n            bool positive = (val > 0);\\n            unordered_map<int, bool> vmap;\\n            int id = i;\\n            bool flag = true;\\n            while (flag || id != i) {\\n                if (positive && nums[id] < 0)   break;\\n                if (!positive && nums[id] > 0)  break;\\n                if (vmap[id])  break;\\n                vmap[id] = true;\\n                int step = nums[id] % n;\\n                id += step;\\n                if (id >= n)    id -= n;\\n                else if (id < 0)    id = n + id;\\n                flag = false;\\n            }\\n            if (id == i && vmap.size() > 1)  return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190478,
                "title": "24ms-98-efficient",
                "content": "24ms, 98% efficient. Bruteforce Approach. \\npython, python3\\nComments inline.\\n\\n```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        \"\"\"\\n            Bruteforce Solution with some improvement\\n        \"\"\"\\n        size = len(nums)\\n        visited = [False]*size\\n        \\n        v = 0\\n        cycle_idx = 0\\n        \\n        i = 0\\n        #check cycle from all index\\n        while i < size:\\n            #if already visited , No Need to find cycle on this index\\n            if visited[i]:\\n                i += 1\\n                continue\\n            v = i\\n            #find cycle_index origin\\n            cycle_idx = 0\\n            for j in range(size):\\n                visited[v] = True\\n                v = (v+nums[v])%size\\n                if visited[v]:\\n                    cycle_idx = v\\n        \\n            v = cycle_idx\\n            #print(i,v, nums)\\n            cycle_len = 0\\n            if nums[v] > 0:\\n                sign = 1\\n            else:\\n                sign = -1\\n            \\n            #find cycle length from cycle_index and check all elements in cycle are of same sign\\n            flag_nxt = False\\n            while True:\\n                cycle_len += 1\\n                if sign == 1 and nums[v] < 0:\\n                    flag_nxt = True\\n                    break\\n            \\n                if sign == -1 and nums[v] > 0:\\n                    flag_nxt = True\\n                    break\\n                    \\n                v = (v+nums[v])%size\\n                if v == cycle_idx:\\n                    break\\n            \\n            i += 1\\n            if flag_nxt:\\n                continue\\n            #condition met for cycle\\n            if cycle_len > 1:\\n                return True\\n            \\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        \"\"\"\\n            Bruteforce Solution with some improvement\\n        \"\"\"\\n        size = len(nums)\\n        visited = [False]*size\\n        \\n        v = 0\\n        cycle_idx = 0\\n        \\n        i = 0\\n        #check cycle from all index\\n        while i < size:\\n            #if already visited , No Need to find cycle on this index\\n            if visited[i]:\\n                i += 1\\n                continue\\n            v = i\\n            #find cycle_index origin\\n            cycle_idx = 0\\n            for j in range(size):\\n                visited[v] = True\\n                v = (v+nums[v])%size\\n                if visited[v]:\\n                    cycle_idx = v\\n        \\n            v = cycle_idx\\n            #print(i,v, nums)\\n            cycle_len = 0\\n            if nums[v] > 0:\\n                sign = 1\\n            else:\\n                sign = -1\\n            \\n            #find cycle length from cycle_index and check all elements in cycle are of same sign\\n            flag_nxt = False\\n            while True:\\n                cycle_len += 1\\n                if sign == 1 and nums[v] < 0:\\n                    flag_nxt = True\\n                    break\\n            \\n                if sign == -1 and nums[v] > 0:\\n                    flag_nxt = True\\n                    break\\n                    \\n                v = (v+nums[v])%size\\n                if v == cycle_idx:\\n                    break\\n            \\n            i += 1\\n            if flag_nxt:\\n                continue\\n            #condition met for cycle\\n            if cycle_len > 1:\\n                return True\\n            \\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189514,
                "title": "a-cumbersome-questions-but-this-line-by-line-explanation-using-comments-will-help-you-a-lot",
                "content": "```\\nclass Solution {\\npublic:\\n     bool circularArrayLoop(vector<int>& nums)\\n     {\\n        int n = nums.size(); //find size of array\\n         \\n        for (int j = 0; j < n; ++ j) \\n            nums[j] %= n; // After this, no number is > n or < -n.\\n         \\n        for (int j = 0; j < n; ++ j) \\n        {\\n            int i = j, last_i = 0;\\n            \\n            bool is_forward = nums[i] > 0; //positive / negative number loop\\n            \\n            while (nums[i] % n != 0 && nums[i] > 0 == is_forward) \\n            {\\n                last_i = i;\\n                i = (i + nums[i] + n) % n; // +n to curb negatives, i i current positon and it is updated to the next position\\n                \\n                nums[last_i] = (j + 1) * n; //just getting a very large number to make it visited without affecting it\\'s mode with n\\n                \\n                if (nums[i] == nums[last_i]) //nums[last_i]\\'s mode with n is same as mode of nums[i] since last_i is current position and nums[i] is the next position so if we have looped to the same position then return true;\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool circularArrayLoop(vector<int>& nums)\\n     {\\n        int n = nums.size(); //find size of array\\n         \\n        for (int j = 0; j < n; ++ j) \\n            nums[j] %= n; // After this, no number is > n or < -n.\\n         \\n        for (int j = 0; j < n; ++ j) \\n        {\\n            int i = j, last_i = 0;\\n            \\n            bool is_forward = nums[i] > 0; //positive / negative number loop\\n            \\n            while (nums[i] % n != 0 && nums[i] > 0 == is_forward) \\n            {\\n                last_i = i;\\n                i = (i + nums[i] + n) % n; // +n to curb negatives, i i current positon and it is updated to the next position\\n                \\n                nums[last_i] = (j + 1) * n; //just getting a very large number to make it visited without affecting it\\'s mode with n\\n                \\n                if (nums[i] == nums[last_i]) //nums[last_i]\\'s mode with n is same as mode of nums[i] since last_i is current position and nums[i] is the next position so if we have looped to the same position then return true;\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103802,
                "title": "i-cannot-understand-why-3-1-2-gives-true",
                "content": "## Can someone help me understand why the following testcase is expecting True?\\nnums = [3,1, 2] \\n\\nIt forms cycle with index ```0->0->0->..``` as it is of sequence length = 1, output should be false, Isn\\'t it?",
                "solutionTags": [],
                "code": "```0->0->0->..```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099561,
                "title": "java-solution-speed-faster-than-100-00-memory-usage-less-than-79-26-well-commented",
                "content": "```\\nclass Solution {\\n    private int getNext(int[] nums, int idx) {\\n        int n = nums.length;\\n        return ((nums[idx] + idx) % n + n) % n;\\n    }\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return false;\\n        }\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 0) {\\n                continue; // no need to visit OR has visited\\n            }\\n            \\n            int slow = i, fast = i, val = 0;\\n            \\n            while(nums[fast] * nums[i] > 0 && nums[getNext(nums, fast)] * nums[i] > 0) {\\n                \\n                slow = getNext(nums, slow);\\n                fast = getNext(nums, getNext(nums, fast));\\n                \\n                // ensure the direction remains same\\n                if (slow == fast) {\\n                    if (slow == getNext(nums, slow)) {\\n                        // check for loop that only contains one element\\n                        break;\\n                    }\\n                    // valid answer\\n                    return true;\\n                }\\n            }\\n            \\n            // loop not found, set all element along the way to 0\\n            // let them avoid being visited again\\n            slow = i;\\n            val = nums[i];\\n            while(nums[slow] * val > 0) {\\n                int next = getNext(nums, slow);\\n                nums[slow] = 0;\\n                slow = next;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int getNext(int[] nums, int idx) {\\n        int n = nums.length;\\n        return ((nums[idx] + idx) % n + n) % n;\\n    }\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return false;\\n        }\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 0) {\\n                continue; // no need to visit OR has visited\\n            }\\n            \\n            int slow = i, fast = i, val = 0;\\n            \\n            while(nums[fast] * nums[i] > 0 && nums[getNext(nums, fast)] * nums[i] > 0) {\\n                \\n                slow = getNext(nums, slow);\\n                fast = getNext(nums, getNext(nums, fast));\\n                \\n                // ensure the direction remains same\\n                if (slow == fast) {\\n                    if (slow == getNext(nums, slow)) {\\n                        // check for loop that only contains one element\\n                        break;\\n                    }\\n                    // valid answer\\n                    return true;\\n                }\\n            }\\n            \\n            // loop not found, set all element along the way to 0\\n            // let them avoid being visited again\\n            slow = i;\\n            val = nums[i];\\n            while(nums[slow] * val > 0) {\\n                int next = getNext(nums, slow);\\n                nums[slow] = 0;\\n                slow = next;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054426,
                "title": "c-hare-tortoise-algorithm-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int getNext(int ptr, int N, bool forward, vector<int>& nums){\\n        bool direction = nums[ptr] > 0;\\n        if(direction != forward)\\n            return -1;\\n        if(nums[ptr] % N == 0)\\n            return -1;\\n        return ((ptr + nums[ptr]) % N + N) % N;\\n    }\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        int N = nums.size();\\n        for(int i = 0; i < N; i++){\\n            if(nums[i] % N == 0)\\n                continue;\\n            bool forward = nums[i] > 0;\\n            int slow = i;\\n            int fast = i;\\n            while(1){\\n                slow = getNext(slow, N, forward, nums);\\n                if(slow == -1)\\n                    break;\\n                fast = getNext(fast, N, forward, nums);\\n                if(fast == -1)\\n                    break;\\n                fast = getNext(fast, N, forward, nums);\\n                if(fast == -1)\\n                    break;\\n                if(slow == fast)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getNext(int ptr, int N, bool forward, vector<int>& nums){\\n        bool direction = nums[ptr] > 0;\\n        if(direction != forward)\\n            return -1;\\n        if(nums[ptr] % N == 0)\\n            return -1;\\n        return ((ptr + nums[ptr]) % N + N) % N;\\n    }\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        int N = nums.size();\\n        for(int i = 0; i < N; i++){\\n            if(nums[i] % N == 0)\\n                continue;\\n            bool forward = nums[i] > 0;\\n            int slow = i;\\n            int fast = i;\\n            while(1){\\n                slow = getNext(slow, N, forward, nums);\\n                if(slow == -1)\\n                    break;\\n                fast = getNext(fast, N, forward, nums);\\n                if(fast == -1)\\n                    break;\\n                fast = getNext(fast, N, forward, nums);\\n                if(fast == -1)\\n                    break;\\n                if(slow == fast)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048922,
                "title": "python3-hare-and-tortoise-algorithm-with-explanation",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        \\n        def circular_array_loop_exists(arr):\\n            for i in range(len(arr)):\\n                is_forward = arr[i] >= 0  # if we are moving forward or not\\n                slow, fast = i, i\\n\\n                # if slow or fast becomes \\'-1\\' this means we can\\'t find cycle for this number\\n                while True:\\n                    # move one step for slow pointer\\n                    slow = find_next_index(arr, is_forward, slow)\\n                    # move one step for fast pointer\\n                    fast = find_next_index(arr, is_forward, fast)\\n                    if (fast != -1):\\n                        # move another step for fast pointer\\n                        fast = find_next_index(arr, is_forward, fast)\\n                    if slow == -1 or fast == -1 or slow == fast:\\n                        break\\n\\n                if slow != -1 and slow == fast:\\n                    return True\\n\\n            return False\\n\\n\\n        def find_next_index(arr, is_forward, current_index):\\n            direction = arr[current_index] >= 0\\n\\n            if is_forward != direction:\\n                return -1  # change in direction, return -1\\n\\n            next_index = (current_index + arr[current_index]) % len(arr)\\n\\n            # one element cycle, return -1\\n            if next_index == current_index:\\n                next_index = -1\\n\\n            return next_index\\n        \\n        return circular_array_loop_exists(nums)\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        \\n        def circular_array_loop_exists(arr):\\n            for i in range(len(arr)):\\n                is_forward = arr[i] >= 0  # if we are moving forward or not\\n                slow, fast = i, i\\n\\n                # if slow or fast becomes \\'-1\\' this means we can\\'t find cycle for this number\\n                while True:\\n                    # move one step for slow pointer\\n                    slow = find_next_index(arr, is_forward, slow)\\n                    # move one step for fast pointer\\n                    fast = find_next_index(arr, is_forward, fast)\\n                    if (fast != -1):\\n                        # move another step for fast pointer\\n                        fast = find_next_index(arr, is_forward, fast)\\n                    if slow == -1 or fast == -1 or slow == fast:\\n                        break\\n\\n                if slow != -1 and slow == fast:\\n                    return True\\n\\n            return False\\n\\n\\n        def find_next_index(arr, is_forward, current_index):\\n            direction = arr[current_index] >= 0\\n\\n            if is_forward != direction:\\n                return -1  # change in direction, return -1\\n\\n            next_index = (current_index + arr[current_index]) % len(arr)\\n\\n            # one element cycle, return -1\\n            if next_index == current_index:\\n                next_index = -1\\n\\n            return next_index\\n        \\n        return circular_array_loop_exists(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039559,
                "title": "straightforward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        bool forward=true;\\n        for (int i=0;i<n;i++){\\n            //the cycle\\'s length must be greater than 1\\n            if (abs(nums[i])%n==0) continue;\\n            //starting from nums[i]\\n            forward=(nums[i]>0);\\n            int p=i;//position\\n            while (p<2*n && p>-2*n){//check for two rounds\\n                int id= (3*n+p)%n;\\n                if (abs(nums[id])%n==0) break;\\n                p+=nums[id]%n;\\n                id= (3*n+p)%n;\\n                //wrong direction\\n                if (nums[id]<0 && forward) break;\\n                if (nums[id]>0 && !forward) break;\\n                if (id==i){\\n                    //arrived at the same index, found a cycle\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        bool forward=true;\\n        for (int i=0;i<n;i++){\\n            //the cycle\\'s length must be greater than 1\\n            if (abs(nums[i])%n==0) continue;\\n            //starting from nums[i]\\n            forward=(nums[i]>0);\\n            int p=i;//position\\n            while (p<2*n && p>-2*n){//check for two rounds\\n                int id= (3*n+p)%n;\\n                if (abs(nums[id])%n==0) break;\\n                p+=nums[id]%n;\\n                id= (3*n+p)%n;\\n                //wrong direction\\n                if (nums[id]<0 && forward) break;\\n                if (nums[id]>0 && !forward) break;\\n                if (id==i){\\n                    //arrived at the same index, found a cycle\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031261,
                "title": "javascript-solution-explain",
                "content": "\\n```\\nvar circularArrayLoop = function(nums) {\\n    //1.This array maybe has more than one cycle that we don\\'t know,\\n\\t//so we need to run each element to check cycle. \\n    for(let i = 0 ; i < nums.length ; i++){\\n\\t    //2.this cycle only can choose one direction , \\n\\t\\t//so we need to use \\'dir\\' to check they all positive or negative.\\n        let ans = [];\\n        let dir = Math.sign(nums[i]);\\n        let j = i;\\n        \\n\\t\\t//3.if this element has been checked, change it to zero.\\n\\t\\t//if the nums[j]  == 0 , means we find this cycle and get the start point called j.\\n        while(nums[j] != 0 && Math.sign(nums[j]) == dir){\\n            let preJ = j;\\n            \\n            j += nums[j];\\n            j %= nums.length;\\n            j += j < 0 ? nums.length : 0;\\n            \\n            ans.push(preJ);\\n            nums[preJ] = 0;\\n        }\\n\\t\\t//4.check the cycle size more than one or not\\n        let pos = ans.indexOf(j);\\n        if(ans.length > 1 && pos != -1 && pos != ans.length - 1)  return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar circularArrayLoop = function(nums) {\\n    //1.This array maybe has more than one cycle that we don\\'t know,\\n\\t//so we need to run each element to check cycle. \\n    for(let i = 0 ; i < nums.length ; i++){\\n\\t    //2.this cycle only can choose one direction , \\n\\t\\t//so we need to use \\'dir\\' to check they all positive or negative.\\n        let ans = [];\\n        let dir = Math.sign(nums[i]);\\n        let j = i;\\n        \\n\\t\\t//3.if this element has been checked, change it to zero.\\n\\t\\t//if the nums[j]  == 0 , means we find this cycle and get the start point called j.\\n        while(nums[j] != 0 && Math.sign(nums[j]) == dir){\\n            let preJ = j;\\n            \\n            j += nums[j];\\n            j %= nums.length;\\n            j += j < 0 ? nums.length : 0;\\n            \\n            ans.push(preJ);\\n            nums[preJ] = 0;\\n        }\\n\\t\\t//4.check the cycle size more than one or not\\n        let pos = ans.indexOf(j);\\n        if(ans.length > 1 && pos != -1 && pos != ans.length - 1)  return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 954131,
                "title": "c-straightforward",
                "content": "1. Pick a starting position `k`, follow it and move to the next position in the array to explore elements in the current \"pesudo-circle\". For each new element, we mark it as visited.\\n2. If an element in the current pesudo-circle is visited again with more than `1` steps, it means we have found a true circle, return `true`\\n3. If an element in the current pesudo-circle has been visited in a different previous pesudo-circle, or it has a reversed direction of moving, stop searching and start with next `k`, which should be an unvisited node.\\n\\n```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        const int N = nums.size();\\n        // trival case\\n        if (N <= 1) {\\n            return false;\\n        }\\n        // flags for visited nodes\\n        vector<bool> visited(N, false);\\n        // loop all possible starting positions\\n        for (int k(0); k < N; ++k) {\\n            if (visited[k]) {\\n                continue;\\n            }\\n            else {\\n                int i = k;\\n                const bool positiveDirection = (nums[i] > 0);\\n                unordered_set<int> pesudoCircle;\\n                while (true) {\\n                    if (pesudoCircle.count(i)) {\\n                        return true;\\n                    }\\n                    else {\\n                        // break if i already visited, or the direction reversed\\n                        if (visited[i] or positiveDirection != (nums[i] > 0)) {\\n                            break;\\n                        }\\n                        // record current i and move to next i\\n                        pesudoCircle.insert(i);\\n                        visited[i] = true;\\n                        int nexti = (i + nums[i]) % N;\\n                        if (nexti < 0) {\\n                            nexti += N;\\n                        }\\n                        // if go back to i itself, does not count as a circle\\n                        if (nexti == i) {\\n                            break;\\n                        }\\n                        else {\\n                            i = nexti;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        const int N = nums.size();\\n        // trival case\\n        if (N <= 1) {\\n            return false;\\n        }\\n        // flags for visited nodes\\n        vector<bool> visited(N, false);\\n        // loop all possible starting positions\\n        for (int k(0); k < N; ++k) {\\n            if (visited[k]) {\\n                continue;\\n            }\\n            else {\\n                int i = k;\\n                const bool positiveDirection = (nums[i] > 0);\\n                unordered_set<int> pesudoCircle;\\n                while (true) {\\n                    if (pesudoCircle.count(i)) {\\n                        return true;\\n                    }\\n                    else {\\n                        // break if i already visited, or the direction reversed\\n                        if (visited[i] or positiveDirection != (nums[i] > 0)) {\\n                            break;\\n                        }\\n                        // record current i and move to next i\\n                        pesudoCircle.insert(i);\\n                        visited[i] = true;\\n                        int nexti = (i + nums[i]) % N;\\n                        if (nexti < 0) {\\n                            nexti += N;\\n                        }\\n                        // if go back to i itself, does not count as a circle\\n                        if (nexti == i) {\\n                            break;\\n                        }\\n                        else {\\n                            i = nexti;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937944,
                "title": "c-0-ms-100-faster",
                "content": "Gist :\\n* No need to consider index again if you have already checked once and cycle not found.\\n* Once check all elements and no cycle, return false.\\n* Cycle with only farword or backword direction, all elements will be \\'+\\'ve or \\'-\\'ve.\\n* If in cycle, positive & negative elements exist, that\\'s not valid cycle.\\n* If next element == last element (single element cycle) not valid.\\n* else if encountered already visited element in current stack (like finding cycle in DAG), return true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> visited(n, false);\\n        for(int i=0;i<n;++i){\\n            if(visited[i]) continue;   //no need to consider visited index again, since this is not part of cycle.\\n            vector<bool> current_visited(n, false);\\n            if(has_cycle(nums, current_visited, i)){  //check if i can lead to cycle or not\\n                return true;\\n            }\\n            else{\\n                for(int j=0;j<n;++j){\\n                     if(current_visited[j]) visited[j] = current_visited[j];  //all index involved in this iteration do not involved in cycle\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int get_next(vector<int> &nums, int current_index){\\n        int next_index = (current_index + nums[current_index] + nums.size())%nums.size();  // +n to make it positive.\\n        return next_index; \\n    }\\n    \\n    bool has_cycle(vector<int> &nums, vector<bool> &visited, int i){\\n        int next = get_next(nums, i);\\n        \\n        visited[i] = true;\\n        \\n        if(next == i){ //single length loop, false by definition\\n            return false;\\n        }\\n        \\n        if(nums[next] > 0 != nums[i] > 0) //for single direction cycle, every element of cycle must be +ve or -ve.\\n            return false;\\n        if(visited[next]) //already visited, cycle detected\\n            return true; \\n\\n        return has_cycle(nums, visited, next);\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> visited(n, false);\\n        for(int i=0;i<n;++i){\\n            if(visited[i]) continue;   //no need to consider visited index again, since this is not part of cycle.\\n            vector<bool> current_visited(n, false);\\n            if(has_cycle(nums, current_visited, i)){  //check if i can lead to cycle or not\\n                return true;\\n            }\\n            else{\\n                for(int j=0;j<n;++j){\\n                     if(current_visited[j]) visited[j] = current_visited[j];  //all index involved in this iteration do not involved in cycle\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int get_next(vector<int> &nums, int current_index){\\n        int next_index = (current_index + nums[current_index] + nums.size())%nums.size();  // +n to make it positive.\\n        return next_index; \\n    }\\n    \\n    bool has_cycle(vector<int> &nums, vector<bool> &visited, int i){\\n        int next = get_next(nums, i);\\n        \\n        visited[i] = true;\\n        \\n        if(next == i){ //single length loop, false by definition\\n            return false;\\n        }\\n        \\n        if(nums[next] > 0 != nums[i] > 0) //for single direction cycle, every element of cycle must be +ve or -ve.\\n            return false;\\n        if(visited[next]) //already visited, cycle detected\\n            return true; \\n\\n        return has_cycle(nums, visited, next);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924978,
                "title": "java-two-pointers",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] arr) {\\n        for(int i = 0; i < arr.length; i++){\\n          int slow = i;\\n          int fast = i;\\n          boolean dir = arr[i] > 0;\\n          int step = arr.length;\\n          while(step > 0){\\n            slow = ((slow + arr[slow]) % arr.length + arr.length) % arr.length;\\n            fast = ((fast + arr[fast]) % arr.length + arr.length) % arr.length;\\n              \\n            if(!validate(arr[slow], dir, arr.length)){\\n              break;\\n            }\\n            if(!validate(arr[fast], dir, arr.length)){\\n              break;\\n            }\\n            fast = ((fast + arr[fast]) % arr.length + arr.length) % arr.length;\\n            if(!validate(arr[fast], dir, arr.length)){\\n              break;\\n            }\\n            if(slow == fast){\\n              return true;\\n            }\\n            step--;\\n          }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean validate(int num, boolean dir, int len){\\n        if(num % len == 0 || (num > 0 != dir)){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] arr) {\\n        for(int i = 0; i < arr.length; i++){\\n          int slow = i;\\n          int fast = i;\\n          boolean dir = arr[i] > 0;\\n          int step = arr.length;\\n          while(step > 0){\\n            slow = ((slow + arr[slow]) % arr.length + arr.length) % arr.length;\\n            fast = ((fast + arr[fast]) % arr.length + arr.length) % arr.length;\\n              \\n            if(!validate(arr[slow], dir, arr.length)){\\n              break;\\n            }\\n            if(!validate(arr[fast], dir, arr.length)){\\n              break;\\n            }\\n            fast = ((fast + arr[fast]) % arr.length + arr.length) % arr.length;\\n            if(!validate(arr[fast], dir, arr.length)){\\n              break;\\n            }\\n            if(slow == fast){\\n              return true;\\n            }\\n            step--;\\n          }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean validate(int num, boolean dir, int len){\\n        if(num % len == 0 || (num > 0 != dir)){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837093,
                "title": "python-o-n-time-o-1-space-without-slow-fast-pointer",
                "content": "```\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i, num in enumerate(nums):\\n            if num <= 5000:\\n                j = i\\n                while nums[j] <= 5000:\\n                    if nums[j] * num < 0:\\n                        break\\n                    nextJ = (j + nums[j]) % len(nums)\\n                    if nextJ == j:\\n                        break\\n                    nums[j] = 5001 + i\\n                    j = nextJ\\n                if nums[j] == 5001 + i:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i, num in enumerate(nums):\\n            if num <= 5000:\\n                j = i\\n                while nums[j] <= 5000:\\n                    if nums[j] * num < 0:\\n                        break\\n                    nextJ = (j + nums[j]) % len(nums)\\n                    if nextJ == j:\\n                        break\\n                    nums[j] = 5001 + i\\n                    j = nextJ\\n                if nums[j] == 5001 + i:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828121,
                "title": "simple-java-solution-o-n-time-and-o-n-space",
                "content": "A fairly simple solution. Do a dfs on numbers in the same direction. If the numbers change signs then start over again. \\n```\\n    static int mod(int a, int b){\\n        int c = a % b;\\n        return (c < 0) ? c + b : c;\\n    }\\n\\n    public static boolean circularArrayLoop(int[] nums) {\\n        Set<Integer> visited = new HashSet<>();\\n        int len = nums.length;\\n        Integer idx = null;\\n        for ( int i = 0; i < len; ++i ) {\\n\\t\\t   // set starting point\\n            if (idx == null) {\\n                idx = i;\\n                visited.add(i);\\n            }\\n            int prevIdx = idx;\\n            idx += nums[idx];\\n            idx = mod(idx,len);\\n\\t\\t\\t// reset starting point \\n            if ( idx == prevIdx ) {\\n                idx = null;\\n                visited.clear();\\n            }\\n\\t\\t\\t// same direction case\\n            else if ((nums[idx] > 0 && nums[prevIdx] > 0) || (nums[idx] < 0 && nums[prevIdx] < 0)) {\\n                if (visited.contains(idx)) return true;\\n                visited.add(idx);\\n            }\\n\\t\\t\\t// reset starting point if direction has changed\\n            else {\\n                idx = null;\\n                visited.clear();\\n            }\\n        }\\n        return false;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    static int mod(int a, int b){\\n        int c = a % b;\\n        return (c < 0) ? c + b : c;\\n    }\\n\\n    public static boolean circularArrayLoop(int[] nums) {\\n        Set<Integer> visited = new HashSet<>();\\n        int len = nums.length;\\n        Integer idx = null;\\n        for ( int i = 0; i < len; ++i ) {\\n\\t\\t   // set starting point\\n            if (idx == null) {\\n                idx = i;\\n                visited.add(i);\\n            }\\n            int prevIdx = idx;\\n            idx += nums[idx];\\n            idx = mod(idx,len);\\n\\t\\t\\t// reset starting point \\n            if ( idx == prevIdx ) {\\n                idx = null;\\n                visited.clear();\\n            }\\n\\t\\t\\t// same direction case\\n            else if ((nums[idx] > 0 && nums[prevIdx] > 0) || (nums[idx] < 0 && nums[prevIdx] < 0)) {\\n                if (visited.contains(idx)) return true;\\n                visited.add(idx);\\n            }\\n\\t\\t\\t// reset starting point if direction has changed\\n            else {\\n                idx = null;\\n                visited.clear();\\n            }\\n        }\\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825148,
                "title": "short-c-dfs-solution",
                "content": "The basic idea is DFS cycle detection.\\n```\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> state(n);\\n        function<bool(int, int)> dfs = [&](int index, int dir) {\\n            int i = ((index % n) + n) % n;\\n            if (state[i])\\n                return state[i] == -1;\\n            if (nums[i] % n == 0) {\\n                state[i] = 1;\\n                return false;\\n            }\\n            if (dir * nums[i] <= 0)\\n                return false;\\n            state[i] = -1;\\n            if (dfs(i + nums[i], nums[i]))\\n                return true;\\n            state[i] = 1;\\n            return false;\\n        };\\n        for (int i = 0; i < n; ++i) \\n            if (dfs(i, nums[i]))\\n                return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> state(n);\\n        function<bool(int, int)> dfs = [&](int index, int dir) {\\n            int i = ((index % n) + n) % n;\\n            if (state[i])\\n                return state[i] == -1;\\n            if (nums[i] % n == 0) {\\n                state[i] = 1;\\n                return false;\\n            }\\n            if (dir * nums[i] <= 0)\\n                return false;\\n            state[i] = -1;\\n            if (dfs(i + nums[i], nums[i]))\\n                return true;\\n            state[i] = 1;\\n            return false;\\n        };\\n        for (int i = 0; i < n; ++i) \\n            if (dfs(i, nums[i]))\\n                return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819074,
                "title": "python-o-n-2",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            direction = nums[i] >= 0\\n            slow, fast = i,i\\n            while True:\\n                # print(slow,fast)\\n                slow = self.next_index(nums, direction, slow)\\n                fast = self.next_index(nums, direction, fast)\\n                # print(slow,fast)\\n                if fast != -1:\\n                    fast = self.next_index(nums, direction, fast)\\n                # print(slow,fast)    \\n                if slow == -1  or fast == -1  or slow == fast:\\n                    break\\n            # print(slow, fast)\\n            if slow != -1 and slow == fast:\\n                return True \\n            \\n        return False\\n    def next_index( self, nums, direction, curr_index):\\n        curr_direction = nums[curr_index]>= 0\\n        \\n        if curr_direction != direction:\\n            return -1\\n        \\n        next_index = (curr_index + nums[curr_index]) % len(nums)\\n        \\n        if curr_index == next_index:\\n            return -1\\n        return next_index\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            direction = nums[i] >= 0\\n            slow, fast = i,i\\n            while True:\\n                # print(slow,fast)\\n                slow = self.next_index(nums, direction, slow)\\n                fast = self.next_index(nums, direction, fast)\\n                # print(slow,fast)\\n                if fast != -1:\\n                    fast = self.next_index(nums, direction, fast)\\n                # print(slow,fast)    \\n                if slow == -1  or fast == -1  or slow == fast:\\n                    break\\n            # print(slow, fast)\\n            if slow != -1 and slow == fast:\\n                return True \\n            \\n        return False\\n    def next_index( self, nums, direction, curr_index):\\n        curr_direction = nums[curr_index]>= 0\\n        \\n        if curr_direction != direction:\\n            return -1\\n        \\n        next_index = (curr_index + nums[curr_index]) % len(nums)\\n        \\n        if curr_index == next_index:\\n            return -1\\n        return next_index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818536,
                "title": "java-slowpointer-fastpointer-solution",
                "content": "```\\nclass Solution {\\n   public boolean circularArrayLoop(int[] nums) {\\n\\t\\tif (nums.length == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\touter: for (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] != 0) {\\n                //use slowPointer and fastPointer to detect a loop\\n\\t\\t\\t\\tint slowPtr = i, fastPtr = i;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tint offset = nums[slowPtr];\\n\\t\\t\\t\\t\\tif (offset == 0) {\\n\\t\\t\\t\\t\\t\\tcontinue outer;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tslowPtr = (slowPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (slowPtr < 0) {\\n\\t\\t\\t\\t\\t\\tslowPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toffset = nums[fastPtr];\\n\\t\\t\\t\\t\\tfastPtr = (fastPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (fastPtr < 0) {\\n\\t\\t\\t\\t\\t\\tfastPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toffset = nums[fastPtr];\\n\\t\\t\\t\\t\\tif (offset == 0) {\\n\\t\\t\\t\\t\\t\\tcontinue outer;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfastPtr = (fastPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (fastPtr < 0) {\\n\\t\\t\\t\\t\\t\\tfastPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while (slowPtr != fastPtr);\\n                //at this point teh fast pointer is somewhere inside  the loop\\n                //reset the slowPointer to the begining and move both pointers one step at a time to find the beginning of loop.\\n                //zero out the locations visited by slowpointer so that they are not visited again in next iteraation of outer for loop\\n                \\n\\t\\t\\t\\tslowPtr = i;\\n\\t\\t\\t\\twhile (slowPtr != fastPtr) {\\n\\t\\t\\t\\t\\tint offset = nums[slowPtr];\\n\\t\\t\\t\\t\\tnums[slowPtr] = 0;\\n\\t\\t\\t\\t\\tslowPtr = (slowPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (slowPtr < 0) {\\n\\t\\t\\t\\t\\t\\tslowPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toffset = nums[fastPtr];\\n\\t\\t\\t\\t\\tfastPtr = (fastPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (fastPtr < 0) {\\n\\t\\t\\t\\t\\t\\tfastPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                //at this point fastptr is at the beginning of the loop\\n                //cycle through the loop one step at a time and note doown the movement direction and cycle length\\n                //zero out the location so taht the yare not visited again in next iteraation of outer for loop\\n\\n\\t\\t\\t\\tint rCount = 0;\\n\\t\\t\\t\\tint fCount = 0;\\n\\t\\t\\t\\tint cycleLength = 0;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tint offset = nums[fastPtr];\\n\\t\\t\\t\\t\\tif (offset < 0) {\\n\\t\\t\\t\\t\\t\\trCount++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfCount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnums[fastPtr] = 0;\\n\\t\\t\\t\\t\\tfastPtr = (fastPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (fastPtr < 0) {\\n\\t\\t\\t\\t\\t\\tfastPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcycleLength++;\\n\\t\\t\\t\\t} while (fastPtr != slowPtr);\\n                \\n\\t\\t\\t\\tif (cycleLength > 1 && (rCount == 0 || fCount == 0)) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public boolean circularArrayLoop(int[] nums) {\\n\\t\\tif (nums.length == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\touter: for (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] != 0) {\\n                //use slowPointer and fastPointer to detect a loop\\n\\t\\t\\t\\tint slowPtr = i, fastPtr = i;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tint offset = nums[slowPtr];\\n\\t\\t\\t\\t\\tif (offset == 0) {\\n\\t\\t\\t\\t\\t\\tcontinue outer;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tslowPtr = (slowPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (slowPtr < 0) {\\n\\t\\t\\t\\t\\t\\tslowPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toffset = nums[fastPtr];\\n\\t\\t\\t\\t\\tfastPtr = (fastPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (fastPtr < 0) {\\n\\t\\t\\t\\t\\t\\tfastPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toffset = nums[fastPtr];\\n\\t\\t\\t\\t\\tif (offset == 0) {\\n\\t\\t\\t\\t\\t\\tcontinue outer;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfastPtr = (fastPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (fastPtr < 0) {\\n\\t\\t\\t\\t\\t\\tfastPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while (slowPtr != fastPtr);\\n                //at this point teh fast pointer is somewhere inside  the loop\\n                //reset the slowPointer to the begining and move both pointers one step at a time to find the beginning of loop.\\n                //zero out the locations visited by slowpointer so that they are not visited again in next iteraation of outer for loop\\n                \\n\\t\\t\\t\\tslowPtr = i;\\n\\t\\t\\t\\twhile (slowPtr != fastPtr) {\\n\\t\\t\\t\\t\\tint offset = nums[slowPtr];\\n\\t\\t\\t\\t\\tnums[slowPtr] = 0;\\n\\t\\t\\t\\t\\tslowPtr = (slowPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (slowPtr < 0) {\\n\\t\\t\\t\\t\\t\\tslowPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toffset = nums[fastPtr];\\n\\t\\t\\t\\t\\tfastPtr = (fastPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (fastPtr < 0) {\\n\\t\\t\\t\\t\\t\\tfastPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                //at this point fastptr is at the beginning of the loop\\n                //cycle through the loop one step at a time and note doown the movement direction and cycle length\\n                //zero out the location so taht the yare not visited again in next iteraation of outer for loop\\n\\n\\t\\t\\t\\tint rCount = 0;\\n\\t\\t\\t\\tint fCount = 0;\\n\\t\\t\\t\\tint cycleLength = 0;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tint offset = nums[fastPtr];\\n\\t\\t\\t\\t\\tif (offset < 0) {\\n\\t\\t\\t\\t\\t\\trCount++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfCount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnums[fastPtr] = 0;\\n\\t\\t\\t\\t\\tfastPtr = (fastPtr + offset) % nums.length;\\n\\t\\t\\t\\t\\tif (fastPtr < 0) {\\n\\t\\t\\t\\t\\t\\tfastPtr += nums.length;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcycleLength++;\\n\\t\\t\\t\\t} while (fastPtr != slowPtr);\\n                \\n\\t\\t\\t\\tif (cycleLength > 1 && (rCount == 0 || fCount == 0)) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 803044,
                "title": "java-indeed-a-very-simple-solution-for-beginners",
                "content": "Hey Reader, I Found this problem a bit difficult and almost read out 15 to 20 solutions on leetcode discuss but there are few key points before you approch the problem.\\n\\nRead the problem statement and make the points clear regarding jump from an index to another,  forward and backward movement rule for loop and length of loop > 1.\\n\\nSo We will use the two pointer approch . Now here two pointers will work like, first one a slow pointer and second , a fast pointer (Floyd Cycle detection concept used in LinkedList Basically).\\n\\nSlow pointer:- moves n indexes, where n is element at index where slow pointer is pointing.\\nFast Pointer :- moves nth time and then again mth time , where n is where fast pointer is pointing \\n                       initially and m is the index at which we arrive after moving fast pointer n times.\\n\\t\\t\\t\\t\\t \\nTake a look at the example:-\\n[1,1,2,1,2]\\ninitially, slow = 0 and fast = 0;\\n\\n(Written below are index of each pointers assuming array starts with 0th index)\\n(S-> Slow) (F-> Fast)\\n*  S       F\\n*  0            0\\n*  1            2\\n*  2            1\\n * 4            4\\n  \\n  At last, we see slow == fast, hence we have a Cycle.\\n  \\n  So Basically , we need to move pointers in the above fashion through applying our logic.\\n  **Now I recommend take a test case from the question description and try applying the above logic.**\\n \\n Now we can proceed to code:-\\n \\n ```\\n    class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        \\n        if(nums.length<=1)  // figured this out from question\\'s note section\\n            return false; \\n        \\n        int len = nums.length;\\n        for(int i =0;i<len;i++)\\n        {\\n            int slow = i;  // initials\\n            int fast = i;\\n            \\n            boolean flag = direction(nums,i);  // to know whether currently in forward or backward direction\\n            \\n            while(true)\\n            {\\n                slow = getNextPos(nums,slow,flag); // get where will go next position\\n                if(slow == -1)\\n                    break;\\n                \\n                fast = getNextPos(nums,fast,flag);  // get where will fast go next position (nth index)\\n                if(fast == -1)\\n                    break;\\n                // Again we call for fast index , because slow moves once and fast moves twice\\n                fast = getNextPos(nums,fast,flag);  // get where fast will got (mth position)\\n                if(fast == -1)\\n                    break;\\n                \\n                if(fast == slow)  // means we have a cycle\\n                    return true;\\n                \\n            }\\n        }\\n        return false; // if none of the above executes, then we return false.\\n    }\\n    public int getNextPos(int arr[],int n , boolean flag) \\n    {\\n        boolean curr_direction = arr[n]>=0;\\n        if(curr_direction != flag)\\n            return -1;\\n        \\n        int nextIndex = (n+arr[n])%arr.length;\\n        if(nextIndex < 0)\\n            nextIndex = nextIndex+arr.length;\\n        if(nextIndex == n) {//this means we come back again to n,thus a loop with length = 1\\n               return-1;\\n        }\\n        \\n        return nextIndex;\\n    }\\n    \\n    public boolean direction(int arr[],int n)\\n    {\\n        if(arr[n] >= 0)\\n            return true;   // true indicates forward direction\\n        else \\n            return false;   // false -> backward direction\\n    }\\n}\\n```\\n\\n*I Suggest Dry running the code yourself with a test case which will surely help you out.*\\n\\nCheers !  \\n  \\n",
                "solutionTags": [],
                "code": "```\\n    class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        \\n        if(nums.length<=1)  // figured this out from question\\'s note section\\n            return false; \\n        \\n        int len = nums.length;\\n        for(int i =0;i<len;i++)\\n        {\\n            int slow = i;  // initials\\n            int fast = i;\\n            \\n            boolean flag = direction(nums,i);  // to know whether currently in forward or backward direction\\n            \\n            while(true)\\n            {\\n                slow = getNextPos(nums,slow,flag); // get where will go next position\\n                if(slow == -1)\\n                    break;\\n                \\n                fast = getNextPos(nums,fast,flag);  // get where will fast go next position (nth index)\\n                if(fast == -1)\\n                    break;\\n                // Again we call for fast index , because slow moves once and fast moves twice\\n                fast = getNextPos(nums,fast,flag);  // get where fast will got (mth position)\\n                if(fast == -1)\\n                    break;\\n                \\n                if(fast == slow)  // means we have a cycle\\n                    return true;\\n                \\n            }\\n        }\\n        return false; // if none of the above executes, then we return false.\\n    }\\n    public int getNextPos(int arr[],int n , boolean flag) \\n    {\\n        boolean curr_direction = arr[n]>=0;\\n        if(curr_direction != flag)\\n            return -1;\\n        \\n        int nextIndex = (n+arr[n])%arr.length;\\n        if(nextIndex < 0)\\n            nextIndex = nextIndex+arr.length;\\n        if(nextIndex == n) {//this means we come back again to n,thus a loop with length = 1\\n               return-1;\\n        }\\n        \\n        return nextIndex;\\n    }\\n    \\n    public boolean direction(int arr[],int n)\\n    {\\n        if(arr[n] >= 0)\\n            return true;   // true indicates forward direction\\n        else \\n            return false;   // false -> backward direction\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795137,
                "title": "java-o-n-time-o-1-space-short-code-100-100",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i = 0; i < nums.length; i++) {\\n            int index = (i + nums[i] + 1000 * nums.length) % nums.length;\\n            while(nums[index] * nums[i] > 0 && index >= i && nums[index] % nums.length != 0) {\\n                if(i == index) return true;\\n                int val = nums[index];\\n                nums[index] = i - index + (nums[index] > 0 ? nums.length : 0);\\n                index = (index + val + 1000 * nums.length) % nums.length;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i = 0; i < nums.length; i++) {\\n            int index = (i + nums[i] + 1000 * nums.length) % nums.length;\\n            while(nums[index] * nums[i] > 0 && index >= i && nums[index] % nums.length != 0) {\\n                if(i == index) return true;\\n                int val = nums[index];\\n                nums[index] = i - index + (nums[index] > 0 ? nums.length : 0);\\n                index = (index + val + 1000 * nums.length) % nums.length;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769621,
                "title": "python3-o-n-solution-using-o-n-space-and-dfs",
                "content": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        adj1=[[] for i in range(n)] # positive cycle\\n        adj2=[[] for i in range(n)] # negative cycle\\n        for i,j in enumerate(nums):\\n            if j>=0:\\n                adj1[i].append((i+j)%n)\\n            else:\\n                adj2[i].append((i+j)%n)\\n            \\n        visited=[0]*n\\n        stack=[0]*n\\n        def dfs(u,adj):\\n            visited[u]=1\\n            stack[u]=1\\n            for v in adj[u]:\\n                if visited[v]==0 and dfs(v,adj):\\n                    return True\\n                elif stack[v]==1 and v!=u:\\n                    return True\\n            stack[u]=0\\n            return False\\n        # Search for positive cycle\\n        for i in range(n):\\n            if visited[i]==0 and dfs(i,adj1)==True:\\n                print(i)\\n                return True\\n        visited=[0]*n\\n        stack=[0]*n\\n         # Search for negative cycle\\n        for i in range(n):\\n            if visited[i]==0 and dfs(i,adj2)==True:\\n                print(i)\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        adj1=[[] for i in range(n)] # positive cycle\\n        adj2=[[] for i in range(n)] # negative cycle\\n        for i,j in enumerate(nums):\\n            if j>=0:\\n                adj1[i].append((i+j)%n)\\n            else:\\n                adj2[i].append((i+j)%n)\\n            \\n        visited=[0]*n\\n        stack=[0]*n\\n        def dfs(u,adj):\\n            visited[u]=1\\n            stack[u]=1\\n            for v in adj[u]:\\n                if visited[v]==0 and dfs(v,adj):\\n                    return True\\n                elif stack[v]==1 and v!=u:\\n                    return True\\n            stack[u]=0\\n            return False\\n        # Search for positive cycle\\n        for i in range(n):\\n            if visited[i]==0 and dfs(i,adj1)==True:\\n                print(i)\\n                return True\\n        visited=[0]*n\\n        stack=[0]*n\\n         # Search for negative cycle\\n        for i in range(n):\\n            if visited[i]==0 and dfs(i,adj2)==True:\\n                print(i)\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760161,
                "title": "c-o-n-time-beats-100-with-o-1-space-1-pointer",
                "content": "Cycle detection by marking cycles with 0 and nodes which cannot end up in cycles with 1002 (inf).\\nEvery no is passed only once and marked.\\n```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (isCycle(nums, i, -1, nums[i])) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool isCycle(vector<int>& nums, int start, int par, int dir) {\\n        if (hasNoCycle(nums, start)) {\\n            return false;\\n        }\\n\\n        if (par == start) {\\n            nums[start] = 1002;\\n            return false;\\n        }\\n        \\n        if (nums[start] == 0) {\\n            return true;\\n        }\\n        \\n        \\n        if (nums[start] * dir < 0) {\\n            return false;\\n        }\\n        \\n        int val = nums[start];\\n        int child = getChild(nums, start);\\n        nums[start] = 0;        \\n        \\n        if (isCycle(nums, child, start, val)) {\\n            return true;\\n        }\\n        \\n        nums[start] = 1002;\\n        return false;\\n    }\\n    \\n    int getChild(vector<int>& nums, int i) {\\n        return (nums[i] + i + nums.size()) % nums.size();\\n    }\\n    \\n    bool hasNoCycle(vector<int>& nums, int i) {\\n        return nums[i] == 1002;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (isCycle(nums, i, -1, nums[i])) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool isCycle(vector<int>& nums, int start, int par, int dir) {\\n        if (hasNoCycle(nums, start)) {\\n            return false;\\n        }\\n\\n        if (par == start) {\\n            nums[start] = 1002;\\n            return false;\\n        }\\n        \\n        if (nums[start] == 0) {\\n            return true;\\n        }\\n        \\n        \\n        if (nums[start] * dir < 0) {\\n            return false;\\n        }\\n        \\n        int val = nums[start];\\n        int child = getChild(nums, start);\\n        nums[start] = 0;        \\n        \\n        if (isCycle(nums, child, start, val)) {\\n            return true;\\n        }\\n        \\n        nums[start] = 1002;\\n        return false;\\n    }\\n    \\n    int getChild(vector<int>& nums, int i) {\\n        return (nums[i] + i + nums.size()) % nums.size();\\n    }\\n    \\n    bool hasNoCycle(vector<int>& nums, int i) {\\n        return nums[i] == 1002;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747950,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int next(vector<int> &nums,int idx){\\n        return (idx+nums[idx]+nums.size())%nums.size();\\n    }\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        for(auto &it:nums)\\n            it%=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            int slow=i,fast=i;\\n            while(nums[slow]*nums[next(nums,fast)]>0 and nums[slow]*nums[next(nums,next(nums,fast))]>0)\\n            {\\n                slow=next(nums,slow);\\n                fast=next(nums,next(nums,fast));\\n                if(slow==fast)\\n                {\\n                    if(slow==next(nums,slow))\\n                        break;\\n                    return true;\\n                }\\n            }\\n            int j=i;\\n            int val=nums[j];\\n            while(nums[j]*val>0)\\n            {\\n                int nexx=next(nums,j);\\n                nums[j]=0;\\n                j=nexx;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int next(vector<int> &nums,int idx){\\n        return (idx+nums[idx]+nums.size())%nums.size();\\n    }\\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n=nums.size();\\n        for(auto &it:nums)\\n            it%=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            int slow=i,fast=i;\\n            while(nums[slow]*nums[next(nums,fast)]>0 and nums[slow]*nums[next(nums,next(nums,fast))]>0)\\n            {\\n                slow=next(nums,slow);\\n                fast=next(nums,next(nums,fast));\\n                if(slow==fast)\\n                {\\n                    if(slow==next(nums,slow))\\n                        break;\\n                    return true;\\n                }\\n            }\\n            int j=i;\\n            int val=nums[j];\\n            while(nums[j]*val>0)\\n            {\\n                int nexx=next(nums,j);\\n                nums[j]=0;\\n                j=nexx;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746387,
                "title": "java-0ms-100",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int[] loop = new int[nums.length];\\n        int loopIndex = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int cur = i;\\n            if (loop[cur] == 0) {\\n                loop[cur] = loopIndex;\\n                while (true) {\\n                    int next = findNext(nums, cur);\\n                    if (cur == next || nums[next] * nums[cur] < 0) {\\n                        break;\\n                    }\\n                    if (loop[next] == loopIndex) {\\n                        return true;\\n                    }\\n                    loop[next] = loopIndex;\\n                    cur = next;\\n                }\\n                loopIndex++;   \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int findNext(int[] nums, int cur) {\\n        int next = cur + nums[cur];\\n        while (next < 0) {\\n            next += nums.length;\\n        }\\n        return next % nums.length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int[] loop = new int[nums.length];\\n        int loopIndex = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int cur = i;\\n            if (loop[cur] == 0) {\\n                loop[cur] = loopIndex;\\n                while (true) {\\n                    int next = findNext(nums, cur);\\n                    if (cur == next || nums[next] * nums[cur] < 0) {\\n                        break;\\n                    }\\n                    if (loop[next] == loopIndex) {\\n                        return true;\\n                    }\\n                    loop[next] = loopIndex;\\n                    cur = next;\\n                }\\n                loopIndex++;   \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int findNext(int[] nums, int cur) {\\n        int next = cur + nums[cur];\\n        while (next < 0) {\\n            next += nums.length;\\n        }\\n        return next % nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740982,
                "title": "1-1-2-4-4-should-be-false",
                "content": "[1,-1,2,4,4] has a cycle from index 0,1, both direction, should be false. Why \"expected value\" is true?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 718915,
                "title": "c-easy-to-understand-44ms-slow-and-fast",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    int get_next(vector<int>&nums,int ind,bool flag){\\n        int n=nums.size();\\n        \\n        bool dir=nums[ind]>0;\\n        \\n        if(flag!=dir)\\n            return -1;\\n        \\n        int next_ind=(ind+nums[ind])%n;\\n        \\n        if(next_ind<0)\\n            next_ind+=n;\\n        if(next_ind==ind)\\n            return -1;\\n        \\n        return next_ind;\\n    }\\n    \\n    \\n    \\n    \\n    bool circularArrayLoop(vector<int>& nums) {\\n        if(nums.size()<=1)\\n            return false;\\n        \\n        for(int i=0;i<nums.size();i++){\\n                \\n            bool flag=nums[i]>0;\\n            int slow=i,fast=i;            \\n            while(true){   \\n                slow=get_next(nums,slow,flag);\\n                if(slow==-1)\\n                    break;\\n                fast=get_next(nums,fast,flag);\\n                if(fast==-1)\\n                    break;\\n                fast=get_next(nums,fast,flag);\\n                if(fast==-1)\\n                    break;\\n                \\n                if(slow==fast)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int get_next(vector<int>&nums,int ind,bool flag){\\n        int n=nums.size();\\n        \\n        bool dir=nums[ind]>0;\\n        \\n        if(flag!=dir)\\n            return -1;\\n        \\n        int next_ind=(ind+nums[ind])%n;\\n        \\n        if(next_ind<0)\\n            next_ind+=n;\\n        if(next_ind==ind)\\n            return -1;\\n        \\n        return next_ind;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 682407,
                "title": "two-soln-1-o-n-space-and-time-2-o-1-space-and-o-n-2-time",
                "content": "1. This code uses ```O(n)``` extra space as it uses visited array so that we visit every node only once. Time Complexity for this code is ```O(n)```. Runtime for time algorithm is **0ms.**\\n```\\nclass Solution {\\npublic:\\n    int get(int i, vector<int>& nums){\\n        int n = nums.size();\\n        return nums[i] < 0 ?  (i+n-abs(nums[i])%n)%n : (i+nums[i]%n)%n;\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size(), v=1,k,sign=-1;\\n        if(n<2) return false;\\n        vector<int> visited(n,0);\\n        for(int i=0;i<n;i++){\\n            if(visited[i]) continue;\\n            if(get(i,nums)==i){visited[i] = v++; continue;}\\n            k = i;\\n            sign = nums[k] > 0 ? 1 : -1;\\n            while(get(k,nums)!=k){\\n                if(sign*nums[k] < 0) break;\\n                visited[k]=v;\\n                k = get(k,nums);\\n                if(visited[k]==v) return true;\\n            }\\n            v++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n2. This code uses ```O(1)``` space and detects the cycle using two race pointers. But this can take at wost case ```O(n^2)``` time. I checked many codes using the same approach but saying ```O(n)``` time.\\nConsider this example: ```0->1->2->3->4->5->6```. In this case we will start from every node and reach till end which will eventually take our time complexity to ```O(n^2)```. Runtime for this algorithm is **96ms.**\\n```\\nclass Solution {\\npublic:\\n    int get(int i, vector<int>& nums){\\n        int n = nums.size();\\n        return nums[i] < 0 ? (i+n-abs(nums[i])%n)%n : (i+nums[i]%n)%n;\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size(), v=1, slow, fast, sign=-1;\\n        if(n<2) return false;\\n        for(int i=0;i<n;i++){\\n            if(get(i,nums)==i) continue;\\n            slow = i, fast = get(i,nums);\\n            while(nums[i]*nums[fast] > 0 && nums[i]*nums[get(fast,nums)] > 0){\\n                if(fast == get(fast,nums)) break;\\n                if(slow == fast) return true;\\n                slow = get(slow,nums);\\n                fast = get(get(fast,nums),nums);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nAny feedback on my understanding for the complexity analysis will be valuable.",
                "solutionTags": [
                    "C"
                ],
                "code": "```O(n)```\n```O(n)```\n```\\nclass Solution {\\npublic:\\n    int get(int i, vector<int>& nums){\\n        int n = nums.size();\\n        return nums[i] < 0 ?  (i+n-abs(nums[i])%n)%n : (i+nums[i]%n)%n;\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size(), v=1,k,sign=-1;\\n        if(n<2) return false;\\n        vector<int> visited(n,0);\\n        for(int i=0;i<n;i++){\\n            if(visited[i]) continue;\\n            if(get(i,nums)==i){visited[i] = v++; continue;}\\n            k = i;\\n            sign = nums[k] > 0 ? 1 : -1;\\n            while(get(k,nums)!=k){\\n                if(sign*nums[k] < 0) break;\\n                visited[k]=v;\\n                k = get(k,nums);\\n                if(visited[k]==v) return true;\\n            }\\n            v++;\\n        }\\n        return false;\\n    }\\n};\\n```\n```O(1)```\n```O(n^2)```\n```O(n)```\n```0->1->2->3->4->5->6```\n```O(n^2)```\n```\\nclass Solution {\\npublic:\\n    int get(int i, vector<int>& nums){\\n        int n = nums.size();\\n        return nums[i] < 0 ? (i+n-abs(nums[i])%n)%n : (i+nums[i]%n)%n;\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size(), v=1, slow, fast, sign=-1;\\n        if(n<2) return false;\\n        for(int i=0;i<n;i++){\\n            if(get(i,nums)==i) continue;\\n            slow = i, fast = get(i,nums);\\n            while(nums[i]*nums[fast] > 0 && nums[i]*nums[get(fast,nums)] > 0){\\n                if(fast == get(fast,nums)) break;\\n                if(slow == fast) return true;\\n                slow = get(slow,nums);\\n                fast = get(get(fast,nums),nums);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672878,
                "title": "simplified-java-solution",
                "content": "```\\n    public boolean circularArrayLoop(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) continue;\\n            int dir = nums[i] > 0 ? 1 : -1;\\n            int move = nums[i];\\n            int rnd = 0;\\n            while (rnd < n) {\\n                int p = (move + i) % n;\\n                if (move + i < 0) p = (n + p) % n;\\n                if (dir * nums[p] <= 0) break;\\n                if (p == i && rnd > 0) return true;\\n                else if (p == i) break;\\n                move += nums[p];\\n                rnd++;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public boolean circularArrayLoop(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) continue;\\n            int dir = nums[i] > 0 ? 1 : -1;\\n            int move = nums[i];\\n            int rnd = 0;\\n            while (rnd < n) {\\n                int p = (move + i) % n;\\n                if (move + i < 0) p = (n + p) % n;\\n                if (dir * nums[p] <= 0) break;\\n                if (p == i && rnd > 0) return true;\\n                else if (p == i) break;\\n                move += nums[p];\\n                rnd++;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 649347,
                "title": "java-dfs-beats-100-runtime",
                "content": "Using a visited array to keep track of the state of traversal. Initially all `0`. `-1` means currently in the traversal path; `1` means already traversed in previous pass. A boolean flag `forward` to note the direction.\\n```\\nclass Solution {\\n    \\n    private int[] visited;\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        visited = new int[nums.length];\\n        int count = 0;\\n        for (int i = 0; i< nums.length; i++) {\\n            if (visited[i] == 0 && dfs(nums, i, nums[i] > 0)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // returns true if cycle is found\\n    private boolean dfs(int[] nums, int i, boolean forward) {\\n        if (visited[i] == -1) {\\n            return true;\\n        } else if (visited[i] == 1) {\\n            return false;\\n        } else if ((nums[i] > 0) ^ forward) {\\n            return false;\\n        }\\n        int next = Math.floorMod(nums[i] + i, nums.length);\\n        if (next == i) {\\n            return false;\\n        }\\n        visited[i] = -1;\\n        boolean res = dfs(nums, next, forward);\\n        visited[i] = 1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int[] visited;\\n    \\n    public boolean circularArrayLoop(int[] nums) {\\n        visited = new int[nums.length];\\n        int count = 0;\\n        for (int i = 0; i< nums.length; i++) {\\n            if (visited[i] == 0 && dfs(nums, i, nums[i] > 0)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // returns true if cycle is found\\n    private boolean dfs(int[] nums, int i, boolean forward) {\\n        if (visited[i] == -1) {\\n            return true;\\n        } else if (visited[i] == 1) {\\n            return false;\\n        } else if ((nums[i] > 0) ^ forward) {\\n            return false;\\n        }\\n        int next = Math.floorMod(nums[i] + i, nums.length);\\n        if (next == i) {\\n            return false;\\n        }\\n        visited[i] = -1;\\n        boolean res = dfs(nums, next, forward);\\n        visited[i] = 1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565217,
                "title": "well-commented-code-in-c-100-space-complexity-and-100-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    //to take care of modulo operator when number is negative\\n    int mod(int n, int m){\\n        return (m+n%m)%m;\\n    }\\n    //function for detecting cycle in directed graph\\n    bool cycle(int v, vector<vector<int> > &graph, vector<bool> &vis, vector<bool> &isdfs){\\n        vis[v]=1;\\n        isdfs[v]=1;\\n        for(int j=0;j<graph[v].size();j++){\\n            //detected cycle shouldn\\'t be a self loop\\n            if(isdfs[graph[v][j]]==1&&v!=graph[v][j]){\\n                return 1;\\n            }\\n            if(vis[graph[v][j]]==0){\\n                if(cycle(graph[v][j],graph,vis,isdfs)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        isdfs[v]=0;\\n        return 0;\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        vector<vector<int> > graph(nums.size());\\n        //construct graph of indices\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[mod((i+nums[i]),nums.size())]*nums[i]>0){\\n                graph[i].push_back(mod((i+nums[i]),nums.size()));\\n            }\\n        }\\n        vector<bool> vis(nums.size()),isdfs(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            vis[i]=0;\\n            isdfs[i]=0;\\n        }\\n        //run loop to check if loop exists starting from any node\\n        for(int i=0;i<nums.size();i++){\\n            if(vis[i]==0){\\n                if(cycle(i,graph,vis,isdfs)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //to take care of modulo operator when number is negative\\n    int mod(int n, int m){\\n        return (m+n%m)%m;\\n    }\\n    //function for detecting cycle in directed graph\\n    bool cycle(int v, vector<vector<int> > &graph, vector<bool> &vis, vector<bool> &isdfs){\\n        vis[v]=1;\\n        isdfs[v]=1;\\n        for(int j=0;j<graph[v].size();j++){\\n            //detected cycle shouldn\\'t be a self loop\\n            if(isdfs[graph[v][j]]==1&&v!=graph[v][j]){\\n                return 1;\\n            }\\n            if(vis[graph[v][j]]==0){\\n                if(cycle(graph[v][j],graph,vis,isdfs)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        isdfs[v]=0;\\n        return 0;\\n    }\\n    bool circularArrayLoop(vector<int>& nums) {\\n        vector<vector<int> > graph(nums.size());\\n        //construct graph of indices\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[mod((i+nums[i]),nums.size())]*nums[i]>0){\\n                graph[i].push_back(mod((i+nums[i]),nums.size()));\\n            }\\n        }\\n        vector<bool> vis(nums.size()),isdfs(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            vis[i]=0;\\n            isdfs[i]=0;\\n        }\\n        //run loop to check if loop exists starting from any node\\n        for(int i=0;i<nums.size();i++){\\n            if(vis[i]==0){\\n                if(cycle(i,graph,vis,isdfs)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517368,
                "title": "3-1-2-is-true-why",
                "content": "why [3,1,2] is showing true ??? It should be false as arr[0] is 3 and if we move forward 3 steps again we come to 0th index i.e 3 . The rotating length is 1 , so it should give false but it is giving true ???",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 516091,
                "title": "concise-python-slow-faster-pointers-o-n",
                "content": "O(n) time and space.\\nO(1) space if modifying the input list.\\n\\n```\\n    def circularArrayLoop(self, nums: List[int]) -> bool:    \\n        seen = set()\\n        N = len(nums)\\n  \\n        def getNxt(p):\\n            return (p+nums[p])%N\\n            \\n        for i in range(N):\\n            if i in seen: #avoid revisiting\\n                continue\\n            s = f = i #slow and fast pointers\\n            while True:\\n                s = getNxt(s)\\n                temp = getNxt(f)\\n                if f==temp or (nums[f]>0)!=(nums[temp]>0): #length==1 or direction change\\n                    break\\n                f = getNxt(temp)\\n                if f==temp or (nums[f]>0)!=(nums[temp]>0):\\n                    break\\n                if s==f:\\n                    return True  \\n                seen.add(temp)\\n                seen.add(f)\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def circularArrayLoop(self, nums: List[int]) -> bool:    \\n        seen = set()\\n        N = len(nums)\\n  \\n        def getNxt(p):\\n            return (p+nums[p])%N\\n            \\n        for i in range(N):\\n            if i in seen: #avoid revisiting\\n                continue\\n            s = f = i #slow and fast pointers\\n            while True:\\n                s = getNxt(s)\\n                temp = getNxt(f)\\n                if f==temp or (nums[f]>0)!=(nums[temp]>0): #length==1 or direction change\\n                    break\\n                f = getNxt(temp)\\n                if f==temp or (nums[f]>0)!=(nums[temp]>0):\\n                    break\\n                if s==f:\\n                    return True  \\n                seen.add(temp)\\n                seen.add(f)\\n        return False\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 513490,
                "title": "c-dfs-0ms-beats-100",
                "content": "We apply dfs to search the directed graph formulated by `nums` , and our goal is to find a legal circle.\\nA circle is legal iff length > 1 and movements are all backward or forward.\\nSo in my solution, I add a property to dfs operation: `forward` or `backward`. If we find `nums[i]<0` in a forward dfs or `nums[i]>0` in a backward dfs, just abort it because this potential circle won\\'t be legal. And to prevent finding a circle of length 1, we abort the case where `next==i`.\\n```cpp\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        enum {WHITE = 0, GREY, BLACK};\\n        vector<int> visited(n, WHITE);\\n        bool res = false;\\n        function<void(int, bool)> dfs = [&](int i, bool forward) {\\n            if ((forward && nums[i] < 0) || (!forward && nums[i] > 0)) return;\\n            if (visited[i] == GREY) {\\n                res = true;\\n            }\\n            if (visited[i] != WHITE) return;\\n            visited[i] = GREY;\\n            int next = (i+nums[i]) % n;\\n            next = next < 0 ? next + n : next;\\n            if (next != i) dfs(next, forward);\\n            visited[i] = BLACK;\\n        };\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == WHITE) dfs(i, nums[i] > 0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        enum {WHITE = 0, GREY, BLACK};\\n        vector<int> visited(n, WHITE);\\n        bool res = false;\\n        function<void(int, bool)> dfs = [&](int i, bool forward) {\\n            if ((forward && nums[i] < 0) || (!forward && nums[i] > 0)) return;\\n            if (visited[i] == GREY) {\\n                res = true;\\n            }\\n            if (visited[i] != WHITE) return;\\n            visited[i] = GREY;\\n            int next = (i+nums[i]) % n;\\n            next = next < 0 ? next + n : next;\\n            if (next != i) dfs(next, forward);\\n            visited[i] = BLACK;\\n        };\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == WHITE) dfs(i, nums[i] > 0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460345,
                "title": "beats-100-java-with-circular-loops-and-explanation",
                "content": "You can think of the problem as finding circular loop in a directed graph. Use dfs for the same. When performing dfs, you see the direction of the flow changing, your traversal is broken. \\n\\nDo dfs traversal in either direction whenever you encounter an unvisited index. \\n\\nTime Complexity is O(n) as each node is only visited once. Space complexity is O(n);\\n\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        boolean[] visited = new boolean[nums.length];\\n        boolean[] recStack = new boolean[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            if(!visited[i]) {\\n                if(dfs(nums, visited, recStack, nums[i] > 0 ? 1 : -1, i, -1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(int[]nums, boolean[] visited, boolean[] recStack, int flag, int i, int parent) {\\n         if(recStack[i] && i!=parent) return true;\\n                \\n         if(visited[i]) return false;\\n        \\n         if((nums[i] < 0 && flag > 0) || (nums[i] > 0 && flag < 0)) {\\n            return false;    \\n        }\\n        \\n        visited[i] = true;\\n\\n        recStack[i] = true;\\n        \\n        if(dfs(nums, visited, recStack, flag, get(i, nums, nums[i]), i)) {\\n            return true;   \\n        }\\n        \\n        recStack[i] = false;\\n        \\n        return false;\\n    }\\n    \\n    private int get(int i, int[] nums, int k) {\\n        if(i+k >= 0 && i+k <= nums.length-1) return i+k;\\n        \\n        if((i+k)%nums.length >= 0) {\\n            return (i+k)%nums.length;\\n        }\\n        \\n        if((i+k)%nums.length < 0) {\\n            return nums.length + ((i+k)%nums.length);\\n        }\\n        \\n        if((i+k)%nums.length==0) {\\n            return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        boolean[] visited = new boolean[nums.length];\\n        boolean[] recStack = new boolean[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            if(!visited[i]) {\\n                if(dfs(nums, visited, recStack, nums[i] > 0 ? 1 : -1, i, -1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean dfs(int[]nums, boolean[] visited, boolean[] recStack, int flag, int i, int parent) {\\n         if(recStack[i] && i!=parent) return true;\\n                \\n         if(visited[i]) return false;\\n        \\n         if((nums[i] < 0 && flag > 0) || (nums[i] > 0 && flag < 0)) {\\n            return false;    \\n        }\\n        \\n        visited[i] = true;\\n\\n        recStack[i] = true;\\n        \\n        if(dfs(nums, visited, recStack, flag, get(i, nums, nums[i]), i)) {\\n            return true;   \\n        }\\n        \\n        recStack[i] = false;\\n        \\n        return false;\\n    }\\n    \\n    private int get(int i, int[] nums, int k) {\\n        if(i+k >= 0 && i+k <= nums.length-1) return i+k;\\n        \\n        if((i+k)%nums.length >= 0) {\\n            return (i+k)%nums.length;\\n        }\\n        \\n        if((i+k)%nums.length < 0) {\\n            return nums.length + ((i+k)%nums.length);\\n        }\\n        \\n        if((i+k)%nums.length==0) {\\n            return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377151,
                "title": "python-solution-with-o-n-time-and-o-1-space-beat-95-in-time-100-in-memory",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i, num in enumerate(nums):\\n            pos = i\\n            n = num\\n            ind = True\\n            pm = n / abs(n)\\n            \\n            if (abs(n) < 1) or (n % len(nums) == 0):\\n                continue\\n                \\n            nums[pos] = (i + 1) / 10000.0 * pm\\n            \\n            while abs(n - (i + 1) / 10000.0 * pm) > 10e-10:\\n                pos += n\\n                pos = pos % len(nums)\\n                n = nums[pos]\\n                   \\n                if (n % len(nums) == 0) or (n * pm < 0) or (10e-10 < abs(n - (i + 1) / 10000.0 * pm) < 0.6):\\n                    ind = False\\n                    break\\n                    \\n                nums[pos] = (i + 1) / 10000.0 * pm\\n            \\n            if ind:\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        for i, num in enumerate(nums):\\n            pos = i\\n            n = num\\n            ind = True\\n            pm = n / abs(n)\\n            \\n            if (abs(n) < 1) or (n % len(nums) == 0):\\n                continue\\n                \\n            nums[pos] = (i + 1) / 10000.0 * pm\\n            \\n            while abs(n - (i + 1) / 10000.0 * pm) > 10e-10:\\n                pos += n\\n                pos = pos % len(nums)\\n                n = nums[pos]\\n                   \\n                if (n % len(nums) == 0) or (n * pm < 0) or (10e-10 < abs(n - (i + 1) / 10000.0 * pm) < 0.6):\\n                    ind = False\\n                    break\\n                    \\n                nums[pos] = (i + 1) / 10000.0 * pm\\n            \\n            if ind:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373866,
                "title": "java-solution-beats-100-and-not-using-two-pointers",
                "content": "Since it\\'s not stated that we can\\'t modify input array, we could hack it using input array space.\\nMain idea is simple, for each number,  if it\\'s processed, skip, if not, traverse its **one-way line** untill either hits **older** line or hits **current** line. If hits current line and **circle length** is greater than 1, we find the desired circle and exit.\\nSo we need to memorize line **epoch** and current **position** in the line when following a line and make sure the line goes one-way.\\nWe process each number by set it to a control number `ctl` in the form of EPOCH + POS,  which EPOCH in its high 16 bits, and POS in its low 16 bits.\\n```java\\nclass Solution {\\n    // use num[i]\\'s high 16 bits for epoch, so we shift all number to positive\\n\\t// in case negtive number\\'s distraction.\\n    private static final int  SHIFT = 5000;\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i=0; i<nums.length; i++) nums[i]+=SHIFT;\\n        int epoch = 1;\\n        for(int i=0; i<nums.length; i++) {\\n\\t\\t    // set position in line to 0 for each traverse\\n            int pos = 0;\\n            int p = i;\\n            boolean right = nums[p]>SHIFT;\\n            while(true){\\n\\t\\t\\t   // if we don\\'t shift, negative numbers high 16 bits would break our routine.\\n                int cp = nums[p]>>16;\\n                if(cp==0) {\\n                    // unprocessed\\n\\t\\t\\t\\t\\t// wrong direction\\n                    if(right && nums[p]<SHIFT || !right && nums[p]>SHIFT) break;\\n                    // compute where to go next\\n\\t\\t\\t\\t\\tint next = ((nums[p]-SHIFT) + p) % nums.length;\\n                    next = next >=0 ? next : next + nums.length;\\n\\t\\t\\t\\t\\t// mark as processed\\n                    nums[p] = (epoch<<16) + pos++;\\n\\t\\t\\t\\t\\t// go next\\n                    p = next;\\n                } else if(cp<epoch){\\n                    // older epoch\\n                    break;\\n                } else {\\n                    // current epoch\\n\\t\\t\\t\\t\\t// if current position in line - previous position in line > 1\\n\\t\\t\\t\\t\\t// we assure that circle length > 1\\n                    if(pos-(nums[p]&0x0000FFFF)>1) return true;\\n                    else break;\\n                }\\n            }\\n\\n            epoch++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    // use num[i]\\'s high 16 bits for epoch, so we shift all number to positive\\n\\t// in case negtive number\\'s distraction.\\n    private static final int  SHIFT = 5000;\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i=0; i<nums.length; i++) nums[i]+=SHIFT;\\n        int epoch = 1;\\n        for(int i=0; i<nums.length; i++) {\\n\\t\\t    // set position in line to 0 for each traverse\\n            int pos = 0;\\n            int p = i;\\n            boolean right = nums[p]>SHIFT;\\n            while(true){\\n\\t\\t\\t   // if we don\\'t shift, negative numbers high 16 bits would break our routine.\\n                int cp = nums[p]>>16;\\n                if(cp==0) {\\n                    // unprocessed\\n\\t\\t\\t\\t\\t// wrong direction\\n                    if(right && nums[p]<SHIFT || !right && nums[p]>SHIFT) break;\\n                    // compute where to go next\\n\\t\\t\\t\\t\\tint next = ((nums[p]-SHIFT) + p) % nums.length;\\n                    next = next >=0 ? next : next + nums.length;\\n\\t\\t\\t\\t\\t// mark as processed\\n                    nums[p] = (epoch<<16) + pos++;\\n\\t\\t\\t\\t\\t// go next\\n                    p = next;\\n                } else if(cp<epoch){\\n                    // older epoch\\n                    break;\\n                } else {\\n                    // current epoch\\n\\t\\t\\t\\t\\t// if current position in line - previous position in line > 1\\n\\t\\t\\t\\t\\t// we assure that circle length > 1\\n                    if(pos-(nums[p]&0x0000FFFF)>1) return true;\\n                    else break;\\n                }\\n            }\\n\\n            epoch++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325806,
                "title": "c-time-o-n-space-o-1-solution-no-use-fast-slower-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int MAXN = 2000;\\n        int n = nums.size();\\n        int round = 0;\\n        for(int i = 0; i < n; i ++){\\n            round ++;\\n            if(nums[i] > 1000) continue;\\n            int now = ((i+nums[i])%n+n)%n;\\n            if( now == i){\\n                continue;\\n            }\\n            cout << i << \" \" << now << \" \";\\n            while(nums[now] <= 1000 && nums[i] * nums[now] > 0){\\n                int tmp = nums[now];\\n                while(tmp > 1000){\\n                    tmp -= 2000;\\n                }\\n                int pre = now;\\n                nums[now] += round * MAXN;\\n                now = (((now + tmp)%n)+n)%n;\\n                cout << now << \" \";\\n                if(now == pre){\\n                    break;\\n                }\\n                if(now == i){\\n                    return true;\\n                }\\n                if(nums[now] > 1000){\\n                    tmp = nums[now];\\n                    int r = 0;\\n                    while(tmp > 1000){\\n                        r ++ ;\\n                        tmp -= 2000;\\n                    }\\n                    if(round == r){\\n                        return true;\\n                    }\\n                }\\n                \\n            }\\n            nums[i] += MAXN;\\n            cout << endl;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int MAXN = 2000;\\n        int n = nums.size();\\n        int round = 0;\\n        for(int i = 0; i < n; i ++){\\n            round ++;\\n            if(nums[i] > 1000) continue;\\n            int now = ((i+nums[i])%n+n)%n;\\n            if( now == i){\\n                continue;\\n            }\\n            cout << i << \" \" << now << \" \";\\n            while(nums[now] <= 1000 && nums[i] * nums[now] > 0){\\n                int tmp = nums[now];\\n                while(tmp > 1000){\\n                    tmp -= 2000;\\n                }\\n                int pre = now;\\n                nums[now] += round * MAXN;\\n                now = (((now + tmp)%n)+n)%n;\\n                cout << now << \" \";\\n                if(now == pre){\\n                    break;\\n                }\\n                if(now == i){\\n                    return true;\\n                }\\n                if(nums[now] > 1000){\\n                    tmp = nums[now];\\n                    int r = 0;\\n                    while(tmp > 1000){\\n                        r ++ ;\\n                        tmp -= 2000;\\n                    }\\n                    if(round == r){\\n                        return true;\\n                    }\\n                }\\n                \\n            }\\n            nums[i] += MAXN;\\n            cout << endl;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 321862,
                "title": "python3-dfs-beats-97",
                "content": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        colors = [0] * len(nums)\\n        def dfs(i, direction = 0):\\n            if colors[i] < 0: return False\\n            colors[i] = 1 # in-exploration\\n            ni = i + nums[i] + len(nums)\\n            while ni < 0:\\n                ni += len(nums)\\n            ni = ni % len(nums)\\n            next_dir = 1 if nums[ni] > 0 else -1\\n            ans = True\\n            if direction!= 0 and next_dir != direction:\\n                ans = False\\n            elif i == ni:\\n                ans = False\\n            elif colors[ni] == 1:\\n                ans = True\\n            else:\\n                ans = dfs(ni, next_dir)\\n            if not ans: colors[i] = -1\\n            return ans\\n        \\n        return any(dfs(i) for i in range(len(nums)))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def circularArrayLoop(self, nums: List[int]) -> bool:\\n        colors = [0] * len(nums)\\n        def dfs(i, direction = 0):\\n            if colors[i] < 0: return False\\n            colors[i] = 1 # in-exploration\\n            ni = i + nums[i] + len(nums)\\n            while ni < 0:\\n                ni += len(nums)\\n            ni = ni % len(nums)\\n            next_dir = 1 if nums[ni] > 0 else -1\\n            ans = True\\n            if direction!= 0 and next_dir != direction:\\n                ans = False\\n            elif i == ni:\\n                ans = False\\n            elif colors[ni] == 1:\\n                ans = True\\n            else:\\n                ans = dfs(ni, next_dir)\\n            if not ans: colors[i] = -1\\n            return ans\\n        \\n        return any(dfs(i) for i in range(len(nums)))",
                "codeTag": "Java"
            },
            {
                "id": 295133,
                "title": "java-solution-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i = 0; i < nums.length; ++i){\\n            int cur = i, count = 0, dir = 0, prev = i; \\n            while(nums[cur] <= 1000){  \\n                prev = cur; \\n                int t = (cur + nums[cur])%nums.length;\\n                if(nums[cur] < 0){\\n                    cur = t < 0 ? (nums.length + t) : t;\\n                    dir = (dir == 0 || dir == 1) ? 1 : 3;\\n                }else{\\n                    cur = t;\\n                    dir = (dir == 0 || dir == 2) ? 2 : 3;\\n                } \\n                if(dir == 3) break; \\n                nums[prev]  = 1001 + i; \\n                if(cur == prev) break; \\n            } \\n            if(prev != cur && nums[cur] == (1001 + i) && dir != 3) return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        for(int i = 0; i < nums.length; ++i){\\n            int cur = i, count = 0, dir = 0, prev = i; \\n            while(nums[cur] <= 1000){  \\n                prev = cur; \\n                int t = (cur + nums[cur])%nums.length;\\n                if(nums[cur] < 0){\\n                    cur = t < 0 ? (nums.length + t) : t;\\n                    dir = (dir == 0 || dir == 1) ? 1 : 3;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 219831,
                "title": "java-beats-98-00-solutions-runtime-1ms-o-1-space-complexity-easy-to-understand",
                "content": "```class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        if(nums.length == 0) return false; \\n        int len = nums.length;\\n        boolean forward; \\n        int step = (len + 0 + nums[0])%len;\\n\\t\\tif(nums[0] > 0) forward = true; //assign direction of traversal \\n        else forward = false; \\n        int newstep = 0;\\n        while(true) {\\n            if(step == 0) return true; \\n            else if(nums[step] == 0) return false;\\n            newstep = (len + step + nums[step])%len;  //calculate next step \\n            if(nums[step] < 0 && forward == true) return false; \\n            else if(nums[step] > 0 && forward == false) return false; \\n            nums[step] = 0; //marked visited\\n            step = newstep;  //get next step \\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        if(nums.length == 0) return false; \\n        int len = nums.length;\\n        boolean forward; \\n        int step = (len + 0 + nums[0])%len;\\n\\t\\tif(nums[0] > 0) forward = true; //assign direction of traversal \\n        else forward = false; \\n        int newstep = 0;\\n        while(true) {\\n            if(step == 0) return true; \\n            else if(nums[step] == 0) return false;\\n            newstep = (len + step + nums[step])%len;  //calculate next step \\n            if(nums[step] < 0 && forward == true) return false; \\n            else if(nums[step] > 0 && forward == false) return false; \\n            nums[step] = 0; //marked visited\\n            step = newstep;  //get next step \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 217610,
                "title": "who-believes-that-these-simple-code-is-accepted",
                "content": "Is there some problem about the tests? The following simple code even passed all the tests...\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int sum = 0;\\n        for (int i : nums) {\\n            sum += i;\\n        }\\n        \\n        return sum > nums.length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int sum = 0;\\n        for (int i : nums) {\\n            sum += i;\\n        }\\n        \\n        return sum > nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208656,
                "title": "java-o-n-time-o-1-space-solution-track-loop-by-coloring-explanation-included",
                "content": "First, go through the list to take the residue of each value. For example, if the `length = 6`, `-8 -> -2`, `7 -> 1`. This won\\'t change the jump behavior, but can limit each element so that `nums[i] < nums.length`.\\n\\nThen, check each element. When checking the current node `i`, we would color all the visited nodes along the way with `nums.length + i` so that we can identify the loop when we revisited a node with the same color `nums.length + i`.\\n\\nIf we encounter a node with value `nums[i] >= n` but the color is different than the current one, it means the rest of nodes in this chain wouldn\\'t lead to a loop, since it is verified in a previous check.\\n\\nIn addition, if a node\\'s next step is itself, it is not considered as a loop, and it will be an end to a chain.\\n\\n```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums[i] % n;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] >= n) continue;\\n            if (checkLoop(nums, i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean checkLoop(int[] nums, int index) {\\n        int n = nums.length;\\n        boolean forward = (nums[index] > 0);\\n        int ptr = index;\\n        while ((nums[ptr] > 0) == forward && nums[ptr] < n) {\\n            int next = Math.floorMod(ptr + nums[ptr], n);\\n            nums[ptr] = n + index;\\n            if (ptr == next) {\\n                return false;\\n            } else {\\n                ptr = next;\\n            }\\n        }\\n        return nums[ptr] == n + index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums[i] % n;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] >= n) continue;\\n            if (checkLoop(nums, i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean checkLoop(int[] nums, int index) {\\n        int n = nums.length;\\n        boolean forward = (nums[index] > 0);\\n        int ptr = index;\\n        while ((nums[ptr] > 0) == forward && nums[ptr] < n) {\\n            int next = Math.floorMod(ptr + nums[ptr], n);\\n            nums[ptr] = n + index;\\n            if (ptr == next) {\\n                return false;\\n            } else {\\n                ptr = next;\\n            }\\n        }\\n        return nums[ptr] == n + index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197457,
                "title": "java-dfs-solution-beats-100",
                "content": "```\\n public boolean circularArrayLoop(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return false;\\n        }\\n        //0: not visited, 1: visiting, 2:no loop\\n        int[] states = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            boolean res = hasLoop(nums, states, i, nums[i] > 0);\\n            if (res) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean hasLoop(int[] nums, int[] states, int index, boolean direction) {\\n        boolean curDirection = nums[index] >0;\\n        if (curDirection != direction) {\\n            nums[index] = 2;\\n            return false;\\n        }\\n\\n        if (states[index] == 2) {\\n            return false;\\n        }\\n        if (states[index] == 1) {\\n            return true;\\n        }\\n        int n = nums.length;\\n        int nextIndex = (index + nums[index] + n) % n;\\n        if (nextIndex == index) {\\n            states[index] = 2;\\n            return false;\\n        }\\n        states[index] = 1;\\n        boolean res = hasLoop(nums, states, nextIndex, direction);\\n        if (res) {\\n            return true;\\n        }\\n        states[index] = 2;\\n        return false;\\n\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n public boolean circularArrayLoop(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return false;\\n        }\\n        //0: not visited, 1: visiting, 2:no loop\\n        int[] states = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            boolean res = hasLoop(nums, states, i, nums[i] > 0);\\n            if (res) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean hasLoop(int[] nums, int[] states, int index, boolean direction) {\\n        boolean curDirection = nums[index] >0;\\n        if (curDirection != direction) {\\n            nums[index] = 2;\\n            return false;\\n        }\\n\\n        if (states[index] == 2) {\\n            return false;\\n        }\\n        if (states[index] == 1) {\\n            return true;\\n        }\\n        int n = nums.length;\\n        int nextIndex = (index + nums[index] + n) % n;\\n        if (nextIndex == index) {\\n            states[index] = 2;\\n            return false;\\n        }\\n        states[index] = 1;\\n        boolean res = hasLoop(nums, states, nextIndex, direction);\\n        if (res) {\\n            return true;\\n        }\\n        states[index] = 2;\\n        return false;\\n\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 195992,
                "title": "straight-forward-java-beats-100",
                "content": "I really don\\'t like the description of the problem.  The thing about \"forward\" or \"backward\", with them including the pointless scare quotes, does not make clear what they really want.  And since it\\'s supposed to be circular, forward versus backward is meaningless.\\n\\nMy first code was shorter/cleaner, and used O(1) extra space, but it found (as I feel it should) all the loops.  So here\\'s my version to reject perfectly nice loops and only find \"forward\" or \"backward\" loops.  I do use O(n) extra space for this version.\\n```\\n    public boolean circularArrayLoop(int[] nums) {\\n        int[] posNums = new int[nums.length];\\n        int[] negNums = new int[nums.length];\\n\\n        // normalize to 0..+-nums.length-1\\n        for( int i=0; i<nums.length; i++ ) {\\n            posNums[i] = (nums[i]<0) ? 0 : nums[i]%nums.length;\\n            negNums[i] = (nums[i]<0) ? nums[i]%nums.length : 0;\\n        } \\n        \\n        // find any \"forward\" loop\\n        for( int i=0; i<nums.length; i++ ) {\\n            int j=i;\\n            \\n            while( posNums[j]>0 ) {\\n                int temp = j;\\n                j=(j+posNums[j])%nums.length;\\n                posNums[temp]= -i-1;\\n            }\\n            \\n            if( posNums[j] == -i-1 ) return true;\\n        }\\n\\n        // find any \"backward\" loop\\n        for( int i=0; i<nums.length; i++ ) {\\n            int j=i;\\n            \\n            while( negNums[j]<0 ) {\\n                int temp = j;\\n                j=(j+negNums[j])%nums.length;\\n                if( j<0 ) j+=nums.length;\\n                negNums[temp]= i+1;\\n            }\\n            \\n            if( negNums[j] == i+1 ) return true;\\n        }\\n        \\n        return false;\\n    }\\n```\\nThe cleaner version, to find all the loops, is here:\\n```\\n    public boolean circularArrayLoop(int[] nums) {\\n        // normalize to 0..nums.length-1\\n        for( int i=0; i<nums.length; i++ ) nums[i] = (nums[i]<0) ? nums[i]%nums.length+nums.length : nums[i]%nums.length;\\n        \\n        for( int i=0; i<nums.length; i++ ) {\\n            int j=i;\\n            \\n            while( nums[j]>0 ) {\\n                int temp = j;\\n                j=(j+nums[j])%nums.length;\\n                nums[temp]= -i-1;\\n            }\\n            \\n            if( nums[j] == -i-1 ) return true;\\n        }\\n\\t\\t\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean circularArrayLoop(int[] nums) {\\n        int[] posNums = new int[nums.length];\\n        int[] negNums = new int[nums.length];\\n\\n        // normalize to 0..+-nums.length-1\\n        for( int i=0; i<nums.length; i++ ) {\\n            posNums[i] = (nums[i]<0) ? 0 : nums[i]%nums.length;\\n            negNums[i] = (nums[i]<0) ? nums[i]%nums.length : 0;\\n        } \\n        \\n        // find any \"forward\" loop\\n        for( int i=0; i<nums.length; i++ ) {\\n            int j=i;\\n            \\n            while( posNums[j]>0 ) {\\n                int temp = j;\\n                j=(j+posNums[j])%nums.length;\\n                posNums[temp]= -i-1;\\n            }\\n            \\n            if( posNums[j] == -i-1 ) return true;\\n        }\\n\\n        // find any \"backward\" loop\\n        for( int i=0; i<nums.length; i++ ) {\\n            int j=i;\\n            \\n            while( negNums[j]<0 ) {\\n                int temp = j;\\n                j=(j+negNums[j])%nums.length;\\n                if( j<0 ) j+=nums.length;\\n                negNums[temp]= i+1;\\n            }\\n            \\n            if( negNums[j] == i+1 ) return true;\\n        }\\n        \\n        return false;\\n    }\\n```\n```\\n    public boolean circularArrayLoop(int[] nums) {\\n        // normalize to 0..nums.length-1\\n        for( int i=0; i<nums.length; i++ ) nums[i] = (nums[i]<0) ? nums[i]%nums.length+nums.length : nums[i]%nums.length;\\n        \\n        for( int i=0; i<nums.length; i++ ) {\\n            int j=i;\\n            \\n            while( nums[j]>0 ) {\\n                int temp = j;\\n                j=(j+nums[j])%nums.length;\\n                nums[temp]= -i-1;\\n            }\\n            \\n            if( nums[j] == -i-1 ) return true;\\n        }\\n\\t\\t\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 194274,
                "title": "easy-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) \\n    {\\n        int nums_length = nums.length;\\n        int i = 0;\\n        int count = 0;\\n        int loop = 0;\\n        \\n        if(nums.length == 0 || nums == null || nums[i] == 0)\\n            return false;\\n        \\n        else if(nums[i]%nums_length == 0)\\n            return true;\\n        \\n        while(count < nums_length)\\n        {\\n            int rem = nums[i]%nums_length;\\n            \\n            if(i + rem < 0)\\n                i = nums_length + (i + rem);\\n            \\n            else if(i + rem >= nums_length)\\n            {\\n                i = (i + rem) - nums.length;\\n                loop = 1;\\n            }\\n            \\n            else\\n                i = i + rem;\\n            \\n            if(loop == 1 && i == 0)\\n                return true;\\n            \\n            count++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) \\n    {\\n        int nums_length = nums.length;\\n        int i = 0;\\n        int count = 0;\\n        int loop = 0;\\n        \\n        if(nums.length == 0 || nums == null || nums[i] == 0)\\n            return false;\\n        \\n        else if(nums[i]%nums_length == 0)\\n            return true;\\n        \\n        while(count < nums_length)\\n        {\\n            int rem = nums[i]%nums_length;\\n            \\n            if(i + rem < 0)\\n                i = nums_length + (i + rem);\\n            \\n            else if(i + rem >= nums_length)\\n            {\\n                i = (i + rem) - nums.length;\\n                loop = 1;\\n            }\\n            \\n            else\\n                i = i + rem;\\n            \\n            if(loop == 1 && i == 0)\\n                return true;\\n            \\n            count++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184323,
                "title": "clean-python-o-n-time-o-1-space",
                "content": "```\ndef move_circle(idx,nums,loop_dir):\n    if nums[idx]==-float('inf'):\n        return True\n    \n\t\t# direction check\n    curr_dir = nums[idx]>0\n    if curr_dir!=loop_dir:\n        return False\n      \n    idx_next = (idx+nums[idx])%len(nums)\n    # self loop check\n    if idx_next==idx:\n        flag = False\n    else:\n        nums[idx]=-float('inf')\n        flag  = move_circle(idx_next,nums,loop_dir)\n    #mark elements considered in the cycle as 0 \n    nums[idx]=0\n    return flag\n\nclass Solution(object):\n    def circularArrayLoop(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx,num in enumerate(nums):\n            if num!=0:\n                if move_circle(idx,nums,num>0):\n                    return True\n        return False\n```",
                "solutionTags": [],
                "code": "```\ndef move_circle(idx,nums,loop_dir):\n    if nums[idx]==-float('inf'):\n        return True\n    \n\t\t# direction check\n    curr_dir = nums[idx]>0\n    if curr_dir!=loop_dir:\n        return False\n      \n    idx_next = (idx+nums[idx])%len(nums)\n    # self loop check\n    if idx_next==idx:\n        flag = False\n    else:\n        nums[idx]=-float('inf')\n        flag  = move_circle(idx_next,nums,loop_dir)\n    #mark elements considered in the cycle as 0 \n    nums[idx]=0\n    return flag\n\nclass Solution(object):\n    def circularArrayLoop(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx,num in enumerate(nums):\n            if num!=0:\n                if move_circle(idx,nums,num>0):\n                    return True\n        return False\n```",
                "codeTag": "Java"
            },
            {
                "id": 177474,
                "title": "javascript-solution-passed-10-10-cases",
                "content": "```\\nvar circularArrayLoop = function(nums) {\\n    let currentPos = 0, loopIndex = 0, loop_direction;    \\n    let n = nums.length;\\n    if (n == 0)\\n        return false;\\n    if (nums[0] > -1)\\n        loop_direction = true; //First element in the array decides the loop direction.\\n    else loop_direction = false; // true: Forward, false: Backword;\\n    \\n    for (let i = 0; i < n; i++) {\\n        currentPos = (currentPos + nums[currentPos]) % n;\\n        if (loop_direction !== (nums[currentPos] >-1 ))\\n            return false; // Check if anytime loop direction is switched.\\n        if (currentPos < 0)\\n            currentPos += n;\\n        if (currentPos === loopIndex && i < n-1)\\n            return true; // If we reached to the loop Start index, then thats it. Loop detected.\\n    }\\n    return currentPos == loopIndex;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar circularArrayLoop = function(nums) {\\n    let currentPos = 0, loopIndex = 0, loop_direction;    \\n    let n = nums.length;\\n    if (n == 0)\\n        return false;\\n    if (nums[0] > -1)\\n        loop_direction = true; //First element in the array decides the loop direction.\\n    else loop_direction = false; // true: Forward, false: Backword;\\n    \\n    for (let i = 0; i < n; i++) {\\n        currentPos = (currentPos + nums[currentPos]) % n;\\n        if (loop_direction !== (nums[currentPos] >-1 ))\\n            return false; // Check if anytime loop direction is switched.\\n        if (currentPos < 0)\\n            currentPos += n;\\n        if (currentPos === loopIndex && i < n-1)\\n            return true; // If we reached to the loop Start index, then thats it. Loop detected.\\n    }\\n    return currentPos == loopIndex;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173255,
                "title": "c-o-n-time-o-1-space-simulation-easy-to-explain-and-impl-in-10mins",
                "content": "```\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; ++i) {\\n            nums[i] %= n;\\n        }\\n\\n        int id = n;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] > 0 && nums[i] < n) {\\n                int pos = i;\\n                while (nums[pos] > 0 && nums[pos] < n) {\\n                    int next = (pos + nums[pos]) % n;\\n                    nums[pos] = id;\\n                    pos = next;\\n                }\\n\\n                if (nums[pos] == id) {\\n                    return true;\\n                }\\n                ++id;\\n            }\\n        }\\n\\n        id = -n;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] > -n && nums[i] < 0) {\\n                int pos = i;\\n                while (nums[pos] > -n && nums[pos] < 0) {\\n                    int next = (pos + nums[pos] + n) % n;\\n                    nums[pos] = id;\\n                    pos = next;\\n                }\\n\\n                if (nums[pos] == id) {\\n                    return true;\\n                }\\n                --id;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; ++i) {\\n            nums[i] %= n;\\n        }\\n\\n        int id = n;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] > 0 && nums[i] < n) {\\n                int pos = i;\\n                while (nums[pos] > 0 && nums[pos] < n) {\\n                    int next = (pos + nums[pos]) % n;\\n                    nums[pos] = id;\\n                    pos = next;\\n                }\\n\\n                if (nums[pos] == id) {\\n                    return true;\\n                }\\n                ++id;\\n            }\\n        }\\n\\n        id = -n;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] > -n && nums[i] < 0) {\\n                int pos = i;\\n                while (nums[pos] > -n && nums[pos] < 0) {\\n                    int next = (pos + nums[pos] + n) % n;\\n                    nums[pos] = id;\\n                    pos = next;\\n                }\\n\\n                if (nums[pos] == id) {\\n                    return true;\\n                }\\n                --id;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 162662,
                "title": "java-solution-through-doubling-input-array",
                "content": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        if (nums.length == 0) {\\n            return false;\\n        }\\n        int len = nums.length;\\n        int[] doubleNums = new int[2*len];\\n        for (int i = 0; i < len; i++) {\\n            doubleNums[i] = nums[i];\\n            doubleNums[i+len] = nums[i];\\n        }\\n        for (int i = 0; i < len; i++) {\\n            int idx = i, cur = doubleNums[idx], count = 1;\\n            while (cur > 0) {\\n                idx = idx + cur;\\n                if (idx - i >= len) {\\n                    if (count == 1 || idx >= 2 * len) {\\n                        break;\\n                    }\\n                    return true;\\n                }\\n                count++;\\n                cur = doubleNums[idx];\\n            }\\n        }\\n        for (int i = 2*len-1; i >= len; i--) {\\n            int idx = i, cur = doubleNums[idx], count = 1;\\n            while (cur < 0) {\\n                idx = idx + cur;\\n                if (i - idx >= len) {\\n                    if (count == 1 || idx < 0) {\\n                        break;\\n                    }\\n                    return true;\\n                }\\n                count++;\\n                cur = doubleNums[idx];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n        if (nums.length == 0) {\\n            return false;\\n        }\\n        int len = nums.length;\\n        int[] doubleNums = new int[2*len];\\n        for (int i = 0; i < len; i++) {\\n            doubleNums[i] = nums[i];\\n            doubleNums[i+len] = nums[i];\\n        }\\n        for (int i = 0; i < len; i++) {\\n            int idx = i, cur = doubleNums[idx], count = 1;\\n            while (cur > 0) {\\n                idx = idx + cur;\\n                if (idx - i >= len) {\\n                    if (count == 1 || idx >= 2 * len) {\\n                        break;\\n                    }\\n                    return true;\\n                }\\n                count++;\\n                cur = doubleNums[idx];\\n            }\\n        }\\n        for (int i = 2*len-1; i >= len; i--) {\\n            int idx = i, cur = doubleNums[idx], count = 1;\\n            while (cur < 0) {\\n                idx = idx + cur;\\n                if (i - idx >= len) {\\n                    if (count == 1 || idx < 0) {\\n                        break;\\n                    }\\n                    return true;\\n                }\\n                count++;\\n                cur = doubleNums[idx];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141581,
                "title": "c-easiest-solution-beats-100",
                "content": "Not sure what everyone is doing. No need to have nested loops\\n\\'\\'\\'\\n\\nbool circularArrayLoop(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 2) return false;\\n        \\n        int i = 0;\\n        bool forward = nums[i] > 0 ? true : false;\\n        while (1)\\n        {            \\n            int prev = i;\\n            i += nums[i];\\n            if (i < 0)\\n                i += size;\\n            i = i % size;\\n            \\n            if (i == 0)\\n                return true;\\n            if ((nums[i] < 0 && forward) || (nums[i] > 0 && !forward) || i == prev)\\n                return false;                        \\n        }\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Not sure what everyone is doing. No need to have nested loops\\n\\'\\'\\'\\n\\nbool circularArrayLoop(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 2) return false;\\n        \\n        int i = 0;\\n        bool forward = nums[i] > 0 ? true : false;\\n        while (1)\\n        {            \\n            int prev = i;\\n            i += nums[i];\\n            if (i < 0)\\n                i += size;\\n            i = i % size;\\n            \\n            if (i == 0)\\n                return true;\\n            if ((nums[i] < 0 && forward) || (nums[i] > 0 && !forward) || i == prev)\\n                return false;                        \\n        }\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 94168,
                "title": "why-2-1-1-2-2-is-not-a-loop",
                "content": "Why [2, -1, 1, -2, -2] is not a loop? And this is my solution:\\nbool circularArrayLoop(vector<int>& nums) {\\n        if (nums.empty()) {\\n            return false;\\n        }\\n        int currentPos = 0;   \\n        int n = nums.size();  \\n        for (int i = 0; i < n; ++i) {\\n            // std::cout << \"current: \" << currentPos << \" \";\\n            currentPos = (currentPos + nums[currentPos] + n) % n;\\n            // std::cout << \" next: \" << currentPos << std::endl;                                                         \\n            if (currentPos == 0 && i < n - 1) {\\n                return true;      \\n            }\\n        }\\n        return currentPos == 0;\\n    }",
                "solutionTags": [],
                "code": "Why [2, -1, 1, -2, -2] is not a loop? And this is my solution:\\nbool circularArrayLoop(vector<int>& nums) {\\n        if (nums.empty()) {\\n            return false;\\n        }\\n        int currentPos = 0;   \\n        int n = nums.size();  \\n        for (int i = 0; i < n; ++i) {\\n            // std::cout << \"current: \" << currentPos << \" \";\\n            currentPos = (currentPos + nums[currentPos] + n) % n;\\n            // std::cout << \" next: \" << currentPos << std::endl;                                                         \\n            if (currentPos == 0 && i < n - 1) {\\n                return true;      \\n            }\\n        }\\n        return currentPos == 0;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 94182,
                "title": "my-solution-with-o-n-complexity-in-c",
                "content": "When the travelling direction changed, set all points on the path before the change point to zero. The worst case Each point will be visited once, set to zero once. The times that zero points be visited will be no more than n.  The complexity is O(n). O(1) extra space used.\\n```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int size = nums.size();\\n        if (nums.empty())\\n            return false;\\n        for (int i = 0; i<size;i++){\\n            if (nums[i]==0)\\n                continue;\\n            int step = 0;\\n            int j = i;\\n            while (step<=(size+3)){\\n                if (nums[i]*nums[j]<=0){\\n                    setZero(nums,i,step);\\n                    break;\\n                }\\n                int prev = j;\\n                j = j + nums[j];\\n                j = j%size;\\n                if (j<0)\\n                    j+= size;\\n                step++;\\n                if ((step>size)&&j!=prev)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    void setZero(vector<int>&nums,int i,int step){\\n        int size = nums.size();\\n        int k = i;\\n        int step1 = 0;\\n        while(step1<step){\\n            int temp = nums[k];\\n            nums[k] = 0;\\n            k+=temp;\\n            k = k%size;\\n            if (k<0)\\n                k+= size;\\n            step1++;\\n        }\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int size = nums.size();\\n        if (nums.empty())\\n            return false;\\n        for (int i = 0; i<size;i++){\\n            if (nums[i]==0)\\n                continue;\\n            int step = 0;\\n            int j = i;\\n            while (step<=(size+3)){\\n                if (nums[i]*nums[j]<=0){\\n                    setZero(nums,i,step);\\n                    break;\\n                }\\n                int prev = j;\\n                j = j + nums[j];\\n                j = j%size;\\n                if (j<0)\\n                    j+= size;\\n                step++;\\n                if ((step>size)&&j!=prev)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    void setZero(vector<int>&nums,int i,int step){\\n        int size = nums.size();\\n        int k = i;\\n        int step1 = 0;\\n        while(step1<step){\\n            int temp = nums[k];\\n            nums[k] = 0;\\n            k+=temp;\\n            k = k%size;\\n            if (k<0)\\n                k+= size;\\n            step1++;\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94163,
                "title": "simple-c-solution-with-marker-time-o-n-space-o-1",
                "content": "class Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int next = 0;\\n        if(nums.size() == 0)\\n            return 0;\\n        while(1){\\n            int step = nums[next];\\n            nums[next] = 0;\\n            if(step > 0) {\\n                next = (next + step) % nums.size();\\n            } else if(step == 0) {\\n                return false;\\n            } else {\\n                next = nums.size() - (abs(next + step) % nums.size());\\n            }\\n            if(next == nums.size() - 1)\\n                return false;\\n            if(nums[next] == 0)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int next = 0;\\n        if(nums.size() == 0)\\n            return 0;\\n        while(1){\\n            int step = nums[next];\\n            nums[next] = 0;\\n            if(step > 0) {\\n                next = (next + step) % nums.size();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 94207,
                "title": "share-my-c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=1) return false;\\n     for (int i = 0; i < n;++i){//different starting point\\n        int slow = getIndex(nums,i);//initialize slow \\n        int fast = getIndex(nums,slow);\\n             while (nums[slow] * nums[fast] > 0 && nums[slow] * nums[getIndex(nums, fast)] > 0) {//checking same direction\\n                if (slow == fast) {\\n                    if (slow == getIndex(nums, slow)) break;//singel element\\n                    else return true;\\n                }\\n                slow = getIndex(nums, slow);//move\\n                fast = getIndex(nums, getIndex(nums, fast));\\n       }\\n    }\\n          return false;\\n}\\n    int getIndex(const vector<int>& nums,int i){\\n        int n = nums.size();\\n        return nums[i]+i>=0?(i + nums[i])%n:(i+nums[i])%n==0?(i + nums[i])%n+n:0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool circularArrayLoop(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=1) return false;\\n     for (int i = 0; i < n;++i){//different starting point\\n        int slow = getIndex(nums,i);//initialize slow \\n        int fast = getIndex(nums,slow);\\n             while (nums[slow] * nums[fast] > 0 && nums[slow] * nums[getIndex(nums, fast)] > 0) {//checking same direction\\n                if (slow == fast) {\\n                    if (slow == getIndex(nums, slow)) break;//singel element\\n                    else return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 94224,
                "title": "ugly-fast-slow-pointer-python-solution-o-n-time-o-1-space",
                "content": "Use fast/slow pointer to detect loop, just like we did for the linked list.\\nAlso, if we don't find a loop, mark all visited elements zero.\\n\\n'''\\n\\n    def circularArrayLoop(self, nums):\\n\\n        if not nums or len(nums) < 2: return False\\n        \\n        for i in xrange(len(nums)):\\n            \\n            if nums[i] == 0:\\n                continue\\n            if nums[i] > 0:\\n                direction = 1\\n            else:\\n                direction = -1\\n            flag = True  # check is the direction remains unchanged\\n            slow, fast = i, (i + nums[i]) % len(nums)\\n            visited = 1\\n            \\n            while slow != fast and flag and visited < len(nums):\\n                nextslow = (slow + nums[slow]) % len(nums)\\n                if direction * nums[slow] < 0:\\n                    flag = False\\n                    break\\n                slow = nextslow\\n                nextfast = (fast + nums[fast]) % len(nums)\\n                if direction * nums[fast] < 0:\\n                    flag = False\\n                    break\\n                fast = nextfast\\n                nextfast = (fast + nums[fast]) % len(nums)\\n                if direction * nums[fast] < 0:\\n                    flag = False\\n                    break\\n                fast = nextfast\\n                visited += 1\\n               \\n            # fast != (fast + nums[fast]) % len(nums) checks for 1 element loop\\n            # flag checks if direction's been changed\\n            if slow == fast and flag and fast != (fast + nums[fast]) % len(nums):\\n                return True\\n            else:\\n                j = i\\n                while j != fast and visited > 0:\\n                    nums[j] = 0\\n                    j = (j + nums[j]) % len(nums)\\n                    visited -= 1\\n                nums[j] = 0\\n                    \\n        return False\\n'''",
                "solutionTags": [
                    "Python"
                ],
                "code": "Use fast/slow pointer to detect loop, just like we did for the linked list.\\nAlso, if we don't find a loop, mark all visited elements zero.\\n\\n'''\\n\\n    def circularArrayLoop(self, nums):\\n\\n        if not nums or len(nums) < 2: return False\\n        \\n        for i in xrange(len(nums)):\\n            \\n            if nums[i] == 0:\\n                continue\\n            if nums[i] > 0:\\n                direction = 1\\n            else:\\n                direction = -1\\n            flag = True  # check is the direction remains unchanged\\n            slow, fast = i, (i + nums[i]) % len(nums)\\n            visited = 1\\n            \\n            while slow != fast and flag and visited < len(nums):\\n                nextslow = (slow + nums[slow]) % len(nums)\\n                if direction * nums[slow] < 0:\\n                    flag = False\\n                    break\\n                slow = nextslow\\n                nextfast = (fast + nums[fast]) % len(nums)\\n                if direction * nums[fast] < 0:\\n                    flag = False\\n                    break\\n                fast = nextfast\\n                nextfast = (fast + nums[fast]) % len(nums)\\n                if direction * nums[fast] < 0:\\n                    flag = False\\n                    break\\n                fast = nextfast\\n                visited += 1\\n               \\n            # fast != (fast + nums[fast]) % len(nums) checks for 1 element loop\\n            # flag checks if direction's been changed\\n            if slow == fast and flag and fast != (fast + nums[fast]) % len(nums):\\n                return True\\n            else:\\n                j = i\\n                while j != fast and visited > 0:\\n                    nums[j] = 0\\n                    j = (j + nums[j]) % len(nums)\\n                    visited -= 1\\n                nums[j] = 0\\n                    \\n        return False\\n'''",
                "codeTag": "Python3"
            },
            {
                "id": 94244,
                "title": "test-case-missing",
                "content": "The following ***ill-code*** has passed all the existing cases and was accepted.\\nBut it will output the wrong answer ***false*** when input is [1, 1, 2], when the expected answer is ***true***.\\nI would suggest add a new test ***[1, 1, 2]*** in system. Thanks.\\n\\n```\\n// Copyright 2016 Qi Wang\\n// Date: 2016-11-13\\nclass Solution {\\n public:\\n  bool circularArrayLoop(vector<int>& nums) {\\n    for (int i = 0; i < nums.size(); ++i) {\\n      if (nums[i] == 0) continue;\\n      int begin = i;\\n      bool forward = nums[i] > 0;\\n      int cnt = 0;\\n      for (int j = i; nums[j] && forward == nums[j] > 0; ++cnt) {\\n        int next = (j + nums[j]) % static_cast<int>(nums.size());\\n        if (next < 0) next += nums.size();\\n        if (next == begin) {\\n          if (cnt > 0) {\\n            return true;\\n          } else {\\n            break;\\n          }\\n        } else {\\n          nums[j] = 0;\\n          j = next;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Copyright 2016 Qi Wang\\n// Date: 2016-11-13\\nclass Solution {\\n public:\\n  bool circularArrayLoop(vector<int>& nums) {\\n    for (int i = 0; i < nums.size(); ++i) {\\n      if (nums[i] == 0) continue;\\n      int begin = i;\\n      bool forward = nums[i] > 0;\\n      int cnt = 0;\\n      for (int j = i; nums[j] && forward == nums[j] > 0; ++cnt) {\\n        int next = (j + nums[j]) % static_cast<int>(nums.size());\\n        if (next < 0) next += nums.size();\\n        if (next == begin) {\\n          if (cnt > 0) {\\n            return true;\\n          } else {\\n            break;\\n          }\\n        } else {\\n          nums[j] = 0;\\n          j = next;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94161,
                "title": "concise-c-code-0ms-o-n-time-o-1-space-15-lines-with-comments",
                "content": "For each position i that has non-zero value: \\n1) Determine the direction\\n2) Check for loop (see if there is a valid path with length more than array size)\\n3) If no loop, start from i again and change value along path to 0.\\n```\\n    bool circularArrayLoop(vector<int>& nums) {\\n        //next index\\n        #define n(i) ((nums[i]+i)%nums.size())\\n        int count, check, mark, mode;\\n        for( int i = 0; i < nums.size(); i ++ ){\\n            if( nums[i] != 0 ){\\n                //check the direction\\n                mode = nums[i] > 0? 1:-1;\\n                count = 0; check = i; mark = i;\\n                //check for loow\\n                while( count++ <= nums.size() + 1&& mode*nums[n(check)] > 0 && n(check) != check ) \\n                    check = n(check);\\n                //a path longer than array size means there is a loop\\n                if( count > nums.size() + 1 ) return true;\\n                //mark all nodes in path as 0\\n                while( nums[mark] > 0 ){ mark = n(mark); nums[mark] = 0; }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool circularArrayLoop(vector<int>& nums) {\\n        //next index\\n        #define n(i) ((nums[i]+i)%nums.size())\\n        int count, check, mark, mode;\\n        for( int i = 0; i < nums.size(); i ++ ){\\n            if( nums[i] != 0 ){\\n                //check the direction\\n                mode = nums[i] > 0? 1:-1;\\n                count = 0; check = i; mark = i;\\n                //check for loow\\n                while( count++ <= nums.size() + 1&& mode*nums[n(check)] > 0 && n(check) != check ) \\n                    check = n(check);\\n                //a path longer than array size means there is a loop\\n                if( count > nums.size() + 1 ) return true;\\n                //mark all nodes in path as 0\\n                while( nums[mark] > 0 ){ mark = n(mark); nums[mark] = 0; }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94179,
                "title": "python-o-n-solution-with-explaination",
                "content": "<p>There is a condition that is very important but potentially easy to be ignored:\\n**The loop must be \"forward\" or \"backward\"**\\nIt means all elements in the loop has to be either uniformly positive or negative and this is because whether a step is forward or backward is defined by the sign of the element. So a forward loop has to be that all the steps are forward.\\n\\nMy idea is that if there is loop, we could jump forever(actually n times is enough) without stop. If there is no loop, however, we must end up at one element and will never jump out from it. It is therefore we can judge if we run into a \"dead end\" by comparing the current element with previous one.  Also since the loop has to be uniformly forward or backward, whenever we jump to a element that has different sign with previous one, we should stop.\\n\\nThere is still a problem about runtime. Since we has to start from each element (every element could be the elements in the loop) and if we do not record the wrong path we went, the worse case could be n^2. So each time when we realize we went through a wrong path, we started it over again to mark all the elements on the path as visited(here I just set them 0). In this case every point is visited at most twice and therefore the runtime is O(n)</p>\\n\\n<pre><code>def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(len(nums)):\\n            count = 0\\n            pre = i\\n            isloop = True\\n            if nums[i] == 0: \\n                break\\n            is_forward = nums[i]>0\\n            while count<len(nums):\\n                count += 1\\n                cur = (pre+nums[pre])%len(nums)\\n                if pre == cur or (nums[cur]>0) ^ is_forward:# stop if running into a dead end or different sign element\\n                    isloop = False\\n                    break\\n                else:\\n                    pre = cur\\n            if isloop:\\n                return True\\n            else: # mark all the elements on the wrong path as visited \\n                pre = i\\n                while count > 0:\\n                   cur = (pre+nums[pre])%len(nums)\\n                   nums[pre] = 0\\n                   pre = cur\\n                   count -= 1\\n        return False\\n</pre></code>",
                "solutionTags": [],
                "code": "<p>There is a condition that is very important but potentially easy to be ignored:\\n**The loop must be \"forward\" or \"backward\"**\\nIt means all elements in the loop has to be either uniformly positive or negative and this is because whether a step is forward or backward is defined by the sign of the element. So a forward loop has to be that all the steps are forward.\\n\\nMy idea is that if there is loop, we could jump forever(actually n times is enough) without stop. If there is no loop, however, we must end up at one element and will never jump out from it. It is therefore we can judge if we run into a \"dead end\" by comparing the current element with previous one.  Also since the loop has to be uniformly forward or backward, whenever we jump to a element that has different sign with previous one, we should stop.\\n\\nThere is still a problem about runtime. Since we has to start from each element (every element could be the elements in the loop) and if we do not record the wrong path we went, the worse case could be n^2. So each time when we realize we went through a wrong path, we started it over again to mark all the elements on the path as visited(here I just set them 0). In this case every point is visited at most twice and therefore the runtime is O(n)</p>\\n\\n<pre><code>def circularArrayLoop(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(len(nums)):\\n            count = 0\\n            pre = i\\n            isloop = True\\n            if nums[i] == 0: \\n                break\\n            is_forward = nums[i]>0\\n            while count<len(nums):\\n                count += 1\\n                cur = (pre+nums[pre])%len(nums)\\n                if pre == cur or (nums[cur]>0) ^ is_forward:# stop if running into a dead end or different sign element\\n                    isloop = False\\n                    break\\n                else:\\n                    pre = cur\\n            if isloop:\\n                return True\\n            else: # mark all the elements on the wrong path as visited \\n                pre = i\\n                while count > 0:\\n                   cur = (pre+nums[pre])%len(nums)\\n                   nums[pre] = 0\\n                   pre = cur\\n                   count -= 1\\n        return False\\n</pre></code>",
                "codeTag": "Python3"
            },
            {
                "id": 94250,
                "title": "why-2-1-1-2-2-return-false",
                "content": "Why [2, -1, 1, -2, -2] return false?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 94256,
                "title": "java-1-ms-o-n-time-o-1-space-with-single-iterator-solution",
                "content": "The key is array elements are marked with 0 in order to show that they are visited.\\n\\n```\\npublic class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n       \\n       if(nums==null || nums.length==0)\\n            return false;\\n            \\n       while(true)\\n       {\\n           int startindex = FindIndex(nums, nums.length);\\n           if(startindex == -1)\\n              return false;\\n              \\n           if(HasLoop(nums, nums.length, startindex))\\n              return true;\\n       }\\n       \\n    }\\n    \\n    public boolean HasLoop(int[] nums, int len, int startindex)\\n    {\\n       int dir = 0; //1 forward, -1 backward, 0 no-direction yet\\n       int index = startindex;\\n           \\n       while(index >= 0 && index < len)\\n       {\\n           if(dir != 0 && startindex == index)\\n              return true;\\n              \\n            int ndir = nums[index] > 0 ? 1 : -1;\\n            int newindex = (index + nums[index]) % len;\\n            if(newindex < 0) //handle negative\\n                newindex += len;\\n            \\n            if(newindex == index)\\n            {\\n                nums[index] = 0; //mark visisted to prevent infite loop\\n                break;\\n            }\\n            else if(dir!=0 && dir!=ndir)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                nums[index] = 0; //mark visisted\\n                index = newindex;\\n                dir = ndir;\\n            }\\n       }\\n       \\n       return false;\\n    }\\n    \\n    public int FindIndex(int[] nums, int len)\\n    {\\n        for(int i=0; i<len; i++)\\n        {\\n            if(nums[i] != 0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean circularArrayLoop(int[] nums) {\\n       \\n       if(nums==null || nums.length==0)\\n            return false;\\n            \\n       while(true)\\n       {\\n           int startindex = FindIndex(nums, nums.length);\\n           if(startindex == -1)\\n              return false;\\n              \\n           if(HasLoop(nums, nums.length, startindex))\\n              return true;\\n       }\\n       \\n    }\\n    \\n    public boolean HasLoop(int[] nums, int len, int startindex)\\n    {\\n       int dir = 0; //1 forward, -1 backward, 0 no-direction yet\\n       int index = startindex;\\n           \\n       while(index >= 0 && index < len)\\n       {\\n           if(dir != 0 && startindex == index)\\n              return true;\\n              \\n            int ndir = nums[index] > 0 ? 1 : -1;\\n            int newindex = (index + nums[index]) % len;\\n            if(newindex < 0) //handle negative\\n                newindex += len;\\n            \\n            if(newindex == index)\\n            {\\n                nums[index] = 0; //mark visisted to prevent infite loop\\n                break;\\n            }\\n            else if(dir!=0 && dir!=ndir)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                nums[index] = 0; //mark visisted\\n                index = newindex;\\n                dir = ndir;\\n            }\\n       }\\n       \\n       return false;\\n    }\\n    \\n    public int FindIndex(int[] nums, int len)\\n    {\\n        for(int i=0; i<len; i++)\\n        {\\n            if(nums[i] != 0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564749,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1567325,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1564989,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1566845,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1568550,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1570199,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1566819,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1569533,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1569118,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1574907,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1564749,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1567325,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1564989,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1566845,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1568550,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1570199,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1566819,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1569533,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1569118,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1574907,
                "content": [
                    {
                        "username": "czhangaegean",
                        "content": "For example, starting at index 1, nums[1] is 1, move 1 step forward to index 2. Then nums[2] is -1, move back 1 step to index 1. The loop contains indices 1 and 2. Is this a valid loop?"
                    },
                    {
                        "username": "PabloLION",
                        "content": "[@PabloLION](/PabloLION) OK I read the question again and it says\n> Every `nums[seq[j]]` is either all positive or all negative.\nSo it's not valid since there are a `+1` and a `-1`. My algorithm needs change then..."
                    },
                    {
                        "username": "PabloLION",
                        "content": "I think it is, but i have two test cases:\n1. `[-2, 1, -1, -2, -2]`\n2. `[3, 1, -1]`\n\nboth gives \"Expected: `false`\". Could anyone help explaining this?"
                    },
                    {
                        "username": "GeneR",
                        "content": "The problem seems poorly worded. The case [-2, 1, -1, -2, -2] is supposedly False. \\n\\nBut as I read the problem, there\\'s a loop [1,2,1]. \\n\\nCan someone please explain this?"
                    },
                    {
                        "username": "asdfalice",
                        "content": "Every nums[seq[j]] is either all positive or all negative."
                    },
                    {
                        "username": "andhddn",
                        "content": "In the {3, 1, 2} case we jump and return to the same position. So there is really one step and it is considered a loop. Is it because we \"fly over 2 positions\"? Fine. Then why {-1, -2, -3, -4, -5} is not a loop? We make one step from -1 to -5 and then we do exactly the same as in case {3, 1, 2) but to the left.\\n\\nFor this question to be reasonable the description should take these cases:\\n\\n{-1, 2} -> False\\n\\n{-2, 1, -1, -2, -2} -> False\\n\\n{2, -1, 1, -2, -2} -> False\\n\\n{3, 1, 2} -> True\\n\\n{-1, -2, -3, -4, -5} -> False\\n\\nand spell out why exactly the expected results are the way they are."
                    },
                    {
                        "username": "SahaiAbhi",
                        "content": "1) Most important is the loop will and always start and end at position 0.\\n2) Loop will be either in forward or backward direction only.\\n3) None of array value is 0.\\n\\nWith these facts in mind we need not dive into a graph solution , it can be done in order of n by marking visited nodes in array to be 0. Hence space complexisty would be O(1) ."
                    },
                    {
                        "username": "Shazam02",
                        "content": "How come [-1,-2,-3,-4,-5] is false?"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "there are 5  cycles of length 1. length must be > 1. `k > 1` in description"
                    },
                    {
                        "username": "vudao",
                        "content": "Ranting... \\nThis is definitely one of most voted down problem for its unclear and bad explaination.\\nbtw, where is the definition for circular array?\\n"
                    },
                    {
                        "username": "Syndikatz",
                        "content": "For the testcase:[1,1,2]  and [2,-1] it should be giving \"True\" but it is giving \"False\" but u can clearly see there are forward loops in both of it and it satisfies the condition given of leetcode still i won\\'t get the reason for this ambiguity.\\n\\nSo i would recommend leetcode to either check the testcases once again or clarify the question more clearly.......Thank you."
                    },
                    {
                        "username": "SebastienP",
                        "content": "My code gives me  [-2,-3,-9] -> True (I agree) and it **passes** the test \\nAnd also gives me [-1,-2,-3,-4,-5] -> True (I agree) and it **does not pass**  the test\\n\\nBoth examples contai negative cycles of more that 1 step, can somebody explain to me why second example should return false?"
                    },
                    {
                        "username": "lazy_boy",
                        "content": "-1 : take 1 step backward. It will go to -5\\n-5: take 5 steps backward. it will go back to -5. Hence a loop.\\nMy code is return TRUE. but the test case expects a FALSE. Any Idea ?"
                    },
                    {
                        "username": "neerajkasula786",
                        "content": "[-2,1,-1,-2,-2]\\n In this example we can find a cycle from index 0 -- > 3 --> 0 which is of length 2 but output is false. can someone please explain"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its 0 -- > 3 --> 1 I think. Every nums[seq[j]] is either all positive or all negative. index 1 is positive\n"
                    }
                ]
            },
            {
                "id": 1573279,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1569119,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1569120,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1571724,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1576914,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1575293,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1575189,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1574824,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1574585,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1573758,
                "content": [
                    {
                        "username": "dnx",
                        "content": "where is the cycle?"
                    },
                    {
                        "username": "GrubenM",
                        "content": "What does it mean that\\n> the loop must be \"forward\" or \"backward\"\\n\\nWith `[3, 3, -1 -1]`, the loop would cycle forwards, but admittedly also would hiccup backwards.\\n\\nUsing this as a custom test case, the grader expects false.\\n\\nAre `forward` and `backward` best understood as \"having **no** direction reversal\"?\\n\\n**edit**: no direction reversal is also suggested by LHearen's post in [Why does [2,-2,2,-2,-1] return false?](https://discuss.leetcode.com/topic/67221/why-does-2-2-2-2-1-return-false)\\n\\nIf this is the case, I would suggest adding the following to clarify the problem statement:\\n> **Example 3**: Given the array [3, 3, -1, -1], there is no loop.\\n\\nSince the current described meaning of \"forward\" and \"backward\" is ambiguous."
                    },
                    {
                        "username": "nice_dev",
                        "content": "In the problem statement, it is mentioned \"A loop starts and ends at a particular index with `more than 1 element along the loop`\"\\n\\nIn [3,1,2] , I don't find more than 1 selected element along the way to reach the same index."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2, 1, -1, -2, -2]\\n\\n1->2->1->2->1->2.... there is a 2 element loop"
                    },
                    {
                        "username": "mypherDummy",
                        "content": "How is this test case a cycle ?? ( the said the sequence should either contain postive moves or negative moves ) \\n\\n`[1,-1,2,4,4]` \\n\\nMy Output => `false`\\nExpected output => `true`\\n\\n![image](https://assets.leetcode.com/users/images/18366825-44d3-45f3-a3db-e9c7f4f53c9c_1655670836.3183131.png)\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "2--4--3--2"
                    },
                    {
                        "username": "coder1226",
                        "content": "As the question describes that cycle of length 1 is not allowed then how test case [3,2,1] gives true as output?\\nAnybody got the reason behind this please help me out."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Its now false"
                    },
                    {
                        "username": "snehalP789",
                        "content": "As it will keep on visiting 0th index, shouldn\\'t it be false ?"
                    },
                    {
                        "username": "agenedy",
                        "content": "I\\'m a bit stuck here guys. My solution fails because a test case [3,2,1] is expected to return true (circular array), but I don\\'t see how is this possible.\\n\\nFor this array, the cycle would go like this: first element (3) would move us forward 3 steps, which means we go back to the same element (3), so our cycle length is 1, which should return false. But when I submit my solution, it\\'s wrong because this test casse is expected to return true.\\n\\nAm I missing something? Could someone please clarify why this array should return true?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "its >1 . Index 1-->0-->0 or 2-->0-->0\n\n"
                    },
                    {
                        "username": "nkhlkamboj",
                        "content": "Hi can anyone plz justify test case\\n{3,1,2}\\n[1,-1,2,4,4]\\n\\nhow it\\'s possible they are giving true value.\\n\\nThanks"
                    },
                    {
                        "username": "sunyize900227",
                        "content": "I just don\\'t understand, how can man calculate the time complexity O(n). One loop for every element costs already O(n), then loop for slow and fast pointer in every loop is not constant but costs also in O(n) at worst case, then the time complexity is O(n^2) but not O(n), or somewhere i have thought wrong?"
                    }
                ]
            },
            {
                "id": 1572877,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1572627,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1572269,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1572016,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1571987,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1571716,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1571715,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1571717,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1571718,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1571719,
                "content": [
                    {
                        "username": "lalitbhagtani01",
                        "content": "This can not be true as this is produced cycle of length 1. index 0 -> 0"
                    },
                    {
                        "username": "Apoorva333",
                        "content": "Every chain ends up at 7 which is a loop of size 1. Am I missing something ?"
                    },
                    {
                        "username": "momonga",
                        "content": "Are you referring to test case 40: [2,2,2,2,2,4,7]? According to the problem, the output should be true and my algo returns true, but the test case is expecting false."
                    },
                    {
                        "username": "razvx",
                        "content": "Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element.\\n\\nI dont understand the above line"
                    },
                    {
                        "username": "bhushan55",
                        "content": "like what does this means:\\n\"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element\"???"
                    },
                    {
                        "username": "QI1002",
                        "content": "Hi \\n\\ndoes anyone tell me what is wrong in this case ?\\n1=>2=>1=>2 ... shall be a loop\\nI submited and failed in this case.\\n\\nRegards"
                    },
                    {
                        "username": "kurifu",
                        "content": "The language is very unclear, particularly:\\n\"Assume the first element of the array is **forward next to the last element**, and the last element is **backward next to the first element**.\"\\n\\nWhat is this trying to say? If it is trying to indicate direction of traversal, use left to right / right to left to indicate direction.\\n\\nThe first example is also unclear, because it **has not defined the behavior of taking steps beyond the boundaries of the array**. If the array is [2, -1, 1, 2, 2], I would go from index 0 -> 2 -> 3, at which point I would have to take 2 steps to exit the boundaries of the array. What about this last step makes this a loop?"
                    },
                    {
                        "username": "kaushikosu",
                        "content": "[3,1,2] results in 0->0->0->0 .....\\n\\n[2,-1] also results in 0->0->0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\n\n"
                    },
                    {
                        "username": "rsai420",
                        "content": "The loop starts at index 1 and doesn't land at index 0.. There is atleast one accepted solution that doesn't cover for this testcase and gives an incorrect answer."
                    },
                    {
                        "username": "cameomarathon",
                        "content": "Why is [-1, 2] false, whereas [3,1,2] is true? In the first case the problem will loop around the number 2, and in the second case the problem will loop around the number 3. And in both cases there are \"supposedly\" \"more than 1 element along the loop\". \\n\\nJust a humble comment: this is a very ill-posed problem."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": " Index 1-->2-->1 or 2-->1-->2 for [3,1,2]\\n\\nfor [-1,2], its not cycles. it is moving backward and then own loop. The loop is  not returning to -1."
                    },
                    {
                        "username": "sks1901",
                        "content": "why test case [1,1,-2] gives false. Isn't it a loop from 0>1>2>0 (these are indices of array)\\nThanks"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    }
                ]
            },
            {
                "id": 1571721,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1571722,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1571720,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1571723,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1571725,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1569198,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1569121,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1997906,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1956757,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            },
            {
                "id": 1917841,
                "content": [
                    {
                        "username": "merchant",
                        "content": "I am getting true logically as well .\\n\\nBascially starts from indexs 0-> 2 ->3->1->0. Then this is a loop right ? Why is it returning false ?\\n\\nPlease help if my understanding is wrong"
                    },
                    {
                        "username": "dribvurhd",
                        "content": "I feel that the case `[2,-2,2,-2,-1]` should return true. Maybe I am mis-understanding the problem statement, but there seems to be a backward loop here."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "szp14",
                        "content": "As the title above, [1,1,-2,1,4] has loop of 3->4->3->...\\uff0cand it's a \"forward\" loop, but the \"run code\" returns false\\nI think it's because I mix a \"fake\" loop 0->1->2->0 with a genuine loop."
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "From the problem definition, can someone explain this : \"Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. \" ?"
                    },
                    {
                        "username": "lano1",
                        "content": "C# (if it matters)\\n\\nThe following returns false (no loop) and I can't see why. Could I have some clarification as to what I'm missing\\n\\n[2, -1, 1, -2, -2]\\n\\n0 \\u2192 2 \\u2192 3 \\u2192 1 \\u2192 0"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Every nums[seq[j]] is either all positive or all negative.\\n"
                    },
                    {
                        "username": "LearningToFly",
                        "content": "Let\\'s start with the example given as part of the problem \\n\\nExample 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.\\nExample 2: Given the array [-1, 2], there is no loop. \\nWhy the example 2 has no loop ? 0 -> 1 -> 1 .. so why is it not a loop ?  \\n-1 should take me to the last element of the array (1), and from there I will have to go to  2 elements and hence I will come back to the same element 1. Is it not a loop ?\\nAm I missing anything ?\\n\\n\\n \\n\\n"
                    },
                    {
                        "username": "jedihy",
                        "content": "[2, 0, 2, 1, 3]\\n0->2->4->2->4... should be true?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This question is fun, but the explanation is not so great. Basically, each spot in nums represents the number of steps you should take forward or backward in the array. A negative represents going left in nums, a positive represents going right. If we go outside the indexing range of the array, loop back to the other side. So if we go too far right (index == nums.Length) we loop back to index == 0. If we go too far left (index == -1) we loop back to index == nums.Length - 1.\\n\\nWe are searching for a starting index in nums where, starting from that point, we follow the steps and it takes us in a full loop back to where we started. However the direction of the steps in the cycle must either be going ALL RIGHT (positive) or ALL LEFT (negative). If we start with a negative number and then encounter a positive, the cycle is considered invalidated.\\n\\nFinally, the cycle must land at more than 1 index. In other words [0, 0, 0, 0, 5] is not considered a valid cycle because 5 loops back to itself, and every other index doesn\\'t go anywhere but itself. So even though 5 does cycle back to 5, it only ever \"touches\" 1 index in that cycle.\\n\\nIf we can find an index that has a cycle, going always in one direction, and that lands on more than just 1 index, we can return true.\\n\\nIf we check every index in nums and conclude that no starting index has a valid cycle according to the above criteria, we can return false.\\n\\nI hope this helps someone!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think it\\'s not a bad problem, but the wording of the prompt definitely could have been better..."
                    },
                    {
                        "username": "Ainur39",
                        "content": "[-2,1,-1,-2,-2]\\nIf you wondering why [-2,1,-1,-2,-2] is FALSE. Cycle is true ONLY if it goes in one direction Here we move from {i: 0, val: -2} -> {i: 4, val - 2} -> {i: 2: val: 1} It was okey so far. But now we have positive direction because value = 1. So we dont even proceed checking for cycle.\\n\\nYou can check my solution on JS. \\nhttps://leetcode.com/problems/circular-array-loop/submissions/964358531/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Words in a String III",
        "question_content": "<p>Given a string <code>s</code>, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"Let's take LeetCode contest\"\n<strong>Output:</strong> \"s'teL ekat edoCteeL tsetnoc\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"God Ding\"\n<strong>Output:</strong> \"doG gniD\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains printable <strong>ASCII</strong> characters.</li>\n\t<li><code>s</code> does not contain any leading or trailing spaces.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n\t<li>All the words in <code>s</code> are separated by a single space.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 101909,
                "title": "1-line-ruby-python",
                "content": "**Ruby:**\\n\\nOnce again Ruby is really nice, it's super short and you can just write the steps from left to right. Split the string into words, reverse each word, then join them back together.\\n```\\ndef reverse_words(s)\\n  s.split.map(&:reverse).join(\" \")\\nend\\n```\\n\\n**Python:**\\n\\nHere I first reverse the order of the words and then reverse the entire string.\\n\\n    def reverseWords(self, s):\\n        return ' '.join(s.split()[::-1])[::-1]\\n\\nThat's a bit shorter than the more obvious one:\\n\\n    def reverseWords(self, s):\\n        return ' '.join(x[::-1] for x in s.split())\\n\\n**Ruby again:**\\n\\nThat double reversal in Ruby:\\n```\\ndef reverse_words(s)\\n  s.split.reverse.join(\" \").reverse\\nend\\n```\\n**Python again:**\\n\\nThe double reversal is not just shorter but also faster. Trying both versions as well as the optimized obvious solution (using a list comprehension instead of a generator expression), five attempts each:\\n```\\n>>> from timeit import timeit\\n>>> setup = 's = \"Let\\\\'s take LeetCode contest\"'\\n>>> statements = (\"' '.join(s.split()[::-1])[::-1]\",\\n\\t          \"' '.join(x[::-1] for x in s.split())\",\\n\\t          \"' '.join([x[::-1] for x in s.split()])\")\\n>>> for stmt in statements:\\n        print ' '.join('%.2f' % timeit(stmt, setup) for _ in range(5)), 'seconds for:', stmt\\n\\n0.79 0.78 0.80 0.82 0.79 seconds for: ' '.join(s.split()[::-1])[::-1]\\n2.10 2.14 2.08 2.06 2.13 seconds for: ' '.join(x[::-1] for x in s.split())\\n1.27 1.26 1.28 1.28 1.26 seconds for: ' '.join([x[::-1] for x in s.split()])\\n```\\nWith many more words, the double reversal's advantage gets even bigger:\\n```\\n>>> setup = 's = \"Let\\\\'s take LeetCode contest\" * 1000'\\n>>> for stmt in statements:\\n        print ' '.join('%.2f' % timeit(stmt, setup, number=1000) for _ in range(5)), 'seconds for:', stmt\\n\\n0.16 0.14 0.13 0.14 0.14 seconds for: ' '.join(s.split()[::-1])[::-1]\\n0.69 0.71 0.69 0.70 0.70 seconds for: ' '.join(x[::-1] for x in s.split())\\n0.63 0.68 0.63 0.64 0.64 seconds for: ' '.join([x[::-1] for x in s.split()])\\n```",
                "solutionTags": [],
                "code": "```\\ndef reverse_words(s)\\n  s.split.map(&:reverse).join(\" \")\\nend\\n```\n```\\ndef reverse_words(s)\\n  s.split.reverse.join(\" \").reverse\\nend\\n```\n```\\n>>> from timeit import timeit\\n>>> setup = 's = \"Let\\\\'s take LeetCode contest\"'\\n>>> statements = (\"' '.join(s.split()[::-1])[::-1]\",\\n\\t          \"' '.join(x[::-1] for x in s.split())\",\\n\\t          \"' '.join([x[::-1] for x in s.split()])\")\\n>>> for stmt in statements:\\n        print ' '.join('%.2f' % timeit(stmt, setup) for _ in range(5)), 'seconds for:', stmt\\n\\n0.79 0.78 0.80 0.82 0.79 seconds for: ' '.join(s.split()[::-1])[::-1]\\n2.10 2.14 2.08 2.06 2.13 seconds for: ' '.join(x[::-1] for x in s.split())\\n1.27 1.26 1.28 1.28 1.26 seconds for: ' '.join([x[::-1] for x in s.split()])\\n```\n```\\n>>> setup = 's = \"Let\\\\'s take LeetCode contest\" * 1000'\\n>>> for stmt in statements:\\n        print ' '.join('%.2f' % timeit(stmt, setup, number=1000) for _ in range(5)), 'seconds for:', stmt\\n\\n0.16 0.14 0.13 0.14 0.14 seconds for: ' '.join(s.split()[::-1])[::-1]\\n0.69 0.71 0.69 0.70 0.70 seconds for: ' '.join(x[::-1] for x in s.split())\\n0.63 0.68 0.63 0.64 0.64 seconds for: ' '.join([x[::-1] for x in s.split()])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 101906,
                "title": "c-java-clean-code",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != ' ') {   // when i is a non-space\\n                int j = i;\\n                for (; j < s.length() && s[j] != ' '; j++) { } // move j to the next space\\n                reverse(s.begin() + i, s.begin() + j);\\n                i = j - 1;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public String reverseWords(String s) {\\n        char[] ca = s.toCharArray();\\n        for (int i = 0; i < ca.length; i++) {\\n            if (ca[i] != ' ') {   // when i is a non-space\\n                int j = i;\\n                while (j + 1 < ca.length && ca[j + 1] != ' ') { j++; } // move j to the end of the word\\n                reverse(ca, i, j);\\n                i = j;\\n            }\\n        }\\n        return new String(ca);\\n    }\\n\\n    private void reverse(char[] ca, int i, int j) {\\n        for (; i < j; i++, j--) {\\n            char tmp = ca[i];\\n            ca[i] = ca[j];\\n            ca[j] = tmp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != ' ') {   // when i is a non-space\\n                int j = i;\\n                for (; j < s.length() && s[j] != ' '; j++) { } // move j to the next space\\n                reverse(s.begin() + i, s.begin() + j);\\n                i = j - 1;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public String reverseWords(String s) {\\n        char[] ca = s.toCharArray();\\n        for (int i = 0; i < ca.length; i++) {\\n            if (ca[i] != ' ') {   // when i is a non-space\\n                int j = i;\\n                while (j + 1 < ca.length && ca[j + 1] != ' ') { j++; } // move j to the end of the word\\n                reverse(ca, i, j);\\n                i = j;\\n            }\\n        }\\n        return new String(ca);\\n    }\\n\\n    private void reverse(char[] ca, int i, int j) {\\n        for (; i < j; i++, j--) {\\n            char tmp = ca[i];\\n            ca[i] = ca[j];\\n            ca[j] = tmp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664562,
                "title": "simple-clean-c-solution-in-place",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string& s) {\\n        int i = 0;\\n        for (int j = 0; j < s.size(); ++j) {\\n            if (s[j] == \\' \\') {\\n                reverse(s.begin() + i, s.begin() + j);\\n                i = j + 1;\\n            }\\n        }\\n        reverse(s.begin() + i, s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string& s) {\\n        int i = 0;\\n        for (int j = 0; j < s.size(); ++j) {\\n            if (s[j] == \\' \\') {\\n                reverse(s.begin() + i, s.begin() + j);\\n                i = j + 1;\\n            }\\n        }\\n        reverse(s.begin() + i, s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101963,
                "title": "easiest-java-solution-9ms-similar-to-reverse-words-in-a-string-ii",
                "content": "I just wanted to use the same logic as Reverse Words in a String II. \\n\\nStep 1. Convert the string to char[] array\\nStep 2. Whenever I encounter a space ' ' , I call the reverse function ( just to keep the code clean )\\nStep 3. Repeat till the end!\\n\\nHope this helps! Thanks for voting :)\\n\\n\\n    public String reverseWords(String s) \\n    {\\n        char[] s1 = s.toCharArray();\\n        int i = 0;\\n        for(int j = 0; j < s1.length; j++)\\n        {\\n            if(s1[j] == ' ')\\n            {\\n                reverse(s1, i, j - 1);\\n                i = j + 1;\\n            }\\n        }\\n        reverse(s1, i, s1.length - 1);\\n        return new String(s1);\\n    }\\n    \\n    public void reverse(char[] s, int l, int r)\\n    {\\n    \\twhile(l < r)\\n    \\t{\\n    \\t\\tchar temp = s[l];\\n    \\t\\ts[l] = s[r];\\n    \\t\\ts[r] = temp;\\n    \\t\\tl++; r--;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "I just wanted to use the same logic as Reverse Words in a String II. \\n\\nStep 1. Convert the string to char[] array\\nStep 2. Whenever I encounter a space ' ' , I call the reverse function ( just to keep the code clean )\\nStep 3. Repeat till the end!\\n\\nHope this helps! Thanks for voting :)\\n\\n\\n    public String reverseWords(String s) \\n    {\\n        char[] s1 = s.toCharArray();\\n        int i = 0;\\n        for(int j = 0; j < s1.length; j++)\\n        {\\n            if(s1[j] == ' ')\\n            {\\n                reverse(s1, i, j - 1);\\n                i = j + 1;\\n            }\\n        }\\n        reverse(s1, i, s1.length - 1);\\n        return new String(s1);\\n    }\\n    \\n    public void reverse(char[] s, int l, int r)\\n    {\\n    \\twhile(l < r)\\n    \\t{\\n    \\t\\tchar temp = s[l];\\n    \\t\\ts[l] = s[r];\\n    \\t\\ts[r] = temp;\\n    \\t\\tl++; r--;\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 102048,
                "title": "a-couple-of-javascript-o-n-solutions",
                "content": "We can build the reversed words as if we're using a stack:\\n```\\nvar reverseWords = function(s) {\\n    let res = '';\\n    let word = '';\\n    for (let c of s) {\\n        if (c === ' ') {\\n            res += word + c;\\n            word = '';\\n        } else {\\n            word = c + word;\\n        }\\n    }\\n    return res + word;\\n};\\n```\\nOr we can do the splitting stuff:\\n```\\nvar reverseWords = function(s) {\\n    return s.split(' ').map(w => w.split('').reverse().join('')).join(' ');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n    let res = '';\\n    let word = '';\\n    for (let c of s) {\\n        if (c === ' ') {\\n            res += word + c;\\n            word = '';\\n        } else {\\n            word = c + word;\\n        }\\n    }\\n    return res + word;\\n};\\n```\n```\\nvar reverseWords = function(s) {\\n    return s.split(' ').map(w => w.split('').reverse().join('')).join(' ');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051657,
                "title": "python-3-two-pointer-approach-for-the-sake-of-practice",
                "content": "We can do the whole thing manually (without ```split()```). \\n**Idea**:\\ninitilialize two pointers, ```l``` and ```r```.\\nMove the right pointer as long as it\\'s not pointing to the whitespace.\\nIf it finally points to the whitespace, we have a word. Take this word by using slicing, reverse it, and add to ```res```.\\nMove ```r``` and ```l```. Now they point to the character after the whitespace (essentially, it\\'s where the next word starts). \\n\\nOnce the loop ends, we have the last word unproccessed. \\nNeed to add it manually.\\nAdd an extra space to ```res``` (because ```l``` always points to the first character of a word).\\nAdd the reversed word to ```res```. \\nFinally, ```res``` has one extra whitespace in the beginning. It appeared when we were appending the first word. But you can account for this in your ```return``` statement. \\n\\n```\\ndef reverseWords_manual(s):  # O(n) both\\n    res = \\'\\'\\n    l, r = 0, 0\\n    while r < len(s):\\n        if s[r] != \\' \\':\\n            r += 1\\n        elif s[r] == \\' \\':\\n            res += s[l:r + 1][::-1]\\n            r += 1\\n            l = r\\n    res += \\' \\'\\n    res += s[l:r + 2][::-1]\\n    return res[1:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```split()```\n```l```\n```r```\n```res```\n```r```\n```l```\n```res```\n```l```\n```res```\n```res```\n```return```\n```\\ndef reverseWords_manual(s):  # O(n) both\\n    res = \\'\\'\\n    l, r = 0, 0\\n    while r < len(s):\\n        if s[r] != \\' \\':\\n            r += 1\\n        elif s[r] == \\' \\':\\n            res += s[l:r + 1][::-1]\\n            r += 1\\n            l = r\\n    res += \\' \\'\\n    res += s[l:r + 2][::-1]\\n    return res[1:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 102105,
                "title": "c-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        size_t front = 0;\\n        for(int i = 0; i <= s.length(); ++i){\\n            if(i == s.length() || s[i] == ' '){\\n                reverse(&s[front], &s[i]);\\n                front = i + 1;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        size_t front = 0;\\n        for(int i = 0; i <= s.length(); ++i){\\n            if(i == s.length() || s[i] == ' '){\\n                reverse(&s[front], &s[i]);\\n                front = i + 1;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842597,
                "title": "4-ways-easy-understanding-c-faster",
                "content": "```\\n//1.[runtime beats 52.56 %]\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result,word;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                word+=s[i];\\n            }else{\\n                reverse(word.begin(),word.end());\\n                result+=(word);\\n                result+=\" \";\\n                word.clear();\\n            }\\n        }\\n        reverse(word.begin(),word.end());\\n        result+=word;\\n        return result;\\n    }\\n};\\n//2.[faster than 94.78% ]\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        if(s.size()==0) return \"\";\\n        stringstream ss(s);\\n        string word;\\n        string res=\"\";\\n        while(ss>>word){\\n            reverse(word.begin(),word.end());\\n            res+=word;\\n            res+=\" \";\\n        }\\n        res.erase(res.size() - 1);\\n        //or  res.erase(std::prev(res.end())); [faster one]\\n        //or  res.resize(res.size() - 1);\\n        //or  res.pop_back();\\n        return res;\\n    }\\n};\\n//3.[runtime beats 81.51 % ]\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        if(s.size()<=1) return s;\\n        int i=0,j,len=s.size();\\n        while(i<len){\\n            j=i+1;\\n            while(s[j]!=\\' \\' && j<len)  j++;\\n            reverse(s.begin()+i,s.begin()+j);\\n            i=j+1;\\n        }\\n        return s;\\n    }\\n};\\n//4.[faster than 94.66% ]\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i = 0;\\n        for (int j = 0; j < s.size(); ++j) {\\n            if (s[j] == \\' \\') {\\n                reverse(s.begin() + i, s.begin() + j);\\n                i = j + 1;\\n            }\\n        }\\n        reverse(s.begin() + i, s.end());\\n        return s;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.[runtime beats 52.56 %]\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result,word;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                word+=s[i];\\n            }else{\\n                reverse(word.begin(),word.end());\\n                result+=(word);\\n                result+=\" \";\\n                word.clear();\\n            }\\n        }\\n        reverse(word.begin(),word.end());\\n        result+=word;\\n        return result;\\n    }\\n};\\n//2.[faster than 94.78% ]\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        if(s.size()==0) return \"\";\\n        stringstream ss(s);\\n        string word;\\n        string res=\"\";\\n        while(ss>>word){\\n            reverse(word.begin(),word.end());\\n            res+=word;\\n            res+=\" \";\\n        }\\n        res.erase(res.size() - 1);\\n        //or  res.erase(std::prev(res.end())); [faster one]\\n        //or  res.resize(res.size() - 1);\\n        //or  res.pop_back();\\n        return res;\\n    }\\n};\\n//3.[runtime beats 81.51 % ]\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        if(s.size()<=1) return s;\\n        int i=0,j,len=s.size();\\n        while(i<len){\\n            j=i+1;\\n            while(s[j]!=\\' \\' && j<len)  j++;\\n            reverse(s.begin()+i,s.begin()+j);\\n            i=j+1;\\n        }\\n        return s;\\n    }\\n};\\n//4.[faster than 94.66% ]\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i = 0;\\n        for (int j = 0; j < s.size(); ++j) {\\n            if (s[j] == \\' \\') {\\n                reverse(s.begin() + i, s.begin() + j);\\n                i = j + 1;\\n            }\\n        }\\n        reverse(s.begin() + i, s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607912,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**Approach 1: Split and Reverse**\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // custom split template\\n    vector<string> split(string str, char delim) {\\n        string line;\\n        vector<string> res;\\n        stringstream ss(str);\\n        while (getline(ss, line, delim)) res.push_back(line);\\n        return res;\\n    }\\n\\n    string reverseWords(string s) {\\n        // split by \\' \\'\\n        vector<string> v = split(s, \\' \\');\\n        // reverse each string\\n        for(auto &x : v) reverse(x.begin(), x.end());\\n        // construct the answer\\n        string ans;\\n        for(int i = 0; i < v.size(); i++) {\\n            ans += v[i];\\n            // add space after each string except the last one\\n            if(i != v.size() - 1) ans += \" \";\\n        } \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        # step1: split the string\\n        #   split() = [\"Let\\'s\",\"take\",\"LeetCode\",\"contest\"]\\n        # step2: reverse the list \\n        #   s.split()[::-1] = [\"contest\",\"LeetCode\",\"take\",\"Let\\'s\"]\\n        # step3: convert each element to string separated by space\\n        #   \\' \\'.join(s.split()[::-1]) = \"contest LeetCode take Let\\'s\"\\n        # step4: reverse the string \\n        #   \\' \\'.join(s.split()[::-1])[::-1] = \"s\\'teL ekat edoCteeL tsetnoc\"\\n        return \\' \\'.join(s.split()[::-1])[::-1]\\n```\\n\\n**Go**\\n\\n```go\\nfunc reverseWords(s string) string {\\n    // split by space\\n    w := strings.Split(s, \" \")\\n    // iterate each word\\n    for k, v := range w {\\n        // convert to bytes array\\n        b := []byte(v)\\n        // length of current word\\n        n := len(v)\\n        // for each word, we iterate n / 2 times\\n        for i := 0; i < n / 2; i++ {\\n            // swap the characters\\n            b[i], b[n - 1 - i] = b[n - 1 - i], b[i]\\n            // w[k] here is the reversed version of v\\n            w[k] = string(b)\\n        }\\n    }\\n    // build the final string\\n    return strings.Join(w, \" \")\\n}\\n```\\n\\n**TypeScript**\\n\\n```ts\\nfunction reverseWords(s: string): string {\\n    // step 1: split by space\\n    //  s.split(\\' \\') = [ \"Let\\'s\", \\'take\\', \\'LeetCode\\', \\'contest\\' ]\\n    // step 2: for each element, reverse it \\n    //  s.split(\\' \\').map(w => w.split(\\'\\').reverse().join(\\'\\')) = [ \"s\\'teL\", \\'ekat\\', \\'edoCteeL\\', \\'tsetnoc\\' ]\\n    // step 3: join them back\\n    //  s.split(\\' \\').map(w => w.split(\\'\\').reverse().join(\\'\\')).join(\\' \\') = \"s\\'teL ekat edoCteeL tsetnoc\"\\n    return s.split(\\' \\').map(w => w.split(\\'\\').reverse().join(\\'\\')).join(\\' \\')\\n};\\n```\\n\\n**Kotlin**\\n\\n```kotlin\\nclass Solution {\\n    fun reverseWords(s: String): String {\\n        // step 1: split by space\\n        // s.split(\" \") = [Let\\'s, take, LeetCode, contest]\\n        // step 2: reverse each element\\n        // s.split(\" \").map { it.reversed() } = [s\\'teL, ekat, edoCteeL, tsetnoc]\\n        // step 3: join them back\\n        // s.split(\" \").map { it.reversed() }.joinToString(\" \") = \"s\\'teL ekat edoCteeL tsetnoc\"\\n        return s.split(\" \").map { it.reversed() }.joinToString(\" \");\\n    }\\n}\\n```\\n\\n**Approach 2: Two Pointers**\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int l = 0, r = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            // looking for the space index\\n            if (s[i] == \\' \\' || i == n - 1) {\\n                // r is the index before the space\\n                // if s[i] is space, then we want to reverse s[l : i - 1]\\n                // if s[i] is the last character, then we want to reverse s[l : i]\\n                r = i == n - 1 ? i : i - 1;\\n                // swap the character\\n                // e.g. s = `Let\\'s` where l is 0 and r is 4\\n                // Let\\'s -> set\\'L -> s\\'teL\\n                while (l < r) swap(s[l++], s[r--]);\\n                // update left pointer which is i + 1\\n                // i.e. the first index of the next word if applicable\\n                l = i + 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n**Java**\\n\\n```java\\nclass Solution {\\n    public String reverseWords(String s) {\\n        int l = 0, r = 0, n = s.length();\\n        char[] c = s.toCharArray();\\n        for (int i = 0; i < n; i++) {\\n            // looking for the space index\\n            if (c[i] == \\' \\' || i == n - 1) {\\n                // r is the index before the space\\n                // if s[i] is space, then we want to reverse s[l : i - 1]\\n                // if s[i] is the last character, then we want to reverse s[l : i]\\n                r = i == n - 1 ? i : i - 1;\\n                // swap the character\\n                // e.g. s = `Let\\'s` where l is 0 and r is 4\\n                // Let\\'s -> set\\'L -> s\\'teL\\n                while (l < r) {\\n                    char tmp = c[l];\\n                    c[l] = c[r];\\n                    c[r] = tmp;\\n                    l++;\\n                    r--;\\n                }\\n                // update left pointer which is i + 1\\n                // i.e. the first index of the next word if applicable\\n                l = i + 1;\\n            }\\n        }\\n        return new String(c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Go",
                    "Kotlin",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // custom split template\\n    vector<string> split(string str, char delim) {\\n        string line;\\n        vector<string> res;\\n        stringstream ss(str);\\n        while (getline(ss, line, delim)) res.push_back(line);\\n        return res;\\n    }\\n\\n    string reverseWords(string s) {\\n        // split by \\' \\'\\n        vector<string> v = split(s, \\' \\');\\n        // reverse each string\\n        for(auto &x : v) reverse(x.begin(), x.end());\\n        // construct the answer\\n        string ans;\\n        for(int i = 0; i < v.size(); i++) {\\n            ans += v[i];\\n            // add space after each string except the last one\\n            if(i != v.size() - 1) ans += \" \";\\n        } \\n        return ans;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        # step1: split the string\\n        #   split() = [\"Let\\'s\",\"take\",\"LeetCode\",\"contest\"]\\n        # step2: reverse the list \\n        #   s.split()[::-1] = [\"contest\",\"LeetCode\",\"take\",\"Let\\'s\"]\\n        # step3: convert each element to string separated by space\\n        #   \\' \\'.join(s.split()[::-1]) = \"contest LeetCode take Let\\'s\"\\n        # step4: reverse the string \\n        #   \\' \\'.join(s.split()[::-1])[::-1] = \"s\\'teL ekat edoCteeL tsetnoc\"\\n        return \\' \\'.join(s.split()[::-1])[::-1]\\n```\n```go\\nfunc reverseWords(s string) string {\\n    // split by space\\n    w := strings.Split(s, \" \")\\n    // iterate each word\\n    for k, v := range w {\\n        // convert to bytes array\\n        b := []byte(v)\\n        // length of current word\\n        n := len(v)\\n        // for each word, we iterate n / 2 times\\n        for i := 0; i < n / 2; i++ {\\n            // swap the characters\\n            b[i], b[n - 1 - i] = b[n - 1 - i], b[i]\\n            // w[k] here is the reversed version of v\\n            w[k] = string(b)\\n        }\\n    }\\n    // build the final string\\n    return strings.Join(w, \" \")\\n}\\n```\n```ts\\nfunction reverseWords(s: string): string {\\n    // step 1: split by space\\n    //  s.split(\\' \\') = [ \"Let\\'s\", \\'take\\', \\'LeetCode\\', \\'contest\\' ]\\n    // step 2: for each element, reverse it \\n    //  s.split(\\' \\').map(w => w.split(\\'\\').reverse().join(\\'\\')) = [ \"s\\'teL\", \\'ekat\\', \\'edoCteeL\\', \\'tsetnoc\\' ]\\n    // step 3: join them back\\n    //  s.split(\\' \\').map(w => w.split(\\'\\').reverse().join(\\'\\')).join(\\' \\') = \"s\\'teL ekat edoCteeL tsetnoc\"\\n    return s.split(\\' \\').map(w => w.split(\\'\\').reverse().join(\\'\\')).join(\\' \\')\\n};\\n```\n```kotlin\\nclass Solution {\\n    fun reverseWords(s: String): String {\\n        // step 1: split by space\\n        // s.split(\" \") = [Let\\'s, take, LeetCode, contest]\\n        // step 2: reverse each element\\n        // s.split(\" \").map { it.reversed() } = [s\\'teL, ekat, edoCteeL, tsetnoc]\\n        // step 3: join them back\\n        // s.split(\" \").map { it.reversed() }.joinToString(\" \") = \"s\\'teL ekat edoCteeL tsetnoc\"\\n        return s.split(\" \").map { it.reversed() }.joinToString(\" \");\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int l = 0, r = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            // looking for the space index\\n            if (s[i] == \\' \\' || i == n - 1) {\\n                // r is the index before the space\\n                // if s[i] is space, then we want to reverse s[l : i - 1]\\n                // if s[i] is the last character, then we want to reverse s[l : i]\\n                r = i == n - 1 ? i : i - 1;\\n                // swap the character\\n                // e.g. s = `Let\\'s` where l is 0 and r is 4\\n                // Let\\'s -> set\\'L -> s\\'teL\\n                while (l < r) swap(s[l++], s[r--]);\\n                // update left pointer which is i + 1\\n                // i.e. the first index of the next word if applicable\\n                l = i + 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public String reverseWords(String s) {\\n        int l = 0, r = 0, n = s.length();\\n        char[] c = s.toCharArray();\\n        for (int i = 0; i < n; i++) {\\n            // looking for the space index\\n            if (c[i] == \\' \\' || i == n - 1) {\\n                // r is the index before the space\\n                // if s[i] is space, then we want to reverse s[l : i - 1]\\n                // if s[i] is the last character, then we want to reverse s[l : i]\\n                r = i == n - 1 ? i : i - 1;\\n                // swap the character\\n                // e.g. s = `Let\\'s` where l is 0 and r is 4\\n                // Let\\'s -> set\\'L -> s\\'teL\\n                while (l < r) {\\n                    char tmp = c[l];\\n                    c[l] = c[r];\\n                    c[r] = tmp;\\n                    l++;\\n                    r--;\\n                }\\n                // update left pointer which is i + 1\\n                // i.e. the first index of the next word if applicable\\n                l = i + 1;\\n            }\\n        }\\n        return new String(c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607780,
                "title": "java-explained-in-detail-fast-two-pointers-stringbuilder",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n**Java - Two Pointers**\\n\\n```\\nclass Solution {\\n\\n    // Approach:\\n    // Using two pointers, \\'start\\' and \\'end\\', each time \\'end\\' reaches a space, we reverse the words before.\\n    // To reverse, we convert the String \\'s\\' to a char array, then write a method to reverse the char in the array.\\n\\n    public String reverseWords(String s) {\\n        // Convert s into char array.\\n        char[] chars = s.toCharArray();\\n\\n        int start = 0;\\n        int end;\\n        for (end = 0; end <= chars.length; end++) {\\n            // When \\'end\\' reaches a space character \\' \\', reverse the words from \\'start\\' to \\'end\\' - 1 index in \\'chars\\'.\\n            if (end == chars.length || chars[end] == \\' \\') {\\n                reverse(chars, start, end - 1);\\n                // reset the start for the next word.\\n                start = end + 1;\\n            }\\n        }\\n\\n        return new String(chars);\\n    }\\n\\n    // A private method to reverse the char in the array using the \\'start\\' and \\'end\\' pointer.\\n    private void reverse(char[] c, int start, int end) {\\n        while (start < end) {\\n            char tmp = c[end];\\n            c[end] = c[start];\\n            c[start] = tmp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n\\n**Java - StringBuilder**\\n\\n```\\nclass Solution {\\n    // Approach:\\n    // Split the string into String array \\'words\\'.\\n    // Then use a StringBuilder to reverse each words within the \\'words\\' array.\\n    // Note: This approach uses more time and memory than the two pointers, due to the use of StringBuilder.\\n\\n    public String reverseWords(String s) {\\n        // Split the String \\'s\\' using regex \" \".\\n        String[] words = s.split(\" \");\\n\\n        // Reverse each word in the \\'words\\' array.\\n        for (int i = 0; i < words.length; i++) {\\n            words[i] = new StringBuilder(words[i]).reverse().toString();\\n        }\\n\\n        // Build a new String using the \" \" delimiter and return result.\\n        return String.join(\" \", words);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Approach:\\n    // Using two pointers, \\'start\\' and \\'end\\', each time \\'end\\' reaches a space, we reverse the words before.\\n    // To reverse, we convert the String \\'s\\' to a char array, then write a method to reverse the char in the array.\\n\\n    public String reverseWords(String s) {\\n        // Convert s into char array.\\n        char[] chars = s.toCharArray();\\n\\n        int start = 0;\\n        int end;\\n        for (end = 0; end <= chars.length; end++) {\\n            // When \\'end\\' reaches a space character \\' \\', reverse the words from \\'start\\' to \\'end\\' - 1 index in \\'chars\\'.\\n            if (end == chars.length || chars[end] == \\' \\') {\\n                reverse(chars, start, end - 1);\\n                // reset the start for the next word.\\n                start = end + 1;\\n            }\\n        }\\n\\n        return new String(chars);\\n    }\\n\\n    // A private method to reverse the char in the array using the \\'start\\' and \\'end\\' pointer.\\n    private void reverse(char[] c, int start, int end) {\\n        while (start < end) {\\n            char tmp = c[end];\\n            c[end] = c[start];\\n            c[start] = tmp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Approach:\\n    // Split the string into String array \\'words\\'.\\n    // Then use a StringBuilder to reverse each words within the \\'words\\' array.\\n    // Note: This approach uses more time and memory than the two pointers, due to the use of StringBuilder.\\n\\n    public String reverseWords(String s) {\\n        // Split the String \\'s\\' using regex \" \".\\n        String[] words = s.split(\" \");\\n\\n        // Reverse each word in the \\'words\\' array.\\n        for (int i = 0; i < words.length; i++) {\\n            words[i] = new StringBuilder(words[i]).reverse().toString();\\n        }\\n\\n        // Build a new String using the \" \" delimiter and return result.\\n        return String.join(\" \", words);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278841,
                "title": "java-simple-faster-than-99-88-clean-pure-logic-efficient-explained",
                "content": "**Please Upvote if found useful !!!**\\n\\n**The basic idea is to get the first and last index of each word and reverse word with itself using first and last indexes.**\\n\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        final int len = s.length(); // saving the length as constant so as to avoid calling s.length() again and again.\\n        \\n        if(len == 1) // no need to iterate if string is of length 1\\n            return s;\\n        \\n        int firstIndex, lastIndex;\\n        char[] ch = s.toCharArray(); // converting the string into it\\'s corresponding character array\\n        char temp;\\n        \\n        for(int index = 0 ; index < len ; index++){\\n            \\n            firstIndex = index; // store the first index of word\\n            \\n            while(++index < len && ch[index] != \\' \\'); // iterate until space is found i.e. to get the last index of the word\\n            \\n            lastIndex = index - 1; // store the last index of the word\\n            \\n\\t\\t\\t// reverse characters of the word\\n            while(firstIndex < lastIndex){\\n                temp = ch[firstIndex];\\n                ch[firstIndex++] = ch[lastIndex];\\n                ch[lastIndex--] = temp;\\n            }\\n        }\\n        \\n        return new String(ch); // convert the character into string and return it\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        final int len = s.length(); // saving the length as constant so as to avoid calling s.length() again and again.\\n        \\n        if(len == 1) // no need to iterate if string is of length 1\\n            return s;\\n        \\n        int firstIndex, lastIndex;\\n        char[] ch = s.toCharArray(); // converting the string into it\\'s corresponding character array\\n        char temp;\\n        \\n        for(int index = 0 ; index < len ; index++){\\n            \\n            firstIndex = index; // store the first index of word\\n            \\n            while(++index < len && ch[index] != \\' \\'); // iterate until space is found i.e. to get the last index of the word\\n            \\n            lastIndex = index - 1; // store the last index of the word\\n            \\n\\t\\t\\t// reverse characters of the word\\n            while(firstIndex < lastIndex){\\n                temp = ch[firstIndex];\\n                ch[firstIndex++] = ch[lastIndex];\\n                ch[lastIndex--] = temp;\\n            }\\n        }\\n        \\n        return new String(ch); // convert the character into string and return it\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148188,
                "title": "100-o-n-in-java",
                "content": "Idea:\\n1. Convert string to char array to avoid having to deal with separate strings (since concatenation is an expensive operation).\\n2. Go through char array, keeping pointer *start* at the beginning of words and pointer *end* iterating through whole array checking for white space.\\n3. If white space is found, call function reverse() on char array to reverse chars between start and end-1 (inclusive)\\n4. Once loop is finished, start now points to start of last word and end points to the last+1 index of char array\\n5. Thus, need to call reverse once again to reverse the last word.\\n6. Return char array as a String\\n\\n```\\n    public String reverseWords(String s) {\\n        \\n        char[] c = s.toCharArray();\\n        int start = 0, end = 0;\\n        for(; end < c.length; end++){\\n            if(c[end] == \\' \\'){\\n                reverse(c, start, end-1);\\n                start = end+1;\\n            }\\n        }\\n        reverse(c, start, end-1);\\n        return new String(c);\\n    }\\n    \\n    private void reverse(char[] c, int start, int end){\\n        while(start < end){\\n            char tmp = c[end];\\n            c[end] = c[start];\\n            c[start] = tmp;\\n            start++;\\n            end--;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String reverseWords(String s) {\\n        \\n        char[] c = s.toCharArray();\\n        int start = 0, end = 0;\\n        for(; end < c.length; end++){\\n            if(c[end] == \\' \\'){\\n                reverse(c, start, end-1);\\n                start = end+1;\\n            }\\n        }\\n        reverse(c, start, end-1);\\n        return new String(c);\\n    }\\n    \\n    private void reverse(char[] c, int start, int end){\\n        while(start < end){\\n            char tmp = c[end];\\n            c[end] = c[start];\\n            c[start] = tmp;\\n            start++;\\n            end--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541946,
                "title": "javascript-solution-using-the-two-pointers-technique",
                "content": "This solution uses the two pointers technique to reverse the characters in each word of the string. It\\'s middle of the road in time and space complexity and there are definitely better solutions out there, but this one\\'s for the folks looking for a simple explanation.\\n\\nThe highest level of pseudocode for this problem would look like this:\\n1. Split the string into an array of words\\n2. Reverse the characters in each individual word\\n3. Return the recombined string\\n\\nHere\\'s how this code might look:\\n```\\nvar reverseWords = function(s) {\\n\\t// 1. Split the string into an array of words\\n    s = s.split(\\' \\')\\n\\t\\n\\t// 2. Reverse the characters in each individual word\\n    for (let word = 0; word < s.length; word++) {\\n        s[word] = reverse(s[word])\\n    } \\n\\t\\n\\t// 3. Return the recombined string\\n    return s.join(\\' \\')\\n};\\n```\\n\\nBut how do we reverse the characters in a word without using the built in reverse method? This is where the two pointers technique comes in! We\\'ll build a separate helper function,  ```reverse(word)```, to implement this.\\n\\nThe pseudocode for ```reverse(word)``` would look like this:\\n1. Split the word into an array of characters, e.g. ```[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']```\\n2. Initialize our two pointers: ```left``` and ```right```. ```left = 0``` and ```right = word.length - 1``` . So ```word[left] === \\'h\\'``` and ```word[right] === \\'o\\'```.\\n3. Swap ```left``` and ```right```. We need a new variable ```temp``` for this. Now ```word[left] === \\'o\\'``` and ```word[right] === \\'h\\'```.\\n4. Move ```left``` one character to the right and ```right``` one character to the left (```left++, right--)```. This will keep us moving towards the middle of the array. Now ```word[left] === \\'e\\'``` and ```word[right] === \\'l\\'```.\\n5. Repeat steps 1-4 while ```left < right```. Once ```left === right```, we\\'ve reached the middle of the array, and we know all necessary characters have been swapped.\\n6. Join the array and return it as a string\\n\\n```    \\nfunction reverse(word) {\\n\\t// 1. Split the word into an array of characters\\n    word = word.split(\\'\\')\\n\\t\\n\\t// 2. Initialize our two pointers, left and right\\n    for (let left = 0, right = word.length - 1; left < right; left++, right--) {\\n\\t\\t// 3. Swap the left and right characters with the help of a temp variable\\n        const temp = word[left]\\n        word[left] = word[right]\\n        word[right] = temp\\n\\t\\t\\n\\t\\t// 4. Increment left and decrement right to move towards the middle of the array\\n\\t\\t// 5. Repeat the loop while left < right\\n\\t\\t// (The above steps are implemented in the definition of the for loop)\\n    }\\n\\n\\t// 6. Join the array and return it as a string\\n    return word.join(\\'\\')\\n}\\n```\\n\\nCombine these functions and you\\'ve got yourself a solution! Thanks for reading and hope this helps somebody!",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n\\t// 1. Split the string into an array of words\\n    s = s.split(\\' \\')\\n\\t\\n\\t// 2. Reverse the characters in each individual word\\n    for (let word = 0; word < s.length; word++) {\\n        s[word] = reverse(s[word])\\n    } \\n\\t\\n\\t// 3. Return the recombined string\\n    return s.join(\\' \\')\\n};\\n```\n```reverse(word)```\n```reverse(word)```\n```[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']```\n```left```\n```right```\n```left = 0```\n```right = word.length - 1```\n```word[left] === \\'h\\'```\n```word[right] === \\'o\\'```\n```left```\n```right```\n```temp```\n```word[left] === \\'o\\'```\n```word[right] === \\'h\\'```\n```left```\n```right```\n```left++, right--)```\n```word[left] === \\'e\\'```\n```word[right] === \\'l\\'```\n```left < right```\n```left === right```\n```    \\nfunction reverse(word) {\\n\\t// 1. Split the word into an array of characters\\n    word = word.split(\\'\\')\\n\\t\\n\\t// 2. Initialize our two pointers, left and right\\n    for (let left = 0, right = word.length - 1; left < right; left++, right--) {\\n\\t\\t// 3. Swap the left and right characters with the help of a temp variable\\n        const temp = word[left]\\n        word[left] = word[right]\\n        word[right] = temp\\n\\t\\t\\n\\t\\t// 4. Increment left and decrement right to move towards the middle of the array\\n\\t\\t// 5. Repeat the loop while left < right\\n\\t\\t// (The above steps are implemented in the definition of the for loop)\\n    }\\n\\n\\t// 6. Join the array and return it as a string\\n    return word.join(\\'\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2608434,
                "title": "c-two-pointers-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0;\\n        for(int j=0;j<s.length();j++)\\n        {\\n            if(s[j]==\\' \\')\\n            {\\n                reverse(s.begin()+i,s.begin()+j);\\n                i=j+1;\\n            }\\n        }\\n        reverse(s.begin()+i,s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0;\\n        for(int j=0;j<s.length();j++)\\n        {\\n            if(s[j]==\\' \\')\\n            {\\n                reverse(s.begin()+i,s.begin()+j);\\n                i=j+1;\\n            }\\n        }\\n        reverse(s.begin()+i,s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101905,
                "title": "short-java-code-without-explanation",
                "content": "```\\n    public String reverseWords(String s) {\\n        String[] str = s.split(\" \");\\n        for (int i = 0; i < str.length; i++) str[i] = new StringBuilder(str[i]).reverse().toString();\\n        StringBuilder result = new StringBuilder();\\n        for (String st : str) result.append(st + \" \");\\n        return result.toString().trim();\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\n    public String reverseWords(String s) {\\n        String[] str = s.split(\" \");\\n        for (int i = 0; i < str.length; i++) str[i] = new StringBuilder(str[i]).reverse().toString();\\n        StringBuilder result = new StringBuilder();\\n        for (String st : str) result.append(st + \" \");\\n        return result.toString().trim();\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 926023,
                "title": "python-3-liner-easy-solution-split-and-reverse",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        split_list = s.split(\" \")\\n        split_list = [i[::-1] for i in split_list]\\n        return \" \".join(split_list)\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        split_list = s.split(\" \")\\n        split_list = [i[::-1] for i in split_list]\\n        return \" \".join(split_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607953,
                "title": "c-stringstream-related-problems",
                "content": "**Approach**\\n- Use C++ stringstream class and getline function.\\n- The getline function will run for n times, where n is the number of words in string separated by space. \\n- We will just reverse each of those words and add them into our answer.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream ss(s);\\n        string t, ans;\\n        \\n        while (getline(ss, t, \\' \\')) {\\n            reverse(t.begin(), t.end());\\n            ans += t + \\' \\';\\n        }\\n        // We will take substring of one less size as there will be space after last word which is not required.\\n        return ans.substr(0, ans.size() - 1); \\n    }\\n};\\n```\\n\\n**Stringstream Related Problems**\\n[1. Find Duplicate File in System ](https://leetcode.com/problems/find-duplicate-file-in-system/)\\n[2. Apply Discount to Prices ](https://leetcode.com/problems/apply-discount-to-prices/)\\n[3. Reverse Words in a String III ](https://leetcode.com/problems/reverse-words-in-a-string-iii/)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream ss(s);\\n        string t, ans;\\n        \\n        while (getline(ss, t, \\' \\')) {\\n            reverse(t.begin(), t.end());\\n            ans += t + \\' \\';\\n        }\\n        // We will take substring of one less size as there will be space after last word which is not required.\\n        return ans.substr(0, ans.size() - 1); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765753,
                "title": "c-efficient-two-pointers-in-place-o-1-space-with-comments",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0;\\n        for(int j=0;j<s.size();j++){\\n            if(s[j]==\\' \\'){\\n                reverse(s.begin()+i, s.begin()+j);//when find a space just reverse the word;\\n                i=j+1;//update j pointer for next reversal\\n            }\\n        }\\n        reverse(s.begin()+i,s.end());//explicitely reverse the last word,as the last word don\\'t has \\' \\'(space) in the end;\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0;\\n        for(int j=0;j<s.size();j++){\\n            if(s[j]==\\' \\'){\\n                reverse(s.begin()+i, s.begin()+j);//when find a space just reverse the word;\\n                i=j+1;//update j pointer for next reversal\\n            }\\n        }\\n        reverse(s.begin()+i,s.end());//explicitely reverse the last word,as the last word don\\'t has \\' \\'(space) in the end;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102004,
                "title": "c-solution",
                "content": "```\\nvoid reverse(int b, int e, char *s){\\n    while(b < e) {\\n        s[b] = s[b] ^ s[e];\\n        s[e] = s[b] ^ s[e];\\n        s[b] = s[b] ^ s[e];\\n        b++;\\n        e--;\\n    }\\n}\\n\\nchar* reverseWords(char* s) {\\n    int i, s_len = strlen(s), index = 0;\\n    \\n    for(i = 0; i <= s_len; i++) {\\n        if((s[i] == ' ') || (s[i] == '\\\\0')){\\n            reverse(index, i - 1, s);\\n            index = i + 1;\\n        }\\n    }\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverse(int b, int e, char *s){\\n    while(b < e) {\\n        s[b] = s[b] ^ s[e];\\n        s[e] = s[b] ^ s[e];\\n        s[b] = s[b] ^ s[e];\\n        b++;\\n        e--;\\n    }\\n}\\n\\nchar* reverseWords(char* s) {\\n    int i, s_len = strlen(s), index = 0;\\n    \\n    for(i = 0; i <= s_len; i++) {\\n        if((s[i] == ' ') || (s[i] == '\\\\0')){\\n            reverse(index, i - 1, s);\\n            index = i + 1;\\n        }\\n    }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101997,
                "title": "1-line-python",
                "content": "Straightforward one.\\n```\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return \" \".join(map(lambda x: x[::-1], s.split()))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return \" \".join(map(lambda x: x[::-1], s.split()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608012,
                "title": "python3-4-lines-or-1-w-example-beginner-friendly-t-m-97-82",
                "content": "```\\nclass Solution:                 # Two versions-- first is a step-by-step walk-through of the solution. The second \\n                                #                is a one-liner. Each run in O(n)/O(n).\\n \\n# first---------------------------------------------\\n\\t\\tdef reverseWords(self, s: str) -> str:                  #  Ex: \"Let\\'s take LeetCode contest\"\\n\\n\\t\\t\\twords = s.split()                                   #      [\"Let\\'s\", \"take\", \"LeetCode\", \"contest\"]\\n\\n\\t\\t\\twords = [word[::-1] for word in words]              #      [\"s\\'teL\", \"ekat\", \"edoCteeL\", \"tsetnoc\"]\\n\\n\\t\\t\\twords = \\' \\'.join(words)                             #      \"s\\'teL ekat edoCteeL tsetnoc\"\\n\\n            return words\\n\\t\\t\\n# second---------------------------------------------\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join([word[::-1] for word in s.split()])     #      \"s\\'teL ekat edoCteeL tsetnoc\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:                 # Two versions-- first is a step-by-step walk-through of the solution. The second \\n                                #                is a one-liner. Each run in O(n)/O(n).\\n \\n# first---------------------------------------------\\n\\t\\tdef reverseWords(self, s: str) -> str:                  #  Ex: \"Let\\'s take LeetCode contest\"\\n\\n\\t\\t\\twords = s.split()                                   #      [\"Let\\'s\", \"take\", \"LeetCode\", \"contest\"]\\n\\n\\t\\t\\twords = [word[::-1] for word in words]              #      [\"s\\'teL\", \"ekat\", \"edoCteeL\", \"tsetnoc\"]\\n\\n\\t\\t\\twords = \\' \\'.join(words)                             #      \"s\\'teL ekat edoCteeL tsetnoc\"\\n\\n            return words\\n\\t\\t\\n# second---------------------------------------------\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join([word[::-1] for word in s.split()])     #      \"s\\'teL ekat edoCteeL tsetnoc\"",
                "codeTag": "Java"
            },
            {
                "id": 1644341,
                "title": "fastest-java-solution",
                "content": "**Runtime: 2 ms**, faster than 99.75% of Java online submissions\\n**Memory Usage: 39.3 MB**, less than 95.75% of Java online submissions\\n\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        char[] c = s.toCharArray();\\n        int i = 0, j = 0;\\n        for (;j<c.length;j++) {\\n            if (c[j] == \\' \\') {\\n                reverseWord(c, i, j-1);\\n                i = j+1;\\n            } \\n        }\\n        reverseWord(c, i, j-1);\\n        return new String(c);\\n    }\\n    \\n    private void reverseWord(char[] c, int i, int j) {\\n        while (i < j) {\\n            char temp = c[i];\\n            c[i++] = c[j];\\n            c[j--] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        char[] c = s.toCharArray();\\n        int i = 0, j = 0;\\n        for (;j<c.length;j++) {\\n            if (c[j] == \\' \\') {\\n                reverseWord(c, i, j-1);\\n                i = j+1;\\n            } \\n        }\\n        reverseWord(c, i, j-1);\\n        return new String(c);\\n    }\\n    \\n    private void reverseWord(char[] c, int i, int j) {\\n        while (i < j) {\\n            char temp = c[i];\\n            c[i++] = c[j];\\n            c[j--] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379194,
                "title": "c-fast-solution-inplace-16ms",
                "content": "Runtime: 16 ms, faster than 96.91% of C++ online submissions for Reverse Words in a String III.\\nMemory Usage: 11.6 MB, less than 100.00% of C++ online submissions for Reverse Words in a String III.\\n\\n```\\nstring reverseWords(string s) {\\n    \\n        int front = 0;\\n        for(int i=0; i<=s.size(); i++)\\n        {\\n            if(i == s.size() || s[i] == \\' \\')\\n            {\\n                reverse(&s[front], &s[i]);\\n                front = i+1;\\n            }\\n        }\\n        return s;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 16 ms, faster than 96.91% of C++ online submissions for Reverse Words in a String III.\\nMemory Usage: 11.6 MB, less than 100.00% of C++ online submissions for Reverse Words in a String III.\\n\\n```\\nstring reverseWords(string s) {\\n    \\n        int front = 0;\\n        for(int i=0; i<=s.size(); i++)\\n        {\\n            if(i == s.size() || s[i] == \\' \\')\\n            {\\n                reverse(&s[front], &s[i]);\\n                front = i+1;\\n            }\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1694956,
                "title": "c-solution-with-detailed-explanation-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/d0f4eb62-47be-4e1b-97ba-fc60e9a6c931_1642349254.7453952.jpeg)\\n\\n```\\nstring reverseWords(string s) {\\n        int l = 0, r = 0;\\n        while(l < s.size()){\\n            while(r < s.size() && s[r] != \\' \\'){\\n                r++;\\n            }\\n            reverse(s.begin() + l, s.begin() + r);\\n            l = r+1;\\n            r = l;\\n        }\\n        return s;\\n    }\\n```\\n\\nIf you understood this solution encourage me by giving me a vote up :) Feel free to ask doubts",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring reverseWords(string s) {\\n        int l = 0, r = 0;\\n        while(l < s.size()){\\n            while(r < s.size() && s[r] != \\' \\'){\\n                r++;\\n            }\\n            reverse(s.begin() + l, s.begin() + r);\\n            l = r+1;\\n            r = l;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2608798,
                "title": "easy-video-explanation-c-strings",
                "content": "https://www.youtube.com/watch?v=QazRBvt6-ag\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s)\\n    {\\n        int i=0;\\n        \\n          for(int j=0; j<s.size(); j++)\\n          {\\n              if(s[j] == \\' \\')\\n              {\\n                  reverse(s.begin()+i, s.begin()+j);\\n                  i = j+1;\\n              }\\n          }\\n        \\n        reverse(s.begin()+i,s.end());\\n        \\n        return s;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s)\\n    {\\n        int i=0;\\n        \\n          for(int j=0; j<s.size(); j++)\\n          {\\n              if(s[j] == \\' \\')\\n              {\\n                  reverse(s.begin()+i, s.begin()+j);\\n                  i = j+1;\\n              }\\n          }\\n        \\n        reverse(s.begin()+i,s.end());\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605550,
                "title": "python-two-pointers",
                "content": "Didn\\'t see many python solutions doing it with two pointers so sharing my code.\\n\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        \\n        left, right = 0, 0\\n        res = []\\n        while right < len(s):\\n            if s[right] == \\' \\':\\n                cur_word = s[left:right]\\n                res.append(cur_word[::-1])\\n                left = right + 1\\n        \\n            right += 1\\n        \\n        res.append(s[left:right][::-1])\\n        \\n        return \" \".join(res)\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        \\n        left, right = 0, 0\\n        res = []\\n        while right < len(s):\\n            if s[right] == \\' \\':\\n                cur_word = s[left:right]\\n                res.append(cur_word[::-1])\\n                left = right + 1\\n        \\n            right += 1\\n        \\n        res.append(s[left:right][::-1])\\n        \\n        return \" \".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422907,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.strip().split()                   #Converting s into a list to get rid of spaces\\n        out = []\\n        for word in s:                          #Reversing each word of the list using two-pointers\\n            i = 0\\n            j = (len(word) - 1)\\n            while (i < j):\\n                word = list(word)\\n                word[i], word[j] = word[j], word[i]\\n                i += 1\\n                j -= 1\\n            a = (\\'\\'.join(word))\\n            out.append(a)\\n        return(\\' \\'.join(out))                     #joining the words back to form a string",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.strip().split()                   #Converting s into a list to get rid of spaces\\n        out = []\\n        for word in s:                          #Reversing each word of the list using two-pointers\\n            i = 0\\n            j = (len(word) - 1)\\n            while (i < j):\\n                word = list(word)\\n                word[i], word[j] = word[j], word[i]\\n                i += 1\\n                j -= 1\\n            a = (\\'\\'.join(word))\\n            out.append(a)\\n        return(\\' \\'.join(out))                     #joining the words back to form a string",
                "codeTag": "Java"
            },
            {
                "id": 2074689,
                "title": "100-faster-java-solution-explained",
                "content": "How the code works :\\n1. start and end initially point to index 0\\n2. end goes through the Array/String searching for spaces.\\n3. The start index of the current word (end is on) is stored in start.\\n4. When a space is found, start and end index of the word is passed to the reverse function where it is reversed by two pointers method.\\n5. Now start stores the start index of the next word and end goes searching for the next space.\\n6. The process repeats until end has traversed the whole array.\\nFinally, we call reverse() once more to reverse the last word as there isn\\'t a space after the last word.\\n```\\nclass Solution{\\n    public String reverseWords(String s) {\\n            char[] c = s.toCharArray();\\n            int start = 0, end = 0;\\n            for(; end < c.length; end++){\\n                if(c[end] == \\' \\'){\\n                    reverse(c, start, end-1);\\n                    start = end+1;\\n                }\\n            }\\n            reverse(c, start, end-1);\\n            return new String(c);\\n        }\\n        private void reverse(char[] c, int start, int end){\\n            while(start < end){\\n                char tmp = c[end];\\n                c[end] = c[start];\\n                c[start] = tmp;\\n                start++;\\n                end--;\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution{\\n    public String reverseWords(String s) {\\n            char[] c = s.toCharArray();\\n            int start = 0, end = 0;\\n            for(; end < c.length; end++){\\n                if(c[end] == \\' \\'){\\n                    reverse(c, start, end-1);\\n                    start = end+1;\\n                }\\n            }\\n            reverse(c, start, end-1);\\n            return new String(c);\\n        }\\n        private void reverse(char[] c, int start, int end){\\n            while(start < end){\\n                char tmp = c[end];\\n                c[end] = c[start];\\n                c[start] = tmp;\\n                start++;\\n                end--;\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369482,
                "title": "python-lovely-1-liner-70-faster",
                "content": "```\\n class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join([w[::-1] for w in s.split(\\' \\')])\\n```\\n\\u2764\\uFE0F",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join([w[::-1] for w in s.split(\\' \\')])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229022,
                "title": "java-100-faster-clean-code",
                "content": "# Complexity\\n- Time complexity:O(N);\\n\\n- Space complexity:O(1)\\n\\n******PLEASE UPVOTE IF IT HELPS YOU******\\n\\n# Code\\n```\\nclass Solution {\\n    public static String reverseWords(String s) {\\n        String[] str = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String value : str) {\\n            char[] c = value.toCharArray();\\n            swap(c,0,c.length);\\n            sb.append(c).append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n\\n    //swapping the array;\\n    public static void swap(char[] c, int i, int j) {\\n        i = 0;\\n        j = c.length - 1;\\n        while (i < j) {\\n            char temp = c[i];\\n            c[i] = c[j];\\n            c[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public static String reverseWords(String s) {\\n        String[] str = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String value : str) {\\n            char[] c = value.toCharArray();\\n            swap(c,0,c.length);\\n            sb.append(c).append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n\\n    //swapping the array;\\n    public static void swap(char[] c, int i, int j) {\\n        i = 0;\\n        j = c.length - 1;\\n        while (i < j) {\\n            char temp = c[i];\\n            c[i] = c[j];\\n            c[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479068,
                "title": "o-n-javascript-solution-without-built-in-function",
                "content": "```\\nvar reverseWords = function(s) {\\n    let result = \\'\\'\\n    let word = \\'\\'\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        let val = s[i]\\n        if (val !== \\' \\') { \\n            word = val + word \\n        }\\n        else {\\n            result += (word + val)\\n            word = \\'\\'\\n        }\\n    }\\n    \\n    return result += (word)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n    let result = \\'\\'\\n    let word = \\'\\'\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        let val = s[i]\\n        if (val !== \\' \\') { \\n            word = val + word \\n        }\\n        else {\\n            result += (word + val)\\n            word = \\'\\'\\n        }\\n    }\\n    \\n    return result += (word)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 102091,
                "title": "c-solution-with-istringstream",
                "content": "``` cpp\\nstring reverseWords(string s) {\\n\\tistringstream iss{s};\\n\\tauto iter = s.begin();\\n\\tfor (string word; iss >> word;) {\\n\\t\\titer = copy(word.rbegin(), word.rend(), iter);\\n\\t\\tif (iter != s.end())\\n\\t\\t\\t++iter;\\n\\t}\\n\\treturn s;\\n}\\n```",
                "solutionTags": [],
                "code": "``` cpp\\nstring reverseWords(string s) {\\n\\tistringstream iss{s};\\n\\tauto iter = s.begin();\\n\\tfor (string word; iss >> word;) {\\n\\t\\titer = copy(word.rbegin(), word.rend(), iter);\\n\\t\\tif (iter != s.end())\\n\\t\\t\\t++iter;\\n\\t}\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2608315,
                "title": "3-lines-java-code-super-simple-to-understand",
                "content": "```\\n        String res=\"\";\\n        for(String str: s.split(\" \")) res+=new StringBuilder(str).reverse().toString()+\" \";\\n        return res.trim();\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n        String res=\"\";\\n        for(String str: s.split(\" \")) res+=new StringBuilder(str).reverse().toString()+\" \";\\n        return res.trim();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607917,
                "title": "c-java-just-6-lines",
                "content": "\\n\\n# 1) [C++]Using stringstream\\n\\n\\n> More information regarding the C++ `stringstream` function may be found here.  **[link](https://cplusplus.com/reference/sstream/stringstream/stringstream/)**\\n> \\n\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s, string ans = \"\", string temp = \"\") {\\n        stringstream ss(s);\\n        while(ss >> temp){\\n            reverse(temp.begin(), temp.end());\\n            ans += temp + \" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n\\n-----------------------\\n\\n# 2) [C++]Most efficient\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        for(int end = 0, start = 0; end <= s.size(); end++){\\n            if(s[end] == \\' \\' or s[end] == \\'\\\\0\\'){           // The last word is tested using s[i]==\\'\\\\0\\'\\n                reverse(s.begin()+start, s.begin()+end);\\n                start = end+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n------------------------\\n\\n# [Java] :\\n\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String ans[] = s.split(\"\\\\\\\\s\"), reverseWord = \"\";\\n        for(String word : ans) reverseWord += new StringBuilder(word).reverse().toString() + \" \";\\n        return reverseWord.trim(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s, string ans = \"\", string temp = \"\") {\\n        stringstream ss(s);\\n        while(ss >> temp){\\n            reverse(temp.begin(), temp.end());\\n            ans += temp + \" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        for(int end = 0, start = 0; end <= s.size(); end++){\\n            if(s[end] == \\' \\' or s[end] == \\'\\\\0\\'){           // The last word is tested using s[i]==\\'\\\\0\\'\\n                reverse(s.begin()+start, s.begin()+end);\\n                start = end+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String ans[] = s.split(\"\\\\\\\\s\"), reverseWord = \"\";\\n        for(String word : ans) reverseWord += new StringBuilder(word).reverse().toString() + \" \";\\n        return reverseWord.trim(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194992,
                "title": "python-clean-simple-solution-and-one-liner",
                "content": "\\n# Code\\n\\n## heading :\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        words=s.split()\\n        ans = \"\"\\n        for  i in range(len(words)):\\n            ans += words[i][::-1]\\n            if i != len(words)-1:\\n                ans+=\" \"\\n        return ans\\n```\\n\\n## 1 Liner :\\nI had did same thing which i did above but here in one line. \\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([word[::-1] for word in s.split(\" \")])\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        words=s.split()\\n        ans = \"\"\\n        for  i in range(len(words)):\\n            ans += words[i][::-1]\\n            if i != len(words)-1:\\n                ans+=\" \"\\n        return ans\\n```\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([word[::-1] for word in s.split(\" \")])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608114,
                "title": "c-stringstream-easy-approach",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Intuition:**\\nSince we need to **reverse** the order of **characters** in each word within a sentence while still preserving **whitespace** and **initial** word order. We can use `stringstream` to `split` the **string** into **words** and then `reverse` each word and then **append** it to the **answer** string.\\n\\n**Approach:**\\n* Create a `string stream` `object` and pass the `string` to it.\\n* Create a string to store the `words`.\\n* Create a string to store the `answer`.\\n* Use a `while` loop to iterate over the `string stream` object.\\n* In the `while` loop, use the string stream object to `extract` the `words` and store it in the `word` string.\\n* `Reverse` the `word` string.\\n* `Append` the word string to the `answer` string.\\n* Return the `answer` string.\\n\\n**C++:**\\n```\\nclass Solution{\\npublic:\\n    string reverseWords(string s){\\n        stringstream ss(s);\\n        string word;\\n        string ans = \"\";\\n        while (ss >> word){ // this will read the string word by word\\n            reverse(word.begin(), word.end());\\n            ans += word + \" \";\\n        }\\n        ans.pop_back(); // this line is basically to remove the last space\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n)**, where `n` is the length of the string\\n**Space Complexity:** **O(n)** , where `n` is the length of the string\\n****\\n\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    string reverseWords(string s){\\n        stringstream ss(s);\\n        string word;\\n        string ans = \"\";\\n        while (ss >> word){ // this will read the string word by word\\n            reverse(word.begin(), word.end());\\n            ans += word + \" \";\\n        }\\n        ans.pop_back(); // this line is basically to remove the last space\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332138,
                "title": "simple-python-3-solution-beats-98-three-lines",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n    \\ts = s.split()\\n    \\tfor i in range(len(s)): s[i] = s[i][::-1]\\n    \\treturn \" \".join(s)\\n\\t\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n    \\ts = s.split()\\n    \\tfor i in range(len(s)): s[i] = s[i][::-1]\\n    \\treturn \" \".join(s)\\n\\t\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 320511,
                "title": "c-beats-98-time",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i = 0, j = 0, k;\\n        while(j < s.size()) {\\n            i = j;\\n            while(s[j] != \\' \\' && j < s.size()) j++;\\n            k = j-1;\\n            while(i < k) swap(s[i++], s[k--]);\\n            j++;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i = 0, j = 0, k;\\n        while(j < s.size()) {\\n            i = j;\\n            while(s[j] != \\' \\' && j < s.size()) j++;\\n            k = j-1;\\n            while(i < k) swap(s[i++], s[k--]);\\n            j++;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688073,
                "title": "java-simple-approach",
                "content": "class Solution {\\n    public String reverseWords(String s) {\\n        int n=s.length(),i=0;\\n        String ans=\"\";\\n        while(i<n){\\n            while(i<n && s.charAt(i)==\\' \\')\\n                i++;\\n            int j=i;\\n            while(i<n && s.charAt(i)!=\\' \\')\\n                i++;\\n            if(ans.isEmpty()){\\n                for(int x=i-1;x>=j;x--)\\n                    ans+=s.charAt(x);\\n            }else{\\n                ans+=\" \";\\n                for(int x=i-1;x>=j;x--)\\n                    ans+=s.charAt(x);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String reverseWords(String s) {\\n        int n=s.length(),i=0;\\n        String ans=\"\";\\n        while(i<n){\\n            while(i<n && s.charAt(i)==\\' \\')\\n                i++;\\n            int j=i;\\n            while(i<n && s.charAt(i)!=\\' \\')\\n                i++;\\n            if(ans.isEmpty()){\\n                for(int x=i-1;x>=j;x--)\\n                    ans+=s.charAt(x);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1640310,
                "title": "rust-0ms-2-2mb",
                "content": "```\\n    pub fn reverse_words(s: String) -> String {\\n        s\\n        .chars()\\n        .rev()\\n        .collect::<String>()\\n        .split_whitespace()\\n        .rev()\\n        .collect::<Vec<_>>()\\n        .join(\" \")\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn reverse_words(s: String) -> String {\\n        s\\n        .chars()\\n        .rev()\\n        .collect::<String>()\\n        .split_whitespace()\\n        .rev()\\n        .collect::<Vec<_>>()\\n        .join(\" \")\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 424292,
                "title": "98-simple-js-solution",
                "content": "~~~\\nlet reverse = (start, end, array) => {\\n    while(start < end) {\\n        let temp = array[start];\\n        array[start] = array[end];\\n        array[end] = temp;\\n        start++;\\n        end--; \\n    }\\n}\\nvar reverseWords = function(s) {\\n    let copy = [...s];\\n    let i = 0, j = 0;\\n    while( j < s.length) {\\n        if( copy[j] === \\' \\') {\\n            reverse(i,j-1,copy);\\n            i = j + 1;\\n        }\\n        j++;\\n    }\\n    reverse(i,s.length-1,copy);\\n    return copy.join(\\'\\');\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "~~~\\nlet reverse = (start, end, array) => {\\n    while(start < end) {\\n        let temp = array[start];\\n        array[start] = array[end];\\n        array[end] = temp;\\n        start++;\\n        end--; \\n    }\\n}\\nvar reverseWords = function(s) {\\n    let copy = [...s];\\n    let i = 0, j = 0;\\n    while( j < s.length) {\\n        if( copy[j] === \\' \\') {\\n            reverse(i,j-1,copy);\\n            i = j + 1;\\n        }\\n        j++;\\n    }\\n    reverse(i,s.length-1,copy);\\n    return copy.join(\\'\\');\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2608366,
                "title": "93-faster-easy-approach-reverse-words-in-a-string-iii",
                "content": "```\\nclass Solution {\\npublic:\\n    void help(string &s,int i, int j){\\n        while(i<j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        int n = s.length();\\n        int i = 0, j = 0;\\n        while(j<n){\\n            if(s[j] != \\' \\') j++;\\n            else{\\n                help(s,i,j-1);\\n                j++;\\n                i = j;\\n            }\\n        }\\n        help(s,i,j-1);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(string &s,int i, int j){\\n        while(i<j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        int n = s.length();\\n        int i = 0, j = 0;\\n        while(j<n){\\n            if(s[j] != \\' \\') j++;\\n            else{\\n                help(s,i,j-1);\\n                j++;\\n                i = j;\\n            }\\n        }\\n        help(s,i,j-1);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155460,
                "title": "java-solution",
                "content": "I think we **probably are not allowed** to use any built-in method during the interview. I was given a medium problem during the interview last month with a tech company. I was not allowed to use any built-in method, and the problem was a little bit more complicated. There were one or multiple whitespaces between words, and we have to kept all those whitespace. But anyways, this problem is still a good approach/ practice for these kind of \"Reverse Words in String\" problems.\\n\\n  Below is my solution in Java by using built-in method. (Yes, I use the build-in method in my solution since I don\\'t see it\\'s prohibited in the problem description hahaa).\\n\\n ```\\nclass Solution {\\n    public String reverseWords(String s) \\n    {\\n        // O(n) time | O(n) space\\n        ArrayList<String> res = new ArrayList<>();\\n        String[] strs = s.split(\" \");\\n        \\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(strs[i]).reverse();\\n            res.add(sb.toString());\\n        }             \\n        return String.join(\" \", res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) \\n    {\\n        // O(n) time | O(n) space\\n        ArrayList<String> res = new ArrayList<>();\\n        String[] strs = s.split(\" \");\\n        \\n        for(int i = 0; i < strs.length; i++)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(strs[i]).reverse();\\n            res.add(sb.toString());\\n        }             \\n        return String.join(\" \", res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602450,
                "title": "4-line-python-code-that-beats-94-78",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l = s.split(\\' \\')\\n        for x in range(len(l)):\\n            l[x] = l[x][::-1]\\n        return \\' \\'.join(l)\\n        # Please submit 2-3 time if not getting 94% , and Upvote If you like\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l = s.split(\\' \\')\\n        for x in range(len(l)):\\n            l[x] = l[x][::-1]\\n        return \\' \\'.join(l)\\n        # Please submit 2-3 time if not getting 94% , and Upvote If you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594914,
                "title": "python-super-simple-solution-clear-explanation",
                "content": "**1. Solution**\\n```\\n    def reverseWords(self, s):\\n\\t\\n        words = s.split()\\n        output = \" \".join(word[::-1] for word in words)\\n        \\n        return output\\n```\\n\\t\\t\\n**2. Remarks**\\n* `A.split()` without arguments splits the string by `\" \"` (white space).\\n* `string[::-1]` slices the string backwards, we use it to get the reversed words.\\n* use list comprehension (`x for x in list_of_x`) to get the list of the reversed words.\\n* `x.join(list)` concatenates the elements in list together, with `x` in between as a separater.\\n\\n****Please upvote if you find it useful, and welcome to any further discussion!***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def reverseWords(self, s):\\n\\t\\n        words = s.split()\\n        output = \" \".join(word[::-1] for word in words)\\n        \\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3454693,
                "title": "100-easy-to-understand",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        split the the sentence and store it in array based on \" \"\\n        and access each element of array and reverse it using StringBuilder\\n\\n# Complexity\\n- Time complexity: O(NM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(NM)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words= s.split(\" \");\\n        \\n        StringBuilder res=new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder temp= new StringBuilder(words[i]);\\n            \\n            res.append(temp.reverse());\\n            res.append(\" \");\\n        }\\n        return res.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words= s.split(\" \");\\n        \\n        StringBuilder res=new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder temp= new StringBuilder(words[i]);\\n            \\n            res.append(temp.reverse());\\n            res.append(\" \");\\n        }\\n        return res.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297119,
                "title": "557-time-97-62-and-space-97-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Split the string s into a list of words using the split() method.\\n2. Traverse the list of words using a loop and reverse each word using the slicing technique [::-1].\\n3. Join the reversed words using the join() method with a space separator.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s_list = s.split()\\n        for i in range(len(s_list)):\\n            s_list[i] = s_list[i][::-1]\\n        return \\' \\'.join(s_list)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s_list = s.split()\\n        for i in range(len(s_list)):\\n            s_list[i] = s_list[i][::-1]\\n        return \\' \\'.join(s_list)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126671,
                "title": "easy-to-understand-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder res=new StringBuilder();\\n        int n=s.length();\\n        for(int i=0; i<n; i++){\\n            int j=i;\\n            while(j<n && s.charAt(j) != \\' \\') j++;\\n            for(int a=j-1; a>=i;a--){\\n                res.append(s.charAt(a));\\n            }\\n            i=j;\\n            if(i<n) res.append(\\' \\');\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder res=new StringBuilder();\\n        int n=s.length();\\n        for(int i=0; i<n; i++){\\n            int j=i;\\n            while(j<n && s.charAt(j) != \\' \\') j++;\\n            for(int a=j-1; a>=i;a--){\\n                res.append(s.charAt(a));\\n            }\\n            i=j;\\n            if(i<n) res.append(\\' \\');\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042044,
                "title": "one-liner-python-beats-92",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([word[::-1] for word in s.split(\" \")])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([word[::-1] for word in s.split(\" \")])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609824,
                "title": "c-reverse-in-place-with-std-reverse-using-string-find-first-not-of",
                "content": "### Solution 1: using string::find_first{,_not}_of and std::reverse\\n\\nWe use ```string::find_first_of()``` and ```string::find_first_not_of()``` to look for the word boundaries and then use ```std::reverse``` to reverse each word in place. What\\'s nice about this approach it will also work correctly even if there is leading or trainling space or if there is more than one space (```\\' \\'```) between words.\\n\\n```\\n    string reverseWords(string s) {\\n        size_t l;\\n        size_t r = 0;\\n        while ((l = s.find_first_not_of(\\' \\', r)) != string::npos) {\\n            r = s.find_first_of(\\' \\', l);\\n            reverse(next(begin(s), l), r == string::npos ? end(s) : next(begin(s), r));\\n        }\\n        return s;\\n    }\\n```\\t\\n\\n**Complexity Analysis**\\n  * Time Complexity: O(n) find and reverse both are linear\\n  * Space Complexity: O(1)\\n\\n_As alwasys: Feedback, comments and questions are welcome. Please upvote if you like the post._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```string::find_first_of()```\n```string::find_first_not_of()```\n```std::reverse```\n```\\' \\'```\n```\\n    string reverseWords(string s) {\\n        size_t l;\\n        size_t r = 0;\\n        while ((l = s.find_first_not_of(\\' \\', r)) != string::npos) {\\n            r = s.find_first_of(\\' \\', l);\\n            reverse(next(begin(s), l), r == string::npos ? end(s) : next(begin(s), r));\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2609648,
                "title": "1-lines-run-time-90-44",
                "content": "```\\nfunction reverseWords(s: string): string {\\n  return s\\n    .split(\" \")  // To take individual words depending on the space, split the string.\\n    .map((word) => \\n\\t\\t\\t\\tword.split(\"\")// To create the string, divide each word into characters, \\n\\t\\t\\t    .reverse() //  reverse those characters,\\n\\t\\t\\t\\t.join(\"\")) //  and then put them back together.\\n.join(\" \"); // build the words, then combine them once more into a string with spaces between them.\\n\\t\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction reverseWords(s: string): string {\\n  return s\\n    .split(\" \")  // To take individual words depending on the space, split the string.\\n    .map((word) => \\n\\t\\t\\t\\tword.split(\"\")// To create the string, divide each word into characters, \\n\\t\\t\\t    .reverse() //  reverse those characters,\\n\\t\\t\\t\\t.join(\"\")) //  and then put them back together.\\n.join(\" \"); // build the words, then combine them once more into a string with spaces between them.\\n\\t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607745,
                "title": "daily-leetcoding-challenge-september-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-words-in-a-string-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Traverse and Reverse each character one by one\n\n  \n**Approach 2:** Using Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-words-in-a-string-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2398037,
                "title": "easy-understandable-solution-in-java-using-stringbuilder-faster-than-69",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        String str[] = s.split(\" \");\\n        StringBuilder msg = new StringBuilder();\\n        \\n        for(int i=0; i<str.length; i++){\\n            for(int j=str[i].length()-1; j>=0; j--){\\n                msg.append(str[i].charAt(j));\\n            }\\n            msg.append(\" \");\\n        }\\n        msg.deleteCharAt(msg.length()-1);\\n        \\n        return msg.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        String str[] = s.split(\" \");\\n        StringBuilder msg = new StringBuilder();\\n        \\n        for(int i=0; i<str.length; i++){\\n            for(int j=str[i].length()-1; j>=0; j--){\\n                msg.append(str[i].charAt(j));\\n            }\\n            msg.append(\" \");\\n        }\\n        msg.deleteCharAt(msg.length()-1);\\n        \\n        return msg.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994142,
                "title": "go-golang-two-easy-to-understand-solutions",
                "content": "##### First & Faster Solution\\n```\\nfunc reverseWords(s string) string {\\n\\tvar res string\\n\\tvar word string\\n\\tfor _, char := range strings.Split(s, \"\") {\\n\\t\\tif char != \" \" {\\n\\t\\t\\tword = char + word\\n\\t\\t} else {\\n\\t\\t\\tres += word + char\\n\\t\\t\\tword = \"\"\\n\\t\\t}\\n\\t}\\n\\treturn res + word\\n}\\n```\\n\\n##### Second Solution\\n```\\nfunc reverseWords(s string) string {\\n\\tvar words = strings.Fields(s)\\n\\tfor i, word := range words {\\n\\t\\twords[i] = reverseString(word)\\n\\t}\\n\\treturn strings.Join(words, \" \")\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tvar l = 0\\n\\tvar r = len(s) - 1\\n\\tfor l < r {\\n\\t\\trunes[l], runes[r] = runes[r], runes[l]\\n\\t\\tl++\\n\\t\\tr--\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseWords(s string) string {\\n\\tvar res string\\n\\tvar word string\\n\\tfor _, char := range strings.Split(s, \"\") {\\n\\t\\tif char != \" \" {\\n\\t\\t\\tword = char + word\\n\\t\\t} else {\\n\\t\\t\\tres += word + char\\n\\t\\t\\tword = \"\"\\n\\t\\t}\\n\\t}\\n\\treturn res + word\\n}\\n```\n```\\nfunc reverseWords(s string) string {\\n\\tvar words = strings.Fields(s)\\n\\tfor i, word := range words {\\n\\t\\twords[i] = reverseString(word)\\n\\t}\\n\\treturn strings.Join(words, \" \")\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tvar l = 0\\n\\tvar r = len(s) - 1\\n\\tfor l < r {\\n\\t\\trunes[l], runes[r] = runes[r], runes[l]\\n\\t\\tl++\\n\\t\\tr--\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745815,
                "title": "python3-one-liner",
                "content": "class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        \\n        return (\" \".join(s[::-1].split()[::-1]))\\n\\t\\t\\nI/P: Hello World\\nLet us first reverse the string. O/P: dlroW olleH\\n\\nSecondly split it. Resultant is an array. O/P: (\\'dlroW\\', \\'olleH\\')\\n\\nReverse the array of individual elements. O/P: (\\'olleH\\', \\'dlroW\\' )\\n\\nLastly join the array elements into the string with \" \" space in between. O/P: olleH dlroW\\n\\nReturn",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        \\n        return (\" \".join(s[::-1].split()[::-1]))\\n\\t\\t\\nI/P: Hello World\\nLet us first reverse the string. O/P: dlroW olleH\\n\\nSecondly split it. Resultant is an array. O/P: (\\'dlroW\\', \\'olleH\\')\\n\\nReverse the array of individual elements. O/P: (\\'olleH\\', \\'dlroW\\' )\\n\\nLastly join the array elements into the string with \" \" space in between. O/P: olleH dlroW\\n\\nReturn",
                "codeTag": "Java"
            },
            {
                "id": 1629104,
                "title": "simple-js-solution",
                "content": "```\\nvar reverseWords = function(s) {\\n    let arrStr = s.split(\\' \\');\\n    let result = [];\\n    for (const item of arrStr) {\\n        result.push(item.split(\\'\\').reverse().join(\\'\\'))\\n    }\\n\\n    return result.join(\\' \\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n    let arrStr = s.split(\\' \\');\\n    let result = [];\\n    for (const item of arrStr) {\\n        result.push(item.split(\\'\\').reverse().join(\\'\\'))\\n    }\\n\\n    return result.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1526615,
                "title": "one-line-beats-95-6-of-python3-submissions",
                "content": "```\\nclass Solution:\\n        def reverseWords(self, s):\\n            return \" \".join([x[::-1] for x in s.split()])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n        def reverseWords(self, s):\\n            return \" \".join([x[::-1] for x in s.split()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472508,
                "title": "4ms-c-easy-solution",
                "content": "**Iterate over the string and reverse each word**\\n**Time complexity:**  O (n), n is length os string\\n**Space complexity:**  O(1)\\n\\n```\\nclass Solution {\\n//funtion to reverse a word\\n    void reverseWord(string &s, int start, int end){\\n        int mid = (start + end) / 2;\\n        for(int i = start; i <= mid; i++, end--)\\n            swap(s[i], s[end]);\\n    }\\npublic:\\n    string reverseWords(string s) {\\n        int n = s.size();\\n        for(int i = 0; i < n; ){\\n\\t\\t//mark the starting of the word\\n            int start = i;\\n\\t\\t\\t//iterate till the end of the word\\n            while(i < n && s[i] != \\' \\')\\n                i++;\\n            reverseWord(s, start, i-1);\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n//funtion to reverse a word\\n    void reverseWord(string &s, int start, int end){\\n        int mid = (start + end) / 2;\\n        for(int i = start; i <= mid; i++, end--)\\n            swap(s[i], s[end]);\\n    }\\npublic:\\n    string reverseWords(string s) {\\n        int n = s.size();\\n        for(int i = 0; i < n; ){\\n\\t\\t//mark the starting of the word\\n            int start = i;\\n\\t\\t\\t//iterate till the end of the word\\n            while(i < n && s[i] != \\' \\')\\n                i++;\\n            reverseWord(s, start, i-1);\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440466,
                "title": "python-without-built-ins-and-one-liners",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        reversed_s = \"\"\\n        current_word = []\\n        \\n        for c in s:\\n            if c == \" \":\\n                reversed_s += self.reverseWord(current_word) + \" \"\\n                current_word = []\\n            else:\\n                current_word.append(c)\\n                \\n        return reversed_s + self.reverseWord(current_word)\\n    \\n    def reverseWord(self, word: List[int]) -> str:\\n        l, r = 0, len(word) - 1\\n        \\n        while l < r:\\n            word[l], word[r] = word[r], word[l]\\n            l += 1\\n            r -= 1\\n        \\n        return \"\".join(word)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        reversed_s = \"\"\\n        current_word = []\\n        \\n        for c in s:\\n            if c == \" \":\\n                reversed_s += self.reverseWord(current_word) + \" \"\\n                current_word = []\\n            else:\\n                current_word.append(c)\\n                \\n        return reversed_s + self.reverseWord(current_word)\\n    \\n    def reverseWord(self, word: List[int]) -> str:\\n        l, r = 0, len(word) - 1\\n        \\n        while l < r:\\n            word[l], word[r] = word[r], word[l]\\n            l += 1\\n            r -= 1\\n        \\n        return \"\".join(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241240,
                "title": "c-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s)\\n    {\\n        int temp = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\' \\')\\n            {\\n                reverse(s.begin()+temp,s.begin()+i);\\n                temp = i+1;\\n            }\\n        }\\n        reverse(s.begin()+temp,s.end());\\n        return s;\\n    }\\n};\\n```\\nIf you like the solution, please upvote;",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s)\\n    {\\n        int temp = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\' \\')\\n            {\\n                reverse(s.begin()+temp,s.begin()+i);\\n                temp = i+1;\\n            }\\n        }\\n        reverse(s.begin()+temp,s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124304,
                "title": "go-solution-beating-100-submissions-8ms-using-analogue-in-place-method-with-explanation",
                "content": "Due to string manipulation in Golang, we have to convert string into []byte. After converting, we can handle the problem in-place so called analogue in-place method. After all, we have to do conversion between String and []byte, and []byte is extra space in this case. \\n\\nWe can traverse byte by byte with O(n), and while meeting Space character, we just start to reverse the preceding characters without Space character. Subsequently, we adopt the same strategy for the following characters right after the previous Space character. \\n\\nThe complexity would be T(2n), for instance, the worst case, only one word as the string. \\n\\n```go\\nfunc reverseWords(s string) string {\\n\\tbs := []byte(s)\\n\\tleft := 0\\n\\tfor i, b := range bs {\\n\\t\\tif b == \\' \\' {\\n\\t\\t\\treverse(&bs, left, i-1)\\n\\t\\t\\tleft = i + 1\\n\\t\\t}\\n\\t}\\n\\treverse(&bs, left, len(bs)-1)\\n\\treturn string(bs)\\n}\\n\\nfunc reverse(src *[]byte, from int, to int) {\\n\\tfor from < to {\\n\\t\\t(*src)[from], (*src)[to] = (*src)[to], (*src)[from]\\n\\t\\tfrom++\\n\\t\\tto--\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc reverseWords(s string) string {\\n\\tbs := []byte(s)\\n\\tleft := 0\\n\\tfor i, b := range bs {\\n\\t\\tif b == \\' \\' {\\n\\t\\t\\treverse(&bs, left, i-1)\\n\\t\\t\\tleft = i + 1\\n\\t\\t}\\n\\t}\\n\\treverse(&bs, left, len(bs)-1)\\n\\treturn string(bs)\\n}\\n\\nfunc reverse(src *[]byte, from int, to int) {\\n\\tfor from < to {\\n\\t\\t(*src)[from], (*src)[to] = (*src)[to], (*src)[from]\\n\\t\\tfrom++\\n\\t\\tto--\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102100,
                "title": "c-o-n-time-in-place-solution",
                "content": "```\\n// OJ: https://leetcode.com/problems/reverse-words-in-a-string-iii\\n// Auther: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n  string reverseWords(string s) {\\n    int begin = 0;\\n    for (int i = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || isspace(s[i])) {\\n            reverse(s.begin() + begin, s.begin() + i);\\n            begin = i + 1;\\n        }\\n    }\\n    return s;\\n  }\\n};\\n```\\n\\nBTW, if without the condition,\\n> Note: In the string, each word is separated by single space and there will not be any extra space in the string.\\n\\nthe code can be as follows\\n\\n```\\n// OJ: https://leetcode.com/problems/reverse-words-in-a-string-iii\\n// Auther: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n  string reverseWords(string s) {\\n    int begin = 0;\\n    while (begin < s.size() && isspace(s[begin])) ++begin;\\n    while (begin < s.size()) {\\n      int end = begin;\\n      while (end < s.size() && !isspace(s[end])) ++end;\\n      reverse(s.begin() + begin, s.begin() + end);\\n      begin = end;\\n      while (begin < s.size() && isspace(s[begin])) ++begin;\\n    }\\n    return s;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// OJ: https://leetcode.com/problems/reverse-words-in-a-string-iii\\n// Auther: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n  string reverseWords(string s) {\\n    int begin = 0;\\n    for (int i = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || isspace(s[i])) {\\n            reverse(s.begin() + begin, s.begin() + i);\\n            begin = i + 1;\\n        }\\n    }\\n    return s;\\n  }\\n};\\n```\n```\\n// OJ: https://leetcode.com/problems/reverse-words-in-a-string-iii\\n// Auther: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n  string reverseWords(string s) {\\n    int begin = 0;\\n    while (begin < s.size() && isspace(s[begin])) ++begin;\\n    while (begin < s.size()) {\\n      int end = begin;\\n      while (end < s.size() && !isspace(s[end])) ++end;\\n      reverse(s.begin() + begin, s.begin() + end);\\n      begin = end;\\n      while (begin < s.size() && isspace(s[begin])) ++begin;\\n    }\\n    return s;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101873,
                "title": "java-solution",
                "content": "    public String reverseWords(String s) {\\n        String[] strs = s.split(\" \");\\n        StringBuffer sb = new StringBuffer();\\n        for(String str: strs){\\n            StringBuffer temp = new StringBuffer(str);\\n            sb.append(temp.reverse());\\n            sb.append(\" \");\\n        }\\n        sb.setLength(sb.length()-1);\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String reverseWords(String s) {\\n        String[] strs = s.split(\" \");\\n        StringBuffer sb = new StringBuffer();\\n        for(String str: strs){\\n            StringBuffer temp = new StringBuffer(str);\\n            sb.append(temp.reverse());\\n            sb.append(\" \");\\n        }\\n        sb.setLength(sb.length()-1);\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3566874,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {        \\n        String arr[] = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String x : arr) {\\n            sb.append(reverse(x)).append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n    public String reverse(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        char arr[] = s.toCharArray();\\n        while(i < j) {\\n            char temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {        \\n        String arr[] = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String x : arr) {\\n            sb.append(reverse(x)).append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n    public String reverse(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        char arr[] = s.toCharArray();\\n        while(i < j) {\\n            char temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417703,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream ss(s);\\n        string temp,ans;\\n        while(ss>>temp){\\n            reverse(temp.begin(),temp.end());\\n            ans+= (temp+\" \");\\n        }\\n        \\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream ss(s);\\n        string temp,ans;\\n        while(ss>>temp){\\n            reverse(temp.begin(),temp.end());\\n            ans+= (temp+\" \");\\n        }\\n        \\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400052,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void reverse(string& s, int left, int right) {\\n        while (left < right) {\\n            swap(s[left++], s[right--]);\\n        }\\n    }\\n    string reverseWords(string s) {\\n        int left = 0;\\n        int right = 0;\\n        while (right < s.size()) {\\n            while (right < s.size() and s[right] != \\' \\') {\\n                ++right;\\n            }\\n            reverse(s, left, right - 1);\\n            ++right;\\n            left = right;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s_list = s.split()\\n        for i in range(len(s_list)):\\n            s_list[i] = s_list[i][::-1]\\n        return \\' \\'.join(s_list)\\n```\\n\\n```Java []\\nimport java.nio.charset.StandardCharsets;\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        if (s.length() == 1) return s;\\n        int start = 0, end = s.indexOf(\\' \\');\\n        byte[] ans = new byte[s.length()];\\n        while (end != -1) {\\n            reverse(ans, s, start, end);\\n            ans[end] = \\' \\';\\n            start = end + 1;\\n            end = s.indexOf(\\' \\', start);\\n        }\\n        reverse(ans, s, start, s.length());\\n        return new String(ans, StandardCharsets.US_ASCII);\\n    }\\n    private static void reverse(byte[] ans, String s, int start, int end) {\\n        int ins = start;\\n        for (int i = end - 1; i >= start; i--) {\\n            ans[ins++] = (byte) s.charAt(i);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void reverse(string& s, int left, int right) {\\n        while (left < right) {\\n            swap(s[left++], s[right--]);\\n        }\\n    }\\n    string reverseWords(string s) {\\n        int left = 0;\\n        int right = 0;\\n        while (right < s.size()) {\\n            while (right < s.size() and s[right] != \\' \\') {\\n                ++right;\\n            }\\n            reverse(s, left, right - 1);\\n            ++right;\\n            left = right;\\n        }\\n        return s;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s_list = s.split()\\n        for i in range(len(s_list)):\\n            s_list[i] = s_list[i][::-1]\\n        return \\' \\'.join(s_list)\\n```\n```Java []\\nimport java.nio.charset.StandardCharsets;\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        if (s.length() == 1) return s;\\n        int start = 0, end = s.indexOf(\\' \\');\\n        byte[] ans = new byte[s.length()];\\n        while (end != -1) {\\n            reverse(ans, s, start, end);\\n            ans[end] = \\' \\';\\n            start = end + 1;\\n            end = s.indexOf(\\' \\', start);\\n        }\\n        reverse(ans, s, start, s.length());\\n        return new String(ans, StandardCharsets.US_ASCII);\\n    }\\n    private static void reverse(byte[] ans, String s, int start, int end) {\\n        int ins = start;\\n        for (int i = end - 1; i >= start; i--) {\\n            ans[ins++] = (byte) s.charAt(i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096706,
                "title": "3-approaches-easy-solutions",
                "content": "\\n\\n# Approach 1\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n    \\n    String[]rev=s.split(\" \");\\n    s=\"\";\\n    for(int i=0;i<rev.length;i++){\\n        \\n        int k=rev[i].length()-1;\\n        String temp=\"\";\\n        while(k>=0){\\n        temp+=rev[i].charAt(k);\\n        k--;\\n        }\\n\\n        if(i!=rev.length-1)\\n        s+=temp+\" \"; \\n        else\\n        s+=temp;  \\n    }\\n    return s;\\n    \\n    }\\n}\\n\\n```\\n# Approach 2\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n    \\n    String[]rev=s.split(\" \");\\n    s=\"\";\\n    for(int i=0;i<rev.length;i++){\\n        StringBuilder st=new StringBuilder();\\n        st.append(rev[i]);\\n        st.reverse();\\n        if(i!=rev.length-1)\\n        s+=st.toString()+\" \"; \\n        else\\n        s+=st.toString();  \\n    }\\n    return s;\\n    \\n    }\\n}\\n```\\n# Approach 3\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n\\n```\\nclass Solution {\\n\\n    public String reverseWords(String s) {\\n\\n        String[] words = s.split(\" \");\\n\\n        for (int i = 0; i < words.length; i++) {\\n            words[i] = new StringBuilder(words[i]).reverse().toString();\\n        }\\n\\n\\n        return String.join(\" \", words);\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n    \\n    String[]rev=s.split(\" \");\\n    s=\"\";\\n    for(int i=0;i<rev.length;i++){\\n        \\n        int k=rev[i].length()-1;\\n        String temp=\"\";\\n        while(k>=0){\\n        temp+=rev[i].charAt(k);\\n        k--;\\n        }\\n\\n        if(i!=rev.length-1)\\n        s+=temp+\" \"; \\n        else\\n        s+=temp;  \\n    }\\n    return s;\\n    \\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n    \\n    String[]rev=s.split(\" \");\\n    s=\"\";\\n    for(int i=0;i<rev.length;i++){\\n        StringBuilder st=new StringBuilder();\\n        st.append(rev[i]);\\n        st.reverse();\\n        if(i!=rev.length-1)\\n        s+=st.toString()+\" \"; \\n        else\\n        s+=st.toString();  \\n    }\\n    return s;\\n    \\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public String reverseWords(String s) {\\n\\n        String[] words = s.split(\" \");\\n\\n        for (int i = 0; i < words.length; i++) {\\n            words[i] = new StringBuilder(words[i]).reverse().toString();\\n        }\\n\\n\\n        return String.join(\" \", words);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959398,
                "title": "c-easy-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int start = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\' \\') {\\n                reverse(s.begin()+start, s.begin()+i);\\n                start = i + 1;\\n            }\\n        }\\n        reverse(s.begin()+start, s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int start = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\' \\') {\\n                reverse(s.begin()+start, s.begin()+i);\\n                start = i + 1;\\n            }\\n        }\\n        reverse(s.begin()+start, s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851656,
                "title": "python-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        a = \"\"\\n        for x in s.split(\" \"):\\n            a += x[::-1] + \" \"\\n\\n        return a[:-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        a = \"\"\\n        for x in s.split(\" \"):\\n            a += x[::-1] + \" \"\\n\\n        return a[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739256,
                "title": "using-stack-98-fastest-solution-c",
                "content": "\\n```Approach 1:```\\n\\n**Using stack**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void fun(stack<char>&st, vector<char>& str)\\n    {\\n        while(!st.empty()){\\n            str.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n    }\\n    string reverseWords(string s) {\\n        vector<char>str;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i == s.length()-1) str.push_back(s[i]);\\n            if(s[i] == \\' \\' || i == s.length()-1)\\n            {\\n                fun(st,str);\\n                if(i != s.length()-1) str.push_back(s[i]);\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n            \\n        }\\n        s.clear();\\n        string res(str.begin(),str.end());\\n        return res;  \\n    }\\n};\\n```\\n\\n```Approach 2:```\\n\\n**easy and best solution** \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        \\n        for (int left = 0; left < s.length(); left++) {\\n            if (s[left] != \\' \\') {   \\n                int right = left;\\n                for (; right < s.length() && s[right] != \\' \\'; right++) { } \\n                reverse(s.begin() + left, s.begin() + right);\\n                left = right;\\n            }\\n        }\\n        \\n        return s;\\n        \\n    }\\n};\\n```\\n\\nHope it will help you \\uD83D\\uDE4C .\\nThank you!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```Approach 1:```\n```\\nclass Solution {\\npublic:\\n    \\n    void fun(stack<char>&st, vector<char>& str)\\n    {\\n        while(!st.empty()){\\n            str.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n    }\\n    string reverseWords(string s) {\\n        vector<char>str;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i == s.length()-1) str.push_back(s[i]);\\n            if(s[i] == \\' \\' || i == s.length()-1)\\n            {\\n                fun(st,str);\\n                if(i != s.length()-1) str.push_back(s[i]);\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n            \\n        }\\n        s.clear();\\n        string res(str.begin(),str.end());\\n        return res;  \\n    }\\n};\\n```\n```Approach 2:```\n```\\nclass Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        \\n        for (int left = 0; left < s.length(); left++) {\\n            if (s[left] != \\' \\') {   \\n                int right = left;\\n                for (; right < s.length() && s[right] != \\' \\'; right++) { } \\n                reverse(s.begin() + left, s.begin() + right);\\n                left = right;\\n            }\\n        }\\n        \\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609596,
                "title": "most-efficient-easy-understandable-solution",
                "content": "# Guys just vote it!!!!\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        char[] c = s.toCharArray();\\n        int i = 0, j = 0;\\n        for (;j<c.length;j++) {\\n            if (c[j] == \\' \\') {\\n                reverseWord(c, i, j-1);\\n                i = j+1;\\n            } \\n        }\\n        reverseWord(c, i, j-1);\\n        return new String(c);\\n    }\\n    \\n    private void reverseWord(char[] c, int i, int j) {\\n        while (i < j) {\\n            char temp = c[i];\\n            c[i++] = c[j];\\n            c[j--] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        char[] c = s.toCharArray();\\n        int i = 0, j = 0;\\n        for (;j<c.length;j++) {\\n            if (c[j] == \\' \\') {\\n                reverseWord(c, i, j-1);\\n                i = j+1;\\n            } \\n        }\\n        reverseWord(c, i, j-1);\\n        return new String(c);\\n    }\\n    \\n    private void reverseWord(char[] c, int i, int j) {\\n        while (i < j) {\\n            char temp = c[i];\\n            c[i++] = c[j];\\n            c[j--] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608983,
                "title": "js-one-line",
                "content": "\\n\\n```\\nconst reverseWords = s => s.split(\" \").map(e=> e.split(\\'\\').reverse().join(\\'\\')).join(\\' \\') \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst reverseWords = s => s.split(\" \").map(e=> e.split(\\'\\').reverse().join(\\'\\')).join(\\' \\') \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2608834,
                "title": "c-0ms-2-pointers-short-simple",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\n**TC** - O(N), **SC** - O(1)\\n\\n\\tvoid reverse(string &s, int i, int j){   //reverses each letter of string\\n        while(i<j){\\n            swap(s[i],s[j]);\\n            i++;j--;\\n        }\\n    }\\n    \\n    string reverseWords(string s) {\\n        int st=0,end=0,n=s.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){                 //when found a space, end=st-1\\n                end=i-1;                   //call reverse function\\n                reverse(s,st,end);         //update st=i+1 i.e. beginning of new word\\n                st=i+1;\\n            }\\n        }\\n        reverse(s,st,n-1);                 //reverse the last word of string\\n        return s;                          //return s\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\n**TC** - O(N), **SC** - O(1)\\n\\n\\tvoid reverse(string &s, int i, int j){   //reverses each letter of string\\n        while(i<j){\\n            swap(s[i],s[j]);\\n            i++;j--;\\n        }\\n    }\\n    \\n    string reverseWords(string s) {\\n        int st=0,end=0,n=s.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){                 //when found a space, end=st-1\\n                end=i-1;                   //call reverse function\\n                reverse(s,st,end);         //update st=i+1 i.e. beginning of new word\\n                st=i+1;\\n            }\\n        }\\n        reverse(s,st,n-1);                 //reverse the last word of string\\n        return s;                          //return s\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2607753,
                "title": "python-solution-one-liner",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(word[::-1] for word in s.split())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(word[::-1] for word in s.split())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543234,
                "title": "appropriate-java-solution",
                "content": "```\\nclass Solution { \\n    StringBuilder ans = new StringBuilder(); \\n   public String reverseWords(String s) { \\n        int start = 0; int end = 0; \\n       for(int len = 0;len < s.length();len++){ \\n           if(len == s.length()-1){\\n               reverse(s, start, s.length()-1); \\n           } \\n           else if(s.charAt(len)==\\' \\'){ \\n               reverse(s, start, end-1); \\n               start = end+1; \\n           } \\n           end++; \\n       } \\n       return ans.toString();\\n   } \\n    void reverse(String s,int start, int end){ \\n        int num = end; \\n        while(end >= start)\\n        { \\n            ans.append(s.charAt(end)); \\n            end--; \\n        } \\n        if(num!= s.length()-1) ans.append(\\' \\'); \\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    StringBuilder ans = new StringBuilder(); \\n   public String reverseWords(String s) { \\n        int start = 0; int end = 0; \\n       for(int len = 0;len < s.length();len++){ \\n           if(len == s.length()-1){\\n               reverse(s, start, s.length()-1); \\n           } \\n           else if(s.charAt(len)==\\' \\'){ \\n               reverse(s, start, end-1); \\n               start = end+1; \\n           } \\n           end++; \\n       } \\n       return ans.toString();\\n   } \\n    void reverse(String s,int start, int end){ \\n        int num = end; \\n        while(end >= start)\\n        { \\n            ans.append(s.charAt(end)); \\n            end--; \\n        } \\n        if(num!= s.length()-1) ans.append(\\' \\'); \\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382551,
                "title": "c-solution-o-n-fast-than-91-72",
                "content": "![image](https://assets.leetcode.com/users/images/e44a3ff3-be84-4618-9dea-077050d2e88c_1659695765.3315072.png)\\n```\\nclass Solution{\\n    public:\\n        string reverseWords(string s) {\\n        int n=s.size(), i=0, k=0;\\n        while(i<n){\\n            if(s[i]==\\' \\'){\\n                reverse(s.begin()+k,s.begin()+i);\\n                k=i+1;\\n            }\\n            i++;\\n        }\\n        reverse(s.begin()+k,s.begin()+i);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n        string reverseWords(string s) {\\n        int n=s.size(), i=0, k=0;\\n        while(i<n){\\n            if(s[i]==\\' \\'){\\n                reverse(s.begin()+k,s.begin()+i);\\n                k=i+1;\\n            }\\n            i++;\\n        }\\n        reverse(s.begin()+k,s.begin()+i);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236792,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n*m)**\\n**Java**\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String words[] = s.split(\" \");\\n        for(int i=0; i<words.length; i++){\\n            words[i] = new StringBuffer(words[i]).reverse().toString();\\n        }\\n        return String.join(\" \", words);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar reverseWords = function(s) {\\n    let words = s.split(\" \")\\n    for(let i=0; i<words.length; i++){\\n        words[i] = words[i].split(\"\").reverse().join(\"\")\\n    }\\n    return words.join(\" \")\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        words = s.split(\\' \\')\\n        for i in range(len(words)):\\n            words[i] = words[i][::-1]\\n        return \" \".join(words) \\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String words[] = s.split(\" \");\\n        for(int i=0; i<words.length; i++){\\n            words[i] = new StringBuffer(words[i]).reverse().toString();\\n        }\\n        return String.join(\" \", words);\\n    }\\n}\\n```\n```\\nvar reverseWords = function(s) {\\n    let words = s.split(\" \")\\n    for(let i=0; i<words.length; i++){\\n        words[i] = words[i].split(\"\").reverse().join(\"\")\\n    }\\n    return words.join(\" \")\\n};\\n```\n```\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        words = s.split(\\' \\')\\n        for i in range(len(words)):\\n            words[i] = words[i][::-1]\\n        return \" \".join(words) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155002,
                "title": "c-easy-solution-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int n=s.length();\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                reverse(s.begin()+j,s.begin()+i);\\n                j=i+1;\\n            }\\n            \\n        }\\n        reverse(s.begin()+j,s.end());\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int n=s.length();\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                reverse(s.begin()+j,s.begin()+i);\\n                j=i+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2120345,
                "title": "easy-java-stream-solution",
                "content": "This isn\\'t the most performant approach, but in my opinion it\\'s the prettiest and the easiest to understand. We will simply split the String on spaces into an array of Strings for each word. Then for each String in that array we will create a new StringBuilder. The StringBuilder will then reverse the characters in that string. Finally we will rejoin all the strings into one with a single space in between them.\\n\\n**Visual**\\nThe String:\\n`Let\\'s code some stuff`\\nis split on spaces\\n`[\"Let\\'s\", \"code\", \"some\", \"stuff\"]`\\nand mapped to StringBuilder instances\\n`[StringBuilder(\"Let\\'s\"), StringBuilder(\"code\"), StringBuilder(\"some\"), StringBuilder(\"stuff\")]`\\nand each StringBuilder is reversed\\n`[StringBuilder(\"s\\'teL\"), StringBuilder(\"edoc\"), StringBuilder(\"emos\"), StringBuilder(\"ffuts\")]`\\nand finally rejoined into a single String\\n`s\\'teL edoc emos ffuts`\\nNote that we don\\'t need to call `toString()` on the StringBuilder objects as that will happen implicitly when they are being rejoined.\\n\\n**Code**\\n```\\npublic String reverseWords(String s) {\\n    return Arrays.stream(s.split(\" \"))\\n                 .map(StringBuilder::new)\\n                 .map(StringBuilder::reverse)\\n                 .collect(Collectors.joining(\" \"));\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String reverseWords(String s) {\\n    return Arrays.stream(s.split(\" \"))\\n                 .map(StringBuilder::new)\\n                 .map(StringBuilder::reverse)\\n                 .collect(Collectors.joining(\" \"));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924524,
                "title": "smart-js-solution-using-2-pointers-o-n",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(s) {\\n    let output = []\\n    let left = 0\\n    for (let right = 0; right < s.length; right++) {\\n        let nextLetter = s[right + 1]\\n        // if next letter is space or end of the line\\n        if (nextLetter === \\' \\' || nextLetter === undefined) {\\n            // traverse back from the right pointer (end of the word) to the left pointer (beginning of the word)\\n            // and push letters to the stack\\n            for (let i = right; i >= left; i--) {\\n                output.push(s[i])\\n            }\\n            if (nextLetter === \\' \\') {\\n                output.push(\\' \\')\\n                // put to the beginning of the next word\\n                left = right + 2\\n            }\\n        }\\n    }\\n    \\n    // convert stack to string\\n    // we cannot use regular strings because they are immutable\\n\\t// instead we use stack and convert into string at once\\n    return output.join(\\'\\')\\n};\\n```\\n\\n### Complexity analysis:\\n**Time:**\\nOverall we traverse through the letters 2 times + converting stack to string will `O(n)` operation\\nWhich gives us `O(3 * n)` which is `just O(n)` where `n` is amount of letters in string\\n\\n**Space:**\\nWe maintain an additional stack which will hold all letter, so it will be **O(n)**, where n is amount of letters in string\\n\\n\\nHope it helps someone!\\nIf so, please smash the up button : )\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(s) {\\n    let output = []\\n    let left = 0\\n    for (let right = 0; right < s.length; right++) {\\n        let nextLetter = s[right + 1]\\n        // if next letter is space or end of the line\\n        if (nextLetter === \\' \\' || nextLetter === undefined) {\\n            // traverse back from the right pointer (end of the word) to the left pointer (beginning of the word)\\n            // and push letters to the stack\\n            for (let i = right; i >= left; i--) {\\n                output.push(s[i])\\n            }\\n            if (nextLetter === \\' \\') {\\n                output.push(\\' \\')\\n                // put to the beginning of the next word\\n                left = right + 2\\n            }\\n        }\\n    }\\n    \\n    // convert stack to string\\n    // we cannot use regular strings because they are immutable\\n\\t// instead we use stack and convert into string at once\\n    return output.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580492,
                "title": "c-simple-in-place-o-n-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) \\n    {\\n        int j=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                reverse(s.begin()+j,s.begin()+i);\\n                j=i+1;\\n            }\\n            else if(i==s.size()-1)\\n            {\\n                reverse(s.begin()+j,s.end());\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) \\n    {\\n        int j=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                reverse(s.begin()+j,s.begin()+i);\\n                j=i+1;\\n            }\\n            else if(i==s.size()-1)\\n            {\\n                reverse(s.begin()+j,s.end());\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1495139,
                "title": "without-extra-space-faster-than-94-c-two-pointer-somewhat-complicated",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        if(s.size()<=1)\\n            return s;\\n        \\n        int left=0;\\n        int right=0;\\n        \\n        while(right<=s.size())\\n        {\\n            if(s[right]==\\' \\' || right==s.size())\\n            {\\n                for(int i=left,j=right-1;i<j;i++,j--)\\n                    swap(s[i],s[j]);\\n                left=right+1;\\n                right++;\\n            }\\n            else\\n                right++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        if(s.size()<=1)\\n            return s;\\n        \\n        int left=0;\\n        int right=0;\\n        \\n        while(right<=s.size())\\n        {\\n            if(s[right]==\\' \\' || right==s.size())\\n            {\\n                for(int i=left,j=right-1;i<j;i++,j--)\\n                    swap(s[i],s[j]);\\n                left=right+1;\\n                right++;\\n            }\\n            else\\n                right++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487608,
                "title": "java-fast-solution",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words = s.split(\" \");\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for (String word : words)\\n            sb.append(\" \").append(reverse(word));\\n        return sb.toString().substring(1);\\n    }\\n    static String reverse(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words = s.split(\" \");\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for (String word : words)\\n            sb.append(\" \").append(reverse(word));\\n        return sb.toString().substring(1);\\n    }\\n    static String reverse(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473547,
                "title": "0ms-c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0;\\n        int j=0;\\n        for(i=0;i<s.length();i++){\\n            j=i;\\n            while(s[i]!=\\' \\' && i<s.length())\\n                i++;\\n            rev(s,j,i-1);\\n        }\\n        return s;\\n    }\\n    void rev(string &s,int i,int j){\\n        while(i<=j){\\n            char t=s[i];\\n            s[i]=s[j];\\n            s[j]=t;\\n            i++;j--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0;\\n        int j=0;\\n        for(i=0;i<s.length();i++){\\n            j=i;\\n            while(s[i]!=\\' \\' && i<s.length())\\n                i++;\\n            rev(s,j,i-1);\\n        }\\n        return s;\\n    }\\n    void rev(string &s,int i,int j){\\n        while(i<=j){\\n            char t=s[i];\\n            s[i]=s[j];\\n            s[j]=t;\\n            i++;j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466234,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int l=0;\\n        int r=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                r=i-1;\\n                while(l<r)\\n                {\\n                    swap(s[l++],s[r--]);\\n                }\\n                l=i+1;\\n            }\\n            \\n            \\n        }\\n        r=s.size()-1;\\n        while(l<r)\\n        {\\n            swap(s[l++],s[r--]);\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int l=0;\\n        int r=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                r=i-1;\\n                while(l<r)\\n                {\\n                    swap(s[l++],s[r--]);\\n                }\\n                l=i+1;\\n            }\\n            \\n            \\n        }\\n        r=s.size()-1;\\n        while(l<r)\\n        {\\n            swap(s[l++],s[r--]);\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170106,
                "title": "rust-4ms",
                "content": "```\\nimpl Solution {\\n    pub fn reverse_words(s: String) -> String {\\n        s\\n            .split(\" \")\\n            .map(|w| w.chars().rev().collect())\\n            .collect::<Vec<String>>()\\n            .join(\" \")\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_words(s: String) -> String {\\n        s\\n            .split(\" \")\\n            .map(|w| w.chars().rev().collect())\\n            .collect::<Vec<String>>()\\n            .join(\" \")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125797,
                "title": "easy-c-solution",
                "content": "Solution for beginners. Please upvote if found useful!!\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string str=\"\", final=\"\";\\n        int n=s.size(),prev=0;\\n        for(int i=0;i<=n;i++){\\n            if(s[i]==\\' \\'||i==n){\\n                str=s.substr(prev,i-prev);\\n                reverse(str.begin(),str.end());\\n                if(prev==0)\\n                    final=final+str+\" \";\\n                else\\n                    final=final+str;\\n                prev=i;\\n            }\\n        }\\n        final = final.substr(0,final.size()-1);\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string str=\"\", final=\"\";\\n        int n=s.size(),prev=0;\\n        for(int i=0;i<=n;i++){\\n            if(s[i]==\\' \\'||i==n){\\n                str=s.substr(prev,i-prev);\\n                reverse(str.begin(),str.end());\\n                if(prev==0)\\n                    final=final+str+\" \";\\n                else\\n                    final=final+str;\\n                prev=i;\\n            }\\n        }\\n        final = final.substr(0,final.size()-1);\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640863,
                "title": "c-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        stringstream ss(s);\\n        \\n        string str, ans;\\n        \\n        while (ss >> str) {\\n            reverse(str.begin(), str.end());\\n            ans += str;\\n            ans += \" \";\\n        }\\n        \\n        ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        stringstream ss(s);\\n        \\n        string str, ans;\\n        \\n        while (ss >> str) {\\n            reverse(str.begin(), str.end());\\n            ans += str;\\n            ans += \" \";\\n        }\\n        \\n        ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484516,
                "title": "python-solution-o-1-space",
                "content": "Slower but uses less space! Looking for any improvements or suggestions on my code :) \\n\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        \\n        # turn the string into a list\\n        s = [i for i in s]\\n        \\n        start, end = 0, 0\\n        while end < len(s): \\n            while s[end] != \" \" and end != len(s) - 1:\\n                end += 1\\n            \\n            # set end to the letter right before the space\\n            if end == len(s) - 1:\\n                right = len(s) - 1\\n            else:\\n                right = end - 1\\n            left = start\\n            # swap them\\n            while left < right:\\n                temp = s[left]\\n                s[left] = s[right]\\n                s[right] = temp\\n                left += 1\\n                right -= 1\\n            start = end + 1\\n            end = end + 1\\n        \\n        return \"\".join([i for i in s])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        \\n        # turn the string into a list\\n        s = [i for i in s]\\n        \\n        start, end = 0, 0\\n        while end < len(s): \\n            while s[end] != \" \" and end != len(s) - 1:\\n                end += 1\\n            \\n            # set end to the letter right before the space\\n            if end == len(s) - 1:\\n                right = len(s) - 1\\n            else:\\n                right = end - 1\\n            left = start\\n            # swap them\\n            while left < right:\\n                temp = s[left]\\n                s[left] = s[right]\\n                s[right] = temp\\n                left += 1\\n                right -= 1\\n            start = end + 1\\n            end = end + 1\\n        \\n        return \"\".join([i for i in s])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401839,
                "title": "javascript-easy-to-understand-solution",
                "content": "```\\nvar reverseWords = function(s) {\\n    \\n    s = s.split(\\'\\').reverse().join(\\'\\');\\n    s = s.split(\\' \\').reverse().join(\\' \\');\\n    \\n    return s;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseWords = function(s) {\\n    \\n    s = s.split(\\'\\').reverse().join(\\'\\');\\n    s = s.split(\\' \\').reverse().join(\\' \\');\\n    \\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398755,
                "title": "swift-one-line",
                "content": "```\\nfunc reverseWords(_ s: String) -> String {\\n\\treturn s.components(separatedBy: \" \")\\n\\t\\t\\t.map { String($0.reversed()) }\\n\\t\\t\\t.joined(separator: \" \")\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc reverseWords(_ s: String) -> String {\\n\\treturn s.components(separatedBy: \" \")\\n\\t\\t\\t.map { String($0.reversed()) }\\n\\t\\t\\t.joined(separator: \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391524,
                "title": "simple-c-solution-faster-than-98-35-submissions",
                "content": "A very simple C# solution using StringBuilder and Split.\\n\\n**Time Complexity:** O(n * m) \\n**Space Complexity:** O(n * m)\\nwhere n is the number of words and m is the word length\\n\\nRuntime: 88 ms, faster than 98.35% of C# online submissions for Reverse Words in a String III.\\nMemory Usage: 31.4 MB, less than 100.00% of C# online submissions for Reverse Words in a String III.\\n\\n    public string ReverseWords(string s) {\\n        StringBuilder sb = new StringBuilder();\\n        string[] words = s.Split(\" \");\\n        \\n        foreach(string word in words){\\n            for(int i = word.Length - 1; i >= 0; i--){\\n                sb.Append(word[i]);\\n            }\\n            sb.Append(\" \");\\n        }\\n        sb.Length--;\\n        \\n        return sb.ToString();\\n    }",
                "solutionTags": [],
                "code": "A very simple C# solution using StringBuilder and Split.\\n\\n**Time Complexity:** O(n * m) \\n**Space Complexity:** O(n * m)\\nwhere n is the number of words and m is the word length\\n\\nRuntime: 88 ms, faster than 98.35% of C# online submissions for Reverse Words in a String III.\\nMemory Usage: 31.4 MB, less than 100.00% of C# online submissions for Reverse Words in a String III.\\n\\n    public string ReverseWords(string s) {\\n        StringBuilder sb = new StringBuilder();\\n        string[] words = s.Split(\" \");\\n        \\n        foreach(string word in words){\\n            for(int i = word.Length - 1; i >= 0; i--){\\n                sb.Append(word[i]);\\n            }\\n            sb.Append(\" \");\\n        }\\n        sb.Length--;\\n        \\n        return sb.ToString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 250262,
                "title": "c-simple-and-fast-using-sringstream",
                "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        string word,d=\"\"; \\n        stringstream iss(s); \\n        while (iss >> word) \\n        {\\n            reverse(word.begin(),word.end());\\n            d+=word+\\' \\';\\n        }\\n        d.pop_back();\\n        return d;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        string word,d=\"\"; \\n        stringstream iss(s); \\n        while (iss >> word) \\n        {\\n            reverse(word.begin(),word.end());\\n            d+=word+\\' \\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 159145,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return \\' \\'.join([w[::-1] for w in s.split()])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return \\' \\'.join([w[::-1] for w in s.split()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101961,
                "title": "c-solution-with-linq",
                "content": "The runtime is not fast, ~135 ms. It's probably the shortest C# solution.\\n\\n```\\npublic string ReverseWords(string s) {\\n        return string.Join(\" \",\\n                s.Split(' ')\\n                .Select(str => new String(str.Reverse().ToArray())));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic string ReverseWords(string s) {\\n        return string.Join(\" \",\\n                s.Split(' ')\\n                .Select(str => new String(str.Reverse().ToArray())));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101977,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar reverseWords = function(s) {\\n    // reverse string word by word\\n    return s.split(' ').reduce((reversed, curr) => {\\n        reversed.push(curr.split('').reverse().join(''))\\n        return reversed;\\n    }, []).join(' ');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n    // reverse string word by word\\n    return s.split(' ').reduce((reversed, curr) => {\\n        reversed.push(curr.split('').reverse().join(''))\\n        return reversed;\\n    }, []).join(' ');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765625,
                "title": "best-c-solution-simple-two-pointer-approach-beats-80-in-both",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0, j=0, n=s.length(); \\n        while(j < n){\\n            if(s[j+1]==\\' \\' || j==n-1){ // j traverse through the word until it reaches its last letter\\n                int k = j;\\n                while(k>=i)\\n                    swap(s[k--], s[i++]); // Reverse the word by swapping its letters\\n                j++;\\n                i = j+1; // i maintains position of first letter of word\\n            }\\n            j++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0, j=0, n=s.length(); \\n        while(j < n){\\n            if(s[j+1]==\\' \\' || j==n-1){ // j traverse through the word until it reaches its last letter\\n                int k = j;\\n                while(k>=i)\\n                    swap(s[k--], s[i++]); // Reverse the word by swapping its letters\\n                j++;\\n                i = j+1; // i maintains position of first letter of word\\n            }\\n            j++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566887,
                "title": "easy-2-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {        \\n        String x = \"\";        \\n        for(String t : s.split(\" \")) \\n            x += new StringBuilder(t).reverse().toString()+\" \";\\n        return x.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {        \\n        String x = \"\";        \\n        for(String t : s.split(\" \")) \\n            x += new StringBuilder(t).reverse().toString()+\" \";\\n        return x.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446935,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s_list = s.split(\" \")\\n        return \" \".join([item[::-1] for item in s_list])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s_list = s.split(\" \")\\n        return \" \".join([item[::-1] for item in s_list])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374522,
                "title": "easy-beginner-friendly-solution-using-array-methods",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(s) {\\n    let sArr = s.split(\" \");\\n    let temp = [];\\n    for(let i=0; i<sArr.length; i++){\\n        temp.push(sArr[i].split(\"\").reverse().join(\"\"));\\n    }return temp.join(\" \");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(s) {\\n    let sArr = s.split(\" \");\\n    let temp = [];\\n    for(let i=0; i<sArr.length; i++){\\n        temp.push(sArr[i].split(\"\").reverse().join(\"\"));\\n    }return temp.join(\" \");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276398,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        s.push_back(\\' \\');\\n        string ans, st;\\n        for(auto c: s) {\\n            if(c == \\' \\') {\\n                reverse(st.begin(), st.end());\\n                ans += st;\\n                ans += \\' \\';\\n                st.clear();\\n            }\\n            else st.push_back(c);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        s.push_back(\\' \\');\\n        string ans, st;\\n        for(auto c: s) {\\n            if(c == \\' \\') {\\n                reverse(st.begin(), st.end());\\n                ans += st;\\n                ans += \\' \\';\\n                st.clear();\\n            }\\n            else st.push_back(c);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113103,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstraight forward :\\n- convert string to character array\\n- take the range of each individual word by index\\n- reverse that word \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we have to converts the string to a character array, and reverses the order of characters in each individual word in the string. and then returns the modified string. It uses two pointers firstIndex and lastIndex to find the first and last index of each word and then reverse the characters between them. It also uses a while loop to iterate through the characters in the array, checking for spaces and identifying the start and end of each word.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        char[] str = s.toCharArray();\\n        int firstIndex = 0; \\n        int lastIndex = 0;\\n\\n        int i = 0; \\n        while (i < s.length()) {\\n            if(str[i] == \\' \\') {\\n                i++;\\n            } else {\\n                if(i == 0 || str[i-1] == \\' \\') {\\n                    firstIndex = i;\\n                }\\n\\n                if(i == s.length() - 1 || str[i+1] == \\' \\') {\\n                    lastIndex = i;\\n                }\\n\\n                if((firstIndex == 0 || str[firstIndex - 1] == \\' \\') && (lastIndex == s.length() - 1 || str[lastIndex + 1] == \\' \\')) {\\n                    while(firstIndex <= lastIndex) {\\n                        char temp = str[firstIndex];\\n                        str[firstIndex] = str[lastIndex];\\n                        str[lastIndex] = temp;\\n\\n                        firstIndex++;\\n                        lastIndex--;\\n                    }\\n                }\\n                i++;\\n            }\\n        }\\n\\n        return s.valueOf(str);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        char[] str = s.toCharArray();\\n        int firstIndex = 0; \\n        int lastIndex = 0;\\n\\n        int i = 0; \\n        while (i < s.length()) {\\n            if(str[i] == \\' \\') {\\n                i++;\\n            } else {\\n                if(i == 0 || str[i-1] == \\' \\') {\\n                    firstIndex = i;\\n                }\\n\\n                if(i == s.length() - 1 || str[i+1] == \\' \\') {\\n                    lastIndex = i;\\n                }\\n\\n                if((firstIndex == 0 || str[firstIndex - 1] == \\' \\') && (lastIndex == s.length() - 1 || str[lastIndex + 1] == \\' \\')) {\\n                    while(firstIndex <= lastIndex) {\\n                        char temp = str[firstIndex];\\n                        str[firstIndex] = str[lastIndex];\\n                        str[lastIndex] = temp;\\n\\n                        firstIndex++;\\n                        lastIndex--;\\n                    }\\n                }\\n                i++;\\n            }\\n        }\\n\\n        return s.valueOf(str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068294,
                "title": "using-double-pointer-runtime-10ms-memory-9-7mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelect a word and reverse it undtill the end of the string\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing two pointer -> First will point the first letter of word and last will point the last letter. Using reverse word using reverse stl. Continue till the string.end()\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int first=0, last=0;\\n        while(last<=s.size()){\\n            if(s[last]==\\' \\' or last==s.size()){\\n                reverse(s.begin()+first, s.begin()+last);\\n                first=last+1;\\n            }\\n            last++;\\n        }\\n        return s;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int first=0, last=0;\\n        while(last<=s.size()){\\n            if(s[last]==\\' \\' or last==s.size()){\\n                reverse(s.begin()+first, s.begin()+last);\\n                first=last+1;\\n            }\\n            last++;\\n        }\\n        return s;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036049,
                "title": "3ms-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        int j=0;\\n        char[]arr=s.toCharArray();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==\\' \\'){\\n                reverse(j,i-1,arr);\\n                j=i+1;\\n            }\\n            else if(i==arr.length-1){\\n                reverse(j,i,arr);\\n            }\\n        }\\n        return new String(arr);\\n    }\\n    public void reverse(int start,int end,char[]arr){\\n        while(start<end){\\n            char temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        int j=0;\\n        char[]arr=s.toCharArray();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==\\' \\'){\\n                reverse(j,i-1,arr);\\n                j=i+1;\\n            }\\n            else if(i==arr.length-1){\\n                reverse(j,i,arr);\\n            }\\n        }\\n        return new String(arr);\\n    }\\n    public void reverse(int start,int end,char[]arr){\\n        while(start<end){\\n            char temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974916,
                "title": "solution-using-java-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        //ex: \"Dog cat\"\\n        String words[]=s.split(\" \");\\n        // get splitted into substring i.e \"Dog\" \"Cat\"\\n        for(int i=0;i<words.length;i++){\\n\\n            StringBuilder st=new StringBuilder(words[i]); //make string mutable\\n            st.reverse(); \\n            words[i]=st.toString(); \\n        }\\n        for(int i=1;i<words.length;i++){\\n            words[0]=words[0]+\" \"+words[i];\\n        }\\n        return words[0];\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        //ex: \"Dog cat\"\\n        String words[]=s.split(\" \");\\n        // get splitted into substring i.e \"Dog\" \"Cat\"\\n        for(int i=0;i<words.length;i++){\\n\\n            StringBuilder st=new StringBuilder(words[i]); //make string mutable\\n            st.reverse(); \\n            words[i]=st.toString(); \\n        }\\n        for(int i=1;i<words.length;i++){\\n            words[0]=words[0]+\" \"+words[i];\\n        }\\n        return words[0];\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799922,
                "title": "557-reverse-words-in-a-string-iii-easy-clear-and-classic-solution-javascript",
                "content": "****Explanation**: **\\n\\n    var reverseWords = function (s) {\\n    // s = \"God Ding\" -------> arrOfWords = [ \\'God\\', \\'Ding\\' ]\\n    let arrOfWords = s.split(\\' \\')  \\n\\n     for(let i = 0; i < arrOfWords.length; ++i) {\\n         // arrOfWords = [ \\'God\\', \\'Ding\\' ] -------> eachWord = \"God\"\\n        let eachWord = arrOfWords[i].split(\\'\\'); \\n        // left = \"G\", right = \"d\"\\n        let left = 0, right = eachWord.length-1; \\n\\n        //here below is : classic swap function\\n\\n        while(left < right) { \\n            // eachWord[right] = \"d\"  -------> temp = \"d\"\\n            let temp = eachWord[right]\\n            // eachWord[left] = \"G\"  -------> eachWord[right] = \"G\"\\n            eachWord[right] = eachWord[left]\\n            // eachWord[left]  -------> temp = \"d\"\\n            eachWord[left] = temp \\n            left++;\\n            right--;\\n        }\\n        // eachWord = \"doG\"  -------> eachWord.join(\\'\\') = [ \\'d\\', \\'o\\', \\'G\\' ]  -------> [ \\'doG\\', \\'Ding\\' ]\\n        arrOfWords[i] = eachWord.join(\\'\\')\\n    }\\n    //after swaping each word ------> arrOfWords[i] = [ \\'doG\\', \\'gniD\\' ]\\n\\n    // arrOfWords[i] = [ \\'doG\\', \\'gniD\\' ] ------> \"doG gniD\"\\n    return arrOfWords.join(\\' \\') \\n};\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function (s) {\\n\\n    let arrOfWords = s.split(\\' \\')  \\n\\n     for(let i = 0; i < arrOfWords.length; ++i) {\\n        let eachWord = arrOfWords[i].split(\\'\\'); \\n        let left = 0, right = eachWord.length-1; \\n        while(left < right) { \\n            let temp = eachWord[right]\\n            eachWord[right] = eachWord[left]\\n            eachWord[left] = temp \\n            left++;\\n            right--;\\n        }\\n        arrOfWords[i] = eachWord.join(\\'\\')\\n    }\\n    \\n    return arrOfWords.join(\\' \\') \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function (s) {\\n\\n    let arrOfWords = s.split(\\' \\')  \\n\\n     for(let i = 0; i < arrOfWords.length; ++i) {\\n        let eachWord = arrOfWords[i].split(\\'\\'); \\n        let left = 0, right = eachWord.length-1; \\n        while(left < right) { \\n            let temp = eachWord[right]\\n            eachWord[right] = eachWord[left]\\n            eachWord[left] = temp \\n            left++;\\n            right--;\\n        }\\n        arrOfWords[i] = eachWord.join(\\'\\')\\n    }\\n    \\n    return arrOfWords.join(\\' \\') \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2746584,
                "title": "python3-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n\\t\\t# convert string into the list of words\\n        words = s.split()\\n\\t\\t# iterate thru the list and reverse each word\\n        for i, w in enumerate(words):\\n            words[i] = w[::-1]\\n\\t\\t# get the string with spaces between each word\\n        return \" \".join(words)\\n```\\n\\nTime complexity - **0(n*m)** where **m** is the length of the word\\nSpace complexity - **0(n)** because we use extra space to store the list of words",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n\\t\\t# convert string into the list of words\\n        words = s.split()\\n\\t\\t# iterate thru the list and reverse each word\\n        for i, w in enumerate(words):\\n            words[i] = w[::-1]\\n\\t\\t# get the string with spaces between each word\\n        return \" \".join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706091,
                "title": "java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        // take array of words\\n        String[] words = s.split(\" \");\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<words.length;i++) {\\n            // array of letters of word\\n            char[] c = words[i].toCharArray();\\n            // reverse array of letters\\n            int n=c.length-1, j=0;\\n            while(j<n) {\\n                char temp = c[j];\\n                c[j] = c[n];\\n                c[n] = temp;\\n                n--;j++;\\n            }\\n            // append to result\\n            sb.append(new String(c));\\n            if(i!=words.length-1) sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        // take array of words\\n        String[] words = s.split(\" \");\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<words.length;i++) {\\n            // array of letters of word\\n            char[] c = words[i].toCharArray();\\n            // reverse array of letters\\n            int n=c.length-1, j=0;\\n            while(j<n) {\\n                char temp = c[j];\\n                c[j] = c[n];\\n                c[n] = temp;\\n                n--;j++;\\n            }\\n            // append to result\\n            sb.append(new String(c));\\n            if(i!=words.length-1) sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681947,
                "title": "js-es6-two-pointers-with-explanation",
                "content": "Two pointers is the use of two different pointers (usually to keep track of array or string indexes) to solve a problem with specified indexes in order to save time and space.\\n\\nTo solve this problem, we just need to split the string into an array of words, after which, iterating over each word, we can also split it into letters. Now we can step over the indices from both ends and swap them (thus swapping letters) until the indices meet in the middle (which means the iteration is over and the word is reversed). At the end, we change the words in our array to inverted, and collect the string again.\\n\\nI hope the picture below will give you a clearer understanding :)\\n\\n![image](https://assets.leetcode.com/users/images/f015d6b7-6b21-4c14-b443-5ae4524279ba_1665326467.8079593.png)\\n\\n```\\nvar reverseWords = function (s) {\\n    let arrOfWords = s.split(\\' \\');\\n\\n    for (let w = 0; w < arrOfWords.length; w++) {\\n        let arrOfLetters = arrOfWords[w].split(\\'\\');\\n        for (let i = 0, j = arrOfLetters.length - 1; i < j;) {\\n            [arrOfLetters[i], arrOfLetters[j]] = [arrOfLetters[j], arrOfLetters[i]];\\n            i++;\\n            j--;\\n        }\\n        arrOfWords[w] = arrOfLetters.join(\\'\\')\\n    }\\n    return arrOfWords.join(\\' \\')\\n};\\n```\\n\\nI hope I was able to explain clearly. Happy coding! \\uD83D\\uDE43\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nvar reverseWords = function (s) {\\n    let arrOfWords = s.split(\\' \\');\\n\\n    for (let w = 0; w < arrOfWords.length; w++) {\\n        let arrOfLetters = arrOfWords[w].split(\\'\\');\\n        for (let i = 0, j = arrOfLetters.length - 1; i < j;) {\\n            [arrOfLetters[i], arrOfLetters[j]] = [arrOfLetters[j], arrOfLetters[i]];\\n            i++;\\n            j--;\\n        }\\n        arrOfWords[w] = arrOfLetters.join(\\'\\')\\n    }\\n    return arrOfWords.join(\\' \\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2609430,
                "title": "c-simple-swap-approach",
                "content": "**Just swap!**\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string ans = \"\";\\n        int i = 0, j = 0, n = s.size();\\n        while(j <= n){\\n            if(j == n || s[j] == \\' \\'){\\n                int k = j;\\n                --j;\\n                while(i < j){\\n                    swap(s[i], s[j]);\\n                    ++i;\\n                    --j;\\n                }\\n                j = k;\\n                i = j+1;\\n            }\\n            ++j;            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string ans = \"\";\\n        int i = 0, j = 0, n = s.size();\\n        while(j <= n){\\n            if(j == n || s[j] == \\' \\'){\\n                int k = j;\\n                --j;\\n                while(i < j){\\n                    swap(s[i], s[j]);\\n                    ++i;\\n                    --j;\\n                }\\n                j = k;\\n                i = j+1;\\n            }\\n            ++j;            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609052,
                "title": "python-java-elegant-short-o-n",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def reverseWords(self, string: str) -> str:\\n        return \\' \\'.join(word[::-1] for word in string.split())\\n```\\n\\n```\\nclass Solution {\\n\\n    /**\\n     * Time:   O(n)\\n     * Memory: O(n)\\n     */\\n    public String reverseWords(String s) {\\n        StringBuilder reversed = new StringBuilder();\\n\\n        for (String word : s.split(\"\\\\\\\\s\"))\\n            reversed.append(new StringBuilder(word).reverse()).append(\" \");\\n\\n        return reversed.toString().trim();\\n    }\\n}\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def reverseWords(self, string: str) -> str:\\n        return \\' \\'.join(word[::-1] for word in string.split())\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * Time:   O(n)\\n     * Memory: O(n)\\n     */\\n    public String reverseWords(String s) {\\n        StringBuilder reversed = new StringBuilder();\\n\\n        for (String word : s.split(\"\\\\\\\\s\"))\\n            reversed.append(new StringBuilder(word).reverse()).append(\" \");\\n\\n        return reversed.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608119,
                "title": "javascript-two-one-liner-solutions-using-array-methods-reduce-map-split-join",
                "content": "Approach 1:\\nUsing Map \\n```\\nvar reverseWords = function(s) {\\n    return s.split(\\' \\').map((word)=>word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\')\\n}\\n```\\nApproach 2:\\nUsing reduce \\n```\\nvar reverseWords = function(s) {\\n    return s.split(\\' \\').reduce((a,b)=>a+\\' \\'+b.split(\\'\\').reverse().join(\\'\\'),\\'\\').trim()\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n    return s.split(\\' \\').map((word)=>word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\')\\n}\\n```\n```\\nvar reverseWords = function(s) {\\n    return s.split(\\' \\').reduce((a,b)=>a+\\' \\'+b.split(\\'\\').reverse().join(\\'\\'),\\'\\').trim()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607836,
                "title": "daily-leetcode-solution-two-pointers-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int n=s.size();\\n        int i=0,j=0;\\n        string ans=\"\";\\n        string temp;\\n        s+=\" \";\\n        while(j<=n)\\n        {\\n\\n            if(s[j]!=\\' \\')\\n            {\\n                temp.push_back(s[j]);\\n                j++;\\n            }\\n            else\\n            {\\n                reverse(temp.begin(),temp.end());\\n                for(int k=0;k<temp.size();k++)\\n                {\\n                    ans+=temp[k];\\n                    i++;\\n                }\\n                ans+=\\' \\';\\n                j++;\\n                i=j;\\n                temp=\"\";\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int n=s.size();\\n        int i=0,j=0;\\n        string ans=\"\";\\n        string temp;\\n        s+=\" \";\\n        while(j<=n)\\n        {\\n\\n            if(s[j]!=\\' \\')\\n            {\\n                temp.push_back(s[j]);\\n                j++;\\n            }\\n            else\\n            {\\n                reverse(temp.begin(),temp.end());\\n                for(int k=0;k<temp.size();k++)\\n                {\\n                    ans+=temp[k];\\n                    i++;\\n                }\\n                ans+=\\' \\';\\n                j++;\\n                i=j;\\n                temp=\"\";\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362014,
                "title": "python-one-liner",
                "content": "```\\nreturn str.join(\\' \\',[w[::-1] for w in s.split(\\' \\')])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nreturn str.join(\\' \\',[w[::-1] for w in s.split(\\' \\')])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2250385,
                "title": "simple-c-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0,start=0;\\n        \\n        while(i<s.size()){\\n            if(s[i]==\\' \\'){\\n                reverse(s.begin()+start, s.begin()+i);\\n                start=i+1;\\n            }\\n            ++i;\\n        }\\n        reverse(s.begin()+start, s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0,start=0;\\n        \\n        while(i<s.size()){\\n            if(s[i]==\\' \\'){\\n                reverse(s.begin()+start, s.begin()+i);\\n                start=i+1;\\n            }\\n            ++i;\\n        }\\n        reverse(s.begin()+start, s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081914,
                "title": "reverse-words-in-a-string-very-simple-solution",
                "content": "eg: \"Let\\'s take LeetCode contest\"\\n\\n*  We will traverse the string from backward so we will get reverse string.\\n*  Basically we store each words in in our **word** variable  eg: (s\\'teL , edoCteeL etc)\\n*  Then we add each word into **Res** string variable eg: ( \"\" , \"tsetnoc\", \"edoCteeL tsetnoc\" )\\n*  and Final result will be **Res** = \"s\\'teL ekat edoCteeL tsetnoc\".\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        string word=\"\", res=\"\";\\n        \\n        for(auto it= s.rbegin(); it!= s.rend()+1; it++)\\n        {\\n            if(it==s.rend())\\n            {\\n                res= word+res;\\n            }\\n            else if(*it!=\\' \\')\\n\\t\\t\\t{\\n                word+=*it;\\n\\t\\t\\t}\\n            else\\n            {\\n                res= \\' \\'+word+res; \\n                word=\"\";\\n            }\\n        }\\n  \\n        return res;  \\n    }\\n};\\n```\\n\\nIf it helps you do subscribe and Upvote Please!!!!!!!!.\\nupvote Button is in left-top corner please !!!!!!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        string word=\"\", res=\"\";\\n        \\n        for(auto it= s.rbegin(); it!= s.rend()+1; it++)\\n        {\\n            if(it==s.rend())\\n            {\\n                res= word+res;\\n            }\\n            else if(*it!=\\' \\')\\n\\t\\t\\t{\\n                word+=*it;\\n\\t\\t\\t}\\n            else\\n            {\\n                res= \\' \\'+word+res; \\n                word=\"\";\\n            }\\n        }\\n  \\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982916,
                "title": "simple-java-solution-runs-in-5ms-using-two-pointers-pattern",
                "content": "## Two Pointer pattern\\n\\nWe start the pointers `i` and `j` from `0`th index.\\n\\nWhen ever we see a space `char` then we need to reverse the substring by considering the pointers position.\\n\\nFor the position `s.length()` or `string` length, we don\\'t have another space `char`. So we can reverse the `i` , `j` pointered substring easily, unlike for the spaced chars, we need to consider the `char` before the `space` char.\\n\\n```\\npackage twopointers;\\n\\npublic class ReverseWordsInStringIII {\\n  public static void main(String[] args) {\\n    System.out.println(reverseWords(\"Let\\'s take LeetCode contest\"));\\n    System.out.println(reverseWords(\"God Ding\"));\\n  }\\n\\n  public static String reverseWords(String s) {\\n    char[] chars = s.toCharArray(); // O(n) space. We can remove this, but its easy with array of chars than string operations.\\n\\n    int i = 0;\\n    int j = 0;\\n\\n    while (j < chars.length) {\\n      if (chars[j] == \\' \\') { // at this point j is at space char, so we use j-1 to consider the last char.\\n        reverse(chars, i, j - 1);\\n        i = j + 1;\\n      }\\n      if (j == chars.length - 1) {\\n        reverse(chars, i, j);\\n        i = j + 1;\\n      }\\n      j++;\\n    }\\n    return new String(chars);\\n  }\\n\\n  public static void reverse(char[] chars, int i, int j) {\\n    while (i < j) {\\n      char ch = chars[i];\\n      chars[i++] = chars[j];\\n      chars[j--] = ch;\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\npackage twopointers;\\n\\npublic class ReverseWordsInStringIII {\\n  public static void main(String[] args) {\\n    System.out.println(reverseWords(\"Let\\'s take LeetCode contest\"));\\n    System.out.println(reverseWords(\"God Ding\"));\\n  }\\n\\n  public static String reverseWords(String s) {\\n    char[] chars = s.toCharArray(); // O(n) space. We can remove this, but its easy with array of chars than string operations.\\n\\n    int i = 0;\\n    int j = 0;\\n\\n    while (j < chars.length) {\\n      if (chars[j] == \\' \\') { // at this point j is at space char, so we use j-1 to consider the last char.\\n        reverse(chars, i, j - 1);\\n        i = j + 1;\\n      }\\n      if (j == chars.length - 1) {\\n        reverse(chars, i, j);\\n        i = j + 1;\\n      }\\n      j++;\\n    }\\n    return new String(chars);\\n  }\\n\\n  public static void reverse(char[] chars, int i, int j) {\\n    while (i < j) {\\n      char ch = chars[i];\\n      chars[i++] = chars[j];\\n      chars[j--] = ch;\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914837,
                "title": "2-javascript-solution-runtime-76-ms-and-memory-usage-48-2-mb",
                "content": "1. Very small and simple solution. Split into words by \" \" and split function, then reverse using another technique first split it empty string \"\" to convert into array then using array reverse. Finaly join this character. After that join every word by join method. \\nRuntime: 76 ms\\nMemory Usage: 48.2 MB.\\n\\n```\\nvar reverseWords = function(s) {\\n    let words=s.split(\" \"),i,r=[];\\n    r=words.map(function(word){\\n        return ((word.split(\"\")).reverse()).join(\"\");\\n    });\\n    return r.join(\" \");\\n};\\n```\\n\\n2. Here is another solution.\\n\\n```\\nvar reverseWords = function(s) {\\n    let words=s.split(\" \"),i;\\n    for(i=0;i<words.length;i++){\\n        words[i]=((words[i].split(\"\")).reverse()).join(\"\");\\n    }\\n    return words.join(\" \");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n    let words=s.split(\" \"),i,r=[];\\n    r=words.map(function(word){\\n        return ((word.split(\"\")).reverse()).join(\"\");\\n    });\\n    return r.join(\" \");\\n};\\n```\n```\\nvar reverseWords = function(s) {\\n    let words=s.split(\" \"),i;\\n    for(i=0;i<words.length;i++){\\n        words[i]=((words[i].split(\"\")).reverse()).join(\"\");\\n    }\\n    return words.join(\" \");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840181,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string res=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp.begin(),temp.end());\\n                res+=temp;\\n                res+=\" \";\\n                temp=\"\";\\n            }\\n            else\\n                temp+=s[i];\\n            \\n        }\\n        reverse(temp.begin(),temp.end());\\n        res+=temp;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string res=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp.begin(),temp.end());\\n                res+=temp;\\n                res+=\" \";\\n                temp=\"\";\\n            }\\n            else\\n                temp+=s[i];\\n            \\n        }\\n        reverse(temp.begin(),temp.end());\\n        res+=temp;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764378,
                "title": "python-3-30ms-slicing-approach-2-solutions-one-liner-easy-to-understand",
                "content": "***1 - Slicing Approach :-***\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l=list(s.split(\" \"))\\n        for i in range(len(l)):\\n            l[i] = l[i][::-1]\\n        return \" \".join(l)\\n```\\n***2 - One-Liner :-***\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(s.split()[::-1])[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l=list(s.split(\" \"))\\n        for i in range(len(l)):\\n            l[i] = l[i][::-1]\\n        return \" \".join(l)\\n```\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(s.split()[::-1])[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680241,
                "title": "c-o-1-space-solution-without-using-any-in-built-functions",
                "content": "Hello everyone, bolow is the solution to the problem ```557. Reverse Words in a String III```\\n* No in-built functions are used to split or reverse string. \\n* **No extra space** is used. \\n* The string is reversed **in place**.\\n\\n**Space complexity: O(1)**\\n\\n\\n```\\nclass Solution {\\n    void reverseString(string& s, int l, int r) {\\n        while(l<=r) {\\n            char tmp = s[l];\\n            s[l] = s[r];\\n            s[r] = tmp;\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    string reverseWords(string s) {\\n        int i=0, j=0;\\n        \\n        for(; j<s.size(); j++) {\\n            if(s[j] != \\' \\')\\n                continue;\\n            \\n            reverseString(s, i, j-1);\\n            i = j+1;\\n        }\\n        \\n        reverseString(s, i, j-1);\\n        \\n        return s;\\n    }\\n};\\n```\\n\\nIf you like the solution please consider upvoting.",
                "solutionTags": [
                    "C"
                ],
                "code": "```557. Reverse Words in a String III```\n```\\nclass Solution {\\n    void reverseString(string& s, int l, int r) {\\n        while(l<=r) {\\n            char tmp = s[l];\\n            s[l] = s[r];\\n            s[r] = tmp;\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    string reverseWords(string s) {\\n        int i=0, j=0;\\n        \\n        for(; j<s.size(); j++) {\\n            if(s[j] != \\' \\')\\n                continue;\\n            \\n            reverseString(s, i, j-1);\\n            i = j+1;\\n        }\\n        \\n        reverseString(s, i, j-1);\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678646,
                "title": "python-one-line-simple-sloce-solution",
                "content": "**Python :**\\n\\n```\\ndef reverseWords(self, s: str) -> str:\\n\\treturn \" \".join([word[::-1] for word in s.split()])\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef reverseWords(self, s: str) -> str:\\n\\treturn \" \".join([word[::-1] for word in s.split()])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1674524,
                "title": "c-100-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int start=i;\\n            while(s[i]!=\\' \\' && i<s.size())\\n            {\\n                i++;\\n            }\\n            int end=i-1;\\n            while(start<=end)\\n            {\\n                swap(s[start],s[end]);\\n                start++;\\n                end--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int start=i;\\n            while(s[i]!=\\' \\' && i<s.size())\\n            {\\n                i++;\\n            }\\n            int end=i-1;\\n            while(start<=end)\\n            {\\n                swap(s[start],s[end]);\\n                start++;\\n                end--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627036,
                "title": "94-faster-runtime-with-iterators-and-std-reverse",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        s += \\' \\';\\n        auto word_begin = s.begin();\\n        for (auto it = s.begin(); it != s.end(); it++) {\\n            if (*it == \\' \\') {\\n                std::reverse(word_begin, it);\\n                word_begin = it + 1;\\n            }\\n        }\\n        s.pop_back();\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        s += \\' \\';\\n        auto word_begin = s.begin();\\n        for (auto it = s.begin(); it != s.end(); it++) {\\n            if (*it == \\' \\') {\\n                std::reverse(word_begin, it);\\n                word_begin = it + 1;\\n            }\\n        }\\n        s.pop_back();\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595466,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l = s.split(\" \")\\n        s = \"\"\\n        for x in l:\\n            x = x[::-1]\\n            s += x + \" \"\\n        s = s[:-1]\\n        return s\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l = s.split(\" \")\\n        s = \"\"\\n        for x in l:\\n            x = x[::-1]\\n            s += x + \" \"\\n        s = s[:-1]\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561985,
                "title": "go-golang-time-o-n-1-5-0-ms-100-space-o-n-6-5-mb-66-33",
                "content": "```\\nfunc reverse(s string) string {\\n    result := []byte(s)\\n\\n    for l, r := 0, len(s) - 1; l < r; l, r = l + 1, r - 1 {\\n        result[l], result[r] = result[r], result[l]\\n    }\\n    \\n    return string(result)\\n}\\n\\nfunc reverseWords(s string) string {\\n    result := []string{}\\n    \\n    for _, word := range strings.Split(s, \" \") {        \\n        result = append(result, reverse(word))\\n    }\\n    \\n    return strings.Join(result, \" \")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverse(s string) string {\\n    result := []byte(s)\\n\\n    for l, r := 0, len(s) - 1; l < r; l, r = l + 1, r - 1 {\\n        result[l], result[r] = result[r], result[l]\\n    }\\n    \\n    return string(result)\\n}\\n\\nfunc reverseWords(s string) string {\\n    result := []string{}\\n    \\n    for _, word := range strings.Split(s, \" \") {        \\n        result = append(result, reverse(word))\\n    }\\n    \\n    return strings.Join(result, \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518382,
                "title": "simple-python-code-two-pointer-approach-with-comments",
                "content": "\\n```\\nclass Solution:\\n\\t# Normal reverse Function to reverse values\\n    def reverse(self, s , low, high):\\n        while(low < high):\\n            s[low] , s[high] = s[high] , s[low]\\n            low+=1\\n            high-=1\\n\\t\\t\\t\\n\\t\\t\\t\\n    def reverseWords(self, s: str) -> str:\\n        curr= 0  #Marks the beignning of word\\n        s=list(s)  #converted String to list to avoid error as strings are immutable\\n        for i in range(len(s)-1):\\n            if(s[i]==\" \"):   #if we encounter a blank space then we need to reverse values from curr to i-1\\n                self.reverse(s, curr, i-1)\\n                curr = i+1 #update curr to point next word\\'s beignning\\n        self.reverse(s, curr,len(s)-1) #reverse the last word\\n        return \"\".join(s) #join the list to return it as a String\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n\\t# Normal reverse Function to reverse values\\n    def reverse(self, s , low, high):\\n        while(low < high):\\n            s[low] , s[high] = s[high] , s[low]\\n            low+=1\\n            high-=1\\n\\t\\t\\t\\n\\t\\t\\t\\n    def reverseWords(self, s: str) -> str:\\n        curr= 0  #Marks the beignning of word\\n        s=list(s)  #converted String to list to avoid error as strings are immutable\\n        for i in range(len(s)-1):\\n            if(s[i]==\" \"):   #if we encounter a blank space then we need to reverse values from curr to i-1\\n                self.reverse(s, curr, i-1)\\n                curr = i+1 #update curr to point next word\\'s beignning\\n        self.reverse(s, curr,len(s)-1) #reverse the last word\\n        return \"\".join(s) #join the list to return it as a String\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1506245,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn reverse_words(s: String) -> String {\\n        let result: Vec<String> = s.split(\\' \\').map(|word| {\\n            word.chars().rev().collect::<String>()\\n        }).collect();\\n        \\n        result.join(\" \")\\n    }\\n}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_words(s: String) -> String {\\n        let result: Vec<String> = s.split(\\' \\').map(|word| {\\n            word.chars().rev().collect::<String>()\\n        }).collect();\\n        \\n        result.join(\" \")\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1479260,
                "title": "rust-0ms-constant-space",
                "content": "```\\npub fn reverse_words(mut s: String) -> String {\\n    assert!(s.is_ascii());\\n    unsafe { s.as_bytes_mut() }\\n        .split_mut(u8::is_ascii_whitespace)\\n        .for_each(<[_]>::reverse);\\n    s\\n}\\n```\\n\\nexplanation:\\n\\n```\\n// ensure all characters within `s` are ascii\\nassert!(s.is_ascii());\\n\\n// the bytes within `s` may be freely rearranged because ascii characters\\n// are each 1 byte\\nunsafe { s.as_bytes_mut() }\\n    // create an iterator over all whitespace-separated subslices of `s`\\n    .split_mut(u8::is_ascii_whitespace)\\n    // reverse each subslice\\n    .for_each(<[_]>::reverse);\\n\\t\\n// return the modified string\\ns\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn reverse_words(mut s: String) -> String {\\n    assert!(s.is_ascii());\\n    unsafe { s.as_bytes_mut() }\\n        .split_mut(u8::is_ascii_whitespace)\\n        .for_each(<[_]>::reverse);\\n    s\\n}\\n```\n```\\n// ensure all characters within `s` are ascii\\nassert!(s.is_ascii());\\n\\n// the bytes within `s` may be freely rearranged because ascii characters\\n// are each 1 byte\\nunsafe { s.as_bytes_mut() }\\n    // create an iterator over all whitespace-separated subslices of `s`\\n    .split_mut(u8::is_ascii_whitespace)\\n    // reverse each subslice\\n    .for_each(<[_]>::reverse);\\n\\t\\n// return the modified string\\ns\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1462822,
                "title": "python3-accepted-solution",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([i[::-1] for i in s.split()])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([i[::-1] for i in s.split()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461846,
                "title": "c-2-approaches-using-string-stream-and-without-string-stream-o-n-easy-to-understand",
                "content": "**APPROACH 1:**  Second Solution ***using stringStream*** .\\nHere i used string string stream to break the words and while breaking each word simultaneously i add this word into a new string after reversing with a space added to it  but here one thing is so important that while adding a space too at last there is an unwanted space so after whole logic ***pop_back()*** that space.\\n\\n```\\n string reverseWords(string s) {\\n     stringstream str(s);\\n    string word;\\n    string ans;\\n    while(str >> word)\\n    {\\n        reverse(word.begin(), word.end());\\n        ans += word + \" \";\\n    }\\n    ans.pop_back(); //this is mendatory to add because in line 10 i am adding each word with a space but at last we put an extra space so for that we have to remove that ont \\n    return ans; \\n\\t}\\n```\\n\\n\\n**APPROACH 2:**  Second Solution ***without using stringStream*** .\\n\\n```\\n  string reverseWords(string s) {\\n s += \" \";  \\n /* this is added only and only because if it is not added then loops break at last second word \\n and reverse only first to last second word so if i added one \\n more space at last to the main string then without any problem we can traverse the whole string with our logic .*/\\nstring ans, temp;\\nfor(int i = 0 ; i < s.size(); i++)\\n{\\n    temp += s[i];\\n    if(s[i] == \\' \\') //if we got any space then reverse the string whichever u stored in the temp till now\\n    {\\n        reverse(temp.begin(), temp.end());\\n        ans += temp;\\n        temp = \"\"; //after completion of one word again make it empty for the next word so on and so forth .\\n    }\\n}\\n        ans.erase(ans.begin()); //while doing this there is an extra space remains in front of the string(ans) after debugging u can see that so remove that space too at later;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\n string reverseWords(string s) {\\n     stringstream str(s);\\n    string word;\\n    string ans;\\n    while(str >> word)\\n    {\\n        reverse(word.begin(), word.end());\\n        ans += word + \" \";\\n    }\\n    ans.pop_back(); //this is mendatory to add because in line 10 i am adding each word with a space but at last we put an extra space so for that we have to remove that ont \\n    return ans; \\n\\t}\\n```\n```\\n  string reverseWords(string s) {\\n s += \" \";  \\n /* this is added only and only because if it is not added then loops break at last second word \\n and reverse only first to last second word so if i added one \\n more space at last to the main string then without any problem we can traverse the whole string with our logic .*/\\nstring ans, temp;\\nfor(int i = 0 ; i < s.size(); i++)\\n{\\n    temp += s[i];\\n    if(s[i] == \\' \\') //if we got any space then reverse the string whichever u stored in the temp till now\\n    {\\n        reverse(temp.begin(), temp.end());\\n        ans += temp;\\n        temp = \"\"; //after completion of one word again make it empty for the next word so on and so forth .\\n    }\\n}\\n        ans.erase(ans.begin()); //while doing this there is an extra space remains in front of the string(ans) after debugging u can see that so remove that space too at later;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368982,
                "title": "with-builtin-function-188ms-vs-88ms-without-builtin-funtion-c",
                "content": "**C# solution using Built in function in 1 line faster than 6.37% (188ms)**\\n\\n```\\npublic string ReverseWords(string s)\\n        {\\n            return string.Join(\" \", s.Split(\" \").Select(x => new string(x.ToCharArray().Reverse().ToArray())));\\n        }\\n```\\n**C# solution without built in function faster than 90.69% (88ms)**\\n```\\npublic string ReverseWords(string s)\\n        {\\n            char[] sentence = s.ToCharArray();\\n            int i = 0;\\n            for (int k = 0; k < sentence.Length; k++)\\n            {\\n                if (sentence[k] == \\' \\' || (k+1 == sentence.Length && ++k == sentence.Length) )\\n                {\\n                    for (int j = k - 1; i < j; i++, j--)\\n                    {\\n                        char c = sentence[i];\\n                        sentence[i] = sentence[j];\\n                        sentence[j] = c;\\n                    }\\n                    i = k+1;\\n                }\\n            }\\n\\n            return new string(sentence);\\n        }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic string ReverseWords(string s)\\n        {\\n            return string.Join(\" \", s.Split(\" \").Select(x => new string(x.ToCharArray().Reverse().ToArray())));\\n        }\\n```\n```\\npublic string ReverseWords(string s)\\n        {\\n            char[] sentence = s.ToCharArray();\\n            int i = 0;\\n            for (int k = 0; k < sentence.Length; k++)\\n            {\\n                if (sentence[k] == \\' \\' || (k+1 == sentence.Length && ++k == sentence.Length) )\\n                {\\n                    for (int j = k - 1; i < j; i++, j--)\\n                    {\\n                        char c = sentence[i];\\n                        sentence[i] = sentence[j];\\n                        sentence[j] = c;\\n                    }\\n                    i = k+1;\\n                }\\n            }\\n\\n            return new string(sentence);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099716,
                "title": "c-98-5",
                "content": "```\\nint start=0;\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            if(isspace(s[i]) || i==s.length())\\n            {\\n                reverse(s.begin()+start,s.begin()+i);\\n                start=i+1;\\n            }\\n        }\\n        return s;\\n```",
                "solutionTags": [],
                "code": "```\\nint start=0;\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            if(isspace(s[i]) || i==s.length())\\n            {\\n                reverse(s.begin()+start,s.begin()+i);\\n                start=i+1;\\n            }\\n        }\\n        return s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034183,
                "title": "one-line-in-python-faster-than-98",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join([w[::-1] for w in s.split(\\' \\')])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join([w[::-1] for w in s.split(\\' \\')])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956616,
                "title": "12ms-99-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int begin = 0;\\n        int end = 0;\\n        \\n        for (int i = 0; i < s.size() + 1; i++) {\\n            \\n            char ch = i == s.size() ? \\' \\' : s[i];\\n            \\n            if (ch == \\' \\') {\\n                end = i - 1;\\n                \\n                reverse(s, begin, end);\\n                \\n                begin = i + 1;\\n            }\\n            \\n        }\\n        \\n        return s;\\n        \\n    }\\n    \\n    void reverse(string& s, int left, int right) {\\n        \\n        while(left < right) {\\n            swap(s[left++], s[right--]);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int begin = 0;\\n        int end = 0;\\n        \\n        for (int i = 0; i < s.size() + 1; i++) {\\n            \\n            char ch = i == s.size() ? \\' \\' : s[i];\\n            \\n            if (ch == \\' \\') {\\n                end = i - 1;\\n                \\n                reverse(s, begin, end);\\n                \\n                begin = i + 1;\\n            }\\n            \\n        }\\n        \\n        return s;\\n        \\n    }\\n    \\n    void reverse(string& s, int left, int right) {\\n        \\n        while(left < right) {\\n            swap(s[left++], s[right--]);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705857,
                "title": "python-one-liner-faster-than-57-02-submissions",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([word[::-1] for word in s.split()])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([word[::-1] for word in s.split()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679095,
                "title": "python-one-liner-40ms",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(map(lambda i:i[::-1],s.split()))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(map(lambda i:i[::-1],s.split()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601706,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        a = s.split(\" \")\\n        for i in range(len(a)):\\n            a[i] = a[i][::-1]\\n        return \" \".join(a)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        a = s.split(\" \")\\n        for i in range(len(a)):\\n            a[i] = a[i][::-1]\\n        return \" \".join(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581749,
                "title": "swift-1-line",
                "content": "```\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        return s.components(separatedBy: \" \").map{String($0.reversed())}.joined(separator: \" \")\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        return s.components(separatedBy: \" \").map{String($0.reversed())}.joined(separator: \" \")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485618,
                "title": "easy-c-solution-with-stack",
                "content": "```\\n    public class Solution\\n    {\\n        public string ReverseWords(string s)\\n        {\\n            Stack<char> stack = new Stack<char>();\\n            StringBuilder sb = new StringBuilder(s.Length);\\n            foreach (var c in s)\\n            {\\n                if (c == \\' \\')\\n                {\\n                    while (stack.Count > 0)\\n                    {\\n                        sb.Append(stack.Pop());\\n                    }\\n\\n                    sb.Append(c);\\n                    continue;\\n                }\\n\\n                stack.Push(c);\\n            }\\n\\n            while (stack.Count > 0)\\n            {\\n                sb.Append(stack.Pop());\\n            }\\n\\n            return sb.ToString();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public string ReverseWords(string s)\\n        {\\n            Stack<char> stack = new Stack<char>();\\n            StringBuilder sb = new StringBuilder(s.Length);\\n            foreach (var c in s)\\n            {\\n                if (c == \\' \\')\\n                {\\n                    while (stack.Count > 0)\\n                    {\\n                        sb.Append(stack.Pop());\\n                    }\\n\\n                    sb.Append(c);\\n                    continue;\\n                }\\n\\n                stack.Push(c);\\n            }\\n\\n            while (stack.Count > 0)\\n            {\\n                sb.Append(stack.Pop());\\n            }\\n\\n            return sb.ToString();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358331,
                "title": "python3-explanation",
                "content": "*  save the word in the input string to a list.\\n```\\ns = \"Let\\'s take LeetCode contest\"\\nl =s.split()\\n>>> l = [\"Let\\'s\", \\'take\\', \\'LeetCode\\', \\'contest\\']\\n```\\n* reverse each item in the list l.\\n```\\nreverse = []\\nfor i in l:\\n\\tr = i[::-1]\\n\\treverse.append(r)\\n>>> reverse = [\"s\\'teL\", \\'ekat\\', \\'edoCteeL\\', \\'tsetnoc\\']\\n```\\n* build the string by using the item in the list.\\n```\\n res = \" \".join(i for i in reverse)\\n >>> res = \"s\\'teL ekat edoCteeL tsetnoc\"\\n```\\n\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l =s.split()\\n        reverse = []\\n        for i in l:\\n            r = i[::-1]\\n            reverse.append(r)\\n        res = \" \".join(i for i in reverse)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ns = \"Let\\'s take LeetCode contest\"\\nl =s.split()\\n>>> l = [\"Let\\'s\", \\'take\\', \\'LeetCode\\', \\'contest\\']\\n```\n```\\nreverse = []\\nfor i in l:\\n\\tr = i[::-1]\\n\\treverse.append(r)\\n>>> reverse = [\"s\\'teL\", \\'ekat\\', \\'edoCteeL\\', \\'tsetnoc\\']\\n```\n```\\n res = \" \".join(i for i in reverse)\\n >>> res = \"s\\'teL ekat edoCteeL tsetnoc\"\\n```\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l =s.split()\\n        reverse = []\\n        for i in l:\\n            r = i[::-1]\\n            reverse.append(r)\\n        res = \" \".join(i for i in reverse)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247155,
                "title": "simple-go-solution",
                "content": "```\\nfunc reverseWords(s string) string {\\n    ls := len(s)\\n    if ls < 2 {\\n        return s\\n    }\\n    \\n    b := []byte(s)\\n    l, r := 0, 0\\n    for i, v := range b {\\n        // if v is space or come to the end\\n        if v == \\' \\' || i == ls -1 {\\n            r = i - 1 // set the right index\\n            // but if we get the end of s, we should plus 1 to r, because we subtracted r before\\n            if i == ls -1 {\\n                r++\\n            }\\n            // loop between l and r, swap the vlalue on the two indexes\\n            for l < r  {\\n                b[l], b[r] = b[r], b[l]\\n\\n                r--\\n                l++\\n            }\\n            l = i +1 // set l to i plus 1. because s[i] is space, so we start at the next one\\n        }\\n    }\\n    return string(b)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reverseWords(s string) string {\\n    ls := len(s)\\n    if ls < 2 {\\n        return s\\n    }\\n    \\n    b := []byte(s)\\n    l, r := 0, 0\\n    for i, v := range b {\\n        // if v is space or come to the end\\n        if v == \\' \\' || i == ls -1 {\\n            r = i - 1 // set the right index\\n            // but if we get the end of s, we should plus 1 to r, because we subtracted r before\\n            if i == ls -1 {\\n                r++\\n            }\\n            // loop between l and r, swap the vlalue on the two indexes\\n            for l < r  {\\n                b[l], b[r] = b[r], b[l]\\n\\n                r--\\n                l++\\n            }\\n            l = i +1 // set l to i plus 1. because s[i] is space, so we start at the next one\\n        }\\n    }\\n    return string(b)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216618,
                "title": "easy-to-understand-solution-in-swift",
                "content": "```\\nfunc reverseWords(_ s: String) -> String {\\n        var output = Array(s)\\n        var left = 0, right = 0\\n        while right < output.count {\\n            while right < output.count && output[right] != \" \" { right += 1 }\\n            \\n            if right == output.count || output[right] == \" \" {\\n                reverse(&output, left, right-1)\\n                right += 1\\n                left = right\\n            }\\n        }\\n        \\n        return String(output)\\n    }\\n    \\n    private func reverse(_ s: inout [Character], _ left: Int, _ right: Int) {\\n        var l = left, r = right\\n        while l <= r {\\n            s.swapAt(l, r)\\n            l += 1\\n            r -= 1\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reverseWords(_ s: String) -> String {\\n        var output = Array(s)\\n        var left = 0, right = 0\\n        while right < output.count {\\n            while right < output.count && output[right] != \" \" { right += 1 }\\n            \\n            if right == output.count || output[right] == \" \" {\\n                reverse(&output, left, right-1)\\n                right += 1\\n                left = right\\n            }\\n        }\\n        \\n        return String(output)\\n    }\\n    \\n    private func reverse(_ s: inout [Character], _ left: Int, _ right: Int) {\\n        var l = left, r = right\\n        while l <= r {\\n            s.swapAt(l, r)\\n            l += 1\\n            r -= 1\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 185917,
                "title": "java-solution",
                "content": "1) Used StringBuilder and split()\n2) Time: O(N), Space: O(N)\n```\nclass Solution {\n    public String reverseWords(String s) {\n        //Strings in java are immutable, so I have to work with StringBuilder\n        String[] words = s.split(\" \");\n        \n        StringBuilder reversed = new StringBuilder();\n        for(String word : words){\n            for(int i=word.length()-1;i>=0;i--){\n                reversed.append(word.charAt(i));\n            }\n            reversed.append(\" \");\n        }\n        //delete the last space\n        reversed.deleteCharAt(reversed.length()-1);\n        return reversed.toString();\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public String reverseWords(String s) {\n        //Strings in java are immutable, so I have to work with StringBuilder\n        String[] words = s.split(\" \");\n        \n        StringBuilder reversed = new StringBuilder();\n        for(String word : words){\n            for(int i=word.length()-1;i>=0;i--){\n                reversed.append(word.charAt(i));\n            }\n            reversed.append(\" \");\n        }\n        //delete the last space\n        reversed.deleteCharAt(reversed.length()-1);\n        return reversed.toString();\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 178681,
                "title": "java-easy-to-read-and-understand",
                "content": "Not too different to other answers, but definitely easy to read and undestand.\n\nSplit the string into words, use a stack to reverse, then append to stringbuilder. At the end do ```toString()``` and ```.trim()``` to remove last space.\n\n```\nclass Solution {\n    public String reverseWords(String s) {\n        \n        StringBuilder sb = new StringBuilder();\n        \n        for(String word : s.split(\" \")){\n            Stack<Character> stack = new Stack();\n            \n            for(Character c: word.toCharArray())\n                stack.push(c);\n            \n            while(!stack.empty())\n                sb.append(stack.pop());\n            \n            sb.append(' ');\n        }\n        \n        return sb.toString().trim();      \n    }\n}\n```",
                "solutionTags": [],
                "code": "```toString()```\n```.trim()```\n```\nclass Solution {\n    public String reverseWords(String s) {\n        \n        StringBuilder sb = new StringBuilder();\n        \n        for(String word : s.split(\" \")){\n            Stack<Character> stack = new Stack();\n            \n            for(Character c: word.toCharArray())\n                stack.push(c);\n            \n            while(!stack.empty())\n                sb.append(stack.pop());\n            \n            sb.append(' ');\n        }\n        \n        return sb.toString().trim();      \n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 101919,
                "title": "python-o-n",
                "content": "Unlike some of the fancy one-liners in Python I've seen, this solution does not require splitting the list and using that extra space. This is also O(n) time.\\n```\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        current_word = ''\\n        start = 0\\n        for x in range(len(s)):\\n            index = s[x]\\n            if index == ' ':\\n                beginning = s[:start]\\n                end = s[x:]\\n                s = beginning + current_word + end\\n                start = x + 1\\n                current_word = ''\\n            else:\\n                current_word = index + current_word\\n        s = s[:start] + current_word\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        current_word = ''\\n        start = 0\\n        for x in range(len(s)):\\n            index = s[x]\\n            if index == ' ':\\n                beginning = s[:start]\\n                end = s[x:]\\n                s = beginning + current_word + end\\n                start = x + 1\\n                current_word = ''\\n            else:\\n                current_word = index + current_word\\n        s = s[:start] + current_word\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101949,
                "title": "java-8-1-line-solution",
                "content": "```java\\npublic class Solution {\\n    public String reverseWords(String s) {\\n        return new ArrayList<>(Arrays.asList(s.split(\" \"))).stream()\\n            .map(str -> new StringBuilder(str).reverse().toString())\\n            .collect(Collectors.joining(\" \"));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public String reverseWords(String s) {\\n        return new ArrayList<>(Arrays.asList(s.split(\" \"))).stream()\\n            .map(str -> new StringBuilder(str).reverse().toString())\\n            .collect(Collectors.joining(\" \"));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102053,
                "title": "c-solution",
                "content": "```\\nvoid reverse(char *s, int l, int r)\\n{\\n\\tchar tmp;\\n\\twhile(l < r)\\n\\t{\\n\\t\\ttmp = s[l];\\n\\t\\ts[l] = s[r];\\n\\t\\ts[r] = tmp;\\n\\t\\tl ++;\\n\\t\\tr --;\\n\\t}\\n}\\n\\nchar* reverseWords(char* s) {\\n\\tint l, r, len=strlen(s);\\n\\tl=r=0;\\n\\twhile(1){\\n\\t\\tif(r >= len-1)\\treturn s;\\n\\t\\twhile(s[l] == ' ') l++;\\n\\t\\tr = l;\\n\\t\\twhile(s[r] != ' ' && r < len) r++;\\n\\t\\treverse(s, l, r-1);\\n\\t\\tl=r;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid reverse(char *s, int l, int r)\\n{\\n\\tchar tmp;\\n\\twhile(l < r)\\n\\t{\\n\\t\\ttmp = s[l];\\n\\t\\ts[l] = s[r];\\n\\t\\ts[r] = tmp;\\n\\t\\tl ++;\\n\\t\\tr --;\\n\\t}\\n}\\n\\nchar* reverseWords(char* s) {\\n\\tint l, r, len=strlen(s);\\n\\tl=r=0;\\n\\twhile(1){\\n\\t\\tif(r >= len-1)\\treturn s;\\n\\t\\twhile(s[l] == ' ') l++;\\n\\t\\tr = l;\\n\\t\\twhile(s[r] != ' ' && r < len) r++;\\n\\t\\treverse(s, l, r-1);\\n\\t\\tl=r;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101875,
                "title": "easy-javascript-solution",
                "content": "```\\nvar reverseWords = function(s) {\\n    var str = s.split(\" \");\\n    for(let i = 0;i < str.length;i++){\\n        str[i] = str[i].split(\"\").reverse().join(\"\");\\n    }\\n    return str.join(\" \");\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseWords = function(s) {\\n    var str = s.split(\" \");\\n    for(let i = 0;i < str.length;i++){\\n        str[i] = str[i].split(\"\").reverse().join(\"\");\\n    }\\n    return str.join(\" \");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079268,
                "title": "python-4-line-code-96-68-2-approach",
                "content": "**If you got help from this,... Plz Upvote .. it encourage me**\\n\\n# Code\\n```\\n<!-- 1st Approach Memory % is more -->\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.split(\\' \\')\\n        for i in range(len(s)):\\n            s[i] = s[i][::-1]\\n        return \\' \\'.join(s)\\n\\n\\n# ===========================================================\\n<!-- 2nd Approach Runtime % is More 96.68% -->\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.split(\\' \\')\\n        new = \\'\\'\\n        for word in s:\\n            new += word[::-1] + \\' \\'\\n\\n        return new[:-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\n<!-- 1st Approach Memory % is more -->\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.split(\\' \\')\\n        for i in range(len(s)):\\n            s[i] = s[i][::-1]\\n        return \\' \\'.join(s)\\n\\n\\n# ===========================================================\\n<!-- 2nd Approach Runtime % is More 96.68% -->\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.split(\\' \\')\\n        new = \\'\\'\\n        for word in s:\\n            new += word[::-1] + \\' \\'\\n\\n        return new[:-1]\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576858,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1576837,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1697860,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1572285,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1839845,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1576392,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1572784,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1571770,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1571927,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1576743,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1576858,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1576837,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1697860,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1572285,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1839845,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1576392,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1572784,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1571770,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1571927,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 1576743,
                "content": [
                    {
                        "username": "juhi123",
                        "content": "![image](https://assets.leetcode.com/users/images/f47a4b8d-a27e-4e93-b823-18a9d45909d5_1654539094.999315.png)\\n\\n"
                    },
                    {
                        "username": "frankchen23214",
                        "content": "![image](https://assets.leetcode.com/users/images/d648730e-f9ad-4741-915e-fc0895607550_1654069113.7029223.png)\\n**please upvote if you like answer\\uD83D\\uDE06**"
                    },
                    {
                        "username": "Aarib",
                        "content": "why it\\'s show memory limit exceeded?\\n\\nclass Solution {\\n int space(string s,int start){\\n     while(start<s.length()){\\n        if(s[start]==\\' \\'){\\n            return start;\\n        }\\n        start++;\\n     }\\n     return s.length();\\n    }\\nvoid reverse(string& s,int start,int end){\\n    while(start<=end){\\n    swap(s[start++],s[end--]);\\n    }\\n}\\npublic:\\n    string reverseWords(string s) {\\n        int start=0,end;\\n        for(int i=0;i<s.length();i++){\\n        end = space(s,i)-1;\\n        reverse(s,start,end);\\n        start=end+2;\\n        }\\n    return s;\\n    }\\n};"
                    },
                    {
                        "username": "talibhussain6394",
                        "content": "i also have same question"
                    },
                    {
                        "username": "randompast",
                        "content": "We use s.split(\" \") to split s about the spaces and turn it into a list.\\nUsing a list comprehension, for each word w in s, we reverse the indeces with w[::-1].\\nFinally, we join the resulting list with spaces via \" \".join(words).\\n\\n\\treturn \" \".join([w[::-1] for w in s.split(\" \")])"
                    },
                    {
                        "username": "rishabh8057",
                        "content": "is there any linear solution for this,? if yes please let me know."
                    },
                    {
                        "username": "HsnImam",
                        "content": "\\t\\tvar reverseWords = function(s) {\\n\\t\\t\\treturn s.split(\\' \\').map(word => word.split(\\'\\').reverse().join(\\'\\')).join(\\' \\');\\n\\t\\t};"
                    },
                    {
                        "username": "alvintan626",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function(str) {\\n\\t\\treturn str.split(\" \").map(elem =>(elem.split(\"\").reverse()).join(\"\")).join(\" \")\\n};"
                    },
                    {
                        "username": "Predator_",
                        "content": "For this problem.\\n\"x      Let's take LeetCode contest\"\\nwith several whitespace on between a and L. Should be producing :\\n\"x      s'teL ekat edoCteeL tsetnoc\" with several with spaces.\\n\\nI will use underscore to denoted whitespace.\\n\\n\"x___Let's take LeetCode contest\"\\n\"x___s'teL ekat edoCteeL tsetnoc\" \\nthe expected answer is:\\n\"x_s'teL ekat edoCteeL tsetnoc\"\\n\\nProblem state: \" [...] while still preserving whitespace [...]\"\\nI think test are no considering this case."
                    },
                    {
                        "username": "sr_vrd",
                        "content": "They have now added\n> All the words in `s` are separated by a single space.\n\nto discard this cases."
                    },
                    {
                        "username": "SmileJohnson",
                        "content": "`return \\' \\'.join(list(map(lambda x : x[::-1], s.split())))`"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\treturn \" \".join(x[::-1] for x in s.split(\" \"))"
                    }
                ]
            },
            {
                "id": 2068653,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1999290,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1999266,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1952923,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1911735,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1852589,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1827049,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1803928,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1802484,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1801447,
                "content": [
                    {
                        "username": "lc7",
                        "content": "I got execution time as low as 3 ms with C."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Two pointer approach with $$O(n+m)$$ time complexcity,\\nHere is code implementation with detailed explanation:\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860960/two-pointer-approach-o-n-m-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "use lambda to reverse each word, then join the reversed word with \" \", and return!! Easy \\n`Here is the code implementation: `\\nhttps://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/3860855/simple-lambda-reverse-approach-o-n-beats-98-9-runtime-detailed-explanation/"
                    },
                    {
                        "username": "TechSavvyAmit",
                        "content": "why i getting wrong answer as i got the same result which is showing in the console ?"
                    },
                    {
                        "username": "putwind",
                        "content": "Can you check your return statement once or share your code."
                    },
                    {
                        "username": "putwind",
                        "content": "Pythonic Solution in single line:\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(list(map(lambda x: x[::-1], s.split(\\' \\'))))"
                    },
                    {
                        "username": "Ayush_Kumar-01",
                        "content": "Why is it showing Runtime Error ?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int st=0,e=s.length()-1;\\n        int k=0;\\n        \\n        for(int i=0;i<=e;i++)\\n        {\\n            int n=i-1;\\n            char ch=s[i];\\n            if(ch==\\' \\')\\n            {\\n                while(st<=n)\\n                {\\n                    swap(s[st++],s[n--]);\\n                    for(int j=st;j<=i;j++)\\n                    {\\n                        s[k++]=s[j++];\\n                    }\\n                }\\n                \\n                st=i+1;\\n                \\n                i++;\\n                \\n            }\\n\\n        }\\n        s.resize(k);\\n        return s;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "5ms ans in java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new StringBuilder(arr[i]).reverse().toString();\n        }\n        return String.join(\" \", arr);\n    }\n}"
                    },
                    {
                        "username": "doduythinh1",
                        "content": "var reverseWords = function(s) {\n    let chunks = [];\n    s.split(' ').map((item,index) => {\n        chunks.push(item.split('').reverse().join(''));\n    })\n    // for(let i = 0; i < newString.length; i ++){\n    //     chunks.push(newString[i].split('').reverse().join(''));\n    // }\n    return chunks.join(' ');\n};"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n       String[] strArray =s.split(\" \"); \\n       s=\"\"; \\n       for (int i = 0; i< strArray.length; i++){  \\n           String str= strArray[i],nstr=\"\";\\n           char ch;\\n           for (int j=0; j<str.length(); j++)\\n            {\\n                ch= str.charAt(j); \\n                nstr= ch+nstr;\\n            }\\n            s+=\" \"+nstr;\\n       } \\n       return s.trim();  \\n    } \\n}\\nhelp me improve it\\'s time complexity."
                    },
                    {
                        "username": "siddharthmishra436",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n      int lastspaceIndex = -1;\\n      int length = s.length();\\n      char arr[] = s.toCharArray();\\n      for(int strIndex = 0 ; strIndex <= length ; strIndex++){\\n        if(strIndex == length || s.charAt(strIndex) == \\' \\'){\\n         int startIndex = lastspaceIndex+1;\\n         int endIndex = strIndex-1;\\n          while(startIndex < endIndex){\\n            char temp = arr[startIndex];\\n            arr[startIndex] = arr[endIndex];\\n            arr[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\n          } \\n          lastspaceIndex = strIndex;\\n      }\\n    \\n    }\\n      return new String(arr);\\n      \\n}\\n}"
                    }
                ]
            },
            {
                "id": 1776266,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1772891,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1759319,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1757652,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1731985,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1726269,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1722362,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1717647,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1714771,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            },
            {
                "id": 1713446,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/557_Reverse_Words_in_a_String_III.CPP\\n\\nVERY SIMPLE APPROACH "
                    },
                    {
                        "username": "akuthiala",
                        "content": "#Why is this wrong?\\n    void reverse(string &s1){\\n        int i=0;\\n        int j=s1.size()-1;\\n        while(i<j){\\n            swap(s1[i],s1[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        string ans=\"\";\\n        string temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\' \\'){\\n                reverse(temp);\\n                ans=ans+temp;\\n                ans=ans+\\' \\';\\n                temp=\"\";\\n            }\\n            else{\\n                temp=temp+s[i];\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Sakshi_2010",
                        "content": "class Solution {\\npublic:\\n    \\n    string reverseWords(string s) {\\n        stack<char> sta;\\n        string ans ; \\n        int n = s.length();\\n        for(int i =0; i<n ;i++)\\n        {\\n            char c = s[i];\\n            sta.push(c);\\n             if(c == \\' \\')\\n             {\\n                 string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans =  ans +reverseString;\\n             }\\n        }\\n        string reverseString;\\n                    while(!sta.empty())\\n                    {\\n                        char a =  sta.top();\\n                        reverseString.push_back(a);\\n                        sta.pop();\\n                    }\\n                    ans = ans +\" \"+ reverseString;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nPlease help me to fix my code. I am getting one space more before the desired output ...help me to fix this."
                    },
                    {
                        "username": "srinivaspavan05",
                        "content": "Why is this code getting TLE!!! ?\\n\\n class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\')\\n                st.push(s[i]);\\n            else{\\n                while(!st.empty()){\\n                    ans=ans+st.top();\\n                    st.pop();\\n                }\\n                ans=ans+\\' \\';\\n            }   \\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "        return string.Join(\" \", s.Split(\\' \\').Select(x => string.Concat(x.Reverse())));\\n"
                    },
                    {
                        "username": "kawcher_h",
                        "content": "var reverseWords = function(s) {\\n  return s.split(\\'\\').reverse().join(\\'\\').split(\\' \\').reverse().join(\\' \\');\\n};"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "wenhaowuuu",
                        "content": "A random question about memory.....Not sure why is the Space complexity of the character traversal solution just O(1). Isn\\'t using StringBuilder() would lead to O(N), with N = length of the input string? Thanks"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        int idx = 0;\\n        string result = \"\";\\n        while (idx < s.size()) {\\n            if (s[idx] != \\' \\') {\\n                int len = 0;\\n                while (s[idx+len] != \\' \\') {\\n                    len++;\\n                }\\n                if (len == 1) {\\n                    result+=s[idx];\\n                    idx++;\\n                }else {\\n                    string sub = s.substr(idx, len);\\n                    reverse(sub.begin(), sub.end());\\n                    result+=sub;\\n                    idx += len;\\n                }\\n            }\\n            else {\\n                result+=\\' \\';\\n                idx++;\\n            };\\n        }\\n        return result;\\n    }\\n    \\n};\\n\\nMy code works fine when I run it locally but got \"ERROR: AddressSanitizer: heap-buffer-overflow\" whe I submit. Anyone know why?"
                    },
                    {
                        "username": "juuni26",
                        "content": "js in one line (not good for company environment haha) : \\n\\nvar reverseWords = function(s) {    \\n    return s.split(\" \").map(word => word.split(\"\").reverse().join(\\'\\')).join(\" \")\\n};\\n"
                    }
                ]
            }
        ]
    }
]