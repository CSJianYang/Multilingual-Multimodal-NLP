[
    {
        "title": "Subarrays with K Different Integers",
        "question_content": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA good array is an array where the number of different integers in that array is exactly k.\n\n\tFor example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.\n\nA subarray is a contiguous part of an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,1,2,3], k = 2\nOutput: 7\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]\n\nExample 2:\n\nInput: nums = [1,2,1,3,4], k = 3\nOutput: 3\nExplanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 2 * 104\n\t1 <= nums[i], k <= nums.length",
        "solutions": [
            {
                "id": 523136,
                "title": "java-c-python-sliding-window",
                "content": "**I republished this post.\\nThe original one is deleded by Leetcode without any notification or information.\\nThe only reason that, I included my youtube channel link.\\nExcusem me, What the HACK!?**\\n<br>\\n\\n## **Intuition**:\\nFirst you may have feeling of using sliding window.\\nThen this idea get stuck in the middle.\\n\\nThis problem will be a very typical sliding window,\\nif it asks the number of subarrays with **at most** K distinct elements.\\n\\nJust need one more step to reach the folloing equation:\\n`exactly(K) = atMost(K) - atMost(K-1)`\\n<br>\\n\\n## **Explanation**\\n1. Write/copy a helper function of sliding window,\\nto get the number of subarrays with at most K distinct elements.\\n2. Done.\\n<br>\\n\\n## **Complexity**:\\nTime `O(N)` for two passes.\\nSpace `O(K)` at most K elements in the counter\\n\\nOf course, you can merge 2 for loops into one, if you like.\\n<br>\\n\\n**Java:**\\n```java\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(int[] A, int K) {\\n        int i = 0, res = 0;\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int j = 0; j < A.length; ++j) {\\n            if (count.getOrDefault(A[j], 0) == 0) K--;\\n            count.put(A[j], count.getOrDefault(A[j], 0) + 1);\\n            while (K < 0) {\\n                count.put(A[i], count.get(A[i]) - 1);\\n                if (count.get(A[i]) == 0) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(vector<int>& A, int K) {\\n        int i = 0, res = 0;\\n        unordered_map<int, int> count;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!count[A[j]]++) K--;\\n            while (K < 0) {\\n                if (!--count[A[i]]) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def subarraysWithKDistinct(self, A, K):\\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\\n\\n    def atMostK(self, A, K):\\n        count = collections.Counter()\\n        res = i = 0\\n        for j in range(len(A)):\\n            if count[A[j]] == 0: K -= 1\\n            count[A[j]] += 1\\n            while K < 0:\\n                count[A[i]] -= 1\\n                if count[A[i]] == 0: K += 1\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(int[] A, int K) {\\n        int i = 0, res = 0;\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int j = 0; j < A.length; ++j) {\\n            if (count.getOrDefault(A[j], 0) == 0) K--;\\n            count.put(A[j], count.getOrDefault(A[j], 0) + 1);\\n            while (K < 0) {\\n                count.put(A[i], count.get(A[i]) - 1);\\n                if (count.get(A[i]) == 0) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(vector<int>& A, int K) {\\n        int i = 0, res = 0;\\n        unordered_map<int, int> count;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!count[A[j]]++) K--;\\n            while (K < 0) {\\n                if (!--count[A[i]]) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def subarraysWithKDistinct(self, A, K):\\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\\n\\n    def atMostK(self, A, K):\\n        count = collections.Counter()\\n        res = i = 0\\n        for j in range(len(A)):\\n            if count[A[j]] == 0: K -= 1\\n            count[A[j]] += 1\\n            while K < 0:\\n                count[A[i]] -= 1\\n                if count[A[i]] == 0: K += 1\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 235235,
                "title": "c-java-with-picture-prefixed-sliding-window",
                "content": "If the problem talks about continuous subarrays or substrings, the sliding window technique may help solve it in a linear time. Such problems are tricky, though the solution is simple once you get it. No wonder I am seeing such problems in almost every interview!\\n\\nHere, we will take a look at [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/) (LeetCode Hard), which appeared on LeetCode [weekly contest #123](https://leetcode.com/contest/weekly-contest-123). You can also master the sliding windows technique with these additional problems:\\n- [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\\n- [Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/)\\n- [Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)\\n<!--# Problem Description\\nGiven an array ```A``` of positive integers, call a (contiguous, not necessarily distinct) subarray of ```A``` good if the number of different integers in that subarray is exactly ```K```. For example, ```[1,2,3,1,2]``` has 3 different integers: 1, 2, and 3.\\n\\nReturn the number of good subarrays of ```A```.\\n### Example\\n**Input:** A = [1,2,1,2,3], K = 2\\n**Output:** 7\\n**Explanation:** Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\\n# Coding Practice\\nTry solving this problem before moving on to the solutions. It is available on LeetCode Online Judge ([Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/)). Also, as you read through a solution, try implementing it yourself.\\n\\nLeetCode is my favorite destinations for algorithmic problems. It has 987 problems and counting, with test cases to validate the correctness, as well as computational and memory complexity. There is also a large community discussing different approaches, tips and tricks.\\n# Brute-Force Solution\\nWe can just iterate through each sub-array using two loops and count the good ones. For the inner loop, we use hash set to count unique numbers; if we the set size becomes larger than ```K```, we break from the inner loop.\\n```\\nint subarraysWithKDistinct(vector<int>& A, int K, int res = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    unordered_set<int> s;\\n    for (auto j = i; j < A.size() && s.size() <= K; ++j) {\\n      s.insert(A[j]);\\n      if (s.size() == K) ++res;\\n    }\\n  }\\n  return res;\\n}\\n```\\n### Complexity Analysis\\nThe time complexity of this solution is *O(n * n)*, where *n* is the length of ```A```. This solution is not accepted by the online judge.\\n-->\\n# Intuition\\nIf the subarray ```[j, i]``` contains ```K``` unique numbers, and first ```prefix``` numbers also appear in ```[j + prefix, i]``` subarray, we have total ```1 + prefix``` good subarrays. For example, there are 3 unique numers in ```[1, 2, 1, 2, 3]```. First two numbers also appear in the remaining subarray ```[1, 2, 3]```, so we have 1 + 2 good subarrays: ```[1, 2, 1, 2, 3]```, ```[2, 1, 2, 3]``` and ```[1, 2, 3]```.\\n# Linear Solution\\nWe can iterate through the array and use two pointers for our sliding window (```[j, i]```). The back of the window is always the current position in the array (```i```). The front of the window (```j```) is moved so that A[j] appear only once in the sliding window. In other words, we are trying to shrink our sliding window while maintaining the same number of unique elements.\\n\\nTo do that, we keep tabs on how many times each number appears in our window (```m```). After we add next number to the back of our window, we try to remove as many as possible numbers from the front, until the number in the front appears only once. While removing numbers, we are increasing ```prefix```.\\n\\nIf we collected ```K``` unique numbers, then we found 1 + ```prefix``` sequences, as each removed number would also form a sequence.\\n\\nIf our window reached ```K + 1``` unique numbers, we remove one number from the head (again, that number appears only in the front), and reset ```prefix``` as now we are starting a new sequence. This process is demonstrated step-by-step for the test case below; ```prefix``` are shown as ```+1``` in the green background.\\n```\\n[5,7,5,2,3,3,4,1,5,2,7,4,6,2,3,8,4,5,7]\\n7\\n```\\n![image](https://assets.leetcode.com/users/votrubac/image_1549876616.png)\\n\\nIn the code below, we use ```cnt``` to track unique numbers. Since ```1 <= A[i] <= A.size()```, we can use an array instead of hash map to improve the performance.\\n```\\nint subarraysWithKDistinct(vector<int>& A, int K, int res = 0) {\\n  vector<int> m(A.size() + 1);\\n  for(auto i = 0, j = 0, prefix = 0, cnt = 0; i < A.size(); ++i) {\\n    if (m[A[i]]++ == 0) ++cnt;\\n    if (cnt > K) --m[A[j++]], --cnt, prefix = 0;\\n    while (m[A[j]] > 1) ++prefix, --m[A[j++]];\\n    if (cnt == K) res += prefix + 1;\\n  }\\n  return res;\\n}\\n```\\nJava version:\\n```\\npublic int subarraysWithKDistinct(int[] A, int K) {\\n  int res = 0, prefix = 0;\\n  int[] m = new int[A.length + 1];\\n  for (int i = 0, j = 0, cnt = 0; i < A.length; ++i) {\\n    if (m[A[i]]++ == 0) ++cnt;\\n    if (cnt > K) {\\n      --m[A[j++]]; --cnt; prefix = 0; \\n    }\\n    while (m[A[j]] > 1) {\\n      ++prefix; --m[A[j++]]; \\n    }\\n    if (cnt == K) res += prefix + 1;\\n  }\\n  return res;\\n} \\n```\\n### Complexity Analysis\\n- Time Complexity: *O(n)*, where *n* is the length of ```A```.\\n- Space Complexity: *O(n)*.",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```A```\n```A```\n```K```\n```[1,2,3,1,2]```\n```A```\n```K```\n```\\nint subarraysWithKDistinct(vector<int>& A, int K, int res = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    unordered_set<int> s;\\n    for (auto j = i; j < A.size() && s.size() <= K; ++j) {\\n      s.insert(A[j]);\\n      if (s.size() == K) ++res;\\n    }\\n  }\\n  return res;\\n}\\n```\n```A```\n```[j, i]```\n```K```\n```prefix```\n```[j + prefix, i]```\n```1 + prefix```\n```[1, 2, 1, 2, 3]```\n```[1, 2, 3]```\n```[1, 2, 1, 2, 3]```\n```[2, 1, 2, 3]```\n```[1, 2, 3]```\n```[j, i]```\n```i```\n```j```\n```m```\n```prefix```\n```K```\n```prefix```\n```K + 1```\n```prefix```\n```prefix```\n```+1```\n```\\n[5,7,5,2,3,3,4,1,5,2,7,4,6,2,3,8,4,5,7]\\n7\\n```\n```cnt```\n```1 <= A[i] <= A.size()```\n```\\nint subarraysWithKDistinct(vector<int>& A, int K, int res = 0) {\\n  vector<int> m(A.size() + 1);\\n  for(auto i = 0, j = 0, prefix = 0, cnt = 0; i < A.size(); ++i) {\\n    if (m[A[i]]++ == 0) ++cnt;\\n    if (cnt > K) --m[A[j++]], --cnt, prefix = 0;\\n    while (m[A[j]] > 1) ++prefix, --m[A[j++]];\\n    if (cnt == K) res += prefix + 1;\\n  }\\n  return res;\\n}\\n```\n```\\npublic int subarraysWithKDistinct(int[] A, int K) {\\n  int res = 0, prefix = 0;\\n  int[] m = new int[A.length + 1];\\n  for (int i = 0, j = 0, cnt = 0; i < A.length; ++i) {\\n    if (m[A[i]]++ == 0) ++cnt;\\n    if (cnt > K) {\\n      --m[A[j++]]; --cnt; prefix = 0; \\n    }\\n    while (m[A[j]] > 1) {\\n      ++prefix; --m[A[j++]]; \\n    }\\n    if (cnt == K) res += prefix + 1;\\n  }\\n  return res;\\n} \\n```\n```A```",
                "codeTag": "Unknown"
            },
            {
                "id": 235002,
                "title": "one-code-template-to-solve-all-of-these-problems",
                "content": "For [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/):\\n\\n```python\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        return self.subarraysWithAtMostKDistinct(A, K) - self.subarraysWithAtMostKDistinct(A, K-1)\\n    \\n    def subarraysWithAtMostKDistinct(self, s, k):\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > k:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res += r - l \\n        return res\\n```\\n\\nFor [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/):\\n\\n```python\\nclass Solution:\\n    def lengthOfLongestSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1\\n            while l < r and counter < r - l:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l)\\n        return res\\n```\\n\\nFor [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/):\\n\\n```python\\nclass Solution(object):\\n    def lengthOfLongestSubstringTwoDistinct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > 2:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l) \\n        return res\\n```\\n\\nFor [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/):\\n\\n```python\\nclass Solution(object):\\n    def lengthOfLongestSubstringKDistinct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > k:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l) \\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        return self.subarraysWithAtMostKDistinct(A, K) - self.subarraysWithAtMostKDistinct(A, K-1)\\n    \\n    def subarraysWithAtMostKDistinct(self, s, k):\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > k:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res += r - l \\n        return res\\n```\n```python\\nclass Solution:\\n    def lengthOfLongestSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1\\n            while l < r and counter < r - l:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l)\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def lengthOfLongestSubstringTwoDistinct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > 2:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l) \\n        return res\\n```\n```python\\nclass Solution(object):\\n    def lengthOfLongestSubstringKDistinct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > k:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l) \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360147,
                "title": "share-my-solution",
                "content": "Assume we have an array `A = [1, 1, 2, 1, 1, 3, 3, 2, 4, 2]` and `K = 3`\\nLet\\'s ask yourself how many ranges start with `index = 0` and have `3` distinct numbers?\\nWe can at first find the first range that satisfies this condition using sliding window, in which keep one head `lo = 0`, and increase another head `hi = 0` until we count the distinct numbers `= 3`\\n\\n`[1]` - `lo = 0, hi = 0, count = 1`\\n`[1,1]` - `lo = 0, hi = 1, count = 1`\\n`[1,1,2]` - `lo = 0, hi = 2, count = 2`\\n....\\n`[1,1,2,1,1,3]` - `lo = 0, hi = 5, count = 3`\\n\\nOk. We found it. Now keep increasing `hi`, what will happen?\\n\\n`[1,1,2,1,1,3,3]` - `lo = 0, hi = 6, count still = 3`, because `A[hi] = 3` is still the one of the old numbers\\n`[1,1,2,1,1,3,3,2]` - `lo = 0, hi = 7, count still = 3`, because `A[hi] = 2` is still the one of the old numbers\\n**However**:\\n`[1,1,2,1,1,3,3,2,4]` - `lo = 0, hi = 8, count = 4`, because `A[hi] = 4` is the new number\\nSo, now we know if the new number appears, we can stop the journey. We call the `index` before making the new number appear is `max`. We have:\\n\\n- The range starting with `lo = 0` and have `K = 3` distinct numbers = `max - hi + 1`\\n\\n- The same analysis for how many ranges start with `lo = 1` and have `K = 3` distinct numbers = `max - hi + 1`\\n- We keep shrinking the window by increasing `lo`, until the `count` of distinct numbers `< K = 3`. Then we repeat : increasing `hi` until the `count of distinct numbers `= `3`\\n\\n`1....1....2....1....1....3....3....2....4....2`\\n`lo.......................hi........max`\\n`...............lo.................hi=max`\\n`.........................lo.............hi....max`\\n\\n````\\n\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n        int res = 0, count = 0, lo = 0, hi = 0, max = 0, n;\\n        Map<Integer, Integer> dp = new HashMap<>();\\n\\n        while (hi < A.length) {\\n            \\n            // define how many ranges starting with lo, and has K distinct numbers\\n            while (count == K) {\\n                res += max - hi + 1;\\n                n = dp.get(A[lo]);\\n                if (n == 1) {\\n                    count--;\\n                    hi++;\\n                }\\n                dp.put(A[lo], n-1);\\n                lo++;\\n            }\\n\\n            // find the first range starting with lo, and has K distinct numbers\\n            while (hi < A.length) {\\n                n = dp.getOrDefault(A[hi], 0);\\n                if (n == 0) count++;\\n                dp.put(A[hi], n+1);\\n                \\n                // if found hi, then define max\\n                if (count == K) {\\n                    max = hi;\\n                    while (max+1 < A.length) {\\n                        if (dp.getOrDefault(A[max+1], 0) == 0) break;\\n                        max++;\\n                    }\\n                    break;\\n                }\\n                hi++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n        int res = 0, count = 0, lo = 0, hi = 0, max = 0, n;\\n        Map<Integer, Integer> dp = new HashMap<>();\\n\\n        while (hi < A.length) {\\n            \\n            // define how many ranges starting with lo, and has K distinct numbers\\n            while (count == K) {\\n                res += max - hi + 1;\\n                n = dp.get(A[lo]);\\n                if (n == 1) {\\n                    count--;\\n                    hi++;\\n                }\\n                dp.put(A[lo], n-1);\\n                lo++;\\n            }\\n\\n            // find the first range starting with lo, and has K distinct numbers\\n            while (hi < A.length) {\\n                n = dp.getOrDefault(A[hi], 0);\\n                if (n == 0) count++;\\n                dp.put(A[hi], n+1);\\n                \\n                // if found hi, then define max\\n                if (count == K) {\\n                    max = hi;\\n                    while (max+1 < A.length) {\\n                        if (dp.getOrDefault(A[max+1], 0) == 0) break;\\n                        max++;\\n                    }\\n                    break;\\n                }\\n                hi++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640450,
                "title": "c-code-easy-solution-using-map-and-sliding-window-with-approach",
                "content": "Approach: To directly count the subarrays with exactly K different integers is hard but to find the count of subarrays with at most K different integers is easy. So the idea is to find the count of subarrays with at most K different integers, let it be C(K), and the count of subarrays with at most (K \\u2013 1) different integers, let it be C(K \\u2013 1) and finally take their difference, C(K) \\u2013 C(K \\u2013 1) which is the required answer.\\nCount of subarrays with at most K different elements can be easily calculated through the sliding window technique. The idea is to keep expanding the right boundary of the window till the count of distinct elements in the window is less than or equal to K and when the count of distinct elements inside the window becomes more than K, start shrinking the window from the left till the count becomes less than or equal to K. Also for every expansion, keep counting the subarrays as right \\u2013 left + 1 where right and left are the boundaries of the current window.\\n```\\nint atMostKDistinct(vector<int>& A,int n,int k){\\n    int count = 0;\\n    int left = 0;\\n    int right = 0;\\n    \\n    unordered_map<int,int> mp;\\n    \\n    while(right < n){\\n        \\n        //add current element in the map\\n        if(mp.find(A[right]) == mp.end()){\\n            mp[A[right]] = 1;\\n        }else{\\n            mp[A[right]]++;\\n        }\\n        \\n        while(mp.size() > k){\\n            mp[A[left]]--;\\n            if(mp[A[left]] == 0){\\n                mp.erase(A[left]);\\n            }\\n            left++;\\n        }\\n        \\n        count += right-left+1;\\n        right++;\\n    }\\n    \\n    \\n    return count;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int k) {\\n        int n = A.size();\\n        return atMostKDistinct(A,n,k) - atMostKDistinct(A,n,k-1);\\n    }\\n};\\n```\\nhope it helps",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint atMostKDistinct(vector<int>& A,int n,int k){\\n    int count = 0;\\n    int left = 0;\\n    int right = 0;\\n    \\n    unordered_map<int,int> mp;\\n    \\n    while(right < n){\\n        \\n        //add current element in the map\\n        if(mp.find(A[right]) == mp.end()){\\n            mp[A[right]] = 1;\\n        }else{\\n            mp[A[right]]++;\\n        }\\n        \\n        while(mp.size() > k){\\n            mp[A[left]]--;\\n            if(mp[A[left]] == 0){\\n                mp.erase(A[left]);\\n            }\\n            left++;\\n        }\\n        \\n        count += right-left+1;\\n        right++;\\n    }\\n    \\n    \\n    return count;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int k) {\\n        int n = A.size();\\n        return atMostKDistinct(A,n,k) - atMostKDistinct(A,n,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235417,
                "title": "sliding-window-logical-thinking",
                "content": "> so-called sliding window technique needs an aggregated requirement, for example, the window with at most K dinstinct or with at least K dinstinct.\\n\\n> so we transform the original problem to\\n> ```\\n>subarraysWith(K)Distinct = subarraysWithAtMost(K)Distinct - subarraysWithAtMost(K -1)Distinct\\n>```\\n\\n> intuitively,\\n> ```\\n> for (i = 0, i < n; i++) {\\n>   for (j = i; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct++;\\n>   }\\n> }\\n> ```\\n> optimize 1, loop j break earlier\\n> ```\\n> for (i = 0, i < n; i++) {\\n>   for (j = i; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct++;\\n>     else break;\\n>   }\\n> }\\n> ```\\n> optimize 2, j doen\\'t restart at i but keeps increasing\\n> ```\\n> for (i = 0, i < n; i++) {\\n>   for (; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct= j - i + 1;\\n>     else break;\\n>   }\\n> }\\n> ```\\n\\n> to check whether `[i, j] with at most K distinct`\\n> we maintain a map `chToFreq` to record a digit and its corresponding frequency in curret window [i, j]\\n****\\n```\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return subarraysWithAtMostKDistinct(A, K) - subarraysWithAtMostKDistinct(A, K - 1);\\n    }\\n    \\n    private int subarraysWithAtMostKDistinct(int[] A, int K) {\\n        if (K == 0) return 0;\\n        \\n        int j = 0, numGoodSubArr = 0, n = A.length;\\n        // Map a character to its frequency in current window.\\n        Map<Integer, Integer> chToFreq = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (; j < n; j++) {\\n                chToFreq.put(A[j], chToFreq.getOrDefault(A[j], 0) + 1);\\n                if (chToFreq.size() <= K) numGoodSubArr += j - i + 1; \\n                else {\\n                    chToFreq.put(A[j], chToFreq.get(A[j]) - 1);\\n                    if (chToFreq.get(A[j]) == 0) chToFreq.remove(A[j]);\\n                    break; \\n                }\\n            }\\n            chToFreq.put(A[i], chToFreq.get(A[i]) - 1);\\n            if (chToFreq.get(A[i]) == 0) chToFreq.remove(A[i]);\\n        }\\n\\n        return numGoodSubArr;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n>subarraysWith(K)Distinct = subarraysWithAtMost(K)Distinct - subarraysWithAtMost(K -1)Distinct\\n>```\n```\\n> for (i = 0, i < n; i++) {\\n>   for (j = i; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct++;\\n>   }\\n> }\\n> ```\n```\\n> for (i = 0, i < n; i++) {\\n>   for (j = i; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct++;\\n>     else break;\\n>   }\\n> }\\n> ```\n```\\n> for (i = 0, i < n; i++) {\\n>   for (; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct= j - i + 1;\\n>     else break;\\n>   }\\n> }\\n> ```\n```\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return subarraysWithAtMostKDistinct(A, K) - subarraysWithAtMostKDistinct(A, K - 1);\\n    }\\n    \\n    private int subarraysWithAtMostKDistinct(int[] A, int K) {\\n        if (K == 0) return 0;\\n        \\n        int j = 0, numGoodSubArr = 0, n = A.length;\\n        // Map a character to its frequency in current window.\\n        Map<Integer, Integer> chToFreq = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (; j < n; j++) {\\n                chToFreq.put(A[j], chToFreq.getOrDefault(A[j], 0) + 1);\\n                if (chToFreq.size() <= K) numGoodSubArr += j - i + 1; \\n                else {\\n                    chToFreq.put(A[j], chToFreq.get(A[j]) - 1);\\n                    if (chToFreq.get(A[j]) == 0) chToFreq.remove(A[j]);\\n                    break; \\n                }\\n            }\\n            chToFreq.put(A[i], chToFreq.get(A[i]) - 1);\\n            if (chToFreq.get(A[i]) == 0) chToFreq.remove(A[i]);\\n        }\\n\\n        return numGoodSubArr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237419,
                "title": "python-clean-sliding-window-2-pointers-o-n-99-06",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        freq = {}\\n        start = 0\\n        start_k = 0\\n        res = 0\\n        for i, x in enumerate(A):\\n            freq[x] = freq.get(x, 0) + 1\\n            if len(freq) == K + 1:\\n                # remove the distinct at start_k, move start_k, start\\n                del freq[A[start_k]]\\n                start_k += 1\\n                start = start_k\\n            if len(freq) == K:\\n                # update start_k and res (Notice: K >= 1)\\n                while freq[A[start_k]] > 1:\\n                    freq[A[start_k]] -= 1\\n                    start_k += 1\\n                res += start_k - start + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        freq = {}\\n        start = 0\\n        start_k = 0\\n        res = 0\\n        for i, x in enumerate(A):\\n            freq[x] = freq.get(x, 0) + 1\\n            if len(freq) == K + 1:\\n                # remove the distinct at start_k, move start_k, start\\n                del freq[A[start_k]]\\n                start_k += 1\\n                start = start_k\\n            if len(freq) == K:\\n                # update start_k and res (Notice: K >= 1)\\n                while freq[A[start_k]] > 1:\\n                    freq[A[start_k]] -= 1\\n                    start_k += 1\\n                res += start_k - start + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413266,
                "title": "c-java-python-fully-explained-sliding-window-hash-map-easy-to-understand",
                "content": "# Intuition\\nThe given code solution computes the number of subarrays in a given array \\'nums\\' that have exactly \\'k\\' distinct elements. It first calculates the count of subarrays with at most \\'k\\' distinct elements using the subArray function. Then it calculates the count of subarrays with at most \\'k-1\\' distinct elements using the same subArray function and subtracts it from the previous count. This gives the required count of subarrays with exactly \\'k\\' distinct elements.\\n\\n# Approach\\nThe code solution uses the sliding window technique to calculate the count of subarrays with at most \\'k\\' distinct elements. It initializes an unordered map to store the count of distinct elements in the current subarray. It also initializes \\'count\\', \\'start\\', and \\'end\\' to 0. The \\'end\\' pointer moves through the array while the count of distinct elements in the current subarray is less than or equal to \\'k\\'. If it becomes greater than \\'k\\', then the \\'start\\' pointer moves forward, and the count of the element at the \\'start\\' index is decreased until the count of distinct elements becomes less than or equal to \\'k\\' again. At each step, the count of subarrays is updated by adding the length of the current subarray (i.e., \\'end-start+1\\') to the \\'count\\'. Finally, the \\'count\\' is returned.\\n\\nThe function subarraysWithKDistinct calls the subArray function twice and subtracts the count of subarrays with at most \\'k-1\\' distinct elements from the count of subarrays with at most \\'k\\' distinct elements. This gives the required count of subarrays with exactly \\'k\\' distinct elements.\\n\\n# Complexity\\n- Time complexity: The time complexity of the subArray function is O(n), where \\'n\\' is the length of the input array \\'nums\\'. This is because each element in the array is visited at most twice (once by the \\'end\\' pointer and once by the \\'start\\' pointer), and the map operations are constant time on average. The time complexity of the subarraysWithKDistinct function is also O(n) because it calls the subArray function twice.\\n\\n- Space complexity: The space complexity of the subArray function is O(k), where \\'k\\' is the maximum number of distinct elements that can be present in a subarray. This is because the map can store at most \\'k\\' key-value pairs. The space complexity of the subarraysWithKDistinct function is also O(k) because it calls the subArray function twice.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int subArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> map;  // create an unordered map to store the count of each number in the current subarray\\n        int count = 0, start = 0, end = 0;  // initialize variables for count of valid subarrays, start and end index of subarray\\n        while (end < n) {  // loop through the array from the start to end index\\n            map[nums[end]]++;  // add the current element to the map and increment its count\\n            while (map.size() > k) {  // if the number of distinct elements in the map is greater than k, move the start index and remove elements from the map\\n                map[nums[start]]--;  // decrement the count of the element at the start index\\n                if (map[nums[start]] == 0) {  // if the count of the element at the start index becomes 0, remove it from the map\\n                    map.erase(nums[start]);\\n                }\\n                start++;  // increment the start index to move the window\\n            }\\n            count += end - start + 1;  // add the count of valid subarrays for the current subarray to the total count\\n            end++;  // increment the end index to move the window\\n        }\\n        return count;  // return the total count of valid subarrays\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // return the count of subarrays with exactly k distinct elements minus the count of subarrays with less than k distinct elements\\n        return subArray(nums, k) - subArray(nums, k - 1);\\n    }\\n};\\n\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int subArray(List<Integer> nums, int k) {\\n        int n = nums.size();\\n        Map<Integer, Integer> map = new HashMap<>(); // create a map to store the count of each number in the current subarray\\n        int count = 0, start = 0, end = 0; // initialize variables for count of valid subarrays, start and end index of subarray\\n        while (end < n) { // loop through the array from the start to end index\\n            map.put(nums.get(end), map.getOrDefault(nums.get(end), 0) + 1); // add the current element to the map and increment its count\\n            while (map.size() > k) { // if the number of distinct elements in the map is greater than k, move the start index and remove elements from the map\\n                map.put(nums.get(start), map.get(nums.get(start)) - 1); // decrement the count of the element at the start index\\n                if (map.get(nums.get(start)) == 0) { // if the count of the element at the start index becomes 0, remove it from the map\\n                    map.remove(nums.get(start));\\n                }\\n                start++; // increment the start index to move the window\\n            }\\n            count += end - start + 1; // add the count of valid subarrays for the current subarray to the total count\\n            end++; // increment the end index to move the window\\n        }\\n        return count; // return the total count of valid subarrays\\n    }\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        List<Integer> list = new ArrayList<>(); // convert the input array to a list\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        // return the count of subarrays with exactly k distinct elements minus the count of subarrays with less than k distinct elements\\n        return subArray(list, k) - subArray(list, k - 1);\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def subArray(self, nums, k):\\n        n = len(nums)\\n        map = {}\\n        count = 0\\n        start = 0\\n        end = 0\\n        while end < n:\\n            map[nums[end]] = map.get(nums[end], 0) + 1\\n            while len(map) > k:\\n                map[nums[start]] -= 1\\n                if map[nums[start]] == 0:\\n                    del map[nums[start]]\\n                start += 1\\n            count += end - start + 1\\n            end += 1\\n        return count\\n    \\n    def subarraysWithKDistinct(self, nums, k):\\n        return self.subArray(nums, k) - self.subArray(nums, k - 1)\\n\\n\\n```\\n\\n# Thank You\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> map;  // create an unordered map to store the count of each number in the current subarray\\n        int count = 0, start = 0, end = 0;  // initialize variables for count of valid subarrays, start and end index of subarray\\n        while (end < n) {  // loop through the array from the start to end index\\n            map[nums[end]]++;  // add the current element to the map and increment its count\\n            while (map.size() > k) {  // if the number of distinct elements in the map is greater than k, move the start index and remove elements from the map\\n                map[nums[start]]--;  // decrement the count of the element at the start index\\n                if (map[nums[start]] == 0) {  // if the count of the element at the start index becomes 0, remove it from the map\\n                    map.erase(nums[start]);\\n                }\\n                start++;  // increment the start index to move the window\\n            }\\n            count += end - start + 1;  // add the count of valid subarrays for the current subarray to the total count\\n            end++;  // increment the end index to move the window\\n        }\\n        return count;  // return the total count of valid subarrays\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // return the count of subarrays with exactly k distinct elements minus the count of subarrays with less than k distinct elements\\n        return subArray(nums, k) - subArray(nums, k - 1);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int subArray(List<Integer> nums, int k) {\\n        int n = nums.size();\\n        Map<Integer, Integer> map = new HashMap<>(); // create a map to store the count of each number in the current subarray\\n        int count = 0, start = 0, end = 0; // initialize variables for count of valid subarrays, start and end index of subarray\\n        while (end < n) { // loop through the array from the start to end index\\n            map.put(nums.get(end), map.getOrDefault(nums.get(end), 0) + 1); // add the current element to the map and increment its count\\n            while (map.size() > k) { // if the number of distinct elements in the map is greater than k, move the start index and remove elements from the map\\n                map.put(nums.get(start), map.get(nums.get(start)) - 1); // decrement the count of the element at the start index\\n                if (map.get(nums.get(start)) == 0) { // if the count of the element at the start index becomes 0, remove it from the map\\n                    map.remove(nums.get(start));\\n                }\\n                start++; // increment the start index to move the window\\n            }\\n            count += end - start + 1; // add the count of valid subarrays for the current subarray to the total count\\n            end++; // increment the end index to move the window\\n        }\\n        return count; // return the total count of valid subarrays\\n    }\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        List<Integer> list = new ArrayList<>(); // convert the input array to a list\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        // return the count of subarrays with exactly k distinct elements minus the count of subarrays with less than k distinct elements\\n        return subArray(list, k) - subArray(list, k - 1);\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def subArray(self, nums, k):\\n        n = len(nums)\\n        map = {}\\n        count = 0\\n        start = 0\\n        end = 0\\n        while end < n:\\n            map[nums[end]] = map.get(nums[end], 0) + 1\\n            while len(map) > k:\\n                map[nums[start]] -= 1\\n                if map[nums[start]] == 0:\\n                    del map[nums[start]]\\n                start += 1\\n            count += end - start + 1\\n            end += 1\\n        return count\\n    \\n    def subarraysWithKDistinct(self, nums, k):\\n        return self.subArray(nums, k) - self.subArray(nums, k - 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244641,
                "title": "c-easy-sliding-window-faster-than-80",
                "content": "Solution:: number of subarrays with  **k  different integers** = (number of subarrays with number of different integers **less than equal to k** ) - (number of subarrays with number of different integers **less than equal to k-1** )\\n```\\n//output of this function -->numbers of subarrays which have number of different integers less than equal to k\\n    int fun(int k,vector<int> nums)\\n    {\\n        if(k==0) return 0;\\n        unordered_map<int,int> mp;\\n        int j=0;\\n        int count=0;\\n        int n=nums.size();\\n        int total=0;\\n        vector<int> freq(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(freq[nums[i]]==0) count++;\\n            freq[nums[i]]++;\\n            if(count<=k) total+=(i-j+1); // (i-j+1) = number of subarrays ending at i-th position which contains number of different integers less than or equal to k\\n            else\\n            {\\n                while(count>k)\\n                {\\n                    freq[nums[j]]--;\\n                    if(freq[nums[j]]==0)\\n                    {\\n                        count--;\\n                    }\\n                    j++;\\n                }\\n                total+=(i-j+1);\\n            }\\n        }\\n        return total;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n       return fun(k,nums)-fun(k-1,nums);\\n    }\\n```\\t\\nIf you liked the Code, Give it a **Thumbs Up** !!!",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n//output of this function -->numbers of subarrays which have number of different integers less than equal to k\\n    int fun(int k,vector<int> nums)\\n    {\\n        if(k==0) return 0;\\n        unordered_map<int,int> mp;\\n        int j=0;\\n        int count=0;\\n        int n=nums.size();\\n        int total=0;\\n        vector<int> freq(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(freq[nums[i]]==0) count++;\\n            freq[nums[i]]++;\\n            if(count<=k) total+=(i-j+1); // (i-j+1) = number of subarrays ending at i-th position which contains number of different integers less than or equal to k\\n            else\\n            {\\n                while(count>k)\\n                {\\n                    freq[nums[j]]--;\\n                    if(freq[nums[j]]==0)\\n                    {\\n                        count--;\\n                    }\\n                    j++;\\n                }\\n                total+=(i-j+1);\\n            }\\n        }\\n        return total;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n       return fun(k,nums)-fun(k-1,nums);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672979,
                "title": "analysis-and-explanation-with-visualization",
                "content": "- How many subarrays are there in an array of size N? (subarrays can have size >= 1 up to N)\\n  \\n   ```\\n   There are n * (n + 1) / 2 subarrays in an array of size N. \\n   Example: A = [1,2,3,4]\\n   Subarrays: [1] [2] [3] [4] [1,2] [2,3] [3,4] [1,2,3] [2,3,4]\\n              Subarrays of size 1: 4\\n              Subarrays of size 2: 3\\n              Subarrays of size 3: 2\\n              Subarrays of size 4: 1\\n              Total subarrays: 4 + 3 + 2 + 1 or 1 + 2 + 3 + 4\\n              Which translates to: sum of the first N natural numbers where N is the size of the array\\n   ```\\n\\n- Compute subarrays of size at most k in array of size N:\\n   Solution: use the idea above and the sliding window technique. When our map exceeds k, we shrink it from the left side. In each iteration that we move the end point, we are computing the sum above (1 + 2 + 3 + ---- until end pointer). \\n\\n   ```csharp\\n   public int AtMostK(int[] s, int k) {\\n          Console.WriteLine(\"k = \" + k);\\n\\n          int res = 0;\\n          Dictionary<int, int> map = new Dictionary<int, int>();\\n          int start = 0, end = 0;\\n          while (end < s.Length) {\\n              if (!map.ContainsKey(s[end])) {\\n                  map.Add(s[end], 0);\\n              }\\n\\n              map[s[end]]++;\\n\\n              while (map.Count > k) {\\n                  map[s[start]]--;\\n                  if (map[s[start]] == 0) {\\n                      map.Remove(s[start]);\\n                  }\\n                  start++;\\n              }\\n\\n              res += end - start + 1;\\n              Console.Write(\"[\");\\n              for (int i = start; i <= end; i++) {\\n                  Console.Write(s[i] + (i == end ? \"\" : \",\"));\\n              }\\n              Console.WriteLine(\"]\");\\n\\n              end++;\\n          }\\n\\n          return res;\\n      }\\n   ```\\n  \\n - Compute subarrays of size EXACTLY K from an array of size N. \\n  Solution: Compute subarrays of size AT MOST K and subtract subarrays of size AT MOST K - 1.\\n  Why? atMostK(A, k) includes subarrays of size 1, 2, 3, .... k - 1 (all subrrays with size less than K). How to get rid of those arrays that have size less than K? Compute subarrays of size K - 1 which will give you subarrays of size 1, 2, 3, .... k - 2. The subarrays that we don\\'t want from the first list will be cancelled out by the subarrays in the second list. \\nVisualization: \\n![image](https://assets.leetcode.com/users/benevolent/image_1591429158.png)\\n\\nTherefore, we need to call the above function once with K and once with K - 1, and subtract the results:\\nFinal solution: \\n```csharp\\n return AtMost(s, k) - AtMost(s, k - 1)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   There are n * (n + 1) / 2 subarrays in an array of size N. \\n   Example: A = [1,2,3,4]\\n   Subarrays: [1] [2] [3] [4] [1,2] [2,3] [3,4] [1,2,3] [2,3,4]\\n              Subarrays of size 1: 4\\n              Subarrays of size 2: 3\\n              Subarrays of size 3: 2\\n              Subarrays of size 4: 1\\n              Total subarrays: 4 + 3 + 2 + 1 or 1 + 2 + 3 + 4\\n              Which translates to: sum of the first N natural numbers where N is the size of the array\\n   ```\n```csharp\\n   public int AtMostK(int[] s, int k) {\\n          Console.WriteLine(\"k = \" + k);\\n\\n          int res = 0;\\n          Dictionary<int, int> map = new Dictionary<int, int>();\\n          int start = 0, end = 0;\\n          while (end < s.Length) {\\n              if (!map.ContainsKey(s[end])) {\\n                  map.Add(s[end], 0);\\n              }\\n\\n              map[s[end]]++;\\n\\n              while (map.Count > k) {\\n                  map[s[start]]--;\\n                  if (map[s[start]] == 0) {\\n                      map.Remove(s[start]);\\n                  }\\n                  start++;\\n              }\\n\\n              res += end - start + 1;\\n              Console.Write(\"[\");\\n              for (int i = start; i <= end; i++) {\\n                  Console.Write(s[i] + (i == end ? \"\" : \",\"));\\n              }\\n              Console.WriteLine(\"]\");\\n\\n              end++;\\n          }\\n\\n          return res;\\n      }\\n   ```\n```csharp\\n return AtMost(s, k) - AtMost(s, k - 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348984,
                "title": "different-python-two-pointer-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/392901/Simple-Python-moving-window)\\n[3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/348137/Simple-Python-two-pointer-solution-(52ms-beat-97.94))\\n[159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/348157/Simple-Python-two-pointer-solution)\\n[340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/348216/Simple-Python-two-pointer-solution-(72-ms-beat-94.93))\\n[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/348984/Different-Python-two-pointer-solutions)\\n[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/363071/Simple-Python-two-pointer-solution)\\n[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/344476/Simple-Python-two-pointer-solution)\\n[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/discuss/344245/Simple-Python-solution-(beat-94.59))\\n[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/344533/Simple-Python-two-pointer-solution)\\n\\nSolution 1: \\nKeep a moving window expand while it contains less than k distinct integers, \\nthen shrink while it contains k + 1 distinct integers. \\nOnly save the right-most positions of distinct integers.\\nFor fixed ending at right, the window contains k distinct integers if the left end is between [left, left_k]. \\n\\nTime complexity: O(n * K) (Time Limit Exceeded, 52 / 55 test cases passed.)\\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        right_most_pos = dict()\\n        for right in range(len(A)):\\n            right_most_pos[A[right]] = right\\n            if len(right_most_pos) == K + 1:\\n                left_k = min(right_most_pos.values())\\n                right_most_pos.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(right_most_pos) == K:\\n                left_k = min(right_most_pos.values())\\n                res += left_k - left + 1\\n        return res\\n```\\n\\nSolution 2: use bisect to improve the efficiency of min(right_most_pos.values())\\nTime complexity: O(n * K) (512 ms, beat 85.48%)\\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        sorted_pos = []\\n        right_most_pos = dict()\\n        for right in range(len(A)):\\n            if A[right] in right_most_pos:\\n                ind = bisect.bisect_left(sorted_pos, right_most_pos[A[right]])\\n                sorted_pos.pop(ind)\\n            sorted_pos.append(right)\\n            right_most_pos[A[right]] = right\\n            if len(right_most_pos) == K + 1:\\n                left_k = sorted_pos.pop(0)\\n                right_most_pos.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(right_most_pos) == K:\\n                left_k = sorted_pos[0]\\n                res += left_k - left + 1\\n        return res\\n```\\n\\nSolution 3: instead of saving the right-most positions of distinct integers, we save their frequences\\nTime complexity: O(n) (424 ms, beat 95.16%)\\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        counter = dict()\\n        for right in range(len(A)):\\n            counter[A[right]] = counter.get(A[right], 0) + 1\\n            if len(counter) == K + 1:\\n                counter.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(counter) == K:\\n                while counter[A[left_k]] > 1:\\n                    counter[A[left_k]] -= 1\\n                    left_k += 1\\n                res += left_k - left + 1\\n        return res\\n```\\n\\t\\t\\nSolution 4: two-pass solution\\nTime complexity O(n), (584 ms, beat 62.90%)\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A, K):\\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\\n\\n    def atMostK(self, A, K):\\n        counter = dict()\\n        res = 0\\n        left = 0\\n        for right in range(len(A)):\\n            counter[A[right]] = counter.get(A[right], 0) + 1\\n            while len(counter) > K:\\n                counter[A[left]] -= 1\\n                if counter[A[left]] == 0:\\n                    counter.pop(A[left])\\n                left += 1\\n            res += right - left + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        right_most_pos = dict()\\n        for right in range(len(A)):\\n            right_most_pos[A[right]] = right\\n            if len(right_most_pos) == K + 1:\\n                left_k = min(right_most_pos.values())\\n                right_most_pos.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(right_most_pos) == K:\\n                left_k = min(right_most_pos.values())\\n                res += left_k - left + 1\\n        return res\\n```\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        sorted_pos = []\\n        right_most_pos = dict()\\n        for right in range(len(A)):\\n            if A[right] in right_most_pos:\\n                ind = bisect.bisect_left(sorted_pos, right_most_pos[A[right]])\\n                sorted_pos.pop(ind)\\n            sorted_pos.append(right)\\n            right_most_pos[A[right]] = right\\n            if len(right_most_pos) == K + 1:\\n                left_k = sorted_pos.pop(0)\\n                right_most_pos.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(right_most_pos) == K:\\n                left_k = sorted_pos[0]\\n                res += left_k - left + 1\\n        return res\\n```\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        counter = dict()\\n        for right in range(len(A)):\\n            counter[A[right]] = counter.get(A[right], 0) + 1\\n            if len(counter) == K + 1:\\n                counter.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(counter) == K:\\n                while counter[A[left_k]] > 1:\\n                    counter[A[left_k]] -= 1\\n                    left_k += 1\\n                res += left_k - left + 1\\n        return res\\n```\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A, K):\\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\\n\\n    def atMostK(self, A, K):\\n        counter = dict()\\n        res = 0\\n        left = 0\\n        for right in range(len(A)):\\n            counter[A[right]] = counter.get(A[right], 0) + 1\\n            while len(counter) > K:\\n                counter[A[left]] -= 1\\n                if counter[A[left]] == 0:\\n                    counter.pop(A[left])\\n                left += 1\\n            res += right - left + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996719,
                "title": "for-those-who-didn-t-understand-why-exactly-k-atmost-k-atmost-k-1-works",
                "content": "Well, suppose you have a room with a bunch of children in it. It turns out that there are 12 children who are five years old or under, and 8 children who are four years old or under.\\n\\nNow presumably you agree that each one of the \"children four years old or under\" is also one of the \"children five years old or under,\" right?\\n\\nSo suppose we take the 12 children five years old or younger, and remove from them the 8 children four years old or younger. Of course, 12 - 8 = 4 children remain.\\n\\nNow, how old is each of these children?\\n\\nBelow I am sharing the solution using variable sized sliding window based on above approach.\\n```\\nclass Solution {\\n  public int subarraysWithKDistinct(int[] nums, int k) {\\n\\n    return subarraysWithKSize(nums, k) - subarraysWithKSize(nums, k - 1);\\n  }\\n    \\n    //Function for at-most k distinct\\n    \\n  public int subarraysWithKSize(int[] nums, int k) {\\n    HashMap < Integer, Integer > hs = new HashMap < > ();\\n    int count = 0;\\n    int i = 0;\\n    int j = 0;\\n    while (j < nums.length) {\\n      hs.put(nums[j], hs.getOrDefault(nums[j], 0) + 1);\\n\\n      while (hs.size() == k + 1) \\n      { \\n        hs.put(nums[i], hs.get(nums[i]) - 1);\\n        if (hs.get(nums[i]) == 0)\\n          hs.remove(nums[i]);\\n        i++;\\n\\n      }\\n\\n      count += j - i + 1;\\n      j++;\\n\\n    }\\n\\n    return count;\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  public int subarraysWithKDistinct(int[] nums, int k) {\\n\\n    return subarraysWithKSize(nums, k) - subarraysWithKSize(nums, k - 1);\\n  }\\n    \\n    //Function for at-most k distinct\\n    \\n  public int subarraysWithKSize(int[] nums, int k) {\\n    HashMap < Integer, Integer > hs = new HashMap < > ();\\n    int count = 0;\\n    int i = 0;\\n    int j = 0;\\n    while (j < nums.length) {\\n      hs.put(nums[j], hs.getOrDefault(nums[j], 0) + 1);\\n\\n      while (hs.size() == k + 1) \\n      { \\n        hs.put(nums[i], hs.get(nums[i]) - 1);\\n        if (hs.get(nums[i]) == 0)\\n          hs.remove(nums[i]);\\n        i++;\\n\\n      }\\n\\n      count += j - i + 1;\\n      j++;\\n\\n    }\\n\\n    return count;\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234614,
                "title": "java-solution-using-two-pointers-and-hashmap",
                "content": "\\t class Solution {\\n\\t\\tpublic int subarraysWithKDistinct(int[] nums, int K) {\\n\\t\\t\\tMap<Integer,Integer> map = new HashMap<>();\\n\\n\\t\\t\\tint first=0;\\n\\t\\t\\tint second = 0;\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\twhile(second < nums.length){\\n\\t\\t\\t\\tmap.put(nums[second],map.getOrDefault(nums[second],0)+1);           \\n\\t\\t\\t\\tif(map.size()>K){\\n\\t\\t\\t\\t\\tmap.clear();\\n\\t\\t\\t\\t\\tfirst++;\\n\\t\\t\\t\\t\\tsecond = first;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(map.size() == K){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tsecond++;\\n\\t\\t\\t\\t\\tif(second == nums.length){\\n\\t\\t\\t\\t\\t\\tmap.clear();\\n\\t\\t\\t\\t\\t\\tfirst++;\\n\\t\\t\\t\\t\\t\\tsecond = first;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tsecond++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count;\\n        \\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n\\t\\n\\tThe Idea is to iterate the second pointer until the size of the map is equal to k and then clear the map and move the first pointer.",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int subarraysWithKDistinct(int[] nums, int K) {\\n\\t\\t\\tMap<Integer,Integer> map = new HashMap<>();\\n\\n\\t\\t\\tint first=0;\\n\\t\\t\\tint second = 0;\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\twhile(second < nums.length){\\n\\t\\t\\t\\tmap.put(nums[second],map.getOrDefault(nums[second],0)+1);           \\n\\t\\t\\t\\tif(map.size()>K){\\n\\t\\t\\t\\t\\tmap.clear();\\n\\t\\t\\t\\t\\tfirst++;\\n\\t\\t\\t\\t\\tsecond = first;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 234855,
                "title": "c-o-nk-sliding-modification-with-detailed-explanation",
                "content": "We used a map to keep track of the **last apperance index of a character**. \\nThen we move the **right** in outer layer to update the map. \\nIf we have more than K element inside the window, move the **left** curosr, decrease number and update the map.\\nWhen the map have exactly K element, loop through the map to find out the **minIndex** of the map.  \\n#### ***Any window start between [left, minIndex] and end with right is a qualified answer.***\\nTime complexity **O(NK)**, each element is put/pop from the sliding windows/map only once, each iteration might loop throguh all k element in the map.\\nSpace complexity **O(K)**, for the map keep track of last apperance of each K element.\\n```\\nint subarraysWithKDistinct(vector<int>& A, int K) {\\n    int answer = 0;\\n    unordered_map<int, int> m;\\n    int left = 0;\\n    int right = 0;\\n    while(right < A.size()) {                   // each element is only put into windows once\\n        m[A[right]] = right;\\n\\n        while (m.size() > K) {                 \\n            if (m[A[left]] == left)             // A[left] can be removed from the map if left is the last apperance\\n                m.erase(A[left]);\\n            left++;                             // each element is only pop from windows once\\n        }\\n        if (m.size() == K) {\\n            int minIndex = right;\\n            for (auto i : m)                    // find the minIndex of the map\\n                minIndex = min(minIndex, i.second);\\n            answer += minIndex - left + 1;      // Any window start between [left, minIndex] and end with right is a qualified answer.\\n        }\\n        right++;\\n    }\\n    return answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint subarraysWithKDistinct(vector<int>& A, int K) {\\n    int answer = 0;\\n    unordered_map<int, int> m;\\n    int left = 0;\\n    int right = 0;\\n    while(right < A.size()) {                   // each element is only put into windows once\\n        m[A[right]] = right;\\n\\n        while (m.size() > K) {                 \\n            if (m[A[left]] == left)             // A[left] can be removed from the map if left is the last apperance\\n                m.erase(A[left]);\\n            left++;                             // each element is only pop from windows once\\n        }\\n        if (m.size() == K) {\\n            int minIndex = right;\\n            for (auto i : m)                    // find the minIndex of the map\\n                minIndex = min(minIndex, i.second);\\n            answer += minIndex - left + 1;      // Any window start between [left, minIndex] and end with right is a qualified answer.\\n        }\\n        right++;\\n    }\\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638798,
                "title": "c-code-with-through-explanation",
                "content": "When you move the right cursor, keep tracking whether we have reach a count of K distinct integers, if yes, we process left cursor, here is how we process left cursor:\\n\\ncheck whether the element pointed by left cursor is duplicated in window, if yes, we remove it, and use a variable (e.g. prefix) to record that we have removed an element from the window). keep this process until we reduce the window size from to exactly K. now we can calculate the number of valid good array as res += prefix;\\n\\nafter process left cursor and all the stuff, the outer loop will continue and right cursor will move forward, and then the window size will exceed K, we can simply drop the left most element of the window and reset prefix to 0. and continue on.\\n\\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int res = 0;\\n      \\tvector<int> m(A.size() + 1);\\n        int end = 0, begin = 0, prefix = 0, cnt = 0;\\n      \\twhile(end < A.size()) {\\n        \\tif (m[A[end++]]++ == 0) ++cnt;\\n        \\tif (cnt > K) {\\n                --m[A[begin++]];\\n                --cnt;\\n                prefix = 0;\\n            }\\n        \\twhile (m[A[begin]] > 1) {\\n                ++prefix; \\n                --m[A[begin++]];\\n            }\\n        \\tif (cnt == K) \\n                res += prefix + 1;\\n      \\t}\\n      \\treturn res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/juniway/image_1589794387.png)\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int res = 0;\\n      \\tvector<int> m(A.size() + 1);\\n        int end = 0, begin = 0, prefix = 0, cnt = 0;\\n      \\twhile(end < A.size()) {\\n        \\tif (m[A[end++]]++ == 0) ++cnt;\\n        \\tif (cnt > K) {\\n                --m[A[begin++]];\\n                --cnt;\\n                prefix = 0;\\n            }\\n        \\twhile (m[A[begin]] > 1) {\\n                ++prefix; \\n                --m[A[begin++]];\\n            }\\n        \\tif (cnt == K) \\n                res += prefix + 1;\\n      \\t}\\n      \\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379342,
                "title": "sliding-window-aditya-verma-s-approach-easy-to-understand",
                "content": "# Link to a similar problem && solution :) \\nhttps://leetcode.com/problems/binary-subarrays-with-sum/solutions/3379313/easy-sliding-window-comments-added-for-explanation-beats-92/ \\n# Approach :\\nThe given code provides a solution to find the number of subarrays that contain exactly k distinct integers. It uses a sliding window approach with the help of an unordered map to keep track of the count of each integer in the current window.\\n\\nThe subarrayCountWithAtMostKchar function is used to find the number of subarrays that have at most k distinct integers. It initializes two pointers i and j at the start of the array and uses an unordered map mp to keep track of the count of each integer in the current window. It then moves the right pointer j forward, increments the count of the integer arr[j] in the map, and checks if the number of distinct integers in the map is less than or equal to k. If it is, then it updates the count with the number of subarrays that can be formed with this window and moves the right pointer j forward. If it is not, then it moves the left pointer i forward, decrements the count of the integer arr[i] in the map, and checks if the count becomes 0. If it does, then it removes the integer from the map. It continues this process until the number of distinct integers in the map is less than or equal to k. After shrinking the window, it updates the count with the number of subarrays that can be formed with this window and moves the right pointer j forward. It repeats this process until the right pointer j reaches the end of the array.\\n\\nThe subarraysWithKDistinct function is used to find the number of subarrays that have exactly k distinct integers. It calls the subarrayCountWithAtMostKchar function twice with k and k-1 as input, respectively. It then returns the difference between these two counts, which gives the count of subarrays that have exactly k distinct integers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : The time complexity of the given code is $$O(N)$$, where N is the length of the input array arr or nums. This is because we iterate through each element of the array once using the sliding window approach, and perform constant time operations at each step.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity :  The space complexity of the given code is  $$O(K)$$, where K is the size of the unordered map mp. This is because we store at most K distinct integers in the map at any given time.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// This is a solution to find the number of subarrays that contain exactly k distinct integers\\n\\nclass Solution {\\npublic:\\n    int subarrayCountWithAtMostKchar(vector<int>& arr, int k) {\\n        int i = 0, j = 0, count = 0;\\n        unordered_map<int, int> mp; // create an unordered map to keep track of the count of each integer\\n\\n        while (j < arr.size()) {\\n            mp[arr[j]]++; // increment the count of integer arr[j] in the map\\n\\n            if (mp.size() <= k) { // if the number of distinct integers in the map is less than or equal to k\\n                count += j - i + 1; // then update the count with the number of subarrays that can be formed with this window\\n                j++; // move the right pointer forward\\n            } else {\\n                while (mp.size() > k) { // if the number of distinct integers in the map is greater than k\\n                    mp[arr[i]]--; // decrement the count of the integer arr[i] in the map\\n\\n                    if (mp[arr[i]] == 0) { // if the count becomes 0\\n                        mp.erase(arr[i]); // then remove the integer from the map\\n                    }\\n\\n                    i++; // move the left pointer forward\\n                }\\n\\n                if (mp.size() <= k) { // after shrinking the window, if the number of distinct integers in the map is less than or equal to k\\n                    count += j - i + 1; // then update the count with the number of subarrays that can be formed with this window\\n                }\\n\\n                j++; // move the right pointer forward\\n            }\\n        }\\n\\n        return count; // return the count\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int a = subarrayCountWithAtMostKchar(nums, k); // get the count of subarrays with at most k distinct integers\\n        int b = subarrayCountWithAtMostKchar(nums, k - 1); // get the count of subarrays with at most k-1 distinct integers\\n\\n        return a - b; // the difference between these counts gives the count of subarrays with exactly k distinct integers\\n    }\\n};\\n\\n```\\n\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n**![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/a234e8f5-3869-425b-94a7-beee9509065f_1680614836.0752363.gif)**\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n// This is a solution to find the number of subarrays that contain exactly k distinct integers\\n\\nclass Solution {\\npublic:\\n    int subarrayCountWithAtMostKchar(vector<int>& arr, int k) {\\n        int i = 0, j = 0, count = 0;\\n        unordered_map<int, int> mp; // create an unordered map to keep track of the count of each integer\\n\\n        while (j < arr.size()) {\\n            mp[arr[j]]++; // increment the count of integer arr[j] in the map\\n\\n            if (mp.size() <= k) { // if the number of distinct integers in the map is less than or equal to k\\n                count += j - i + 1; // then update the count with the number of subarrays that can be formed with this window\\n                j++; // move the right pointer forward\\n            } else {\\n                while (mp.size() > k) { // if the number of distinct integers in the map is greater than k\\n                    mp[arr[i]]--; // decrement the count of the integer arr[i] in the map\\n\\n                    if (mp[arr[i]] == 0) { // if the count becomes 0\\n                        mp.erase(arr[i]); // then remove the integer from the map\\n                    }\\n\\n                    i++; // move the left pointer forward\\n                }\\n\\n                if (mp.size() <= k) { // after shrinking the window, if the number of distinct integers in the map is less than or equal to k\\n                    count += j - i + 1; // then update the count with the number of subarrays that can be formed with this window\\n                }\\n\\n                j++; // move the right pointer forward\\n            }\\n        }\\n\\n        return count; // return the count\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int a = subarrayCountWithAtMostKchar(nums, k); // get the count of subarrays with at most k distinct integers\\n        int b = subarrayCountWithAtMostKchar(nums, k - 1); // get the count of subarrays with at most k-1 distinct integers\\n\\n        return a - b; // the difference between these counts gives the count of subarrays with exactly k distinct integers\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920753,
                "title": "python-hashmap-sliding-window-simple-solution-wiith-explanation",
                "content": "## Logic:\\n1. To directly count the subarrays with exactly K different integers is hard but to find the count of subarrays with at most K different integers is easy. \\n2. So the idea is to find the count of subarrays with at most K different integers(fn(K)), and the count of subarrays with at most (K \\u2013 1) different integers(fn(K \\u2013 1)) and finally take their difference, fn(K) \\u2013 fn(K \\u2013 1) which is the required answer.\\n3. Now, count of subarrays with at most K different elements can be easily calculated through the sliding window technique. \\n4. The idea is to keep expanding the right boundary of the window till the count of distinct elements in the window is less than or equal to K and when the count of distinct elements inside the window becomes more than K, start shrinking the window from the left till the count becomes less than or equal to K. Also for every expansion, keep counting the subarrays as end \\u2013 start + 1.\\n\\n```\\nclass Solution:\\n    def atMostKDistinct(self, nums, k):\\n        hashmap = {}\\n        subarrays = 0\\n        start, end = 0, 0\\n        while end < len(nums):\\n            if nums[end] in hashmap:\\n                hashmap[nums[end]] += 1\\n            else:\\n                hashmap[nums[end]] = 1\\n            while len(hashmap) > k:\\n                hashmap[nums[start]] -= 1\\n                if hashmap[nums[start]] == 0:\\n                    del hashmap[nums[start]]\\n                start += 1\\n            subarrays += end-start+1\\n            end += 1\\n        return subarrays\\n    \\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atMostKDistinct(nums, k) - self.atMostKDistinct(nums, k-1)\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def atMostKDistinct(self, nums, k):\\n        hashmap = {}\\n        subarrays = 0\\n        start, end = 0, 0\\n        while end < len(nums):\\n            if nums[end] in hashmap:\\n                hashmap[nums[end]] += 1\\n            else:\\n                hashmap[nums[end]] = 1\\n            while len(hashmap) > k:\\n                hashmap[nums[start]] -= 1\\n                if hashmap[nums[start]] == 0:\\n                    del hashmap[nums[start]]\\n                start += 1\\n            subarrays += end-start+1\\n            end += 1\\n        return subarrays\\n    \\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atMostKDistinct(nums, k) - self.atMostKDistinct(nums, k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205721,
                "title": "easy-sliding-window-approach-in-c-o-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    // Helper function to determine number of subarrays with at most k distinct integers\\n    int helper(vector<int>&nums,int k)\\n    {\\n        int i=0,j=0,count=0,n=nums.size();\\n        unordered_map<int,int>m;\\n        while(j<n)\\n        {\\n            m[nums[j]]++;\\n            while(i<=j && m.size()>k)\\n            {\\n                if(m[nums[i]]==1)\\n                {\\n                    m.erase(nums[i]);\\n                }\\n                else\\n                {\\n                    m[nums[i]]--;\\n                }\\n                i++;\\n            }\\n            count+=(j-i+1);\\n            j++;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        // The concept:-->\\n        // helper(nums,k)=number of subarrays with at most k distinct integers\\n        // helper(nums,k-1)=number of subarrays with at most k-1 distinct integers\\n        // So more formally we can say that \\n        // helper(nums,k)=number of subarrays with exactly k distinct integers + number of subarrays with less than k distinct integers\\n        // So if we exclude the number of subarrays with less than k distinct integers from the number of subarrays with at most k distinct integers, we\\'ll get our answer.\\n        return helper(nums,k)-helper(nums,k-1);\\n    }\\n};\\n```\\n**Don\\'t forget to upvote if you\\'ve got any help from my explanation.**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    // Helper function to determine number of subarrays with at most k distinct integers\\n    int helper(vector<int>&nums,int k)\\n    {\\n        int i=0,j=0,count=0,n=nums.size();\\n        unordered_map<int,int>m;\\n        while(j<n)\\n        {\\n            m[nums[j]]++;\\n            while(i<=j && m.size()>k)\\n            {\\n                if(m[nums[i]]==1)\\n                {\\n                    m.erase(nums[i]);\\n                }\\n                else\\n                {\\n                    m[nums[i]]--;\\n                }\\n                i++;\\n            }\\n            count+=(j-i+1);\\n            j++;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        // The concept:-->\\n        // helper(nums,k)=number of subarrays with at most k distinct integers\\n        // helper(nums,k-1)=number of subarrays with at most k-1 distinct integers\\n        // So more formally we can say that \\n        // helper(nums,k)=number of subarrays with exactly k distinct integers + number of subarrays with less than k distinct integers\\n        // So if we exclude the number of subarrays with less than k distinct integers from the number of subarrays with at most k distinct integers, we\\'ll get our answer.\\n        return helper(nums,k)-helper(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720917,
                "title": "c-o-n-sliding-window-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/subarrays-with-k-different-integers/submissions/\\n    \\n    We use a different problem to solve this. We find the number of substrings with atmost\\n    K unique chars. \\n    substrings with exactly k = atmost unique (K) - atmost unique (K-1)\\n    This diff only leaves the substrings with exactly k unique chars\\n*/\\nclass Solution {\\npublic:\\n    // Finds the substring with atmost K unique chars\\n    int atmostK(vector<int>& arr, int K) {\\n        int i = 0, j = 0, substrings = 0;\\n        unordered_map<int, int> freq;\\n        const int N = arr.size();\\n        \\n        while(i < N) {\\n            // Expand the window\\n            if(K >= 0) {\\n                ++freq[arr[i]];\\n                if(freq[arr[i]] == 1)\\n                    --K;\\n                ++i;\\n            }\\n            // make the window valid\\n            while(K < 0) {\\n                --freq[arr[j]];\\n                if(freq[arr[j]] == 0)\\n                    ++K;\\n                ++j;\\n            }\\n            // Each valid window adds the subarrays which satisfies the condition\\n            // For : 1,2,1, k=2\\n            // 1: [1] \\n            // 2: [2], [1,2]\\n            // 3: [1,2], [2,1], [1,2,1]\\n            substrings += i - j + 1;\\n        }\\n        return substrings;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& arr, int K) {\\n        return atmostK(arr, K) - atmostK(arr, K-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/subarrays-with-k-different-integers/submissions/\\n    \\n    We use a different problem to solve this. We find the number of substrings with atmost\\n    K unique chars. \\n    substrings with exactly k = atmost unique (K) - atmost unique (K-1)\\n    This diff only leaves the substrings with exactly k unique chars\\n*/\\nclass Solution {\\npublic:\\n    // Finds the substring with atmost K unique chars\\n    int atmostK(vector<int>& arr, int K) {\\n        int i = 0, j = 0, substrings = 0;\\n        unordered_map<int, int> freq;\\n        const int N = arr.size();\\n        \\n        while(i < N) {\\n            // Expand the window\\n            if(K >= 0) {\\n                ++freq[arr[i]];\\n                if(freq[arr[i]] == 1)\\n                    --K;\\n                ++i;\\n            }\\n            // make the window valid\\n            while(K < 0) {\\n                --freq[arr[j]];\\n                if(freq[arr[j]] == 0)\\n                    ++K;\\n                ++j;\\n            }\\n            // Each valid window adds the subarrays which satisfies the condition\\n            // For : 1,2,1, k=2\\n            // 1: [1] \\n            // 2: [2], [1,2]\\n            // 3: [1,2], [2,1], [1,2,1]\\n            substrings += i - j + 1;\\n        }\\n        return substrings;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& arr, int K) {\\n        return atmostK(arr, K) - atmostK(arr, K-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262299,
                "title": "single-pass-two-pointer-4ms-java-solution-beats-100-o-n-space",
                "content": "# Background\\nMy first serious attempt was basically this one, but at each loop iteration where I had K unique integers captured, I would manually count the subarrays possible within that range. I would do this by counting how many indices on the left pointed to duplicate values. Looking at other solutions I realized that I don\\'t need to count every time as I can remember how many \"extra\" copies of the unique integers I had at the left of the range and that count was the number of subarrays represented (count+1 actually). It tended towards O(N) in practice, but the extra counting at each step could drive it to a higher complexity if the entire array ended up being one big long valid subarray.\\n\\nMany of the variations of this counting method use a Map for storing the counts, and that is a similar O(N) time complexity to this solution, but slows down the operation of each step compared to using a bucket sort and may use more storage depending on how much you thrash the storage of the Map.  The definition of the problem carefully limits the range of integers you can find in the array to 1..N where N is the size of the data array.  So, accepting O(N) space usage, we can use bucket sorting which is much faster.\\n\\nI\\'ll note that I also used a loop at one point for the \"if (K < 0)\" case thinking that I had to pass up all values until I found one whose count went to 0.  I noticed a solution that didn\\'t use a loop there and realized that if you\\'ve already skipped the left pointer past all of the \"extra\" values (counting them so you know how many subarrays are represented), then the value at the left pointer should be unique, and its count should be 1 exactly.  Thus, you always have at most one value to advance the left pointer past before you are down to the intended number of unique integers in the range.\\n\\nI am not sure why this runs more than 2ms faster than any other Java solution as there is nothing unique here that isn\\'t already used in any number of the other discussion examples, but its run time is consistently shown 2 stops faster than any other recorded solution.\\n\\nHere is a more formal description of the way it works.\\n\\n# Observations\\n- First note that a given range of unique integers can exist within the array with duplicates, such as in **[1,2,1,2]**. For **K=2** that is an example of one of the valid subarrays to be counted, but it also contains further subarrays that should also be counted.\\n- We can exhaustively count all possible subarrays of that range of 4 values, but things get complicated depending on the pattern of the repeated integers.\\n- To break it down, we can find the first unique subarray that starts at the first value and contains all of the integers - [**1,2**,1,2].  It has no further subarrays that also count, so we only get 1 subarray at that position.\\n- Moving to the right by one, we can count all unique subarrays that end at the next index - [1,**2,1**,2] and [**1,2,1**,2]\\n- Finally we move again to the right and count all unique subarrays that end at the last index - [1,2,**1,2**], [1,**2,1,2**], and [**1,2,1,2**]\\n- At each of those stages we are simply counting 1 for the minimal valid subarray that ends at the specified index plus 1 more for each of the duplicate values to the left of that minimal subarray.\\n- We don\\'t recount former subarrays in the latter stages because each stage only counts subarrays that end at the new position and all of the previously counted subarrays ended at an earlier position.\\n\\n# Overview of algorithm\\n- For each index **r** in the array of input values starting with the smallest **r** that encompasses **K** unique integers:\\n  - find the smallest subarray of **K** unique integers that ends at **r**\\n  - count the number of contiguous values (**ndup**) to the left of that subarray that are duplicates of the same **K** unique integers\\n  - new subarrays discovered that end at **r** will be **(ndup + 1)**, add that number to the total\\n\\n# Loop invariants\\n\\n- At the start of each loop iteration we have two pointers framing a section of the input array that contains no more than K unique integers.\\n- **l** and **r** represents the section of unique integers such that any index **i** of the data array where **(l <= i < r)** is in the range, aka the half-open interval **[l -> r)**.\\n- No smaller subarray that also ends at **r** contains the same unique integers so this is the minimal subarray that ends at **r** which has at most K unique integers.\\n- Similarly **l** is a pointer to the first number in the input that is not duplicated in the range **[l -> r)**.\\n- **nsub** represents the number of unique subarrays that also contain the same unique integers that are in the range and is basically a count of the number of duplicates of these integers that lie to the left of **l**, plus one for the minimal subarray from **[l -> r)**.\\n- **nvals[]** array keeps a count of each integer within the range **[l -> r)**.  If the count is 0, that particular integer does not appear in the range.  If the count is 1, then that particular integer appears only once in the range. If the count is greater than 1, then that integer appears multiple times within the range.\\n- Since **[l -> r)** is the smallest subarray with **K** unique integers, then the value at index **l** should  have no other duplicates in the range.\\n- As we grow the range to include more indices (by convention, always at the right end of the range by moving **r** forward), we increment the location in the **nvals** array associated with the new value at **A[r]**.  If that count goes from 0 to 1, then we have added a new unique integer to the range.\\n- As we shrink the range to include fewer indices (by convention, always at the left end of the range by moving **l** forward), we decrement the associated location in the **nvals** array.  If that count goes from 1 to 0, then we have removed all instances of that integer from the range.\\n- Due to the above properties, at the start of a loop iteration we can thus prove that **nvals[l]** is 1 because it is the first integer that is not duplicated in the range.\\n- Rather than keep a separate count of the number of unique integers in the range, we simply use the **K** value to represent how many more unique values we need to add to the range. If it is positive then we need more unique integers, if it is negative we have too many, and if it is 0, then we have a valid range.\\n- Summary:\\n  - **[l->r)** is the minimal subarray ending at **r** with at most **K** unique integers\\n  - value at **l** is unique within the range **[l -> r)** and so **(nvals[A[l]] == 1)**\\n  - **K** reaches 0 as soon as we have a valid subarray with **K** unique integers\\n  - **K** never varies from **[0,-1]** from that point on\\n\\n# Operation of the loop\\n- The first thing that each loop iteration does is to add a new value to the range at **r**.  We adjust the count for that value and if the count used to be 0 then we decrement **K** to represent the inclusion of one more unique integer in the range.\\n- If **K** becomes negative (it will be -1 exactly), then we have too many unique integers in the range and so we need to remove one.  Due to the properties above, we know that simply getting rid of the element at **l** will reduce the unique integers back to the appropriate number since we left it pointing to the first unique integer in the former valid range. In doing so, we no longer have any additional valid subranges to the left of **l** (since we know that the value at **l** itself is no longer in the valid range) so we reset the number of valid subarrays **nsub** to 1 (it may grow again in a later stage of the loop that counts duplicates).\\n- In early passes of the loop before we\\'ve passed **K** unique integers, the value of **K** may be positive at this point in which case we loop around, but once we get going it will tend to be **(K == 0)** at this point.\\n- If **(K == 0)** then **[l -> r)** is a valid range with exactly **K** integers, but it may not be the smallest such range that ends at **r**.\\n  - First we loop and bump **l** as long as it points to numbers that appear more than once in the range (**while (nvals[A[l]] > 1)**)\\n  - (Note that it is impossible for **(nvals[A[l]] == 0)** in this loop because all numbers between **l** and **r** are in the list of unique integers at least once.)\\n  - (Also note that it is impossible for **l** to advance off the end of the **A[]** array because it will always find a unique value before then.)\\n  - For each bump of **l** we adjust the counts in the **nvals[]** array and we increment **nsub** as we have identified one more duplicate integer to the left of **l**\\n  - When that loop terminates by finding a value such that **(nvals[A[l]] == 1)** then we have again found the smallest valid subarray ending at **r**.\\n  - Finally, we can add the number of represented subarrays - **nsub** - to the total\\n\\n# Java implementation\\n```\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int nvals[] = new int[A.length + 1];\\n        int nsub = 1;\\n        int l = 0;\\n        int r = 0;\\n        int totalsub = 0;\\n        while (r < A.length) {\\n            if (nvals[A[r++]]++ == 0) {\\n                K--;\\n            }\\n            if (K < 0) {\\n                --nvals[A[l++]];\\n                K++;\\n                nsub = 1;\\n            }\\n            if (K == 0) {\\n                while (nvals[A[l]] > 1) {\\n                    --nvals[A[l++]];\\n                    nsub++;\\n                }\\n                totalsub += nsub;\\n            }\\n        }\\n        return totalsub;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int nvals[] = new int[A.length + 1];\\n        int nsub = 1;\\n        int l = 0;\\n        int r = 0;\\n        int totalsub = 0;\\n        while (r < A.length) {\\n            if (nvals[A[r++]]++ == 0) {\\n                K--;\\n            }\\n            if (K < 0) {\\n                --nvals[A[l++]];\\n                K++;\\n                nsub = 1;\\n            }\\n            if (K == 0) {\\n                while (nvals[A[l]] > 1) {\\n                    --nvals[A[l++]];\\n                    nsub++;\\n                }\\n                totalsub += nsub;\\n            }\\n        }\\n        return totalsub;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555339,
                "title": "c-explanation-sliding-window-easy-to-understand",
                "content": "-> This problem will be a very typical sliding window,\\n-> if it asks the number of subarrays with at most K distinct elements.\\n\\n-> Just need one more step to reach the folloing equation:\\n-> exactly(K) = atMost(K) - atMost(K-1)\\n```    \\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k)\\n    {\\n        int i=0,res=0;\\n        unordered_map<int,int> m;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            if(!m[nums[j]]++)\\n                k--;\\n            while(k<0)\\n            {\\n                if(!--m[nums[i]])\\n                    k++;\\n                i++;\\n            }\\n            res+=j-i+1;\\n        }\\n        return res;\\n        \\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k)\\n    {\\n        return solve(nums,k)-solve(nums,k-1); //(1 to k all)-(1 to k-1 all)==exactly k  \\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<int>& nums, int k)\\n    {\\n        int i=0,res=0;\\n        unordered_map<int,int> m;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            if(!m[nums[j]]++)\\n                k--;\\n            while(k<0)\\n            {\\n                if(!--m[nums[i]])\\n                    k++;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3763791,
                "title": "dictionary-method-with-comments-beats-79-59-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\n        count1 = 0\\n        count2 = 0\\n\\n        left = 0\\n        right = 0\\n\\n        freq1 = defaultdict(int)\\n        freq2 = defaultdict(int)\\n\\n        res = 0\\n\\n        for i in range(len(nums)):\\n            #count frequencies which are greater than k\\n            if freq1[nums[i]] == 0:\\n                count1 +=1\\n            freq1[nums[i]] +=1\\n            #Count frequencies which are exactly k\\n            if freq2[nums[i]] == 0:\\n                count2 +=1\\n            freq2[nums[i]] +=1\\n            \\n            #Checking for count greater than k\\n            while count1 > k:\\n                freq1[nums[right]] -=1\\n                if freq1[nums[right]] == 0:\\n                    count1-=1\\n                right +=1\\n            \\n            #Checking Counts for exact k\\n            while count2 > k-1:\\n                freq2[nums[left]] -=1\\n                if freq2[nums[left]] == 0:\\n                    count2 -=1\\n                left +=1\\n            \\n            res += left - right\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\n        count1 = 0\\n        count2 = 0\\n\\n        left = 0\\n        right = 0\\n\\n        freq1 = defaultdict(int)\\n        freq2 = defaultdict(int)\\n\\n        res = 0\\n\\n        for i in range(len(nums)):\\n            #count frequencies which are greater than k\\n            if freq1[nums[i]] == 0:\\n                count1 +=1\\n            freq1[nums[i]] +=1\\n            #Count frequencies which are exactly k\\n            if freq2[nums[i]] == 0:\\n                count2 +=1\\n            freq2[nums[i]] +=1\\n            \\n            #Checking for count greater than k\\n            while count1 > k:\\n                freq1[nums[right]] -=1\\n                if freq1[nums[right]] == 0:\\n                    count1-=1\\n                right +=1\\n            \\n            #Checking Counts for exact k\\n            while count2 > k-1:\\n                freq2[nums[left]] -=1\\n                if freq2[nums[left]] == 0:\\n                    count2 -=1\\n                left +=1\\n            \\n            res += left - right\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604221,
                "title": "c-sliding-window-hints-intuition-explained-commented-code",
                "content": "* to move directly to the approach first **make sure you have tried these questions**:\\n\\t* [maximum consecutive ones iii](https://leetcode.com/problems/max-consecutive-ones-iii/)\\n\\t* longest substring with at most k distinct characters\\n* rather then moving to approach of this problem, we will **first see the approach to the problem mentioned above [longest substring with at most k distinct characters]** using sliding window\\n\\t* Now,**when we add an element, there could be 2 cases:**\\n\\t\\t\\t**1**. \\t**element is distinct**: we have found one of the distinct element so we will decrease k as now only k-1 disitnct elements can be added furthur - **[k--]**\\n\\t\\t\\t**2**. \\t**element is not distinct**: no issues! as that is not going to affect k as similar element is already seen before, so we just need to increase its frequency and that\\'s it! \\uD83D\\uDE04 -  [**nothing specific to be done!]**\\n\\t* for above 2 cases, to check whether element is distinct or not, we need to have a **data structure which can store frequency of every element and can access it in minimal time**. And we know that this data structure is **our dearest unordered Map** \\uD83D\\uDC99. So we will declare and unordered map and will be updating the frequency of elements in it in every iteration.\\n\\t* Now, **we will keep moving until we reach the danger** \\uD83D\\uDC80\\u26A1 **point - when k < 0** that means **we have colllected the maximum limit of distinct characters and we have one extra distinct character** and now k is exhausted. Now, this extra distinct character is evil\\uD83D\\uDE08 so we need to remove it as we want to make k = 0 to satisfy the given conditions.\\n\\t* Now, to make k back to safe. So for the same we we will use **2 pointer approach** position ie., 0. we need to go to starting and minimize the window unitl we get k=0. We will decrease the start pointer until we reach a positions where k becomes zero again.\\n\\t* So after all these long points \\uD83E\\uDD74, let me summarize the conditions:\\n\\t\\t\\t**1. k > 0: no issues. Just update the length and update frequency.**\\n\\t\\t\\t**2. k = 0: danger point. but nothing specific to do. all operations like k>0 to be performed.**\\n\\t\\t\\t**3. k < 0: unstable condition. immediately have to make k = 0 by 2 pointer approach. Decrementing k until getting k back to 0 and updating freq in map along with.**\\n#### \\t\\t\\t***CODE FOR LONGEST SUBSTRING WITH AT MOST K DISTINCT CHARACTERS***\\n```\\n\\nstring longestSubstringWuthAtmostKDistinct(string s, int k) {\\n        int size = s.length();\\n        int start = 0, end = 0;\\n        int len = 0, ans = 0;\\n        unordered_map<char, int> mp;\\n        \\n        while(end < size)\\n        {\\n            if(mp[s[end]] == 0) // distinct\\n            {\\n                k--;\\n            }\\n            \\n            if(k >= 0)\\n            {\\n                len++;\\n                mp[s[end++]];\\n                ans = max(ans, len);\\n            }\\n            \\n            else\\n            {\\n                mp[s[end]]++;\\n                while(k < 0)\\n                {\\n                    if(mp[s[start]] == 1)\\n                    {\\n                        k++;\\n                    }\\n                    mp[s[start]]--;\\n                    start++;\\n                    len = end - start + 1;\\n                }\\n            }\\n            end++;\\n        }\\n        if(ans != 0) {\\n            return s.substr(start, end - start + 1);\\n        }\\n    return \"\";\\n    }\\n```\\n* **Coming to question of exactly k distinct characters**. Let\\'s say we have k = 3.\\n* Then the above problem will consider all the string with **AtMost(k) = AtMost(2) = 3 distinct + 2 distinct + 1 distinct + 0 distinct**\\n* And if we run the same above function for k-1 ie., for k = 2.it will consider all the strings with **AtMost(k-1) = AtMost(2) = 2 distinct + 1 distinct + 0 distinct**\\n* **There\\'s a great observation here.** \\n\\t**Atmost(3) - Atmost (2) = (3 distinct + 2 distinct + 1 distinct + 0 distinct) - (2 distinct + 1 distinct + 0 distinct) = 3 disinct = exactly k distinct.**\\n\\t\\n\\t#### \\t\\t\\t***CODE FOR SUBARRAYS WITH K DIFFERENT INTEGERS***\\n\\t\\n```\\n int subarraysWithAtMostKDistinct(vector<int> nums, int k)\\n{\\n\\tunordered_map<int, int> freq;\\n\\tint size = nums.size();\\n\\tint start = 0, end = 0;\\n\\tint total = 0;\\n\\n\\twhile(end < size)\\n\\t{\\n\\t\\tif(freq[nums[end]] == 0) // distinct\\n\\t\\t{\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\n\\t\\tif(k >= 0)\\n\\t\\t{\\n\\t\\t\\tfreq[nums[end]]++;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfreq[nums[end]]++;\\n\\t\\t\\twhile(k < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(freq[nums[start]] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfreq[nums[start]]--;\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tend++;\\n\\t\\ttotal += end-start+-1;\\n\\t}\\n\\n\\treturn total;\\n}\\n\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n\\tint atMostKdistinct = subarraysWithAtMostKDistinct(nums, k);\\n\\n\\tint atMostK_1distinct = subarraysWithAtMostKDistinct(nums, k-1);\\n\\n\\treturn atMostKdistinct - atMostK_1distinct;\\n}\\n```\\n\\n\\n\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n\\nstring longestSubstringWuthAtmostKDistinct(string s, int k) {\\n        int size = s.length();\\n        int start = 0, end = 0;\\n        int len = 0, ans = 0;\\n        unordered_map<char, int> mp;\\n        \\n        while(end < size)\\n        {\\n            if(mp[s[end]] == 0) // distinct\\n            {\\n                k--;\\n            }\\n            \\n            if(k >= 0)\\n            {\\n                len++;\\n                mp[s[end++]];\\n                ans = max(ans, len);\\n            }\\n            \\n            else\\n            {\\n                mp[s[end]]++;\\n                while(k < 0)\\n                {\\n                    if(mp[s[start]] == 1)\\n                    {\\n                        k++;\\n                    }\\n                    mp[s[start]]--;\\n                    start++;\\n                    len = end - start + 1;\\n                }\\n            }\\n            end++;\\n        }\\n        if(ans != 0) {\\n            return s.substr(start, end - start + 1);\\n        }\\n    return \"\";\\n    }\\n```\n```\\n int subarraysWithAtMostKDistinct(vector<int> nums, int k)\\n{\\n\\tunordered_map<int, int> freq;\\n\\tint size = nums.size();\\n\\tint start = 0, end = 0;\\n\\tint total = 0;\\n\\n\\twhile(end < size)\\n\\t{\\n\\t\\tif(freq[nums[end]] == 0) // distinct\\n\\t\\t{\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\n\\t\\tif(k >= 0)\\n\\t\\t{\\n\\t\\t\\tfreq[nums[end]]++;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfreq[nums[end]]++;\\n\\t\\t\\twhile(k < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(freq[nums[start]] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfreq[nums[start]]--;\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tend++;\\n\\t\\ttotal += end-start+-1;\\n\\t}\\n\\n\\treturn total;\\n}\\n\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n\\tint atMostKdistinct = subarraysWithAtMostKDistinct(nums, k);\\n\\n\\tint atMostK_1distinct = subarraysWithAtMostKDistinct(nums, k-1);\\n\\n\\treturn atMostKdistinct - atMostK_1distinct;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690606,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n        \\n    }\\n    public int atmostK(int []nums,int k)\\n    { int ans=0;\\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        int i=0; int j=0;\\n        while(j<nums.length)\\n        {\\n            mp.put(nums[j],mp.getOrDefault(nums[j],0)+1);\\n            while(mp.size()==k+1)\\n            {\\n                mp.put(nums[i],mp.get(nums[i])-1);\\n                if(mp.get(nums[i])==0)\\n                    mp.remove(nums[i]);\\n                i++;\\n            }\\n            ans+=j-i+1;\\n            j++;\\n            \\n        }\\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n        \\n    }\\n    public int atmostK(int []nums,int k)\\n    { int ans=0;\\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        int i=0; int j=0;\\n        while(j<nums.length)\\n        {\\n            mp.put(nums[j],mp.getOrDefault(nums[j],0)+1);\\n            while(mp.size()==k+1)\\n            {\\n                mp.put(nums[i],mp.get(nums[i])-1);\\n                if(mp.get(nums[i])==0)\\n                    mp.remove(nums[i]);\\n                i++;\\n            }\\n            ans+=j-i+1;\\n            j++;\\n            \\n        }\\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617557,
                "title": "python3-o-n-ordereddict-sliding-window-subarrays-with-k-different-integers",
                "content": "```\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        ans = l = 0\\n        # Last seen index of an integer\\n        od = OrderedDict()\\n        for i, n in enumerate(A):\\n            od[n] = i\\n            od.move_to_end(n)\\n            while len(od) > K:\\n                l = od.popitem(last=False)[1] + 1\\n            if len(od) == K:\\n\\t\\t\\t    # The smallest index in od - left bound + 1\\n                ans += next(iter(od.items()))[1] - l + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        ans = l = 0\\n        # Last seen index of an integer\\n        od = OrderedDict()\\n        for i, n in enumerate(A):\\n            od[n] = i\\n            od.move_to_end(n)\\n            while len(od) > K:\\n                l = od.popitem(last=False)[1] + 1\\n            if len(od) == K:\\n\\t\\t\\t    # The smallest index in od - left bound + 1\\n                ans += next(iter(od.items()))[1] - l + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204820,
                "title": "java-using-sliding-window-and-hashmap",
                "content": "```\\n public int subarraysWithKDistinct(int[] A, int K) {\\n        int n = A.length;\\n        int c = 0;\\n        \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        int i=0,j=0; // i is starting pointer and j is end pointer\\n        while(j<n && i<n){\\n            m.put(A[j], m.getOrDefault(A[j], 0)+1);\\n            \\n            while(m.size()>K){\\n                m.put(A[i], m.get(A[i])-1);\\n                if(m.get(A[i])<=0){\\n                    m.remove(A[i]);\\n                }\\n                i++;\\n            }\\n            int prev = i;\\n            while(i<=j && m.size()==K) { //i==j incase of K=1\\n                m.put(A[i], m.get(A[i])-1);\\n                if(m.get(A[i])<=0){\\n                    m.remove(A[i]);\\n                }\\n                i++;\\n                c++;\\n            } \\n            \\n            while(prev!=i){\\n                i--;\\n                m.put(A[i], m.getOrDefault(A[i], 0)+1); \\n                // now get back to the state you previously were\\n            }\\n            j++;   \\n            \\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n public int subarraysWithKDistinct(int[] A, int K) {\\n        int n = A.length;\\n        int c = 0;\\n        \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        int i=0,j=0; // i is starting pointer and j is end pointer\\n        while(j<n && i<n){\\n            m.put(A[j], m.getOrDefault(A[j], 0)+1);\\n            \\n            while(m.size()>K){\\n                m.put(A[i], m.get(A[i])-1);\\n                if(m.get(A[i])<=0){\\n                    m.remove(A[i]);\\n                }\\n                i++;\\n            }\\n            int prev = i;\\n            while(i<=j && m.size()==K) { //i==j incase of K=1\\n                m.put(A[i], m.get(A[i])-1);\\n                if(m.get(A[i])<=0){\\n                    m.remove(A[i]);\\n                }\\n                i++;\\n                c++;\\n            } \\n            \\n            while(prev!=i){\\n                i--;\\n                m.put(A[i], m.getOrDefault(A[i], 0)+1); \\n                // now get back to the state you previously were\\n            }\\n            j++;   \\n            \\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749344,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=akwRFY2eyXs\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int atmost(int k,vector<int>& nums){\\n         unordered_map<int,int> mp;\\n         int count=0,j=0;\\n         for(int i=0;i<nums.size();i++){\\n             mp[nums[i]]++;\\n             while(mp.size()>k){\\n                 if(mp[nums[j]]==1)mp.erase(nums[j]);\\n                 else mp[nums[j]]--;\\n\\n                 j++;\\n             }\\n             count+= i-j+1;\\n         }\\n         return count;\\n     }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmost(k,nums)-atmost(k-1,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int atmost(int k,vector<int>& nums){\\n         unordered_map<int,int> mp;\\n         int count=0,j=0;\\n         for(int i=0;i<nums.size();i++){\\n             mp[nums[i]]++;\\n             while(mp.size()>k){\\n                 if(mp[nums[j]]==1)mp.erase(nums[j]);\\n                 else mp[nums[j]]--;\\n\\n                 j++;\\n             }\\n             count+= i-j+1;\\n         }\\n         return count;\\n     }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmost(k,nums)-atmost(k-1,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475570,
                "title": "sliding-window-hashmap-two-pointer-with-details-python",
                "content": "This problem with involve knowledge from hashmap, two pointers, and sliding window.\\n\\nIt is hard to compute directly the subarray with **exactly** `k` different integers, but it will be easier to count the number of subarrays with **at most** `k` different integers. \\n\\nWe will introduce a new subarray to help us:\\n* **Nice subarray** is an array where the number of different integers in that array is **at most** `k`\\n\\nAfter we get the number of nice subarrays, we can get the number of good arrays using the difference of nice subarrays for `k` and `k-1`.\\ne.g. # of subarrays with exactly 3 different integers = # of subarrays with at most 3 different integers - # of subarrays with at most 2 different integers.\\n\\n# **Here is the idea:**\\n1. We need two pointers as the left and right part of our sliding window.\\n2. If the right pointer is pointing to a value that exists in the hashmap, this means that we can expand the width of our sliding window. \\n3. Then we need to check if the hashmap is containing too many elements (exceed k). If so, we need to shrink our sliding window by deleting the first element inside it, which is `nums[left]`.\\n4. Add the number of nice subarrays we get in the above steps.\\n\\n**Let\\'s start with a step-by-step example:**\\n```\\nnums = [1, 3, 1, 4]\\nk = 2\\noutput (good subarrays) = 4\\n```\\n\\n* **Step 1:** \\n\\t* left = 0, right = 0\\n\\t* hashmap = {1 : 1}\\n\\t* Nice subarrays = 1\\n`[1]`\\n\\n* **Step 2:**\\n\\t* left = 0, right = 1\\n\\t* hashmap = {1 : 1, 3 : 1}\\n\\t* Nice subarrays = 2 + 1 = 3\\n`[1], [3], [1,3]`\\n\\n* **Step 3:**\\n\\t* left = 0, right = 2\\n\\t* hashmap = {1 : 2, 3 : 1}\\n\\t* Nice subarrays = 3 + 3 = 6\\n`[1], [3], [1,3], [1], [1,3,1], [3,1]`\\n\\n* **Step 4:**\\n\\t* left = 0, right = 3\\n\\t* hashmap = {1: 2, 3 : 1, 4 : 1}\\n-> Note that The length of hashmap exceeds `k`! So we need to delete the first element in our sliding window\\n\\n* **Step 5:**\\n\\t* left = 1, right = 3\\n\\t* hashmap = {1 : 1, 3 : 1, 4 : 1}\\n\\tThe length of hashmap still exceed `k`, so we will shrink our sliding window one more times\\n\\t\\n* **Step 6:**\\n\\t* left = 2, right = 3\\n\\t* hashmap = {1 : 1, 4: 1}\\n\\t* Nice subarrays = 2 + 6 = 8\\n\\t`[1], [3], [1,3], [1], [1,3,1], [3,1], [1,4], [4]`\\n\\t\\nWe can see that for `k = 2`, the number of nice subarrays will be 8. If `k = 1`, we can easily see that the number of it will be 4. So the number of good subarrays (output) will be 8 - 4 = 4.\\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \\n        def atMostKDistinct(nums, k):\\n            niceSubarray = 0\\n            hashmap = {}\\n            left, right = 0, 0\\n            \\n            while right < len(nums):\\n                if nums[right] in hashmap:\\n                    hashmap[nums[right]] += 1\\n                else:\\n                    hashmap[nums[right]] = 1\\n            \\n                while len(hashmap) > k:\\n                    hashmap[nums[left]] -= 1\\n                    if hashmap[nums[left]] == 0:\\n                        del hashmap[nums[left]]\\n                    left += 1\\n                \\n                niceSubarray += right - left + 1\\n                right += 1\\n                \\n            return niceSubarray\\n        \\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nnums = [1, 3, 1, 4]\\nk = 2\\noutput (good subarrays) = 4\\n```\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \\n        def atMostKDistinct(nums, k):\\n            niceSubarray = 0\\n            hashmap = {}\\n            left, right = 0, 0\\n            \\n            while right < len(nums):\\n                if nums[right] in hashmap:\\n                    hashmap[nums[right]] += 1\\n                else:\\n                    hashmap[nums[right]] = 1\\n            \\n                while len(hashmap) > k:\\n                    hashmap[nums[left]] -= 1\\n                    if hashmap[nums[left]] == 0:\\n                        del hashmap[nums[left]]\\n                    left += 1\\n                \\n                niceSubarray += right - left + 1\\n                right += 1\\n                \\n            return niceSubarray\\n        \\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044509,
                "title": "simple-java-solution-using-sliding-window-easy-to-understand",
                "content": "Please upvote, if you find it useful :) \\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] arr, int k) {\\n        return solution(arr,k) - solution(arr, k - 1);\\n    }\\n    \\n    public int solution(int[] arr, int K) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tint j = 0;\\n\\t\\tint ans = 0;\\n\\t\\tint i = 0;\\n\\t\\tfor(i = 0; i < arr.length; i++) {\\n\\t\\t\\tmap.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n\\n\\t\\t\\t\\twhile(map.size() > K) {\\n\\t\\t\\t\\t\\tif(map.get(arr[j]) > 1) {\\n\\t\\t\\t\\t\\t\\tmap.put(arr[j], map.get(arr[j]) - 1);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmap.remove(arr[j]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tj += 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans += (i-j) + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] arr, int k) {\\n        return solution(arr,k) - solution(arr, k - 1);\\n    }\\n    \\n    public int solution(int[] arr, int K) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tint j = 0;\\n\\t\\tint ans = 0;\\n\\t\\tint i = 0;\\n\\t\\tfor(i = 0; i < arr.length; i++) {\\n\\t\\t\\tmap.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n\\n\\t\\t\\t\\twhile(map.size() > K) {\\n\\t\\t\\t\\t\\tif(map.get(arr[j]) > 1) {\\n\\t\\t\\t\\t\\t\\tmap.put(arr[j], map.get(arr[j]) - 1);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmap.remove(arr[j]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tj += 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans += (i-j) + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801444,
                "title": "java-solution-with-explanation",
                "content": "```\\n//This is really good question.\\n//here the logic is to get all subarrays of size K then get all subarrays of size k-1 the return the ans as no of Subarrays(k)-no of subarrays(k-1) this is the number of arrays with exact k distinct elements.\\n\\n\\nclass Solution {\\n     public int subarraysWithKDistinct(int[] nums, int k) {\\n         \\n         \\n      return subarraysWithKSize(nums,k)-subarraysWithKSize(nums,k-1);   \\n     }\\n      public int subarraysWithKSize(int[] nums, int k) {\\n\\t       HashMap<Integer,Integer> hs=new HashMap<>();\\n\\t     int count=0;\\n\\t        int i=0;\\n\\t        int j=0;\\n\\t        while(j<nums.length){\\n                  hs.put(nums[j],hs.getOrDefault(nums[j],0)+1);\\n              \\n\\t            \\n\\t           \\n\\t           while(hs.size()==k+1){ //while(hs.size()>k){ this is taking more time\\n\\t              hs.put(nums[i],hs.get(nums[i])-1);\\n\\t                  if(hs.get(nums[i])==0)\\n\\t                     hs.remove(nums[i]);\\n\\t                i++;\\n\\t                \\n\\t            }\\n                \\n                count+=j-i+1;\\n                j++;\\n\\n\\t        }\\n\\t        \\n\\t        \\n\\t        return count;\\n\\t        \\n\\t    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n//This is really good question.\\n//here the logic is to get all subarrays of size K then get all subarrays of size k-1 the return the ans as no of Subarrays(k)-no of subarrays(k-1) this is the number of arrays with exact k distinct elements.\\n\\n\\nclass Solution {\\n     public int subarraysWithKDistinct(int[] nums, int k) {\\n         \\n         \\n      return subarraysWithKSize(nums,k)-subarraysWithKSize(nums,k-1);   \\n     }\\n      public int subarraysWithKSize(int[] nums, int k) {\\n\\t       HashMap<Integer,Integer> hs=new HashMap<>();\\n\\t     int count=0;\\n\\t        int i=0;\\n\\t        int j=0;\\n\\t        while(j<nums.length){\\n                  hs.put(nums[j],hs.getOrDefault(nums[j],0)+1);\\n              \\n\\t            \\n\\t           \\n\\t           while(hs.size()==k+1){ //while(hs.size()>k){ this is taking more time\\n\\t              hs.put(nums[i],hs.get(nums[i])-1);\\n\\t                  if(hs.get(nums[i])==0)\\n\\t                     hs.remove(nums[i]);\\n\\t                i++;\\n\\t                \\n\\t            }\\n                \\n                count+=j-i+1;\\n                j++;\\n\\n\\t        }\\n\\t        \\n\\t        \\n\\t        return count;\\n\\t        \\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234590,
                "title": "java-sliding-window-with-indices-queue",
                "content": "Maintain sliding window within `i` and `j`. (`j` not included)\\n`indices` maintains all the indices for each value in the sliding window.\\n`minEnd` is the minimum end index of possible valid subarrays within current sliding window.\\nUpdate `minEnd` while `i` or `j` is moving. For example:\\n```\\n[1, 2, 1, 2, 3]    K = 2\\n i           j\\nindices: {\\n\\t1: [0, 2]\\n\\t2: [1, 3]\\n}\\nminEnd: 1\\nresult += j - minEnd = 3\\n\\n------\\n\\n[1, 2, 1, 2, 3]    K = 2\\n    i        j\\nindices: {\\n\\t1: [2]\\n\\t2: [1, 3]\\n}\\nminEnd: 2\\nresult += j - minEnd = 3 + 2 = 5\\n\\n------\\n\\n[1, 2, 1, 2, 3]    K = 2\\n       i     j\\nindices: {\\n\\t1: [2]\\n\\t2: [3]\\n}\\nminEnd: 3\\nresult += j - minEnd = 5 + 1 = 6\\n\\n......\\n```\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int result = 0, n = A.length, i = 0, j = 0, minEnd = -1;\\n        Map<Integer, Queue<Integer>> indices = new HashMap<>();\\n        while (j < n) {\\n            while (j < n) {\\n                if (!indices.containsKey(A[j])) {\\n                    if (indices.size() == K - 1) {\\n                        minEnd = j;\\n                    }\\n                    if (indices.size() == K) {\\n                        break;\\n                    }\\n                    indices.put(A[j], new LinkedList<>());\\n                }\\n                indices.get(A[j]).offer(j);\\n                j++;\\n            }\\n            if (j == n && indices.size() < K) {\\n                break;\\n            }\\n            while (i < j) {\\n                int cur = A[i++];\\n                result += j - minEnd;\\n                indices.get(cur).poll();\\n                if (indices.get(cur).isEmpty()) {\\n                    indices.remove(cur);\\n                    break;\\n                }\\n                minEnd = Math.max(minEnd, indices.get(cur).peek());\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\n[1, 2, 1, 2, 3]    K = 2\\n i           j\\nindices: {\\n\\t1: [0, 2]\\n\\t2: [1, 3]\\n}\\nminEnd: 1\\nresult += j - minEnd = 3\\n\\n------\\n\\n[1, 2, 1, 2, 3]    K = 2\\n    i        j\\nindices: {\\n\\t1: [2]\\n\\t2: [1, 3]\\n}\\nminEnd: 2\\nresult += j - minEnd = 3 + 2 = 5\\n\\n------\\n\\n[1, 2, 1, 2, 3]    K = 2\\n       i     j\\nindices: {\\n\\t1: [2]\\n\\t2: [3]\\n}\\nminEnd: 3\\nresult += j - minEnd = 5 + 1 = 6\\n\\n......\\n```\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int result = 0, n = A.length, i = 0, j = 0, minEnd = -1;\\n        Map<Integer, Queue<Integer>> indices = new HashMap<>();\\n        while (j < n) {\\n            while (j < n) {\\n                if (!indices.containsKey(A[j])) {\\n                    if (indices.size() == K - 1) {\\n                        minEnd = j;\\n                    }\\n                    if (indices.size() == K) {\\n                        break;\\n                    }\\n                    indices.put(A[j], new LinkedList<>());\\n                }\\n                indices.get(A[j]).offer(j);\\n                j++;\\n            }\\n            if (j == n && indices.size() < K) {\\n                break;\\n            }\\n            while (i < j) {\\n                int cur = A[i++];\\n                result += j - minEnd;\\n                indices.get(cur).poll();\\n                if (indices.get(cur).isEmpty()) {\\n                    indices.remove(cur);\\n                    break;\\n                }\\n                minEnd = Math.max(minEnd, indices.get(cur).peek());\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109740,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window And Unordered Map***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int count_at_most(vector<int>& nums, int k)\\n    {\\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int left = 0;\\n        \\n        int count = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            mp[nums[right]]++;\\n            \\n            while(mp.size() > k)\\n            {\\n                mp[nums[left]]--;\\n                \\n                if(mp[nums[left]] == 0)\\n                {\\n                    mp.erase(nums[left]);\\n                }\\n                \\n                left++;\\n            }\\n            \\n            int curr_count = right - left + 1;\\n            \\n            count += curr_count;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        \\n        int count_at_most_k = count_at_most(nums, k);\\n        \\n        int count_at_most_k_1 = count_at_most(nums, k - 1);\\n        \\n        int count_exactly_k = count_at_most_k - count_at_most_k_1;\\n        \\n        return count_exactly_k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count_at_most(vector<int>& nums, int k)\\n    {\\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int left = 0;\\n        \\n        int count = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            mp[nums[right]]++;\\n            \\n            while(mp.size() > k)\\n            {\\n                mp[nums[left]]--;\\n                \\n                if(mp[nums[left]] == 0)\\n                {\\n                    mp.erase(nums[left]);\\n                }\\n                \\n                left++;\\n            }\\n            \\n            int curr_count = right - left + 1;\\n            \\n            count += curr_count;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        \\n        int count_at_most_k = count_at_most(nums, k);\\n        \\n        int count_at_most_k_1 = count_at_most(nums, k - 1);\\n        \\n        int count_exactly_k = count_at_most_k - count_at_most_k_1;\\n        \\n        return count_exactly_k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915559,
                "title": "java-sliding-window-easy-consise",
                "content": "```\\nclass Solution {\\n    // number of subarrays with k diff integers = number of subarrays with at most k diff integers - number of subarrays with atmost k-1 diff integers\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return count(nums,k) - count(nums,k-1);\\n    }\\n    public int count(int[] nums,int k){\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int start = 0,end = 0, res = 0;\\n        while(end < nums.length){\\n            map.put(nums[end],map.getOrDefault(nums[end],0)+1);\\n            while(start <= end && map.size() > k){\\n                if(map.containsKey(nums[start])) map.put(nums[start],map.get(nums[start])-1);\\n                if(map.get(nums[start]) == 0) map.remove(nums[start]);\\n                start++;\\n            }\\n            res+= (end - start + 1);\\n            end++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // number of subarrays with k diff integers = number of subarrays with at most k diff integers - number of subarrays with atmost k-1 diff integers\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return count(nums,k) - count(nums,k-1);\\n    }\\n    public int count(int[] nums,int k){\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int start = 0,end = 0, res = 0;\\n        while(end < nums.length){\\n            map.put(nums[end],map.getOrDefault(nums[end],0)+1);\\n            while(start <= end && map.size() > k){\\n                if(map.containsKey(nums[start])) map.put(nums[start],map.get(nums[start])-1);\\n                if(map.get(nums[start]) == 0) map.remove(nums[start]);\\n                start++;\\n            }\\n            res+= (end - start + 1);\\n            end++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425309,
                "title": "c-easy-sol-using-sliding-window",
                "content": "**Approach:** we need exactly k elements so we need to remove less than k elements from (at most k elements)\\nIf the question had been return at most k size good array\\nwe don\\'t need to have to do this step of subtracting less than k elements\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        int i=0;\\n        int unique=0;//unique no till the current window\\n        int ans=0;\\n        for(int j=0; j<n; j++)\\n        {\\n            int curr = nums[j];\\n            if(mp.find(curr) == mp.end())\\n                unique++;\\n            \\n            mp[curr]++;\\n            \\n            while(unique > k)\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                {\\n                    mp.erase(nums[i]);\\n                    unique--;\\n                }\\n                \\n                i++;\\n            }\\n            ans += j-i+1;\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        return helper(nums,k) - helper(nums, k-1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        int i=0;\\n        int unique=0;//unique no till the current window\\n        int ans=0;\\n        for(int j=0; j<n; j++)\\n        {\\n            int curr = nums[j];\\n            if(mp.find(curr) == mp.end())\\n                unique++;\\n            \\n            mp[curr]++;\\n            \\n            while(unique > k)\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                {\\n                    mp.erase(nums[i]);\\n                    unique--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1314813,
                "title": "c-sliding-window",
                "content": "Again it makes it easier to count subarrays with maximum(at-most) `K` different elements rather than counting subarrays with exactly `K` different elements. Reason - we can keep incrementing our subarray count till we reach `K+1` different elements.\\nIf on the other hand we had to count exactly `K` different elements, our subarray count will increase only upon reaching `K` different elements and we will have to check if the next element in the array is different from the elements that we already have in our map, i.e. if it will change our count of different elements or not.\\n\\n`unordered_map` - to store frequency of elements. Its size tells us the number of different elements.\\n`j` - to add new elements\\n`i` - remove elements from map when the number of different elements exceeds `K`.\\n\\n```\\nint atMostKDistinct(vector<int>& arr, int k) {\\n        unordered_map<int, int> mp;\\n        int n = arr.size();\\n        int i=0, j=0;\\n        int count = 0;\\n        \\n        while(j < n) {\\n            mp[arr[j++]] += 1;\\n            while(mp.size() > k) {\\n                if(mp[arr[i]] == 1)\\n                    mp.erase(arr[i++]);\\n                else\\n                    mp[arr[i++]] -= 1;\\n            }\\n            count += j-i;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k-1);\\n    }\\n```\\n\\nNumber of subarrays in array of n elements = `n*(n+1)/2`\\n`count += j-i` takes care of that.\\nI \\'`erase`\\' the element from map when its frequency is 1, otherwise just decrement the frequency.\\n\\nExact `K` subarrays = (at-most `K` subarrays) - (at-most `K-1` subarrays).\\n\\nI hope my explanation was readable and understandable.",
                "solutionTags": [],
                "code": "```\\nint atMostKDistinct(vector<int>& arr, int k) {\\n        unordered_map<int, int> mp;\\n        int n = arr.size();\\n        int i=0, j=0;\\n        int count = 0;\\n        \\n        while(j < n) {\\n            mp[arr[j++]] += 1;\\n            while(mp.size() > k) {\\n                if(mp[arr[i]] == 1)\\n                    mp.erase(arr[i++]);\\n                else\\n                    mp[arr[i++]] -= 1;\\n            }\\n            count += j-i;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1215277,
                "title": "python-sliding-window-set-hashmap",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \\n        def window(nums, k):\\n            left = 0\\n            right = 0\\n\\n            res = 0\\n            in_set = set()\\n            hash_map = collections.Counter()\\n\\n            while right < len(nums):\\n                in_set.add(nums[right])\\n                hash_map[nums[right]] += 1\\n\\n                while len(in_set) > k:\\n                    hash_map[nums[left]] -= 1\\n                    if hash_map[nums[left]] == 0:\\n                        in_set.remove(nums[left])\\n                    left += 1\\n\\n                res += (right - left + 1)\\n\\n                right += 1\\n            return res\\n    \\n       return window(nums, k) - window(nums, k - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \\n        def window(nums, k):\\n            left = 0\\n            right = 0\\n\\n            res = 0\\n            in_set = set()\\n            hash_map = collections.Counter()\\n\\n            while right < len(nums):\\n                in_set.add(nums[right])\\n                hash_map[nums[right]] += 1\\n\\n                while len(in_set) > k:\\n                    hash_map[nums[left]] -= 1\\n                    if hash_map[nums[left]] == 0:\\n                        in_set.remove(nums[left])\\n                    left += 1\\n\\n                res += (right - left + 1)\\n\\n                right += 1\\n            return res\\n    \\n       return window(nums, k) - window(nums, k - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355187,
                "title": "java-two-pointer",
                "content": "To directly compute the subarray with K different nums is hard, but subarray with at most K different nums is easy.\\n\\nBy this idea, the rest effort is straight forward.\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atmost(A,K)-atmost(A,K-1);\\n    }\\n    \\n    int atmost(int[] arr, int k){\\n        int count=0, i=0, j=0, ret=0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (;j<arr.length;){\\n            if (map.getOrDefault(arr[j],0)==0) count++;\\n            map.put(arr[j],map.getOrDefault(arr[j],0)+1);\\n            while (count>k){\\n                map.put(arr[i],map.get(arr[i])-1);\\n                if (map.get(arr[i])==0) count--;\\n                i++;\\n            }\\n            ret += j-i+1;\\n            j++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atmost(A,K)-atmost(A,K-1);\\n    }\\n    \\n    int atmost(int[] arr, int k){\\n        int count=0, i=0, j=0, ret=0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (;j<arr.length;){\\n            if (map.getOrDefault(arr[j],0)==0) count++;\\n            map.put(arr[j],map.getOrDefault(arr[j],0)+1);\\n            while (count>k){\\n                map.put(arr[i],map.get(arr[i])-1);\\n                if (map.get(arr[i])==0) count--;\\n                i++;\\n            }\\n            ret += j-i+1;\\n            j++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350130,
                "title": "cpp-sliding-window-o-n-solution",
                "content": "Use a hashmap to store the frequency of each num, use a variable `cnt` to store the the number of different integers in the window. \\n1. Slide the right border `j` : If we meet a num with `hash[j] == 0, cnt += 1`. Find a sliding window with `k` different numbers . \\n2. Slide left border `i` if `hash[A[i]] > 1`, which means that there are more than one `A[i]` in the window. If we meet `hash[A[i]] == 1` we cannot slide `i`more. Now we can build subarrays which start from `the previous i(istart)` to `i` and ends with `j `, and each of them has k different  integers in it . That adds `i - istart + 1` to our final answer. \\n3. Move on with the right border `j`, there are two situations:\\n* If our `cnt` changes, we must move our left border `i` until `cnt == k` and reset `istart`.\\n* If our `cnt` still equals to `k`(which means `A[j]` eauals to some existing value in the window), the subarrays which start from `istart` to `i` and ends with new `j` will still work(no more different number is added). We just need to move the left border `i` since the right border `j` may have same number with the left border and we only need `one` number to maintain the window. If we cannot slide more(`hash[A[i]] == 1`) , update our answer.\\n\\nSince `1 <= A[i] <= A.length`, we can use a vector instead of hashmap.\\n**Complexity:**\\n* Time: O(N)\\n* Space: O(N)\\n\\n```\\nint subarraysWithKDistinct(vector<int>& A, int k) {\\n        int n = A.size(), ans = 0;\\n        //unordered_map<int, int> hash;\\n\\t\\tvector<int> hash(n + 1, 0);\\n        for(int i = 0, j = 0, cnt = 0, istart = 0; j < n; ++j) {\\n            if(hash[A[j]]++ == 0) cnt++;\\n            if(cnt < k) continue;\\n            while(cnt > k) {\\n                cnt -= (0 == --hash[A[i++]]);\\n                istart = i;\\n            } \\n            while(hash[A[i]] > 1) hash[A[i++]]--;\\n            ans += i - istart + 1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint subarraysWithKDistinct(vector<int>& A, int k) {\\n        int n = A.size(), ans = 0;\\n        //unordered_map<int, int> hash;\\n\\t\\tvector<int> hash(n + 1, 0);\\n        for(int i = 0, j = 0, cnt = 0, istart = 0; j < n; ++j) {\\n            if(hash[A[j]]++ == 0) cnt++;\\n            if(cnt < k) continue;\\n            while(cnt > k) {\\n                cnt -= (0 == --hash[A[i++]]);\\n                istart = i;\\n            } \\n            while(hash[A[i]] > 1) hash[A[i++]]--;\\n            ans += i - istart + 1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2952113,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def atmostk(self,n,k,nums):\\n        l=0\\n        r=0\\n        map=defaultdict(int)\\n        ans=0\\n        while r<n:\\n            map[nums[r]]+=1\\n            while len(map)>k:\\n                map[nums[l]]-=1\\n                if map[nums[l]]==0:\\n                    del map[nums[l]]\\n                l+=1\\n            \\n            ans+=r-l+1\\n            r+=1\\n        return ans\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atmostk(len(nums),k,nums)-self.atmostk(len(nums),k-1,nums)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def atmostk(self,n,k,nums):\\n        l=0\\n        r=0\\n        map=defaultdict(int)\\n        ans=0\\n        while r<n:\\n            map[nums[r]]+=1\\n            while len(map)>k:\\n                map[nums[l]]-=1\\n                if map[nums[l]]==0:\\n                    del map[nums[l]]\\n                l+=1\\n            \\n            ans+=r-l+1\\n            r+=1\\n        return ans\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atmostk(len(nums),k,nums)-self.atmostk(len(nums),k-1,nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253265,
                "title": "common-trick-for-counting-distinct-integers-o-n-sliding-window-solution",
                "content": "When I saw this problem, I immediately thought of this trick I had seen for [counting the number of distinct integers in a subarray](https://stackoverflow.com/a/53066384/3740708). The StackOverflow post does not explain the trick that well, but the trick that they use is, if the subarray ends at index M, then create an array `arr` where `arr[i] = 1` if `i` is the last index <= M in `nums` where `nums[i]` appears, and `arr[i] = 0` otherwise. Then, for any `0 <= j <= M`, the sum of the suffix of `arr` starting from index `j` is the number of distinct elements in the subarray from `j` to `M`. (The StackOverflow post also mentions segment trees, but you don\\'t need segment trees for this problem, you just need to know this trick.)\\n\\nFor me, prefix sums are easier to think about than suffix sums, so I flipped the trick around: If the subarray begins at L, then I created an array `arr` where `arr[i] = 1` if `i` is the *first* index >= L in `nums` where `nums[i]` appears and `arr[i] = 0` otherwise. Then, for any `L <= j < len(nums)`, the sum of the prefix of `arr` ending at index `j` is the number of distinct elements in the subarray from `L` to `j`.\\n\\nNow, we want to count the number of subarrays which have exactly `K` distinct elements. The way we will approach this problem is, for any `0 <= L < len(nums)`, we want to count the number of distinct subarrays that begin at index `L` which have exactly `K` distinct elements. Let\\'s say `arr` is set up as we defined it above. Then, for any `n`, let `f(n)` be the least index `j` of `arr` such that the sum of the prefix of `arr` ending at index `j` is `n`, or `len(nums)` if the sum of all of `arr` is < n. We will maintain two indexes: `lo`, which is `f(K)` and `hi`, which is `f(K+1)`. Then, for any index `lo <= j < hi`, the prefix sum of `arr` ending at `j` is exactly `K`, which means that the subarray from `L` to `j` has exactly `K` distinct elements. Therefore, the number of distinct subarrays that begin at index `L` which have exactly `K` distinct elements is `hi - lo`, so we just add `hi - lo` to our answer.\\n\\nFinally, how do we maintain the array `arr` as we increase `L` by 1 in our for loop from `L = 0` to `L < len(nums)`? Theoretically we should set `arr[L] = 0` but once we increase `L`, none of the elements with index <= L matter anymore, so we don\\'t need to worry about updating `arr[L]`. However, once we increase `L`, `L` is no longer the first index where  `arr[L]` appears anymore anymore, since we are no longer considering elements of index <= L. Therefore, we create an array `next` where `next[i]` is the index of the next occurrence of `nums[i]` in `nums` that happens after index `i` (or -1 if `i` is the last occurrence of `nums[i]` in `nums`). Then, when increasing L, we set `arr[next[L]] = 1`, since `next[L]` is the new first index where `nums[L]` appears. Finally, we update `lo` and `hi` appropriately, increasing the indices until the prefix sums ending at `lo` and `hi` are `K` and `K+1` again, respectively.\\n\\n```\\n# Return the least index j > idx such that arr[j] = 1,\\n# or return len(arr) if no such index exists\\ndef find_next_one(arr: List[int], idx: int) -> int:\\n    N = len(arr)\\n    while idx < N:\\n        idx += 1\\n        if idx == N or arr[idx] == 1:\\n            return idx\\n    return idx\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        # nxt[i] = least j > i such that nums[j] = nums[i], or -1 if i is the last occurrence of nums[i] in nums\\n        nxt = [-1 for _ in range(N)]\\n        # last_seen[n] = last index where n was seen in nums, or -1 if n hasn\\'t been seen before\\n        last_seen = [-1 for _ in range(N+1)]\\n        # arr[i] = 1 if i is the least index >= L where nums[i] appears in nums\\n        # Initially, L = 0\\n        arr = [0 for _ in range(N)]\\n        for i in range(N):\\n            if last_seen[nums[i]] != -1:\\n                # Update nxt, if possible\\n                nxt[last_seen[nums[i]]] = i\\n            else:\\n                # i is the first occurrence of nums[i] in nums, so update arr\\n                arr[i] = 1\\n            # We just saw nums[i], so update last_seen\\n            last_seen[nums[i]] = i\\n        \\n        # lo = least index such that sum from i=0 to lo of arr[i] = K, or N if no such index exists\\n        lo = -1\\n        pfx = 0\\n        while pfx < k:\\n            lo += 1\\n            if lo == N:\\n                break\\n            pfx += arr[lo]\\n        \\n        # hi = least index such that sum from i=0 to lo of arr[i] = K+1, or N if no such index exists\\n        # In other words, hi is the position of the next 1 in arr after lo\\n        hi = find_next_one(arr, lo)\\n        \\n        answer = 0\\n        for L in range(N):\\n            # Remember: Number of subarrays beginning at L with K distinct elements is hi-lo\\n            answer += hi-lo\\n            \\n            # Since we are going to increase L, theoreitcally, we set arr[L] = 0\\n            # This means prefix sums at lo and hi just decreased by 1,\\n            # so we need to update lo and hi\\n            need_to_update_lo = True\\n            need_to_update_hi = True\\n            if nxt[L] != -1:\\n                # Update arr, if possible\\n                arr[nxt[L]] = 1\\n                # If nxt[L] <= lo, then setting arr[nxt[L]] to 1 cancels out\\n                # setting arr[L] to 0, so the prefix sum at lo is still K\\n                # and we don\\'t need to update lo\\n                # Therefore, we only need to update lo if nxt[L] > lo\\n                need_to_update_lo = nxt[L] > lo\\n                # Same for hi\\n                need_to_update_hi = nxt[L] > hi\\n                    \\n            # If we need to update lo, it\\'s because setting arr[L] to 0\\n            # decreased the prefix sum of arr at lo by 1,\\n            # so to update lo, we just need to find the next 1 in arr that comes after lo\\n            if need_to_update_lo:\\n                lo = find_next_one(arr, lo)\\n            # Same for hi\\n            if need_to_update_hi:\\n                hi = find_next_one(arr, hi)\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n# Return the least index j > idx such that arr[j] = 1,\\n# or return len(arr) if no such index exists\\ndef find_next_one(arr: List[int], idx: int) -> int:\\n    N = len(arr)\\n    while idx < N:\\n        idx += 1\\n        if idx == N or arr[idx] == 1:\\n            return idx\\n    return idx\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        # nxt[i] = least j > i such that nums[j] = nums[i], or -1 if i is the last occurrence of nums[i] in nums\\n        nxt = [-1 for _ in range(N)]\\n        # last_seen[n] = last index where n was seen in nums, or -1 if n hasn\\'t been seen before\\n        last_seen = [-1 for _ in range(N+1)]\\n        # arr[i] = 1 if i is the least index >= L where nums[i] appears in nums\\n        # Initially, L = 0\\n        arr = [0 for _ in range(N)]\\n        for i in range(N):\\n            if last_seen[nums[i]] != -1:\\n                # Update nxt, if possible\\n                nxt[last_seen[nums[i]]] = i\\n            else:\\n                # i is the first occurrence of nums[i] in nums, so update arr\\n                arr[i] = 1\\n            # We just saw nums[i], so update last_seen\\n            last_seen[nums[i]] = i\\n        \\n        # lo = least index such that sum from i=0 to lo of arr[i] = K, or N if no such index exists\\n        lo = -1\\n        pfx = 0\\n        while pfx < k:\\n            lo += 1\\n            if lo == N:\\n                break\\n            pfx += arr[lo]\\n        \\n        # hi = least index such that sum from i=0 to lo of arr[i] = K+1, or N if no such index exists\\n        # In other words, hi is the position of the next 1 in arr after lo\\n        hi = find_next_one(arr, lo)\\n        \\n        answer = 0\\n        for L in range(N):\\n            # Remember: Number of subarrays beginning at L with K distinct elements is hi-lo\\n            answer += hi-lo\\n            \\n            # Since we are going to increase L, theoreitcally, we set arr[L] = 0\\n            # This means prefix sums at lo and hi just decreased by 1,\\n            # so we need to update lo and hi\\n            need_to_update_lo = True\\n            need_to_update_hi = True\\n            if nxt[L] != -1:\\n                # Update arr, if possible\\n                arr[nxt[L]] = 1\\n                # If nxt[L] <= lo, then setting arr[nxt[L]] to 1 cancels out\\n                # setting arr[L] to 0, so the prefix sum at lo is still K\\n                # and we don\\'t need to update lo\\n                # Therefore, we only need to update lo if nxt[L] > lo\\n                need_to_update_lo = nxt[L] > lo\\n                # Same for hi\\n                need_to_update_hi = nxt[L] > hi\\n                    \\n            # If we need to update lo, it\\'s because setting arr[L] to 0\\n            # decreased the prefix sum of arr at lo by 1,\\n            # so to update lo, we just need to find the next 1 in arr that comes after lo\\n            if need_to_update_lo:\\n                lo = find_next_one(arr, lo)\\n            # Same for hi\\n            if need_to_update_hi:\\n                hi = find_next_one(arr, hi)\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679902,
                "title": "c-map-sliding-window-two-pointers-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int n = (int)nums.size(), ans1 = 0, l = 0, ans2 = 0;\\n        map<int, int> mp;\\n        //Calculte Subarrays with distinct integers < k\\n        for(int r = 0; r < n; r++){\\n            mp[nums[r]]++;\\n            while(mp.size() >= k){\\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\\n                l++;\\n            }\\n            ans1 += (r - l + 1);\\n        }\\n        l = 0, mp.clear();\\n        //Calculate Subarrays with distinct integers <= k\\n        for(int r = 0; r < n; r++){\\n            mp[nums[r]]++;\\n            while(mp.size() > k){\\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\\n                l++;\\n            }\\n            ans2 += (r - l + 1);\\n        }\\n        // final ans  =  subarrays with <=k distinct integers - subarrays with < k distinct integers\\n        return ans2 - ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int n = (int)nums.size(), ans1 = 0, l = 0, ans2 = 0;\\n        map<int, int> mp;\\n        //Calculte Subarrays with distinct integers < k\\n        for(int r = 0; r < n; r++){\\n            mp[nums[r]]++;\\n            while(mp.size() >= k){\\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\\n                l++;\\n            }\\n            ans1 += (r - l + 1);\\n        }\\n        l = 0, mp.clear();\\n        //Calculate Subarrays with distinct integers <= k\\n        for(int r = 0; r < n; r++){\\n            mp[nums[r]]++;\\n            while(mp.size() > k){\\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\\n                l++;\\n            }\\n            ans2 += (r - l + 1);\\n        }\\n        // final ans  =  subarrays with <=k distinct integers - subarrays with < k distinct integers\\n        return ans2 - ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499830,
                "title": "c-sliding-window",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Sliding Window\\n\\nUse `[i, j)` as a sliding window to find the maximum window which contains no more than `K` unique elements.\\n\\nTo achieve this, we use a map `m` to store the last position of each number in the current window.\\n\\nWhen `m.size() > K`, we should move forward `i` to shrink the window until it become valid again.\\n\\nWhen `m.size() == K`, `[i, j)` is the maximum window we are looking for. \\n\\nWithin this maximum window `[i, j)`, there is a minimum window `[k, j)` containing no more than `K` unique elements. `k` is the minimal index in `m`.\\n\\nNow, the number of valid subarrays in this window is `k - i + 1`.\\n\\nSince `k` is monotonically increasing and must be no less than `i`, we can use `k` as a global pointer just like `i` and `j` so that the overall time complexity of moving `k` is `O(N)`.\\n\\nWhenever `m.size() == K`, we can move `k` forward until `m[A[k] - \\'0\\'] == k`, and add `k - i + 1` to the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/subarrays-with-k-different-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int ans = 0, i = 0, j = 0, k = 0, N = A.size();\\n        unordered_map<int, int> m;\\n        while (j < N) {\\n            m[A[j] - \\'0\\'] = j;\\n            ++j;\\n            while (m.size() > K) {\\n                int d = A[i++] - \\'0\\';\\n                if (m[d] < i) m.erase(d);\\n            }\\n            if (m.size() == K) {\\n                k = max(i, k);\\n                while (m[A[k] - \\'0\\'] != k) ++k;\\n                ans += k - i + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Shrinkable Sliding Window\\n\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\" which can help you solve all sliding window problems.\\n\\nWe can turn this problem into two find maximum sliding window problem: one is to find a window with at most `k` different integers, another is to find a window with at most `k - 1` different integers.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/subarrays-with-k-different-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(U) where U is the number of unique numbers in `A`\\nclass Solution {\\n    int atMost(vector<int> &A, int k) {\\n        int distinct = 0, i = 0, j = 0, N = A.size(), ans = 0;\\n        unordered_map<int, int> cnt;\\n        for (; j < N; ++j) {\\n            distinct += ++cnt[A[j]] == 1;\\n            while (distinct > k) distinct -= --cnt[A[i++]] == 0;\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/subarrays-with-k-different-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int ans = 0, i = 0, j = 0, k = 0, N = A.size();\\n        unordered_map<int, int> m;\\n        while (j < N) {\\n            m[A[j] - \\'0\\'] = j;\\n            ++j;\\n            while (m.size() > K) {\\n                int d = A[i++] - \\'0\\';\\n                if (m[d] < i) m.erase(d);\\n            }\\n            if (m.size() == K) {\\n                k = max(i, k);\\n                while (m[A[k] - \\'0\\'] != k) ++k;\\n                ans += k - i + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/subarrays-with-k-different-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(U) where U is the number of unique numbers in `A`\\nclass Solution {\\n    int atMost(vector<int> &A, int k) {\\n        int distinct = 0, i = 0, j = 0, N = A.size(), ans = 0;\\n        unordered_map<int, int> cnt;\\n        for (; j < N; ++j) {\\n            distinct += ++cnt[A[j]] == 1;\\n            while (distinct > k) distinct -= --cnt[A[i++]] == 0;\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219792,
                "title": "cpp-intitutive-sliding-window-unordered-map-short",
                "content": "Main idea is we can easly calculate number of different subarrays having at most k distant elements instead of exact k elements so we just exploite normal math atMostK( k ) - atMost( k-1 ).\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int>&a , int k){\\n        if( k == 0){\\n            return 0;\\n        }\\n        unordered_map<int,int> map;\\n        int n = a.size();\\n        int j=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            map[a[i]]++;\\n            while(map.size() > k and j <= i){\\n                int p = map[a[j]]--;\\n                if(p == 1){\\n                    map.erase(a[j]);\\n                }\\n                j++;\\n            }\\n            ans += (i-j+1);\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        return help(a, k) - help(a,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(vector<int>&a , int k){\\n        if( k == 0){\\n            return 0;\\n        }\\n        unordered_map<int,int> map;\\n        int n = a.size();\\n        int j=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            map[a[i]]++;\\n            while(map.size() > k and j <= i){\\n                int p = map[a[j]]--;\\n                if(p == 1){\\n                    map.erase(a[j]);\\n                }\\n                j++;\\n            }\\n            ans += (i-j+1);\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        return help(a, k) - help(a,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167100,
                "title": "pretty-simple-sliding-window",
                "content": "Count the number of subarrays having at most k distinct integers and having at most k-1 distinct integers. Once you have found those just take the difference and you will have count of subarrays having exactly k distinct integers.\\n\\nThe problem is to find count of subarrays having atmost k distinct integers for which you can use slding window.\\n\\n```class Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        return self.countAtMostSubarrays(A, K) - self.countAtMostSubarrays(A, K-1)\\n    \\n    def countAtMostSubarrays(self, nums, k):\\n        answer = 0\\n        \\n        if not nums or k == 0:\\n            return answer\\n        \\n        memo = collections.defaultdict(lambda: 0)\\n        left = distinctCount = 0\\n        n = len(nums)\\n        \\n        for right in range(n):\\n            currentVal = nums[right]\\n            \\n            if currentVal not in memo:\\n                distinctCount += 1\\n                \\n            memo[currentVal] += 1\\n            \\n            while left < right and distinctCount > k:\\n                disVal = nums[left]\\n                left += 1\\n                \\n                memo[disVal] -= 1\\n                \\n                if memo[disVal] == 0:\\n                    del memo[disVal]\\n                    distinctCount -= 1\\n                    \\n            answer += right - left + 1\\n            \\n        return answer\\n        \\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        return self.countAtMostSubarrays(A, K) - self.countAtMostSubarrays(A, K-1)\\n    \\n    def countAtMostSubarrays(self, nums, k):\\n        answer = 0\\n        \\n        if not nums or k == 0:\\n            return answer\\n        \\n        memo = collections.defaultdict(lambda: 0)\\n        left = distinctCount = 0\\n        n = len(nums)\\n        \\n        for right in range(n):\\n            currentVal = nums[right]\\n            \\n            if currentVal not in memo:\\n                distinctCount += 1\\n                \\n            memo[currentVal] += 1\\n            \\n            while left < right and distinctCount > k:\\n                disVal = nums[left]\\n                left += 1\\n                \\n                memo[disVal] -= 1\\n                \\n                if memo[disVal] == 0:\\n                    del memo[disVal]\\n                    distinctCount -= 1\\n                    \\n            answer += right - left + 1\\n            \\n        return answer\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043993,
                "title": "java-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        \\n    \\n        return solve(A, K) - solve(A, K-1);    \\n    }\\n    \\n    public int solve(int[] A, int K){\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int ans=0;\\n        int n = A.length;\\n        while(j<n)\\n        {\\n            int key = A[j];\\n            if(map.containsKey(key))\\n            {\\n                map.put(key,map.get(key)+1);\\n            }\\n            else\\n            {\\n                map.put(key,1);\\n            }\\n            \\n            \\n            if(map.size() < K)\\n            {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n            if(map.size()==K)\\n            {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n            if(map.size() > K)\\n            {\\n               while(map.size() > K)\\n               {\\n                     map.put(A[i],map.get(A[i])-1);\\n                       if(map.get(A[i])==0)\\n                       {\\n                           map.remove(A[i]);\\n                       }\\n                      i++;\\n                   \\n               }\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        \\n    \\n        return solve(A, K) - solve(A, K-1);    \\n    }\\n    \\n    public int solve(int[] A, int K){\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int ans=0;\\n        int n = A.length;\\n        while(j<n)\\n        {\\n            int key = A[j];\\n            if(map.containsKey(key))\\n            {\\n                map.put(key,map.get(key)+1);\\n            }\\n            else\\n            {\\n                map.put(key,1);\\n            }\\n            \\n            \\n            if(map.size() < K)\\n            {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n            if(map.size()==K)\\n            {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n            if(map.size() > K)\\n            {\\n               while(map.size() > K)\\n               {\\n                     map.put(A[i],map.get(A[i])-1);\\n                       if(map.get(A[i])==0)\\n                       {\\n                           map.remove(A[i]);\\n                       }\\n                      i++;\\n                   \\n               }\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734832,
                "title": "c-sliding-window-small-an-concise-soln-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int ans=0;\\n        int left=0;\\n        int right=0;\\n        unordered_map<int,int> umap;\\n        int cnt=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            \\n            //updating map\\n\\t\\t\\t\\n            if(umap.find(A[i])==umap.end() || umap[A[i]]==0) cnt++;\\n            umap[A[i]]++;\\n                \\n            \\n            //setting left most side for window\\n            \\n            if(cnt>K){\\n                umap[A[right]]--;\\n                cnt--;\\n                left=right+1;\\n                right=left;\\n                \\n            }\\n\\t\\t\\t\\n\\t\\t\\t//setting right most side of window and and adding possible number of solution to ans\\n\\t\\t\\t\\n            if(cnt==K){\\n                while(umap[A[right]]>1){\\n                    umap[A[right]]--;\\n                    right++;\\n                }\\n                ans=ans+(right-left+1);\\n                \\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int ans=0;\\n        int left=0;\\n        int right=0;\\n        unordered_map<int,int> umap;\\n        int cnt=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            \\n            //updating map\\n\\t\\t\\t\\n            if(umap.find(A[i])==umap.end() || umap[A[i]]==0) cnt++;\\n            umap[A[i]]++;\\n                \\n            \\n            //setting left most side for window\\n            \\n            if(cnt>K){\\n                umap[A[right]]--;\\n                cnt--;\\n                left=right+1;\\n                right=left;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 459766,
                "title": "c-o-n-dictionary-two-pointers",
                "content": "```\\n\\t\\tpublic int SubarraysWithKDistinct(int[] A, int K) {\\n            int res = 0;\\n            Dictionary<int, int> dict = new Dictionary<int, int>();\\n            int start = 0;\\n            int current = 0;\\n            for(int i = 0; i < A.Length; i++) {\\n                if(dict.ContainsKey(A[i])) {\\n                    dict[A[i]]++;\\n                } else {\\n                    dict[A[i]] = 1;\\n                }\\n                if(dict.Keys.Count >= K) {\\n                    while(dict[A[current]] > 1) {\\n                        dict[A[current++]]--;    \\n                    }\\n                    if (dict.Keys.Count == K) {\\n                        res += current - start + 1;\\n                    } else {\\n                        dict.Remove(A[current++]);\\n                        start = current;\\n                        dict[A[i]] = 0;\\n                        i--;\\n                    }\\n                } \\n            }\\n            return res;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic int SubarraysWithKDistinct(int[] A, int K) {\\n            int res = 0;\\n            Dictionary<int, int> dict = new Dictionary<int, int>();\\n            int start = 0;\\n            int current = 0;\\n            for(int i = 0; i < A.Length; i++) {\\n                if(dict.ContainsKey(A[i])) {\\n                    dict[A[i]]++;\\n                } else {\\n                    dict[A[i]] = 1;\\n                }\\n                if(dict.Keys.Count >= K) {\\n                    while(dict[A[current]] > 1) {\\n                        dict[A[current++]]--;    \\n                    }\\n                    if (dict.Keys.Count == K) {\\n                        res += current - start + 1;\\n                    } else {\\n                        dict.Remove(A[current++]);\\n                        start = current;\\n                        dict[A[i]] = 0;\\n                        i--;\\n                    }\\n                } \\n            }\\n            return res;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 264847,
                "title": "4-ms-21-line-java-solution-100-time-94-space",
                "content": "use byte countlist to save space.\\nwindow [i, j] is not satisfactory (k unique elements) at first.\\nvar good count satisfactory subarray.\\nafter [i, j] reach k unique elements, subsequent subarray always satisfy that:\\n\\tcount[arr[i]] == 1.\\n```\\nclass Solution {\\n  public int subarraysWithKDistinct(int[] arr, int k) {\\n    short[] count = new short[arr.length+1];\\n    short unique=0;\\n    int i=0, total=0, good=0;\\n    for(int j=0; j<arr.length; j++){\\n      if(count[arr[j]]++==0) unique++;\\n      if(unique>k){\\n        count[arr[i++]]--;\\n        unique--;\\n        good=0;\\n      }\\n      while(count[arr[i]]>1){\\n        count[arr[i++]]--;\\n        good++;\\n      }\\n      if(unique==k) total += good+1;\\n    }\\n    return total;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int subarraysWithKDistinct(int[] arr, int k) {\\n    short[] count = new short[arr.length+1];\\n    short unique=0;\\n    int i=0, total=0, good=0;\\n    for(int j=0; j<arr.length; j++){\\n      if(count[arr[j]]++==0) unique++;\\n      if(unique>k){\\n        count[arr[i++]]--;\\n        unique--;\\n        good=0;\\n      }\\n      while(count[arr[i]]>1){\\n        count[arr[i++]]--;\\n        good++;\\n      }\\n      if(unique==k) total += good+1;\\n    }\\n    return total;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234775,
                "title": "short-python-two-pointers-o-k-space",
                "content": "Explantion is same as Yaang\\'s in the comment section below\\n```\\nclass Solution(object):\\n    def subarraysWithKDistinct(self, A, K):\\n        s = collections.Counter() \\n        l = r = ans = 0 \\n        for i,num in enumerate(A):\\n            s[num] += 1\\n            if s[num] == 1 and len(s) == K:\\n                while r < len(A) and A[r] in s:\\n                    r += 1 \\n                while len(s) == K:\\n                    ans += r-i \\n                    s[A[l]] -= 1 \\n                    if s[A[l]] == 0: del s[A[l]] \\n                    l += 1 \\n        return ans",
                "solutionTags": [],
                "code": "Explantion is same as Yaang\\'s in the comment section below\\n```\\nclass Solution(object):\\n    def subarraysWithKDistinct(self, A, K):\\n        s = collections.Counter() \\n        l = r = ans = 0 \\n        for i,num in enumerate(A):\\n            s[num] += 1\\n            if s[num] == 1 and len(s) == K:\\n                while r < len(A) and A[r] in s:\\n                    r += 1 \\n                while len(s) == K:\\n                    ans += r-i \\n                    s[A[l]] -= 1 \\n                    if s[A[l]] == 0: del s[A[l]] \\n                    l += 1 \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 234480,
                "title": "java-o-n-2-short-and-easy-understanding",
                "content": "A better implementation should be using sliding window whose time complexity is O(N). However, the bruteforce way is very intuitive that could pass OJ so just share here.\\n\\nFor each subarray, check if there are K distinct intergers.\\n\\n```\\n    public int subarraysWithKDistinct(int[] A, int k) {\\n        int res = 0, n = A.length;\\n        int[] cnt = new int[n + 1]; // Given 1 <= A.length <= 20000 and 1 <= A[i] <= A.length\\n        \\n        for(int i = 0; i < n; i++) {\\n            int distCount = 0;\\n            Arrays.fill(cnt, 0);\\n            for(int j = i; j < n; j++) {\\n                if(cnt[A[j]] == 0) distCount++;\\n                cnt[A[j]]++;\\n                if(distCount == k) res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int subarraysWithKDistinct(int[] A, int k) {\\n        int res = 0, n = A.length;\\n        int[] cnt = new int[n + 1]; // Given 1 <= A.length <= 20000 and 1 <= A[i] <= A.length\\n        \\n        for(int i = 0; i < n; i++) {\\n            int distCount = 0;\\n            Arrays.fill(cnt, 0);\\n            for(int j = i; j < n; j++) {\\n                if(cnt[A[j]] == 0) distCount++;\\n                cnt[A[j]]++;\\n                if(distCount == k) res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3698818,
                "title": "solving-the-problem-using-it-s-easier-version-easy-to-understand-sliding-window-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExactly k distinct integers means : **Atmost (k) distinct integers - Atmost (k - 1)** distinct integers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I have used sliding window combined with two pointers approach.\\n1. **Fix a pointer \\'j\\'** at the beginning of the array and **traverse the array using \\'i\\'** and keep on storing the elements in the map, till the size of the map does not exceeds (k).\\n2. As it exceeds k, start deleting the elements from the beginning of the array using the j pointer and after deleting the elements increment the j pointer.\\n3. Each time calculate the distinct subarrays in the sliding window and add it to our answer.\\n4. By performing this algorithm once, **we\\'ll get subarrays with atmost k elements.**\\n5. **Perform same algorithm for atmost k - 1 elements and subtract the latter from the first part.**\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTraversing the array.\\n\\n- Space complexity: **O(k)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSize of the map will never exceed k.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int atmost(vector<int> nums, int k)\\n    {\\n        int n = nums.size();\\n\\n        int i = 0, j = 0;\\n        int cnt = 0;\\n\\n        map<int,int> mp;\\n\\n        while(i < n)\\n        {\\n            mp[nums[i]]++;\\n\\n            while(mp.size() > k)\\n            {\\n                auto it = mp.find(nums[j]);\\n                it -> second--;\\n\\n                if(it -> second == 0) mp.erase(it);\\n                j++;\\n            }\\n            cnt += (i - j + 1);\\n            i++;\\n        }\\n\\n        return cnt;\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmost(nums, k) - atmost(nums, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int atmost(vector<int> nums, int k)\\n    {\\n        int n = nums.size();\\n\\n        int i = 0, j = 0;\\n        int cnt = 0;\\n\\n        map<int,int> mp;\\n\\n        while(i < n)\\n        {\\n            mp[nums[i]]++;\\n\\n            while(mp.size() > k)\\n            {\\n                auto it = mp.find(nums[j]);\\n                it -> second--;\\n\\n                if(it -> second == 0) mp.erase(it);\\n                j++;\\n            }\\n            cnt += (i - j + 1);\\n            i++;\\n        }\\n\\n        return cnt;\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmost(nums, k) - atmost(nums, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330335,
                "title": "easy-java-solution-using-sliding-window",
                "content": "class Solution {\\n    \\n    private int countAtmost(int nums[], int k)\\n    {\\n        int count=0;\\n        HashMap<Integer, Integer> map=new HashMap<>();\\n        int i=0, j=0;\\n        while(j<nums.length)\\n        {\\n            map.put(nums[j], map.getOrDefault(nums[j], 0)+1);\\n            while(map.size()>k)\\n            {\\n                map.put(nums[i], map.getOrDefault(nums[i], 0)-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++;\\n            }\\n            count+=j-i+1;\\n            j++;\\n        }\\n        return count;\\n    }\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return countAtmost(nums, k) - countAtmost(nums, k-1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    \\n    private int countAtmost(int nums[], int k)\\n    {\\n        int count=0;\\n        HashMap<Integer, Integer> map=new HashMap<>();\\n        int i=0, j=0;\\n        while(j<nums.length)\\n        {\\n            map.put(nums[j], map.getOrDefault(nums[j], 0)+1);\\n            while(map.size()>k)\\n            {\\n                map.put(nums[i], map.getOrDefault(nums[i], 0)-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2158402,
                "title": "lol-first-hard-question-done-by-myself-so-happy",
                "content": "```\\nclass Solution {\\npublic:\\n  int solve(vector<int>&nums,int k)\\n  {\\n    int n=nums.size();\\n     int i=0;\\n     int j=0;\\n      int cnt=0;\\n     map<int,int>mp;\\n     while(j<n)\\n     {\\n       mp[nums[j]]++;\\n       while(i<n && mp.size()>k)\\n       {\\n         mp[nums[i]]--;\\n         if(mp[nums[i]]==0)\\n         {\\n           mp.erase(nums[i]);\\n         }\\n         i++;\\n       }\\n       cnt+=(j-i+1);\\n       j++;\\n     }\\n      return cnt;\\n  }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n     return solve(nums,k)-solve(nums,k-1);// first i counted k and less than k  no integer and then i //counted k-1 and less than k-1; And to get exactly k we need to subtract \\n\\t\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int solve(vector<int>&nums,int k)\\n  {\\n    int n=nums.size();\\n     int i=0;\\n     int j=0;\\n      int cnt=0;\\n     map<int,int>mp;\\n     while(j<n)\\n     {\\n       mp[nums[j]]++;\\n       while(i<n && mp.size()>k)\\n       {\\n         mp[nums[i]]--;\\n         if(mp[nums[i]]==0)\\n         {\\n           mp.erase(nums[i]);\\n         }\\n         i++;\\n       }\\n       cnt+=(j-i+1);\\n       j++;\\n     }\\n      return cnt;\\n  }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n     return solve(nums,k)-solve(nums,k-1);// first i counted k and less than k  no integer and then i //counted k-1 and less than k-1; And to get exactly k we need to subtract \\n\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988735,
                "title": "python-sol-faster-than-99-59-simple-explained-sliding-window-linear-time",
                "content": "# TIME AND SPACE USED\\nRuntime: 378 ms, faster than 99.59% of Python3 online submissions for Subarrays with K Different Integers.\\nMemory Usage: 16.6 MB, less than 85.54% of Python3 online submissions for Subarrays with K Different Integers.\\n\\n# EXPLANATION\\n```\\nWe are going to use sliding window\\n\\nIn sliding window we keep a window which satisfies the problem\\n\\nso we are going to keep a subarry in which there will at exactly k unique integers\\n\\nNow since we have got our subarray say [ 1 , 2 ,1 , 2 , 3 ] and say k = 3\\nMy subarray window satisfies the problem\\nNow the next step is to try to shrink the window from left\\nWhat if I remove 1 [  2 , 1 , 2 ,3 ] still have 3 unique int\\nWhat if I remove 2 [ 1 , 2  , 3 ] still have 3 unique int\\n\\nSo how does this works exactly ??\\n\\nSee when I am removing 1 from start I know that it is not the latest occurence of 1 i.e. 1 occured after that index which means even if I remove this one I still have 1 in my sliding window somewhere\\n\\nWhat If I remove 1 [ 2, 3] will have only 2 unique int\\nThis time this 1 was the latest occurence of 1 so when we removed this 1 we lost 1 in sliding window \\n\\nSo this gives the Idea to store latest of occurence of every int\\n\\nNow when we get sliding window with more than k unique int:\\n   We start removing from left and will remove until we remove all occurence of any integer\\n   specifically saying when latest[nums[index_start]] = index_start\\n   \\n   \\n\\n```\\n# IMAGE\\n![image](https://assets.leetcode.com/users/images/0aa4fcae-07fe-4cf9-89ba-f62fa4baec0c_1651141645.2300825.png)\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(nums)\\n        latest = {}\\n        unique = 0\\n        prev = 0\\n        for i in range(n):\\n            if nums[i] not in latest:\\n                unique += 1\\n            latest[nums[i]] = i\\n            if unique > k :\\n                while True:\\n                    if latest[nums[prev]] == prev:\\n                        latest.pop(nums[prev])\\n                        prev += 1\\n                        unique -= 1                        \\n                        break\\n                    else:\\n                        prev += 1\\n                        \\n            if unique == k:\\n                ans += 1\\n                tmp = prev\\n                while True:\\n                    if latest[nums[tmp]] != tmp:\\n                        ans += 1\\n                        tmp += 1\\n                    else:\\n                        break\\n        return ans\\n                \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nWe are going to use sliding window\\n\\nIn sliding window we keep a window which satisfies the problem\\n\\nso we are going to keep a subarry in which there will at exactly k unique integers\\n\\nNow since we have got our subarray say [ 1 , 2 ,1 , 2 , 3 ] and say k = 3\\nMy subarray window satisfies the problem\\nNow the next step is to try to shrink the window from left\\nWhat if I remove 1 [  2 , 1 , 2 ,3 ] still have 3 unique int\\nWhat if I remove 2 [ 1 , 2  , 3 ] still have 3 unique int\\n\\nSo how does this works exactly ??\\n\\nSee when I am removing 1 from start I know that it is not the latest occurence of 1 i.e. 1 occured after that index which means even if I remove this one I still have 1 in my sliding window somewhere\\n\\nWhat If I remove 1 [ 2, 3] will have only 2 unique int\\nThis time this 1 was the latest occurence of 1 so when we removed this 1 we lost 1 in sliding window \\n\\nSo this gives the Idea to store latest of occurence of every int\\n\\nNow when we get sliding window with more than k unique int:\\n   We start removing from left and will remove until we remove all occurence of any integer\\n   specifically saying when latest[nums[index_start]] = index_start\\n   \\n   \\n\\n```\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(nums)\\n        latest = {}\\n        unique = 0\\n        prev = 0\\n        for i in range(n):\\n            if nums[i] not in latest:\\n                unique += 1\\n            latest[nums[i]] = i\\n            if unique > k :\\n                while True:\\n                    if latest[nums[prev]] == prev:\\n                        latest.pop(nums[prev])\\n                        prev += 1\\n                        unique -= 1                        \\n                        break\\n                    else:\\n                        prev += 1\\n                        \\n            if unique == k:\\n                ans += 1\\n                tmp = prev\\n                while True:\\n                    if latest[nums[tmp]] != tmp:\\n                        ans += 1\\n                        tmp += 1\\n                    else:\\n                        break\\n        return ans\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694376,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        def atMostK(nums, k):\\n            n = len(nums)\\n            left, right = 0, 0\\n\\n            res = 0\\n\\n            from collections import Counter\\n            counter = Counter()\\n\\n            while right < n:\\n                counter[nums[right]] += 1\\n\\n                while len(counter) > k:\\n                    counter[nums[left]] -= 1\\n                    if counter[nums[left]] == 0:\\n                        del counter[nums[left]]\\n\\n                    left += 1\\n\\n                res += right - left + 1\\n                right += 1\\n\\n            return res\\n        \\n        return atMostK(nums, k) - atMostK(nums, k-1)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ebe39cb4-4f95-4e57-8e4c-1bae25544113_1642332679.8178716.png)\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        def atMostK(nums, k):\\n            n = len(nums)\\n            left, right = 0, 0\\n\\n            res = 0\\n\\n            from collections import Counter\\n            counter = Counter()\\n\\n            while right < n:\\n                counter[nums[right]] += 1\\n\\n                while len(counter) > k:\\n                    counter[nums[left]] -= 1\\n                    if counter[nums[left]] == 0:\\n                        del counter[nums[left]]\\n\\n                    left += 1\\n\\n                res += right - left + 1\\n                right += 1\\n\\n            return res\\n        \\n        return atMostK(nums, k) - atMostK(nums, k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312352,
                "title": "c-992-subarrays-with-k-different-integers",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int ans = 0, ii = -1; \\n        unordered_map<int, int> freq; \\n        queue<int> q; \\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            freq[nums[i]]++; \\n            q.push(i); \\n            if (freq.size() > k) {\\n                ii = q.front(); q.pop(); \\n                freq.erase(nums[ii]); \\n            }\\n            \\n            while (freq[nums[q.front()]] > 1) {\\n                int k = q.front(); q.pop(); \\n                freq[nums[k]]--; \\n            }\\n            \\n            if (freq.size() == k) ans += q.front() - ii; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int ans = 0, ii = -1; \\n        unordered_map<int, int> freq; \\n        queue<int> q; \\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            freq[nums[i]]++; \\n            q.push(i); \\n            if (freq.size() > k) {\\n                ii = q.front(); q.pop(); \\n                freq.erase(nums[ii]); \\n            }\\n            \\n            while (freq[nums[q.front()]] > 1) {\\n                int k = q.front(); q.pop(); \\n                freq[nums[k]]--; \\n            }\\n            \\n            if (freq.size() == k) ans += q.front() - ii; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312341,
                "title": "python3-sliding-window-queue",
                "content": "\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = ii = 0 \\n        freq = defaultdict(int)\\n        queue = deque()\\n        for i, x in enumerate(nums): \\n            freq[x] += 1\\n            queue.append(i)\\n            if len(freq) > k: \\n                ii = queue[0]+1\\n                freq.pop(nums[queue.popleft()])\\n            while freq[nums[queue[0]]] > 1: freq[nums[queue.popleft()]] -= 1\\n            if len(freq) == k: ans += queue[0] - ii + 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = ii = 0 \\n        freq = defaultdict(int)\\n        queue = deque()\\n        for i, x in enumerate(nums): \\n            freq[x] += 1\\n            queue.append(i)\\n            if len(freq) > k: \\n                ii = queue[0]+1\\n                freq.pop(nums[queue.popleft()])\\n            while freq[nums[queue[0]]] > 1: freq[nums[queue.popleft()]] -= 1\\n            if len(freq) == k: ans += queue[0] - ii + 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090637,
                "title": "java-sliding-window-4ms-beats-98-o-a-length",
                "content": "\\n    // O(A.length) O(1)\\n\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\treturn subarraysWithKAtmost(A, K) - subarraysWithKAtmost(A, K - 1);\\n\\t}\\n\\n\\t// O(A.length) O(1)\\n\\tpublic int subarraysWithKAtmost(int[] A, int K) {\\n\\n\\t\\tint count = 0, ptr1 = 0, ptr2 = 0, len = A.length, ans = 0;\\n\\t\\tint[] freq = new int[20001];\\n\\n\\t\\twhile (ptr1 < len) {\\n\\n\\t\\t\\twhile (ptr1 < len && count <= K) {\\n\\t\\t\\t\\tint num = A[ptr1];\\n\\t\\t\\t\\tif (freq[num] == 0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tfreq[num]++;\\n\\t\\t\\t\\tptr1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (count == K + 1) {\\n\\t\\t\\t\\tans += (ptr1 - ptr2 - 1);\\n\\t\\t\\t\\tint num = A[ptr2];\\n\\t\\t\\t\\tfreq[num]--;\\n\\t\\t\\t\\tptr2++;\\n\\t\\t\\t\\tif (freq[num] == 0)\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tint n = ptr1 - ptr2;\\n\\t\\tans += (n * (n + 1) / 2);\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(A.length) O(1)\\n\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\treturn subarraysWithKAtmost(A, K) - subarraysWithKAtmost(A, K - 1);\\n\\t}\\n\\n\\t// O(A.length) O(1)\\n\\tpublic int subarraysWithKAtmost(int[] A, int K) {\\n\\n\\t\\tint count = 0, ptr1 = 0, ptr2 = 0, len = A.length, ans = 0;\\n\\t\\tint[] freq = new int[20001];\\n\\n\\t\\twhile (ptr1 < len) {\\n\\n\\t\\t\\twhile (ptr1 < len && count <= K) {\\n\\t\\t\\t\\tint num = A[ptr1];\\n\\t\\t\\t\\tif (freq[num] == 0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tfreq[num]++;\\n\\t\\t\\t\\tptr1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (count == K + 1) {\\n\\t\\t\\t\\tans += (ptr1 - ptr2 - 1);\\n\\t\\t\\t\\tint num = A[ptr2];\\n\\t\\t\\t\\tfreq[num]--;\\n\\t\\t\\t\\tptr2++;\\n\\t\\t\\t\\tif (freq[num] == 0)\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tint n = ptr1 - ptr2;\\n\\t\\tans += (n * (n + 1) / 2);\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1071174,
                "title": "lessons-learned",
                "content": "**Update**:\\n* After years of LC and now clearly understanding Vortubac approach ([this comment to be precise](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window/251836)), I realize this is a Hard question which shouldn\\'t be either asked in an interview or couldn\\'t be in solved in an intetview timeframe. Skipping this Q from my interview prep. But the Q teaches the concept of storing starting indices of other subarrays within the window (like prefix) during shrinking and expanding the sliding window. It is no more simply shrink and expand. This concept must be known.\\n\\n**Original**:\\n* This seems like an advanced variation of https://leetcode.com/problems/subarrays-with-k-different-integers/ . The differnce is here finding the start of valid subarrays is tricky and requires an auxillary array.\\n\\n```\\n// Incomplete\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        int ans = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int subarrayStart = 0;\\n        int prefix = 0;\\n        for (int windowStart = 0, windowEnd = 0; windowEnd < nums.length; ++windowEnd) {\\n            map.put(nums[windowEnd], map.getOrDefault(nums[windowEnd], 0) + 1);\\n            while (map.size() == k) {\\n                ++prefix;\\n                map.put(nums[windowStart], map.get(nums[windowStart]) - 1);\\n                if (map.get(nums[windowStart]) == 0) {\\n                    map.remove(nums[windowStart]);\\n                }\\n                ++windowStart;\\n            }\\n            ans += prefix;\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n// Incomplete\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        int ans = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int subarrayStart = 0;\\n        int prefix = 0;\\n        for (int windowStart = 0, windowEnd = 0; windowEnd < nums.length; ++windowEnd) {\\n            map.put(nums[windowEnd], map.getOrDefault(nums[windowEnd], 0) + 1);\\n            while (map.size() == k) {\\n                ++prefix;\\n                map.put(nums[windowStart], map.get(nums[windowStart]) - 1);\\n                if (map.get(nums[windowStart]) == 0) {\\n                    map.remove(nums[windowStart]);\\n                }\\n                ++windowStart;\\n            }\\n            ans += prefix;\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573196,
                "title": "a-java-based-sliding-window-solution-with-dry-run",
                "content": "1) As already mentioned in a number of other/older threads, the main idea is if we can calculate the number of subarrays with at most K different numbers and then subtract the number of subarrays with at most k-1 unique numbers then we get the answer - this is written in discussion forums\\n\\n2) So the main question how to do calculate the number of subarrays with at most N characters?\\n\\n3) We use sliding window to crate a window with at most N characters; for each of this window we calculate subarrays with at most N characters\\n\\n-------------------------------------------DRY RUN START ------------------------------------------\\nARRAY = [1,2,1,2,3] -- sliding windows with at most 2 unique characters and the subarrays which were not counted before are as follows:\\n\\nSliding-window   -->     Subarrays within sliding window (these are subarrays ending at right pointer)\\n\\n[1]              --> {1}\\n[1,2]            --> {1,2},{2}\\n[1,2,1]          --> {1,2,1},{2,1},{1} \\n[1,2,1,2]        --> {1,2,1,2}, {2,1,2},{1,2},{1} \\n[2,3]            --> {2,3},{3} \\n\\nThe total number of subarrays with at most 2 characters = number of subarrays in {} which is = 12\\n\\nARRAY = [1,2,1,2,3] -- sliding windows with at most 1 unique characters and the subarrays which were not counted before are as follows:\\n\\nSliding-window   -->     Subarrays within sliding window (these are subarrays ending at right pointer)\\n\\n[1]              --> {1}\\n[2]              --> {2}\\n[1]              --> {1} \\n[2]              --> {2} \\n[3]              --> {3} \\n\\nThe total number of subarrays with at most 1 characters = number of subarrays in {} which is = 5\\n\\nSo the Final answer is = 12 - 5 = 7\\n\\n-------------------------------------------DRY RUN END--------------------------------------------\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        //main intution \\n        return subarraysWithAtMostNDistinctNumbers(A,K) - subarraysWithAtMostNDistinctNumbers(A,K-1);\\n    }\\n    \\n    private int subarraysWithAtMostNDistinctNumbers(int[] A, int N) {\\n        \\n        int result = 0;\\n        int numberOfUniqueNumbersInCurrentSlidingWindow = 0;\\n        int left = 0;\\n        int right = 0;\\n        Map<Integer,Integer> slidingWindowCountMap = new HashMap<>();\\n        while(right < A.length) {\\n            int numAtRightIndex = A[right];\\n            slidingWindowCountMap.put(numAtRightIndex,slidingWindowCountMap.getOrDefault(numAtRightIndex,0)+1);\\n            \\n            while(slidingWindowCountMap.size() == N+1) {\\n                int numAtLeftIndex = A[left];\\n                int countOfNumAtLeftIndexInCurrentSlidingWindow = slidingWindowCountMap.get(numAtLeftIndex);\\n                \\n                //if the count is greaterThan 1 then we just decrement the count by 1\\n                //otherwise we remove it from the slidingWindowMap\\n                //We need to do this because our slidingWindowLogic is based on map size \\n                if(countOfNumAtLeftIndexInCurrentSlidingWindow > 1) {\\n                    slidingWindowCountMap.put(numAtLeftIndex,countOfNumAtLeftIndexInCurrentSlidingWindow-1);\\n                } else {\\n                    slidingWindowCountMap.remove(numAtLeftIndex);\\n                }\\n                left++;\\n            }\\n            \\n            //when we get here, right index has definitely moved away from last time we took the count\\n            //additionally left index cound have moved as well, if the inner while loop was run \\n            int numberOfSubArraysInCurrentSlidingWindowEndingAtRightIndex = right+1 - left;\\n            \\n            //Add the above number of unique subarrays to the final result \\n            result += numberOfSubArraysInCurrentSlidingWindowEndingAtRightIndex;\\n            right++;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        //main intution \\n        return subarraysWithAtMostNDistinctNumbers(A,K) - subarraysWithAtMostNDistinctNumbers(A,K-1);\\n    }\\n    \\n    private int subarraysWithAtMostNDistinctNumbers(int[] A, int N) {\\n        \\n        int result = 0;\\n        int numberOfUniqueNumbersInCurrentSlidingWindow = 0;\\n        int left = 0;\\n        int right = 0;\\n        Map<Integer,Integer> slidingWindowCountMap = new HashMap<>();\\n        while(right < A.length) {\\n            int numAtRightIndex = A[right];\\n            slidingWindowCountMap.put(numAtRightIndex,slidingWindowCountMap.getOrDefault(numAtRightIndex,0)+1);\\n            \\n            while(slidingWindowCountMap.size() == N+1) {\\n                int numAtLeftIndex = A[left];\\n                int countOfNumAtLeftIndexInCurrentSlidingWindow = slidingWindowCountMap.get(numAtLeftIndex);\\n                \\n                //if the count is greaterThan 1 then we just decrement the count by 1\\n                //otherwise we remove it from the slidingWindowMap\\n                //We need to do this because our slidingWindowLogic is based on map size \\n                if(countOfNumAtLeftIndexInCurrentSlidingWindow > 1) {\\n                    slidingWindowCountMap.put(numAtLeftIndex,countOfNumAtLeftIndexInCurrentSlidingWindow-1);\\n                } else {\\n                    slidingWindowCountMap.remove(numAtLeftIndex);\\n                }\\n                left++;\\n            }\\n            \\n            //when we get here, right index has definitely moved away from last time we took the count\\n            //additionally left index cound have moved as well, if the inner while loop was run \\n            int numberOfSubArraysInCurrentSlidingWindowEndingAtRightIndex = right+1 - left;\\n            \\n            //Add the above number of unique subarrays to the final result \\n            result += numberOfSubArraysInCurrentSlidingWindowEndingAtRightIndex;\\n            right++;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546964,
                "title": "javascript-solution-sliding-window",
                "content": "Having as a guide the solutions from here: [[Java/C++/Python] Sliding Window](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC++Python-Sliding-Window)\\n```\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar subarraysWithKDistinct = function(A, K) {\\n    return (atMostK(A, K) - atMostK(A, K - 1));\\n};\\n\\nfunction atMostK(A, K) {\\n      let count = {};\\n    let maxArr = 0, windowStart = 0;\\n\\n    for (let windowEnd = 0; windowEnd < A.length; windowEnd++) {\\n        const rightInt = A[windowEnd];\\n\\n        if (!(rightInt in count)) {\\n            count[rightInt] = 0;\\n        }\\n\\n        if (count[rightInt] === 0) {\\n            K -= 1;\\n        }\\n        count[rightInt] += 1;\\n\\n        while (K < 0) {\\n            const leftInt = A[windowStart];\\n            count[leftInt] -= 1;\\n            if (count[leftInt] === 0) {\\n                K += 1;\\n            }\\n            windowStart += 1;        }\\n        maxArr += windowEnd - windowStart + 1;\\n    }\\n\\n    return maxArr;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar subarraysWithKDistinct = function(A, K) {\\n    return (atMostK(A, K) - atMostK(A, K - 1));\\n};\\n\\nfunction atMostK(A, K) {\\n      let count = {};\\n    let maxArr = 0, windowStart = 0;\\n\\n    for (let windowEnd = 0; windowEnd < A.length; windowEnd++) {\\n        const rightInt = A[windowEnd];\\n\\n        if (!(rightInt in count)) {\\n            count[rightInt] = 0;\\n        }\\n\\n        if (count[rightInt] === 0) {\\n            K -= 1;\\n        }\\n        count[rightInt] += 1;\\n\\n        while (K < 0) {\\n            const leftInt = A[windowStart];\\n            count[leftInt] -= 1;\\n            if (count[leftInt] === 0) {\\n                K += 1;\\n            }\\n            windowStart += 1;        }\\n        maxArr += windowEnd - windowStart + 1;\\n    }\\n\\n    return maxArr;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536944,
                "title": "java-universal-format-sliding-window-and-reuse",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return helper(A, K) - helper(A, K - 1); //helper is num of subs at most k distinct\\n    }\\n    private int helper(int[] arr, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int cnt = 0, l = 0, res = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            int n = arr[i];\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            if (map.get(n) == 1) cnt++;\\n            while (cnt > k) {\\n                n = arr[l++];\\n                map.put(n, map.get(n) - 1);\\n                if (map.get(n) == 0) cnt--;\\n            }\\n            res += i - l;\\n        }\\n        return res;\\n    }\\n}\\n```\\nRef: https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235002/One-code-template-to-solve-all-of-these-problems!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return helper(A, K) - helper(A, K - 1); //helper is num of subs at most k distinct\\n    }\\n    private int helper(int[] arr, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int cnt = 0, l = 0, res = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            int n = arr[i];\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            if (map.get(n) == 1) cnt++;\\n            while (cnt > k) {\\n                n = arr[l++];\\n                map.put(n, map.get(n) - 1);\\n                if (map.get(n) == 0) cnt--;\\n            }\\n            res += i - l;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491173,
                "title": "simpler-version-of-official-solution-python",
                "content": "```\\nimport collections\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        ###O(n) sliding window solution\\n        \\n        ##for counting subarrays with at most K unique elements    \\n        c1 = collections.Counter()\\n        d1 = 0 #num_distinct_1\\n\\n        ##for counting subarrays with less than K unique elements\\n        c2 = collections.Counter()\\n        d2 = 0#num_distinct_2\\n        \\n        ans = 0\\n        left1 = left2 = 0\\n            \\n        for idx, num in enumerate(A):\\n            c1[num]+=1\\n            c2[num]+=1\\n            if c1[num]==1:\\n                d1+=1\\n            if c2[num]==1:\\n                d2+=1\\n                \\n            while d1>K:\\n                n = A[left1]\\n                c1[n]-=1\\n                if c1[n]==0:\\n                    d1-=1\\n                left1+=1\\n                \\n            while d2>=K:\\n                n = A[left2]\\n                c2[n]-=1\\n                if c2[n]==0:\\n                    d2-=1\\n                left2+=1\\n            \\n            ans += left2 - left1\\n        \\n        return ans\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        ###O(n) sliding window solution\\n        \\n        ##for counting subarrays with at most K unique elements    \\n        c1 = collections.Counter()\\n        d1 = 0 #num_distinct_1\\n\\n        ##for counting subarrays with less than K unique elements\\n        c2 = collections.Counter()\\n        d2 = 0#num_distinct_2\\n        \\n        ans = 0\\n        left1 = left2 = 0\\n            \\n        for idx, num in enumerate(A):\\n            c1[num]+=1\\n            c2[num]+=1\\n            if c1[num]==1:\\n                d1+=1\\n            if c2[num]==1:\\n                d2+=1\\n                \\n            while d1>K:\\n                n = A[left1]\\n                c1[n]-=1\\n                if c1[n]==0:\\n                    d1-=1\\n                left1+=1\\n                \\n            while d2>=K:\\n                n = A[left2]\\n                c2[n]-=1\\n                if c2[n]==0:\\n                    d2-=1\\n                left2+=1\\n            \\n            ans += left2 - left1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423782,
                "title": "python3-100-100",
                "content": "use hash map. \\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        i = k = 0\\n        ans = 0\\n        mMap = {}\\n        for j in range(n):\\n            if A[j] not in mMap:\\n                mMap[A[j]] = 1\\n            else:\\n                mMap[A[j]] += 1\\n            if len(mMap) < K:\\n                continue\\n            elif len(mMap) > K:\\n                del mMap[A[k]]\\n                i = k = k+1\\n            while mMap[A[k]] > 1:\\n                mMap[A[k]] -= 1\\n                k += 1\\n            ans += k - i + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        i = k = 0\\n        ans = 0\\n        mMap = {}\\n        for j in range(n):\\n            if A[j] not in mMap:\\n                mMap[A[j]] = 1\\n            else:\\n                mMap[A[j]] += 1\\n            if len(mMap) < K:\\n                continue\\n            elif len(mMap) > K:\\n                del mMap[A[k]]\\n                i = k = k+1\\n            while mMap[A[k]] > 1:\\n                mMap[A[k]] -= 1\\n                k += 1\\n            ans += k - i + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393225,
                "title": "java-solution-with-detailed-explaination",
                "content": "We can consider each index as start of the subarray and try to find all the possible end points.\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int size = A.length;\\n        int count = 0 ;\\n\\t\\t// stores the count of each integer appearing in the sliding window\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\t\\t// end points of window\\n        int l=0, r=0;\\n        while(true) {\\n\\t\\t\\t// let p be the index of 1st element such that no. of distinct elements in window [l, p] is K\\n\\t\\t\\t// run right pointer till you find p\\n            while(r<size && m.size()< K) {\\n                add(m, A[r]);\\n                r++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// return answer if we run out of elements\\n            if(m.size()!=K) return count;\\n            \\n\\t\\t\\t// At this point, r is one pointer ahead of p & we have K elements in the window [l, p]\\n\\t\\t\\t\\n\\t\\t\\tint temp = r-1;\\n\\t\\t\\t// Start from p and count for all indexes for which window [l, temp] has K elements. These are the possible ends of the sub array starting at l.\\n            while(temp<size && has(m, A[temp])) {\\n                count++;\\n                temp++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// since all the end pointers have been counted for subarray starting at l, we can move to next element as starting point of subarray\\n            remove(m, A[l]);\\n            l++;\\n        }\\n    }\\n    public void add(Map<Integer, Integer> m, int i) {\\n        m.put(i, m.getOrDefault(i, 0)+1);\\n    }\\n    \\n    public boolean has(Map<Integer, Integer> m, int i){\\n        return m.getOrDefault(i, 0)!=0;\\n    }\\n    \\n    public void remove(Map<Integer, Integer> m, int i) {\\n        int count = m.getOrDefault(i, 0);\\n        if(count<2) m.remove(i);\\n        else m.put(i, count - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int size = A.length;\\n        int count = 0 ;\\n\\t\\t// stores the count of each integer appearing in the sliding window\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\t\\t// end points of window\\n        int l=0, r=0;\\n        while(true) {\\n\\t\\t\\t// let p be the index of 1st element such that no. of distinct elements in window [l, p] is K\\n\\t\\t\\t// run right pointer till you find p\\n            while(r<size && m.size()< K) {\\n                add(m, A[r]);\\n                r++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// return answer if we run out of elements\\n            if(m.size()!=K) return count;\\n            \\n\\t\\t\\t// At this point, r is one pointer ahead of p & we have K elements in the window [l, p]\\n\\t\\t\\t\\n\\t\\t\\tint temp = r-1;\\n\\t\\t\\t// Start from p and count for all indexes for which window [l, temp] has K elements. These are the possible ends of the sub array starting at l.\\n            while(temp<size && has(m, A[temp])) {\\n                count++;\\n                temp++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// since all the end pointers have been counted for subarray starting at l, we can move to next element as starting point of subarray\\n            remove(m, A[l]);\\n            l++;\\n        }\\n    }\\n    public void add(Map<Integer, Integer> m, int i) {\\n        m.put(i, m.getOrDefault(i, 0)+1);\\n    }\\n    \\n    public boolean has(Map<Integer, Integer> m, int i){\\n        return m.getOrDefault(i, 0)!=0;\\n    }\\n    \\n    public void remove(Map<Integer, Integer> m, int i) {\\n        int count = m.getOrDefault(i, 0);\\n        if(count<2) m.remove(i);\\n        else m.put(i, count - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919201,
                "title": "c-solution-using-hashmaps-faster-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int atMostK(vector<int>&nums,int k){\\n        map<int,int> mp;\\n        int i=0,ans = 0;\\n        for(int j=0;j<nums.size();j++){\\n            mp[nums[j]]++;\\n\\n            while(mp.size() > k){\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                i++;\\n            }\\n\\n            ans += (j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n      return atMostK(nums,k)  - atMostK(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int atMostK(vector<int>&nums,int k){\\n        map<int,int> mp;\\n        int i=0,ans = 0;\\n        for(int j=0;j<nums.size();j++){\\n            mp[nums[j]]++;\\n\\n            while(mp.size() > k){\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                i++;\\n            }\\n\\n            ans += (j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n      return atMostK(nums,k)  - atMostK(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745246,
                "title": "c-sliding-window-faster-than-96-with-explanation-o-n",
                "content": "At first the problem seems to be tricky. We need to calculate number of Subarrays with ```exactly K distinct elements``` and this is where we feel defeated by our intuition. We need to somehow drop this word!\\n\\n```\\n\\t(exact K) = (atmost K) - (atmost K - 1)\\n```\\n\\nThe above equation makes problem simpler.\\n\\n**Solution to number of Subarrays with Atmost K distinct elements**\\nwe just need two pointers `left` and `right` and a container which can store the numbers in between these pointers and give results to queries like how many distinct elements it has. So a `map` data structure comes into picture. `(unordered_map will also work.)`\\n\\nNow, we\\'ll keep populating map with elements untill the either `size of map < k` or `right` pointer pointes to an element which is already in our `map`. otherwise `right` pointer is pointing to `(k+1)th` distinct element so we will start reducing our window size. \\n\\nAlso we\\'ll use following formula to `count number of subarrays` starting at index `left` and ends before index `right`.\\n```\\n\\tnumberOfSubarrays = right - left  // starting at index left\\n```\\nThat\\'s it.\\n\\n**Time Complexity** : O(n)\\n**Space complexity** : O(n)\\n\\n**Implementation 1: (normal)**\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithAtmostKDistinct(vector<int>& values, int k)\\n    {\\n        unordered_map<int,int> occurences;\\n        int ans = 0;\\n        int j = 0;\\n        int n = values.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && (occurences.size() < k || occurences.count(values[j])))\\n            {\\n                occurences[values[j]]++;\\n                j++;\\n            }\\n            ans += j - i; // number of subarrays starting at index i\\n            // and ends before j\\n            occurences[values[i]]--;\\n            if(occurences[values[i]] == 0)\\n                occurences.erase(values[i]); \\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // results will be difference in the\\n        // number of subarrays with atmost (k-1) distinct elements and\\n        // number of subarrays with atmost (k) distinct elements\\n        // Time complexity: O(n)\\n        \\n        int atmostKminus1 = subarraysWithAtmostKDistinct(nums, k-1);\\n        int atmostK = subarraysWithAtmostKDistinct(nums, k);\\n        if(k==1)\\n            atmostKminus1 = 0; // as there would not be any distinct element in a subarray\\n        // of size 0\\n        return (atmostK - atmostKminus1);\\n    }\\n};\\n```\\n\\n\\n**Implementation 2: Beats 96% of CPP Solution**\\nSince the range of nums[i] is `1 <= nums[i] <= nums.length() `. We can use `vector` instead of `map` and thus improving the execution time by exploiting fast random access time of arrays.  \\n\\n```\\nclass MyMap {\\npublic:\\n    // we\\'ll use array implemetation of map\\n    // with minimum required functionality\\n    \\n    vector<int> counter;\\n    int distinctElements = 0;\\n    \\n    MyMap() : distinctElements(0) {}\\n    MyMap(int n)\\n    {\\n        // map of capacity of n elements\\n        counter.resize(n+1, 0);\\n    }\\n    \\n    // setter functions\\n    void insertOne(int val)\\n    {\\n        if(!counter[val])\\n        {\\n            distinctElements++;\\n        }\\n        \\n        counter[val]++; // increment distinct element count if it is not present initially\\n    } \\n    \\n    void eraseOne(int val)\\n    {\\n        if(counter[val] == 1)\\n        {\\n            distinctElements--;\\n        }\\n        counter[val]--;\\n    }\\n    \\n    // getter functions\\n    int size()\\n    {\\n       return distinctElements; \\n    }\\n    \\n    bool count(int val)\\n    {\\n       return counter[val]; \\n    }\\n};\\nclass Solution {\\npublic:\\n    int subarraysWithAtmostKDistinct(vector<int>& values, int k)\\n    {\\n        int ans = 0;\\n        int j = 0;\\n        int n = values.size();\\n        MyMap occurences = MyMap(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && (occurences.size() < k || occurences.count(values[j])))\\n            {\\n                occurences.insertOne(values[j]);\\n                j++;\\n            }\\n            ans += j - i; // number of subarrays starting at index i\\n            // and ends before j\\n            occurences.eraseOne(values[i]); \\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // results will be difference in the\\n        // number of subarrays with atmost (k-1) distinct elements and\\n        // number of subarrays with atmost (k) distinct elements\\n        // Time complexity: O(n)\\n        \\n        int atmostKminus1 = subarraysWithAtmostKDistinct(nums, k-1);\\n        int atmostK = subarraysWithAtmostKDistinct(nums, k);\\n        if(k==1)\\n            atmostKminus1 = 0; // as there would not be any distinct element in a subarray\\n        // of size 0\\n        return (atmostK - atmostKminus1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```exactly K distinct elements```\n```\\n\\t(exact K) = (atmost K) - (atmost K - 1)\\n```\n```\\n\\tnumberOfSubarrays = right - left  // starting at index left\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraysWithAtmostKDistinct(vector<int>& values, int k)\\n    {\\n        unordered_map<int,int> occurences;\\n        int ans = 0;\\n        int j = 0;\\n        int n = values.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && (occurences.size() < k || occurences.count(values[j])))\\n            {\\n                occurences[values[j]]++;\\n                j++;\\n            }\\n            ans += j - i; // number of subarrays starting at index i\\n            // and ends before j\\n            occurences[values[i]]--;\\n            if(occurences[values[i]] == 0)\\n                occurences.erase(values[i]); \\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // results will be difference in the\\n        // number of subarrays with atmost (k-1) distinct elements and\\n        // number of subarrays with atmost (k) distinct elements\\n        // Time complexity: O(n)\\n        \\n        int atmostKminus1 = subarraysWithAtmostKDistinct(nums, k-1);\\n        int atmostK = subarraysWithAtmostKDistinct(nums, k);\\n        if(k==1)\\n            atmostKminus1 = 0; // as there would not be any distinct element in a subarray\\n        // of size 0\\n        return (atmostK - atmostKminus1);\\n    }\\n};\\n```\n```\\nclass MyMap {\\npublic:\\n    // we\\'ll use array implemetation of map\\n    // with minimum required functionality\\n    \\n    vector<int> counter;\\n    int distinctElements = 0;\\n    \\n    MyMap() : distinctElements(0) {}\\n    MyMap(int n)\\n    {\\n        // map of capacity of n elements\\n        counter.resize(n+1, 0);\\n    }\\n    \\n    // setter functions\\n    void insertOne(int val)\\n    {\\n        if(!counter[val])\\n        {\\n            distinctElements++;\\n        }\\n        \\n        counter[val]++; // increment distinct element count if it is not present initially\\n    } \\n    \\n    void eraseOne(int val)\\n    {\\n        if(counter[val] == 1)\\n        {\\n            distinctElements--;\\n        }\\n        counter[val]--;\\n    }\\n    \\n    // getter functions\\n    int size()\\n    {\\n       return distinctElements; \\n    }\\n    \\n    bool count(int val)\\n    {\\n       return counter[val]; \\n    }\\n};\\nclass Solution {\\npublic:\\n    int subarraysWithAtmostKDistinct(vector<int>& values, int k)\\n    {\\n        int ans = 0;\\n        int j = 0;\\n        int n = values.size();\\n        MyMap occurences = MyMap(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && (occurences.size() < k || occurences.count(values[j])))\\n            {\\n                occurences.insertOne(values[j]);\\n                j++;\\n            }\\n            ans += j - i; // number of subarrays starting at index i\\n            // and ends before j\\n            occurences.eraseOne(values[i]); \\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // results will be difference in the\\n        // number of subarrays with atmost (k-1) distinct elements and\\n        // number of subarrays with atmost (k) distinct elements\\n        // Time complexity: O(n)\\n        \\n        int atmostKminus1 = subarraysWithAtmostKDistinct(nums, k-1);\\n        int atmostK = subarraysWithAtmostKDistinct(nums, k);\\n        if(k==1)\\n            atmostKminus1 = 0; // as there would not be any distinct element in a subarray\\n        // of size 0\\n        return (atmostK - atmostKminus1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536529,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    int atmostk(vector<int>& nums, int k){\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n        int n = nums.size();\\n        int freq[20005] = {0};\\n        while(right < n){\\n            if(freq[nums[right]]++ == 0){\\n                k--;\\n            }\\n            while(k < 0){\\n                freq[nums[left]]--;\\n                if(freq[nums[left]] == 0) k++;\\n                left++;\\n            }\\n            count += right - left + 1;\\n            right++;\\n        }\\n        return count;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return atmostk(nums,k) - atmostk(nums,k-1);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(nums)\\n        latest = {}\\n        unique = 0\\n        prev = 0\\n        for i in range(n):\\n            if nums[i] not in latest:\\n                unique += 1\\n            latest[nums[i]] = i\\n            if unique > k :\\n                while True:\\n                    if latest[nums[prev]] == prev:\\n                        latest.pop(nums[prev])\\n                        prev += 1\\n                        unique -= 1                        \\n                        break\\n                    else:\\n                        prev += 1\\n                        \\n            if unique == k:\\n                ans += 1\\n                tmp = prev\\n                while True:\\n                    if latest[nums[tmp]] != tmp:\\n                        ans += 1\\n                        tmp += 1\\n                    else:\\n                        break\\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        int j = 0;\\n        int res = 0;\\n        int prefix = 0;\\n        int[] arr = new int[A.length + 1];\\n        for (int value : A) {\\n            if (arr[value]++ == 0) {\\n                count++;\\n            }\\n            while (count > K) {\\n                arr[A[j++]]--;\\n                prefix = 0;\\n                count--;\\n            }\\n            while (arr[A[j]] > 1) {\\n                prefix++;\\n                arr[A[j++]]--;\\n            }\\n            if (count == K) {\\n                res += prefix + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    int atmostk(vector<int>& nums, int k){\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n        int n = nums.size();\\n        int freq[20005] = {0};\\n        while(right < n){\\n            if(freq[nums[right]]++ == 0){\\n                k--;\\n            }\\n            while(k < 0){\\n                freq[nums[left]]--;\\n                if(freq[nums[left]] == 0) k++;\\n                left++;\\n            }\\n            count += right - left + 1;\\n            right++;\\n        }\\n        return count;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return atmostk(nums,k) - atmostk(nums,k-1);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(nums)\\n        latest = {}\\n        unique = 0\\n        prev = 0\\n        for i in range(n):\\n            if nums[i] not in latest:\\n                unique += 1\\n            latest[nums[i]] = i\\n            if unique > k :\\n                while True:\\n                    if latest[nums[prev]] == prev:\\n                        latest.pop(nums[prev])\\n                        prev += 1\\n                        unique -= 1                        \\n                        break\\n                    else:\\n                        prev += 1\\n                        \\n            if unique == k:\\n                ans += 1\\n                tmp = prev\\n                while True:\\n                    if latest[nums[tmp]] != tmp:\\n                        ans += 1\\n                        tmp += 1\\n                    else:\\n                        break\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        int j = 0;\\n        int res = 0;\\n        int prefix = 0;\\n        int[] arr = new int[A.length + 1];\\n        for (int value : A) {\\n            if (arr[value]++ == 0) {\\n                count++;\\n            }\\n            while (count > K) {\\n                arr[A[j++]]--;\\n                prefix = 0;\\n                count--;\\n            }\\n            while (arr[A[j]] > 1) {\\n                prefix++;\\n                arr[A[j++]]--;\\n            }\\n            if (count == K) {\\n                res += prefix + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3307322,
                "title": "sliding-window-hashmap-approach-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(nums.length)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(k)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    static int subarraysWithAtMostKDistinct(int nums[],int k){\\n        int ans = 0;\\n        int l = 0;\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        for(int i = 0;i < nums.length;i++){\\n            mp.put(nums[i],mp.getOrDefault(nums[i],0) + 1);\\n            for(;mp.size() > k;){\\n                mp.put(nums[l],mp.get(nums[l]) - 1);\\n                if(mp.get(nums[l]) == 0) mp.remove(nums[l]);\\n                l++;\\n            }\\n            ans += i - l + 1;\\n        }\\n        return ans;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return subarraysWithAtMostKDistinct(nums,k) - subarraysWithAtMostKDistinct(nums,k - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    static int subarraysWithAtMostKDistinct(int nums[],int k){\\n        int ans = 0;\\n        int l = 0;\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        for(int i = 0;i < nums.length;i++){\\n            mp.put(nums[i],mp.getOrDefault(nums[i],0) + 1);\\n            for(;mp.size() > k;){\\n                mp.put(nums[l],mp.get(nums[l]) - 1);\\n                if(mp.get(nums[l]) == 0) mp.remove(nums[l]);\\n                l++;\\n            }\\n            ans += i - l + 1;\\n        }\\n        return ans;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return subarraysWithAtMostKDistinct(nums,k) - subarraysWithAtMostKDistinct(nums,k - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154929,
                "title": "java-c-beats-99-8-o-n-time-and-o-n-space-hashtable",
                "content": "## Approach\\nCount of SubArrays with k distinct elements = Count of SubArrays with at most k distinct elements - Count of SubArrays with at most k-1 distinct elements.\\n\\n## Complexity\\n- Time complexity: O(2*n) \\u2243 O(n)\\n\\n- Space complexity: O(2*n) \\u2243 O(n)\\n\\n## Code\\n``` java []\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n       return subarraysWithAtMostKDistinct(nums,k)-subarraysWithAtMostKDistinct(nums,k-1);\\n    }\\n\\n    private int subarraysWithAtMostKDistinct(int[] nums,int k){\\n         int[] freq = new int[nums.length+1]; //1 <= nums[i] <= nums.length\\n\\n        int j=0, count=0, unique=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(freq[nums[i]]++==0)\\n               unique++;\\n\\n            while(unique>k){\\n                if(freq[nums[j++]]--==1)\\n                   unique--;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return subarraysWithAtMostKDistinct(nums,k)-subarraysWithAtMostKDistinct(nums,k-1);\\n    }\\n\\nprivate:\\n    int subarraysWithAtMostKDistinct(vector<int> &nums,int k){\\n        vector<int> freq(nums.size()+1); //1 <= nums[i] <= nums.size()\\n\\n        int j=0, count=0, unique=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(freq[nums[i]]++==0)\\n               unique++;\\n\\n            while(unique>k){\\n                if(freq[nums[j++]]--==1)\\n                   unique--;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n       return subarraysWithAtMostKDistinct(nums,k)-subarraysWithAtMostKDistinct(nums,k-1);\\n    }\\n\\n    private int subarraysWithAtMostKDistinct(int[] nums,int k){\\n         int[] freq = new int[nums.length+1]; //1 <= nums[i] <= nums.length\\n\\n        int j=0, count=0, unique=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(freq[nums[i]]++==0)\\n               unique++;\\n\\n            while(unique>k){\\n                if(freq[nums[j++]]--==1)\\n                   unique--;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return subarraysWithAtMostKDistinct(nums,k)-subarraysWithAtMostKDistinct(nums,k-1);\\n    }\\n\\nprivate:\\n    int subarraysWithAtMostKDistinct(vector<int> &nums,int k){\\n        vector<int> freq(nums.size()+1); //1 <= nums[i] <= nums.size()\\n\\n        int j=0, count=0, unique=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(freq[nums[i]]++==0)\\n               unique++;\\n\\n            while(unique>k){\\n                if(freq[nums[j++]]--==1)\\n                   unique--;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872558,
                "title": "easy-way-in-cpp-subarrays-with-k-different-integers",
                "content": "\\nclass Solution {\\npublic:\\n\\n  int atMostK(vector<int>arr, int n, int k)\\n{\\n    int i = 0,j=0,count=0;\\n     unordered_map<int,int>mp;\\n        while (j<n) {\\n \\n        if (mp.find(arr[j])==mp.end())\\n            mp[arr[j]]=0;\\n        mp[arr[j]]++;\\n\\n        while (mp.size() > k) {\\n            mp[arr[i]]--;\\n            if (mp[arr[i]] == 0)\\n                mp.erase(arr[i]);\\n        i++;\\n        }\\n        count += j - i+ 1;\\n        j++;\\n    }\\n    return count;\\n}\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n    int n=nums.size();\\n  return (atMostK(nums, n, k) - atMostK(nums, n, k - 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n  int atMostK(vector<int>arr, int n, int k)\\n{\\n    int i = 0,j=0,count=0;\\n     unordered_map<int,int>mp;\\n        while (j<n) {\\n \\n        if (mp.find(arr[j])==mp.end())\\n            mp[arr[j]]=0;\\n        mp[arr[j]]++;\\n\\n        while (mp.size() > k) {\\n            mp[arr[i]]--;\\n            if (mp[arr[i]] == 0)\\n                mp.erase(arr[i]);\\n        i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2870573,
                "title": "java-common-format-for-such-questions-explained",
                "content": "```\\nclass Solution {\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        // common format to get the subarrays or substrings with a constant k\\n        return atMost(nums,k) - atMost(nums, k-1);\\n    }\\n    \\n    public int atMost(int []nums, int k)\\n    {\\n        int i=0;\\n        int j=0;\\n        int [] count = new int[nums.length+1];\\n        int unique =0;\\n        int res=0;\\n        while(j<nums.length)\\n        {\\n            // we note the unique elements \\n            if(count[nums[j]] ==0)\\n                unique++;\\n            \\n            count[nums[j]]++;\\n            // while unique becomes more then reduce it \\n            while(unique>k)\\n            {\\n                count[nums[i]]--;\\n                if(count[nums[i]]==0)\\n                    unique--;\\n                i++;\\n            }\\n            // get the all subarrays between j and i \\n            // dont worry about the repeatition of subarrays as we have to eventually subtract\\n            res = res +j-i+1;\\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        // common format to get the subarrays or substrings with a constant k\\n        return atMost(nums,k) - atMost(nums, k-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2822742,
                "title": "most-concise-code-ever-java-solution-inspired-by-lee",
                "content": "Inspired by @lee215\\nWe can calculate \\nall subarrays with having distinct number `<=k` `-`  all subarrays having distinct number `<k` ;\\n```\\n public int subarraysWithKDistinct(int[] nums, int k) {\\n       return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n    private static int atMost(int[] arr,int k){\\n        int res = 0 , count = 0 , j = 0 ;\\n        Map<Integer,Integer> hm = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\\n            while(hm.size()>k){\\n                if(hm.get(arr[j])==1) hm.remove(arr[j++]);\\n                else hm.put(arr[j],hm.get(arr[j++])-1);\\n            }\\n            res+=i-j+1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int subarraysWithKDistinct(int[] nums, int k) {\\n       return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n    private static int atMost(int[] arr,int k){\\n        int res = 0 , count = 0 , j = 0 ;\\n        Map<Integer,Integer> hm = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\\n            while(hm.size()>k){\\n                if(hm.get(arr[j])==1) hm.remove(arr[j++]);\\n                else hm.put(arr[j],hm.get(arr[j++])-1);\\n            }\\n            res+=i-j+1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809399,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(vector<int>& A, int K) {\\n        int i = 0, res = 0;\\n        unordered_map<int, int> count;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!count[A[j]]++) K--;\\n            while (K < 0) {\\n                if (!--count[A[i]]) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(vector<int>& A, int K) {\\n        int i = 0, res = 0;\\n        unordered_map<int, int> count;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!count[A[j]]++) K--;\\n            while (K < 0) {\\n                if (!--count[A[i]]) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674032,
                "title": "dynamic-programming-and-sliding-window-c-solution",
                "content": "### Motivation\\nThis solution is more efficient than the usual one, which computes the number of subarrays with at most k and at most k - 1 distinct elements (you can check it [here](https://leetcode.com/problems/subarrays-with-k-different-integers/solutions/523136/java-c-python-sliding-window/)).\\nThis is because the other solution does the sliding window twice, thus having at most 4\\\\*n steps. On the other hand, this solution\\'s worst case is 2*n steps.\\n\\n### Complexity\\n- Time complexity: O(n) (2*n steps performed in total in the worst case)\\n- Space complexity: O(1)\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n        Dynamic Programming + Sliding Window\\n        - O(n) time complexity\\n        - O(1) extra-space complexity\\n    */\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        std::unordered_map<int, int> currentNos;\\n        int start = 0, before = 1, currentCnt = 0, result = 0;\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (!currentNos[nums[i]]) {\\n                currentCnt++;\\n            }\\n\\n            currentNos[nums[i]]++;\\n            if (currentCnt > k) {\\n                before = 1;\\n                currentCnt--;\\n\\n                while (true) {\\n                    currentNos[nums[start]]--;\\n                    start++;\\n\\n                    if (!currentNos[nums[start - 1]]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (currentCnt == k) {\\n                while (currentNos[nums[start]] > 1) {\\n                    currentNos[nums[start]]--;\\n                    start++;\\n                    before++;\\n                }\\n\\n                result += before;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        Dynamic Programming + Sliding Window\\n        - O(n) time complexity\\n        - O(1) extra-space complexity\\n    */\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        std::unordered_map<int, int> currentNos;\\n        int start = 0, before = 1, currentCnt = 0, result = 0;\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (!currentNos[nums[i]]) {\\n                currentCnt++;\\n            }\\n\\n            currentNos[nums[i]]++;\\n            if (currentCnt > k) {\\n                before = 1;\\n                currentCnt--;\\n\\n                while (true) {\\n                    currentNos[nums[start]]--;\\n                    start++;\\n\\n                    if (!currentNos[nums[start - 1]]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (currentCnt == k) {\\n                while (currentNos[nums[start]] > 1) {\\n                    currentNos[nums[start]]--;\\n                    start++;\\n                    before++;\\n                }\\n\\n                result += before;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642201,
                "title": "easiest-explanation",
                "content": "**Prerequisites :-**\\n* How many subarray can be generated if we have a window of size n ending at last element? \\n\\t\\tWe can generate n subarrays.\\n\\t\\tExample -> [a, b, c] -> [b], [b,c], [a,b,c]\\n\\t\\n* If there are two pointers i and j, where i is pointing at the first element of the window and j is pointing at the last element, then what is the size of the window?\\n\\t\\tsize of window would be = j-i+1\\n\\t\\tExampe -> [1, 2, 3, 4] , i =0 , j = 3 -> size = j - i + 1 = 3 - 0 + 1 = 4 \\n\\n*  Number of subarrays with k different integers = Number of subarrays with atmost k different integers - Number of subarrays with atmost k-1 different integers \\n\\t\\tIntitutively you can understand this.\\n\\t\\t\\n```\\n\\tint atMostK(vector<int> &nums, int k){\\n        unordered_map<int, int> mp;\\n        int cnt = 0;\\n        int j = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            mp[nums[i]]++;\\n            while(mp.size()>k){\\n                mp[nums[j]]--;\\n                if(mp[nums[j]]==0) mp.erase(nums[j]);\\n                j++;\\n            }\\n            cnt+=i-j+1;\\n        }\\n        return cnt;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n\\tint atMostK(vector<int> &nums, int k){\\n        unordered_map<int, int> mp;\\n        int cnt = 0;\\n        int j = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            mp[nums[i]]++;\\n            while(mp.size()>k){\\n                mp[nums[j]]--;\\n                if(mp[nums[j]]==0) mp.erase(nums[j]);\\n                j++;\\n            }\\n            cnt+=i-j+1;\\n        }\\n        return cnt;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2611355,
                "title": "c-best-solution-explanation-map-sliding-window",
                "content": "\\uD83D\\uDCCA ***Explanation :***\\nFor \\u21E2 ***return atMost(nums,k)-atMost(nums,k-1);***\\nAccording to the question , we need subarrays with ***Exactly k*** distinct elements.\\nSo , when we carry out function for value k , we get the subarrays with ***atmost k*** distince elements **+** all the subarrays with ***less than k*** distinct elemnts .\\nWe ***subtract*** the subarrays with k-1 elements , which contains , subarrays with ***k-1 elements*** **+** all the subarrays with ***less than k-1 elements.***\\n***Hence*** , we get subarrays with ***exactly k distinct elements.***\\n>***exactly(K) = atMost(K) - atMost(K-1)***\\n\\n***Time Complexity : O(n)\\nSpace Complexity : O(n+n)=O(n)***\\n\\n**UPVOTE IF YOU LIKE** \\uD83D\\uDE0A\\u2705\\uD83D\\uDD11\\n\\n```\\nclass Solution {\\npublic:\\n    int atmostK(vector<int> &nums,int k){\\n        if(k<=0)return 0;\\n        unordered_map<int,int>m;\\n        \\n        int n=nums.size();\\n        int start=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n            while(start<i && m.size()>k){\\n                m[nums[start]]--;\\n                if(m[nums[start]]==0)m.erase(nums[start]);\\n                start++;\\n            }\\n            ans+=i-start+1;\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int atmostK(vector<int> &nums,int k){\\n        if(k<=0)return 0;\\n        unordered_map<int,int>m;\\n        \\n        int n=nums.size();\\n        int start=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n            while(start<i && m.size()>k){\\n                m[nums[start]]--;\\n                if(m[nums[start]]==0)m.erase(nums[start]);\\n                start++;\\n            }\\n            ans+=i-start+1;\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586942,
                "title": "cpp-intuition-comments-easy-understanding",
                "content": "```\\n    // crux of the problem:\\n    // if a problem is too confusing to solve reduce it to smaller problem\\n\\t// The problem is just a higher version of an easy problem\\n\\t// the only hard part here is to deduce that\\n\\t// if we want exactly k distinct elements then it can be wriiten as atmost k distinct elements - atmost (k-1) distinct elements\\n    \\n    int atmostK(vector<int> &nums,int k){\\n        \\n        if(k<=0)return 0;\\n        unordered_map<int,int> A;\\n        \\n        int n=nums.size();\\n        int i=0,j=0;\\n        \\n        int ans=0;\\n        while(j<n){\\n            A[nums[j]]++;\\n            while(A.size()>k){\\n                A[nums[i]]--;\\n                if(A[nums[i]]==0)A.erase(nums[i]);\\n                i++;\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n    // crux of the problem:\\n    // if a problem is too confusing to solve reduce it to smaller problem\\n\\t// The problem is just a higher version of an easy problem\\n\\t// the only hard part here is to deduce that\\n\\t// if we want exactly k distinct elements then it can be wriiten as atmost k distinct elements - atmost (k-1) distinct elements\\n    \\n    int atmostK(vector<int> &nums,int k){\\n        \\n        if(k<=0)return 0;\\n        unordered_map<int,int> A;\\n        \\n        int n=nums.size();\\n        int i=0,j=0;\\n        \\n        int ans=0;\\n        while(j<n){\\n            A[nums[j]]++;\\n            while(A.size()>k){\\n                A[nums[i]]--;\\n                if(A[nums[i]]==0)A.erase(nums[i]);\\n                i++;\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570693,
                "title": "sliding-window-variation-at-most-k-template-based-solution",
                "content": "###  exactly(K) = atMost(K) - atMost(K-1)\\n\\t\\n    int atmost(vector<int>& nums, int k)\\n    {\\n        if(k==0)\\n            return 0;\\n        unordered_map<int,int> mp;\\n        int i=0,j=0,count=0,n=nums.size();\\n        while(j<n)\\n        {\\n            mp[nums[j]]++;\\n                while(mp.size()>k)\\n                {\\n                    mp[nums[i]]--;\\n                      if(mp[nums[i]]==0)\\n                        mp.erase(nums[i]);\\n                      i++;\\n                }\\n            count+=(j-i+1);\\n            j++;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return (atmost(nums,k)-atmost(nums,k-1));\\n    }",
                "solutionTags": [],
                "code": "###  exactly(K) = atMost(K) - atMost(K-1)\\n\\t\\n    int atmost(vector<int>& nums, int k)\\n    {\\n        if(k==0)\\n            return 0;\\n        unordered_map<int,int> mp;\\n        int i=0,j=0,count=0,n=nums.size();\\n        while(j<n)\\n        {\\n            mp[nums[j]]++;\\n                while(mp.size()>k)\\n                {\\n                    mp[nums[i]]--;\\n                      if(mp[nums[i]]==0)\\n                        mp.erase(nums[i]);\\n                      i++;\\n                }\\n            count+=(j-i+1);\\n            j++;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return (atmost(nums,k)-atmost(nums,k-1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2568548,
                "title": "c-easy-understanding-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int atMost(vector<int>& nums, int goal)\\n    {\\n        unordered_map<int,int>mp;\\n        int window_start=0, window_end=0, ans=0,count=0;\\n        if (goal < 0)\\n            return 0;\\n        for(window_end=0; window_end<nums.size() ;window_end++)\\n        {\\n            mp[nums[window_end]]++;\\n            while(mp.size()>goal)\\n            {\\n                mp[nums[window_start]]--;\\n                if(mp[nums[window_start]]==0)\\n                    mp.erase(nums[window_start]);\\n                window_start++;\\n            }\\n            ans+=window_end-window_start+1;\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n};\\n```\\nNote:- window_end-window_start+1 gives number of subarrays in a window.\\nTime O(N) for two passes.\\nSpace O(K) at most K elements in the mp\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int atMost(vector<int>& nums, int goal)\\n    {\\n        unordered_map<int,int>mp;\\n        int window_start=0, window_end=0, ans=0,count=0;\\n        if (goal < 0)\\n            return 0;\\n        for(window_end=0; window_end<nums.size() ;window_end++)\\n        {\\n            mp[nums[window_end]]++;\\n            while(mp.size()>goal)\\n            {\\n                mp[nums[window_start]]--;\\n                if(mp[nums[window_start]]==0)\\n                    mp.erase(nums[window_start]);\\n                window_start++;\\n            }\\n            ans+=window_end-window_start+1;\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253375,
                "title": "python-sliding-window",
                "content": "We\\'ll maintain a sliding window such that we advance the right pointer on each iteration to point to the current element. \\n\\nIt\\'s then our aim to calculate the number of subarrays with K distinct elements ENDING on the right pointer\\'s element.\\n\\nTherefore at each iteration we end up with three cases:\\n- **(1)** Our window has less than K distinct elements - we don\\'t do anything and continue iteration, maybe enlarging our window next iteration will get us there\\n- **(2)** Our window has exactly K distinct elements - we need to find the maximum left pointer such that up to the end of the window, we still have K distinct elements. Then we add the distance from the `bound` to that left pointer, where the `bound` is the farthest left you can go without introducing more distinct elements.\\n- **(3)** Our window has more than K distinct elements - constrict your window by advancing the left pointer, until you end up with exactly K distinct elements. At this point you can update your `bound` as well (again to mark the farthest left your current set of distinct elements can extend).\\n\\nAs dealing with **(3)** leads directly to **(2)**, I combined those cases together into one block in my code.\\n\\nThe `Counter` data structure helps us maintain a window\\'s distinct element count (by just accessing the size of its key set). We delete entries once the count of an element hits 0.\\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = bound = l = 0\\n        window = Counter()\\n        \\n        for num in nums:\\n            window[num] += 1\\n            \\n            if len(window) >= k:\\n                while len(window) > k:\\n                    window[nums[l]] -= 1\\n                    if window[nums[l]] == 0:\\n                        del window[nums[l]]\\n                    l += 1\\n                    bound = l\\n         \\n                while window[nums[l]] - 1 > 0:\\n                    window[nums[l]] -= 1\\n                    l += 1\\n                \\n                ans += (l - bound + 1)\\n        \\n        return ans\\n```\\n\\nTime/space: `O(n)`",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = bound = l = 0\\n        window = Counter()\\n        \\n        for num in nums:\\n            window[num] += 1\\n            \\n            if len(window) >= k:\\n                while len(window) > k:\\n                    window[nums[l]] -= 1\\n                    if window[nums[l]] == 0:\\n                        del window[nums[l]]\\n                    l += 1\\n                    bound = l\\n         \\n                while window[nums[l]] - 1 > 0:\\n                    window[nums[l]] -= 1\\n                    l += 1\\n                \\n                ans += (l - bound + 1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184647,
                "title": "c-sliding-window-map",
                "content": "Upvote if it helps :)\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // atmost k -  atmost k-1 = only k characters \\n        return fun(nums,k)-fun(nums,k-1);\\n    }\\n    int fun(vector<int>& nums, int k) // atmost k diff character\\n    {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n            while(m.size()>k)\\n            {\\n                m[nums[j]]--;\\n                if(m[nums[j]]==0)\\n                    m.erase(nums[j]);\\n                j++;\\n            }\\n            res+=i-j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // atmost k -  atmost k-1 = only k characters \\n        return fun(nums,k)-fun(nums,k-1);\\n    }\\n    int fun(vector<int>& nums, int k) // atmost k diff character\\n    {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n            while(m.size()>k)\\n            {\\n                m[nums[j]]--;\\n                if(m[nums[j]]==0)\\n                    m.erase(nums[j]);\\n                j++;\\n            }\\n            res+=i-j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126160,
                "title": "easy-cpp-solution-sliding-window",
                "content": "So the logic is to find all subarray count for atmost k distinct characters and all subarray count for atmost k-1 distinct characters, if you find the difference of the two you will get the subarray count for exactly k distinct characters. \\n ```\\nclass Solution {\\npublic:\\n    int subarrayCountWithAtMostKchar(vector<int>& arr, int k) \\n    {\\n        int i=0,j=0,count=0;\\n        unordered_map<int,int> mp;\\n        while(j<arr.size())\\n        {\\n            mp[arr[j]]++;\\n            if(mp.size()<=k)\\n            {\\n                count+=j-i+1;\\n                j++;\\n            }\\n            else \\n            {\\n                while(mp.size()>k)\\n                {\\n                    mp[arr[i]]--;\\n                    if(mp[arr[i]]==0)\\n                    {\\n                        mp.erase(arr[i]);\\n                    }\\n                    i++;\\n                }\\n                if(mp.size()<=k)\\n                {\\n                    count+=j-i+1;\\n                }\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        int a=subarrayCountWithAtMostKchar(nums,k);\\n        int b=subarrayCountWithAtMostKchar(nums,k-1);\\n        return a-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayCountWithAtMostKchar(vector<int>& arr, int k) \\n    {\\n        int i=0,j=0,count=0;\\n        unordered_map<int,int> mp;\\n        while(j<arr.size())\\n        {\\n            mp[arr[j]]++;\\n            if(mp.size()<=k)\\n            {\\n                count+=j-i+1;\\n                j++;\\n            }\\n            else \\n            {\\n                while(mp.size()>k)\\n                {\\n                    mp[arr[i]]--;\\n                    if(mp[arr[i]]==0)\\n                    {\\n                        mp.erase(arr[i]);\\n                    }\\n                    i++;\\n                }\\n                if(mp.size()<=k)\\n                {\\n                    count+=j-i+1;\\n                }\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        int a=subarrayCountWithAtMostKchar(nums,k);\\n        int b=subarrayCountWithAtMostKchar(nums,k-1);\\n        return a-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073009,
                "title": "c-sliding-window-variation-of-longest-subarray-with-atmost-k-different-elements",
                "content": "Simple Variation of Longest Subarray (or substring) with Atmost k Distinct Elements:\\n\\n\\nFormula: \\nExactly(k distinct) = Atmost(k distinct) - Atmost(k-1 distinct);\\n\\n\\nIntution:\\nFor example let us consider k as 5 at most 5 distinct will include all posibilities such as sub arrays with 1 distinct element until 5 distince elements. Similarly at most 4 will include all possibilities sub arrays with 1 distinct element  to 4 distinct elements. \\n\\nIf we subtract both we will remain with all possibilities which contain 5 different elements.\\n\\n\\n\\n    int solve_at_most(vector<int> nums, int k){\\n        int n = nums.size();\\n        int res = 0;\\n        int i=0,j=0;\\n        unordered_map<int,int> mp;\\n        \\n        while(j < n){\\n            mp[nums[j]]++;\\n            \\n            while(mp.size() > k){\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                    mp.erase(nums[i]);\\n                i++;\\n            }\\n            res += j-i+1;\\n            j++;\\n        }\\n        return res;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int res = solve_at_most(nums,k) - solve_at_most(nums,k-1);\\n        return res;\\n    }\\n\\n\\nReference:\\nThe problem Longest Increasing Subsequence with Atmost K distinct charecters can be found in PepCoding\\'s youtube channel",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "Simple Variation of Longest Subarray (or substring) with Atmost k Distinct Elements:\\n\\n\\nFormula: \\nExactly(k distinct) = Atmost(k distinct) - Atmost(k-1 distinct);\\n\\n\\nIntution:\\nFor example let us consider k as 5 at most 5 distinct will include all posibilities such as sub arrays with 1 distinct element until 5 distince elements. Similarly at most 4 will include all possibilities sub arrays with 1 distinct element  to 4 distinct elements. \\n\\nIf we subtract both we will remain with all possibilities which contain 5 different elements.\\n\\n\\n\\n    int solve_at_most(vector<int> nums, int k){\\n        int n = nums.size();\\n        int res = 0;\\n        int i=0,j=0;\\n        unordered_map<int,int> mp;\\n        \\n        while(j < n){\\n            mp[nums[j]]++;\\n            \\n            while(mp.size() > k){\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                    mp.erase(nums[i]);\\n                i++;\\n            }\\n            res += j-i+1;\\n            j++;\\n        }\\n        return res;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int res = solve_at_most(nums,k) - solve_at_most(nums,k-1);\\n        return res;\\n    }\\n\\n\\nReference:\\nThe problem Longest Increasing Subsequence with Atmost K distinct charecters can be found in PepCoding\\'s youtube channel",
                "codeTag": "Unknown"
            },
            {
                "id": 1819753,
                "title": "c-sliding-window-992-subarrays-with-k-different-integers",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(vector<int>& nums, int k){\\n        unordered_map<int,int>m;\\n        int i=0, c=0;\\n        for(int j=0;j<nums.size();j++){\\n            m[nums[j]]++;\\n            while(m.size()>k){\\n                m[nums[i]]--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            c+=(j-i+1);\\n        }\\n        return c;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // count of subarrays with <=K distant\\n        // -\\n        // count of subarrays with <=K-1 (<K) distant\\n        return count(nums,k)-count(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(vector<int>& nums, int k){\\n        unordered_map<int,int>m;\\n        int i=0, c=0;\\n        for(int j=0;j<nums.size();j++){\\n            m[nums[j]]++;\\n            while(m.size()>k){\\n                m[nums[i]]--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            c+=(j-i+1);\\n        }\\n        return c;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // count of subarrays with <=K distant\\n        // -\\n        // count of subarrays with <=K-1 (<K) distant\\n        return count(nums,k)-count(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774003,
                "title": "python-verbose",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Appraoch: One way to solve for distinct element is to keep a set \\n        Alternate approach is to find all possibilites of at most K distinct subarrays and all possibilitites of at most K - 1 distinct subarrays and take their difference \\n        \\n        Since we are interested only in the count and not the actual numbers the latter appraoch seems a wiser choise\\n        \\n        \"\"\"\\n        def atmostK(s,k):\\n            # Initialize to defaultdict(int)\\n            d = Counter()\\n            \\n            # left end pointer\\n            l = 0\\n            \\n            # Counter to count ans\\n            ans = 0\\n            \\n            for r,i in enumerate(s):\\n                # check if the number is a new entry\\n                if d[i] == 0:\\n                    # if yes reduce k \\n                    k-=1\\n                    \\n                # Add to the dict\\n                d[i] +=1\\n                \\n                # To remove element until k distinct\\n                while k < 0:\\n                    d[s[l]]-=1\\n                    if d[s[l]] == 0:\\n                        k+=1\\n                    l+=1\\n\\n                # Total number of subarrays when a new element is added is equal to the length of the new array \\n                # ex [1,2,3] + [4]\\n                # Total number of subarrays = [1,2,3,4],[2,3,4],[3,4],[4]\\n                # which is equal to the length\\n                ans += r - l + 1\\n\\n            return ans\\n        return atmostK(nums,k) - atmostK(nums,k-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Appraoch: One way to solve for distinct element is to keep a set \\n        Alternate approach is to find all possibilites of at most K distinct subarrays and all possibilitites of at most K - 1 distinct subarrays and take their difference \\n        \\n        Since we are interested only in the count and not the actual numbers the latter appraoch seems a wiser choise\\n        \\n        \"\"\"\\n        def atmostK(s,k):\\n            # Initialize to defaultdict(int)\\n            d = Counter()\\n            \\n            # left end pointer\\n            l = 0\\n            \\n            # Counter to count ans\\n            ans = 0\\n            \\n            for r,i in enumerate(s):\\n                # check if the number is a new entry\\n                if d[i] == 0:\\n                    # if yes reduce k \\n                    k-=1\\n                    \\n                # Add to the dict\\n                d[i] +=1\\n                \\n                # To remove element until k distinct\\n                while k < 0:\\n                    d[s[l]]-=1\\n                    if d[s[l]] == 0:\\n                        k+=1\\n                    l+=1\\n\\n                # Total number of subarrays when a new element is added is equal to the length of the new array \\n                # ex [1,2,3] + [4]\\n                # Total number of subarrays = [1,2,3,4],[2,3,4],[3,4],[4]\\n                # which is equal to the length\\n                ans += r - l + 1\\n\\n            return ans\\n        return atmostK(nums,k) - atmostK(nums,k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764686,
                "title": "exact-k-atmost-k-atmost-k-1",
                "content": "<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    int atMostK(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int left = 0, right = 0, ans = 0;\\n        \\n        while(right < nums.size()) {\\n            mp[nums[right]]++;\\n            while(mp.size() > k) {\\n                if(--mp[nums[left]] == 0) mp.erase(nums[left]);\\n                left++;\\n            }\\n            ans += (right - left + 1);\\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n};\\n```\\n<br/>\\n\\nTime Complexity: **O(N)**\\nSpace Complexity: **O(N)**\\n\\n<br/>",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int atMostK(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int left = 0, right = 0, ans = 0;\\n        \\n        while(right < nums.size()) {\\n            mp[nums[right]]++;\\n            while(mp.size() > k) {\\n                if(--mp[nums[left]] == 0) mp.erase(nums[left]);\\n                left++;\\n            }\\n            ans += (right - left + 1);\\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656234,
                "title": "python-solution-with-explaination",
                "content": "The idea is:\\n1. we maintain two pointers `left, right` which point to the start and end of the shortest good array ends on `right`.\\n2. we maintain the number of good arrays ends on `right`.\\n3. On `right+1`, there\\'s two situation:\\n\\t3.1. By appending the element to the shortest good array ends on `right`, it is still good. This means we can safely extend all good arrays ends on `right` with the element on `right+1`. \\n\\t3.2 By appending the element to the shortest good array ends on `right`, it is not good. We don\\'t extend any of the previous in this case.\\n4. Now we\\'ve handled all cases by exntedning previous good arrays, we then keep moving `left` to get the new shortest good array. In this process, any arrays encountered are always good.\\n\\nIn the worst case, we process every element two times, thus the worst time complexity is O(n) where n is the number of elements.\\n\\nBelow is the code:\\n```python\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ret = 0\\n        prev_good = 0\\n        counter = dict()\\n        left, right = 0, 0\\n        \\n        # keep moving right\\n        for right in range(len(nums)):\\n            counter[nums[right]] = counter.setdefault(nums[right], 0) + 1\\n            \\n            # now we have k distinct\\n            if len(counter.keys()) == k:        \\n                # the first time we meet k distinct\\n                if prev_good == 0:\\n                    prev_good = 1\\n                    \\n                # we can move left to find the shortest good to get new good\\n                while counter[nums[left]] > 1:\\n                    counter[nums[left]] -= 1\\n                    left += 1\\n                    prev_good += 1\\n            # now we have more than k distinct\\n            elif len(counter.keys()) > k:\\n                # we remove the first of previous shortest good and appending the right\\n                # to get a new good\\n                prev_good = 1\\n                counter.pop(nums[left])\\n                left += 1\\n            \\n                # we can move left to reach the shortest good to get new good\\n                while counter[nums[left]] > 1:\\n                    counter[nums[left]] -= 1\\n                    left += 1\\n                    prev_good += 1\\n            ret += prev_good\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ret = 0\\n        prev_good = 0\\n        counter = dict()\\n        left, right = 0, 0\\n        \\n        # keep moving right\\n        for right in range(len(nums)):\\n            counter[nums[right]] = counter.setdefault(nums[right], 0) + 1\\n            \\n            # now we have k distinct\\n            if len(counter.keys()) == k:        \\n                # the first time we meet k distinct\\n                if prev_good == 0:\\n                    prev_good = 1\\n                    \\n                # we can move left to find the shortest good to get new good\\n                while counter[nums[left]] > 1:\\n                    counter[nums[left]] -= 1\\n                    left += 1\\n                    prev_good += 1\\n            # now we have more than k distinct\\n            elif len(counter.keys()) > k:\\n                # we remove the first of previous shortest good and appending the right\\n                # to get a new good\\n                prev_good = 1\\n                counter.pop(nums[left])\\n                left += 1\\n            \\n                # we can move left to reach the shortest good to get new good\\n                while counter[nums[left]] > 1:\\n                    counter[nums[left]] -= 1\\n                    left += 1\\n                    prev_good += 1\\n            ret += prev_good\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568903,
                "title": "c-sliding-window-with-3-pointers",
                "content": "1. I used two pointers `l` and `r` to maintain the **largest** window which has exact `k` different numbers ended at `r`.\\n2. A third pointer `p` is inbetween `l` and `r`. `p` is squeezed from `l` towards `r` and stops at the **smallest** window with  `k` distinct elements ened at `r`.\\n3. The counting process is at each step at `r`, counts the number of the subarrays ends at `r` and this is `p-l+1`\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nSee the following example, nums = [1,2,1,2,3,3,4,5] and k = 5\\nthe last column is the number of the subarrays which has exact `k` different numbers. The final result is the sum over the results in the last column for each row.\\n![image](https://assets.leetcode.com/users/images/97625ce2-31fa-4c55-93e4-7a336bbd2c51_1636490645.8440108.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        unordered_map<int,int> freq_in;\\n        int l =0, r=0, p = 0;\\n        int n = nums.size();\\n        int sum = 0;\\n        int counts = 0;\\n        while(r<n){\\n            freq[nums[r]]++;\\n            freq_in[nums[r]]++;\\n            if(freq[nums[r]]==1){\\n                counts++;\\n            }\\n            while(counts>k){\\n                freq[nums[l]]--;\\n                freq_in[nums[l]]=freq[nums[l]];\\n                if(freq[nums[l]]==0){\\n                    counts--;\\n                }\\n                l++;\\n                p=l;\\n            } \\n            if(counts==k){\\n                while(freq_in[nums[p]]!=1){\\n                    freq_in[nums[p]]--;\\n                    p++;\\n                }      \\n                sum += (p-l+1);\\n            }\\n            r++;\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        unordered_map<int,int> freq_in;\\n        int l =0, r=0, p = 0;\\n        int n = nums.size();\\n        int sum = 0;\\n        int counts = 0;\\n        while(r<n){\\n            freq[nums[r]]++;\\n            freq_in[nums[r]]++;\\n            if(freq[nums[r]]==1){\\n                counts++;\\n            }\\n            while(counts>k){\\n                freq[nums[l]]--;\\n                freq_in[nums[l]]=freq[nums[l]];\\n                if(freq[nums[l]]==0){\\n                    counts--;\\n                }\\n                l++;\\n                p=l;\\n            } \\n            if(counts==k){\\n                while(freq_in[nums[p]]!=1){\\n                    freq_in[nums[p]]--;\\n                    p++;\\n                }      \\n                sum += (p-l+1);\\n            }\\n            r++;\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521009,
                "title": "java-sliding-window",
                "content": "\\n\\n\\tclass Solution {\\n\\t\\n\\t\\t// Function to return the count of subarrays\\n\\t\\t// with at most K distinct elements using\\n\\t\\t// the sliding window technique\\n\\t\\tprivate static int atMostK(int arr[], int k) {\\n\\t \\n\\t\\t\\t// To store the result\\n\\t\\t\\tint count = 0;\\n\\t \\n\\t\\t\\t// Left boundary of window\\n\\t\\t\\tint left = 0;\\n\\t \\n\\t\\t\\t// Map to keep track of number of distinct\\n\\t\\t\\t// elements in the current window\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t \\n\\t\\t\\t// Loop to calculate the count\\n\\t\\t\\tfor(int right =0; right < arr.length; right++){\\n\\t \\n\\t\\t\\t\\t// Calculating the frequency of each\\n\\t\\t\\t\\t// element in the current window\\n\\t\\t\\t\\tmap.put(arr[right], map.getOrDefault(arr[right], 0) + 1);\\n\\t \\n\\t\\t\\t\\t// Shrinking the window from left if the\\n\\t\\t\\t\\t// count of distinct elements exceeds K\\n\\t\\t\\t\\twhile (map.size() > k) {\\n\\t\\t\\t\\t\\tmap.put(arr[left], map.get(arr[left]) - 1);\\n\\t\\t\\t\\t\\tif (map.get(arr[left]) == 0) map.remove(arr[left]);\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t \\n\\t\\t\\t\\t// Adding the count of subarrays with at most\\n\\t\\t\\t\\t// K distinct elements in the current window\\n\\t\\t\\t\\tcount += right - left + 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t \\n\\t\\t// Function to return the count of subarrays\\n\\t\\t// with exactly K distinct elements\\n\\t\\tprivate static int exactlyK(int arr[], int k) {\\n\\t \\n\\t\\t\\t// Count of subarrays with exactly k distinct\\n\\t\\t\\t// elements is equal to the difference of the\\n\\t\\t\\t// count of subarrays with at most K distinct\\n\\t\\t\\t// elements and the count of subararys with\\n\\t\\t\\t// at most (K - 1) distinct elements\\n\\t\\t\\treturn (atMostK(arr, k) - atMostK(arr, k - 1));\\n\\t\\t}\\n\\t\\t\\n\\t\\tstatic int subarraysWithKDistinct(int arr[], int k) {\\n\\t\\t\\treturn exactlyK(arr, k);\\n\\t\\t}\\n\\t\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\n\\t\\t// Function to return the count of subarrays\\n\\t\\t// with at most K distinct elements using\\n\\t\\t// the sliding window technique\\n\\t\\tprivate static int atMostK(int arr[], int k) {\\n\\t \\n\\t\\t\\t// To store the result\\n\\t\\t\\tint count = 0;\\n\\t \\n\\t\\t\\t// Left boundary of window\\n\\t\\t\\tint left = 0;\\n\\t \\n\\t\\t\\t// Map to keep track of number of distinct\\n\\t\\t\\t// elements in the current window\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t \\n\\t\\t\\t// Loop to calculate the count\\n\\t\\t\\tfor(int right =0; right < arr.length; right++){\\n\\t \\n\\t\\t\\t\\t// Calculating the frequency of each\\n\\t\\t\\t\\t// element in the current window\\n\\t\\t\\t\\tmap.put(arr[right], map.getOrDefault(arr[right], 0) + 1);\\n\\t \\n\\t\\t\\t\\t// Shrinking the window from left if the\\n\\t\\t\\t\\t// count of distinct elements exceeds K\\n\\t\\t\\t\\twhile (map.size() > k) {\\n\\t\\t\\t\\t\\tmap.put(arr[left], map.get(arr[left]) - 1);\\n\\t\\t\\t\\t\\tif (map.get(arr[left]) == 0) map.remove(arr[left]);\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1418048,
                "title": "brute-force-approach-tle-tell-this-to-the-interviewer-at-first",
                "content": "TC: Approx O(n^2)\\n```\\n public int subarraysWithKDistinct(int[] arr, int k) {\\n        \\n        // 55 / 55 test cases passed, but took too long.\\n\\t\\t\\n        int cogs=0; //count of good subarrays\\n        int count = 0, n = arr.length, si = 0, ei = 0;\\n        int[] freq = new int[20000 + 1];\\n        \\n        \\n        while (ei<n) {\\n            if (ei<n && freq[arr[ei++]]++ == 0) count++;\\n            \\n            if(count==k) cogs++;\\n            \\n            if (count > k || ei==n) {\\n                si++;\\n                ei=si;\\n                count = 0;\\n                freq = new int[20000 + 1];\\n            }\\n            \\n        }\\n\\n        return cogs;\\n        \\n    }\\n```\\n\\nAnyone know other working solution than the atMost(k)-atMost(k-1) solution?....(well this was O(n))",
                "solutionTags": [],
                "code": "```\\n public int subarraysWithKDistinct(int[] arr, int k) {\\n        \\n        // 55 / 55 test cases passed, but took too long.\\n\\t\\t\\n        int cogs=0; //count of good subarrays\\n        int count = 0, n = arr.length, si = 0, ei = 0;\\n        int[] freq = new int[20000 + 1];\\n        \\n        \\n        while (ei<n) {\\n            if (ei<n && freq[arr[ei++]]++ == 0) count++;\\n            \\n            if(count==k) cogs++;\\n            \\n            if (count > k || ei==n) {\\n                si++;\\n                ei=si;\\n                count = 0;\\n                freq = new int[20000 + 1];\\n            }\\n            \\n        }\\n\\n        return cogs;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398951,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int atMostKDistict(vector<int> &ar, int n, int k) {\\n        \\n        unordered_map<int, int> mp;\\n        int j = 0, ans = 0;\\n        for(int i=0; i<n; i++) {\\n            \\n            mp[ar[i]]++;\\n            while(mp.size() > k) {\\n                if(mp[ar[j]] > 1) {\\n                    mp[ar[j]]--;\\n                } else {\\n                    mp.erase(ar[j]);\\n                }\\n                \\n                j++;\\n            }\\n            \\n            ans += (i-j+1);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        return atMostKDistict(nums, n, k) - atMostKDistict(nums, n, k-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int atMostKDistict(vector<int> &ar, int n, int k) {\\n        \\n        unordered_map<int, int> mp;\\n        int j = 0, ans = 0;\\n        for(int i=0; i<n; i++) {\\n            \\n            mp[ar[i]]++;\\n            while(mp.size() > k) {\\n                if(mp[ar[j]] > 1) {\\n                    mp[ar[j]]--;\\n                } else {\\n                    mp.erase(ar[j]);\\n                }\\n                \\n                j++;\\n            }\\n            \\n            ans += (i-j+1);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        return atMostKDistict(nums, n, k) - atMostKDistict(nums, n, k-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365933,
                "title": "c-sliding-window-full-explanation",
                "content": "// Explanation: for test case : [1,2,1,3,4], k = 3\\n// Subarray with atmost k diff integer ->\\n// [1],[1,2],[1,2,1],[1,2,1,3],[2],[2,1],[2,1,3]\\n// [1],[1,3],[1,3,4]\\n// [3],[3,4]\\n// [4]\\n// Subarray with atmost k-1 diff integer ->\\n// [1],[1,2],[1,2,1],[2],[2,1],[1],[1,3],[3],[3,4],[4]\\n\\n// x-> no of subarray with atmost k\\n// y-> no of subarray with atmost k-1\\n// if we do (x-y) we will be left with exactly k diff integers\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int k) {\\n        int i,j;\\n        i = j = 0;\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        while(i<=j && j<nums.size()) {\\n            mp[nums[j]]++;\\n            while(mp.size()>k) {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0) {\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n            ans += (j-i);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return solve(nums,k) - solve(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int k) {\\n        int i,j;\\n        i = j = 0;\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        while(i<=j && j<nums.size()) {\\n            mp[nums[j]]++;\\n            while(mp.size()>k) {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0) {\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n            ans += (j-i);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return solve(nums,k) - solve(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191772,
                "title": "c-95-sliding-window",
                "content": "```\\npublic class Solution {\\n    public int SubarraysWithKDistinct(int[] A, int K) {\\n        \\n        var map = new int[A.Length + 1]; //gotcha\\n        var count = 0;\\n        var start = 0;\\n        var end = 0;\\n        var prefix = 0;\\n        var result = 0;\\n        \\n        while(end < A.Length)\\n        {\\n            if(map[A[end++]]++ == 0)\\n                count++;\\n            \\n            if(count > K)\\n            {\\n                map[A[start++]]--;\\n                count--;\\n                prefix = 0;\\n            }\\n            while(map[A[start]] > 1) //gotcha\\n            {\\n                prefix++;\\n                map[A[start++]]--;\\n            }\\n            \\n            if(count == K)\\n            {\\n                result += prefix + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SubarraysWithKDistinct(int[] A, int K) {\\n        \\n        var map = new int[A.Length + 1]; //gotcha\\n        var count = 0;\\n        var start = 0;\\n        var end = 0;\\n        var prefix = 0;\\n        var result = 0;\\n        \\n        while(end < A.Length)\\n        {\\n            if(map[A[end++]]++ == 0)\\n                count++;\\n            \\n            if(count > K)\\n            {\\n                map[A[start++]]--;\\n                count--;\\n                prefix = 0;\\n            }\\n            while(map[A[start]] > 1) //gotcha\\n            {\\n                prefix++;\\n                map[A[start++]]--;\\n            }\\n            \\n            if(count == K)\\n            {\\n                result += prefix + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167138,
                "title": "javascript-beat-97-96-time-100-space",
                "content": "Javascript solution, for detailed explaination, please refer to the following\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C%2B%2BJava-with-picture-prefixed-sliding-window\\n\\n````\\nvar subarraysWithKDistinct = function (A, K) {\\n    if (A == null || A.length == 0 || K == 0 || A.length < K) {\\n        return 0;\\n    }\\n    let count = Array(A.length + 1).fill(0);\\n    let l = 0, acc = 0, res = 0;\\n    for (let r = 0; r < A.length; r++) {\\n        if (count[A[r]]++ == 0) {\\n            K--;\\n        }\\n        if (K < 0) {\\n            count[A[l++]]--;\\n            K++;\\n            acc = 0;\\n        }\\n        if (K == 0) {\\n            while (count[A[l]] > 1) {\\n                count[A[l++]]--;\\n                acc++;\\n            }\\n            res += acc + 1;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "````\\nvar subarraysWithKDistinct = function (A, K) {\\n    if (A == null || A.length == 0 || K == 0 || A.length < K) {\\n        return 0;\\n    }\\n    let count = Array(A.length + 1).fill(0);\\n    let l = 0, acc = 0, res = 0;\\n    for (let r = 0; r < A.length; r++) {\\n        if (count[A[r]]++ == 0) {\\n            K--;\\n        }\\n        if (K < 0) {\\n            count[A[l++]]--;\\n            K++;\\n            acc = 0;\\n        }\\n        if (K == 0) {\\n            while (count[A[l]] > 1) {\\n                count[A[l++]]--;\\n                acc++;\\n            }\\n            res += acc + 1;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135205,
                "title": "java-human-readable-solution-2-mins-to-understand-it",
                "content": "if you stuck with other solutions with a lot a time, read this one instead.\\n\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        // brainstorm: subarrays with at most K distinct values contains two parts: \\n\\t\\t// subarrays with exactly K distinct values + subarrays with at most K - 1 distinct values\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n\\n    private int atMostK(int[] A, int k) {\\n        // use a map to control what we\\'ve seen before, map.size() compared to k during the process.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int start = 0;\\n        int end = 0;\\n        int res = 0;\\n        while (end < A.length) {\\n            // put it into map anyway\\n            map.put(A[end], map.getOrDefault(A[end], 0) + 1);\\n            \\n            // if map size is larger then k, must reduce it to exactly k by moving start and deleting the count in map\\n            while (map.size() > k) {\\n                map.put(A[start], map.getOrDefault(A[start], 0) - 1);\\n                if (map.get(A[start]) == 0) map.remove(A[start]);\\n                start++;\\n            }\\n            res += end - start + 1; // brainstorm: when you get a range that satisfy at most k distinct values, \\n\\t\\t\\t                                      // how many subarrays are there ending with this \"end\" pointer? exactly end - start + 1\\n            end++; // move end one by one\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "if you stuck with other solutions with a lot a time, read this one instead.\\n\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        // brainstorm: subarrays with at most K distinct values contains two parts: \\n\\t\\t// subarrays with exactly K distinct values + subarrays with at most K - 1 distinct values\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n\\n    private int atMostK(int[] A, int k) {\\n        // use a map to control what we\\'ve seen before, map.size() compared to k during the process.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int start = 0;\\n        int end = 0;\\n        int res = 0;\\n        while (end < A.length) {\\n            // put it into map anyway\\n            map.put(A[end], map.getOrDefault(A[end], 0) + 1);\\n            \\n            // if map size is larger then k, must reduce it to exactly k by moving start and deleting the count in map\\n            while (map.size() > k) {\\n                map.put(A[start], map.getOrDefault(A[start], 0) - 1);\\n                if (map.get(A[start]) == 0) map.remove(A[start]);\\n                start++;\\n            }\\n            res += end - start + 1; // brainstorm: when you get a range that satisfy at most k distinct values, \\n\\t\\t\\t                                      // how many subarrays are there ending with this \"end\" pointer? exactly end - start + 1\\n            end++; // move end one by one\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1026527,
                "title": "java-souution-using-hashmap-and-solding-window-easy-to-understand",
                "content": "just keep [l,r] with K different integers, then tmp copy l and slide to right until [tmp,r] without k different integers, then we should restore hashMap to record correctly\\n ```java\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        int l = 0, r = 0;\\n        while(r < A.length){\\n            map.put(A[r], map.getOrDefault(A[r], 0) + 1);\\n            while(map.size() > K){\\n                int num = map.get(A[l]);\\n                if(num == 1){ \\n                    map.remove(A[l]);\\n                }\\n                else{\\n                    map.put(A[l], num - 1);\\n                }\\n                l++;\\n            }\\n            \\n            int tmp = l;\\n            while(map.size() == K){\\n                res++;\\n                int num = map.get(A[tmp]);\\n                if(num == 1){ \\n                    map.remove(A[tmp]);\\n                }\\n                else{\\n                    map.put(A[tmp], num - 1);\\n                }\\n                tmp++;\\n            }\\n            while(tmp > l){\\n                tmp--;\\n                map.put(A[tmp], map.getOrDefault(A[tmp], 0) + 1);\\n            }\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        int l = 0, r = 0;\\n        while(r < A.length){\\n            map.put(A[r], map.getOrDefault(A[r], 0) + 1);\\n            while(map.size() > K){\\n                int num = map.get(A[l]);\\n                if(num == 1){ \\n                    map.remove(A[l]);\\n                }\\n                else{\\n                    map.put(A[l], num - 1);\\n                }\\n                l++;\\n            }\\n            \\n            int tmp = l;\\n            while(map.size() == K){\\n                res++;\\n                int num = map.get(A[tmp]);\\n                if(num == 1){ \\n                    map.remove(A[tmp]);\\n                }\\n                else{\\n                    map.put(A[tmp], num - 1);\\n                }\\n                tmp++;\\n            }\\n            while(tmp > l){\\n                tmp--;\\n                map.put(A[tmp], map.getOrDefault(A[tmp], 0) + 1);\\n            }\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992676,
                "title": "simple-c-using-sliding-window",
                "content": "```\\nint findno(vector<int>& nums, int k)\\n{\\n\\tunordered_map<int,int> hashmap;\\n\\tint j=0,count=0;\\n\\tfor(int i=0;i<nums.size();i++)\\n\\t{\\n\\t\\thashmap[nums[i]]++;\\n\\t\\twhile(hashmap.size()>k)\\n\\t\\t{\\n\\t\\t\\thashmap[nums[j]]--;\\n\\t\\t\\tif(hashmap[nums[j]]==0)\\n\\t\\t\\t\\thashmap.erase(nums[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tcount=count+i-j+1;\\n\\t}\\n\\treturn count;\\n}\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n\\treturn findno(nums,k)-findno(nums,k-1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findno(vector<int>& nums, int k)\\n{\\n\\tunordered_map<int,int> hashmap;\\n\\tint j=0,count=0;\\n\\tfor(int i=0;i<nums.size();i++)\\n\\t{\\n\\t\\thashmap[nums[i]]++;\\n\\t\\twhile(hashmap.size()>k)\\n\\t\\t{\\n\\t\\t\\thashmap[nums[j]]--;\\n\\t\\t\\tif(hashmap[nums[j]]==0)\\n\\t\\t\\t\\thashmap.erase(nums[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tcount=count+i-j+1;\\n\\t}\\n\\treturn count;\\n}\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n\\treturn findno(nums,k)-findno(nums,k-1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855975,
                "title": "java-solution-using-sliding-window-and-map",
                "content": "```\\nclass Solution {\\n    \\n    public int subarraysWithKDistinct(int[] ar, int k) {\\n\\t    // exact(k) == atMost(k) + atMost(k - 1)\\n        return atMostK(ar, k) - atMostK(ar, k-1);\\n    }\\n    \\n    private int atMostK(int[] arr, int k) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int left = 0;\\n        int count = 0;\\n        for (int right = 0; right < arr.length; right++) {\\n            int num = arr[right];\\n            addToMap(countMap, num);\\n            while (countMap.size() > k) {\\n                removeFromMap(countMap, arr[left]);\\n                left++;\\n            }\\n            count += right - left + 1;\\n        }\\n        return count;\\n    }\\n    \\n    private void addToMap(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n    }\\n\\n    private void removeFromMap(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) - 1);\\n        if (countMap.get(num) <= 0) {\\n            countMap.remove(num);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int subarraysWithKDistinct(int[] ar, int k) {\\n\\t    // exact(k) == atMost(k) + atMost(k - 1)\\n        return atMostK(ar, k) - atMostK(ar, k-1);\\n    }\\n    \\n    private int atMostK(int[] arr, int k) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int left = 0;\\n        int count = 0;\\n        for (int right = 0; right < arr.length; right++) {\\n            int num = arr[right];\\n            addToMap(countMap, num);\\n            while (countMap.size() > k) {\\n                removeFromMap(countMap, arr[left]);\\n                left++;\\n            }\\n            count += right - left + 1;\\n        }\\n        return count;\\n    }\\n    \\n    private void addToMap(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n    }\\n\\n    private void removeFromMap(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) - 1);\\n        if (countMap.get(num) <= 0) {\\n            countMap.remove(num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853831,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def helper(self,A,B):\\n        count = 0\\n        left = 0\\n        right = 0\\n        d = {}\\n        \\n        while right<len(A):\\n            if A[right] not in d:\\n                d[A[right]] = 0\\n            d[A[right]] += 1\\n            \\n            while len(d)>B:\\n                d[A[left]] -= 1\\n                if d[A[left]] == 0:\\n                    d.pop(A[left])\\n                left += 1\\n            \\n            count += right-left+1\\n            right += 1\\n        \\n        return count    \\n                    \\n                \\n    \\n    def subarraysWithKDistinct(self, A: List[int], B: int) -> int:\\n        return self.helper(A,B)-self.helper(A,B-1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self,A,B):\\n        count = 0\\n        left = 0\\n        right = 0\\n        d = {}\\n        \\n        while right<len(A):\\n            if A[right] not in d:\\n                d[A[right]] = 0\\n            d[A[right]] += 1\\n            \\n            while len(d)>B:\\n                d[A[left]] -= 1\\n                if d[A[left]] == 0:\\n                    d.pop(A[left])\\n                left += 1\\n            \\n            count += right-left+1\\n            right += 1\\n        \\n        return count    \\n                    \\n                \\n    \\n    def subarraysWithKDistinct(self, A: List[int], B: int) -> int:\\n        return self.helper(A,B)-self.helper(A,B-1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846543,
                "title": "c-o-n-sliding-window-short-concise-solution-easily-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int subarraysWithAtmostKDistinct(vector<int> nums,int k){\\n        int ans=0,l=0,r=0,n=nums.size(),kCounter=0;\\n        map<int,int> mm;\\n        while(r<n){\\n            if(++mm[nums[r++]]==1){\\n                kCounter++;\\n            }\\n            while(kCounter>k){\\n                if(--mm[nums[l++]]==0)\\n                    kCounter--;\\n            }\\n            ans+=r-l;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return subarraysWithAtmostKDistinct(nums,k)-subarraysWithAtmostKDistinct(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int subarraysWithAtmostKDistinct(vector<int> nums,int k){\\n        int ans=0,l=0,r=0,n=nums.size(),kCounter=0;\\n        map<int,int> mm;\\n        while(r<n){\\n            if(++mm[nums[r++]]==1){\\n                kCounter++;\\n            }\\n            while(kCounter>k){\\n                if(--mm[nums[l++]]==0)\\n                    kCounter--;\\n            }\\n            ans+=r-l;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return subarraysWithAtmostKDistinct(nums,k)-subarraysWithAtmostKDistinct(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788419,
                "title": "python-sliding-window-using-deque",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        return self.atmostDiff(A,K) - self.atmostDiff(A,K-1)\\n    \\n    def atmostDiff(self, A, K):\\n        count = 0\\n        temp = collections.deque()\\n        hmap = defaultdict(int)\\n        \\n        for i in A:\\n            temp.append(i)\\n            hmap[i]+=1\\n            \\n            while len(hmap)>K:\\n                front = temp.popleft()\\n                hmap[front]-=1\\n                if hmap[front]==0:\\n                    del hmap[front]\\n                    \\n            count += len(temp)\\n            \\n        return count\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        return self.atmostDiff(A,K) - self.atmostDiff(A,K-1)\\n    \\n    def atmostDiff(self, A, K):\\n        count = 0\\n        temp = collections.deque()\\n        hmap = defaultdict(int)\\n        \\n        for i in A:\\n            temp.append(i)\\n            hmap[i]+=1\\n            \\n            while len(hmap)>K:\\n                front = temp.popleft()\\n                hmap[front]-=1\\n                if hmap[front]==0:\\n                    del hmap[front]\\n                    \\n            count += len(temp)\\n            \\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 763344,
                "title": "java-hashmap-and-sliding-window",
                "content": "If you found the solution helpful, kindly upvote or like. :)\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atMostK(A, K)-atMostK(A, K-1);\\n    }\\n\\n\\tprivate int atMostK(int[] a, int k) \\n\\t{\\n\\t\\tint left= 0, right=0, res=0;\\n\\t\\tHashMap<Integer, Integer> map= new HashMap<Integer, Integer>();\\n\\t\\twhile(right<a.length)\\n\\t\\t{\\n\\t\\t\\tmap.put(a[right],map.getOrDefault(a[right],0)+1);\\n\\t\\t\\twhile(map.size() >k)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Slide the window from the left\\n\\t\\t\\t\\tmap.put(a[left],map.get(a[left])-1);\\n\\t\\t\\t\\tif(map.get(a[left])==0) map.remove(a[left]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t\\tres += right-left+1;\\n\\t\\t\\tright++;\\n\\t\\t}\\n\\t\\treturn res;\\n    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atMostK(A, K)-atMostK(A, K-1);\\n    }\\n\\n\\tprivate int atMostK(int[] a, int k) \\n\\t{\\n\\t\\tint left= 0, right=0, res=0;\\n\\t\\tHashMap<Integer, Integer> map= new HashMap<Integer, Integer>();\\n\\t\\twhile(right<a.length)\\n\\t\\t{\\n\\t\\t\\tmap.put(a[right],map.getOrDefault(a[right],0)+1);\\n\\t\\t\\twhile(map.size() >k)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Slide the window from the left\\n\\t\\t\\t\\tmap.put(a[left],map.get(a[left])-1);\\n\\t\\t\\t\\tif(map.get(a[left])==0) map.remove(a[left]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t\\tres += right-left+1;\\n\\t\\t\\tright++;\\n\\t\\t}\\n\\t\\treturn res;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596186,
                "title": "c-sliding-window-solution",
                "content": "```\\nclass Solution {\\n    int subarraysWithAtmostK(vector<int>& A, int K) {\\n        int n = A.size();\\n        \\n        unordered_map<int, int>hm;\\n        int res = 0, i = 0, j = 0, count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            hm[A[i]]++;\\n            while (j < n && hm.size() > K) {\\n                hm[A[j]]--;\\n                if (hm[A[j]] == 0)\\n                    hm.erase(A[j]);\\n                j++;\\n            }\\n            \\n            res += (i-j+1);\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return subarraysWithAtmostK(A, K) - subarraysWithAtmostK(A, K-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int subarraysWithAtmostK(vector<int>& A, int K) {\\n        int n = A.size();\\n        \\n        unordered_map<int, int>hm;\\n        int res = 0, i = 0, j = 0, count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            hm[A[i]]++;\\n            while (j < n && hm.size() > K) {\\n                hm[A[j]]--;\\n                if (hm[A[j]] == 0)\\n                    hm.erase(A[j]);\\n                j++;\\n            }\\n            \\n            res += (i-j+1);\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return subarraysWithAtmostK(A, K) - subarraysWithAtmostK(A, K-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547450,
                "title": "java-well-explained",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n\\t   //At most K - at Most (k-1) gives exactly K - Nothing much to explain here\\n        return atMostK(A, K) - atMostK(A, K-1);\\n    }\\n    \\n    private int atMostK(int[] A, int K) {\\n\\t\\t//If the length of array is smaller than K, this means it\\'s not possible to find a subarray with K different integers, even if the array has Array.length number of distinct integers\\\\\\n        if(A == null || A.length < K) return 0;\\n\\t\\t//Stores frequency of the incoming and outgoing integers \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int i = 0, j = 0, counter = 0, res = 0;\\n        while(j < A.length) {\\n\\t\\t\\t//Right end of the window starts from 0. \\n\\t\\t\\t//Add frequency, or add 1 to every new occurrence \\n            int c = A[j++];\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t\\t\\t//For every DISTINCT integer, increment counter\\n            if(map.get(c) == 1) counter++;\\n            \\n\\t\\t\\t//If counter exceeds K, means, there are more than K distinct integers\\n\\t\\t\\t//This means, we have to reduce the left boundary to come to a value such that Arrays.subarray(left TO right) contains 2 disticnt characters\\n            while(counter > K) {\\n                int d = A[i++];\\n\\t\\t\\t\\t//For every encountered integer, decrement frequency\\n                map.put(d, map.get(d) - 1);\\n\\t\\t\\t\\t//If an integer has been frequented so much, that the window doesn\\'t contain it anymore, decrement counter. Counter should be 2 now \\n                if(map.get(d) == 0) counter--;\\n            }\\n\\t\\t\\t//All subarrays between i and j, boundaries included are subarrays with AT MOST k characters, including each subarray of length 1 and so on. \\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n\\t   //At most K - at Most (k-1) gives exactly K - Nothing much to explain here\\n        return atMostK(A, K) - atMostK(A, K-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 545714,
                "title": "java-solution-using-doubly-linked-list-map-o-n-time-o-k-memory",
                "content": "1. Doubly linked list node has two fields: `val` and `lastIndex`. The `lastIndex` denotes the last occurrence of `val` in input array `A` up to now.\\n2. When we loop the `val` in `A`, we update the `lastIndex` of the occurrence of `A[i]`.\\n3. Use a Map to track the number of distinct values.\\n4. The number of K-value subarray found in each step is \\n```\\nif(map.size() == K) {\\n      cnt += (head.next.lastIndex - st);\\n}\\n```\\n5. Do not forget to update `st`.\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\tDoublyListNode head = new DoublyListNode(Integer.MIN_VALUE, -1);\\n        DoublyListNode tail = new DoublyListNode(Integer.MAX_VALUE, A.length);\\n        head.next = tail;\\n        tail.prev = head;\\n        Map<Integer, DoublyListNode> map = new HashMap<>();\\n        int cnt = 0, st = -1;\\n        for(int i = 0; i < A.length; ++i) {\\n            DoublyListNode curr;\\n            if(map.containsKey(A[i])) {\\n                curr = map.get(A[i]);\\n                curr.prev.next = curr.next;\\n                curr.next.prev = curr.prev;\\n                curr.prev = null;\\n                curr.next = null;\\n                curr.lastIndex = i;\\n            } else {\\n                curr = new DoublyListNode(A[i], i);\\n            }\\n\\n            tail.prev.next = curr;\\n            curr.prev = tail.prev;\\n            curr.next = tail;\\n            tail.prev = curr;\\n            map.put(A[i], curr);\\n            if(map.size() > K) {\\n                DoublyListNode first = head.next;\\n                st = first.lastIndex;\\n                head.next = first.next;\\n                first.next.prev = head;\\n                first.next = null;\\n                first.prev = null;\\n                map.remove(first.val);\\n            }\\n\\n            if(map.size() == K) {\\n                cnt += (head.next.lastIndex - st);\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    class DoublyListNode {\\n        int val;\\n        int lastIndex;\\n        DoublyListNode prev, next;\\n        public DoublyListNode(int val, int lastIndex) {\\n            this.val = val;\\n            this.lastIndex = lastIndex;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif(map.size() == K) {\\n      cnt += (head.next.lastIndex - st);\\n}\\n```\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\tDoublyListNode head = new DoublyListNode(Integer.MIN_VALUE, -1);\\n        DoublyListNode tail = new DoublyListNode(Integer.MAX_VALUE, A.length);\\n        head.next = tail;\\n        tail.prev = head;\\n        Map<Integer, DoublyListNode> map = new HashMap<>();\\n        int cnt = 0, st = -1;\\n        for(int i = 0; i < A.length; ++i) {\\n            DoublyListNode curr;\\n            if(map.containsKey(A[i])) {\\n                curr = map.get(A[i]);\\n                curr.prev.next = curr.next;\\n                curr.next.prev = curr.prev;\\n                curr.prev = null;\\n                curr.next = null;\\n                curr.lastIndex = i;\\n            } else {\\n                curr = new DoublyListNode(A[i], i);\\n            }\\n\\n            tail.prev.next = curr;\\n            curr.prev = tail.prev;\\n            curr.next = tail;\\n            tail.prev = curr;\\n            map.put(A[i], curr);\\n            if(map.size() > K) {\\n                DoublyListNode first = head.next;\\n                st = first.lastIndex;\\n                head.next = first.next;\\n                first.next.prev = head;\\n                first.next = null;\\n                first.prev = null;\\n                map.remove(first.val);\\n            }\\n\\n            if(map.size() == K) {\\n                cnt += (head.next.lastIndex - st);\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    class DoublyListNode {\\n        int val;\\n        int lastIndex;\\n        DoublyListNode prev, next;\\n        public DoublyListNode(int val, int lastIndex) {\\n            this.val = val;\\n            this.lastIndex = lastIndex;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467333,
                "title": "java-o-n-sliding-window-two-pointers",
                "content": "Key Insights.\\n\\n1) Use a sliding window.\\n2) Keep track of the leftmost element in the window that if removed decreases the distinct number of integers in the window.\\n\\nwStartIndex = start of the window.\\nz = leftmost element in the window that if removed would decrease the number of different integers in the window.\\n\\nlastOccurrence  = A map of the rightmost index of each element in the window.\\nE.G. [(1, 1, 2, 1)] The map contains 1 -> 3, 2 -> 2.\\nThis is used to advance z as the window advances as well as count the number of distinct integers in the window.\\n\\nCounting good Sub Arrays (k=2)\\n\\nWhen the window slides from [(2, 2, 1), 2] -> [(2, 2, 1, 2)] (z = 2, wStartIndex = 0)\\nadd the following 3 good sub arrays: [2, 2, 1, 2], [2, 1, 2], [1, 2]\\n2 - 0 + 1 = 3 (z - wStartIndex + 1)\\n \\n ```java\\n public int subarraysWithKDistinct(int[] A, int K) {\\n    Map<Integer, Integer> lastOccurrence = new HashMap<>();\\n    int count = 0;\\n    int wStartIndex = 0;\\n    // leftmost element in the window that if removed would \\n    // decrease the number of different integers in the window.\\n    int z = 0;\\n\\n    for (int wEndIndex = 0; wEndIndex < A.length; wEndIndex++) {\\n      lastOccurrence.put(A[wEndIndex], wEndIndex);\\n      if (lastOccurrence.size() > K) {\\n        lastOccurrence.remove(A[z]);\\n        z++;\\n        wStartIndex = z;\\n      }\\n\\t  // Advance z until it is the rightmost occurance of that integer in the window.\\n      while(z < lastOccurrence.get(A[z])) {\\n        z++;\\n      }\\n      if (lastOccurrence.size() == K) {\\n        count += (z - wStartIndex) + 1;\\n      }\\n    }\\n    return count;\\n  }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int subarraysWithKDistinct(int[] A, int K) {\\n    Map<Integer, Integer> lastOccurrence = new HashMap<>();\\n    int count = 0;\\n    int wStartIndex = 0;\\n    // leftmost element in the window that if removed would \\n    // decrease the number of different integers in the window.\\n    int z = 0;\\n\\n    for (int wEndIndex = 0; wEndIndex < A.length; wEndIndex++) {\\n      lastOccurrence.put(A[wEndIndex], wEndIndex);\\n      if (lastOccurrence.size() > K) {\\n        lastOccurrence.remove(A[z]);\\n        z++;\\n        wStartIndex = z;\\n      }\\n\\t  // Advance z until it is the rightmost occurance of that integer in the window.\\n      while(z < lastOccurrence.get(A[z])) {\\n        z++;\\n      }\\n      if (lastOccurrence.size() == K) {\\n        count += (z - wStartIndex) + 1;\\n      }\\n    }\\n    return count;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444192,
                "title": "java-easy-to-understand-sliding-window-solution-with-inline-comments",
                "content": "```\\npublic int subarraysWithKDistinct(int[] A, int K) {\\n        if(A==null || A.length==0) return 0;\\n        \\n        int count=0;\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        Map<Integer, Integer> map2 = new HashMap<>();\\n        int idx1=0, idx2=0;\\n        for(int i=0; i< A.length; i++){\\n            Integer num = A[i];\\n            map1.put(num, map1.getOrDefault(num, 0)+1);\\n            map2.put(num, map2.getOrDefault(num, 0)+1);\\n            \\n            //the longest qualified subarray (K distinct numbers) till now: [idx1, i]\\n            while(map1.size() > K){\\n                Integer remove = A[idx1++];\\n                int rc = map1.get(remove);\\n                if(rc == 1) map1.remove(remove);\\n                else map1.put(remove, rc-1);\\n            }\\n            \\n            //the longest non-qualified (K-1 distinct numbers) subarray till now: [idx2, i]\\n            while(map2.size() >= K){\\n                Integer remove = A[idx2++];\\n                int rc = map2.get(remove);\\n                if(rc == 1) map2.remove(remove);\\n                else map2.put(remove, rc-1);\\n            }\\n            \\n            //With idx1 and idx2, it is safe to remove the numbers between [idx1, idx2) but still maintain the qualification state of map1.\\n            //In other words, each of the extra element between [idx1, idx2) contributes a new combination of qualified subarray ending with i.\\n\\t\\t\\t//For example, [idx1 ... i], [idx1+1 ... i] ... [idx2-1 ... i]\\n            int prefixCount = idx2-idx1;\\n            count += prefixCount;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int subarraysWithKDistinct(int[] A, int K) {\\n        if(A==null || A.length==0) return 0;\\n        \\n        int count=0;\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        Map<Integer, Integer> map2 = new HashMap<>();\\n        int idx1=0, idx2=0;\\n        for(int i=0; i< A.length; i++){\\n            Integer num = A[i];\\n            map1.put(num, map1.getOrDefault(num, 0)+1);\\n            map2.put(num, map2.getOrDefault(num, 0)+1);\\n            \\n            //the longest qualified subarray (K distinct numbers) till now: [idx1, i]\\n            while(map1.size() > K){\\n                Integer remove = A[idx1++];\\n                int rc = map1.get(remove);\\n                if(rc == 1) map1.remove(remove);\\n                else map1.put(remove, rc-1);\\n            }\\n            \\n            //the longest non-qualified (K-1 distinct numbers) subarray till now: [idx2, i]\\n            while(map2.size() >= K){\\n                Integer remove = A[idx2++];\\n                int rc = map2.get(remove);\\n                if(rc == 1) map2.remove(remove);\\n                else map2.put(remove, rc-1);\\n            }\\n            \\n            //With idx1 and idx2, it is safe to remove the numbers between [idx1, idx2) but still maintain the qualification state of map1.\\n            //In other words, each of the extra element between [idx1, idx2) contributes a new combination of qualified subarray ending with i.\\n\\t\\t\\t//For example, [idx1 ... i], [idx1+1 ... i] ... [idx2-1 ... i]\\n            int prefixCount = idx2-idx1;\\n            count += prefixCount;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429241,
                "title": "short-clean-java-with-hashmap-and-2-pointer",
                "content": "This is again the same redundant hashmap implementation, couldnt see anyone posting easy hashmap based short solution, hence posting this.\\n```\\n    public int subarraysWithKDistinct(int[] arr, int k) {\\n        if(k==0) return 0;\\n        int n = arr.length;\\n        Map < Integer, Integer > map = new HashMap < > ();\\n        int i = 0, j = 0, total = 0;\\n        while (j < arr.length) {\\n            map.put(arr[j], map.getOrDefault(arr[j], 0) + 1);\\n            if (map.size() == k) {\\n                int dups = j;\\n                while ((dups + 1) < n && map.containsKey(arr[dups + 1])) dups++;\\n                while (map.size() == k) {\\n                    total += (dups - j) + 1;\\n                    int removable = arr[i];\\n                    map.put(removable, map.get(removable) - 1);\\n                    if (map.get(removable) == 0) map.remove(removable);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return total;\\n\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public int subarraysWithKDistinct(int[] arr, int k) {\\n        if(k==0) return 0;\\n        int n = arr.length;\\n        Map < Integer, Integer > map = new HashMap < > ();\\n        int i = 0, j = 0, total = 0;\\n        while (j < arr.length) {\\n            map.put(arr[j], map.getOrDefault(arr[j], 0) + 1);\\n            if (map.size() == k) {\\n                int dups = j;\\n                while ((dups + 1) < n && map.containsKey(arr[dups + 1])) dups++;\\n                while (map.size() == k) {\\n                    total += (dups - j) + 1;\\n                    int removable = arr[i];\\n                    map.put(removable, map.get(removable) - 1);\\n                    if (map.get(removable) == 0) map.remove(removable);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return total;\\n\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 408810,
                "title": "clean-javascript-solution-atmost",
                "content": "Reference https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)\\n\\n```\\nfunction subarraysWithKDistinct(A, K) {\\n  function atMostK(k) {\\n    let l = 0;\\n    let res = 0;\\n    const count = {};\\n\\n    for (let r = 0; r < A.length; r++) {\\n      if (count[A[r]] == null) count[A[r]] = 0;\\n      if (count[A[r]] === 0) k--;\\n      count[A[r]]++;\\n\\n      while (k < 0) {\\n        count[A[l]]--;\\n        if (count[A[l]] === 0) k++;\\n        l++;\\n      }\\n      res += r - l + 1;\\n    }\\n    return res;\\n  }\\n\\n  return atMostK(K) - atMostK(K - 1);\\n}\\n```\\n\\nMore at https://github.com/Hongbo-Miao/leetcode",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction subarraysWithKDistinct(A, K) {\\n  function atMostK(k) {\\n    let l = 0;\\n    let res = 0;\\n    const count = {};\\n\\n    for (let r = 0; r < A.length; r++) {\\n      if (count[A[r]] == null) count[A[r]] = 0;\\n      if (count[A[r]] === 0) k--;\\n      count[A[r]]++;\\n\\n      while (k < 0) {\\n        count[A[l]]--;\\n        if (count[A[l]] === 0) k++;\\n        l++;\\n      }\\n      res += r - l + 1;\\n    }\\n    return res;\\n  }\\n\\n  return atMostK(K) - atMostK(K - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 372136,
                "title": "subarrays-with-k-different-integers-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\t\\treturn atMostK(A, K) - atMostK(A, K - 1);\\n\\t\\t}\\n\\t\\tprivate int atMostK(int[] A, int K) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor (int j = 0; j < A.length; j++) {\\n\\t\\t\\t\\tif (map.getOrDefault(A[j], 0) == 0) K--;\\n\\t\\t\\t\\tmap.put(A[j], map.getOrDefault(A[j], 0) + 1);\\n\\t\\t\\t\\twhile (K < 0) {\\n\\t\\t\\t\\t\\tmap.put(A[i], map.get(A[i]) - 1);\\n\\t\\t\\t\\t\\tif (map.get(A[i]) == 0) K++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres += j - i + 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\t\\treturn atMostK(A, K) - atMostK(A, K - 1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 235777,
                "title": "javascript-o-n-solution",
                "content": "```\\nconst subarraysWithKDistinct = (A, K) => {\\n  let ans = 0;\\n  let l = 0, r = 0;\\n  let leftUniques = 0;\\n  let leftDic = {};\\n  let rightUniques = 0;\\n  let rightDic = {};\\n  for (let i = 0; i < A.length; i++) {\\n    leftDic[A[i]] = leftDic[A[i]] ? leftDic[A[i]] + 1 : 1;\\n    rightDic[A[i]] = rightDic[A[i]] ? rightDic[A[i]] + 1 : 1;\\n    if (leftDic[A[i]] === 1) leftUniques++;\\n    if (rightDic[A[i]] === 1) rightUniques++;\\n\\n    while (leftUniques > K) {\\n      if (leftDic[A[l]] === 1) {\\n        leftUniques--;\\n      }\\n      leftDic[A[l]] -= 1;\\n      l++;\\n    }\\n\\n    while (rightUniques >= K) {\\n      if (rightDic[A[r]] === 1) {\\n        rightUniques--;\\n      }\\n      rightDic[A[r]] -= 1;\\n      r++;\\n    }\\n    ans += r - l;\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst subarraysWithKDistinct = (A, K) => {\\n  let ans = 0;\\n  let l = 0, r = 0;\\n  let leftUniques = 0;\\n  let leftDic = {};\\n  let rightUniques = 0;\\n  let rightDic = {};\\n  for (let i = 0; i < A.length; i++) {\\n    leftDic[A[i]] = leftDic[A[i]] ? leftDic[A[i]] + 1 : 1;\\n    rightDic[A[i]] = rightDic[A[i]] ? rightDic[A[i]] + 1 : 1;\\n    if (leftDic[A[i]] === 1) leftUniques++;\\n    if (rightDic[A[i]] === 1) rightUniques++;\\n\\n    while (leftUniques > K) {\\n      if (leftDic[A[l]] === 1) {\\n        leftUniques--;\\n      }\\n      leftDic[A[l]] -= 1;\\n      l++;\\n    }\\n\\n    while (rightUniques >= K) {\\n      if (rightDic[A[r]] === 1) {\\n        rightUniques--;\\n      }\\n      rightDic[A[r]] -= 1;\\n      r++;\\n    }\\n    ans += r - l;\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234915,
                "title": "c-two-pointers-o-n-time-solution-with-o-k-space",
                "content": "The basic idea is first find a \"base\" index interval `[L, R]` which contains `K` distinct elements in `A`, and then try to expand it to the right such that it still contains only these `K` elements. For each feasible extension, suppose the right end is `R1`, and let `L1` be the largest index such that `[L1, R1]` contains these `K` elements, then we know we have `L1 - L + 1` more feasible subarrays, i.e., `A[L:R1]`, `A[(L+1):R1]`, ..., and `A[L1:R1]`.\\n\\nIn order to achieve this, we use two pointers i and j starting from 0, and a hashmap `cntMap` to store the frequency per elements in some sliding window of `A`.\\n\\nWe move right pointer `j` until interval `[i, j-1]` contains `K` distinct elements, that is, `cntMap.size() == K`. By now we have found a base interval. Then, for every index `r` in `[j-1, A.size())`, if `A[r]` is one of the `K` distinct elements we have got, that is, `A[r]` is in `cntMap`, then we have found a feasible extension; now we use a temporary left pointer `l` starting from `i`, and move it to right, during which we decrease the frequency of `A[l]` by `1`, until `A[l]` is already `1`, which implies that `l` is the largest index such that the subarray `A[l...r]` contains those `K` elements, so we increment the result by `l - i + 1`. When we find the first `r` such that `A[r]` is not in `cntMap`, then it means that the current interval `[i, j)` cannot be extended anymore, so we update `i = l + 1` and `j = r`, and try to find the next base interval and repeat the process, until `r` hits `A.size()`.\\n\\nTime and space complexity: in the algorithm, `i`, `j`, `l`, and `r` are always going right, so the time complexity is `O(n)`. Size of the hashmap will not go beyond `K`, so the space complexity is `O(K)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int n = A.size();\\n        unordered_map<int, int> cntMap;\\n        int i = 0, j = 0;\\n        int res = 0;\\n        \\n        while (i < n && j < n) {\\n            // Find a feasible base interval [i, j)\\n            while (j < n && cntMap.size() < K) {\\n                ++cntMap[A[j++]];\\n            }\\n            \\n            // Try to extend [i, j)\\n            if (cntMap.size() == K) {\\n                int r = j - 1;\\n                int l = i;\\n                \\n                for (; r < n && cntMap.find(A[r]) != cntMap.end(); ++r) {\\n                    if (r >= j) {\\n                        ++cntMap[A[r]];\\n                    }\\n                    \\n                    // If A[r] is not a new element, then fix r and see how far we can move l\\n                    for (; l < n; ++l) {\\n                        if (cntMap[A[l]] == 1)\\n                            break;\\n                        else\\n                            --cntMap[A[l]];\\n                    }\\n                    \\n                    // l is the far right index we can go such that A[l...r] is a feasible sub-array\\n                    // We know that A[i:r], A[(i+1):r], ..., and A[l...r] are all feasible\\n                    res += l - i + 1;\\n                }\\n                \\n                // Now l exits the sliding window, update cntMap[A[l]]\\n                if (l < n && --cntMap[A[l]] == 0) {\\n                    cntMap.erase(A[l]);\\n                }\\n                \\n                // Update the two-pointer position to find next base interval\\n                i = l + 1;\\n                j = r;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int n = A.size();\\n        unordered_map<int, int> cntMap;\\n        int i = 0, j = 0;\\n        int res = 0;\\n        \\n        while (i < n && j < n) {\\n            // Find a feasible base interval [i, j)\\n            while (j < n && cntMap.size() < K) {\\n                ++cntMap[A[j++]];\\n            }\\n            \\n            // Try to extend [i, j)\\n            if (cntMap.size() == K) {\\n                int r = j - 1;\\n                int l = i;\\n                \\n                for (; r < n && cntMap.find(A[r]) != cntMap.end(); ++r) {\\n                    if (r >= j) {\\n                        ++cntMap[A[r]];\\n                    }\\n                    \\n                    // If A[r] is not a new element, then fix r and see how far we can move l\\n                    for (; l < n; ++l) {\\n                        if (cntMap[A[l]] == 1)\\n                            break;\\n                        else\\n                            --cntMap[A[l]];\\n                    }\\n                    \\n                    // l is the far right index we can go such that A[l...r] is a feasible sub-array\\n                    // We know that A[i:r], A[(i+1):r], ..., and A[l...r] are all feasible\\n                    res += l - i + 1;\\n                }\\n                \\n                // Now l exits the sliding window, update cntMap[A[l]]\\n                if (l < n && --cntMap[A[l]] == 0) {\\n                    cntMap.erase(A[l]);\\n                }\\n                \\n                // Update the two-pointer position to find next base interval\\n                i = l + 1;\\n                j = r;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234542,
                "title": "python-two-pointer-one-sliding-window-o-n-solution",
                "content": "The idea is to keep the invariant that the sliding window contains K different integers, shrink the sliding window form left as much as we can, and keep track of the number of subarrays ending at each position. The time complexity is O(N), and the space complexity is O(K).\\nThank @h11129 for pointing out the redundancy in my original version! The modified version is as follows.\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        count = collections.Counter()\\n        ans = dp = 0\\n        i = 0\\n        for j in range(len(A)):\\n            count[A[j]] += 1\\n            if len(count) < K:\\n                continue\\n            elif len(count) == K:\\n                dp = max(dp, 1)\\n            else:\\n                del count[A[i]]\\n                i += 1\\n                dp = 1\\n            while count[A[i]] != 1:\\n                dp += 1\\n                count[A[i]] -= 1\\n                i += 1\\n            ans += dp\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        count = collections.Counter()\\n        ans = dp = 0\\n        i = 0\\n        for j in range(len(A)):\\n            count[A[j]] += 1\\n            if len(count) < K:\\n                continue\\n            elif len(count) == K:\\n                dp = max(dp, 1)\\n            else:\\n                del count[A[i]]\\n                i += 1\\n                dp = 1\\n            while count[A[i]] != 1:\\n                dp += 1\\n                count[A[i]] -= 1\\n                i += 1\\n            ans += dp\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040769,
                "title": "java-solution-sliding-window",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return helper(nums, k) - helper(nums, k-1);\\n    }\\n\\n    private int helper(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int count = 0, left = 0;\\n        for(int right = 0; right < nums.length; right++) {\\n            map.put(nums[right], map.getOrDefault(nums[right], 0) + 1);\\n\\n            while(map.size() > k) {\\n                if(map.get(nums[left]) == 1)  map.remove(nums[left]);\\n                else map.put(nums[left], map.getOrDefault(nums[left], 0) - 1);\\n                left++;\\n            } \\n\\n            count += (right - left + 1);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return helper(nums, k) - helper(nums, k-1);\\n    }\\n\\n    private int helper(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int count = 0, left = 0;\\n        for(int right = 0; right < nums.length; right++) {\\n            map.put(nums[right], map.getOrDefault(nums[right], 0) + 1);\\n\\n            while(map.size() > k) {\\n                if(map.get(nums[left]) == 1)  map.remove(nums[left]);\\n                else map.put(nums[left], map.getOrDefault(nums[left], 0) - 1);\\n                left++;\\n            } \\n\\n            count += (right - left + 1);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891761,
                "title": "sliding-window-easy",
                "content": "**Similar ::**\\n***2799. Count Complete Subarrays in an Array***\\n**>>>** https://leetcode.com/problems/count-complete-subarrays-in-an-array/solutions/3891740/sliding-window-easy/\\n\\n________________________________\\n\\n# Approach  : at most *K* subsets\\n```\\nclass Solution {\\n     public int subarraysWithKDistinct(int[] nums, int k) {\\n         return f(nums,k)-f(nums,k-1);\\n     }\\n    public int f(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int si=0;\\n        int ei=0;\\n        int count=0;\\n        while(ei<nums.length){\\n            map.put(nums[ei], map.getOrDefault(nums[ei], 0) + 1);\\n            while(map.size()>k){\\n\\t\\t\\t\\tif(map.get(nums[si]) > 1) {\\n\\t\\t\\t\\t\\tmap.put(nums[si], map.get(nums[si]) - 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmap.remove(nums[si]);\\n\\t\\t\\t\\t}\\n               si++;\\n            }\\n            count+=ei-si+1;\\n            ei++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n________________________________\\n\\n**Upvote if helps**\\n![image.png](https://assets.leetcode.com/users/images/f18ccf7b-bb7d-4a8e-8622-2f0acbd705cc_1683886081.2272806.png)\\n\\n________________________________",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n     public int subarraysWithKDistinct(int[] nums, int k) {\\n         return f(nums,k)-f(nums,k-1);\\n     }\\n    public int f(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int si=0;\\n        int ei=0;\\n        int count=0;\\n        while(ei<nums.length){\\n            map.put(nums[ei], map.getOrDefault(nums[ei], 0) + 1);\\n            while(map.size()>k){\\n\\t\\t\\t\\tif(map.get(nums[si]) > 1) {\\n\\t\\t\\t\\t\\tmap.put(nums[si], map.get(nums[si]) - 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmap.remove(nums[si]);\\n\\t\\t\\t\\t}\\n               si++;\\n            }\\n            count+=ei-si+1;\\n            ei++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662013,
                "title": "simple-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int atmost(int[]nums,int n ,int k){\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            map.put(nums[j],map.getOrDefault(nums[j], 0)+1);\\n            while(map.size()>k){\\n                map.put(nums[i],map.get(nums[i])-1);\\n               \\n                if(map.get(nums[i])==0)map.remove(nums[i]);\\n                 i++;\\n            }\\n            count+=j-i+1;\\n            j++;\\n        }\\n        return count;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n         int n=nums.length;\\n        return atmost(nums,n,k)-atmost(nums,n,k-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int atmost(int[]nums,int n ,int k){\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            map.put(nums[j],map.getOrDefault(nums[j], 0)+1);\\n            while(map.size()>k){\\n                map.put(nums[i],map.get(nums[i])-1);\\n               \\n                if(map.get(nums[i])==0)map.remove(nums[i]);\\n                 i++;\\n            }\\n            count+=j-i+1;\\n            j++;\\n        }\\n        return count;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n         int n=nums.length;\\n        return atmost(nums,n,k)-atmost(nums,n,k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503714,
                "title": "kotlin-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\\n        return atMostK(nums, k) - atMostK(nums, k - 1)\\n    }\\n\\n    fun atMostK(nums: IntArray, _k: Int): Int {\\n        var result = 0\\n        var i = 0\\n        var k = _k\\n        var cache = HashMap<Int, Int>()\\n\\n        for (j in nums.indices) {\\n            if (cache.getOrDefault(nums[j], 0) == 0) k--\\n            cache.put(nums[j], cache.getOrDefault(nums[j], 0) + 1)\\n\\n            while (k < 0) {\\n                cache.put(nums[i], cache.getOrDefault(nums[i], 1) - 1)\\n                if (cache.getOrDefault(nums[i], 0) == 0) k++\\n                i++\\n            }\\n\\n            result += j - i + 1\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\\n        return atMostK(nums, k) - atMostK(nums, k - 1)\\n    }\\n\\n    fun atMostK(nums: IntArray, _k: Int): Int {\\n        var result = 0\\n        var i = 0\\n        var k = _k\\n        var cache = HashMap<Int, Int>()\\n\\n        for (j in nums.indices) {\\n            if (cache.getOrDefault(nums[j], 0) == 0) k--\\n            cache.put(nums[j], cache.getOrDefault(nums[j], 0) + 1)\\n\\n            while (k < 0) {\\n                cache.put(nums[i], cache.getOrDefault(nums[i], 1) - 1)\\n                if (cache.getOrDefault(nums[i], 0) == 0) k++\\n                i++\\n            }\\n\\n            result += j - i + 1\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383664,
                "title": "three-pointer-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThree-pointer approach :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAllways keep the right pointer to the right most while the number of different integers is equal to K\\nMiddle pointer should point the place where the number of different integers is exactly k\\nLeft pointer should always delete one number at a time from the left\\nans+=(right-mid+1)\\n\\n# Complexity\\n- Time complexity: O(n) Just one Pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you like my solution.\\n\\n# Code\\n```\\nclass Solution {\\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\\n    val all = hashMapOf<Int, Int>()\\n    val small = hashMapOf<Int, Int>()\\n    all[nums[0]] = 1\\n    small[nums[0]] = 1\\n    var r = 1\\n    var mid = 1\\n    var ans = 0\\n    for (l in 0 until nums.size) {\\n        while (mid < nums.size && small.size != k) {\\n            small[nums[mid]] = small.getOrDefault(nums[mid], 0) + 1\\n            mid++\\n        }\\n        while (r < nums.size && (all.containsKey(nums[r]) || all.size < k)) {\\n            all[nums[r]] = all.getOrDefault(nums[r], 0) + 1\\n            r++\\n        }\\n        if (small.size == k) {\\n            ans+=(r-mid+1)\\n        }\\n        small[nums[l]] = small.getOrDefault(nums[l], 0) - 1\\n        if (small[nums[l]] == 0)\\n            small.remove(nums[l])\\n        all[nums[l]] = all.getOrDefault(nums[l], 0) - 1\\n        if (all[nums[l]] == 0)\\n            all.remove(nums[l])\\n    }\\n    return ans\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\\n    val all = hashMapOf<Int, Int>()\\n    val small = hashMapOf<Int, Int>()\\n    all[nums[0]] = 1\\n    small[nums[0]] = 1\\n    var r = 1\\n    var mid = 1\\n    var ans = 0\\n    for (l in 0 until nums.size) {\\n        while (mid < nums.size && small.size != k) {\\n            small[nums[mid]] = small.getOrDefault(nums[mid], 0) + 1\\n            mid++\\n        }\\n        while (r < nums.size && (all.containsKey(nums[r]) || all.size < k)) {\\n            all[nums[r]] = all.getOrDefault(nums[r], 0) + 1\\n            r++\\n        }\\n        if (small.size == k) {\\n            ans+=(r-mid+1)\\n        }\\n        small[nums[l]] = small.getOrDefault(nums[l], 0) - 1\\n        if (small[nums[l]] == 0)\\n            small.remove(nums[l])\\n        all[nums[l]] = all.getOrDefault(nums[l], 0) - 1\\n        if (all[nums[l]] == 0)\\n            all.remove(nums[l])\\n    }\\n    return ans\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280465,
                "title": "javascript-992-subarrays-with-k-different-integers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nA good solution\\n\\n1\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Map();\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (!m.has(a[R])) uniq++;\\n                m.set(a[R], (m.get(a[R]) || 0) + 1);\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m.set(a[L], (m.get(a[L]) || 0) - 1);\\n            if (m.get(a[L]) === 0) {\\n                m.delete(a[L]);\\n                uniq--;\\n            }\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t + 1) - atLeast(a, t);\\n};\\n```\\n\\n2\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Array(n + 1).fill(0);\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (m[a[R]] === 0) uniq++;\\n                m[a[R]]++;\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m[a[L]]--;\\n            if (m[a[L]] === 0) uniq--;\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t + 1) - atLeast(a, t);\\n};\\n```\\n\\n3\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Array(n + 1).fill(0);\\n        let uniq = 0;\\n        let L = 0;\\n        let cc = 0;\\n        for (let R = 0; R < n; R++) {\\n            if (m[a[R]] === 0) uniq++;\\n            m[a[R]]++;\\n            for (; uniq > t; L++) {\\n                m[a[L]]--;\\n                if (m[a[L]] === 0) uniq--;\\n            }\\n            cc += R - L + 1;\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t) - atLeast(a, t - 1);\\n};\\n```\\n\\n4\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    class MapUnique {\\n        m = new Map();\\n        uniq = 0;\\n\\n        get size() {\\n            return this.uniq;\\n        }\\n        inc(e) {\\n            if (this.m.has(e) === false) this.uniq++;\\n            this.m.set(e, (this.m.get(e) || 0) + 1);\\n        }\\n        dec(e) {\\n            this.m.set(e, (this.m.get(e) || 0) - 1);\\n            if (this.m.get(e) === 0) {\\n                this.m.delete(e);\\n                this.uniq--;\\n            }\\n        }\\n    }\\n    let m1 = new MapUnique();\\n    let m2 = new MapUnique();\\n    let n = a.length;\\n    let cc = 0;\\n    let L = 0;\\n    let R = 0;\\n    for (let i = 0; i < n; i++) {\\n        while (L < n && m1.size < t) {\\n            m1.inc(a[L]);\\n            L += 1;\\n        }\\n        while (R < n && m2.size < t + 1) {\\n            m2.inc(a[R]);\\n            R += 1;\\n        }\\n        if (m1.size < t) {\\n            break;\\n        }\\n        if (m2.size < t + 1) {\\n            R = n + 1;\\n        }\\n        cc += R - L;\\n        m1.dec(a[i]);\\n        m2.dec(a[i]);\\n    }\\n    return cc;\\n};\\n```\\n\\n5\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        cc = 0,\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        m = new Array(n + 1).fill(0);\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) uniques++;\\n        m[e]++;\\n\\n        while (uniques > t) {\\n            m[a[L]]--;\\n            if (m[a[L]] === 0) {\\n                uniques--;\\n                leftMostExtra = 0;\\n            }\\n            L++;\\n        }\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            leftMostExtra++;\\n            L++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n6\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        cc = 0,\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        m = new Array(n + 1).fill(0);\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) uniques++;\\n        m[e]++;\\n\\n        if (uniques > t) {\\n            m[a[L]]--;\\n            uniques--;\\n            leftMostExtra = 0;\\n            L++;\\n        }\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            leftMostExtra++;\\n            L++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n7\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        m = new Array(n + 1).fill(0),\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        cc = 0;\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) {\\n            uniques++;\\n            if (uniques > t) {\\n                m[a[L]]--;\\n                uniques--;\\n                L++;\\n                leftMostExtra = 0;\\n            }\\n        }\\n        m[e]++;\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            L++;\\n            leftMostExtra++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n8\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        m = new Array(n + 1).fill(0),\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        cc = 0;\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) {\\n            uniques++;\\n            if (uniques > t) {\\n                m[a[L]]--;\\n                uniques--;\\n                L++;\\n                leftMostExtra = 0;\\n            }\\n        }\\n        m[e]++;\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            L++;\\n            leftMostExtra++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Map();\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (!m.has(a[R])) uniq++;\\n                m.set(a[R], (m.get(a[R]) || 0) + 1);\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m.set(a[L], (m.get(a[L]) || 0) - 1);\\n            if (m.get(a[L]) === 0) {\\n                m.delete(a[L]);\\n                uniq--;\\n            }\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t + 1) - atLeast(a, t);\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Array(n + 1).fill(0);\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (m[a[R]] === 0) uniq++;\\n                m[a[R]]++;\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m[a[L]]--;\\n            if (m[a[L]] === 0) uniq--;\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t + 1) - atLeast(a, t);\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Array(n + 1).fill(0);\\n        let uniq = 0;\\n        let L = 0;\\n        let cc = 0;\\n        for (let R = 0; R < n; R++) {\\n            if (m[a[R]] === 0) uniq++;\\n            m[a[R]]++;\\n            for (; uniq > t; L++) {\\n                m[a[L]]--;\\n                if (m[a[L]] === 0) uniq--;\\n            }\\n            cc += R - L + 1;\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t) - atLeast(a, t - 1);\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    class MapUnique {\\n        m = new Map();\\n        uniq = 0;\\n\\n        get size() {\\n            return this.uniq;\\n        }\\n        inc(e) {\\n            if (this.m.has(e) === false) this.uniq++;\\n            this.m.set(e, (this.m.get(e) || 0) + 1);\\n        }\\n        dec(e) {\\n            this.m.set(e, (this.m.get(e) || 0) - 1);\\n            if (this.m.get(e) === 0) {\\n                this.m.delete(e);\\n                this.uniq--;\\n            }\\n        }\\n    }\\n    let m1 = new MapUnique();\\n    let m2 = new MapUnique();\\n    let n = a.length;\\n    let cc = 0;\\n    let L = 0;\\n    let R = 0;\\n    for (let i = 0; i < n; i++) {\\n        while (L < n && m1.size < t) {\\n            m1.inc(a[L]);\\n            L += 1;\\n        }\\n        while (R < n && m2.size < t + 1) {\\n            m2.inc(a[R]);\\n            R += 1;\\n        }\\n        if (m1.size < t) {\\n            break;\\n        }\\n        if (m2.size < t + 1) {\\n            R = n + 1;\\n        }\\n        cc += R - L;\\n        m1.dec(a[i]);\\n        m2.dec(a[i]);\\n    }\\n    return cc;\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        cc = 0,\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        m = new Array(n + 1).fill(0);\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) uniques++;\\n        m[e]++;\\n\\n        while (uniques > t) {\\n            m[a[L]]--;\\n            if (m[a[L]] === 0) {\\n                uniques--;\\n                leftMostExtra = 0;\\n            }\\n            L++;\\n        }\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            leftMostExtra++;\\n            L++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        cc = 0,\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        m = new Array(n + 1).fill(0);\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) uniques++;\\n        m[e]++;\\n\\n        if (uniques > t) {\\n            m[a[L]]--;\\n            uniques--;\\n            leftMostExtra = 0;\\n            L++;\\n        }\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            leftMostExtra++;\\n            L++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        m = new Array(n + 1).fill(0),\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        cc = 0;\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) {\\n            uniques++;\\n            if (uniques > t) {\\n                m[a[L]]--;\\n                uniques--;\\n                L++;\\n                leftMostExtra = 0;\\n            }\\n        }\\n        m[e]++;\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            L++;\\n            leftMostExtra++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        m = new Array(n + 1).fill(0),\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        cc = 0;\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) {\\n            uniques++;\\n            if (uniques > t) {\\n                m[a[L]]--;\\n                uniques--;\\n                L++;\\n                leftMostExtra = 0;\\n            }\\n        }\\n        m[e]++;\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            L++;\\n            leftMostExtra++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110154,
                "title": "key-idea-behind-sliding-window-python",
                "content": "This problem is a bit similar to: https://leetcode.com/problems/count-number-of-nice-subarrays/description/\\n\\n**The key idea is:**\\n```\\nlet f(k) = no. of subarrays with at most k \"something\"\\nno. of subarrays with exactly k \"something\" = f(k) - f(k-1)\\n```\\nThe question to ask now is,\\n**find the number of subarrays with at most k distinct integers**\\n\\n**Approach**\\nUse two pointers and hashmap to keep track of elements in the window\\nif number of elements in window > k, move the left pointer to bring count back to k\\n\\n**Time: O(n)\\nSpace: O(n)**\\n```\\ndef subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\n    def countAtMost(k):\\n        i = ans = 0\\n        elements = defaultdict(int)\\n        for j in range(len(nums)):\\n            elements[nums[j]] += 1\\n            while len(elements) > k:\\n                elements[nums[i]] -= 1\\n                if not elements[nums[i]]:\\n                    del elements[nums[i]]\\n                i += 1\\n            ans += j - i + 1\\n        return ans\\n    \\n    return countAtMost(k) - countAtMost(k-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nlet f(k) = no. of subarrays with at most k \"something\"\\nno. of subarrays with exactly k \"something\" = f(k) - f(k-1)\\n```\n```\\ndef subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\n    def countAtMost(k):\\n        i = ans = 0\\n        elements = defaultdict(int)\\n        for j in range(len(nums)):\\n            elements[nums[j]] += 1\\n            while len(elements) > k:\\n                elements[nums[i]] -= 1\\n                if not elements[nums[i]]:\\n                    del elements[nums[i]]\\n                i += 1\\n            ans += j - i + 1\\n        return ans\\n    \\n    return countAtMost(k) - countAtMost(k-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3074199,
                "title": "substract-atmost-k-1-distinct-from-atmost-k-distinct",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(vector<int>& a, int k)\\n    {\\n        \\n        int n = a.size();\\n        int res=0,ans=0;\\n        int j=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[a[i]]++;\\n            while(mp.size()>k && j<n)\\n            {\\n                mp[a[j]]--;\\n                if(mp[a[j]] == 0)\\n                    mp.erase(a[j]);\\n                j++;\\n            }\\n            \\n            res+=(i-j+1);\\n        }\\n        return res;\\n    }\\n    \\n    /*\\n    \\n    brute force \\n    \\n            for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> mp;\\n            for(int j=i;j<n;j++)\\n            {\\n                if(mp.size()>k)\\n                    break;\\n                mp[a[j]]++;\\n                if(mp.size()==k)\\n                    res++;\\n                \\n            }\\n        }\\n\\n    \\n    */\\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        \\n        \\n        int n = a.size();\\n        int res=0;\\n        res = solve(a,k)-solve(a,k-1);\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(vector<int>& a, int k)\\n    {\\n        \\n        int n = a.size();\\n        int res=0,ans=0;\\n        int j=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[a[i]]++;\\n            while(mp.size()>k && j<n)\\n            {\\n                mp[a[j]]--;\\n                if(mp[a[j]] == 0)\\n                    mp.erase(a[j]);\\n                j++;\\n            }\\n            \\n            res+=(i-j+1);\\n        }\\n        return res;\\n    }\\n    \\n    /*\\n    \\n    brute force \\n    \\n            for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> mp;\\n            for(int j=i;j<n;j++)\\n            {\\n                if(mp.size()>k)\\n                    break;\\n                mp[a[j]]++;\\n                if(mp.size()==k)\\n                    res++;\\n                \\n            }\\n        }\\n\\n    \\n    */\\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        \\n        \\n        int n = a.size();\\n        int res=0;\\n        res = solve(a,k)-solve(a,k-1);\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743868,
                "title": "java-easy-hashmap-solution-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmost(nums,k)-atmost(nums,k-1);\\n    }\\n    public int atmost(int[] nums, int k){\\n        int res = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int j = -1;\\n        for(int i = 0; i<nums.length; i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            while(j<i && map.size()>k){\\n                j++;\\n                if(map.get(nums[j])==1){\\n                    map.remove(nums[j]);\\n                }else{\\n                    map.put(nums[j],map.get(nums[j])-1);\\n                }\\n            }\\n            res += i-j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmost(nums,k)-atmost(nums,k-1);\\n    }\\n    public int atmost(int[] nums, int k){\\n        int res = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int j = -1;\\n        for(int i = 0; i<nums.length; i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            while(j<i && map.size()>k){\\n                j++;\\n                if(map.get(nums[j])==1){\\n                    map.remove(nums[j]);\\n                }else{\\n                    map.put(nums[j],map.get(nums[j])-1);\\n                }\\n            }\\n            res += i-j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626182,
                "title": "python-sliding-window-hashmap",
                "content": "```\\nclass Solution(object):\\n    def subarraysWithKDistinct(self, nums, k):\\n        return self.atmostK(nums, k) - self.atmostK(nums, k - 1)\\n    def atmostK(self, nums, k):\\n        hashmap = defaultdict(int)\\n        left = 0\\n        right = 0\\n        ans = 0\\n        while right < len(nums):\\n            hashmap[nums[right]] += 1\\n            while len(hashmap) > k:\\n                hashmap[nums[left]] -= 1\\n                if hashmap[nums[left]] == 0:\\n                    del hashmap[nums[left]]\\n                left += 1\\n            ans += right - left + 1\\n            right += 1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subarraysWithKDistinct(self, nums, k):\\n        return self.atmostK(nums, k) - self.atmostK(nums, k - 1)\\n    def atmostK(self, nums, k):\\n        hashmap = defaultdict(int)\\n        left = 0\\n        right = 0\\n        ans = 0\\n        while right < len(nums):\\n            hashmap[nums[right]] += 1\\n            while len(hashmap) > k:\\n                hashmap[nums[left]] -= 1\\n                if hashmap[nums[left]] == 0:\\n                    del hashmap[nums[left]]\\n                left += 1\\n            ans += right - left + 1\\n            right += 1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625981,
                "title": "subarrays-with-k-different-integers-solution-java",
                "content": "class Solution {\\n  public int subarraysWithKDistinct(int[] A, int K) {\\n    return subarraysWithAtMostKDistinct(A, K) - subarraysWithAtMostKDistinct(A, K - 1);\\n  }\\n\\n  private int subarraysWithAtMostKDistinct(int[] A, int K) {\\n    int ans = 0;\\n    int[] count = new int[A.length + 1];\\n\\n    for (int l = 0, r = 0; r < A.length; ++r) {\\n      if (++count[A[r]] == 1)\\n        --K;\\n      while (K == -1)\\n        if (--count[A[l++]] == 0)\\n          ++K;\\n      ans += r - l + 1; // A[l..r], A[l + 1..r], ..., A[r]\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "class Solution {\\n  public int subarraysWithKDistinct(int[] A, int K) {\\n    return subarraysWithAtMostKDistinct(A, K) - subarraysWithAtMostKDistinct(A, K - 1);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2374110,
                "title": "easy-and-simple-java-solution",
                "content": "The problem can be simply solved by counting the subarrays in range of 1 - k and then subtracting the subarrays in range of 1 - (k - 1) with two pointers for both subarray count.\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n       return  count(nums, k) - count(nums, k - 1);\\n    }\\n\\n\\n       public int count(int[] nums, int k){\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int left = 0, right = 0, ans = 0;\\n        \\n        while(right < nums.length){\\n            hm.put(nums[right] , hm.getOrDefault(nums[right], 0) + 1);\\n            \\n            while(hm.size() == k + 1){\\n                hm.put(nums[left], hm.get(nums[left]) - 1);\\n                if(hm.get(nums[left]) == 0)\\n                    hm.remove(nums[left]);\\n                    left++;\\n            }\\n            ans += right - left + 1;\\n            right++;\\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n       return  count(nums, k) - count(nums, k - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2340510,
                "title": "easy-sliding-window-solution",
                "content": "**Brute Force**\\n*Brute force might won\\'t work, but you can understand  how things are working because optimise solution is variation of brute force  *\\n```\\n  public int subarraysWithKDistinct(int[] nums, int k) {\\n      \\n         int n=nums.length;\\n\\t\\tint ans=0;\\n        for(int i=0;i<n;i++){\\n              Set<Integer> set=new HashSet<>();\\n             for(int j=i;j<n;j++){\\n                 if(!set.contains(nums[j])) set.add(nums[j]);\\n                 if(set.size()==k)  ans++;\\n                 else if(set.size()>k) break;\\n             }\\n         }\\n        return ans;\\n    }\\n```\\n**Optimise Solution**\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n//      Subarray with exactly k distinct integer= (subarray with atmost k integer) - (subarray with armost k-1 integers)\\n        return f(nums,k)-f(nums,k-1);\\n    }\\n    int f(int[] nums, int k){\\n          int s=0;\\n        int ans=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int e=0;e<nums.length;e++){\\n            map.put(nums[e],map.getOrDefault(nums[e],0)+1);\\n        \\n          \\n            while(map.size()>k){\\n                int p=map.get(nums[s]);\\n                map.put(nums[s],p-1);\\n                if(p==1) map.remove(nums[s]);\\n              \\n                s++;\\n                // ans++;\\n            }\\n            ans+=e-s+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n  public int subarraysWithKDistinct(int[] nums, int k) {\\n      \\n         int n=nums.length;\\n\\t\\tint ans=0;\\n        for(int i=0;i<n;i++){\\n              Set<Integer> set=new HashSet<>();\\n             for(int j=i;j<n;j++){\\n                 if(!set.contains(nums[j])) set.add(nums[j]);\\n                 if(set.size()==k)  ans++;\\n                 else if(set.size()>k) break;\\n             }\\n         }\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n//      Subarray with exactly k distinct integer= (subarray with atmost k integer) - (subarray with armost k-1 integers)\\n        return f(nums,k)-f(nums,k-1);\\n    }\\n    int f(int[] nums, int k){\\n          int s=0;\\n        int ans=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int e=0;e<nums.length;e++){\\n            map.put(nums[e],map.getOrDefault(nums[e],0)+1);\\n        \\n          \\n            while(map.size()>k){\\n                int p=map.get(nums[s]);\\n                map.put(nums[s],p-1);\\n                if(p==1) map.remove(nums[s]);\\n              \\n                s++;\\n                // ans++;\\n            }\\n            ans+=e-s+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254737,
                "title": "easier-version-atmost-k-atmost-k-1",
                "content": "```\\n int tom(vector<int>& nums,int k){\\n        int i=0,j=0;\\n        int n=nums.size();\\n        int ans=0;\\n      \\n        if(k==0){\\n            return 0;\\n        }\\n      \\n        unordered_map<int,int> mp;\\n        mp[nums[0]]++;\\n        \\n        while(i<n){\\n            \\n\\n           \\n            if(mp.size()<=k){\\n      \\n                ans=ans+(i-j+1);\\n                \\n               \\n                i++;\\n                if(i==n){\\n                    break;\\n                }\\n                          mp[nums[i]]++;\\n            }\\n            else if(mp.size()>k){\\n               \\n                mp[nums[j]]--;\\n              \\n                if(mp[nums[j]]==0){\\n                    mp.erase(nums[j]);\\n                }\\n                j++;\\n            }\\n        }\\n      \\n      \\n        return ans;\\n        \\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n       \\n    int n=nums.size();\\n       \\n       int c=tom(nums,k);\\n        int d=tom(nums,k-1);\\n    \\n      \\n        return (c-d);\\n        \\n        \\n      \\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n int tom(vector<int>& nums,int k){\\n        int i=0,j=0;\\n        int n=nums.size();\\n        int ans=0;\\n      \\n        if(k==0){\\n            return 0;\\n        }\\n      \\n        unordered_map<int,int> mp;\\n        mp[nums[0]]++;\\n        \\n        while(i<n){\\n            \\n\\n           \\n            if(mp.size()<=k){\\n      \\n                ans=ans+(i-j+1);\\n                \\n               \\n                i++;\\n                if(i==n){\\n                    break;\\n                }\\n                          mp[nums[i]]++;\\n            }\\n            else if(mp.size()>k){\\n               \\n                mp[nums[j]]--;\\n              \\n                if(mp[nums[j]]==0){\\n                    mp.erase(nums[j]);\\n                }\\n                j++;\\n            }\\n        }\\n      \\n      \\n        return ans;\\n        \\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n       \\n    int n=nums.size();\\n       \\n       int c=tom(nums,k);\\n        int d=tom(nums,k-1);\\n    \\n      \\n        return (c-d);\\n        \\n        \\n      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224922,
                "title": "sliding-window-with-c-for-loop-simplest-solution",
                "content": "Conclusion: number of subarrays with k different integers = (number of subarrays with number of different integers less than equal to k ) - (number of subarrays with number of different integers less than equal to k-1 )\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k){\\n        unordered_map<int, int> maps;\\n        int left = 0, res = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            maps[nums[i]]++;\\n            while(maps.size() > k){\\n                maps[nums[left]]--;\\n                if(maps[nums[left]] == 0)  maps.erase(nums[left]);\\n                left++;\\n            }\\n            res += i - left + 1;\\n        }\\n        return res;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return helper(nums, k) - helper(nums, k - 1);\\n    }\\n};\\n```\\nThe helper function can also be applied in 340. If don\\'t know the helper function mechanism, do 340 first.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k){\\n        unordered_map<int, int> maps;\\n        int left = 0, res = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            maps[nums[i]]++;\\n            while(maps.size() > k){\\n                maps[nums[left]]--;\\n                if(maps[nums[left]] == 0)  maps.erase(nums[left]);\\n                left++;\\n            }\\n            res += i - left + 1;\\n        }\\n        return res;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return helper(nums, k) - helper(nums, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218716,
                "title": "tricky-sliding-window-in-1-loop-only",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    int subarraysWithKDistinct(vector<int> &nums, int k)\\n    {\\n\\n        int s = 0;\\n        int e = 0;\\n\\n        unordered_map<int, int> freq;\\n\\n        int res = 0;\\n        int prev = 0;\\n\\n        for (; e < nums.size(); e++)\\n        {\\n\\n            freq[nums[e]] += 1;\\n\\n            int mysub = 0;\\n\\n            if (freq.size() == k)\\n            {\\n\\n                if (s != 0 && nums[s - 1] != nums[e])\\n                    prev = 0;\\n\\n                while (s <= e && freq.size() == k)\\n                {\\n\\n                    mysub++;\\n\\n                    int n = nums[s++];\\n\\n                    freq[n] -= 1;\\n\\n                    if (freq[n] == 0)\\n                        freq.erase(n);\\n                }\\n            }\\n\\n            prev += mysub;\\n            res += prev;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    int subarraysWithKDistinct(vector<int> &nums, int k)\\n    {\\n\\n        int s = 0;\\n        int e = 0;\\n\\n        unordered_map<int, int> freq;\\n\\n        int res = 0;\\n        int prev = 0;\\n\\n        for (; e < nums.size(); e++)\\n        {\\n\\n            freq[nums[e]] += 1;\\n\\n            int mysub = 0;\\n\\n            if (freq.size() == k)\\n            {\\n\\n                if (s != 0 && nums[s - 1] != nums[e])\\n                    prev = 0;\\n\\n                while (s <= e && freq.size() == k)\\n                {\\n\\n                    mysub++;\\n\\n                    int n = nums[s++];\\n\\n                    freq[n] -= 1;\\n\\n                    if (freq[n] == 0)\\n                        freq.erase(n);\\n                }\\n            }\\n\\n            prev += mysub;\\n            res += prev;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213823,
                "title": "c-o-n-easy-solution",
                "content": "**C++ Code:**\\n**Time Complexity : O(n)**\\n**Approach:**\\nTo directly count the subarrays with exactly K different integers is hard but to find the count of subarrays with at most K different integers is easy. So the idea is to find the count of subarrays with at most K different integers, let it be C(K), and the count of subarrays with at most (K \\u2013 1) different integers, let it be C(K \\u2013 1) and finally take their difference, C(K) \\u2013 C(K \\u2013 1) which is the required answer.\\nCount of subarrays with at most K different elements can be easily calculated through the sliding window technique. The idea is to keep expanding the right boundary of the window till the count of distinct elements in the window is less than or equal to K and when the count of distinct elements inside the window becomes more than K, start shrinking the window from the left till the count becomes less than or equal to K. Also for every expansion, keep counting the subarrays as right \\u2013 left + 1 where right and left are the boundaries of the current window.\\n\\n```\\n    int solve(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int>m;\\n        int ans = 0;\\n        int i=0,j=0;\\n        while(i<nums.size())\\n        {\\n            m[nums[i]]++;\\n            while(m.size()>k)\\n            {\\n                m[nums[j]]--;\\n                if(m[nums[j]]==0) m.erase(nums[j]);\\n                j++;\\n            }\\n            ans += (i-j+1);\\n            i++;\\n        }\\n     return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {  \\n     int ans = solve(nums,k)-solve(nums,k-1);\\n    return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n    int solve(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int>m;\\n        int ans = 0;\\n        int i=0,j=0;\\n        while(i<nums.size())\\n        {\\n            m[nums[i]]++;\\n            while(m.size()>k)\\n            {\\n                m[nums[j]]--;\\n                if(m[nums[j]]==0) m.erase(nums[j]);\\n                j++;\\n            }\\n            ans += (i-j+1);\\n            i++;\\n        }\\n     return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {  \\n     int ans = solve(nums,k)-solve(nums,k-1);\\n    return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2181157,
                "title": "hard-problem-using-easy-sliding-window-concept-o-n",
                "content": "****we will find total subarrays with atmost k diff int and atmost k-1 diff int using sliding window \\n#subtraction of this 2 will give us subarrays with exactly k diff int ,pls upvote if u like the solun\\n# atmost(k)-atmost(k-1)=exactly k \\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums,int k){\\n        unordered_map<int,int>map;\\n        int i=0,j=0,ans=0;\\n        while(j<nums.size()){\\n            map[nums[j]]++;\\n            while(map.size()>k){\\n                map[nums[i]]--;\\n                if(map[nums[i]]==0)map.erase(nums[i]);\\n                i++;}\\n            ans+=j-i+1;\\n            j++;}\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k){\\n        return helper(nums,k)-helper(nums,k-1);  }  \\n    };\\n```\\n**pls upvote if u got the solun**\\nsimilar prob-\\n[https://leetcode.com/problems/count-vowel-substrings-of-a-string/](http://)",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums,int k){\\n        unordered_map<int,int>map;\\n        int i=0,j=0,ans=0;\\n        while(j<nums.size()){\\n            map[nums[j]]++;\\n            while(map.size()>k){\\n                map[nums[i]]--;\\n                if(map[nums[i]]==0)map.erase(nums[i]);\\n                i++;}\\n            ans+=j-i+1;\\n            j++;}\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k){\\n        return helper(nums,k)-helper(nums,k-1);  }  \\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124668,
                "title": "c-solution-o-n-without-map",
                "content": "2 Slide windows to keep k or k-1 diff values.\\nTime O(N)\\nSpace O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> cb(n+1);\\n        vector<int> ce(n+1);\\n        int kb = 0;\\n        int ke = 0;\\n        int b = 0;\\n        int e = 0;\\n        int ans = 0;\\n        for(auto v: nums) {\\n            if(cb[v]++ == 0) kb++;\\n            if(ce[v]++ == 0) ke++;\\n            \\n            while(kb > k) {\\n                if(--cb[nums[b++]] == 0) kb--;\\n            }\\n            while(ke >= k) {\\n                if(--ce[nums[e++]] == 0) ke--;\\n            }\\n            ans += e-b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> cb(n+1);\\n        vector<int> ce(n+1);\\n        int kb = 0;\\n        int ke = 0;\\n        int b = 0;\\n        int e = 0;\\n        int ans = 0;\\n        for(auto v: nums) {\\n            if(cb[v]++ == 0) kb++;\\n            if(ce[v]++ == 0) ke++;\\n            \\n            while(kb > k) {\\n                if(--cb[nums[b++]] == 0) kb--;\\n            }\\n            while(ke >= k) {\\n                if(--ce[nums[e++]] == 0) ke--;\\n            }\\n            ans += e-b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122607,
                "title": "python-atmostk-algorithm",
                "content": "```\\nimport collections\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        # exact k = atMostK(k) - atMost(k-1)\\n        def atMostK(k):\\n            counter = collections.defaultdict(int)\\n            res = i = 0\\n            for j in range(len(nums)):\\n                if counter[nums[j]] == 0:\\n                    k -= 1\\n                counter[nums[j]] += 1\\n                while k < 0:\\n                    counter[nums[i]] -= 1\\n                    if counter[nums[i]] == 0:\\n                        k += 1\\n                    i += 1\\n                res += j - i + 1\\n            return res\\n        return atMostK(k) - atMostK(k-1)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        # exact k = atMostK(k) - atMost(k-1)\\n        def atMostK(k):\\n            counter = collections.defaultdict(int)\\n            res = i = 0\\n            for j in range(len(nums)):\\n                if counter[nums[j]] == 0:\\n                    k -= 1\\n                counter[nums[j]] += 1\\n                while k < 0:\\n                    counter[nums[i]] -= 1\\n                    if counter[nums[i]] == 0:\\n                        k += 1\\n                    i += 1\\n                res += j - i + 1\\n            return res\\n        return atMostK(k) - atMostK(k-1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111046,
                "title": "python3-simple-sliding-window-based-solution",
                "content": "```\\n\"\"\"https://leetcode.com/problems/subarrays-with-k-different-integers/\"\"\"\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        def subarraysWithAtMostKDistinct(size):\\n            count, left, freq_dict = 0, 0, defaultdict(int)\\n            for right, num in enumerate(nums):\\n                freq_dict[num] += 1\\n                while len(freq_dict) > size:\\n                    num_to_remove = nums[left]\\n                    freq_dict[num_to_remove] -= 1\\n                    if freq_dict[num_to_remove] == 0:\\n                        freq_dict.pop(num_to_remove)\\n                    left += 1\\n                count += right - left + 1\\n            return count\\n\\n        return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/subarrays-with-k-different-integers/\"\"\"\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        def subarraysWithAtMostKDistinct(size):\\n            count, left, freq_dict = 0, 0, defaultdict(int)\\n            for right, num in enumerate(nums):\\n                freq_dict[num] += 1\\n                while len(freq_dict) > size:\\n                    num_to_remove = nums[left]\\n                    freq_dict[num_to_remove] -= 1\\n                    if freq_dict[num_to_remove] == 0:\\n                        freq_dict.pop(num_to_remove)\\n                    left += 1\\n                count += right - left + 1\\n            return count\\n\\n        return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2052227,
                "title": "c-hashmap-sliding-window-explanation-linked-thoughts-added",
                "content": "Awesome explanation of the problem:\\n\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/672979/Analysis-and-explanation-with-Visualization\\n\\nWhen I first attempted the problem, my mind went to combinatorics, but I couldn\\'t exactly figure out why that was the case. The post above provided much clarity. \\n\\nDefinitely a \"hard\" problem, but once you figure out the discrete math behind it (for anyone with a Computer Science degree) I hope you come to appreciate this problem as I have. With that being said, I would never give this to anyone who is being interviewed without MASSIVE hints, haha.\\n\\nHappy Coding!\\n```\\npublic class Solution {\\n    \\n    public int SubarraysWithKDistinct(int[] nums, int k) \\n    {    \\n        return _atMost(nums, k) - _atMost(nums, k - 1);\\n    }\\n    \\n    private int _atMost(int[] nums, int k)\\n    {\\n        var answer = 0;\\n        var fast = 0;\\n        var slow = 0;\\n        var map = new Dictionary<int, int>();\\n        var unique = 0;\\n        \\n        while(fast < nums.Length)\\n        {\\n            var curr = nums[fast];\\n            \\n            if(!map.ContainsKey(curr))\\n            {\\n                map.Add(curr, 0);\\n            }\\n            \\n            map[curr]++;\\n            \\n            if(map[curr] == 1)\\n            {\\n                unique++;   //Since we\\'re adding a different integer for this window sliding, we increase unique by 1 \\n            }\\n            \\n            //Close the window.\\n            while(unique > k)\\n            {           \\n                map[nums[slow]]--;\\n                \\n                /*\\n                    If we completely remove an element from our window closing (aka, if the count in the map is 0),\\n                    then we decrement unique, ending our closing of the window\\n                */\\n                if(map[nums[slow]] == 0)\\n                {\\n                    unique--;\\n                }\\n                \\n                slow++;\\n            }\\n            \\n            answer += fast - slow + 1;  //Flash back to discrete mathematics. Fun times!\\n            \\n            fast++;     //Slide the window\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    public int SubarraysWithKDistinct(int[] nums, int k) \\n    {    \\n        return _atMost(nums, k) - _atMost(nums, k - 1);\\n    }\\n    \\n    private int _atMost(int[] nums, int k)\\n    {\\n        var answer = 0;\\n        var fast = 0;\\n        var slow = 0;\\n        var map = new Dictionary<int, int>();\\n        var unique = 0;\\n        \\n        while(fast < nums.Length)\\n        {\\n            var curr = nums[fast];\\n            \\n            if(!map.ContainsKey(curr))\\n            {\\n                map.Add(curr, 0);\\n            }\\n            \\n            map[curr]++;\\n            \\n            if(map[curr] == 1)\\n            {\\n                unique++;   //Since we\\'re adding a different integer for this window sliding, we increase unique by 1 \\n            }\\n            \\n            //Close the window.\\n            while(unique > k)\\n            {           \\n                map[nums[slow]]--;\\n                \\n                /*\\n                    If we completely remove an element from our window closing (aka, if the count in the map is 0),\\n                    then we decrement unique, ending our closing of the window\\n                */\\n                if(map[nums[slow]] == 0)\\n                {\\n                    unique--;\\n                }\\n                \\n                slow++;\\n            }\\n            \\n            answer += fast - slow + 1;  //Flash back to discrete mathematics. Fun times!\\n            \\n            fast++;     //Slide the window\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964899,
                "title": "13-lines-python",
                "content": "Solution relies on the fact that:\\n\\nNumber of subarrays with K different integers = number of subarrays with at most K different integers - number of subarrays with at most K-1 different integers.\\n\\n```python\\ndef subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\tdef atMostk(k):\\n\\t\\tleft, res, cnt = 0, 0, {}\\n\\t\\tfor right, n in enumerate(nums):\\n\\t\\t\\tcnt[n] = cnt.setdefault(n,0)+1\\n\\t\\t\\tk -= cnt[n] == 1\\n\\t\\t\\twhile left <= right and k < 0:\\n\\t\\t\\t\\tcnt[nums[left]] -= 1\\n\\t\\t\\t\\tk += cnt[nums[left]] == 0\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\tres += (right - left + 1)\\n\\t\\treturn res\\n\\treturn atMostk(k) - atMostk(k-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\ndef subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\tdef atMostk(k):\\n\\t\\tleft, res, cnt = 0, 0, {}\\n\\t\\tfor right, n in enumerate(nums):\\n\\t\\t\\tcnt[n] = cnt.setdefault(n,0)+1\\n\\t\\t\\tk -= cnt[n] == 1\\n\\t\\t\\twhile left <= right and k < 0:\\n\\t\\t\\t\\tcnt[nums[left]] -= 1\\n\\t\\t\\t\\tk += cnt[nums[left]] == 0\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\tres += (right - left + 1)\\n\\t\\treturn res\\n\\treturn atMostk(k) - atMostk(k-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1871340,
                "title": "c",
                "content": "Explanation : https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/360147/Share-my-solution\\n\\n```\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int j=0, u=0, res=0, maxi=0, nsub=0;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<nums.size(); i++) {\\n            // Part 1 : Count Unique nums\\n            m[nums[i]]++;\\n            if (m[nums[i]]==1)\\n                u++;\\n            \\n            // Part 2 : If Unique nums == k, find maxi upto where uniques are still k\\n            if(u==k) {\\n                maxi = i;\\n                while(maxi+1<nums.size() && m[nums[maxi+1]]>0)\\n                    maxi++;\\n                // num of valid subarrays :\\n                nsub = maxi - i + 1;\\n            }\\n            \\n            // Part 3 : reduce window from left, while maintaining uniques to k\\n            // for every iteration, add previoursly calculated num of valid subarrays.\\n            while (u==k && j<nums.size()) {\\n                res += nsub;\\n                m[nums[j]]--;\\n                if (m[nums[j]] == 0)\\n                    u--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int j=0, u=0, res=0, maxi=0, nsub=0;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<nums.size(); i++) {\\n            // Part 1 : Count Unique nums\\n            m[nums[i]]++;\\n            if (m[nums[i]]==1)\\n                u++;\\n            \\n            // Part 2 : If Unique nums == k, find maxi upto where uniques are still k\\n            if(u==k) {\\n                maxi = i;\\n                while(maxi+1<nums.size() && m[nums[maxi+1]]>0)\\n                    maxi++;\\n                // num of valid subarrays :\\n                nsub = maxi - i + 1;\\n            }\\n            \\n            // Part 3 : reduce window from left, while maintaining uniques to k\\n            // for every iteration, add previoursly calculated num of valid subarrays.\\n            while (u==k && j<nums.size()) {\\n                res += nsub;\\n                m[nums[j]]--;\\n                if (m[nums[j]] == 0)\\n                    u--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808952,
                "title": "single-pass-java-solution-beat-95",
                "content": "class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        int [] countLongest = new int[nums.length + 1];\\n        int [] countShortest = new int[nums.length + 1];\\n        int total =0, result=0;\\n        for(int leftLongest =0, leftShortest=0, right =0; right < nums.length ; right ++) {\\n            \\n            countLongest[nums[right]]++;\\n            countShortest[nums[right]]++;\\n            if(countLongest[nums[right]] == 1 ) {\\n               total ++;    \\n            }\\n            \\n          //move Leftlongest\\n            while(leftLongest < right &&  total > k) {\\n                countLongest[nums[leftLongest]]--;\\n                if(countLongest[nums[leftLongest]] == 0) {\\n                    total--;\\n                }\\n                leftLongest++;\\n            }\\n            \\n            //move LeftShortest\\n            while(leftShortest < right &&  (countShortest[nums[leftShortest]] > 1|| leftShortest < leftLongest  )) {\\n                    countShortest[ nums[leftShortest]]--;\\n                    leftShortest++;\\n            }\\n           \\n            \\n            if(total == k) {\\n                result += leftShortest-leftLongest+1;\\n\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        int [] countLongest = new int[nums.length + 1];\\n        int [] countShortest = new int[nums.length + 1];\\n        int total =0, result=0;\\n        for(int leftLongest =0, leftShortest=0, right =0; right < nums.length ; right ++) {\\n            \\n            countLongest[nums[right]]++;\\n            countShortest[nums[right]]++;\\n            if(countLongest[nums[right]] == 1 ) {\\n               total ++;    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1751427,
                "title": "python-sliding-window-dict",
                "content": "\\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], K: int) -> int:\\n\\n        def atMostK(nums, K):\\n            n = len(nums)\\n            pool = Counter()\\n            left = right = 0\\n            ct = 0\\n            \\n            while right < n:\\n                pool[nums[right]] += 1\\n                \\n                while len(pool) > K and left <= right:\\n                    pool[nums[left]] -= 1\\n                    if not pool[nums[left]]:\\n                        del pool[nums[left]]\\n                    left += 1\\n                \\n                ct += right - left + 1\\n                right += 1\\n            return ct\\n        return atMostK(nums, K) - atMostK(nums, K-1)\\n                    \\n                \\n                    \\n                \\n        \\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], K: int) -> int:\\n\\n        def atMostK(nums, K):\\n            n = len(nums)\\n            pool = Counter()\\n            left = right = 0\\n            ct = 0\\n            \\n            while right < n:\\n                pool[nums[right]] += 1\\n                \\n                while len(pool) > K and left <= right:\\n                    pool[nums[left]] -= 1\\n                    if not pool[nums[left]]:\\n                        del pool[nums[left]]\\n                    left += 1\\n                \\n                ct += right - left + 1\\n                right += 1\\n            return ct\\n        return atMostK(nums, K) - atMostK(nums, K-1)\\n                    \\n                \\n                    \\n                \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1692176,
                "title": "c-solution-based-on-similar-problem-with-explanation",
                "content": "The solution is bassed on a similar problem https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/ :\\nWe are finding the number of substrings that can contain all three characters.\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubstrings(string s) {\\n        unordered_map<char, int> hmap;\\n        int res = 0 , i = 0;\\n        for (int j = 0; j < s.size(); ++j) {\\n            ++hmap[s[j]];\\n            while (hmap[\\'a\\'] && hmap[\\'b\\'] && hmap[\\'c\\']) {\\n                --hmap[s[i++]];\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n};\\n```\\nOur new problem sounds similar to the above problem, so we can apply the same techique to this problem:\\n```\\nclass Solution {\\npublic:\\n    int sliding(vector<int>& A, int K) {\\n        unordered_map<int, int> hmap;\\n        int res = 0 , i = 0, cnt = 0;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!hmap[A[j]]++) cnt++;\\n            while (cnt == K) {\\n                if (--hmap[A[i]] == 0) {\\n                    cnt--;\\n                }\\n                i++;\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return sliding(A, K) - sliding(A, K + 1);\\n    }\\n};\\n```\\nIf we can apply exactly the same algorithm as in first problem we will end up with more subarrays:\\n`return sliding(A, K)` for input: `[1,2,1,2,3]` will return `10 `-> this is because we will have redundant`[1,2,1,2,3], [2,1,2,3] and [1,2,3]` subarrays in our result set.\\nIn order to remove these subarrays from the result set we have to apply the same algorithm for K + 1 and substract them from K:  `return sliding(A, K) - sliding(A, K + 1);`\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubstrings(string s) {\\n        unordered_map<char, int> hmap;\\n        int res = 0 , i = 0;\\n        for (int j = 0; j < s.size(); ++j) {\\n            ++hmap[s[j]];\\n            while (hmap[\\'a\\'] && hmap[\\'b\\'] && hmap[\\'c\\']) {\\n                --hmap[s[i++]];\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sliding(vector<int>& A, int K) {\\n        unordered_map<int, int> hmap;\\n        int res = 0 , i = 0, cnt = 0;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!hmap[A[j]]++) cnt++;\\n            while (cnt == K) {\\n                if (--hmap[A[i]] == 0) {\\n                    cnt--;\\n                }\\n                i++;\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return sliding(A, K) - sliding(A, K + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676641,
                "title": "typescript-sliding-window",
                "content": "```\\nfunction subarraysWithKDistinct(nums: number[], k: number): number {\\n    if (nums.length === 1) {\\n        return Number(k === 1)\\n    }\\n    \\n    // initialize state\\n    const freq = new Map<number, number>([[nums[0], 1]])\\n    let left = 0\\n    let right = 1\\n    let total = k === 1 ? 1 : 0\\n    freq.set(nums[1], (freq.get(nums[1]) || 0) + 1)\\n    \\n    // track current number of prefixes with k distinct values\\n    let prefixes = 1\\n    \\n    function decrementMap(num: number): void {\\n        freq.set(num, freq.get(num) - 1)\\n        if (!freq.get(num)) {\\n            freq.delete(num)\\n        }\\n    }\\n    \\n    while (right < nums.length) {\\n        if (freq.size === k) {\\n            if (freq.get(nums[left]) > 1) {\\n                // we can remove this value and keep freq.size === k\\n                // increment prefixes\\n                prefixes++\\n                \\n                // remove value from left side of subarray\\n                decrementMap(nums[left])\\n\\n                left++\\n            } else {\\n                // collect on prefixes\\n                total += prefixes\\n                right++\\n                freq.set(nums[right], (freq.get(nums[right]) || 0) + 1)\\n            }\\n        } else if (freq.size < k) {\\n            // keep expanding right, looking for new unique values\\n            right++\\n            freq.set(nums[right], (freq.get(nums[right]) || 0) + 1)\\n        } else {\\n            // too many distinct values, reset prefixes, start moving left pointer to drop distinct values\\n            prefixes = 1\\n\\n            decrementMap(nums[left])\\n            left++            \\n        }\\n    }\\n    \\n    return total\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction subarraysWithKDistinct(nums: number[], k: number): number {\\n    if (nums.length === 1) {\\n        return Number(k === 1)\\n    }\\n    \\n    // initialize state\\n    const freq = new Map<number, number>([[nums[0], 1]])\\n    let left = 0\\n    let right = 1\\n    let total = k === 1 ? 1 : 0\\n    freq.set(nums[1], (freq.get(nums[1]) || 0) + 1)\\n    \\n    // track current number of prefixes with k distinct values\\n    let prefixes = 1\\n    \\n    function decrementMap(num: number): void {\\n        freq.set(num, freq.get(num) - 1)\\n        if (!freq.get(num)) {\\n            freq.delete(num)\\n        }\\n    }\\n    \\n    while (right < nums.length) {\\n        if (freq.size === k) {\\n            if (freq.get(nums[left]) > 1) {\\n                // we can remove this value and keep freq.size === k\\n                // increment prefixes\\n                prefixes++\\n                \\n                // remove value from left side of subarray\\n                decrementMap(nums[left])\\n\\n                left++\\n            } else {\\n                // collect on prefixes\\n                total += prefixes\\n                right++\\n                freq.set(nums[right], (freq.get(nums[right]) || 0) + 1)\\n            }\\n        } else if (freq.size < k) {\\n            // keep expanding right, looking for new unique values\\n            right++\\n            freq.set(nums[right], (freq.get(nums[right]) || 0) + 1)\\n        } else {\\n            // too many distinct values, reset prefixes, start moving left pointer to drop distinct values\\n            prefixes = 1\\n\\n            decrementMap(nums[left])\\n            left++            \\n        }\\n    }\\n    \\n    return total\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1559335,
                "title": "c-sliding-window-solution-for-992-subarrays-with-k-different-integers",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k) \\n    {\\n        int i = 0, j = 0, sz = nums.size(), good = 0 ;\\n        unordered_map<int, int> umap ;\\n        \\n        while(j<sz)\\n        {\\n            umap[nums[j]]++ ;\\n            \\n            if(umap.size() > k)\\n            {\\n                while(umap.size() > k)\\n                {\\n                    umap[nums[i]]-- ; \\n                    if(umap[nums[i]] == 0){ umap.erase(nums[i]) ;}\\n                    i++ ;\\n                }\\n                \\n            }\\n            good += j - i ;\\n            j++ ;\\n        }\\n        \\n        return good ;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k)\\n    {\\n        int a = helper(nums, k);\\n        int b = helper(nums, k-1);\\n        return a-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k) \\n    {\\n        int i = 0, j = 0, sz = nums.size(), good = 0 ;\\n        unordered_map<int, int> umap ;\\n        \\n        while(j<sz)\\n        {\\n            umap[nums[j]]++ ;\\n            \\n            if(umap.size() > k)\\n            {\\n                while(umap.size() > k)\\n                {\\n                    umap[nums[i]]-- ; \\n                    if(umap[nums[i]] == 0){ umap.erase(nums[i]) ;}\\n                    i++ ;\\n                }\\n                \\n            }\\n            good += j - i ;\\n            j++ ;\\n        }\\n        \\n        return good ;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k)\\n    {\\n        int a = helper(nums, k);\\n        int b = helper(nums, k-1);\\n        return a-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552981,
                "title": "java-sliding-window-with-three-pointers-o-n",
                "content": "This question hints you to use sliding window cause its crazy data scale (10^5) and its difficulty rating hard. But you will find trouble designing standard sliding window idea:\\n\\n- When we start the window, we usually put start and end both pointed at 0. And we would move end, until our window has K + 1 elements and stop right before that happens. \\n- Now we can no longer move end pointer, we should move start. Let\\'s say we recorded the # of subarrays between [start, end] during this pass. This can be done by recording the occurences when we  found K elements in the window (use hashset or counter array).\\n- We move start + 1.\\n- Now, problem happens: we reduce the start locations count in our hash map, but we still has K elements! We cannot move end, and we are not quite sure how many good arrays are there in [start + 1, end]. We will need to loop over from start the check again. -> This gives you O(N^2) complexity.\\n\\nThe ideal solution would be we need another tracker/pointer to track **location when K distint elements are FIRST satisfied**. So now the algorithm works like this: we name end pointer as last, recording the last position which satisfies K elements requirement. \\n- We have start and last pointing at 0. And we move last + 1, until when we reached an location where further moving gives you K+1 distinct elements. \\n- During the above process, we parallelly add another pointer called first, and we will stop as soon as we discover K element for the first time.\\n- Now, when a window get stuck, we have this result **#good arrays starting at start location**. We will iterate over all start locations from 0 to nums.length - 1.\\n- When our window get stuck, we move start + 1, and we will keep using the first and last pointers to update to the new start + 1 location\\'s first and last location. \\n- Essentially, this is a 3 pointer approach, where each pointer will need to move from 0 -> N.\\n\\nThe good thing for the proposed solution is, it is very straight forward in design, really tries its best to mimic standard sliding window appraoch. The bad thing is, I won\\'t call it easy to implement, especially under pressure.\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        // Like three pointers.\\n        // we pick a left pointer which is left bound\\n        // of the subarr. After that, we start two new pointers\\n        // first and last, first stands for first time sat.\\n        // last stands for last time sat.\\n        \\n        Map<Integer, Integer> firstSat = new HashMap<>();\\n        int start = 0;\\n        int first = 0;\\n        int last = 0;\\n        int n = nums.length;\\n        \\n        int res = 0;\\n        while (start < n) {\\n            while (first < n &&\\n                   firstSat.size() < k) {\\n                int c = firstSat.getOrDefault(nums[first], 0);\\n                firstSat.put(nums[first], c + 1);\\n                \\n                first += 1;\\n            }\\n            \\n            // last = first;\\n            while (last < n && \\n                   firstSat.containsKey(nums[last])) {\\n                last += 1;\\n            }\\n            \\n            // last now points to right most ind + 1\\n            res += firstSat.size() == k ? (last - first + 1) : 0;\\n            \\n            // move start\\n            int startValCount = firstSat.get(nums[start]);\\n            if (startValCount == 1) {\\n                firstSat.remove(nums[start]);\\n            } else {\\n                firstSat.put(nums[start], startValCount - 1);\\n            }\\n            \\n            start += 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        // Like three pointers.\\n        // we pick a left pointer which is left bound\\n        // of the subarr. After that, we start two new pointers\\n        // first and last, first stands for first time sat.\\n        // last stands for last time sat.\\n        \\n        Map<Integer, Integer> firstSat = new HashMap<>();\\n        int start = 0;\\n        int first = 0;\\n        int last = 0;\\n        int n = nums.length;\\n        \\n        int res = 0;\\n        while (start < n) {\\n            while (first < n &&\\n                   firstSat.size() < k) {\\n                int c = firstSat.getOrDefault(nums[first], 0);\\n                firstSat.put(nums[first], c + 1);\\n                \\n                first += 1;\\n            }\\n            \\n            // last = first;\\n            while (last < n && \\n                   firstSat.containsKey(nums[last])) {\\n                last += 1;\\n            }\\n            \\n            // last now points to right most ind + 1\\n            res += firstSat.size() == k ? (last - first + 1) : 0;\\n            \\n            // move start\\n            int startValCount = firstSat.get(nums[start]);\\n            if (startValCount == 1) {\\n                firstSat.remove(nums[start]);\\n            } else {\\n                firstSat.put(nums[start], startValCount - 1);\\n            }\\n            \\n            start += 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549411,
                "title": "java-simple-sliding-window",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        Map<Integer,Integer> window = new HashMap<>();\\n        \\n        int numberOfGoodSubarrays = 0;\\n        int l = 0, r = 0;\\n        int duplicates = 0;\\n        while (r < nums.length) {\\n            addToWindow(window, nums[r++]);\\n\\n            if (window.size() > k) {\\n                removeFromWindow(window, nums[l++]);\\n                duplicates = 0;\\n            }\\n\\n            while (window.get(nums[l]) > 1) {\\n                removeFromWindow(window, nums[l++]);\\n                duplicates++;\\n            }\\n            \\n            if (window.size() == k) {\\n                numberOfGoodSubarrays += duplicates + 1;\\n            }\\n        }\\n\\n        return numberOfGoodSubarrays;\\n    }\\n    \\n    private void addToWindow(Map<Integer,Integer> window, int value) {\\n        window.put(value, window.getOrDefault(value, 0) + 1);\\n    }\\n    \\n    private void removeFromWindow(Map<Integer,Integer> window, int value) {\\n        Integer freq = window.get(value);\\n        if (freq == null) return;\\n        if (freq == 1) window.remove(value);\\n        else window.put(value, freq - 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        Map<Integer,Integer> window = new HashMap<>();\\n        \\n        int numberOfGoodSubarrays = 0;\\n        int l = 0, r = 0;\\n        int duplicates = 0;\\n        while (r < nums.length) {\\n            addToWindow(window, nums[r++]);\\n\\n            if (window.size() > k) {\\n                removeFromWindow(window, nums[l++]);\\n                duplicates = 0;\\n            }\\n\\n            while (window.get(nums[l]) > 1) {\\n                removeFromWindow(window, nums[l++]);\\n                duplicates++;\\n            }\\n            \\n            if (window.size() == k) {\\n                numberOfGoodSubarrays += duplicates + 1;\\n            }\\n        }\\n\\n        return numberOfGoodSubarrays;\\n    }\\n    \\n    private void addToWindow(Map<Integer,Integer> window, int value) {\\n        window.put(value, window.getOrDefault(value, 0) + 1);\\n    }\\n    \\n    private void removeFromWindow(Map<Integer,Integer> window, int value) {\\n        Integer freq = window.get(value);\\n        if (freq == null) return;\\n        if (freq == 1) window.remove(value);\\n        else window.put(value, freq - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521276,
                "title": "golang-100",
                "content": "```\\nfunc subarraysWithKDistinct(A []int, K int) (ans int) {\\n\\tn := len(A)\\n\\tnum1 := make([]int, n+1)\\n\\tnum2 := make([]int, n+1)\\n\\tvar tot1, tot2, left1, left2 int\\n\\tfor _, v := range A {\\n\\t\\tif num1[v] == 0 {\\n\\t\\t\\ttot1++\\n\\t\\t}\\n\\t\\tnum1[v]++\\n\\t\\tif num2[v] == 0 {\\n\\t\\t\\ttot2++\\n\\t\\t}\\n\\t\\tnum2[v]++\\n\\t\\tfor tot1 > K {\\n\\t\\t\\tnum1[A[left1]]--\\n\\t\\t\\tif num1[A[left1]] == 0 {\\n\\t\\t\\t\\ttot1--\\n\\t\\t\\t}\\n\\t\\t\\tleft1++\\n\\t\\t}\\n\\t\\tfor tot2 > K-1 {\\n\\t\\t\\tnum2[A[left2]]--\\n\\t\\t\\tif num2[A[left2]] == 0 {\\n\\t\\t\\t\\ttot2--\\n\\t\\t\\t}\\n\\t\\t\\tleft2++\\n\\t\\t}\\n\\t\\tans += left2 - left1\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subarraysWithKDistinct(A []int, K int) (ans int) {\\n\\tn := len(A)\\n\\tnum1 := make([]int, n+1)\\n\\tnum2 := make([]int, n+1)\\n\\tvar tot1, tot2, left1, left2 int\\n\\tfor _, v := range A {\\n\\t\\tif num1[v] == 0 {\\n\\t\\t\\ttot1++\\n\\t\\t}\\n\\t\\tnum1[v]++\\n\\t\\tif num2[v] == 0 {\\n\\t\\t\\ttot2++\\n\\t\\t}\\n\\t\\tnum2[v]++\\n\\t\\tfor tot1 > K {\\n\\t\\t\\tnum1[A[left1]]--\\n\\t\\t\\tif num1[A[left1]] == 0 {\\n\\t\\t\\t\\ttot1--\\n\\t\\t\\t}\\n\\t\\t\\tleft1++\\n\\t\\t}\\n\\t\\tfor tot2 > K-1 {\\n\\t\\t\\tnum2[A[left2]]--\\n\\t\\t\\tif num2[A[left2]] == 0 {\\n\\t\\t\\t\\ttot2--\\n\\t\\t\\t}\\n\\t\\t\\tleft2++\\n\\t\\t}\\n\\t\\tans += left2 - left1\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488660,
                "title": "c-o-n-2-pointers-sliding-window-with-unordered-map",
                "content": "Concept1: Find number of subarrays with more than k distinct digits\\nConecpt2: If Sub-Array (from index i to j) have k distinct digits then for every index k such that j1 > j, the sub-array(from index i to j1) must have more than or equal to k disctinct digits.\\nConcept3: How to move fast and slow in sliding window\\nInput: nums = [1,2,1,2,3], k = 2\\nlet slow(index) = 0, and fast(index) = 1 -> subarray(slow, fast) = 2 distinct digits, hence, all the indices after fast must have more than or equal to k distinct digits, hence, we will add (size - fast) to our count. Now, as we have considered all fasts, hence, we will move our slow forward, else we would have moved our fast forward.\\n\\nSolution: \\nNumber of subarrays with exactly k distinct digits = Number of subarrays with more than k distinct digits - Number of subarrays with more than (k+1) distinct digits\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k) {\\n        unordered_map<int, int> uMap;\\n        int size = 0;\\n        int slow = 0, fast = 0;\\n        uMap[nums[fast++]]++;\\n        size++;\\n        \\n        int count = 0;\\n        \\n        while(slow < nums.size()){\\n            if((slow == fast || size < k) && (fast < nums.size())){\\n                if(uMap.find(nums[fast]) == uMap.end() || uMap[nums[fast]] == 0)\\n                    size++;\\n                uMap[nums[fast++]]++;\\n            }\\n            else{\\n                if(size == k){\\n                    count += nums.size() - fast + 1;\\n                }\\n                uMap[nums[slow]]--;\\n                if(uMap[nums[slow]] == 0)\\n                    size--;\\n                slow++;\\n            }\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return solve(nums, k) - solve(nums, k+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k) {\\n        unordered_map<int, int> uMap;\\n        int size = 0;\\n        int slow = 0, fast = 0;\\n        uMap[nums[fast++]]++;\\n        size++;\\n        \\n        int count = 0;\\n        \\n        while(slow < nums.size()){\\n            if((slow == fast || size < k) && (fast < nums.size())){\\n                if(uMap.find(nums[fast]) == uMap.end() || uMap[nums[fast]] == 0)\\n                    size++;\\n                uMap[nums[fast++]]++;\\n            }\\n            else{\\n                if(size == k){\\n                    count += nums.size() - fast + 1;\\n                }\\n                uMap[nums[slow]]--;\\n                if(uMap[nums[slow]] == 0)\\n                    size--;\\n                slow++;\\n            }\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return solve(nums, k) - solve(nums, k+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487664,
                "title": "c-sliding-window",
                "content": "**Exactly = atMostK(k) - atMostK(k-1)**\\n\\n```\\nint atMostK(vector<int>& a, int k) {\\n        int i=0,count = 0,res =0;\\n        unordered_map<int,int> m;\\n        for(int j=0;j<a.size();j++){\\n            m[a[j]]++;\\n            if(m[a[j]]==1) count++;\\n            if(count > k){\\n                while(count>k){\\n                    m[a[i]]--;\\n                    if(m[a[i]] == 0) count--;\\n                    i++;\\n                }\\n            }\\n            res += j-i+-1;\\n        }\\n        return res;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        return atMostK(a,k) - atMostK(a,k-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint atMostK(vector<int>& a, int k) {\\n        int i=0,count = 0,res =0;\\n        unordered_map<int,int> m;\\n        for(int j=0;j<a.size();j++){\\n            m[a[j]]++;\\n            if(m[a[j]]==1) count++;\\n            if(count > k){\\n                while(count>k){\\n                    m[a[i]]--;\\n                    if(m[a[i]] == 0) count--;\\n                    i++;\\n                }\\n            }\\n            res += j-i+-1;\\n        }\\n        return res;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        return atMostK(a,k) - atMostK(a,k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468471,
                "title": "java-o-n-approach-with-sliding-window-and-hashmap",
                "content": "Using Two Hashmaps small and big in which small hashamp conatains elements till the size of hashmap not  equals to `k-1` and big hashmap contains elements till the size of hashmap not equal to `k`. And if `k==1` then we handle this case in other function/method. \\n```\\nclass Solution {\\n    public static int for_k_equals_one(int[] nums){\\n        int ans=0;\\n        int i=-1;\\n        int j=-1;\\n        HashMap<Integer,Integer> map= new HashMap<>();\\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            while(i<nums.length-1){\\n                i++;\\n                f1=false;\\n                int n=nums[i];\\n                map.put(n,map.getOrDefault(n,0)+1);\\n                if(map.size()==2){\\n                    removeMap(map,n);\\n                    i--;\\n                    break;\\n                }\\n            }\\n            while(j<i){\\n                \\n                f2=false;\\n                if(map.size()==1){\\n                    ans+=i-j;\\n                }\\n                j++;\\n                int n=nums[j];\\n                removeMap(map,n);\\n                if(map.size()==0){\\n                    break;\\n                }\\n            }\\n            if(f1 && f2){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n      if(k==1){\\n         return for_k_equals_one(nums); \\n      }  \\n        int ans=0;\\n        HashMap<Integer,Integer> big_map=new HashMap<>();\\n        HashMap<Integer,Integer> small_map=new HashMap<>();\\n        int i_s=-1;\\n        int i_b=-1;\\n        int j=-1;\\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            boolean f3=true;\\n            while(i_b<nums.length-1){\\n                i_b++;\\n                f1=false;\\n                int n=nums[i_b];\\n                big_map.put(n,big_map.getOrDefault(n,0)+1);\\n                if(big_map.size()==k+1){\\n                    i_b--;\\n                    removeMap(big_map,n);\\n                    break;\\n                }\\n            }\\n            while(i_s<i_b){\\n                i_s++;\\n                f2=false;\\n                int n=nums[i_s];\\n                small_map.put(n,small_map.getOrDefault(n,0)+1);\\n                if(small_map.size()==k){\\n                    i_s--;\\n                    removeMap(small_map,n);\\n                    break;\\n                }\\n            }\\n            while(j<i_s){\\n                j++;\\n                f3=false;\\n                if(big_map.size()==k && small_map.size()==k-1){\\n                    ans+=i_b-i_s;\\n                }\\n                int n=nums[j];\\n                removeMap(big_map,n);\\n                removeMap(small_map,n);\\n                if(big_map.size()<k || small_map.size()<k-1){\\n                    break;\\n                }\\n            }\\n            if(f1 && f2 && f3){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    public static void removeMap(HashMap<Integer,Integer> map,int n){\\n        if(map.get(n)==1){\\n            map.remove(n);\\n        }else{\\n            map.put(n,map.get(n)-1);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public static int for_k_equals_one(int[] nums){\\n        int ans=0;\\n        int i=-1;\\n        int j=-1;\\n        HashMap<Integer,Integer> map= new HashMap<>();\\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            while(i<nums.length-1){\\n                i++;\\n                f1=false;\\n                int n=nums[i];\\n                map.put(n,map.getOrDefault(n,0)+1);\\n                if(map.size()==2){\\n                    removeMap(map,n);\\n                    i--;\\n                    break;\\n                }\\n            }\\n            while(j<i){\\n                \\n                f2=false;\\n                if(map.size()==1){\\n                    ans+=i-j;\\n                }\\n                j++;\\n                int n=nums[j];\\n                removeMap(map,n);\\n                if(map.size()==0){\\n                    break;\\n                }\\n            }\\n            if(f1 && f2){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n      if(k==1){\\n         return for_k_equals_one(nums); \\n      }  \\n        int ans=0;\\n        HashMap<Integer,Integer> big_map=new HashMap<>();\\n        HashMap<Integer,Integer> small_map=new HashMap<>();\\n        int i_s=-1;\\n        int i_b=-1;\\n        int j=-1;\\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            boolean f3=true;\\n            while(i_b<nums.length-1){\\n                i_b++;\\n                f1=false;\\n                int n=nums[i_b];\\n                big_map.put(n,big_map.getOrDefault(n,0)+1);\\n                if(big_map.size()==k+1){\\n                    i_b--;\\n                    removeMap(big_map,n);\\n                    break;\\n                }\\n            }\\n            while(i_s<i_b){\\n                i_s++;\\n                f2=false;\\n                int n=nums[i_s];\\n                small_map.put(n,small_map.getOrDefault(n,0)+1);\\n                if(small_map.size()==k){\\n                    i_s--;\\n                    removeMap(small_map,n);\\n                    break;\\n                }\\n            }\\n            while(j<i_s){\\n                j++;\\n                f3=false;\\n                if(big_map.size()==k && small_map.size()==k-1){\\n                    ans+=i_b-i_s;\\n                }\\n                int n=nums[j];\\n                removeMap(big_map,n);\\n                removeMap(small_map,n);\\n                if(big_map.size()<k || small_map.size()<k-1){\\n                    break;\\n                }\\n            }\\n            if(f1 && f2 && f3){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    public static void removeMap(HashMap<Integer,Integer> map,int n){\\n        if(map.get(n)==1){\\n            map.remove(n);\\n        }else{\\n            map.put(n,map.get(n)-1);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425980,
                "title": "js-o-n-sliding-windows",
                "content": "```\\nconst atmostK = (nums, k) => {\\n    const feq = new Map();\\n    let count = 0, feqK=0, left=0;\\n    for(let i=0;i<nums.length;i++) {\\n        if (feq.has(nums[i])) {\\n            if (feq.get(nums[i]) == 0) {\\n                feqK++;\\n            }\\n            feq.set(nums[i], feq.get(nums[i])+1);\\n        } else {\\n            feqK++;\\n            feq.set(nums[i], 1);\\n        }\\n        while (feqK > k) {\\n            if (feq.get(nums[left]) == 1) {\\n                feqK--;\\n            }\\n            feq.set(nums[left],feq.get(nums[left]) -1);\\n            left++;\\n        }\\n        count += i-left+1;\\n        \\n    }\\n    \\n    return count;\\n}\\nvar subarraysWithKDistinct = function(nums, k) {\\n    const allK = atmostK(nums, k);\\n    const allKmins1 = atmostK(nums, k-1);\\n    \\n    return allK -allKmins1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst atmostK = (nums, k) => {\\n    const feq = new Map();\\n    let count = 0, feqK=0, left=0;\\n    for(let i=0;i<nums.length;i++) {\\n        if (feq.has(nums[i])) {\\n            if (feq.get(nums[i]) == 0) {\\n                feqK++;\\n            }\\n            feq.set(nums[i], feq.get(nums[i])+1);\\n        } else {\\n            feqK++;\\n            feq.set(nums[i], 1);\\n        }\\n        while (feqK > k) {\\n            if (feq.get(nums[left]) == 1) {\\n                feqK--;\\n            }\\n            feq.set(nums[left],feq.get(nums[left]) -1);\\n            left++;\\n        }\\n        count += i-left+1;\\n        \\n    }\\n    \\n    return count;\\n}\\nvar subarraysWithKDistinct = function(nums, k) {\\n    const allK = atmostK(nums, k);\\n    const allKmins1 = atmostK(nums, k-1);\\n    \\n    return allK -allKmins1;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1791730,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            },
            {
                "id": 1572766,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            },
            {
                "id": 2008343,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            },
            {
                "id": 1964295,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            },
            {
                "id": 1949653,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            }
        ]
    }
]