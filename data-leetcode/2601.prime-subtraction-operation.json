[
    {
        "title": "Prime Subtraction Operation",
        "question_content": "You are given a 0-indexed integer array nums of length n.\nYou can perform the following operation as many times as you want:\n\n\tPick an index i that you haven&rsquo;t picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i].\n\nReturn true if you can make nums a strictly increasing array using the above operation and false otherwise.\nA strictly increasing array is an array whose each element is strictly greater than its preceding element.\n&nbsp;\nExample 1:\n\nInput: nums = [4,9,6,10]\nOutput: true\nExplanation: In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].\nIn the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].\nAfter the second operation, nums is sorted in strictly increasing order, so the answer is true.\nExample 2:\n\nInput: nums = [6,8,11,12]\nOutput: true\nExplanation: Initially nums is sorted in strictly increasing order, so we don't need to make any operations.\nExample 3:\n\nInput: nums = [5,8,3]\nOutput: false\nExplanation: It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 1000\n\tnums.length == n",
        "solutions": [
            {
                "id": 3342176,
                "title": "c-sieve-algorithm-simplest-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  **Sieve of Eratosthenes**\\nWe will traverse the array from back and store the previous (just next) element. And then try to make upcoming element just smaller than the previous by subtracting the smallest possible prime numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Seive Algorithm:**\\n1. Store all the prime numbers less than 1000 in `prime` (because contraints are less than or equal to 1000).\\n2. Traverse the array from back.\\n3. Store the last element in `prev`.\\n4. Try to make current element less than `prev`, if it is possible by subtracting smallest prime numbers less than current element.\\n5. If we are not able to make any of the current element less than the previous, then assign 1 to `flg` and return false.\\n6. Else return true.\\n\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n);\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void seive_algo(vector<bool> &v, int n){\\n        v[0] = v[1] = false;\\n        for(int i=2; i*i<n; i++){\\n            for(int j=2*i; j<n; j+=i){\\n                v[j] = false;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> isPrime(1005, true);\\n        seive_algo(isPrime, 1005);\\n\\n        vector<int> prime;\\n        for(int i=0; i<1004; i++)\\n            if(isPrime[i]) prime.push_back(i);\\n        \\n        int flg = 0;\\n        int prev = nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i]<prev){prev = nums[i]; continue;}\\n            flg = 1;\\n            for(int sub=0; sub<prime.size() && prime[sub]<nums[i]; sub++){\\n                if(nums[i]-prime[sub]<prev){\\n                    prev = nums[i]-prime[sub];\\n                    flg = 0;\\n                    break;\\n                }\\n            }\\n            if(flg) break;\\n\\n        }\\n        return !flg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void seive_algo(vector<bool> &v, int n){\\n        v[0] = v[1] = false;\\n        for(int i=2; i*i<n; i++){\\n            for(int j=2*i; j<n; j+=i){\\n                v[j] = false;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> isPrime(1005, true);\\n        seive_algo(isPrime, 1005);\\n\\n        vector<int> prime;\\n        for(int i=0; i<1004; i++)\\n            if(isPrime[i]) prime.push_back(i);\\n        \\n        int flg = 0;\\n        int prev = nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i]<prev){prev = nums[i]; continue;}\\n            flg = 1;\\n            for(int sub=0; sub<prime.size() && prime[sub]<nums[i]; sub++){\\n                if(nums[i]-prime[sub]<prev){\\n                    prev = nums[i]-prime[sub];\\n                    flg = 0;\\n                    break;\\n                }\\n            }\\n            if(flg) break;\\n\\n        }\\n        return !flg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341995,
                "title": "image-explanation-reduce-prime-from-last-easy-concise",
                "content": "# Video Solution (`Aryan Mittal`)\\n\\n`Prime Subtraction Operation` by `Aryan Mittal`\\n![b.png](https://assets.leetcode.com/users/images/3f60f2a8-4f79-47a1-b223-efa8cce3e7aa_1679811502.2302964.png)\\n\\n# Approach & Intuition\\n![image.png](https://assets.leetcode.com/users/images/c25f0c76-722a-489a-9538-7c13e0c1e104_1679804143.6792533.png)\\n![image.png](https://assets.leetcode.com/users/images/17c4520f-2853-4dc8-a55f-13d17e498d6d_1679804150.9317358.png)\\n![image.png](https://assets.leetcode.com/users/images/aad6cea5-c88b-4420-9153-a8d98e55c12a_1679804206.8082983.png)\\n![image.png](https://assets.leetcode.com/users/images/64b1c29a-d014-4daa-b473-ebe88a10c1df_1679804225.8144722.png)\\n\\n\\n\\n# Code\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    static const ll MAX=1005;\\n    bool prime[MAX];\\n    \\n    void sieve(){\\n        fill(prime, prime+MAX, true);\\n        prime[0] = prime[1] = false;\\n        \\n        for(ll i=2;i*i<MAX;i++){\\n            if(prime[i]){\\n                for(ll j=i*i;j<MAX;j+=i){\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        sieve();\\n        vector<int> primes; // 168 primes\\n        for(int i=2;i<=1000;i++){\\n            if(prime[i]) primes.push_back(i);\\n        }\\n        \\n        int n = nums.size();\\n        vector<int> new_nums(n, -1);\\n        new_nums[n-1] = nums[n-1];\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < new_nums[i+1]){\\n                new_nums[i] = nums[i];\\n                continue;\\n            }\\n            \\n            for(auto p : primes){\\n                if(p >= nums[i]){ \\n                    new_nums[i] = nums[i];\\n                    break;\\n                }                 \\n                if(nums[i]-p < new_nums[i+1]){\\n                    new_nums[i] = nums[i] - p;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            if(new_nums[i] <= new_nums[i-1]) return false;\\n        \\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    static const ll MAX=1005;\\n    bool prime[MAX];\\n    \\n    void sieve(){\\n        fill(prime, prime+MAX, true);\\n        prime[0] = prime[1] = false;\\n        \\n        for(ll i=2;i*i<MAX;i++){\\n            if(prime[i]){\\n                for(ll j=i*i;j<MAX;j+=i){\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        sieve();\\n        vector<int> primes; // 168 primes\\n        for(int i=2;i<=1000;i++){\\n            if(prime[i]) primes.push_back(i);\\n        }\\n        \\n        int n = nums.size();\\n        vector<int> new_nums(n, -1);\\n        new_nums[n-1] = nums[n-1];\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < new_nums[i+1]){\\n                new_nums[i] = nums[i];\\n                continue;\\n            }\\n            \\n            for(auto p : primes){\\n                if(p >= nums[i]){ \\n                    new_nums[i] = nums[i];\\n                    break;\\n                }                 \\n                if(nums[i]-p < new_nums[i+1]){\\n                    new_nums[i] = nums[i] - p;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            if(new_nums[i] <= new_nums[i-1]) return false;\\n        \\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342030,
                "title": "dry-run-image-explanation-c-sieve-of-eratosthenes-and-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each nums[i] find all the prime numbers less than nums[i].\\nTry to reduce each element(nums[i]) to **as small** as it can get and such that it is **greater than the previous** element(nums[i-1]).\\n\\nFor i==0 always reduce the number by the highest prime number less than nums[0], so that we have the smallest number to begin our array.\\nFor i>0 try to reduce it to as small as possible keeping in mind that it should be greater than nums[i-1].\\n\\n\\n![leetcode prime.jpeg](https://assets.leetcode.com/users/images/e42719ca-4c90-4f1b-ab33-ab1a7744d097_1679804638.0328207.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sieve_of_eratosthenes(int n)\\n    {\\n        vector<int> v;\\n        bool is_prime[n + 1];\\n        memset(is_prime, true, sizeof(is_prime));\\n        is_prime[0] = is_prime[1] = false;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (is_prime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    is_prime[i] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= n; i++) {\\n            if (is_prime[i]) {\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {   \\n            if(nums[i]==1 && i==0) continue; //if the element is 1 and it is at the 0th index then it is the minimum possible value for that place and it should not be changed                                                   \\n            else if(nums[i]==1 && i>0) return false; //if the element is 1 but it is not at the 0th index this means that there is a number greater than equal to 1 already in this array. Think!\\n\\n            vector<int> prime = sieve_of_eratosthenes(nums[i]-1); //adding all the prime numbers lesser than the current element of array\\n\\n            prime.insert(prime.begin(),0); //adding 0 at the beginning of the prime array so that if there is any number that should not be subtracted by any other number or if the current element is at the proper place then dont change it\\n            \\n            if(i==0) nums[i]-=prime[prime.size()-1]; //it is first element so reduce it as much as possible\\n            else\\n            {\\n                bool flag = false;\\n                for(int j=prime.size()-1;j>=0;j--)\\n                {\\n                    if((nums[i]-prime[j])>nums[i-1])\\n                    {\\n                        nums[i]-=prime[j];\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                \\n                if(!flag) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sieve_of_eratosthenes(int n)\\n    {\\n        vector<int> v;\\n        bool is_prime[n + 1];\\n        memset(is_prime, true, sizeof(is_prime));\\n        is_prime[0] = is_prime[1] = false;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (is_prime[p]) {\\n                for (int i = p * p; i <= n; i += p) {\\n                    is_prime[i] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= n; i++) {\\n            if (is_prime[i]) {\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {   \\n            if(nums[i]==1 && i==0) continue; //if the element is 1 and it is at the 0th index then it is the minimum possible value for that place and it should not be changed                                                   \\n            else if(nums[i]==1 && i>0) return false; //if the element is 1 but it is not at the 0th index this means that there is a number greater than equal to 1 already in this array. Think!\\n\\n            vector<int> prime = sieve_of_eratosthenes(nums[i]-1); //adding all the prime numbers lesser than the current element of array\\n\\n            prime.insert(prime.begin(),0); //adding 0 at the beginning of the prime array so that if there is any number that should not be subtracted by any other number or if the current element is at the proper place then dont change it\\n            \\n            if(i==0) nums[i]-=prime[prime.size()-1]; //it is first element so reduce it as much as possible\\n            else\\n            {\\n                bool flag = false;\\n                for(int j=prime.size()-1;j>=0;j--)\\n                {\\n                    if((nums[i]-prime[j])>nums[i-1])\\n                    {\\n                        nums[i]-=prime[j];\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                \\n                if(!flag) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341971,
                "title": "explained-check-out-last-possible-value-very-simple-easy-to-understand-solution",
                "content": "# Approach\\n\\n1. Evaluate all primes lower than 1000.\\n2. Then we will take one value from num and try to make this as small as possible by subtracting available primes.\\n3. store the possble smallest value in last variable.\\n4. Next time, simply subtract the last form the new num value and then try\\n    to minimize by subtracting primes. last variable is subtracted to ensure that the new minimize is larger than the previous.\\n\\nNote : serach op optimal prime to subtract can be done by finding lower bound in faster way, but just to keep thing simple used the iterative way.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    void getAllPrimes(){\\n        primes.push_back(2);\\n        for(int i = 3; i < 1000; ++i){\\n            int f = 1;\\n            for(auto p:primes){\\n                if(i % p == 0) {f = 0; break;}\\n            }\\n            if(f) primes.push_back(i);\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        if(primes.size() == 0) getAllPrimes();\\n        int last = 0;\\n        for(auto n: nums){\\n            n = n - last;\\n            int mn = n;\\n            if(mn <= 0) return false;\\n            for(auto p: primes){\\n                if(n - p > 0 ) mn = min(mn, n-p);\\n                else{\\n                    last = last + mn;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    void getAllPrimes(){\\n        primes.push_back(2);\\n        for(int i = 3; i < 1000; ++i){\\n            int f = 1;\\n            for(auto p:primes){\\n                if(i % p == 0) {f = 0; break;}\\n            }\\n            if(f) primes.push_back(i);\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        if(primes.size() == 0) getAllPrimes();\\n        int last = 0;\\n        for(auto n: nums){\\n            n = n - last;\\n            int mn = n;\\n            if(mn <= 0) return false;\\n            for(auto p: primes){\\n                if(n - p > 0 ) mn = min(mn, n-p);\\n                else{\\n                    last = last + mn;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341984,
                "title": "greedy",
                "content": "First, we generate primes up to 1,000 (using Sieve of Eratosthenes).\\n\\nThen, we try to reduce the current number as much as possible.\\n\\nFor that, we search for the largest prime smaller than `nums[i] - nums[i - 1]`, and subtract it from `nums[i]`.\\n\\n**C++**\\n```c++\\nvector<int> getPrimes() {\\n    vector<int> ps = {2}, sieve(1001);\\n    for (int i = 3; i < 32; ++i)\\n        if (!sieve[i])\\n            for (int j = i * i; j <= 1000; j += i)\\n                sieve[j] = true;\\n    for (int i = 3; i <= 1000; i += 2)\\n        if (!sieve[i])\\n            ps.push_back(i);\\n    return ps;\\n}\\nbool primeSubOperation(vector<int>& nums) {\\n    auto ps = getPrimes();\\n    for (int i = 0; i < nums.size(); ++i) {\\n        auto it = lower_bound(begin(ps), end(ps), nums[i] - (i ? nums[i - 1] : 0));\\n        if (it != begin(ps))\\n            nums[i] -= *prev(it);\\n        if (i && nums[i] <= nums[i - 1])\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nvector<int> getPrimes() {\\n    vector<int> ps = {2}, sieve(1001);\\n    for (int i = 3; i < 32; ++i)\\n        if (!sieve[i])\\n            for (int j = i * i; j <= 1000; j += i)\\n                sieve[j] = true;\\n    for (int i = 3; i <= 1000; i += 2)\\n        if (!sieve[i])\\n            ps.push_back(i);\\n    return ps;\\n}\\nbool primeSubOperation(vector<int>& nums) {\\n    auto ps = getPrimes();\\n    for (int i = 0; i < nums.size(); ++i) {\\n        auto it = lower_bound(begin(ps), end(ps), nums[i] - (i ? nums[i - 1] : 0));\\n        if (it != begin(ps))\\n            nums[i] -= *prev(it);\\n        if (i && nums[i] <= nums[i - 1])\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342034,
                "title": "easy-cpp-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};\\n\\n\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& v) {\\n        for(int i = 0; i < v.size(); i += 1) {\\n            if(i > 0 && v[i] <= v[i - 1]) return false;\\n            int idx = lower_bound(primes.begin(),primes.end(),v[i]) - primes.begin();\\n            for(int j = idx - 1; j >= 0; j -= 1) {\\n                if(i == 0 || v[i] - primes[j] > v[i - 1]) {\\n                    v[i] -= primes[j];break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n#### Alternatively you can calculate primes like this :\\n## Sieve of Eratosthenes\\n\\n```\\n\\tvector<int> primes;\\nvoid SieveOfEratosthenes(int n = 1000)\\n{\\n    bool prime[n + 1];\\n    memset(prime, true, sizeof(prime));\\n    for (int p = 2; p * p <= n; p++) {\\n        if (prime[p] == true) {\\n            for (int i = p * p; i <= n; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n    for (int p = 2; p <= n; p++)\\n        if (prime[p])\\n            primes.push_back(p);\\n}\\n\\nstruct node {\\n    node() {\\n        SieveOfEratosthenes();\\n    }\\n}_;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nvector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};\\n\\n\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& v) {\\n        for(int i = 0; i < v.size(); i += 1) {\\n            if(i > 0 && v[i] <= v[i - 1]) return false;\\n            int idx = lower_bound(primes.begin(),primes.end(),v[i]) - primes.begin();\\n            for(int j = idx - 1; j >= 0; j -= 1) {\\n                if(i == 0 || v[i] - primes[j] > v[i - 1]) {\\n                    v[i] -= primes[j];break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\n\\tvector<int> primes;\\nvoid SieveOfEratosthenes(int n = 1000)\\n{\\n    bool prime[n + 1];\\n    memset(prime, true, sizeof(prime));\\n    for (int p = 2; p * p <= n; p++) {\\n        if (prime[p] == true) {\\n            for (int i = p * p; i <= n; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n    for (int p = 2; p <= n; p++)\\n        if (prime[p])\\n            primes.push_back(p);\\n}\\n\\nstruct node {\\n    node() {\\n        SieveOfEratosthenes();\\n    }\\n}_;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346044,
                "title": "day-361-greedy-approach-o-n-sqrt-x-o-1-dry-run-explained-in-detailed-meme",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### \\u2022\\tsolution uses a greedy approach to solve the problem. The idea is to use the smallest prime number greater than or equal to each element in the nums vector to reduce that element so that the resulting array is strictly increasing. If no such prime number exists, we cannot make the array strictly increasing using the given operation.\\n##### \\u2022\\tThe isPrime function takes an integer x and returns true if x is a prime number, and false otherwise. It checks whether x is divisible by any number between 2 and the square root of x. If it is, it returns false. Otherwise, it returns true.\\n##### \\u2022\\tThe primeSubOperation function takes a vector nums and implements the approach described above. It initializes p to 0, which represents the largest element seen so far. For each element x in the nums vector, it checks whether x is smaller than or equal to p. If it is, we cannot make the array strictly increasing using the given operation, so we return false. Otherwise, it searches for the smallest prime number greater than or equal to x using a while loop. If it finds a prime number, it subtracts it from x and updates the value of p to x. If no such prime number exists, we cannot make the array strictly increasing using the given operation, so we return false. If the loop completes without finding any element that is smaller than or equal to p, the function returns true, indicating that it is possible to make the array strictly increasing using the given operation.\\n##### \\u2022\\tThis approach is correct because using the smallest prime number greater than or equal to an element guarantees that we reduce that element by the smallest possible amount. This helps to ensure that the resulting array is strictly increasing.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n##### \\u2022\\tThe solution uses a greedy approach to solve the problem. The main idea is to use the smallest prime number greater than or equal to each element in the nums vector to reduce that element so that the resulting array is strictly increasing. If no such prime number exists, it means that we cannot make the array strictly increasing using the given operation.\\n\\n##### \\u2022\\tThe isPrime function takes an integer x and returns true if x is a prime number, and false otherwise. It first checks if the integer x is equal to 1, in which case it immediately returns false. Then, it iterates through all the integers from 2 to the square root of x. If any of these integers divides x without a remainder, the function returns false. Otherwise, it returns true.\\n\\n##### \\u2022\\tThe primeSubOperation function takes a vector nums and implements the approach described above. It initializes p to 0, which represents the largest element seen so far. For each element x in the nums vector, it checks whether x is smaller than or equal to p. If it is, it means that we cannot make the array strictly increasing using the given operation, so we immediately return false.\\n\\n##### \\u2022\\tOtherwise, the function searches for the smallest prime number greater than or equal to x. It does this by initializing a variable prime to x - p - 1 and then decrementing prime until it either becomes 0 or it is a prime number. If prime becomes 0, it means that there is no prime number less than or equal to x that we can subtract to make it smaller than the previous element, so we set p to x. Otherwise, we set p to x - prime.\\n\\n##### \\u2022\\tFinally, if the function successfully iterates through all the elements in the nums vector without returning false, it means that we can make the array strictly increasing using the given operation, so we return true.\\n\\n##### \\u2022\\tOverall, this is a simple and efficient approach for solving the problem.\\n\\n\\n# algo\\n\\nhere is a step-by-step explanation of the algorithm used in the provided code:\\n\\n##### \\u2022\\tDefine a function isPrime that takes an integer x and returns true if x is a prime number, and false otherwise.\\n\\n##### \\u2022\\tIf x is equal to 1, return false.\\n##### \\u2022\\tIterate through all the integers from 2 to the square root of x.\\n##### \\u2022\\tIf any of these integers divides x without a remainder, return false.\\n##### \\u2022\\tOtherwise, return true.\\n##### \\u2022\\tDefine a function primeSubOperation that takes a vector nums and implements the approach described in the problem statement.\\n\\n##### \\u2022\\tInitialize a variable p to 0, which represents the largest element seen so far.\\n##### \\u2022\\tFor each element x in the nums vector:\\n##### \\u2022\\tCheck whether x is smaller than or equal to p. If it is, immediately return false.\\n##### \\u2022\\tCompute prime as x - p - 1.\\n##### \\u2022\\tWhile prime is greater than 0 and is not a prime number, decrement it.\\n##### \\u2022\\tIf prime becomes 0, set p to x.\\n##### \\u2022\\tOtherwise, set p to x - prime.\\n##### \\u2022\\tIf the function successfully iterates through all the elements in the nums vector without returning false, return true.\\n##### \\u2022\\tThe main idea of the algorithm is to use the smallest prime number greater than or equal to each element of the nums vector to reduce that element so that the resulting array is strictly increasing. If no such prime number exists, it means that we cannot make the array strictly increasing using the given operation.\\n\\n\\n\\n\\n\\n# Code\\n```c++ []\\nbool isPrime(int x) {\\n    if (x == 1) {\\n        return false;\\n    }\\n    for (int i = 2; i * i <= x; ++i) {\\n        if (x %i == 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nbool primeSubOperation(vector<int>& nums) {\\n    int p = 0;\\n    for (int x : nums) {\\n        if (x <= p) {\\n            return false;\\n        }\\n        int prime = x - p - 1;\\n        while (prime > 0 && !isPrime(prime)) {\\n            prime--;\\n        }\\n        if (prime == 0) {\\n            p = x;\\n        } else {\\n            p = x - prime;\\n        }\\n    }\\n    return true;\\n}\\n```\\n```java []\\npublic boolean isPrime(int x) {\\n    if (x == 1) {\\n        return false;\\n    }\\n    for (int i = 2; i * i <= x; ++i) {\\n        if (x %i == 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\npublic boolean primeSubOperation(int[] nums) {\\n    int p = 0;\\n    for (int x : nums) {\\n        if (x <= p) {\\n            return false;\\n        }\\n        int prime = x - p - 1;\\n        while (prime > 0 && !isPrime(prime)) {\\n            prime--;\\n        }\\n        if (prime == 0) {\\n            p = x;\\n        } else {\\n            p = x - prime;\\n        }\\n    }\\n    return true;\\n}\\n```\\n```python []\\ndef isPrime(x: int) -> bool:\\n    if x == 1:\\n        return False\\n    for i in range(2, int(x ** 0.5) + 1):\\n        if x %i == 0:\\n            return False\\n    return True\\n\\ndef primeSubOperation(nums: List[int]) -> bool:\\n    p = 0\\n    for x in nums:\\n        if x <= p:\\n            return False\\n        prime = x - p - 1\\n        while prime > 0 and not isPrime(prime):\\n            prime -= 1\\n        if prime == 0:\\n            p = x\\n        else:\\n            p = x - prime\\n    return True\\n```\\n# dry run \\nlet\\'s do a dry run of the primeSubOperation function for nums = [6, 8, 11, 12]:\\n\\nInitialize p to 0.\\nFor the first element x = 6:\\nCheck whether x is smaller than or equal to p. It isn\\'t, so continue.\\nCompute prime as x - p - 1 = 6 - 0 - 1 = 5.\\nCheck whether 5 is a prime number. It is, so subtract prime from x to get 1, and update p to x. The array now becomes [6, 1, 11, 12].\\nFor the second element x = 1:\\nCheck whether x is smaller than or equal to p. It isn\\'t, so continue.\\nCompute prime as x - p - 1 = 1 - 6 - 1 = -6. Since prime is less than or equal to 0, set p to x. The array remains [6, 1, 11, 12].\\nFor the third element x = 11:\\nCheck whether x is smaller than or equal to p. It isn\\'t, so continue.\\nCompute prime as x - p - 1 = 11 - 1 - 1 = 9.\\nCheck whether 9 is a prime number. It isn\\'t, so decrement prime to 8.\\nCheck whether 8 is a prime number. It isn\\'t, so decrement prime to 7.\\nCheck whether 7 is a prime number. It is, so subtract prime from x to get 4, and update p to x. The array now becomes [6, 1, 4, 12].\\nFor the fourth element x = 12:\\nCheck whether x is smaller than or equal to p. It isn\\'t, so continue.\\nCompute prime as x - p - 1 = 12 - 11 - 1 = 0. Since prime is less than or equal to 0, set p to x. The array now becomes [6, 1, 4, 12].\\nWe have iterated through all the elements in the nums vector without returning false, so return true.\\nTherefore, the function returns true for nums = [6, 8, 11, 12].\\n# dry run 2\\nlet\\'s do a dry run of the primeSubOperation function for nums = [5, 8, 3]:\\n\\nInitialize p to 0.\\nFor the first element x = 5:\\nCheck whether x is smaller than or equal to p. It isn\\'t, so continue.\\nCompute prime as x - p - 1 = 5 - 0 - 1 = 4.\\nCheck whether 4 is a prime number. It isn\\'t, so decrement prime to 3.\\nCheck whether 3 is a prime number. It is, but subtracting it from x would result in a negative number, so set p to x. The array now becomes [5, 8, 3].\\nFor the second element x = 8:\\nCheck whether x is smaller than or equal to p. It isn\\'t, so continue.\\nCompute prime as x - p - 1 = 8 - 5 - 1 = 2.\\nCheck whether 2 is a prime number. It is, but subtracting it from x would result in 6, which is less than p = 5. Therefore, return false.\\nThe function has returned false, so stop.\\nTherefore, the function returns false for nums = [5, 8, 3].\\n\\nhere : https://leetcode.com/problems/prime-subtraction-operation/solutions/3346044/greedy-approach-o-n-sqrt-x-o-1-dry-run-explained-in-detailed-meme/\\n\\n# Complexity\\nThe time complexity (TC) and space complexity (SC) of the provided solution are as follows:\\n\\nThe isPrime function has a time complexity of O(sqrt(x)), since it iterates through all the integers from 2 to the square root of x.\\n\\nThe primeSubOperation function has a time complexity of O(n * sqrt(x)), where n is the length of the nums vector. This is because for each element x in the nums vector, we need to find the smallest prime number greater than or equal to x, which takes O(sqrt(x)) time. Therefore, the total time complexity of the algorithm is O(n * sqrt(x)).\\n\\nThe space complexity of the algorithm is O(1), since we only use a constant amount of extra space for storing the variables p, prime, i, and x in the primeSubOperation function. The isPrime function does not use any extra space other than the input integer x.\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d9f6c941-e0ab-40f5-9945-e7e2f43a185c_1679861685.7942004.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```c++ []\\nbool isPrime(int x) {\\n    if (x == 1) {\\n        return false;\\n    }\\n    for (int i = 2; i * i <= x; ++i) {\\n        if (x %i == 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nbool primeSubOperation(vector<int>& nums) {\\n    int p = 0;\\n    for (int x : nums) {\\n        if (x <= p) {\\n            return false;\\n        }\\n        int prime = x - p - 1;\\n        while (prime > 0 && !isPrime(prime)) {\\n            prime--;\\n        }\\n        if (prime == 0) {\\n            p = x;\\n        } else {\\n            p = x - prime;\\n        }\\n    }\\n    return true;\\n}\\n```\n```java []\\npublic boolean isPrime(int x) {\\n    if (x == 1) {\\n        return false;\\n    }\\n    for (int i = 2; i * i <= x; ++i) {\\n        if (x %i == 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\npublic boolean primeSubOperation(int[] nums) {\\n    int p = 0;\\n    for (int x : nums) {\\n        if (x <= p) {\\n            return false;\\n        }\\n        int prime = x - p - 1;\\n        while (prime > 0 && !isPrime(prime)) {\\n            prime--;\\n        }\\n        if (prime == 0) {\\n            p = x;\\n        } else {\\n            p = x - prime;\\n        }\\n    }\\n    return true;\\n}\\n```\n```python []\\ndef isPrime(x: int) -> bool:\\n    if x == 1:\\n        return False\\n    for i in range(2, int(x ** 0.5) + 1):\\n        if x %i == 0:\\n            return False\\n    return True\\n\\ndef primeSubOperation(nums: List[int]) -> bool:\\n    p = 0\\n    for x in nums:\\n        if x <= p:\\n            return False\\n        prime = x - p - 1\\n        while prime > 0 and not isPrime(prime):\\n            prime -= 1\\n        if prime == 0:\\n            p = x\\n        else:\\n            p = x - prime\\n    return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3342572,
                "title": "short-crispy-concise-solution-easy-to-understand",
                "content": "# Intuition\\nEASY Question Just Analyzing Statement\\n\\n# Approach\\nSS APPROACH \\nJUST SMILE AND SOLVE.\\n\\n# Complexity\\nNOTHING COMPLEX\\n\\n# PLEASE UPVOTE\\nPLEASE UPVOTE IF I HELPED YOU\\nTHANK YOU \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }\\n                    \\n                    if (nums[i - 2] - primes.get(primeIndex) < nums[i - 1]) {\\n                        index = primeIndex;\\n                        break;\\n                    }\\n                }\\n                if (index == -1) {\\n                    return false;\\n                }\\n                nums[i - 2] = nums[i - 2] - primes.get(index);\\n            }\\n        }\\n        return true;\\n    }\\n    public List<Integer> sieveOfEratosthenes(int count) {\\n        List<Integer> result = new ArrayList<>();\\n        boolean[] primes = new boolean[count + 1];\\n        for (int i = 0; i < primes.length; i++) {\\n            primes[i] = true;\\n        }        \\n        for (int i = 2; i * i <= count; i++) {\\n            if (primes[i]) {\\n                for (int j = i * 2; j <= count; j = j + i) {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= count; i++) {\\n            if (primes[i]) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }\\n                    \\n                    if (nums[i - 2] - primes.get(primeIndex) < nums[i - 1]) {\\n                        index = primeIndex;\\n                        break;\\n                    }\\n                }\\n                if (index == -1) {\\n                    return false;\\n                }\\n                nums[i - 2] = nums[i - 2] - primes.get(index);\\n            }\\n        }\\n        return true;\\n    }\\n    public List<Integer> sieveOfEratosthenes(int count) {\\n        List<Integer> result = new ArrayList<>();\\n        boolean[] primes = new boolean[count + 1];\\n        for (int i = 0; i < primes.length; i++) {\\n            primes[i] = true;\\n        }        \\n        for (int i = 2; i * i <= count; i++) {\\n            if (primes[i]) {\\n                for (int j = i * 2; j <= count; j = j + i) {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= count; i++) {\\n            if (primes[i]) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342130,
                "title": "simple-easy-jugadu-solution-by-trippy-the-coder",
                "content": "# Intuition\\nEASY KOCHEN\\nBAKCHOD SOLUTION\\n\\n# Approach\\nSS APPROACH \\nJUST SMILE AND SOLVE.\\nHERE I AM PRESENTING JAVA SOL C++ WOULD BE SIMMILAR TO IT.\\n\\n# Complexity\\nNOTHING COMPLEX\\n\\n# PLEASE UPVOTE\\nPLEASE UPVOTE IF I HELPED YOU\\nTHANK YOU \\nLOVE FOR YOU BY TRIPPY\\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }\\n                    \\n                    if (nums[i - 2] - primes.get(primeIndex) < nums[i - 1]) {\\n                        index = primeIndex;\\n                        break;\\n                    }\\n                }\\n                if (index == -1) {\\n                    return false;\\n                }\\n                nums[i - 2] = nums[i - 2] - primes.get(index);\\n            }\\n        }\\n        return true;\\n    }\\n    public List<Integer> sieveOfEratosthenes(int count) {\\n        List<Integer> result = new ArrayList<>();\\n        boolean[] primes = new boolean[count + 1];\\n        for (int i = 0; i < primes.length; i++) {\\n            primes[i] = true;\\n        }        \\n        for (int i = 2; i * i <= count; i++) {\\n            if (primes[i]) {\\n                for (int j = i * 2; j <= count; j = j + i) {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= count; i++) {\\n            if (primes[i]) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }\\n                    \\n                    if (nums[i - 2] - primes.get(primeIndex) < nums[i - 1]) {\\n                        index = primeIndex;\\n                        break;\\n                    }\\n                }\\n                if (index == -1) {\\n                    return false;\\n                }\\n                nums[i - 2] = nums[i - 2] - primes.get(index);\\n            }\\n        }\\n        return true;\\n    }\\n    public List<Integer> sieveOfEratosthenes(int count) {\\n        List<Integer> result = new ArrayList<>();\\n        boolean[] primes = new boolean[count + 1];\\n        for (int i = 0; i < primes.length; i++) {\\n            primes[i] = true;\\n        }        \\n        for (int i = 2; i * i <= count; i++) {\\n            if (primes[i]) {\\n                for (int j = i * 2; j <= count; j = j + i) {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= count; i++) {\\n            if (primes[i]) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342258,
                "title": "greedy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf array iis already n strictly incresing order then just return true. Try to make first element as small as possible and try to make other element just greater than previous element and as small as possible if it is impossible to make just greater element then it is impossble to make array in strictly increasing order by given operation.Constraint are low so we can use o(n*n*sqrt(n)) solution also.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. if size of array is one or array is already in strictly increasiing order then return true.\\n2. Make first element as small as possble by substracting largest prime number which is less than nums[0].\\n3. Start traversing from i=1 till i=n-1, Check difference of nums[i] and nums[i-1] is negative or not if negative then it is impossiible to convert array into strictly increasing array hence we will return false.\\n4. if difference is not negative then we will find a prime number which is just smaller then difference of nums[i] ans nums[i-1], substract nums[i] with that prime number and break the inner loop and checl for other value of i.\\n5. at the end return true.\\n# Complexity\\n- Time complexity:O(N^2 *sqrt(N)). \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int n)\\n    {\\n        if (n <= 1)\\n\\t\\treturn false;\\n     \\tif (n == 2 || n == 3)\\n\\t     \\treturn true;\\n\\t    if (n % 2 == 0 || n % 3 == 0)\\n\\t\\t  return false;\\n\\t    for (int i = 5; i <= sqrt(n); i = i + 6)\\n\\t\\t   if (n % i == 0 || n % (i + 2) == 0)\\n\\t\\t\\treturn false;\\n\\t    return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        bool fl=true;\\n        int n=nums.size();\\n        if(n==1) return true;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                fl=false;\\n            }\\n        }\\n        if(fl)\\n        { \\n            // when array is already in strictly increasing order.\\n            return true;\\n        }\\n        for(int i=nums[0]-1;i>1;i--)\\n        {\\n            if(check(i))\\n            {\\n                nums[0]-=i;\\n                break;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int k=nums[i]-nums[i-1];\\n            if(k<=0) return false;\\n            for(int j=k-1;j>1;j--)\\n            {\\n                if(check(j))\\n                {\\n                    nums[i]-=j;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n)\\n    {\\n        if (n <= 1)\\n\\t\\treturn false;\\n     \\tif (n == 2 || n == 3)\\n\\t     \\treturn true;\\n\\t    if (n % 2 == 0 || n % 3 == 0)\\n\\t\\t  return false;\\n\\t    for (int i = 5; i <= sqrt(n); i = i + 6)\\n\\t\\t   if (n % i == 0 || n % (i + 2) == 0)\\n\\t\\t\\treturn false;\\n\\t    return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        bool fl=true;\\n        int n=nums.size();\\n        if(n==1) return true;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                fl=false;\\n            }\\n        }\\n        if(fl)\\n        { \\n            // when array is already in strictly increasing order.\\n            return true;\\n        }\\n        for(int i=nums[0]-1;i>1;i--)\\n        {\\n            if(check(i))\\n            {\\n                nums[0]-=i;\\n                break;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int k=nums[i]-nums[i-1];\\n            if(k<=0) return false;\\n            for(int j=k-1;j>1;j--)\\n            {\\n                if(check(j))\\n                {\\n                    nums[i]-=j;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341901,
                "title": "python-nlogn-sieve-maths-binary-search",
                "content": "## Approach : Maths + Binary Search \\nReduce the number as much as possible just greater than the prev means we are greedy here , why ?.... because we don\\'t know about the future element it may be either too small so just reduce the earlier elements as much you can by the possible prime \\nNow let\\'s start the maths -\\ni.e   curr - x > prev  \\nx < curr - prev\\nx < = curr - prev - 1\\nthen find the closest x in the primes (upto 1000) using binary search\\nthen subtract it from the curr num \\nif not possible to find the closest then remain the curr number as it is\\nso if at any point curr<=prev we can\\'t make array strictly increasing otherwise if there is no such point we are able to make array strictly increasing\\n\\nTime Complexity : nlogn\\n\\n\\t\\tdef sieve(num):  \\n\\t\\t\\tprime = [True]*(num+1)\\n\\t\\t\\tprime[0] = prime[1] = False\\n\\n\\t\\t\\tfor i in range(2, int(num ** 0.5) + 1):  \\n\\t\\t\\t\\tif prime[i] :   \\n\\t\\t\\t\\t\\tfor j in range(i*i ,num+1 ,i):   \\n\\t\\t\\t\\t\\t\\tprime[j] = False\\n\\t\\t\\treturn [i for i in range(len(prime)) if prime[i]]\\n\\n\\t\\tprimes  = sieve(1000)\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef primeSubOperation(self, nums: List[int]) -> bool:\\n\\t\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\tprev = 0\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\treq = nums[i]-prev-1\\n\\t\\t\\t\\t\\tidx = bisect_left(primes, req)\\n\\t\\t\\t\\t\\ttakeCurr = False\\n\\t\\t\\t\\t\\tif idx>=len(primes) or primes[idx] > req:  # can\\'t take from primes idx\\n\\t\\t\\t\\t\\t\\t# check if we can take the prev idx bcz idx can\\'t be taken idx-1 may be closest which satisfy the condition\\n\\t\\t\\t\\t\\t\\tif idx>0 and primes[idx-1]<=req:\\n\\t\\t\\t\\t\\t\\t\\tidx = idx-1\\n\\t\\t\\t\\t\\t\\telse:  # we have no choice need to take the curr element\\n\\t\\t\\t\\t\\t\\t\\ttakeCurr = True\\n\\t\\t\\t\\t\\tcurr = nums[i]\\n\\t\\t\\t\\t\\tif not takeCurr :  # no need to take the curr element\\n\\t\\t\\t\\t\\t\\tcurr = nums[i]-primes[idx]\\n\\t\\t\\t\\t\\tif curr <= prev:  # if curr is not greater than prev can\\'t make it\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tprev = curr\\n\\t\\t\\t\\treturn True",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "## Approach : Maths + Binary Search \\nReduce the number as much as possible just greater than the prev means we are greedy here , why ?.... because we don\\'t know about the future element it may be either too small so just reduce the earlier elements as much you can by the possible prime \\nNow let\\'s start the maths -\\ni.e   curr - x > prev  \\nx < curr - prev\\nx < = curr - prev - 1\\nthen find the closest x in the primes (upto 1000) using binary search\\nthen subtract it from the curr num \\nif not possible to find the closest then remain the curr number as it is\\nso if at any point curr<=prev we can\\'t make array strictly increasing otherwise if there is no such point we are able to make array strictly increasing\\n\\nTime Complexity : nlogn\\n\\n\\t\\tdef sieve(num):  \\n\\t\\t\\tprime = [True]*(num+1)\\n\\t\\t\\tprime[0] = prime[1] = False\\n\\n\\t\\t\\tfor i in range(2, int(num ** 0.5) + 1):  \\n\\t\\t\\t\\tif prime[i] :   \\n\\t\\t\\t\\t\\tfor j in range(i*i ,num+1 ,i):   \\n\\t\\t\\t\\t\\t\\tprime[j] = False\\n\\t\\t\\treturn [i for i in range(len(prime)) if prime[i]]\\n\\n\\t\\tprimes  = sieve(1000)\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef primeSubOperation(self, nums: List[int]) -> bool:\\n\\t\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\tprev = 0\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\treq = nums[i]-prev-1\\n\\t\\t\\t\\t\\tidx = bisect_left(primes, req)\\n\\t\\t\\t\\t\\ttakeCurr = False\\n\\t\\t\\t\\t\\tif idx>=len(primes) or primes[idx] > req:  # can\\'t take from primes idx\\n\\t\\t\\t\\t\\t\\t# check if we can take the prev idx bcz idx can\\'t be taken idx-1 may be closest which satisfy the condition\\n\\t\\t\\t\\t\\t\\tif idx>0 and primes[idx-1]<=req:\\n\\t\\t\\t\\t\\t\\t\\tidx = idx-1\\n\\t\\t\\t\\t\\t\\telse:  # we have no choice need to take the curr element\\n\\t\\t\\t\\t\\t\\t\\ttakeCurr = True\\n\\t\\t\\t\\t\\tcurr = nums[i]\\n\\t\\t\\t\\t\\tif not takeCurr :  # no need to take the curr element\\n\\t\\t\\t\\t\\t\\tcurr = nums[i]-primes[idx]\\n\\t\\t\\t\\t\\tif curr <= prev:  # if curr is not greater than prev can\\'t make it\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tprev = curr\\n\\t\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 3343523,
                "title": "python-o-nlogp-fast",
                "content": "# Intuition\\nConstraints are low, primes upto 1000 can be stored in array and binary searched. \\nGo from back and if current item is not smaller then next after\\ntry to find smallest prime that can make current smaller then one after it.\\nThis can be done in greedy way, until beggining is reached or current problematic item can not be paired with any smaller prime.\\nIn problems with larger P and V (value of A[i]), they can precomputed too, this saves a lot of time if there are many calls to primeSubOperation function.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log p)$$ --> where N is length of array and p is the number of primes upto 1000\\n\\n- Space complexity:\\n$$O(P)$$, where p is number of primes upto 1000\\n\\n# Code\\n```\\nclass Solution:\\n    def primeSubOperation(self, A: List[int]) -> bool:\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n\\n        for i in range(len(A) - 2, -1, -1):\\n            if A[i] < A[i + 1]: continue\\n            index = bisect_right(primes, A[i] - A[i + 1])\\n            if index == len(primes) or A[i] - primes[index] < 1: return False\\n            A[i] -= primes[index]\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, A: List[int]) -> bool:\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n\\n        for i in range(len(A) - 2, -1, -1):\\n            if A[i] < A[i + 1]: continue\\n            index = bisect_right(primes, A[i] - A[i + 1])\\n            if index == len(primes) or A[i] - primes[index] < 1: return False\\n            A[i] -= primes[index]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343327,
                "title": "java-sieve-of-ohio-explained",
                "content": "# Explanation:\\nI reduced every number from the left to its minimum possible value by subtracting the greatest possible prime number from it such that a strictly increasing order is maintained.\\n\\nSay we have `[4, 9, 6, 10]`\\nInitially `prev` is `0`, we need to transform `nums[0]` to something which is strictly greater then `0` which can be `1` atleast.\\n\\nSo the **difference** is `4 - 0 - 1` i.e. `3`. So we can subtract a number from `nums[0]` which is at max `3` (If we subtract a greater number then the strictly increasing order will be broken). Now what is the greatest prime number less than or equal to `3` (floor prime)? Its `3` itself, so we subtract `3` from `nums[0]` and make it `1`. Now `prev` becomes `1`. Which means that the next number that we are gonna make should be strictly greater than `prev` (i.e. `1`).\\n\\nSo the **difference** will help us to determine the prime number we should subtract from our current number to make it smallest possible but strictly greater than `prev` number.\\n\\nThe `fillFloorPrime()` method fills the `getFloorPrime[]` array which stores the greatest prime number lesser than or equal to a number when provided to it as an index.\\n\\nSomething like this:\\n`[0, 0, 2, 3, 3, 5, 5, 7, 7, 7, 7, 11, 11, 13, 13, 13, .....]`\\nSo I have named this a ***Sieve of Ohio*** (Idk if you\\'d get it \\uD83E\\uDD21)\\n\\nSo after we are able to transform all the numbers we return `true` at the end.\\n\\n### *When to return false?*\\n\\nLets take the example `[5, 8, 3]`.\\nThe array after reduction of the first two numbers would be `[2, 3, 3]`. The third number is itself `3`. So the difference would come out to be negative.\\n\\nSo, if the difference is negative (or if the current number is lesser or equal to the previous number (which is already reduced)) return `false`, because its not possible to make it strictly increasing which is clearly visible.\\n\\n---\\n\\n# Solution:\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        fillFloorPrime();\\n        int prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            // Either this condition\\n            if (i > 0 && nums[i] <= nums[i-1]) { \\n                return false;\\n            }\\n            int diff = nums[i] - prev - 1;\\n            // Or this condition\\n            // if (diff < 0) {\\n            //     return false;\\n            // }\\n            prev = nums[i] -= getFloorPrime[diff];\\n        }\\n\\n        return true;\\n    }\\n    \\n    int[] getFloorPrime = new int[1001];\\n    private void fillFloorPrime() {\\n        int prev = 0;\\n        for (int i = 2; i < getFloorPrime.length; i++) {\\n            if (isPrime(i)) {\\n                getFloorPrime[i] = i;\\n                prev = i;\\n            } else {\\n                getFloorPrime[i] = prev;\\n            }\\n        }\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        for (int i = 2; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n##### Time complexity: $$O(1000.k) + O(n)$$\\n> $$O(1000.k)$$ to fill the `getFloorPrime[]` array. Let $$k$$ be the particular number we are trying to determine if its prime or not.\\n\\n> $$O(n)$$ to traverse on `nums`.\\n\\n##### Space complexity: $$O(1001) => O(1)$$",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        fillFloorPrime();\\n        int prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            // Either this condition\\n            if (i > 0 && nums[i] <= nums[i-1]) { \\n                return false;\\n            }\\n            int diff = nums[i] - prev - 1;\\n            // Or this condition\\n            // if (diff < 0) {\\n            //     return false;\\n            // }\\n            prev = nums[i] -= getFloorPrime[diff];\\n        }\\n\\n        return true;\\n    }\\n    \\n    int[] getFloorPrime = new int[1001];\\n    private void fillFloorPrime() {\\n        int prev = 0;\\n        for (int i = 2; i < getFloorPrime.length; i++) {\\n            if (isPrime(i)) {\\n                getFloorPrime[i] = i;\\n                prev = i;\\n            } else {\\n                getFloorPrime[i] = prev;\\n            }\\n        }\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        for (int i = 2; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342209,
                "title": "greedy-binary-search-c",
                "content": "```\\nclass Solution {\\n    vector<int> sieve(int n) {\\n        vector<int> v(n + 1), ans;\\n        for (int i=2; i<=sqrt(n); i++) {\\n            if(!v[i]) {\\n                for (int j=i*i; j<=n; j+=i) v[j] = 1;\\n            }\\n        }\\n        for (int i=2; i<=n; i++) {\\n            if (!v[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> p = sieve(1000);\\n        int n = nums.size(), last = nums.back();\\n        for(int i=n-2; i>=0; i--) {\\n            if(nums[i] < last) last = nums[i];\\n            else {\\n                int pos = lower_bound(p.begin(), p.end(), nums[i]) - p.begin() - 1;\\n                int f = 0;\\n                for(int j=0; j<=pos; j++) {\\n                    if(nums[i] - p[j] < last) {\\n                        last = nums[i] - p[j];\\n                        f = 1;\\n                        break;\\n                    }\\n                }\\n                if(!f) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> sieve(int n) {\\n        vector<int> v(n + 1), ans;\\n        for (int i=2; i<=sqrt(n); i++) {\\n            if(!v[i]) {\\n                for (int j=i*i; j<=n; j+=i) v[j] = 1;\\n            }\\n        }\\n        for (int i=2; i<=n; i++) {\\n            if (!v[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> p = sieve(1000);\\n        int n = nums.size(), last = nums.back();\\n        for(int i=n-2; i>=0; i--) {\\n            if(nums[i] < last) last = nums[i];\\n            else {\\n                int pos = lower_bound(p.begin(), p.end(), nums[i]) - p.begin() - 1;\\n                int f = 0;\\n                for(int j=0; j<=pos; j++) {\\n                    if(nums[i] - p[j] < last) {\\n                        last = nums[i] - p[j];\\n                        f = 1;\\n                        break;\\n                    }\\n                }\\n                if(!f) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342184,
                "title": "very-easy-to-understand-sieve-algorithm-c-100-faster",
                "content": "# Intuition\\nThe main intuition behind the problem is simple,you just have to check if the current number is smaller or equal to the previous number then you have to subtract a prime number from previous number to make increasing array. The prime number must lie in the range of(previous-cuurent+1,current-1) if it exist then subtract if doesn\\'t then return false.\\nInstead of finding prime each time use sieve of eratosthenes to store prime in predefined vector or array.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(log(n)))-for sieve.\\nO(n*n)-to traverse and find prime.\\n\\n- Space complexity:\\nO(n) for prime vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool>prime;\\n    void sieve()\\n    {\\n        prime.resize(1001,true);\\n        prime[0]=false;\\n        prime[1]=false;\\n        for(int i=2;i*i<1001;i++)\\n        {\\n            if(prime[i])\\n            {\\n                for(int j=i*i;j<=1000;j+=i)\\n                {\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int search(int x,int y)\\n    {\\n        for(int i=x+1;i<y;i++)\\n        {\\n            if(prime[i])\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sieve();\\n        for(int i=n-1;i>0;i--)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                int x=search(nums[i-1]-nums[i],nums[i-1]);\\n                // cout<<x<<\" \"<<nums[i-1]-nums[i]<<\" \"<<nums[i-1]<<endl;\\n                if(x==-1)\\n                {\\n                    return false;\\n                }\\n                nums[i-1]-=x;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool>prime;\\n    void sieve()\\n    {\\n        prime.resize(1001,true);\\n        prime[0]=false;\\n        prime[1]=false;\\n        for(int i=2;i*i<1001;i++)\\n        {\\n            if(prime[i])\\n            {\\n                for(int j=i*i;j<=1000;j+=i)\\n                {\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int search(int x,int y)\\n    {\\n        for(int i=x+1;i<y;i++)\\n        {\\n            if(prime[i])\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sieve();\\n        for(int i=n-1;i>0;i--)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                int x=search(nums[i-1]-nums[i],nums[i-1]);\\n                // cout<<x<<\" \"<<nums[i-1]-nums[i]<<\" \"<<nums[i-1]<<endl;\\n                if(x==-1)\\n                {\\n                    return false;\\n                }\\n                nums[i-1]-=x;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3501476,
                "title": "brute-force-c-easy-to-understnad",
                "content": "find maximum possible prime no such that nums[i]-p > nums[i-1]\\nif not possible than don\\'t change in nums[i];\\n\\nafter modification of array if nums[i]<=nums[i-1] return false, else return true;\\n\\n# Complexity\\n- Time complexity:\\nO(1000*SQRT(1000))\\n\\n- Space complexity:\\nO(no of prime no till 1000)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool prime(int n){\\n        for(int i = 2; i <= sqrt(n); i++){\\n            if(n%i == 0)return false;\\n        }\\n        return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> p;\\n        int i,n=nums.size(),j,x;\\n        for(i = 2; i <= 1000; i++){\\n            if(prime(i)){\\n                // cout<<i<<\" \";\\n                p.push_back(i);\\n            }\\n        }\\n        // cout<<endl;\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                j = p.size();\\n                while(j--){\\n                    if(p[j]<nums[i]){\\n                        break;\\n                    }\\n                }\\n                if(j==-1)continue;\\n                nums[i] -= p[j];\\n            }else{\\n                j = p.size(),x=0;\\n                while(j--){\\n                    if(nums[i]-p[j] > nums[i-1]&&p[j]<nums[i]){\\n                        x = p[j];\\n                        break;\\n                    }\\n                }\\n                if(j>=0){\\n                    nums[i] -= x;\\n                }\\n            }\\n        }\\n        //<!-- for(auto &i: nums)cout<<i<<\" \"; -->\\n        for(i = 1; i < n; i++){\\n            if(nums[i-1]>=nums[i])return false;\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prime(int n){\\n        for(int i = 2; i <= sqrt(n); i++){\\n            if(n%i == 0)return false;\\n        }\\n        return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> p;\\n        int i,n=nums.size(),j,x;\\n        for(i = 2; i <= 1000; i++){\\n            if(prime(i)){\\n                // cout<<i<<\" \";\\n                p.push_back(i);\\n            }\\n        }\\n        // cout<<endl;\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                j = p.size();\\n                while(j--){\\n                    if(p[j]<nums[i]){\\n                        break;\\n                    }\\n                }\\n                if(j==-1)continue;\\n                nums[i] -= p[j];\\n            }else{\\n                j = p.size(),x=0;\\n                while(j--){\\n                    if(nums[i]-p[j] > nums[i-1]&&p[j]<nums[i]){\\n                        x = p[j];\\n                        break;\\n                    }\\n                }\\n                if(j>=0){\\n                    nums[i] -= x;\\n                }\\n            }\\n        }\\n        //<!-- for(auto &i: nums)cout<<i<<\" \"; -->\\n        for(i = 1; i < n; i++){\\n            if(nums[i-1]>=nums[i])return false;\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3343540,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\nAs we need to make the array in the increasing order, by substracting it with the prime numbers. So, we can do that by moving from start to end and making the elements as smallest as possible with the constraint that it will be strictly greater than the previous element.\\n\\n# Approach\\nTry making the first index the smallest and then go successively such that num[i] > num[i-1] and num[i] is the minimum possible after removing the maximum prime from end.\\n\\nAfter the operations, if the array is sorted then return true, else false\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ as the 10001 is also constanteas\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    ArrayList<Integer> primes = new ArrayList<Integer>();\\n    \\n    public void getPrimes(){\\n        \\n        boolean[] visited = new boolean[10001];\\n        \\n        for(int i = 2; i <= 10000; i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                primes.add(i);\\n                \\n                int j = i;\\n                while(j <= 10000){\\n                    visited[j] = true;\\n                    j += i;\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    public boolean primeSubOperation(int[] nums) {\\n        getPrimes();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            int prime = 0;\\n            if(i == 0){\\n                for(int j : primes){\\n                    if(j >= nums[i]){\\n                        break;\\n                    }\\n\\n                    prime = j;\\n                }\\n\\n                nums[i] -= prime;\\n\\n                // if(prime != 0)\\n                //     primes.remove((Integer)prime);\\n            }else{\\n                for(int j : primes){\\n                    if(j >= nums[i]){\\n                        break;\\n                    }\\n\\n                    if(nums[i-1] < (nums[i] - j)){\\n                        prime = j;\\n                    }\\n                }\\n\\n                nums[i] -= prime;\\n\\n                // if(prime != 0)\\n                //     primes.remove((Integer)prime);\\n            }\\n        }\\n\\n        System.out.println(Arrays.toString(nums));\\n\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i-1] >= nums[i]){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<Integer> primes = new ArrayList<Integer>();\\n    \\n    public void getPrimes(){\\n        \\n        boolean[] visited = new boolean[10001];\\n        \\n        for(int i = 2; i <= 10000; i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                primes.add(i);\\n                \\n                int j = i;\\n                while(j <= 10000){\\n                    visited[j] = true;\\n                    j += i;\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    public boolean primeSubOperation(int[] nums) {\\n        getPrimes();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            int prime = 0;\\n            if(i == 0){\\n                for(int j : primes){\\n                    if(j >= nums[i]){\\n                        break;\\n                    }\\n\\n                    prime = j;\\n                }\\n\\n                nums[i] -= prime;\\n\\n                // if(prime != 0)\\n                //     primes.remove((Integer)prime);\\n            }else{\\n                for(int j : primes){\\n                    if(j >= nums[i]){\\n                        break;\\n                    }\\n\\n                    if(nums[i-1] < (nums[i] - j)){\\n                        prime = j;\\n                    }\\n                }\\n\\n                nums[i] -= prime;\\n\\n                // if(prime != 0)\\n                //     primes.remove((Integer)prime);\\n            }\\n        }\\n\\n        System.out.println(Arrays.toString(nums));\\n\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i-1] >= nums[i]){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342316,
                "title": "java-treeset-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private static boolean isPrime(int n) {\\n    for (var i=2; i*i <= n; i++)\\n      if (n % i == 0) return false;\\n \\n    return true;\\n  }\\n  \\n  public boolean primeSubOperation(int[] nums) {\\n    var set = new TreeSet<Integer>();\\n    set.add(2);\\n\\n    for (var i = 3; i <= 1000; i += 2)\\n      if (isPrime(i)) set.add(i);\\n\\n    var n = nums.length;\\n    \\n    for (var i = n-2; i >= 0; i--) {\\n      if (nums[i] >= nums[i+1]) {\\n        var a = set.higher(nums[i] - nums[i+1]);\\n\\n        if (a == null || a >= nums[i]) return false;\\n        \\n        nums[i] -= a;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n  private static boolean isPrime(int n) {\\n    for (var i=2; i*i <= n; i++)\\n      if (n % i == 0) return false;\\n \\n    return true;\\n  }\\n  \\n  public boolean primeSubOperation(int[] nums) {\\n    var set = new TreeSet<Integer>();\\n    set.add(2);\\n\\n    for (var i = 3; i <= 1000; i += 2)\\n      if (isPrime(i)) set.add(i);\\n\\n    var n = nums.length;\\n    \\n    for (var i = n-2; i >= 0; i--) {\\n      if (nums[i] >= nums[i+1]) {\\n        var a = set.higher(nums[i] - nums[i+1]);\\n\\n        if (a == null || a >= nums[i]) return false;\\n        \\n        nums[i] -= a;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342145,
                "title": "faster-than-100-sc-o-max-value-tc-o-n-log-max-easy",
                "content": "SC and TC already defined in title..\\nWell commented, Easy to understand!\\nPreRequisites : Seive of eratosthenes, binary search(lower_bound)\\n```\\nbool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //finding max value to determine required size of seive needed..\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        \\n        //using seive of eratosthenes algorithm to generate primes.., TC : O(nlog(logn))\\n        vector<bool> primes(maxi + 1, 1);\\n        for(int i = 2; i*i <= maxi; i++)\\n        {\\n            if(primes[i])\\n            {\\n                for(int j = i * i; j <= maxi; j += i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n        \\n        //storing all primes inside prime vector for getting direct access using lower_bound(logN - TC) \\n        vector<int> prime;\\n        for(int i = 2; i <= maxi; i++)\\n        {\\n            if(primes[i])\\n                prime.push_back(i);\\n        }\\n        \\n        //modifying the nums[0] to lowest value possible\\n        if(nums[0] > 2)\\n        {\\n            auto temp = lower_bound(prime.begin(), prime.end(), nums[0]);\\n            temp--;\\n            \\n            nums[0] -= *temp;\\n        }\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            // nums[i] can only be reduced, so if it is <= nums[i - 1], then we can\\'t , simply return 0..\\n            if(nums[i] <= nums[i - 1])\\n                return false;\\n            \\n            int dif = nums[i] - nums[i - 1];\\n            \\n            //if dif <= 2, then no need to modify, because we can\\'t get any prime < 2..\\n            if(dif <= 2)\\n                continue;\\n            \\n            //this is imp, formula derivation\\n            // nums[i] - selectedPrime > nums[i - 1]\\n            // selectedPrime < nums[i] - nums[i - 1]\\n            \\n            //selectedPrime is dif, that\\'s why finding lower_bound\\n            // why lower_bound ? because we need to decrease nums[i] as much as we can, but it must be greater than nums[i - 1]\\n            auto temp = lower_bound(prime.begin(), prime.end(), dif);\\n            \\n            //temp will point to element which is <= dif, so getting just previous element to fulfill condition of strictly less than prime number selection condition\\n            temp--;\\n            \\n            nums[i] -= *temp;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nbool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //finding max value to determine required size of seive needed..\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        \\n        //using seive of eratosthenes algorithm to generate primes.., TC : O(nlog(logn))\\n        vector<bool> primes(maxi + 1, 1);\\n        for(int i = 2; i*i <= maxi; i++)\\n        {\\n            if(primes[i])\\n            {\\n                for(int j = i * i; j <= maxi; j += i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n        \\n        //storing all primes inside prime vector for getting direct access using lower_bound(logN - TC) \\n        vector<int> prime;\\n        for(int i = 2; i <= maxi; i++)\\n        {\\n            if(primes[i])\\n                prime.push_back(i);\\n        }\\n        \\n        //modifying the nums[0] to lowest value possible\\n        if(nums[0] > 2)\\n        {\\n            auto temp = lower_bound(prime.begin(), prime.end(), nums[0]);\\n            temp--;\\n            \\n            nums[0] -= *temp;\\n        }\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            // nums[i] can only be reduced, so if it is <= nums[i - 1], then we can\\'t , simply return 0..\\n            if(nums[i] <= nums[i - 1])\\n                return false;\\n            \\n            int dif = nums[i] - nums[i - 1];\\n            \\n            //if dif <= 2, then no need to modify, because we can\\'t get any prime < 2..\\n            if(dif <= 2)\\n                continue;\\n            \\n            //this is imp, formula derivation\\n            // nums[i] - selectedPrime > nums[i - 1]\\n            // selectedPrime < nums[i] - nums[i - 1]\\n            \\n            //selectedPrime is dif, that\\'s why finding lower_bound\\n            // why lower_bound ? because we need to decrease nums[i] as much as we can, but it must be greater than nums[i - 1]\\n            auto temp = lower_bound(prime.begin(), prime.end(), dif);\\n            \\n            //temp will point to element which is <= dif, so getting just previous element to fulfill condition of strictly less than prime number selection condition\\n            temp--;\\n            \\n            nums[i] -= *temp;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343806,
                "title": "easy-binary-search-solution-c-100-better-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want starting number as small as possible  => making higher number accomodate later in the array \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind prime number which reduces the current element of the array and also make sure that resulting number is greater than the previous one (thats when binary search kicks in) , if such a prime number is not possible return false\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(nlogn)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1000) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int>primes = {0,2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013};\\n        int prev = -1;\\n        for(auto &it : nums) {\\n            int left2 = 0 , left1 = 0;\\n            auto upper = lower_bound(primes.begin() , primes.end() , it) - primes.begin() - 1;   \\n            \\n            int low = 0;\\n            int high = upper;\\n\\n            if(low != high) {\\n                while(low <= high) {\\n                    int mid = (low + high)/2;\\n                    auto dif = it - primes[mid];\\n                    if(dif > prev) {\\n                        low = mid + 1;\\n                    }\\n                    else high = mid - 1;\\n                }\\n                low = low - 1 >= 0 ?  low - 1 : low;\\n            }\\n            if(it - primes[low] <= prev ) return false;\\n            prev = it - primes[low]; \\n            \\n        }\\n        return true;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int>primes = {0,2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013};\\n        int prev = -1;\\n        for(auto &it : nums) {\\n            int left2 = 0 , left1 = 0;\\n            auto upper = lower_bound(primes.begin() , primes.end() , it) - primes.begin() - 1;   \\n            \\n            int low = 0;\\n            int high = upper;\\n\\n            if(low != high) {\\n                while(low <= high) {\\n                    int mid = (low + high)/2;\\n                    auto dif = it - primes[mid];\\n                    if(dif > prev) {\\n                        low = mid + 1;\\n                    }\\n                    else high = mid - 1;\\n                }\\n                low = low - 1 >= 0 ?  low - 1 : low;\\n            }\\n            if(it - primes[low] <= prev ) return false;\\n            prev = it - primes[low]; \\n            \\n        }\\n        return true;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342443,
                "title": "binary-search-c-easy-to-understnad",
                "content": "````\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> p;\\n        int i,j;\\n        for(i = 2; i <= 1000; i++){\\n            for(j = 2; j <= sqrt(i); j++){\\n                if(i%j==0)break;\\n            }\\n            if(j>sqrt(i)){\\n                p.push_back(i);\\n            }\\n        }\\n        for(i = 0; i < nums.size(); i++){\\n            if(nums[i]<=2)continue;\\n            int a = 0, b = p.size()-1,k=-1,mid;\\n            while(a<=b){\\n                mid = (b-a)/2+a;\\n                if(p[mid]<=nums[i]){\\n                    k = mid;\\n                    a = mid+1;\\n                }else{\\n                    b = mid-1;\\n                }\\n            }\\n            if(p[k]==nums[i])k--;\\n            if(k==-1)continue;\\n            cout<<p[k]<<\" \";\\n            if(i==0){\\n                nums[0] = nums[0]-p[k];\\n            }\\n            else{\\n                for(j = k;j>=0;j--){\\n                    if(nums[i-1]<nums[i]-p[j]){\\n                        nums[i] = nums[i]-p[j];\\n                        break;\\n                    }\\n                }\\n                if(nums[i]<=nums[i-1])return false;\\n            }\\n            cout<<nums[i]<<endl;\\n        }\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i-1]>=nums[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> p;\\n        int i,j;\\n        for(i = 2; i <= 1000; i++){\\n            for(j = 2; j <= sqrt(i); j++){\\n                if(i%j==0)break;\\n            }\\n            if(j>sqrt(i)){\\n                p.push_back(i);\\n            }\\n        }\\n        for(i = 0; i < nums.size(); i++){\\n            if(nums[i]<=2)continue;\\n            int a = 0, b = p.size()-1,k=-1,mid;\\n            while(a<=b){\\n                mid = (b-a)/2+a;\\n                if(p[mid]<=nums[i]){\\n                    k = mid;\\n                    a = mid+1;\\n                }else{\\n                    b = mid-1;\\n                }\\n            }\\n            if(p[k]==nums[i])k--;\\n            if(k==-1)continue;\\n            cout<<p[k]<<\" \";\\n            if(i==0){\\n                nums[0] = nums[0]-p[k];\\n            }\\n            else{\\n                for(j = k;j>=0;j--){\\n                    if(nums[i-1]<nums[i]-p[j]){\\n                        nums[i] = nums[i]-p[j];\\n                        break;\\n                    }\\n                }\\n                if(nums[i]<=nums[i-1])return false;\\n            }\\n            cout<<nums[i]<<endl;\\n        }\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i-1]>=nums[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3342045,
                "title": "python-answer-find-all-primes-remove-the-largest-possible-prime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find all Primes\\n2. Keep a previous_min\\n3. Find the next number larger than previous_min by removing all possible primes smaller than n from n. Save it as previous_min.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * 168 + 1000 * 168)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(168)\\n\\n# Code\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        primes = []\\n\\n        for num in range(2, 1000):\\n\\n            for i in primes:\\n                if (num % i) == 0:\\n                    break\\n            else:\\n                primes.append(num)\\n        \\n        primes = [0] + primes\\n\\n        previous_min = 0\\n        \\n        for n in nums:\\n\\n            if n <= previous_min:\\n                return False\\n            \\n            next_previous_min = 0\\n            for p in primes:\\n                if p < n:\\n                    if n - p > previous_min:\\n                        next_previous_min = n-p\\n                else:\\n                    break\\n            previous_min = next_previous_min\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        primes = []\\n\\n        for num in range(2, 1000):\\n\\n            for i in primes:\\n                if (num % i) == 0:\\n                    break\\n            else:\\n                primes.append(num)\\n        \\n        primes = [0] + primes\\n\\n        previous_min = 0\\n        \\n        for n in nums:\\n\\n            if n <= previous_min:\\n                return False\\n            \\n            next_previous_min = 0\\n            for p in primes:\\n                if p < n:\\n                    if n - p > previous_min:\\n                        next_previous_min = n-p\\n                else:\\n                    break\\n            previous_min = next_previous_min\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341906,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }\\n                    \\n                    if (nums[i - 2] - primes.get(primeIndex) < nums[i - 1]) {\\n                        index = primeIndex;\\n                        break;\\n                    }\\n                }\\n                if (index == -1) {\\n                    return false;\\n                }\\n                nums[i - 2] = nums[i - 2] - primes.get(index);\\n            }\\n        }\\n        return true;\\n    }\\n    public List<Integer> sieveOfEratosthenes(int count) {\\n        List<Integer> result = new ArrayList<>();\\n        boolean[] primes = new boolean[count + 1];\\n        for (int i = 0; i < primes.length; i++) {\\n            primes[i] = true;\\n        }        \\n        for (int i = 2; i * i <= count; i++) {\\n            if (primes[i]) {\\n                for (int j = i * 2; j <= count; j = j + i) {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= count; i++) {\\n            if (primes[i]) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = sieveOfEratosthenes(1000);\\n        for (int i = nums.length; i >= 2; i--) {\\n            if (nums[i - 2] >= nums[i - 1]) {\\n                int index = -1;\\n                for (int primeIndex = 0; primeIndex < primes.size(); primeIndex++) {\\n                    if (primes.get(primeIndex) >= nums[i - 2]) {\\n                        break;\\n                    }\\n                    \\n                    if (nums[i - 2] - primes.get(primeIndex) < nums[i - 1]) {\\n                        index = primeIndex;\\n                        break;\\n                    }\\n                }\\n                if (index == -1) {\\n                    return false;\\n                }\\n                nums[i - 2] = nums[i - 2] - primes.get(index);\\n            }\\n        }\\n        return true;\\n    }\\n    public List<Integer> sieveOfEratosthenes(int count) {\\n        List<Integer> result = new ArrayList<>();\\n        boolean[] primes = new boolean[count + 1];\\n        for (int i = 0; i < primes.length; i++) {\\n            primes[i] = true;\\n        }        \\n        for (int i = 2; i * i <= count; i++) {\\n            if (primes[i]) {\\n                for (int j = i * 2; j <= count; j = j + i) {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i <= count; i++) {\\n            if (primes[i]) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446774,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int n){\\n        if (n <= 1)\\n\\t\\t    return false;\\n\\t    for (int i = 2; i <= sqrt(n); i++){\\n\\t\\t   if (n % i == 0)\\n\\t\\t\\treturn false;\\n        }\\n\\t    return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        bool fl=true;\\n        int n=nums.size();\\n        if(n==1) return true;\\n        for(int i=1;i<n;i++){\\n            if(nums[i-1]>=nums[i])\\n                fl=false;\\n        }\\n        if(fl)\\n            return true;\\n        for(int i=nums[0]-1;i>1;i--){\\n            if(check(i)){\\n                nums[0]-=i;\\n                break;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            int k=nums[i]-nums[i-1];\\n            if(k<=0) return false;\\n            for(int j=k-1;j>1;j--){\\n                if(check(j)){\\n                    nums[i]-=j;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n){\\n        if (n <= 1)\\n\\t\\t    return false;\\n\\t    for (int i = 2; i <= sqrt(n); i++){\\n\\t\\t   if (n % i == 0)\\n\\t\\t\\treturn false;\\n        }\\n\\t    return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        bool fl=true;\\n        int n=nums.size();\\n        if(n==1) return true;\\n        for(int i=1;i<n;i++){\\n            if(nums[i-1]>=nums[i])\\n                fl=false;\\n        }\\n        if(fl)\\n            return true;\\n        for(int i=nums[0]-1;i>1;i--){\\n            if(check(i)){\\n                nums[0]-=i;\\n                break;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            int k=nums[i]-nums[i-1];\\n            if(k<=0) return false;\\n            for(int j=k-1;j>1;j--){\\n                if(check(j)){\\n                    nums[i]-=j;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393044,
                "title": "java-solution-1ms-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        //if only 1 element: \\n        int n = nums.length; \\n        if(n == 1) return true;\\n\\n        //if more than 1 elements, start from the end, for the last element\\n        // for the last element do nothing, because it will always make it difficult to generate the strictly increaseing array. \\n\\n        for(int i = n - 2; i >= 0; i--){\\n            //if current num[i] < nums[i+1]: do nothing, automatic satisfy condition. \\n            if(nums[i] < nums[i + 1]) continue;\\n            else{\\n                int diff = nums[i] - nums[i+1];\\n                //need find the first prime between (diff + 1, nums[i] - 1)\\n                // if diff + 1 > nums[i] - 1: no such prime exist\\n                if(diff + 1 > nums[i] - 1) return false;\\n\\n                //start checking number from (diff + 1) to (nums[i] - 1), pick the first prime number to substract from nums[i]\\n                //it will make the nums[i] - prime < nums[i + 1]\\n\\n                int j = diff + 1, end = nums[i] - 1;\\n\\n                for(; j <= end; j++){\\n                    if(isPrime(j)){\\n                        nums[i] = nums[i] - j;\\n                        break;\\n                    }\\n                }\\n                //no prime number found:\\n                if(j > end) return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n\\n    //a helper function to determine if a number is prime or not: \\n    private boolean isPrime(int num){\\n        if(num == 1) return false;\\n        if(num == 2) return true;\\n        int sqrt = (int)Math.sqrt(num);\\n        for(int i = 2; i <= sqrt; i++){\\n            if(num % i == 0) return false; \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        //if only 1 element: \\n        int n = nums.length; \\n        if(n == 1) return true;\\n\\n        //if more than 1 elements, start from the end, for the last element\\n        // for the last element do nothing, because it will always make it difficult to generate the strictly increaseing array. \\n\\n        for(int i = n - 2; i >= 0; i--){\\n            //if current num[i] < nums[i+1]: do nothing, automatic satisfy condition. \\n            if(nums[i] < nums[i + 1]) continue;\\n            else{\\n                int diff = nums[i] - nums[i+1];\\n                //need find the first prime between (diff + 1, nums[i] - 1)\\n                // if diff + 1 > nums[i] - 1: no such prime exist\\n                if(diff + 1 > nums[i] - 1) return false;\\n\\n                //start checking number from (diff + 1) to (nums[i] - 1), pick the first prime number to substract from nums[i]\\n                //it will make the nums[i] - prime < nums[i + 1]\\n\\n                int j = diff + 1, end = nums[i] - 1;\\n\\n                for(; j <= end; j++){\\n                    if(isPrime(j)){\\n                        nums[i] = nums[i] - j;\\n                        break;\\n                    }\\n                }\\n                //no prime number found:\\n                if(j > end) return false;\\n\\n            }\\n        }\\n        return true;\\n    }\\n\\n    //a helper function to determine if a number is prime or not: \\n    private boolean isPrime(int num){\\n        if(num == 1) return false;\\n        if(num == 2) return true;\\n        int sqrt = (int)Math.sqrt(num);\\n        for(int i = 2; i <= sqrt; i++){\\n            if(num % i == 0) return false; \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354803,
                "title": "c-best-easy-to-understand",
                "content": "\\n# Complexity\\n-  Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int a){\\n        if(a<2){\\n            return false;\\n        }\\n        for(int i=2;i<=a/2;i++){\\n            if(a%i ==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int dec(int a, int b){\\n        for(int i=a;i<b;i++){\\n            if(isPrime(i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i+1]<=nums[i]){\\n                int l= dec(nums[i]-nums[i+1]+1, nums[i]);\\n                if(l==0){return false;}\\n                nums[i]-=l;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int a){\\n        if(a<2){\\n            return false;\\n        }\\n        for(int i=2;i<=a/2;i++){\\n            if(a%i ==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int dec(int a, int b){\\n        for(int i=a;i<b;i++){\\n            if(isPrime(i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i+1]<=nums[i]){\\n                int l= dec(nums[i]-nums[i+1]+1, nums[i]);\\n                if(l==0){return false;}\\n                nums[i]-=l;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346716,
                "title": "efficient-greedy-approach-understandable-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*sqrt(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int diff = 0;\\n        for(int val : nums) {\\n            if(val <= diff) return false;\\n            int prime = val - diff - 1;\\n            while(prime > 0 && !isPrime(prime)) {\\n                prime--;\\n            }\\n            if(prime > 0) {\\n                diff = val - prime;\\n            } else {\\n                diff = val;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isPrime(int number) {\\n    if(number <= 2)\\n        return number == 2;\\n    else\\n        return  (number % 2) != 0\\n        &&\\n        IntStream.rangeClosed(3, (int) Math.sqrt(number))\\n        .filter(n -> n % 2 != 0)\\n            .noneMatch(n -> (number % n == 0));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int diff = 0;\\n        for(int val : nums) {\\n            if(val <= diff) return false;\\n            int prime = val - diff - 1;\\n            while(prime > 0 && !isPrime(prime)) {\\n                prime--;\\n            }\\n            if(prime > 0) {\\n                diff = val - prime;\\n            } else {\\n                diff = val;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isPrime(int number) {\\n    if(number <= 2)\\n        return number == 2;\\n    else\\n        return  (number % 2) != 0\\n        &&\\n        IntStream.rangeClosed(3, (int) Math.sqrt(number))\\n        .filter(n -> n % 2 != 0)\\n            .noneMatch(n -> (number % n == 0));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345269,
                "title": "python-beats-100-clearly-written",
                "content": "The idea is to get max prime we can substract from an element that wouldn\\'t make it equal or less than previous element. \\nThe steps are: \\n1. Define a list of prime numbers less than 1000. \\n2. Iterate through the input list of integers and performs the following operations on each element\\n3. Calculate an upper bound for the binary search by finding the index of the prime number that is less than or equal to the difference between the current element and the previous element (if the current element is not the first element in the list).\\n4. Find the index of the largest prime number that is less than or equal to the current element, within the range of primes defined by the upper bound calculated in step 3.\\n5. If a prime number is found in step 4, subtract it from the current element.\\n6. Checks if the current element is less than or equal to the previous element. If so, returns False.\\nTime Complexity:\\nO(n* logm)\\nn - size of nums\\nm - (size of the number of primes from 1-1000) - can be considered constant\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n\\n\\n        for i in range(len(nums)):\\n            \\n            #get the right(high) pointer for the binary search so as not to make it less than prev element\\n            upper_bound = bisect_left(primes,nums[i] - nums[i-1]) if i > 0 else len(primes)\\n            \\n            #get the index of the greatest prime we can subtract\\n            max_prime_idx = bisect_left(primes,nums[i],hi = upper_bound)-1\\n            \\n            if max_prime_idx >= 0:\\n                nums[i]-=primes[max_prime_idx]\\n            \\n            if i > 0 and nums[i] <= nums[i-1]:\\n                return False\\n        return True\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n\\n\\n        for i in range(len(nums)):\\n            \\n            #get the right(high) pointer for the binary search so as not to make it less than prev element\\n            upper_bound = bisect_left(primes,nums[i] - nums[i-1]) if i > 0 else len(primes)\\n            \\n            #get the index of the greatest prime we can subtract\\n            max_prime_idx = bisect_left(primes,nums[i],hi = upper_bound)-1\\n            \\n            if max_prime_idx >= 0:\\n                nums[i]-=primes[max_prime_idx]\\n            \\n            if i > 0 and nums[i] <= nums[i-1]:\\n                return False\\n        return True\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3343875,
                "title": "c-greedy-math-faster-easy-to-understand",
                "content": "* ***Greedy***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for checking prime no.\\n    \\n    bool is_prime(int n)\\n    {\\n        for(int i = 2; i * i <= n; i++)\\n        {\\n            if(n % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // find the maximum element from nums\\n        \\n        int maxi = *max_element(nums.begin(), nums.end());\\n        \\n        // find all the prime numbers till maxi\\n        \\n        vector<int> prime;\\n        \\n        for(int i = 2; i <= maxi; i++)\\n        {\\n            if(is_prime(i))\\n            {\\n                prime.push_back(i);\\n            }\\n        }\\n        \\n        // perform the operations greedily\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i == 0)\\n            {\\n                int maximum = 0;\\n                \\n                for(int j = 0; j < prime.size() && prime[j] < nums[i]; j++)\\n                {\\n                    maximum = max(maximum, prime[j]);\\n                }\\n                \\n                nums[i] -= maximum;\\n            }\\n            else\\n            {\\n                int maximum = 0;\\n                \\n                for(int j = 0; j < prime.size() && prime[j] < nums[i]; j++)\\n                {\\n                    if(nums[i] - prime[j] > nums[i - 1])\\n                    {\\n                        maximum = prime[j];\\n                    }\\n                }\\n                \\n                nums[i] -= maximum;\\n            }\\n        }\\n        \\n        // now check for sorted nums\\n      \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] <= nums[i - 1])\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for checking prime no.\\n    \\n    bool is_prime(int n)\\n    {\\n        for(int i = 2; i * i <= n; i++)\\n        {\\n            if(n % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // find the maximum element from nums\\n        \\n        int maxi = *max_element(nums.begin(), nums.end());\\n        \\n        // find all the prime numbers till maxi\\n        \\n        vector<int> prime;\\n        \\n        for(int i = 2; i <= maxi; i++)\\n        {\\n            if(is_prime(i))\\n            {\\n                prime.push_back(i);\\n            }\\n        }\\n        \\n        // perform the operations greedily\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i == 0)\\n            {\\n                int maximum = 0;\\n                \\n                for(int j = 0; j < prime.size() && prime[j] < nums[i]; j++)\\n                {\\n                    maximum = max(maximum, prime[j]);\\n                }\\n                \\n                nums[i] -= maximum;\\n            }\\n            else\\n            {\\n                int maximum = 0;\\n                \\n                for(int j = 0; j < prime.size() && prime[j] < nums[i]; j++)\\n                {\\n                    if(nums[i] - prime[j] > nums[i - 1])\\n                    {\\n                        maximum = prime[j];\\n                    }\\n                }\\n                \\n                nums[i] -= maximum;\\n            }\\n        }\\n        \\n        // now check for sorted nums\\n      \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] <= nums[i - 1])\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343027,
                "title": "very-easy-to-understand-c",
                "content": "# Intuition\\n1-> Generate all prime number.\\n2-> then prev which maintain value .diff is maximum which can subtract from nums[i] and check nearest prime number.\\n3->and then check nums is strictly greater or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>Allprime;\\n    bool isprime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void generateprime(){\\n        Allprime.push_back(2);\\n        for(int i=3;i<=1000;i++){\\n            if(isprime(i)){\\n                Allprime.push_back(i);\\n            }\\n        }\\n    }\\n    int maxprime(int n){\\n        if(Allprime[0]>n){\\n            return 0;\\n        }\\n        int ans=Allprime[0];\\n        for(int i=1;i<Allprime.size();i++){\\n            if(Allprime[i]>n){\\n                return ans;\\n            }\\n            ans=Allprime[i];\\n        }\\n        return ans;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n       generateprime();\\n       int prev=0;\\n       for(int i=0;i<nums.size();i++){\\n           int diff=nums[i]-prev-1;\\n           int mxprime=maxprime(diff);\\n           nums[i]-=mxprime;\\n           prev=nums[i];\\n       }\\n       for(int i=1;i<nums.size();i++){\\n           if(nums[i]<=nums[i-1]){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>Allprime;\\n    bool isprime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void generateprime(){\\n        Allprime.push_back(2);\\n        for(int i=3;i<=1000;i++){\\n            if(isprime(i)){\\n                Allprime.push_back(i);\\n            }\\n        }\\n    }\\n    int maxprime(int n){\\n        if(Allprime[0]>n){\\n            return 0;\\n        }\\n        int ans=Allprime[0];\\n        for(int i=1;i<Allprime.size();i++){\\n            if(Allprime[i]>n){\\n                return ans;\\n            }\\n            ans=Allprime[i];\\n        }\\n        return ans;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n       generateprime();\\n       int prev=0;\\n       for(int i=0;i<nums.size();i++){\\n           int diff=nums[i]-prev-1;\\n           int mxprime=maxprime(diff);\\n           nums[i]-=mxprime;\\n           prev=nums[i];\\n       }\\n       for(int i=1;i<nums.size();i++){\\n           if(nums[i]<=nums[i-1]){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342866,
                "title": "line-by-line-explanation-easy-to-understand-c-sieveoferatosthenes",
                "content": "# Intuition\\nchecking maximum prime number can be subtracted from each number \\n# Approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   //generating prime number\\n    bool prime[2000];\\n    void SieveOfEratosthenes(int n)\\n    {\\n        memset(prime, true, sizeof(prime));\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n       SieveOfEratosthenes(1000);\\n        //for index 0 the max number prime number i can subtract for ex:\\n        // [4,9,6,10] 0 index:- 4-3 = 1 \\n       for(int i = nums[0]-1;i>=2;i--){\\n           if(prime[i]){\\n               nums[0] -=i;\\n               break;\\n           }\\n       }\\n      //[1,9,6,10]\\n       for(int i  = 1;i<nums.size();i++){\\n      //max number can be subtracted is 9-1-1 = 7 why? answer is := \\n      //1 is first number for strictly increasing min number i need is 2 \\n      //i.e, nums[i-1]+1 so for nums[i] i need to subtract num[i]  - (nums////[i-1]+) == num[i]-nums[i-1]-1;\\n           for(int j = abs(nums[i]-nums[i-1]-1);j>=2;j--){\\n               if(prime[j]){\\n                  nums[i]-=j;\\n                  break;\\n               }\\n           }\\n       }\\n       for(int i = 1;i<nums.size();i++){\\n           if(nums[i]<=nums[i-1]){\\n             return 0;\\n           }\\n       }\\n       return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   //generating prime number\\n    bool prime[2000];\\n    void SieveOfEratosthenes(int n)\\n    {\\n        memset(prime, true, sizeof(prime));\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n       SieveOfEratosthenes(1000);\\n        //for index 0 the max number prime number i can subtract for ex:\\n        // [4,9,6,10] 0 index:- 4-3 = 1 \\n       for(int i = nums[0]-1;i>=2;i--){\\n           if(prime[i]){\\n               nums[0] -=i;\\n               break;\\n           }\\n       }\\n      //[1,9,6,10]\\n       for(int i  = 1;i<nums.size();i++){\\n      //max number can be subtracted is 9-1-1 = 7 why? answer is := \\n      //1 is first number for strictly increasing min number i need is 2 \\n      //i.e, nums[i-1]+1 so for nums[i] i need to subtract num[i]  - (nums////[i-1]+) == num[i]-nums[i-1]-1;\\n           for(int j = abs(nums[i]-nums[i-1]-1);j>=2;j--){\\n               if(prime[j]){\\n                  nums[i]-=j;\\n                  break;\\n               }\\n           }\\n       }\\n       for(int i = 1;i<nums.size();i++){\\n           if(nums[i]<=nums[i-1]){\\n             return 0;\\n           }\\n       }\\n       return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342669,
                "title": "c-simple-approach-easy-to-understand",
                "content": "We start iterating the loop from last, assuming last number to be largest, start to check from i=n-2. If nums[i] is greater than nums[i-1], we don\\'t do anything because it is in increasing order but when nums[i] is less or equal to nums[i-1] we have to solve it. We take difference of nums[i] and nums[i-1] let the difference be dif, so we find the nearest prime number greater than dif, if the prime number comes out to be equal or greater than nums[i], we return false else we subtract nums[i] and prime number we got.\\n```\\nclass Solution {\\npublic:\\n    bool checkPrime(int n)\\n{\\n    if (n <= 1)\\n        return false;\\n    for (int i = 2; i * i <= n; i++) {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){ // start iterating loop from last\\n            if(nums[i]>=nums[i+1]){ // if nums[i] is greater or equal to next index do these\\n                int dif=nums[i]-nums[i+1]; // take difference of both\\n                dif++;\\n                while(true){ \\n                    if(checkPrime(dif)) break; // find next prime to dif\\n                    dif++;\\n                }\\n                if(dif>=nums[i]) { // if prime came out is greater than or equal to nums[i] return false\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n                nums[i]-=dif; // else subtract that prime number from nums[i]\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkPrime(int n)\\n{\\n    if (n <= 1)\\n        return false;\\n    for (int i = 2; i * i <= n; i++) {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){ // start iterating loop from last\\n            if(nums[i]>=nums[i+1]){ // if nums[i] is greater or equal to next index do these\\n                int dif=nums[i]-nums[i+1]; // take difference of both\\n                dif++;\\n                while(true){ \\n                    if(checkPrime(dif)) break; // find next prime to dif\\n                    dif++;\\n                }\\n                if(dif>=nums[i]) { // if prime came out is greater than or equal to nums[i] return false\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n                nums[i]-=dif; // else subtract that prime number from nums[i]\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342507,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        prime=[True]*1001\\n        prime[0]=prime[1]=False\\n        for x in range(2,1001):\\n            if prime[x]:\\n                for i in range(x*x,1001,x):\\n                    prime[i]=False\\n\\n\\n        prev=0\\n        for x in nums:\\n            if prev>=x:\\n                return False\\n\\n            for p in range(x-1,-1,-1):\\n                if prime[p] and x-p>prev:\\n                    break\\n\\n            prev=x-p\\n\\n        return True                            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        prime=[True]*1001\\n        prime[0]=prime[1]=False\\n        for x in range(2,1001):\\n            if prime[x]:\\n                for i in range(x*x,1001,x):\\n                    prime[i]=False\\n\\n\\n        prev=0\\n        for x in nums:\\n            if prev>=x:\\n                return False\\n\\n            for p in range(x-1,-1,-1):\\n                if prime[p] and x-p>prev:\\n                    break\\n\\n            prev=x-p\\n\\n        return True                            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342179,
                "title": "easiest-solution-in-java-prime-number-strictly-increasing-with-comment",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // take one boolean array for navigating the prime number using sieve of eratosthenes Algo\\n    boolean prime[];\\n    public boolean primeSubOperation(int[] nums) {\\n        int n = nums.length;\\n        //sieve of eratosthenes\\n        prime = new boolean[1001];\\n        Arrays.fill(prime , true);  \\n        prime[0] = false;\\n        prime[1] = false;\\n        for(int i=2 ; i*i<=1000 ; i++){\\n            for(int j = 2*i;j<=1000;j+=i){\\n                prime[j] = false;\\n            }\\n        }\\n        \\n\\n        for (int i=0;i<n;i++){\\n            // checking on every iteration that array is strictly increasing or not\\n            if (checkStrictlyIncreasing(nums)) return true;\\n            \\n            int x = 0;\\n            // if the index is 0 \\n            if (i == 0){\\n                int temp = nums[i]-1;\\n                while(temp > 0 && !prime[temp]) temp--;\\n                x = temp;\\n            }else{\\n                // if i > 0, then we have to check with prev(num[i-1]) also because we have to follow strictly increasing sequence\\n                x = findStrictLessNum(nums[i],nums[i-1]);\\n            }\\n            //just reduce the x from nums[i]\\n            nums[i] = nums[i] - x;\\n            //System.out.println(nums[i] +\"  \"+x);\\n            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean checkStrictlyIncreasing(int[] nums){\\n        int n = nums.length;\\n        // checking the prev with curr, equal or not\\n        for (int i=1;i<n;i++){\\n            if (nums[i-1] >= nums[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int findStrictLessNum(int num,int prev){\\n        int x = num;\\n        num--;\\n        /*\\n            here I am checking x - num should be less than equal to nums[i-1]\\n            because we need strictly increasing array as ans\\n        */\\n        while(num > 0 && (x - num <= prev || !prime[num])){\\n            num--;\\n        }\\n       \\n        return num;\\n    }\\n}\\n```\\n\\n\\nIf you face any issue, please comment in it",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // take one boolean array for navigating the prime number using sieve of eratosthenes Algo\\n    boolean prime[];\\n    public boolean primeSubOperation(int[] nums) {\\n        int n = nums.length;\\n        //sieve of eratosthenes\\n        prime = new boolean[1001];\\n        Arrays.fill(prime , true);  \\n        prime[0] = false;\\n        prime[1] = false;\\n        for(int i=2 ; i*i<=1000 ; i++){\\n            for(int j = 2*i;j<=1000;j+=i){\\n                prime[j] = false;\\n            }\\n        }\\n        \\n\\n        for (int i=0;i<n;i++){\\n            // checking on every iteration that array is strictly increasing or not\\n            if (checkStrictlyIncreasing(nums)) return true;\\n            \\n            int x = 0;\\n            // if the index is 0 \\n            if (i == 0){\\n                int temp = nums[i]-1;\\n                while(temp > 0 && !prime[temp]) temp--;\\n                x = temp;\\n            }else{\\n                // if i > 0, then we have to check with prev(num[i-1]) also because we have to follow strictly increasing sequence\\n                x = findStrictLessNum(nums[i],nums[i-1]);\\n            }\\n            //just reduce the x from nums[i]\\n            nums[i] = nums[i] - x;\\n            //System.out.println(nums[i] +\"  \"+x);\\n            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean checkStrictlyIncreasing(int[] nums){\\n        int n = nums.length;\\n        // checking the prev with curr, equal or not\\n        for (int i=1;i<n;i++){\\n            if (nums[i-1] >= nums[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int findStrictLessNum(int num,int prev){\\n        int x = num;\\n        num--;\\n        /*\\n            here I am checking x - num should be less than equal to nums[i-1]\\n            because we need strictly increasing array as ans\\n        */\\n        while(num > 0 && (x - num <= prev || !prime[num])){\\n            num--;\\n        }\\n       \\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342106,
                "title": "neat-golang-binary-search",
                "content": "```\\npackage main\\n\\nimport \"sort\"\\n\\nfunc primeSubOperation(nums []int) bool {\\n\\tprimes := []int{0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}\\n\\n\\tlast := 0\\n\\tfor _, num := range nums {\\n\\t\\tif num <= last {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\t// Binary search the index\\n\\t\\tindex := sort.Search(len(primes), func(i int) bool {\\n\\t\\t\\treturn num-primes[i] <= last\\n\\t\\t}) - 1\\n\\n\\t\\tlast = num - primes[index]\\n\\t}\\n\\n\\treturn true\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport \"sort\"\\n\\nfunc primeSubOperation(nums []int) bool {\\n\\tprimes := []int{0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}\\n\\n\\tlast := 0\\n\\tfor _, num := range nums {\\n\\t\\tif num <= last {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\t// Binary search the index\\n\\t\\tindex := sort.Search(len(primes), func(i int) bool {\\n\\t\\t\\treturn num-primes[i] <= last\\n\\t\\t}) - 1\\n\\n\\t\\tlast = num - primes[index]\\n\\t}\\n\\n\\treturn true\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3341891,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1) return false;\\n     \\n        for (int i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        int n = nums.size(), prev = -1; \\n        \\n        for(int i=0; i<n; i++) {\\n            \\n            if(nums[i] <= prev) return false;\\n            bool found = false;\\n            \\n            for(int curr = nums[i]-1; curr>1; curr--)\\n            {\\n                if(isPrime(curr))\\n                {\\n                    if(prev >= nums[i]-curr) continue;\\n                    \\n                    prev = nums[i] - curr;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(!found)\\n            {\\n                if(nums[i] > prev) prev = nums[i];\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1) return false;\\n     \\n        for (int i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        int n = nums.size(), prev = -1; \\n        \\n        for(int i=0; i<n; i++) {\\n            \\n            if(nums[i] <= prev) return false;\\n            bool found = false;\\n            \\n            for(int curr = nums[i]-1; curr>1; curr--)\\n            {\\n                if(isPrime(curr))\\n                {\\n                    if(prev >= nums[i]-curr) continue;\\n                    \\n                    prev = nums[i] - curr;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(!found)\\n            {\\n                if(nums[i] > prev) prev = nums[i];\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067877,
                "title": "c-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    vector<bool> prime;\\n    void sieve(int x, int y){\\n        prime.resize(y + 1, true);\\n        prime[1] = false;\\n        for (int i = 2; i * i <= y; i++)\\n            if (prime[i])\\n                for (int j = i * i; j <= y; j += i)\\n                    prime[j] = false;\\n    }\\n    vector<int> allPrime(int l, int r){\\n        sieve(1,1001);\\n        vector<int> result;\\n        for (int i = l; i <= r; i++)\\n            if (prime[i])\\n                result.push_back(i);\\n        return result;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        if(nums.size()==1) return 1;\\n        vector<int>v=allPrime(2,1000);\\n         int k=-1,f=0;\\n         for(int i=0;i<v.size();i++){\\n             if(nums[0]<=v[i]){\\n                 k=i-1;\\n                 break;\\n             }\\n             if(i==v.size()-1 && nums[0]>v.size())f=1;\\n         }\\n         if(f==0 && k!=-1)nums[0]-=v[k];\\n         else if(f==1)nums[0]-=v[v.size()-1];\\n         for(int i=1;i<nums.size();i++){\\n             if(nums[i]<=nums[i-1])return false;\\n             k=-1;\\n             for(int j=0;j<v.size();j++)\\n                 if(nums[i]-v[j]<0 || nums[i]-v[j]<=nums[i-1]){\\n                     k=j-1;\\n                     break;\\n                 }\\n                 if(k!=-1)nums[i]=nums[i]-v[k];\\n         }  \\n         return nums[nums.size()-1]>nums[nums.size()-2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    vector<bool> prime;\\n    void sieve(int x, int y){\\n        prime.resize(y + 1, true);\\n        prime[1] = false;\\n        for (int i = 2; i * i <= y; i++)\\n            if (prime[i])\\n                for (int j = i * i; j <= y; j += i)\\n                    prime[j] = false;\\n    }\\n    vector<int> allPrime(int l, int r){\\n        sieve(1,1001);\\n        vector<int> result;\\n        for (int i = l; i <= r; i++)\\n            if (prime[i])\\n                result.push_back(i);\\n        return result;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        if(nums.size()==1) return 1;\\n        vector<int>v=allPrime(2,1000);\\n         int k=-1,f=0;\\n         for(int i=0;i<v.size();i++){\\n             if(nums[0]<=v[i]){\\n                 k=i-1;\\n                 break;\\n             }\\n             if(i==v.size()-1 && nums[0]>v.size())f=1;\\n         }\\n         if(f==0 && k!=-1)nums[0]-=v[k];\\n         else if(f==1)nums[0]-=v[v.size()-1];\\n         for(int i=1;i<nums.size();i++){\\n             if(nums[i]<=nums[i-1])return false;\\n             k=-1;\\n             for(int j=0;j<v.size();j++)\\n                 if(nums[i]-v[j]<0 || nums[i]-v[j]<=nums[i-1]){\\n                     k=j-1;\\n                     break;\\n                 }\\n                 if(k!=-1)nums[i]=nums[i]-v[k];\\n         }  \\n         return nums[nums.size()-1]>nums[nums.size()-2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036404,
                "title": "golang-binary-search-solution",
                "content": "# Code\\n```go\\nfunc primeSubOperation(nums []int) bool {\\n\\tprimes := make([]int, 0, 32)\\n\\tfor i := 2; i < 1000; i++ {\\n\\t\\tif isPrime(i) == true {\\n\\t\\t\\tprimes = append(primes, i)\\n\\t\\t}\\n\\t}\\n\\tidx := findFirstLessThan(primes, nums[0])\\n\\tif idx >= 0 {\\n\\t\\t// make nums[0] as little as possible\\n\\t\\tnums[0] -= primes[idx]\\n\\t}\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tdiff := nums[i] - nums[i-1]\\n\\t\\tidx := findFirstLessThan(primes, diff)\\n\\t\\tif idx >= 0 {\\n\\t\\t\\t// make nums[i] as little as possible\\n\\t\\t\\tnums[i] -= primes[idx]\\n\\t\\t}\\n\\t\\tif nums[i] <= nums[i-1] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc findFirstLessThan(nums []int, val int) int {\\n\\tl, r := 0, len(nums)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif nums[m] < val {\\n\\t\\t\\tl = m+1\\n\\t\\t} else {\\n\\t\\t\\tr = m-1\\n\\t\\t}\\n\\t}\\n\\treturn l-1\\n}\\n\\nfunc isPrime(v int) bool {\\n\\tswitch {\\n\\tcase v == 1:\\n\\t\\treturn false\\n\\tcase v <= 3:\\n\\t\\treturn true\\n\\tcase v%2 == 0:\\n\\t\\treturn false\\n\\tdefault:\\n\\t}\\n\\tfor i := 3; i*i <= v; i += 2 {\\n\\t\\tif v%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc primeSubOperation(nums []int) bool {\\n\\tprimes := make([]int, 0, 32)\\n\\tfor i := 2; i < 1000; i++ {\\n\\t\\tif isPrime(i) == true {\\n\\t\\t\\tprimes = append(primes, i)\\n\\t\\t}\\n\\t}\\n\\tidx := findFirstLessThan(primes, nums[0])\\n\\tif idx >= 0 {\\n\\t\\t// make nums[0] as little as possible\\n\\t\\tnums[0] -= primes[idx]\\n\\t}\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tdiff := nums[i] - nums[i-1]\\n\\t\\tidx := findFirstLessThan(primes, diff)\\n\\t\\tif idx >= 0 {\\n\\t\\t\\t// make nums[i] as little as possible\\n\\t\\t\\tnums[i] -= primes[idx]\\n\\t\\t}\\n\\t\\tif nums[i] <= nums[i-1] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc findFirstLessThan(nums []int, val int) int {\\n\\tl, r := 0, len(nums)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif nums[m] < val {\\n\\t\\t\\tl = m+1\\n\\t\\t} else {\\n\\t\\t\\tr = m-1\\n\\t\\t}\\n\\t}\\n\\treturn l-1\\n}\\n\\nfunc isPrime(v int) bool {\\n\\tswitch {\\n\\tcase v == 1:\\n\\t\\treturn false\\n\\tcase v <= 3:\\n\\t\\treturn true\\n\\tcase v%2 == 0:\\n\\t\\treturn false\\n\\tdefault:\\n\\t}\\n\\tfor i := 3; i*i <= v; i += 2 {\\n\\t\\tif v%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014092,
                "title": "100-space-efficient-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar primeSubOperation = function(nums) {\\n    function getPrimes(num) {\\n        let res = []\\n        let primes = new Array(num).fill(true)\\n        primes[0] = primes[1] = false\\n\\n        for(let i = 2; i <= Math.sqrt(num); ++i) {\\n            if(primes[i]) {\\n                for(let j = i * i; j <= num; j+=i) primes[j] = false\\n            }\\n        }\\n\\n        for(let i = 0; i <= num; ++i) if(primes[i]) res.push(i)\\n\\n        return res\\n    }\\n\\n    let primes = getPrimes(1010)\\n\\n    for(let i = nums.length - 1; i > 0; --i) {\\n        let j = 0\\n\\n        if (nums[i] > nums[i - 1]) continue\\n\\n        while (j <= primes.length - 1) {\\n            if(primes[j] >= nums[i-1]) return false\\n\\n            if((nums[i-1] - primes[j]) < nums[i]) {\\n                nums[i-1] = nums[i-1] - primes[j]\\n                needSub = false;\\n                break\\n            }\\n            j++\\n        }\\n    }\\n\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar primeSubOperation = function(nums) {\\n    function getPrimes(num) {\\n        let res = []\\n        let primes = new Array(num).fill(true)\\n        primes[0] = primes[1] = false\\n\\n        for(let i = 2; i <= Math.sqrt(num); ++i) {\\n            if(primes[i]) {\\n                for(let j = i * i; j <= num; j+=i) primes[j] = false\\n            }\\n        }\\n\\n        for(let i = 0; i <= num; ++i) if(primes[i]) res.push(i)\\n\\n        return res\\n    }\\n\\n    let primes = getPrimes(1010)\\n\\n    for(let i = nums.length - 1; i > 0; --i) {\\n        let j = 0\\n\\n        if (nums[i] > nums[i - 1]) continue\\n\\n        while (j <= primes.length - 1) {\\n            if(primes[j] >= nums[i-1]) return false\\n\\n            if((nums[i-1] - primes[j]) < nums[i]) {\\n                nums[i-1] = nums[i-1] - primes[j]\\n                needSub = false;\\n                break\\n            }\\n            j++\\n        }\\n    }\\n\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014025,
                "title": "try-taking-all-primes-dynamic-programming-brute-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n- Space Complexity : O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    \\n    int dp[1000][1005];\\n    \\n    vector<bool> sieve(int n) {\\n        vector<bool> isPrime(n+1, true);\\n        isPrime[0] = isPrime[1] = false;\\n        for(int i=2; (long long)i*i <= n; i++) {\\n            if(isPrime[i]) {\\n                for(int j=i*i; j<=n; j+=i) {\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n\\n        return isPrime;\\n    }\\n    \\n    vector<bool> prime;\\n    \\n    bool solve(int ind, int prev, vector<int> &nums) {\\n        if(ind >= nums.size()) return true;\\n        if(dp[ind][prev+1] != -1) return dp[ind][prev+1];\\n        \\n        for(int i = 0; i < 1000; i++) {\\n            if(!prime[i]) continue;\\n            if(i >= nums[ind]) break;\\n            \\n            int newNum = nums[ind] - i;\\n            if(prev < newNum || prev == -1) {\\n                int curRes = solve(ind+1, newNum, nums);\\n                if(curRes) return true;\\n            }\\n        }\\n        \\n        return dp[ind][prev+1] = false;\\n    }\\n    \\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        prime = sieve(1005);\\n        prime[0] = 1; // becuz we can take the number as it is without subtracting a prime \\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, -1, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\n    int dp[1000][1005];\\n    \\n    vector<bool> sieve(int n) {\\n        vector<bool> isPrime(n+1, true);\\n        isPrime[0] = isPrime[1] = false;\\n        for(int i=2; (long long)i*i <= n; i++) {\\n            if(isPrime[i]) {\\n                for(int j=i*i; j<=n; j+=i) {\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n\\n        return isPrime;\\n    }\\n    \\n    vector<bool> prime;\\n    \\n    bool solve(int ind, int prev, vector<int> &nums) {\\n        if(ind >= nums.size()) return true;\\n        if(dp[ind][prev+1] != -1) return dp[ind][prev+1];\\n        \\n        for(int i = 0; i < 1000; i++) {\\n            if(!prime[i]) continue;\\n            if(i >= nums[ind]) break;\\n            \\n            int newNum = nums[ind] - i;\\n            if(prev < newNum || prev == -1) {\\n                int curRes = solve(ind+1, newNum, nums);\\n                if(curRes) return true;\\n            }\\n        }\\n        \\n        return dp[ind][prev+1] = false;\\n    }\\n    \\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        prime = sieve(1005);\\n        prime[0] = 1; // becuz we can take the number as it is without subtracting a prime \\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, -1, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948417,
                "title": "greedy-approach-with-lower-bound-c-simple-and-easy",
                "content": "# intuition\\nThe solution uses a greedy approach to solve the problem. The main idea is to use the smallest prime number greater than or equal to each element in the nums vector to reduce that element so that the resulting array is strictly increasing. If no such prime number exists, it means that we cannot make the array strictly increasing using the given operation.\\n\\n\\n\\n# Code\\n```\\nvector<int> primes = {\\n    2,    3,    5,    7,    11,   13,   17,   19,   23,   29,\\n    31,   37,   41,   43,   47,   53,   59,   61,   67,   71,\\n    73,   79,   83,   89,   97,   101,  103,  107,  109,  113,\\n    127,  131,  137,  139,  149,  151,  157,  163,  167,  173,\\n    179,  181,  191,  193,  197,  199,  211,  223,  227,  229,\\n    233,  239,  241,  251,  257,  263,  269,  271,  277,  281,\\n    283,  293,  307,  311,  313,  317,  331,  337,  347,  349,\\n    353,  359,  367,  373,  379,  383,  389,  397,  401,  409,\\n    419,  421,  431,  433,  439,  443,  449,  457,  461,  463,\\n    467,  479,  487,  491,  499,  503,  509,  521,  523,  541,\\n    547,  557,  563,  569,  571,  577,  587,  593,  599,  601,\\n    607,  613,  617,  619,  631,  641,  643,  647,  653,  659,\\n    661,  673,  677,  683,  691,  701,  709,  719,  727,  733,\\n    739,  743,  751,  757,  761,  769,  773,  787,  797,  809,\\n    811,  821,  823,  827,  829,  839,  853,  857,  859,  863,\\n    877,  881,  883,  887,  907,  911,  919,  929,  937,  941,\\n    947,  953,  967,  971,  977,  983,  991,  997\\n};\\n\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            int idx = lower_bound(primes.begin(), primes.end(), nums[i] - (i ? nums[i-1] : 0)) - primes.begin();\\n            if(idx > 0)\\n                nums[i] -= primes[idx-1];\\n            if(i && nums[i] <= nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> primes = {\\n    2,    3,    5,    7,    11,   13,   17,   19,   23,   29,\\n    31,   37,   41,   43,   47,   53,   59,   61,   67,   71,\\n    73,   79,   83,   89,   97,   101,  103,  107,  109,  113,\\n    127,  131,  137,  139,  149,  151,  157,  163,  167,  173,\\n    179,  181,  191,  193,  197,  199,  211,  223,  227,  229,\\n    233,  239,  241,  251,  257,  263,  269,  271,  277,  281,\\n    283,  293,  307,  311,  313,  317,  331,  337,  347,  349,\\n    353,  359,  367,  373,  379,  383,  389,  397,  401,  409,\\n    419,  421,  431,  433,  439,  443,  449,  457,  461,  463,\\n    467,  479,  487,  491,  499,  503,  509,  521,  523,  541,\\n    547,  557,  563,  569,  571,  577,  587,  593,  599,  601,\\n    607,  613,  617,  619,  631,  641,  643,  647,  653,  659,\\n    661,  673,  677,  683,  691,  701,  709,  719,  727,  733,\\n    739,  743,  751,  757,  761,  769,  773,  787,  797,  809,\\n    811,  821,  823,  827,  829,  839,  853,  857,  859,  863,\\n    877,  881,  883,  887,  907,  911,  919,  929,  937,  941,\\n    947,  953,  967,  971,  977,  983,  991,  997\\n};\\n\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            int idx = lower_bound(primes.begin(), primes.end(), nums[i] - (i ? nums[i-1] : 0)) - primes.begin();\\n            if(idx > 0)\\n                nums[i] -= primes[idx-1];\\n            if(i && nums[i] <= nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944712,
                "title": "generating-all-primes-tilll-max-array-using-binary-search-to-find-best-prime-to-subtract",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int max = nums[0];\\n        for(int i : nums)\\n            if(max < i)\\n                max = i;\\n        List<Integer> primes = getAllPrimes(max);\\n        nums[0] -= getMaxPrime(nums[0]-1, primes); \\n        for(int i=1; i < nums.length; i++){\\n            if(nums[i-1] >= nums[i])\\n                return false; \\n            nums[i] -= getMaxPrime(nums[i]-nums[i-1]-1, primes);    \\n        }\\n        return true; \\n    }\\n\\n    int getMaxPrime(int upperBound, List<Integer> primes){\\n        int left = 0; \\n        int right = primes.size()-1;\\n        int maxPrime = 0; \\n        while(left <= right){\\n            int mid = left+(right-left)/2;\\n            int primeAtMid = primes.get(mid);\\n            if(primeAtMid > upperBound){\\n                right = mid-1; \\n            }else{\\n                maxPrime = primeAtMid; \\n                left = mid+1; \\n            }\\n        }\\n        return maxPrime; \\n    }\\n\\n    List<Integer> getAllPrimes(int N){\\n        boolean[] isNotPrime = new boolean[N+1];\\n        for(int i = 2 ; i*i <= N; i++){\\n            if(isNotPrime[i])\\n                continue; \\n            int j = i; \\n            while(i*j <= N){\\n                isNotPrime[i*j] = true; \\n                j++;\\n            }\\n        }\\n        List<Integer> primes = new ArrayList<>();\\n        for(int i=2; i<= N; i++){\\n            if(!isNotPrime[i])\\n                primes.add(i);\\n        }\\n        return primes; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int max = nums[0];\\n        for(int i : nums)\\n            if(max < i)\\n                max = i;\\n        List<Integer> primes = getAllPrimes(max);\\n        nums[0] -= getMaxPrime(nums[0]-1, primes); \\n        for(int i=1; i < nums.length; i++){\\n            if(nums[i-1] >= nums[i])\\n                return false; \\n            nums[i] -= getMaxPrime(nums[i]-nums[i-1]-1, primes);    \\n        }\\n        return true; \\n    }\\n\\n    int getMaxPrime(int upperBound, List<Integer> primes){\\n        int left = 0; \\n        int right = primes.size()-1;\\n        int maxPrime = 0; \\n        while(left <= right){\\n            int mid = left+(right-left)/2;\\n            int primeAtMid = primes.get(mid);\\n            if(primeAtMid > upperBound){\\n                right = mid-1; \\n            }else{\\n                maxPrime = primeAtMid; \\n                left = mid+1; \\n            }\\n        }\\n        return maxPrime; \\n    }\\n\\n    List<Integer> getAllPrimes(int N){\\n        boolean[] isNotPrime = new boolean[N+1];\\n        for(int i = 2 ; i*i <= N; i++){\\n            if(isNotPrime[i])\\n                continue; \\n            int j = i; \\n            while(i*j <= N){\\n                isNotPrime[i*j] = true; \\n                j++;\\n            }\\n        }\\n        List<Integer> primes = new ArrayList<>();\\n        for(int i=2; i<= N; i++){\\n            if(!isNotPrime[i])\\n                primes.add(i);\\n        }\\n        return primes; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917916,
                "title": "c-dp-sieve",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[1000][1001]; // can we make first i elements strictly increasing if the ith element is j ?\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> sieve(1001,1);\\n        sieve[0] = 1;\\n        sieve[1] = 0;\\n        for(int i=2;i<=1e3;i++)\\n        {\\n            if(sieve[i])\\n            {\\n                for(int j=2*i;j<=1e3;j+=i)\\n                {\\n                    sieve[j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<nums[0];i++)\\n        {\\n            if(sieve[i])\\n            dp[0][nums[0] - i] = 1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int lst = INT_MAX;\\n            for(int j=0;j<=nums[i - 1];j++)\\n            {\\n                if(dp[i - 1][j])\\n                {\\n                    lst = j;\\n                    break;\\n                }\\n            }\\n            for(int j=0;j<nums[i];j++)\\n            {\\n                if(sieve[j])\\n                {\\n                    if(nums[i] - j > lst)\\n                    dp[i][nums[i] - j] = 1;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<=nums[n - 1];i++)\\n        {\\n            ans |= dp[n - 1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[1000][1001]; // can we make first i elements strictly increasing if the ith element is j ?\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> sieve(1001,1);\\n        sieve[0] = 1;\\n        sieve[1] = 0;\\n        for(int i=2;i<=1e3;i++)\\n        {\\n            if(sieve[i])\\n            {\\n                for(int j=2*i;j<=1e3;j+=i)\\n                {\\n                    sieve[j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<nums[0];i++)\\n        {\\n            if(sieve[i])\\n            dp[0][nums[0] - i] = 1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int lst = INT_MAX;\\n            for(int j=0;j<=nums[i - 1];j++)\\n            {\\n                if(dp[i - 1][j])\\n                {\\n                    lst = j;\\n                    break;\\n                }\\n            }\\n            for(int j=0;j<nums[i];j++)\\n            {\\n                if(sieve[j])\\n                {\\n                    if(nums[i] - j > lst)\\n                    dp[i][nums[i] - j] = 1;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<=nums[n - 1];i++)\\n        {\\n            ans |= dp[n - 1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895599,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    bool primeSubOperation(vector<int> nums) {\\n        vector<int> prime;\\n        prime.push_back(2);\\n        for(int i=3;i<1000;i++){\\n            bool p=1;\\n            for(int j:prime){\\n                if(i%j==0) p=0;\\n            }\\n            if(p) prime.push_back(i);\\n        }\\n        int n=nums.size(),k=prime.size();\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>=nums[i+1]){\\n                int diff=nums[i]-nums[i+1];\\n                int ind=upper_bound(prime.begin(),prime.end(),diff)-prime.begin();\\n                if(ind==k || prime[ind]>=nums[i]) return 0;\\n                nums[i]-=prime[ind];\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    bool primeSubOperation(vector<int> nums) {\\n        vector<int> prime;\\n        prime.push_back(2);\\n        for(int i=3;i<1000;i++){\\n            bool p=1;\\n            for(int j:prime){\\n                if(i%j==0) p=0;\\n            }\\n            if(p) prime.push_back(i);\\n        }\\n        int n=nums.size(),k=prime.size();\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>=nums[i+1]){\\n                int diff=nums[i]-nums[i+1];\\n                int ind=upper_bound(prime.begin(),prime.end(),diff)-prime.begin();\\n                if(ind==k || prime[ind]>=nums[i]) return 0;\\n                nums[i]-=prime[ind];\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883260,
                "title": "brute-force-approach-using-hashset-and-sieve-of-eratosthenes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int max = 0;\\n        for(int num : nums){\\n            max = Math.max(num,max);\\n        }\\n\\n        HashSet<Integer> primeNums = sieveOfEratosthenes(max);\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(checkIfIncreasing(nums)) return true;\\n            int num = nums[i];\\n            for(int j=num-1;j>=0;j--){\\n                if(primeNums.contains(j)){\\n                    int diff = nums[i] - j;\\n                    if(i > 0 && i < nums.length-1){\\n                        if(diff > nums[i-1] && diff < nums[i+1]){\\n                            nums[i] = diff;\\n                            break;\\n                        }\\n                    }else{\\n                        nums[i] = diff;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    //seive of Eratosthenes, returns primes\\n    public HashSet<Integer> sieveOfEratosthenes(int n){\\n        int[] isPrimeArray = new int[n+1];\\n\\n        for(int i=2;i<=n;i++){\\n            if(isPrime(i)){\\n                isPrimeArray[i] = 1;\\n                for(int j=i*i;j<=n;j+=i){\\n                    isPrimeArray[j] = 0;\\n                }\\n            }\\n        }\\n\\n        HashSet<Integer> primeNums = new HashSet<>();\\n        for(int i=0;i<isPrimeArray.length;i++){\\n            if(isPrimeArray[i] == 1){\\n                primeNums.add(i);\\n            }\\n        }\\n\\n        return primeNums;\\n    }\\n\\n    public boolean isPrime(int n){\\n        for(int i=2;i<=Math.sqrt(n);i++){\\n            if(n%i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    //check after every step, the order is increasing or not\\n    public boolean checkIfIncreasing(int[] nums){\\n        for(int i=nums.length-1;i>0;i--){\\n            if(nums[i] <= nums[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int max = 0;\\n        for(int num : nums){\\n            max = Math.max(num,max);\\n        }\\n\\n        HashSet<Integer> primeNums = sieveOfEratosthenes(max);\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(checkIfIncreasing(nums)) return true;\\n            int num = nums[i];\\n            for(int j=num-1;j>=0;j--){\\n                if(primeNums.contains(j)){\\n                    int diff = nums[i] - j;\\n                    if(i > 0 && i < nums.length-1){\\n                        if(diff > nums[i-1] && diff < nums[i+1]){\\n                            nums[i] = diff;\\n                            break;\\n                        }\\n                    }else{\\n                        nums[i] = diff;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n    //seive of Eratosthenes, returns primes\\n    public HashSet<Integer> sieveOfEratosthenes(int n){\\n        int[] isPrimeArray = new int[n+1];\\n\\n        for(int i=2;i<=n;i++){\\n            if(isPrime(i)){\\n                isPrimeArray[i] = 1;\\n                for(int j=i*i;j<=n;j+=i){\\n                    isPrimeArray[j] = 0;\\n                }\\n            }\\n        }\\n\\n        HashSet<Integer> primeNums = new HashSet<>();\\n        for(int i=0;i<isPrimeArray.length;i++){\\n            if(isPrimeArray[i] == 1){\\n                primeNums.add(i);\\n            }\\n        }\\n\\n        return primeNums;\\n    }\\n\\n    public boolean isPrime(int n){\\n        for(int i=2;i<=Math.sqrt(n);i++){\\n            if(n%i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    //check after every step, the order is increasing or not\\n    public boolean checkIfIncreasing(int[] nums){\\n        for(int i=nums.length-1;i>0;i--){\\n            if(nums[i] <= nums[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864510,
                "title": "java-solution-some-explanation",
                "content": "# Approach\\n- Check for index `i` where `nums[i..nums.length]` is already sorted so that we only need to process for `0 <= j < i`\\n- Enumerate all primes number less than 1000\\n- Search for the prime $$p$$ where `nums[j] - p > nums[j-1]`. We can use binary search to efficiently find it.\\n- Replace `nums[j]` with `nums[j] - p`\\n- For each iteration, check if `nums[j] > nums[j-1]`, if it\\'s not then can\\'t have strictly increasing array.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(nlog168)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(168)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    final int[] primes = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n\\n    public void searchAndReplace(int[] nums, int i, int prev) {\\n        int left = -1, right = primes.length - 1;\\n\\n        while (left < right) {\\n            int mid = right - (right - left) / 2;\\n            if (nums[i] > primes[mid] + prev) left = mid;\\n            else right = mid - 1;\\n        }\\n\\n        if (right >= 0) {\\n            nums[i] -= primes[right];\\n        }\\n    }\\n\\n    public boolean primeSubOperation(int[] nums) {\\n        int i = nums.length - 1;\\n        while (i > 0 && nums[i] > nums[i - 1]) --i;\\n\\n        if (i == 0) \\n            return true;\\n\\n        int j = 1;\\n        searchAndReplace(nums, 0, 0);\\n        for (; j < i && nums[j] > nums[j - 1]; j++) {\\n            searchAndReplace(nums, j, nums[j - 1]);\\n        }\\n\\n        return (j == i) && (nums[i] > nums[i - 1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    final int[] primes = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n\\n    public void searchAndReplace(int[] nums, int i, int prev) {\\n        int left = -1, right = primes.length - 1;\\n\\n        while (left < right) {\\n            int mid = right - (right - left) / 2;\\n            if (nums[i] > primes[mid] + prev) left = mid;\\n            else right = mid - 1;\\n        }\\n\\n        if (right >= 0) {\\n            nums[i] -= primes[right];\\n        }\\n    }\\n\\n    public boolean primeSubOperation(int[] nums) {\\n        int i = nums.length - 1;\\n        while (i > 0 && nums[i] > nums[i - 1]) --i;\\n\\n        if (i == 0) \\n            return true;\\n\\n        int j = 1;\\n        searchAndReplace(nums, 0, 0);\\n        for (; j < i && nums[j] > nums[j - 1]; j++) {\\n            searchAndReplace(nums, j, nums[j - 1]);\\n        }\\n\\n        return (j == i) && (nums[i] > nums[i - 1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832174,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n      primes = self.primenumbers(1000+10)\\n      flag = True\\n      for i in range(len(nums)):\\n        if i == 0:\\n          if nums[i] > 2:\\n              nums[i] = self.binarysearch(primes,nums[i],0)\\n          if nums[i] < 0:\\n            falg = False\\n        else:\\n          if nums[i] >2:\\n            nums[i] = self.binarysearch(primes,nums[i],nums[i-1])\\n          if nums[i] <= nums[i-1]:\\n            flag = False\\n      print(nums)\\n      return flag\\n\\n    def primenumbers(self,limit):\\n      primes =[True for i in range(limit+1)]\\n      p =2 \\n      while p*p <= limit:\\n        if primes[p]:\\n          for i in range(p*p,limit+1,p):\\n            primes[i]= False\\n        p +=1 \\n      prime = [num for num in range(2,limit+1) if primes[num]]\\n      return prime\\n    def binarysearch(self,primes,currelement,prevelement):\\n      l = 0 \\n      r = len(primes)-1\\n      while l <=r :\\n        mid = (l+r)//2\\n        if primes[mid] == currelement:\\n          l = mid-1\\n          break\\n        elif primes[mid] < currelement:\\n           l = l +1\\n        elif primes[mid] > currelement:\\n          r -=1\\n      while l > 0  and prevelement >= currelement - primes[l]:\\n        l -= 1\\n      if currelement-primes[l] <= prevelement:\\n        pass\\n      else:\\n         currelement -=primes[l]\\n      return currelement\\n\"\"\"\\nThese test cases cover all the edge cases\\n[4,9,6,10]\\n[6,8,11,12]\\n[5,8,3]\\n[2,2]\\n[998,2]\\n[8,19,3,4,9]\\n\"\"\"\\n      \\n\\n\\n      \\n\\n\\n  \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n      primes = self.primenumbers(1000+10)\\n      flag = True\\n      for i in range(len(nums)):\\n        if i == 0:\\n          if nums[i] > 2:\\n              nums[i] = self.binarysearch(primes,nums[i],0)\\n          if nums[i] < 0:\\n            falg = False\\n        else:\\n          if nums[i] >2:\\n            nums[i] = self.binarysearch(primes,nums[i],nums[i-1])\\n          if nums[i] <= nums[i-1]:\\n            flag = False\\n      print(nums)\\n      return flag\\n\\n    def primenumbers(self,limit):\\n      primes =[True for i in range(limit+1)]\\n      p =2 \\n      while p*p <= limit:\\n        if primes[p]:\\n          for i in range(p*p,limit+1,p):\\n            primes[i]= False\\n        p +=1 \\n      prime = [num for num in range(2,limit+1) if primes[num]]\\n      return prime\\n    def binarysearch(self,primes,currelement,prevelement):\\n      l = 0 \\n      r = len(primes)-1\\n      while l <=r :\\n        mid = (l+r)//2\\n        if primes[mid] == currelement:\\n          l = mid-1\\n          break\\n        elif primes[mid] < currelement:\\n           l = l +1\\n        elif primes[mid] > currelement:\\n          r -=1\\n      while l > 0  and prevelement >= currelement - primes[l]:\\n        l -= 1\\n      if currelement-primes[l] <= prevelement:\\n        pass\\n      else:\\n         currelement -=primes[l]\\n      return currelement\\n\"\"\"\\nThese test cases cover all the edge cases\\n[4,9,6,10]\\n[6,8,11,12]\\n[5,8,3]\\n[2,2]\\n[998,2]\\n[8,19,3,4,9]\\n\"\"\"\\n      \\n\\n\\n      \\n\\n\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794730,
                "title": "one-of-the-best-question-on-prime-factorization-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> isprime;\\n    void seive(int n){\\n        isprime.resize(n+1,1);\\n        isprime[0] = isprime[1] = 0;\\n        for(int i=2;i<=n;i++){\\n            if(isprime[i] == 1){\\n                for(int j = 2*i;j<=n;j+=i){\\n                    isprime[j] = 0;\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        //for each element we have to check all the prime number which is less than\\n        seive(1000);\\n        //let us store all the isprime number less than 1000\\n        vector<int> p;\\n        for(int i=2;i<=1000;i++){\\n            if(isprime[i] == 1){\\n                p.push_back(i);\\n            }\\n        }\\n\\n        vector<int> arr;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i == 0){\\n                int findind = lower_bound(p.begin(),p.end(),nums[i]) - p.begin();\\n                if(findind>0){\\n                    nums[i]-=p[findind-1];//i substract the prime number from nums[i] which is just less than nums[i]\\n                }\\n            }\\n            else{\\n                int findind = lower_bound(p.begin(),p.end(),nums[i] -nums[i-1]) - p.begin();\\n                //p[findind] will give us the prime no which is greater or equal to nums[i] - nums[i-1]\\n                //but we need to find the samller prime number \\n                if(findind>0){\\n                    nums[i]-=p[findind-1];\\n                }\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++)cout<<nums[i]<<\" \";\\n        for(int i=1;i<n;i++){\\n            if(nums[i] <= nums[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> isprime;\\n    void seive(int n){\\n        isprime.resize(n+1,1);\\n        isprime[0] = isprime[1] = 0;\\n        for(int i=2;i<=n;i++){\\n            if(isprime[i] == 1){\\n                for(int j = 2*i;j<=n;j+=i){\\n                    isprime[j] = 0;\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        //for each element we have to check all the prime number which is less than\\n        seive(1000);\\n        //let us store all the isprime number less than 1000\\n        vector<int> p;\\n        for(int i=2;i<=1000;i++){\\n            if(isprime[i] == 1){\\n                p.push_back(i);\\n            }\\n        }\\n\\n        vector<int> arr;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i == 0){\\n                int findind = lower_bound(p.begin(),p.end(),nums[i]) - p.begin();\\n                if(findind>0){\\n                    nums[i]-=p[findind-1];//i substract the prime number from nums[i] which is just less than nums[i]\\n                }\\n            }\\n            else{\\n                int findind = lower_bound(p.begin(),p.end(),nums[i] -nums[i-1]) - p.begin();\\n                //p[findind] will give us the prime no which is greater or equal to nums[i] - nums[i-1]\\n                //but we need to find the samller prime number \\n                if(findind>0){\\n                    nums[i]-=p[findind-1];\\n                }\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++)cout<<nums[i]<<\" \";\\n        for(int i=1;i<n;i++){\\n            if(nums[i] <= nums[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3773865,
                "title": "c-solution-greedy-sol-brute-force-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    vector<int> primes;\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1)\\n            return 0;\\n        for (int i = 2; i <= sqrt(n); i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    void findPrimes(){\\n        for(int i=2;i<=1000;i++){\\n            if(isPrime(i))\\n                primes.push_back(i);\\n        }\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n=nums.size();\\n        findPrimes();\\n        for(int i=0;i<n;i++){\\n            if(i>0 && nums[i]<=nums[i-1]) \\n                return 0;\\n            int p = lower_bound(primes.begin(),primes.end(),nums[i]) - primes.begin();\\n            for(int j=p-1;j>=0;j--) {\\n                if(i==0 || nums[i]-primes[j]>nums[i-1]){\\n                    nums[i] -= primes[j];\\n                    break;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> primes;\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1)\\n            return 0;\\n        for (int i = 2; i <= sqrt(n); i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    void findPrimes(){\\n        for(int i=2;i<=1000;i++){\\n            if(isPrime(i))\\n                primes.push_back(i);\\n        }\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n=nums.size();\\n        findPrimes();\\n        for(int i=0;i<n;i++){\\n            if(i>0 && nums[i]<=nums[i-1]) \\n                return 0;\\n            int p = lower_bound(primes.begin(),primes.end(),nums[i]) - primes.begin();\\n            for(int j=p-1;j>=0;j--) {\\n                if(i==0 || nums[i]-primes[j]>nums[i-1]){\\n                    nums[i] -= primes[j];\\n                    break;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762972,
                "title": "idiomatic-ish-rust-solution",
                "content": "This probably isn\\'t _as_ optimal as it could be but I\\'m generally focused on solutions that get pretty close while maintaining good Rust patterns/usage.\\n\\n# Intuition\\nSince you can only change each number once, it makes sense to go right-to-left, since you can take a greedy approach that way while maintaining the optimal solution\\n\\n# Approach\\nGo right to left and subtract the smallest prime that satisfies: 0 < nums[i] < nums[i + 1]\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ for 1001-element vector of cached primes\\n\\n# Code\\n```\\nuse std::ops::Range;\\n\\n#[derive(Clone, Copy)]\\nenum PrimeState {\\n    Composite,\\n    Prime,\\n    Unknown,\\n}\\n\\n// No derive default on enums in leetcode\\'s Rust toolchain :(\\nimpl Default for PrimeState {\\n    fn default() -> Self {\\n        PrimeState::Unknown\\n    }\\n}\\n\\nstruct PrimeFinder {\\n    cache: [PrimeState; 1001],\\n}\\n\\nimpl Default for PrimeFinder {\\n    fn default() -> Self {\\n        let mut res = Self {\\n            cache: [PrimeState::default(); 1001],\\n        };\\n        // Special case: 2 is prime\\n        res.cache[2] = PrimeState::Prime;\\n        res\\n    }\\n}\\n\\nimpl PrimeFinder {\\n    /// Returns whether or not the number is prime\\n    fn is_prime(&mut self, n: i32) -> bool {\\n        match self.cache[n as usize] {\\n            PrimeState::Composite => false,\\n            PrimeState::Prime => true,\\n            PrimeState::Unknown => {\\n                let prime = (2..n).find(|i| n % i == 0).is_none();\\n                if prime {\\n                    self.cache[n as usize] = PrimeState::Prime;\\n                } else {\\n                    self.cache[n as usize] = PrimeState::Composite;\\n                }\\n\\n                prime\\n            }\\n        }\\n    }\\n\\n    /// Takes a range of i32s and returns the lowest prime among them, if any\\n    fn find_lowest_prime(&mut self, mut range: Range<i32>) -> Option<i32> {\\n        range.find(|n| self.is_prime(*n))\\n    }\\n}\\n\\nimpl Solution {\\n    #[allow(unused)]\\n    pub fn prime_sub_operation(mut nums: Vec<i32>) -> bool {\\n        // Cache primes\\n        let mut prime_finder = PrimeFinder::default();\\n\\n        // Range to fixup over is all but the last number: [0, nums.len() - 1)\\n        for i in (0..(nums.len() - 1)).rev() {\\n            // Fixup this index to make strictly less than its successor\\n            if nums[i] >= nums[i + 1] {\\n                // Start at the lowest prime number you\\'d have to subtract to make nums[i] < nums[i + 1], end with nums[i] - 1\\n                // If we turn any element into 1 along the way, the range will be empty on the next iteration\\n                let prime_search_range = (i32::max(nums[i] - nums[i + 1] + 1, 2))..nums[i];\\n                // Find lowest prime in the given range to subtract from nums[i]\\n                if let Some(lowest_prime) = prime_finder.find_lowest_prime(prime_search_range) {\\n                    nums[i] -= lowest_prime;\\n                } else {\\n                    // Could not find a prime smaller than nums[i] but large enough to make nums[i] < nums[i + 1]\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::ops::Range;\\n\\n#[derive(Clone, Copy)]\\nenum PrimeState {\\n    Composite,\\n    Prime,\\n    Unknown,\\n}\\n\\n// No derive default on enums in leetcode\\'s Rust toolchain :(\\nimpl Default for PrimeState {\\n    fn default() -> Self {\\n        PrimeState::Unknown\\n    }\\n}\\n\\nstruct PrimeFinder {\\n    cache: [PrimeState; 1001],\\n}\\n\\nimpl Default for PrimeFinder {\\n    fn default() -> Self {\\n        let mut res = Self {\\n            cache: [PrimeState::default(); 1001],\\n        };\\n        // Special case: 2 is prime\\n        res.cache[2] = PrimeState::Prime;\\n        res\\n    }\\n}\\n\\nimpl PrimeFinder {\\n    /// Returns whether or not the number is prime\\n    fn is_prime(&mut self, n: i32) -> bool {\\n        match self.cache[n as usize] {\\n            PrimeState::Composite => false,\\n            PrimeState::Prime => true,\\n            PrimeState::Unknown => {\\n                let prime = (2..n).find(|i| n % i == 0).is_none();\\n                if prime {\\n                    self.cache[n as usize] = PrimeState::Prime;\\n                } else {\\n                    self.cache[n as usize] = PrimeState::Composite;\\n                }\\n\\n                prime\\n            }\\n        }\\n    }\\n\\n    /// Takes a range of i32s and returns the lowest prime among them, if any\\n    fn find_lowest_prime(&mut self, mut range: Range<i32>) -> Option<i32> {\\n        range.find(|n| self.is_prime(*n))\\n    }\\n}\\n\\nimpl Solution {\\n    #[allow(unused)]\\n    pub fn prime_sub_operation(mut nums: Vec<i32>) -> bool {\\n        // Cache primes\\n        let mut prime_finder = PrimeFinder::default();\\n\\n        // Range to fixup over is all but the last number: [0, nums.len() - 1)\\n        for i in (0..(nums.len() - 1)).rev() {\\n            // Fixup this index to make strictly less than its successor\\n            if nums[i] >= nums[i + 1] {\\n                // Start at the lowest prime number you\\'d have to subtract to make nums[i] < nums[i + 1], end with nums[i] - 1\\n                // If we turn any element into 1 along the way, the range will be empty on the next iteration\\n                let prime_search_range = (i32::max(nums[i] - nums[i + 1] + 1, 2))..nums[i];\\n                // Find lowest prime in the given range to subtract from nums[i]\\n                if let Some(lowest_prime) = prime_finder.find_lowest_prime(prime_search_range) {\\n                    nums[i] -= lowest_prime;\\n                } else {\\n                    // Could not find a prime smaller than nums[i] but large enough to make nums[i] < nums[i + 1]\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745531,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n          int diff = 0;\\n        for(int val : nums) {\\n            if(val <= diff) return false;\\n            int prime = val - diff - 1;\\n            while(prime > 0 && !isPrime(prime)) {\\n                prime--;\\n            }\\n            if(prime > 0) {\\n                diff = val - prime;\\n            } else {\\n                diff = val;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n   public boolean isPrime(int n)\\n    {\\n \\n        if (n <= 1)\\n            return false;\\n \\n        else if (n == 2)\\n            return true;\\n\\n        else if (n % 2 == 0)\\n            return false;\\n \\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n          int diff = 0;\\n        for(int val : nums) {\\n            if(val <= diff) return false;\\n            int prime = val - diff - 1;\\n            while(prime > 0 && !isPrime(prime)) {\\n                prime--;\\n            }\\n            if(prime > 0) {\\n                diff = val - prime;\\n            } else {\\n                diff = val;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n   public boolean isPrime(int n)\\n    {\\n \\n        if (n <= 1)\\n            return false;\\n \\n        else if (n == 2)\\n            return true;\\n\\n        else if (n % 2 == 0)\\n            return false;\\n \\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744381,
                "title": "prime-subtraction-operation-leetcode",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool prime(int n){\\n        for(int i = 2; i <= sqrt(n); i++){\\n            if(n%i == 0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> p;\\n        int i,n=nums.size(),j,x;\\n        for(i = 2; i <= 1000; i++){\\n            if(prime(i)){\\n                p.push_back(i);\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                j = p.size();\\n                while(j--){\\n                    if(p[j]<nums[i]){\\n                        break;\\n                    }\\n                }\\n                if(j==-1)\\n                continue;\\n                nums[i] -= p[j];\\n            }else{\\n                j = p.size(),x=0;\\n                while(j--){\\n                    if(nums[i]-p[j] > nums[i-1]&&p[j]<nums[i]){\\n                        x = p[j];\\n                        break;\\n                    }\\n                }\\n                if(j>=0){\\n                    nums[i] -= x;\\n                }\\n            }\\n        }\\n        for(i = 1; i < n; i++){\\n            if(nums[i-1]>=nums[i])\\n            return false;\\n\\n        }\\n        return true;\\n    }\\nBy ~ Shubham Verma\\n};\\n```\\n![7cfadaec-4ab3-45e4-9ad8-313c2db992f9_1678433858.6366765.png](https://assets.leetcode.com/users/images/0c6f6f00-a990-4be0-82c1-48b8c3be2b37_1688977071.4682095.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prime(int n){\\n        for(int i = 2; i <= sqrt(n); i++){\\n            if(n%i == 0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> p;\\n        int i,n=nums.size(),j,x;\\n        for(i = 2; i <= 1000; i++){\\n            if(prime(i)){\\n                p.push_back(i);\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                j = p.size();\\n                while(j--){\\n                    if(p[j]<nums[i]){\\n                        break;\\n                    }\\n                }\\n                if(j==-1)\\n                continue;\\n                nums[i] -= p[j];\\n            }else{\\n                j = p.size(),x=0;\\n                while(j--){\\n                    if(nums[i]-p[j] > nums[i-1]&&p[j]<nums[i]){\\n                        x = p[j];\\n                        break;\\n                    }\\n                }\\n                if(j>=0){\\n                    nums[i] -= x;\\n                }\\n            }\\n        }\\n        for(i = 1; i < n; i++){\\n            if(nums[i-1]>=nums[i])\\n            return false;\\n\\n        }\\n        return true;\\n    }\\nBy ~ Shubham Verma\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736772,
                "title": "c-o-nlogn-prime-table-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a prime table and minus the biggest possible prime sum.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime[1001];\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> primeNums;\\n        memset(isPrime, 1, sizeof(isPrime));\\n        for (int i = 2; i <= sqrt(1000) + 1; i++) {\\n            if (isPrime[i]) {\\n                for (int j = i * i; j <= 1000; j+=i) {\\n                    isPrime[j] = false;\\n                }   \\n            }\\n        }\\n        \\n        for (int i = 2; i <= 1000; i++) {\\n            if (isPrime[i]) {\\n                primeNums.emplace_back(i);\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int upperBound = nums[i] - 1;\\n            if (i != 0) {\\n                upperBound = min(upperBound, nums[i] - nums[i - 1] - 1); \\n            }\\n            if (upperBound < 0) {\\n                return false;\\n            }\\n            else if (upperBound <= 1) {\\n                continue;\\n            }\\n            \\n            auto it = lower_bound(primeNums.begin(), primeNums.end(), upperBound);\\n            if (*it == upperBound) {\\n                nums[i] -= *it;   \\n            }\\n            else {\\n                nums[i] -= *(--it);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime[1001];\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> primeNums;\\n        memset(isPrime, 1, sizeof(isPrime));\\n        for (int i = 2; i <= sqrt(1000) + 1; i++) {\\n            if (isPrime[i]) {\\n                for (int j = i * i; j <= 1000; j+=i) {\\n                    isPrime[j] = false;\\n                }   \\n            }\\n        }\\n        \\n        for (int i = 2; i <= 1000; i++) {\\n            if (isPrime[i]) {\\n                primeNums.emplace_back(i);\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int upperBound = nums[i] - 1;\\n            if (i != 0) {\\n                upperBound = min(upperBound, nums[i] - nums[i - 1] - 1); \\n            }\\n            if (upperBound < 0) {\\n                return false;\\n            }\\n            else if (upperBound <= 1) {\\n                continue;\\n            }\\n            \\n            auto it = lower_bound(primeNums.begin(), primeNums.end(), upperBound);\\n            if (*it == upperBound) {\\n                nums[i] -= *it;   \\n            }\\n            else {\\n                nums[i] -= *(--it);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721120,
                "title": "python-almost-linear-solution-with-explanation",
                "content": "# Intuition\\nFirst we need to know all the primes numbers we can use. They are generated with the sieve of erathosphen which is $O(n \\\\log log n)$ time and it generates ~$log(n)$ numbers.\\n\\nNow we go over all the numbers and for each of them we are trying to subtract as big prime as we can (we can find position using binary search from log n numbers so it will be log log n). Then if the position can be found such that our new number is smaller than the previous number, we store previously smaller number and continue. If now, we short-circuit and return false.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log \\\\log n)$\\n\\n- Space complexity: $O(\\\\log n)$\\n\\n# Code\\n```\\nclass Solution:\\n  def primeSubOperation(self, nums: List[int]) -> bool:\\n    primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n    prev_small = 0\\n    for v in nums:\\n      pos, is_found = bisect_left(primes, v), False\\n      for i in range(pos - 1, -1, -1):\\n        if v - primes[i] > prev_small:\\n          prev_small = v - primes[i]\\n          is_found = True\\n          break\\n      if not is_found:\\n        return False\\n    \\n    return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def primeSubOperation(self, nums: List[int]) -> bool:\\n    primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n    prev_small = 0\\n    for v in nums:\\n      pos, is_found = bisect_left(primes, v), False\\n      for i in range(pos - 1, -1, -1):\\n        if v - primes[i] > prev_small:\\n          prev_small = v - primes[i]\\n          is_found = True\\n          break\\n      if not is_found:\\n        return False\\n    \\n    return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706968,
                "title": "c-sieve-alogrithm-beats-70-solutions-traverse-from-beginning-to-end-method",
                "content": "# Intuition\\nfind all prime nos. just greater than max of array and subtract the maximum possible prime no. such that it still remains bigger than prev element\\n\\n# Approach\\n1) Use sieve to find all primes till max+1\\n2) traverse the array and start filling your ans array\\n3) if ans is empty find biggest possible prime no. less than equal to nums[0];\\n4) when ans is not empty find a prime no. such that nums[i]-ans.back()-1<=prime this will make the curr element always bigger than prev ans element\\n5) traverse the ans array and check if all elements are in increasing order\\n\\n# Complexity\\n- Time complexity:\\nO(N* sqrt(N))\\n- Space complexity:\\nO(max(nums));\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sieve(int n) {\\n        vector<int> v(n + 1), ans;\\n        for (int i=2; i<=sqrt(n); i++) {\\n            if(!v[i]) {\\n                for (int j=i*i; j<=n; j+=i) v[j] = 1;\\n            }\\n        }\\n        for (int i=2; i<=n; i++) {\\n            if (!v[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int maxi=2;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n        }\\n        vector<int>prime=sieve(maxi+1);\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            auto idx=upper_bound(prime.begin(),prime.end(),nums[i]);\\n            if(ans.empty()){\\n                idx=lower_bound(prime.begin(),prime.end(),nums[i]);\\n                if(idx==prime.end()||*idx>=nums[i]){\\n                    idx--;\\n                }\\n            }\\n            else{\\n                idx=lower_bound(prime.begin(),prime.end(),nums[i]-ans.back());\\n                if(idx==prime.end()||*idx>=nums[i]-ans.back()){\\n                    idx--;\\n                }\\n            }\\n            int pos=idx-prime.begin();\\n            if(pos<0){\\n                ans.push_back(nums[i]);\\n                continue;\\n            }\\n            ans.push_back(nums[i]-*idx);\\n        }\\n        int curr=ans[0];\\n        for(int i=1;i<ans.size();i++){\\n            if(curr>=ans[i]){\\n                return false;\\n            }\\n            curr=ans[i];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sieve(int n) {\\n        vector<int> v(n + 1), ans;\\n        for (int i=2; i<=sqrt(n); i++) {\\n            if(!v[i]) {\\n                for (int j=i*i; j<=n; j+=i) v[j] = 1;\\n            }\\n        }\\n        for (int i=2; i<=n; i++) {\\n            if (!v[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int maxi=2;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n        }\\n        vector<int>prime=sieve(maxi+1);\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            auto idx=upper_bound(prime.begin(),prime.end(),nums[i]);\\n            if(ans.empty()){\\n                idx=lower_bound(prime.begin(),prime.end(),nums[i]);\\n                if(idx==prime.end()||*idx>=nums[i]){\\n                    idx--;\\n                }\\n            }\\n            else{\\n                idx=lower_bound(prime.begin(),prime.end(),nums[i]-ans.back());\\n                if(idx==prime.end()||*idx>=nums[i]-ans.back()){\\n                    idx--;\\n                }\\n            }\\n            int pos=idx-prime.begin();\\n            if(pos<0){\\n                ans.push_back(nums[i]);\\n                continue;\\n            }\\n            ans.push_back(nums[i]-*idx);\\n        }\\n        int curr=ans[0];\\n        for(int i=1;i<ans.size();i++){\\n            if(curr>=ans[i]){\\n                return false;\\n            }\\n            curr=ans[i];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691031,
                "title": "golang-sieve-of-eratosthenes-binary-search",
                "content": "# Code\\n```\\n// Calculate just once\\nvar Primes []int\\n\\nfunc primeSubOperation(nums []int) bool {\\n  // Use Sieve of Eratosthenes to calculate prime numbers up to N\\n  if len(Primes) == 0 {\\n    var marked [1001]bool\\n    marked[1] = true\\n    for i := 2; i <= 1000; i++ {\\n      if !marked[i] { // i is not marked; let\\'s mark its multipliers\\n        for j := i*i; j <= 1000; j += i {\\n          marked[j] = true\\n        }\\n      }\\n    }\\n    var primes []int\\n    for i := 2; i <= 1000; i++ {\\n      if !marked[i] {\\n        primes = append(primes, i)\\n      }\\n    }\\n    Primes = primes\\n  }\\n  // Our goal is to make the current number to be a minimum number that is greater\\n  // than the previous number but we only do that by subtracting only prime numbers\\n  prev := 0\\n  for i := 0; i < len(nums); i++ {\\n    curr := nums[i]\\n    j := binarySearch(Primes, nums[i] - prev - 1)\\n    if nums[i] - Primes[j] > prev && nums[i] - Primes[j] < curr {\\n      curr = nums[i] - Primes[j]\\n    }\\n    if curr <= prev {\\n      return false\\n    }\\n    prev = curr\\n  }\\n  return true\\n}\\n\\n// binarySearch finds the number <= target\\nfunc binarySearch(nums []int, target int) int {\\n  var res int\\n  left, right := 0, len(nums)-1\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if nums[mid] > target {\\n      right = mid - 1\\n    } else {\\n      res = mid\\n      left = mid + 1\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\n// Calculate just once\\nvar Primes []int\\n\\nfunc primeSubOperation(nums []int) bool {\\n  // Use Sieve of Eratosthenes to calculate prime numbers up to N\\n  if len(Primes) == 0 {\\n    var marked [1001]bool\\n    marked[1] = true\\n    for i := 2; i <= 1000; i++ {\\n      if !marked[i] { // i is not marked; let\\'s mark its multipliers\\n        for j := i*i; j <= 1000; j += i {\\n          marked[j] = true\\n        }\\n      }\\n    }\\n    var primes []int\\n    for i := 2; i <= 1000; i++ {\\n      if !marked[i] {\\n        primes = append(primes, i)\\n      }\\n    }\\n    Primes = primes\\n  }\\n  // Our goal is to make the current number to be a minimum number that is greater\\n  // than the previous number but we only do that by subtracting only prime numbers\\n  prev := 0\\n  for i := 0; i < len(nums); i++ {\\n    curr := nums[i]\\n    j := binarySearch(Primes, nums[i] - prev - 1)\\n    if nums[i] - Primes[j] > prev && nums[i] - Primes[j] < curr {\\n      curr = nums[i] - Primes[j]\\n    }\\n    if curr <= prev {\\n      return false\\n    }\\n    prev = curr\\n  }\\n  return true\\n}\\n\\n// binarySearch finds the number <= target\\nfunc binarySearch(nums []int, target int) int {\\n  var res int\\n  left, right := 0, len(nums)-1\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if nums[mid] > target {\\n      right = mid - 1\\n    } else {\\n      res = mid\\n      left = mid + 1\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3655786,
                "title": "prime-subtraction-operation-easy-approach-simple-and-fast",
                "content": "\\n\\n# Code\\n```\\nvector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};\\n\\n\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& v) {\\n        for(int i = 0; i < v.size(); i += 1) {\\n            if(i > 0 && v[i] <= v[i - 1]) return false;\\n            int idx = lower_bound(primes.begin(),primes.end(),v[i]) - primes.begin();\\n            for(int j = idx - 1; j >= 0; j -= 1) {\\n                if(i == 0 || v[i] - primes[j] > v[i - 1]) {\\n                    v[i] -= primes[j];break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nvector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};\\n\\n\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& v) {\\n        for(int i = 0; i < v.size(); i += 1) {\\n            if(i > 0 && v[i] <= v[i - 1]) return false;\\n            int idx = lower_bound(primes.begin(),primes.end(),v[i]) - primes.begin();\\n            for(int j = idx - 1; j >= 0; j -= 1) {\\n                if(i == 0 || v[i] - primes[j] > v[i - 1]) {\\n                    v[i] -= primes[j];break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640278,
                "title": "c-easy-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<bool>isprime(1001,false);\\n        for(int i=2;i<=1001;i++){\\n            bool wq = false;\\n            for(int j=2;j<=sqrt(i);j++){\\n                if(i%j==0){\\n                    wq=true;\\n                }\\n            }\\n            if(wq==false){\\n                isprime[i]=true;\\n            }\\n        }\\n        vector<int>prime;\\n        for(int i=2;i<=1001;i++){\\n            if(isprime[i]==true){\\n                prime.push_back(i);\\n            }\\n        }\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }\\n            else{\\n                int r = nums[i]-nums[i+1];\\n                int l= 0, h= prime.size()-1;\\n                int yy = -1;\\n                while(l<=h){\\n                    int mid = ((h-l)/2)+l;\\n                    if(prime[mid]>r){\\n                        yy=prime[mid];\\n                        h=mid-1;\\n                    }\\n                    else{\\n                        l=mid+1;\\n                    }\\n                }\\n                if(yy==-1){\\n                    return false;\\n                }\\n                else if(yy>=nums[i]){\\n                    return false;\\n                }\\n                else{\\n                    nums[i]=nums[i]-yy;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<bool>isprime(1001,false);\\n        for(int i=2;i<=1001;i++){\\n            bool wq = false;\\n            for(int j=2;j<=sqrt(i);j++){\\n                if(i%j==0){\\n                    wq=true;\\n                }\\n            }\\n            if(wq==false){\\n                isprime[i]=true;\\n            }\\n        }\\n        vector<int>prime;\\n        for(int i=2;i<=1001;i++){\\n            if(isprime[i]==true){\\n                prime.push_back(i);\\n            }\\n        }\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }\\n            else{\\n                int r = nums[i]-nums[i+1];\\n                int l= 0, h= prime.size()-1;\\n                int yy = -1;\\n                while(l<=h){\\n                    int mid = ((h-l)/2)+l;\\n                    if(prime[mid]>r){\\n                        yy=prime[mid];\\n                        h=mid-1;\\n                    }\\n                    else{\\n                        l=mid+1;\\n                    }\\n                }\\n                if(yy==-1){\\n                    return false;\\n                }\\n                else if(yy>=nums[i]){\\n                    return false;\\n                }\\n                else{\\n                    nums[i]=nums[i]-yy;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551458,
                "title": "convoluted-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMax(vector<int>& nums) {\\n        int max_num = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            max_num = max(max_num, nums[i]);\\n        }\\n        return max_num;\\n    }\\n\\n    bool isPrime(int n) {\\n        for (int i = 2; i * i <= n; ++i) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<int> findPrimes(int n) {\\n        vector<int> primes;\\n        for (int i = 2; i < n; ++i) {\\n            if (isPrime(i)) {\\n                primes.push_back(i);\\n            }\\n        }\\n        return primes;\\n    }\\n\\n    optional<int> maxPrimeLessEfficient(const vector<int>& primes, int n, int c) {\\n        int l = 0, h = (int)primes.size()-1;\\n        while (l <= h) {\\n            int m = (l + h + 1) / 2;\\n            if (n - primes[m] > c) {\\n                if (m == primes.size()-1 || n - primes[m+1] <= c) {\\n                    return primes[m];\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return nullopt;\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int max_num = findMax(nums);\\n        auto primes = findPrimes(max_num);\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int c = i == 0 ? 0 : nums[i-1];\\n            auto prime_or = maxPrimeLessEfficient(primes, nums[i], c);\\n            if (prime_or.has_value()) {\\n                nums[i] -= prime_or.value();\\n            } \\n        }\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i-1] >= nums[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMax(vector<int>& nums) {\\n        int max_num = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            max_num = max(max_num, nums[i]);\\n        }\\n        return max_num;\\n    }\\n\\n    bool isPrime(int n) {\\n        for (int i = 2; i * i <= n; ++i) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<int> findPrimes(int n) {\\n        vector<int> primes;\\n        for (int i = 2; i < n; ++i) {\\n            if (isPrime(i)) {\\n                primes.push_back(i);\\n            }\\n        }\\n        return primes;\\n    }\\n\\n    optional<int> maxPrimeLessEfficient(const vector<int>& primes, int n, int c) {\\n        int l = 0, h = (int)primes.size()-1;\\n        while (l <= h) {\\n            int m = (l + h + 1) / 2;\\n            if (n - primes[m] > c) {\\n                if (m == primes.size()-1 || n - primes[m+1] <= c) {\\n                    return primes[m];\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return nullopt;\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int max_num = findMax(nums);\\n        auto primes = findPrimes(max_num);\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int c = i == 0 ? 0 : nums[i-1];\\n            auto prime_or = maxPrimeLessEfficient(primes, nums[i], c);\\n            if (prime_or.has_value()) {\\n                nums[i] -= prime_or.value();\\n            } \\n        }\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i-1] >= nums[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544889,
                "title": "using-greedy-approach-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int prime[1001] = {0};\\n    void mark(int num){\\n        for(int i=num; i*num<1001; i++){\\n            prime[i*num] = 1;\\n        }\\n    }\\n    int perform(int n, int mn, int mx){\\n        for(int i=n-1; i>=2; i--){\\n            if(prime[i]==0 && n-i>mn && n-i<mx){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=2; i<=1000; i++){\\n            if(prime[i]==0){\\n                mark(i);\\n            }\\n        }\\n        int mn = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            int mx = i<nums.size()-1 ? nums[i+1] : 1e9;\\n            int num = perform(nums[i],mn,mx);\\n            nums[i] -= num;\\n            if(i-1>=0 && nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n            mn = nums[i];\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int prime[1001] = {0};\\n    void mark(int num){\\n        for(int i=num; i*num<1001; i++){\\n            prime[i*num] = 1;\\n        }\\n    }\\n    int perform(int n, int mn, int mx){\\n        for(int i=n-1; i>=2; i--){\\n            if(prime[i]==0 && n-i>mn && n-i<mx){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=2; i<=1000; i++){\\n            if(prime[i]==0){\\n                mark(i);\\n            }\\n        }\\n        int mn = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            int mx = i<nums.size()-1 ? nums[i+1] : 1e9;\\n            int num = perform(nums[i],mn,mx);\\n            nums[i] -= num;\\n            if(i-1>=0 && nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n            mn = nums[i];\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543054,
                "title": "fast-and-elegant-sieve-of-eratosthenes",
                "content": "# TL;DR\\n``` java []\\nclass Solution {\\n    private int[] primesUntil(int n) {\\n        if (n < 2) return new int[]{};\\n        var primes = new int[200];\\n        var composite = new boolean[n + 1];\\n        primes[0] = 2;\\n        var added = 1;\\n        for (int i = 3; i <= n; i += 2) {\\n            if (composite[i]) continue;\\n            primes[added++] = i;\\n            for (int j = i * i; j <= n; j += i) {\\n                composite[j] = true;\\n            }\\n        }\\n        return Arrays.copyOf(primes, added);\\n    }\\n\\n    public boolean primeSubOperation(int[] nums) {\\n        int max = 0;\\n        for (int n: nums) {\\n            max = Math.max(max, n);\\n        }\\n        var primes = primesUntil(max);\\n\\n        int prev = 0;\\n        for (var n : nums) {\\n            var pos = Arrays.binarySearch(primes, n - prev - 1);\\n            if (pos == -1 && n <= prev) return false;\\n            prev = n - (pos == -1 ? 0 : (pos < 0 ? primes[-pos - 2] : primes[pos]));\\n        }\\n        return true;\\n    }\\n}\\n```\\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n# Approach\\n\\nThe core idea is to make each number in the array larger than its predecessor by subtracting the largest prime number possible. This helps the array stay strictly increasing and gives us flexibility for subsequent elements.\\n\\nThe algorithm first generates all prime numbers up to the maximum number in `nums` using the Sieve of Eratosthenes algorithm.\\n\\nAfter this, the array is traversed. For each `nums[i]`, binary search is used to find the largest prime number less than `nums[i] - nums[i-1] - 1`. This prime number is the maximum value that can be subtracted from `nums[i]` such that it still remains greater than `nums[i-1]`.\\n\\nThe position of this prime number in the array is stored in the variable `pos`. If `pos` equals `-1`, it means that no prime number can be subtracted from `nums[i]` to make it larger than `nums[i-1]`, hence the algorithm returns `false`.\\n\\nHowever, if `pos` is not `-1` but negative, it indicates that the exact prime is not found, but we have a prime smaller than `nums[i] - nums[i-1] - 1`, which is indicated by `primes[-pos - 2]`. If `pos` is non-negative, we have found the exact prime to subtract from `nums[i]`.\\n\\n# Complexity\\n\\n- Time complexity: $$O(n \\\\log n + n \\\\log p)$$, where `n` is the length of `nums` and `p` is the count of primes less than `max`.\\n- Space complexity: $$O(n)$$ for the array of primes.",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    private int[] primesUntil(int n) {\\n        if (n < 2) return new int[]{};\\n        var primes = new int[200];\\n        var composite = new boolean[n + 1];\\n        primes[0] = 2;\\n        var added = 1;\\n        for (int i = 3; i <= n; i += 2) {\\n            if (composite[i]) continue;\\n            primes[added++] = i;\\n            for (int j = i * i; j <= n; j += i) {\\n                composite[j] = true;\\n            }\\n        }\\n        return Arrays.copyOf(primes, added);\\n    }\\n\\n    public boolean primeSubOperation(int[] nums) {\\n        int max = 0;\\n        for (int n: nums) {\\n            max = Math.max(max, n);\\n        }\\n        var primes = primesUntil(max);\\n\\n        int prev = 0;\\n        for (var n : nums) {\\n            var pos = Arrays.binarySearch(primes, n - prev - 1);\\n            if (pos == -1 && n <= prev) return false;\\n            prev = n - (pos == -1 ? 0 : (pos < 0 ? primes[-pos - 2] : primes[pos]));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522193,
                "title": "sieve-of-erothostenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prime[1007];\\n    void sieve(){\\n        //int prime[n];\\n        //memset(prime,0,sizeof(prime));\\n        for(int i=2;i*i<=1000;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=1000;j+=i){\\n                    prime[j]=1;\\n                }\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        sieve();\\n        int s=0,f=true;\\n        for(int i=0;i<nums.size();i++){\\n            int y=nums[i]-(s+1);\\n            if(y<0){\\n                f=false;\\n                break;\\n            }\\n            for(int j=y;j>=2;j--){\\n                if(prime[j]==0){\\n                    nums[i]-=j;\\n                    s=nums[i];\\n                    break;\\n                }\\n            }\\n            s=nums[i];\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prime[1007];\\n    void sieve(){\\n        //int prime[n];\\n        //memset(prime,0,sizeof(prime));\\n        for(int i=2;i*i<=1000;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=1000;j+=i){\\n                    prime[j]=1;\\n                }\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        sieve();\\n        int s=0,f=true;\\n        for(int i=0;i<nums.size();i++){\\n            int y=nums[i]-(s+1);\\n            if(y<0){\\n                f=false;\\n                break;\\n            }\\n            for(int j=y;j>=2;j--){\\n                if(prime[j]==0){\\n                    nums[i]-=j;\\n                    s=nums[i];\\n                    break;\\n                }\\n            }\\n            s=nums[i];\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522192,
                "title": "sieve-of-erothostenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prime[1007];\\n    void sieve(){\\n        //int prime[n];\\n        //memset(prime,0,sizeof(prime));\\n        for(int i=2;i*i<=1000;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=1000;j+=i){\\n                    prime[j]=1;\\n                }\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        sieve();\\n        int s=0,f=true;\\n        for(int i=0;i<nums.size();i++){\\n            int y=nums[i]-(s+1);\\n            if(y<0){\\n                f=false;\\n                break;\\n            }\\n            for(int j=y;j>=2;j--){\\n                if(prime[j]==0){\\n                    nums[i]-=j;\\n                    s=nums[i];\\n                    break;\\n                }\\n            }\\n            s=nums[i];\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prime[1007];\\n    void sieve(){\\n        //int prime[n];\\n        //memset(prime,0,sizeof(prime));\\n        for(int i=2;i*i<=1000;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=1000;j+=i){\\n                    prime[j]=1;\\n                }\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        sieve();\\n        int s=0,f=true;\\n        for(int i=0;i<nums.size();i++){\\n            int y=nums[i]-(s+1);\\n            if(y<0){\\n                f=false;\\n                break;\\n            }\\n            for(int j=y;j>=2;j--){\\n                if(prime[j]==0){\\n                    nums[i]-=j;\\n                    s=nums[i];\\n                    break;\\n                }\\n            }\\n            s=nums[i];\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518554,
                "title": "c-straight-forward-solution-tc-o-n-k-sc-o-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSince the nums are less than 1000, first we could list all the prime numbers less than 1000 and try to make nums in strict increasing order.\\n\\n1. List all prime numbers less than 1000\\n2. Start from the tail, try to make the nums array strict increasing order. \\n  2.1. We try to substract from the minimum prime so that the left side of nums could easier to achieve the increase order  \\n3. Verify the final nums array for edge cases\\n\\n# Complexity\\n- Time complexity: O(n*k), K is the numbers of prime less than 1000 \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if(n < 2) return false;\\n        if(n == 2 || n == 3) return true;\\n        for(int i = 2;i <= sqrt(n); i++) {\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        // list all prime numbers less than 1000\\n        vector<int> primeList;\\n        for(int i = 2; i < 1000; i++) {\\n            if(isPrime(i)) primeList.push_back(i);\\n        }\\n\\n        int n = nums.size();\\n        for(int i = n-1; i > 0; i--) {\\n            if(nums[i] > nums[i-1]) continue;\\n            else {\\n                int diff = nums[i-1] - nums[i];\\n                // start from diff\\n                for(int j = 0; j < primeList.size();j++ ) {\\n                    if(primeList[j] <= diff) continue;\\n                    // substract the minimum prime that would make nums[i-1] strictly less than nums[i]\\n                    if(nums[i-1] - primeList[j] < nums[i]) {\\n                        nums[i-1] -= primeList[j];\\n                        break;\\n                    }\\n                }\\n                if(nums[i-1] <= 0) return false;\\n            }\\n        }\\n\\n        // verify the final nums\\n        bool ans = true;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] < nums[i-1]) ans = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if(n < 2) return false;\\n        if(n == 2 || n == 3) return true;\\n        for(int i = 2;i <= sqrt(n); i++) {\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        // list all prime numbers less than 1000\\n        vector<int> primeList;\\n        for(int i = 2; i < 1000; i++) {\\n            if(isPrime(i)) primeList.push_back(i);\\n        }\\n\\n        int n = nums.size();\\n        for(int i = n-1; i > 0; i--) {\\n            if(nums[i] > nums[i-1]) continue;\\n            else {\\n                int diff = nums[i-1] - nums[i];\\n                // start from diff\\n                for(int j = 0; j < primeList.size();j++ ) {\\n                    if(primeList[j] <= diff) continue;\\n                    // substract the minimum prime that would make nums[i-1] strictly less than nums[i]\\n                    if(nums[i-1] - primeList[j] < nums[i]) {\\n                        nums[i-1] -= primeList[j];\\n                        break;\\n                    }\\n                }\\n                if(nums[i-1] <= 0) return false;\\n            }\\n        }\\n\\n        // verify the final nums\\n        bool ans = true;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] < nums[i-1]) ans = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515634,
                "title": "with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int curr = 0;\\n\\t \\n     for(int i=0;i<nums.length;i++){\\n         int p = nums[i]-1;\\n         \\n         if(curr>=nums[i]) {         \\t \\n        \\t return false;}\\n         \\n         \\n       while(!isPrime(p)) {  // loop until prime is found\\n    \\t   p--; }\\n       \\n       while(curr>=nums[i]-p){   // if curr is smaller than current element- prime\\n           p--;\\n           while(!isPrime(p)) {\\n        \\t   p--; }}\\n       \\n       \\n       curr = nums[i]-p; }// set curr value to the difference\\n     return true;}\\n\\n\\n public static boolean isPrime(int x){    // getting prime number\\n     if(x==1) return false;\\n     if(x==2 || x==3) return true;\\n \\n     \\n     for(int i=2;i<=x/2;i++){\\n         if(x%i==0) { \\n        \\t return false;  }}\\n     \\n     return true;\\n }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int curr = 0;\\n\\t \\n     for(int i=0;i<nums.length;i++){\\n         int p = nums[i]-1;\\n         \\n         if(curr>=nums[i]) {         \\t \\n        \\t return false;}\\n         \\n         \\n       while(!isPrime(p)) {  // loop until prime is found\\n    \\t   p--; }\\n       \\n       while(curr>=nums[i]-p){   // if curr is smaller than current element- prime\\n           p--;\\n           while(!isPrime(p)) {\\n        \\t   p--; }}\\n       \\n       \\n       curr = nums[i]-p; }// set curr value to the difference\\n     return true;}\\n\\n\\n public static boolean isPrime(int x){    // getting prime number\\n     if(x==1) return false;\\n     if(x==2 || x==3) return true;\\n \\n     \\n     for(int i=2;i<=x/2;i++){\\n         if(x%i==0) { \\n        \\t return false;  }}\\n     \\n     return true;\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497860,
                "title": "c-reverse-iterate-and-subtract-smallest-prime",
                "content": "```\\nclass Solution {\\n    void sieve() {\\n        vector<bool> isprime(1001,true);\\n        for(int p = 2; p <= 1000; ++p) {\\n            if(isprime[p]) {\\n                primes.push_back(p);\\n                for(int n = p*p; n <= 1000; n += p) \\n                    isprime[n] = false;\\n            }\\n        }\\n    }\\n    vector<int> primes;\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        sieve();\\n        for(auto j = nums.rbegin(), i = ++nums.rbegin(); i != nums.rend(); ++i, ++j) {\\n            if(int delta = *i - *j; delta >= 0) {\\n                if(auto itr = lower_bound(primes.begin(), primes.end(), max(delta+1, 2)); itr != primes.end() && *itr < *i)\\n                    *i -= *itr;\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void sieve() {\\n        vector<bool> isprime(1001,true);\\n        for(int p = 2; p <= 1000; ++p) {\\n            if(isprime[p]) {\\n                primes.push_back(p);\\n                for(int n = p*p; n <= 1000; n += p) \\n                    isprime[n] = false;\\n            }\\n        }\\n    }\\n    vector<int> primes;\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        sieve();\\n        for(auto j = nums.rbegin(), i = ++nums.rbegin(); i != nums.rend(); ++i, ++j) {\\n            if(int delta = *i - *j; delta >= 0) {\\n                if(auto itr = lower_bound(primes.begin(), primes.end(), max(delta+1, 2)); itr != primes.end() && *itr < *i)\\n                    *i -= *itr;\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469528,
                "title": "c-solution-using-sieve-algorithm",
                "content": "\\n```\\npublic class Solution {\\n    public bool PrimeSubOperation(int[] nums) {\\n        bool increase = true;\\n        for(int i = 1; i < nums.Length;i++){\\n            if(nums[i] <= nums[i - 1]){\\n                increase = false;\\n                break;\\n            }\\n        }\\n        if(increase) return true;\\n        bool[] primes = new bool[1001];\\n        for(int i = 2; i < primes.Length;i++) primes[i] = true;\\n        for(int i = 2; i < primes.Length;i++){\\n            if(!primes[i]) continue;\\n            for(int j = i * 2; j < primes.Length;j+=i) primes[j] = false;\\n        }\\n\\n        int prev = 0; \\n        for(int i = 0; i < nums.Length;i++){\\n            for(int j = nums[i] - 1; j >= 2;j--){\\n                if(primes[j] && nums[i] - j > prev){\\n                    nums[i] = nums[i] - j;\\n                    break;\\n                }\\n            }\\n            if(nums[i] <= prev) return false;\\n            prev = nums[i];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public bool PrimeSubOperation(int[] nums) {\\n        bool increase = true;\\n        for(int i = 1; i < nums.Length;i++){\\n            if(nums[i] <= nums[i - 1]){\\n                increase = false;\\n                break;\\n            }\\n        }\\n        if(increase) return true;\\n        bool[] primes = new bool[1001];\\n        for(int i = 2; i < primes.Length;i++) primes[i] = true;\\n        for(int i = 2; i < primes.Length;i++){\\n            if(!primes[i]) continue;\\n            for(int j = i * 2; j < primes.Length;j+=i) primes[j] = false;\\n        }\\n\\n        int prev = 0; \\n        for(int i = 0; i < nums.Length;i++){\\n            for(int j = nums[i] - 1; j >= 2;j--){\\n                if(primes[j] && nums[i] - j > prev){\\n                    nums[i] = nums[i] - j;\\n                    break;\\n                }\\n            }\\n            if(nums[i] <= prev) return false;\\n            prev = nums[i];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466025,
                "title": "c-using-sieve-and-binarysearch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(max(mx, nlogn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mx)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> sieve(int n)\\n    {\\n        vector<int> ans;\\n        \\n        bool isPrime[n + 1]; \\n        memset(&isPrime, 0x00, sizeof(isPrime)); \\n        for(int i = 2; i <= n; i++) isPrime[i] = 1;\\n        \\n        for(int i = 2; i * i <= n; i++)\\n        {\\n            if(!isPrime[i]) continue;\\n\\n            for(int j = i * i; j <= n; j += i)\\n                isPrime[j] = 0;     \\n        }\\n\\n        for(int i = 0; i <= n; i++) if(isPrime[i]) ans.push_back(i);\\n\\n        return ans;\\n    }\\n\\n    int ceil(vector<int> &a, int x)\\n    {\\n        int ans = -1;\\n\\n        int beg = 0, end = a.size() - 1;\\n        while(beg <= end)\\n        {\\n            int mid = (beg + end) / 2;\\n            if(a[mid] > x)\\n            {\\n                ans = a[mid];\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool primeSubOperation(vector<int>& a) {\\n        int mx = a[0]; for(auto x : a) mx = max(mx, x);\\n        vector<int> prime = sieve(mx);\\n\\n        int n = a.size();\\n        //a[i] - p < a[i + 1] => p > a[i] - a[i + 1]\\n        //as per ques p < a[i] => a[i] - a[i + 1] < p < a[i]\\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(a[i] < a[i + 1]) continue;\\n\\n            int P = ceil(prime, a[i] - a[i + 1]);\\n            if(P == -1 || P >= a[i]) return 0; \\n            a[i] -= P;\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> sieve(int n)\\n    {\\n        vector<int> ans;\\n        \\n        bool isPrime[n + 1]; \\n        memset(&isPrime, 0x00, sizeof(isPrime)); \\n        for(int i = 2; i <= n; i++) isPrime[i] = 1;\\n        \\n        for(int i = 2; i * i <= n; i++)\\n        {\\n            if(!isPrime[i]) continue;\\n\\n            for(int j = i * i; j <= n; j += i)\\n                isPrime[j] = 0;     \\n        }\\n\\n        for(int i = 0; i <= n; i++) if(isPrime[i]) ans.push_back(i);\\n\\n        return ans;\\n    }\\n\\n    int ceil(vector<int> &a, int x)\\n    {\\n        int ans = -1;\\n\\n        int beg = 0, end = a.size() - 1;\\n        while(beg <= end)\\n        {\\n            int mid = (beg + end) / 2;\\n            if(a[mid] > x)\\n            {\\n                ans = a[mid];\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool primeSubOperation(vector<int>& a) {\\n        int mx = a[0]; for(auto x : a) mx = max(mx, x);\\n        vector<int> prime = sieve(mx);\\n\\n        int n = a.size();\\n        //a[i] - p < a[i + 1] => p > a[i] - a[i + 1]\\n        //as per ques p < a[i] => a[i] - a[i + 1] < p < a[i]\\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(a[i] < a[i + 1]) continue;\\n\\n            int P = ceil(prime, a[i] - a[i + 1]);\\n            if(P == -1 || P >= a[i]) return 0; \\n            a[i] -= P;\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463820,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> prime = new ArrayList<>();\\n        for(int i = 2; i <= 1000; i++)\\n        {\\n            if(isPrime(i))\\n            {\\n                prime.add(i);\\n            }\\n        }\\n        for(int i = nums.length - 2; i >= 0; i--)\\n        {\\n            if(nums[i] < nums[i + 1])\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                int idx = -1;\\n                for(int j = 0; j < prime.size(); j++)\\n                {\\n                    if(prime.get(j) >= nums[i])\\n                    {\\n                        break;\\n                    }\\n                    if(nums[i] - prime.get(j) < nums[i + 1])\\n                    {\\n                        idx = j;\\n                        break;\\n                    }\\n                }\\n                if(idx == -1)\\n                {\\n                    return false;\\n                }\\n                nums[i] = nums[i] - prime.get(idx);\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPrime(int x)\\n    {\\n        for(int i = 2; i <= Math.sqrt(x); i++)\\n        {\\n            if(x%i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> prime = new ArrayList<>();\\n        for(int i = 2; i <= 1000; i++)\\n        {\\n            if(isPrime(i))\\n            {\\n                prime.add(i);\\n            }\\n        }\\n        for(int i = nums.length - 2; i >= 0; i--)\\n        {\\n            if(nums[i] < nums[i + 1])\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                int idx = -1;\\n                for(int j = 0; j < prime.size(); j++)\\n                {\\n                    if(prime.get(j) >= nums[i])\\n                    {\\n                        break;\\n                    }\\n                    if(nums[i] - prime.get(j) < nums[i + 1])\\n                    {\\n                        idx = j;\\n                        break;\\n                    }\\n                }\\n                if(idx == -1)\\n                {\\n                    return false;\\n                }\\n                nums[i] = nums[i] - prime.get(idx);\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPrime(int x)\\n    {\\n        for(int i = 2; i <= Math.sqrt(x); i++)\\n        {\\n            if(x%i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437608,
                "title": "python3-sieve-algorithm-greedy",
                "content": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        isprime, primes = [True] * (max(nums) + 1), []\\n        for i in range(2, len(isprime)):\\n            if not isprime[i]: continue\\n            primes.append(i)\\n            j = 2 * i\\n            while j < len(isprime):\\n                isprime[j] = False\\n                j += i\\n        for i in range(len(nums)):\\n            v = nums[i]\\n            for p in primes:\\n                if p >= nums[i]: break\\n                if i == 0 or nums[i] - p > nums[i - 1]: v = nums[i] - p\\n            if i > 0 and v <= nums[i - 1]: return False\\n            nums[i] = v\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        isprime, primes = [True] * (max(nums) + 1), []\\n        for i in range(2, len(isprime)):\\n            if not isprime[i]: continue\\n            primes.append(i)\\n            j = 2 * i\\n            while j < len(isprime):\\n                isprime[j] = False\\n                j += i\\n        for i in range(len(nums)):\\n            v = nums[i]\\n            for p in primes:\\n                if p >= nums[i]: break\\n                if i == 0 or nums[i] - p > nums[i - 1]: v = nums[i] - p\\n            if i > 0 and v <= nums[i - 1]: return False\\n            nums[i] = v\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437147,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean isPrime(int x){\\n        if(x==0)\\n        return true;\\n        if(x==1)\\n        return false;\\n        for(int i=2;i<=Math.sqrt(x);i++){\\n            if(x%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int findPrime(int curr,int prev){\\n        for(int i=curr-1;i>=0;i--){\\n            if(curr-i>prev && isPrime(i))\\n            return curr-i;\\n        }\\n        return -1;\\n    }\\n    public boolean primeSubOperation(int[] nums) {\\n        int n=nums.length;\\n        int prev=0;\\n        for(int i=0;i<n;i++){\\n            int temp=findPrime(nums[i],prev);\\n            if(temp==-1)\\n            return false;\\n            prev=temp;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean isPrime(int x){\\n        if(x==0)\\n        return true;\\n        if(x==1)\\n        return false;\\n        for(int i=2;i<=Math.sqrt(x);i++){\\n            if(x%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int findPrime(int curr,int prev){\\n        for(int i=curr-1;i>=0;i--){\\n            if(curr-i>prev && isPrime(i))\\n            return curr-i;\\n        }\\n        return -1;\\n    }\\n    public boolean primeSubOperation(int[] nums) {\\n        int n=nums.length;\\n        int prev=0;\\n        for(int i=0;i<n;i++){\\n            int temp=findPrime(nums[i],prev);\\n            if(temp==-1)\\n            return false;\\n            prev=temp;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432892,
                "title": "c-seive-primes-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getprimes(int n){\\n       \\n       vector<int> temp;\\n       if(n==1 || n==0){\\n           return temp;\\n       }\\n       bool is_prime[n + 1];\\n       memset(is_prime, true, sizeof(is_prime));\\n       is_prime[0] = is_prime[1] = false;\\n       for (int p = 2; p * p <= n; p++) {\\n           if (is_prime[p]) {\\n               for (int i = p * p; i <= n; i += p) {\\n                   is_prime[i] = false;\\n               }\\n           }\\n       }\\n       for (int i = 2; i <= n; i++) {\\n          if (is_prime[i]) {\\n              temp.push_back(i);\\n          }\\n       }\\n        return temp;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n        vector<int> temp=getprimes(nums[0]-1);\\n        if(temp.size()!=0){\\n            nums[0]=nums[0]-temp[temp.size()-1];\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            \\n            if(nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n            vector<int> temp=getprimes(nums[i]-1);\\n            if(temp.size()!=0){\\n                 int start=0;\\n                 int end=temp.size()-1;\\n                 int index=-1;\\n                 while(start<=end){\\n                     \\n                     int mid=(start+end)/2;\\n                     if(nums[i]-temp[mid]>nums[i-1]){\\n                         index=mid;\\n                         start=mid+1;\\n                     }\\n                     else{\\n                         end=mid-1;\\n                     }\\n                 }\\n                 if(index!=-1){\\n                     nums[i]=nums[i]-temp[index];\\n                 }\\n            }\\n            \\n        }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> getprimes(int n){\\n       \\n       vector<int> temp;\\n       if(n==1 || n==0){\\n           return temp;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3432380,
                "title": "sieve-of-eratosthenes",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(log(n)))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sieve(vector<bool>& prime) {\\n        prime[0] = false;\\n        prime[1] = false;\\n        \\n        for (int p = 2 ; p*p <= 1000 ; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p ; i <= 1000 ; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<bool> prime(1001, true);\\n        sieve(prime);\\n        \\n        for(int i = nums.size() - 1 ; i>0 ; i--) {\\n            if(nums[i] <= nums[i-1]) {\\n                int minSubtract = nums[i-1] - nums[i] + 1;\\n                int maxSubtract = nums[i-1] - 1;\\n                int toSubtract = -1;\\n                                \\n                for(int j = minSubtract ; j <= maxSubtract ; j++) {\\n                    if(prime[j]) {\\n                        toSubtract = j;\\n                        break;\\n                    }\\n                }\\n                                                \\n                if(toSubtract == -1 || (nums[i-1] - toSubtract) <= 0) return false;\\n                \\n                nums[i-1] -= toSubtract;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sieve(vector<bool>& prime) {\\n        prime[0] = false;\\n        prime[1] = false;\\n        \\n        for (int p = 2 ; p*p <= 1000 ; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p ; i <= 1000 ; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<bool> prime(1001, true);\\n        sieve(prime);\\n        \\n        for(int i = nums.size() - 1 ; i>0 ; i--) {\\n            if(nums[i] <= nums[i-1]) {\\n                int minSubtract = nums[i-1] - nums[i] + 1;\\n                int maxSubtract = nums[i-1] - 1;\\n                int toSubtract = -1;\\n                                \\n                for(int j = minSubtract ; j <= maxSubtract ; j++) {\\n                    if(prime[j]) {\\n                        toSubtract = j;\\n                        break;\\n                    }\\n                }\\n                                                \\n                if(toSubtract == -1 || (nums[i-1] - toSubtract) <= 0) return false;\\n                \\n                nums[i-1] -= toSubtract;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421318,
                "title": "greedy-prime-subtraction-o-n-logn-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make nums a strictly increasing array, we need to subtract prime numbers from nums[i] such that nums[i] < nums[i+1] for all i. We will use a greedy approach by iterating through the array in reverse and checking if the current number nums[i] is greater than or equal to nums[i+1]. If it is, we will subtract a prime number from nums[i] to make it less than nums[i+1]. We continue this process until we reach the beginning of the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate through the array in reverse, starting from index n-2.\\n1. If nums[i] >= nums[i+1], subtract a prime number from nums[i] to make it less than nums[i+1].\\n1. Continue the process until the beginning of the array is reached.\\n1. Check if the updated nums array is strictly increasing.\\n# Complexity\\n- Time complexity: O(n*logn) - where n is the length of the input array \\'nums\\', considering the isPrime() function.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) - since we don\\'t use any additional data structures.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int n = nums.length;\\n\\n    // Step 1: Iterate through the array in reverse\\n    for (int i = n - 2; i >= 0; i--) {\\n        int num = nums[i];\\n\\n        // Step 2: If nums[i] >= nums[i+1], subtract a prime number from nums[i] to make it less than nums[i+1]\\n        if (num >= nums[i + 1]) {\\n            int guess = nums[i + 1] - 1;\\n            int diff = num - guess;\\n\\n            // Find a prime number to subtract\\n            while (!isPrime(diff)) {\\n                if (guess < i + 1) return false;\\n                guess--;\\n                diff++;\\n            }\\n\\n            // If it\\'s not possible to find a suitable prime, return false\\n            if (guess < i + 1) return false;\\n            nums[i] = guess;\\n        }\\n    }\\n\\n    // Step 4: Check if the updated nums array is strictly increasing\\n    return true;\\n    }\\n// Helper function to check if a number is prime\\n    private boolean isPrime(int num) {\\n        if (num < 2) return false;\\n        if (num == 2) return true;\\n        int left = 2;\\n        int right = num /2 + 1;\\n        while (left <= right) {\\n            if (num % left == 0) return false;\\n            left++;\\n            right = num / left + 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int n = nums.length;\\n\\n    // Step 1: Iterate through the array in reverse\\n    for (int i = n - 2; i >= 0; i--) {\\n        int num = nums[i];\\n\\n        // Step 2: If nums[i] >= nums[i+1], subtract a prime number from nums[i] to make it less than nums[i+1]\\n        if (num >= nums[i + 1]) {\\n            int guess = nums[i + 1] - 1;\\n            int diff = num - guess;\\n\\n            // Find a prime number to subtract\\n            while (!isPrime(diff)) {\\n                if (guess < i + 1) return false;\\n                guess--;\\n                diff++;\\n            }\\n\\n            // If it\\'s not possible to find a suitable prime, return false\\n            if (guess < i + 1) return false;\\n            nums[i] = guess;\\n        }\\n    }\\n\\n    // Step 4: Check if the updated nums array is strictly increasing\\n    return true;\\n    }\\n// Helper function to check if a number is prime\\n    private boolean isPrime(int num) {\\n        if (num < 2) return false;\\n        if (num == 2) return true;\\n        int left = 2;\\n        int right = num /2 + 1;\\n        while (left <= right) {\\n            if (num % left == 0) return false;\\n            left++;\\n            right = num / left + 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417033,
                "title": "easy-python-primesuboperation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart from the last second element and if it is greater then  next subtract min prime number to make it less than next(if after subtracting prime number the value  is less than or equal to 0 return False) and update next \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(mn)$$ -->(MN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(m)$$ -->(M)\\n\\n# Code\\n```\\nclass Solution(object):\\n    \\n    def createPrime(self,m):\\n        primearray=[True]*(m+1)\\n        primearray[0]=False\\n        primearray[1]=False\\n        for i in range(2,int(pow(m,0.5)+1)):\\n            if(primearray[i]):\\n                for j in range(i*i,m+1,i):\\n                    primearray[j]=False\\n        return primearray\\n    def nearestPrime(self,x,m,primearray):\\n         for i in range(x+1,m+1):\\n             if primearray[i]==True: return i\\n         return (-1)\\n    def primeSubOperation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        m=max(nums)\\n        next=nums[-1]\\n        size=len(nums)\\n        primearray=self.createPrime(m)\\n        for i in range(-2,-size-1,-1):\\n            if(nums[i]>=next):\\n                x=self.nearestPrime(nums[i]-next,m,primearray)\\n                if(x==-1):\\n                    return False\\n                next=nums[i]-x\\n                if(next<=0): \\n                     print(next)\\n                     return False\\n            else:\\n                next=nums[i]\\n        print(next)\\n        return True        \\n                \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def createPrime(self,m):\\n        primearray=[True]*(m+1)\\n        primearray[0]=False\\n        primearray[1]=False\\n        for i in range(2,int(pow(m,0.5)+1)):\\n            if(primearray[i]):\\n                for j in range(i*i,m+1,i):\\n                    primearray[j]=False\\n        return primearray\\n    def nearestPrime(self,x,m,primearray):\\n         for i in range(x+1,m+1):\\n             if primearray[i]==True: return i\\n         return (-1)\\n    def primeSubOperation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        m=max(nums)\\n        next=nums[-1]\\n        size=len(nums)\\n        primearray=self.createPrime(m)\\n        for i in range(-2,-size-1,-1):\\n            if(nums[i]>=next):\\n                x=self.nearestPrime(nums[i]-next,m,primearray)\\n                if(x==-1):\\n                    return False\\n                next=nums[i]-x\\n                if(next<=0): \\n                     print(next)\\n                     return False\\n            else:\\n                next=nums[i]\\n        print(next)\\n        return True        \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416457,
                "title": "python-binary-search-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\n`pre` record the the previous number after substract a prime\\nx is current number, and x - prime > pre, and x - pre > prime, so the prime is the larget prime < x - pre, we can use binary search to find it.\\nand if current number x <= pre, return False\\ntc is O(NlogN), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        p = self.getPrimeUnderBound(1000)\\n        pre = 0\\n        def findLeftBound(arr, target):\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m] >= target:\\n                    r = m\\n                else: l = m+1\\n            return l\\n        for x in nums:\\n            if x <= pre: return False\\n            pre = x - p[findLeftBound(p, x - pre)-1]\\n        return True\\n            \\n        \\n        \\n    def getPrimeUnderBound(self, bound):\\n        bound += 1\\n        sieve = [True] * bound\\n        for i in range(2, int(1000 ** 0.5) + 1):\\n            if sieve[i]:\\n                for j in range(i*i, bound, i):\\n                    sieve[j] = False\\n        p = [0]\\n        for i in range(2, bound):\\n            if sieve[i]: p.append(i)\\n        return p\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Binary Search"
                ],
                "code": "```python\\n\\'\\'\\'\\n`pre` record the the previous number after substract a prime\\nx is current number, and x - prime > pre, and x - pre > prime, so the prime is the larget prime < x - pre, we can use binary search to find it.\\nand if current number x <= pre, return False\\ntc is O(NlogN), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        p = self.getPrimeUnderBound(1000)\\n        pre = 0\\n        def findLeftBound(arr, target):\\n            l = 0\\n            r = len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if arr[m] >= target:\\n                    r = m\\n                else: l = m+1\\n            return l\\n        for x in nums:\\n            if x <= pre: return False\\n            pre = x - p[findLeftBound(p, x - pre)-1]\\n        return True\\n            \\n        \\n        \\n    def getPrimeUnderBound(self, bound):\\n        bound += 1\\n        sieve = [True] * bound\\n        for i in range(2, int(1000 ** 0.5) + 1):\\n            if sieve[i]:\\n                for j in range(i*i, bound, i):\\n                    sieve[j] = False\\n        p = [0]\\n        for i in range(2, bound):\\n            if sieve[i]: p.append(i)\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412122,
                "title": "python-sieve-of-eratosthenes-bs",
                "content": "Sieve of Eratosthenes for prime numbers generation.\\nBS to find `prime[mid] <= nums[i] - nums[i + 1]` as prime numbers are sorted.\\n\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        prime = [True for i in range(1000 + 1)]\\n        i = 2\\n        while i * i < 1000 + 1:\\n            for p in range(i * i, 1000 + 1, i):\\n                prime[p] = False\\n            i += 1\\n        prime = [p for p in range(2, 1000 + 1) if prime[p]]\\n        \\n        N = len(nums)\\n        P = len(prime)\\n        for i in reversed(range(N - 1)):\\n            if nums[i] >= nums[i + 1]:\\n                # left = 0\\n                # right = P\\n                # while left < right:\\n                #     mid = (left + right) // 2\\n                #     if nums[i] - prime[mid] >= nums[i + 1]:\\n                #         left = mid + 1\\n                #     else:\\n                #         right = mid\\n                left = bisect_right(prime, nums[i] - nums[i + 1])\\n                if left == P: # cannot find non-dupe prime (nums = [1000],3, prime=997 will create dupe)\\n                    return False\\n                nums[i] -= prime[left]\\n                if nums[i] <= 0: # 0 means prime == target or prime > target\\n                    return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        prime = [True for i in range(1000 + 1)]\\n        i = 2\\n        while i * i < 1000 + 1:\\n            for p in range(i * i, 1000 + 1, i):\\n                prime[p] = False\\n            i += 1\\n        prime = [p for p in range(2, 1000 + 1) if prime[p]]\\n        \\n        N = len(nums)\\n        P = len(prime)\\n        for i in reversed(range(N - 1)):\\n            if nums[i] >= nums[i + 1]:\\n                # left = 0\\n                # right = P\\n                # while left < right:\\n                #     mid = (left + right) // 2\\n                #     if nums[i] - prime[mid] >= nums[i + 1]:\\n                #         left = mid + 1\\n                #     else:\\n                #         right = mid\\n                left = bisect_right(prime, nums[i] - nums[i + 1])\\n                if left == P: # cannot find non-dupe prime (nums = [1000],3, prime=997 will create dupe)\\n                    return False\\n                nums[i] -= prime[left]\\n                if nums[i] <= 0: # 0 means prime == target or prime > target\\n                    return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395220,
                "title": "swift-linear-search-9-sloc",
                "content": "**Linear Search, 9 SLOC (accepted answer)**\\n```\\nclass Solution {\\n    func primeSubOperation(_ nums: [Int]) -> Bool {\\n        var nums = nums\\n\\n        func findLargestPrime(_ x: Int, _ y: Int) -> Int? {\\n            (x-y+1..<x).first{n in n>1 && (2..<n).first{ n % $0 == 0 } == nil}\\n        }\\n\\n        for i in nums.indices.dropLast().reversed() where nums[i] >= nums[i+1] {\\n            guard let largestPrime = findLargestPrime(nums[i], nums[i+1]) else { return false }\\n            nums[i] -= largestPrime\\n        }\\n        \\n        return nums[0] > 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func primeSubOperation(_ nums: [Int]) -> Bool {\\n        var nums = nums\\n\\n        func findLargestPrime(_ x: Int, _ y: Int) -> Int? {\\n            (x-y+1..<x).first{n in n>1 && (2..<n).first{ n % $0 == 0 } == nil}\\n        }\\n\\n        for i in nums.indices.dropLast().reversed() where nums[i] >= nums[i+1] {\\n            guard let largestPrime = findLargestPrime(nums[i], nums[i+1]) else { return false }\\n            nums[i] -= largestPrime\\n        }\\n        \\n        return nums[0] > 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394101,
                "title": "binary-search-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int binar(int a,int ch,vector<int>& nums){\\n        int i=0;\\n        int j=v.size()-1;\\n        int id=-1;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(v[mid]<a){\\n                if(ch==0){\\n                    id=mid;\\n                    i=mid+1;\\n                }else{\\n                    int diff=a-v[mid];\\n                    if(diff>nums[ch-1]){\\n                        id=mid;\\n                        i=mid+1;\\n                    }else j=mid-1;\\n                }\\n            }else j=mid-1;\\n        }\\n        return id;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=2;i<=1000;i++){\\n            bool flag=1;\\n            for(int j=2;j<=sqrt(i);j++){\\n                if(i%j==0){\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag)v.push_back(i);\\n        }\\n        int n=v.size();\\n        int f=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(i!=0&&nums[i]<=nums[i-1]){\\n                f=0;\\n                break;\\n            }\\n            int id=binar(nums[i],i,nums);\\n            if(id!=-1){\\n                nums[i]=nums[i]-v[id];\\n            }\\n            // cout<<nums[i]<<\\' \\';\\n        }\\n        if(f)return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int binar(int a,int ch,vector<int>& nums){\\n        int i=0;\\n        int j=v.size()-1;\\n        int id=-1;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(v[mid]<a){\\n                if(ch==0){\\n                    id=mid;\\n                    i=mid+1;\\n                }else{\\n                    int diff=a-v[mid];\\n                    if(diff>nums[ch-1]){\\n                        id=mid;\\n                        i=mid+1;\\n                    }else j=mid-1;\\n                }\\n            }else j=mid-1;\\n        }\\n        return id;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=2;i<=1000;i++){\\n            bool flag=1;\\n            for(int j=2;j<=sqrt(i);j++){\\n                if(i%j==0){\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag)v.push_back(i);\\n        }\\n        int n=v.size();\\n        int f=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(i!=0&&nums[i]<=nums[i-1]){\\n                f=0;\\n                break;\\n            }\\n            int id=binar(nums[i],i,nums);\\n            if(id!=-1){\\n                nums[i]=nums[i]-v[id];\\n            }\\n            // cout<<nums[i]<<\\' \\';\\n        }\\n        if(f)return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3390557,
                "title": "please-resolve-a-doubt",
                "content": "can anyone tell Why its ouput will be true ?\\n\\n[8,19,3,4,9]",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3386901,
                "title": "c-easy-solution-faster-than-80",
                "content": "# Intuition\\nStarting from index 0 minimise each number as much as possible such that it is greater than the previous number.\\n\\n# Code\\n```\\nclass Solution {\\n    bool isPrime(int n){\\n        for(int i=2;i<n;i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        int prev = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int diff = nums[i]-prev-1;\\n            for(int j=diff;j>1;j--){\\n                if(isPrime(j)){\\n                    nums[i] = nums[i]-j;\\n                    break;\\n                }\\n            }\\n            if(nums[i]<=prev) return false;\\n            else{\\n                prev = nums[i];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    bool isPrime(int n){\\n        for(int i=2;i<n;i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        int prev = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int diff = nums[i]-prev-1;\\n            for(int j=diff;j>1;j--){\\n                if(isPrime(j)){\\n                    nums[i] = nums[i]-j;\\n                    break;\\n                }\\n            }\\n            if(nums[i]<=prev) return false;\\n            else{\\n                prev = nums[i];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385351,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import sqrt\\nclass Solution(object):\\n    def primeSubOperation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        for i,item in enumerate(nums):\\n            \\n            for j in range(item-1,-1,-1):\\n                #print(nums)\\n                if self.isPrime(j):\\n                    if i!=0 and nums[i-1]<nums[i]-j:\\n                        nums[i]=nums[i]-j\\n                        break\\n                    elif i==0:\\n                        nums[i]=nums[i]-j\\n                        break\\n            p=sorted(nums)\\n            ls=set(nums)\\n            if len(ls)==len(nums) and nums==p:\\n                return True\\n            \\n            \\n        \\n        return False\\n\\n            \\n\\n\\n        \\n        \\n    def isPrime(self,n):\\n \\n        # Corner case\\n        if (n <= 1):\\n            return False\\n    \\n        # Check from 2 to sqrt(n)\\n        for i in range(2, int(sqrt(n))+1):\\n            if (n % i == 0):\\n                return False\\n    \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import sqrt\\nclass Solution(object):\\n    def primeSubOperation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        for i,item in enumerate(nums):\\n            \\n            for j in range(item-1,-1,-1):\\n                #print(nums)\\n                if self.isPrime(j):\\n                    if i!=0 and nums[i-1]<nums[i]-j:\\n                        nums[i]=nums[i]-j\\n                        break\\n                    elif i==0:\\n                        nums[i]=nums[i]-j\\n                        break\\n            p=sorted(nums)\\n            ls=set(nums)\\n            if len(ls)==len(nums) and nums==p:\\n                return True\\n            \\n            \\n        \\n        return False\\n\\n            \\n\\n\\n        \\n        \\n    def isPrime(self,n):\\n \\n        # Corner case\\n        if (n <= 1):\\n            return False\\n    \\n        # Check from 2 to sqrt(n)\\n        for i in range(2, int(sqrt(n))+1):\\n            if (n % i == 0):\\n                return False\\n    \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381074,
                "title": "c-greedy-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.  First, construct a list of all prime numbers within the constraint 1 <= n <= 1000.\\n\\n2.  Use a set data structure to store the prime numbers, as sets have an inherent increasing order that allows for efficient binary searches later.\\n\\n3.  Iterate through the array from the beginning.\\n\\n4.  For each iteration, aim to make the current number as small as possible.\\n\\n5.  Find a prime number X in the set that is smaller than the absolute difference between nums[i] and nums[i-1]. This can be calculated as X < abs(nums[i] - nums[i-1]).\\n\\n6.  Update nums[i] by subtracting X from it, i.e., nums[i] = nums[i] - X.\\nRepeat steps 4-6 for each element in the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy + Binary Search\\n# Complexity\\n- Time complexity: O(n^2) + O(nlogn) = O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        set<int> prime;\\n        prime.insert(2);\\n        for(int i=3; i<=1000; i++){\\n            bool flag = true;\\n            for(int j=2; j*j<=i; j++){\\n                if(i%j==0){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                prime.insert(i);\\n            }\\n        }\\n\\n        int n = nums.size();\\n\\n        auto iter = prime.lower_bound(nums[0]);\\n        if(iter!=prime.begin()){\\n            nums[0]-=*prev(iter);\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            // nums[i] - X > nums[i-1]\\n            // X < nums[i] - nums[i-1]\\n            if(nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n            int X = nums[i] - nums[i-1];\\n            auto iter = prime.lower_bound(X);\\n            if(iter!=prime.begin()){\\n                X = *prev(iter);\\n                nums[i]-=X;\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        set<int> prime;\\n        prime.insert(2);\\n        for(int i=3; i<=1000; i++){\\n            bool flag = true;\\n            for(int j=2; j*j<=i; j++){\\n                if(i%j==0){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                prime.insert(i);\\n            }\\n        }\\n\\n        int n = nums.size();\\n\\n        auto iter = prime.lower_bound(nums[0]);\\n        if(iter!=prime.begin()){\\n            nums[0]-=*prev(iter);\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            // nums[i] - X > nums[i-1]\\n            // X < nums[i] - nums[i-1]\\n            if(nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n            int X = nums[i] - nums[i-1];\\n            auto iter = prime.lower_bound(X);\\n            if(iter!=prime.begin()){\\n                X = *prev(iter);\\n                nums[i]-=X;\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379394,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean primeSubOperation(int[] nums) {\\n    int table[] = new int[1000];\\n    ArrayList<Integer> primes = new ArrayList<>();\\n\\n    for(int i = 2; i < 1000; ++i)\\n      if(table[i] == 0){\\n        primes.add(i);\\n        for(int k = i + i; k < 1000; k += i) table[k] = 1;\\n      }      \\n  \\n    for(int r = nums.length - 2; r >= 0; --r)\\n      if(nums[r] >= nums[r+1]){\\n        if(nums[r] < 3) return false;\\n\\n        int a = 0, b = primes.size() - 1, t = nums[r] - nums[r+1];\\n        while(a <= b){\\n          int m = (a+b)>>1;\\n          if(primes.get(m) <= t) a = m + 1;\\n          else                   b = m - 1;\\n        }\\n\\n        if(a == primes.size()) return false;\\n        nums[r] -= primes.get(a);\\n        if(nums[r] <= 0) return false;\\n      }\\n    \\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean primeSubOperation(int[] nums) {\\n    int table[] = new int[1000];\\n    ArrayList<Integer> primes = new ArrayList<>();\\n\\n    for(int i = 2; i < 1000; ++i)\\n      if(table[i] == 0){\\n        primes.add(i);\\n        for(int k = i + i; k < 1000; k += i) table[k] = 1;\\n      }      \\n  \\n    for(int r = nums.length - 2; r >= 0; --r)\\n      if(nums[r] >= nums[r+1]){\\n        if(nums[r] < 3) return false;\\n\\n        int a = 0, b = primes.size() - 1, t = nums[r] - nums[r+1];\\n        while(a <= b){\\n          int m = (a+b)>>1;\\n          if(primes.get(m) <= t) a = m + 1;\\n          else                   b = m - 1;\\n        }\\n\\n        if(a == primes.size()) return false;\\n        nums[r] -= primes.get(a);\\n        if(nums[r] <= 0) return false;\\n      }\\n    \\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379144,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool change(int k, vector<int>& nums){\\n        vector<int> vec(nums[k],1);\\n        vec[0]=0;\\n        vec[1]=0;\\n\\n        for(int i=0;i<nums[k];i++){\\n            if(vec[i]==1){\\n                int j=2;\\n                while(i*j<nums[k]){\\n                    vec[i*j]=0;\\n                    j++;\\n                }\\n            }\\n        }\\n        int i=0;\\n        while(i<nums[k]){\\n            if(vec[i]==1){\\n                if(nums[k]-i<nums[k+1]){\\n                    nums[k]=nums[k]-i;\\n                    if(nums[k]<0){\\n                        return false;\\n                    }\\n                    return true;\\n                }\\n            }\\n            i++;\\n        }\\n        if(i==nums[k]){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]<=nums[i-1]){\\n                if(nums[i-1]==0 || nums[i-1]==1){\\n                    return false;\\n                }else{\\n                    if(!change(i-1,nums)){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool change(int k, vector<int>& nums){\\n        vector<int> vec(nums[k],1);\\n        vec[0]=0;\\n        vec[1]=0;\\n\\n        for(int i=0;i<nums[k];i++){\\n            if(vec[i]==1){\\n                int j=2;\\n                while(i*j<nums[k]){\\n                    vec[i*j]=0;\\n                    j++;\\n                }\\n            }\\n        }\\n        int i=0;\\n        while(i<nums[k]){\\n            if(vec[i]==1){\\n                if(nums[k]-i<nums[k+1]){\\n                    nums[k]=nums[k]-i;\\n                    if(nums[k]<0){\\n                        return false;\\n                    }\\n                    return true;\\n                }\\n            }\\n            i++;\\n        }\\n        if(i==nums[k]){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]<=nums[i-1]){\\n                if(nums[i-1]==0 || nums[i-1]==1){\\n                    return false;\\n                }else{\\n                    if(!change(i-1,nums)){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372643,
                "title": "simple-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static boolean[] primes;\\n    public boolean primeSubOperation(int[] nums) {\\n        \\n         primes=new boolean[1001];\\n        Arrays.fill(primes,true);\\n        primes[0]=false;\\n        primes[1]=false;\\n        //sieveOfEratosthene\\n        for(int i=2;i*i<=1000;i++){\\n            for(int j=i*2;j<=1000;j+=i){\\n                primes[j]=false;\\n            }\\n        }\\n        //for every iteration i have to check whether nums is strictly increasing or not\\n        for(int i=0;i<nums.length;i++){\\n            if(strictlyIncreasing(nums)){\\n                return true;\\n            }\\n            int x=0;\\n            if(i==0){\\n                int temp=nums[i]-1;\\n                while(temp>0 && !primes[temp]){\\n                    temp--;\\n                }\\n                x=temp;\\n            }\\n            else{\\n                x=findlessPrime(nums[i],nums[i-1]);\\n            }\\n            nums[i]=nums[i]-x;\\n        }\\n        return false;\\n    }\\n    //find less prime number\\n    public static int findlessPrime(int num,int prev){\\n        int x=num;\\n        num--;\\n        while(num>0 && (x-num<=prev || !primes[num])){\\n            num--;\\n        }\\n        return num;\\n    }\\n    //check for strictly increasing\\n    public static boolean strictlyIncreasing(int[] arr){\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i-1]>=arr[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static boolean[] primes;\\n    public boolean primeSubOperation(int[] nums) {\\n        \\n         primes=new boolean[1001];\\n        Arrays.fill(primes,true);\\n        primes[0]=false;\\n        primes[1]=false;\\n        //sieveOfEratosthene\\n        for(int i=2;i*i<=1000;i++){\\n            for(int j=i*2;j<=1000;j+=i){\\n                primes[j]=false;\\n            }\\n        }\\n        //for every iteration i have to check whether nums is strictly increasing or not\\n        for(int i=0;i<nums.length;i++){\\n            if(strictlyIncreasing(nums)){\\n                return true;\\n            }\\n            int x=0;\\n            if(i==0){\\n                int temp=nums[i]-1;\\n                while(temp>0 && !primes[temp]){\\n                    temp--;\\n                }\\n                x=temp;\\n            }\\n            else{\\n                x=findlessPrime(nums[i],nums[i-1]);\\n            }\\n            nums[i]=nums[i]-x;\\n        }\\n        return false;\\n    }\\n    //find less prime number\\n    public static int findlessPrime(int num,int prev){\\n        int x=num;\\n        num--;\\n        while(num>0 && (x-num<=prev || !primes[num])){\\n            num--;\\n        }\\n        return num;\\n    }\\n    //check for strictly increasing\\n    public static boolean strictlyIncreasing(int[] arr){\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i-1]>=arr[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365576,
                "title": "c-solution-using-sieve-of-eratosthenes-and-binary-search",
                "content": "```\\n// Given an integer n, this function returns a vector containing all the prime numbers less than n\\nvector<int> getPrimeNumbers(int n) {\\n    vector<bool> isPrime(n, true); // Create a boolean vector to keep track of whether each number is prime or not\\n    // Starting from 2, iterate up to the square root of n, marking all multiples of each prime number as not prime\\n    for (int i = 2; i * i < n; i++) {\\n        if (isPrime[i]) {\\n            for (int j = i * i; j < n; j += i) {\\n                isPrime[j] = false;\\n            }\\n        }\\n    }\\n    vector<int> primeNumbers; // Create a vector to store all the prime numbers found\\n    // Starting from 2, iterate up to n, adding each prime number to the vector\\n    for (int i = 2; i < n; i++) {\\n        if (isPrime[i]) {\\n            primeNumbers.push_back(i);\\n        }\\n    }\\n    return primeNumbers;\\n}\\n\\n// This function performs a binary search on the given vector to find the index of the largest number less than the target\\n// If the target is less than the smallest element in the vector or if the vector is empty, -1 is returned\\nint binarySearch(vector<int>& primeNumbers, int target) {\\n    int lo = 0, hi = primeNumbers.size() - 1;\\n    // Continue iterating until the lower and upper bounds meet\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo + 1) / 2; // Calculate the midpoint of the current range\\n        // If the middle element is greater than or equal to the target, eliminate the upper half of the range\\n        if (primeNumbers[mid] >= target) {\\n            hi = mid - 1;\\n        }\\n        // Otherwise, eliminate the lower half of the range\\n        else {\\n            lo = mid;\\n        }\\n    }\\n    // If the vector is empty or the largest element less than the target is the smallest element in the vector, return -1\\n    if (primeNumbers.size() == 0 or primeNumbers[lo] >= target) {\\n        return -1;\\n    }\\n    // Otherwise, return the index of the largest element less than the target\\n    return lo;\\n}\\n\\n// This function performs the prime suboperation on the given vector\\n// It returns true if the operation can be performed and false otherwise\\nbool primeSubOperation(vector<int>& nums) {\\n    int maxElement = *max_element(nums.begin(), nums.end()); // Find the largest element in the vector\\n    vector<int> primeNumbers = getPrimeNumbers(maxElement); // Get all prime numbers less than or equal to the largest element\\n    nums.insert(nums.begin(), 0); // Insert a 0 at the beginning of the vector to simplify the algorithm\\n    // Iterate over the vector, checking that each element is strictly greater than the previous element and performing the prime suboperation\\n    for (int i = 1; i < nums.size(); i++) {\\n        if (i != 1 and nums[i - 1] >= nums[i]) { // If the current element is not greater than the previous element, return false\\n            return false;\\n        }\\n        int idx = binarySearch(primeNumbers, nums[i] - nums[i - 1]); // Find the largest prime number less than the difference between the current element and the previous element\\n        if (idx != -1) { // If such a prime number exists, subtract it from the current element\\n            nums[i] -= primeNumbers[idx];\\n        }\\n    }\\n    return\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\n// Given an integer n, this function returns a vector containing all the prime numbers less than n\\nvector<int> getPrimeNumbers(int n) {\\n    vector<bool> isPrime(n, true); // Create a boolean vector to keep track of whether each number is prime or not\\n    // Starting from 2, iterate up to the square root of n, marking all multiples of each prime number as not prime\\n    for (int i = 2; i * i < n; i++) {\\n        if (isPrime[i]) {\\n            for (int j = i * i; j < n; j += i) {\\n                isPrime[j] = false;\\n            }\\n        }\\n    }\\n    vector<int> primeNumbers; // Create a vector to store all the prime numbers found\\n    // Starting from 2, iterate up to n, adding each prime number to the vector\\n    for (int i = 2; i < n; i++) {\\n        if (isPrime[i]) {\\n            primeNumbers.push_back(i);\\n        }\\n    }\\n    return primeNumbers;\\n}\\n\\n// This function performs a binary search on the given vector to find the index of the largest number less than the target\\n// If the target is less than the smallest element in the vector or if the vector is empty, -1 is returned\\nint binarySearch(vector<int>& primeNumbers, int target) {\\n    int lo = 0, hi = primeNumbers.size() - 1;\\n    // Continue iterating until the lower and upper bounds meet\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo + 1) / 2; // Calculate the midpoint of the current range\\n        // If the middle element is greater than or equal to the target, eliminate the upper half of the range\\n        if (primeNumbers[mid] >= target) {\\n            hi = mid - 1;\\n        }\\n        // Otherwise, eliminate the lower half of the range\\n        else {\\n            lo = mid;\\n        }\\n    }\\n    // If the vector is empty or the largest element less than the target is the smallest element in the vector, return -1\\n    if (primeNumbers.size() == 0 or primeNumbers[lo] >= target) {\\n        return -1;\\n    }\\n    // Otherwise, return the index of the largest element less than the target\\n    return lo;\\n}\\n\\n// This function performs the prime suboperation on the given vector\\n// It returns true if the operation can be performed and false otherwise\\nbool primeSubOperation(vector<int>& nums) {\\n    int maxElement = *max_element(nums.begin(), nums.end()); // Find the largest element in the vector\\n    vector<int> primeNumbers = getPrimeNumbers(maxElement); // Get all prime numbers less than or equal to the largest element\\n    nums.insert(nums.begin(), 0); // Insert a 0 at the beginning of the vector to simplify the algorithm\\n    // Iterate over the vector, checking that each element is strictly greater than the previous element and performing the prime suboperation\\n    for (int i = 1; i < nums.size(); i++) {\\n        if (i != 1 and nums[i - 1] >= nums[i]) { // If the current element is not greater than the previous element, return false\\n            return false;\\n        }\\n        int idx = binarySearch(primeNumbers, nums[i] - nums[i - 1]); // Find the largest prime number less than the difference between the current element and the previous element\\n        if (idx != -1) { // If such a prime number exists, subtract it from the current element\\n            nums[i] -= primeNumbers[idx];\\n        }\\n    }\\n    return\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3365227,
                "title": "using-sieve-of-eratosthenes-easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) The idea is to subtract every number in the given array with the first prime number which is less than the current element and whose difference is greater than the previous element in the array. (This is done to minimize the current element).\\n2) If such an operation is possible, we update the current element with the difference and move forward.\\n 3) If not, we check whether the current element is already greater than the previous element (we can continue forward without making any operation).\\n4) Else we return false;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) The sieve function is used to fill the seive table where every \\na[i] returns 1 if i is prime else returns 0;\\n2) At every index in the given array, we check is the above mentioned operation is possible. If yes, update the current element, previous element with the diff and continue.\\n3) If not, check if the current element is already greater, then we can continue without performing any operation. (Do not forget to update the last with current element as the elements on the right should be greater than this current element).\\n4) Else return false.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n = 1001;\\n    int a[1001]={-1};\\n\\n    void sieve(){\\n        a[1] =  0;\\n        for(int i=2;i<n;i++){\\n            if(a[i]==-1){\\n                a[i]=1;\\n                for(int j=i*2;j<n;j+=i){\\n                    a[j]=0;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=0;i<n;i++)a[i]=-1;\\n        sieve();\\n        int last=-1;\\n        bool ans = true,temp = false;\\n        for(int i=0;i<nums.size();i++){\\n            temp = false;\\n            int cur = nums[i];\\n            int t = nums[i];\\n            while(t-->1){\\n                if(a[t]==1 and cur-t > last){\\n                    last = cur-t;\\n                    nums[i] = cur-t;\\n                    temp = true;\\n                    break;\\n                }\\n            }\\n\\n            if(!temp and i-1 >=0 and nums[i]<=nums[i-1]){\\n                ans = false;\\n                break;\\n            }\\n            if(!temp and i-1>=0 and nums[i]>nums[i-1]){\\n                last = nums[i];\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++) cout<<nums[i]<<\\' \\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n = 1001;\\n    int a[1001]={-1};\\n\\n    void sieve(){\\n        a[1] =  0;\\n        for(int i=2;i<n;i++){\\n            if(a[i]==-1){\\n                a[i]=1;\\n                for(int j=i*2;j<n;j+=i){\\n                    a[j]=0;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=0;i<n;i++)a[i]=-1;\\n        sieve();\\n        int last=-1;\\n        bool ans = true,temp = false;\\n        for(int i=0;i<nums.size();i++){\\n            temp = false;\\n            int cur = nums[i];\\n            int t = nums[i];\\n            while(t-->1){\\n                if(a[t]==1 and cur-t > last){\\n                    last = cur-t;\\n                    nums[i] = cur-t;\\n                    temp = true;\\n                    break;\\n                }\\n            }\\n\\n            if(!temp and i-1 >=0 and nums[i]<=nums[i-1]){\\n                ans = false;\\n                break;\\n            }\\n            if(!temp and i-1>=0 and nums[i]>nums[i-1]){\\n                last = nums[i];\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++) cout<<nums[i]<<\\' \\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3364394,
                "title": "python-greedy-binary-search-o-n-log-n",
                "content": "1. Use sieve of Eratosthenes to find all prime numbers.\\n2. While keeping `nums` strictly increasing, we should subtract every prime as large as possible.\\n![image](https://assets.leetcode.com/users/images/c89b05c9-cf87-41a7-9a4d-51a435e1c092_1680325355.8262389.png)\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        # find primes within the range\\n        comp = [1, 1] + [0]*999\\n        for i in range(2, int(math.sqrt(1000)+1)):\\n            j = 2*i\\n            while j <= 1000:\\n                comp[j] = 1\\n                j += i\\n        primes = [i for i, a in enumerate(comp) if a == 0]\\n        \\n        # check True or False\\n        nums = [0] + nums\\n        for i, n in enumerate(nums[1:], start=1):\\n            if n <= nums[i-1]:\\n                return False\\n            idx = bisect_left(primes, n - nums[i-1])\\n            p = primes[idx-1] if idx > 0 else 0\\n            nums[i] -= p\\n        return True",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Use sieve of Eratosthenes to find all prime numbers.\\n2. While keeping `nums` strictly increasing, we should subtract every prime as large as possible.\\n![image](https://assets.leetcode.com/users/images/c89b05c9-cf87-41a7-9a4d-51a435e1c092_1680325355.8262389.png)\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        # find primes within the range\\n        comp = [1, 1] + [0]*999\\n        for i in range(2, int(math.sqrt(1000)+1)):\\n            j = 2*i\\n            while j <= 1000:\\n                comp[j] = 1\\n                j += i\\n        primes = [i for i, a in enumerate(comp) if a == 0]\\n        \\n        # check True or False\\n        nums = [0] + nums\\n        for i, n in enumerate(nums[1:], start=1):\\n            if n <= nums[i-1]:\\n                return False\\n            idx = bisect_left(primes, n - nums[i-1])\\n            p = primes[idx-1] if idx > 0 else 0\\n            nums[i] -= p\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3363550,
                "title": "ugly-ruby-one-liner-beats-100-100",
                "content": "```\\nrequire \\'prime\\'\\n\\n# @param {Integer[]} nums\\n# @return {Boolean}\\ndef prime_sub_operation(nums)\\n  t = 0; nums.all? { |x| t += 1; t += 1 while t < x && !(x - t).prime?; t <= x }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nrequire \\'prime\\'\\n\\n# @param {Integer[]} nums\\n# @return {Boolean}\\ndef prime_sub_operation(nums)\\n  t = 0; nums.all? { |x| t += 1; t += 1 while t < x && !(x - t).prime?; t <= x }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3363331,
                "title": "solved",
                "content": "# Intuition\\nReduce each element of the list, starting from 0th index, by subtracting the closest prime number smaller than it. This would give you the smallest value till where the value in this index can be brought down to. Now just ensure that value obtained by this subtraction is greater than the value present in the previous index. If not, find the next closest prime number to the prime number which you used to subtract.  \\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def is_prime(self, num) -> int:\\n        t = int(sqrt(num))\\n        factor_found = 0\\n        if t <= 2:\\n            t = 3\\n        for i in range(2, t + 1):\\n            if (num % i == 0):\\n                return 0\\n        return 1\\n        \\n    def find_nearst_prime(self, num) -> int:\\n        if num <=2:\\n            return 0\\n        t = num - 1\\n        while (t>2):\\n            prime = self.is_prime(t)\\n            if prime == 1:\\n                return t\\n            else:\\n                t = t - 1\\n        return 2\\n\\n    def if_strictly_increasing(self, ref_nums: List[int]) -> int:\\n        counter = 0\\n        while (counter<(len(ref_nums) - 1)):\\n            if ref_nums[counter] >= ref_nums[counter + 1]:\\n                return 0\\n            counter = counter + 1\\n        return 1\\n            \\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        solved = 0\\n        for pointer in range(0,len(nums)):\\n            solved = self.if_strictly_increasing(nums)\\n            if solved:\\n                return True\\n            if pointer == 0:\\n                nearest_prime = self.find_nearst_prime(nums[pointer])\\n            else:\\n                nearest_prime = self.find_nearst_prime(nums[pointer])\\n                while(nums[pointer] - nearest_prime <= nums[pointer - 1] and nearest_prime!=0):\\n                    if nearest_prime == 2:\\n                        if nums[pointer] - nearest_prime > nums[pointer - 1]:\\n                            break\\n                        else:\\n                            nearest_prime = 0\\n                            break\\n                    nearest_prime = self.find_nearst_prime(nearest_prime)\\n                \\n            nums[pointer] = nums[pointer] - nearest_prime\\n           # print (nums)\\n        if solved == 0:\\n            return False\\n        else:\\n            return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def is_prime(self, num) -> int:\\n        t = int(sqrt(num))\\n        factor_found = 0\\n        if t <= 2:\\n            t = 3\\n        for i in range(2, t + 1):\\n            if (num % i == 0):\\n                return 0\\n        return 1\\n        \\n    def find_nearst_prime(self, num) -> int:\\n        if num <=2:\\n            return 0\\n        t = num - 1\\n        while (t>2):\\n            prime = self.is_prime(t)\\n            if prime == 1:\\n                return t\\n            else:\\n                t = t - 1\\n        return 2\\n\\n    def if_strictly_increasing(self, ref_nums: List[int]) -> int:\\n        counter = 0\\n        while (counter<(len(ref_nums) - 1)):\\n            if ref_nums[counter] >= ref_nums[counter + 1]:\\n                return 0\\n            counter = counter + 1\\n        return 1\\n            \\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        solved = 0\\n        for pointer in range(0,len(nums)):\\n            solved = self.if_strictly_increasing(nums)\\n            if solved:\\n                return True\\n            if pointer == 0:\\n                nearest_prime = self.find_nearst_prime(nums[pointer])\\n            else:\\n                nearest_prime = self.find_nearst_prime(nums[pointer])\\n                while(nums[pointer] - nearest_prime <= nums[pointer - 1] and nearest_prime!=0):\\n                    if nearest_prime == 2:\\n                        if nums[pointer] - nearest_prime > nums[pointer - 1]:\\n                            break\\n                        else:\\n                            nearest_prime = 0\\n                            break\\n                    nearest_prime = self.find_nearst_prime(nearest_prime)\\n                \\n            nums[pointer] = nums[pointer] - nearest_prime\\n           # print (nums)\\n        if solved == 0:\\n            return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361655,
                "title": "dart-brute-force-greedy",
                "content": "# Intuition\\n- As length range is 1000, we created isPrimes bool list to check isPrimes.\\n- For picking prime is pick for cur - 1 is the most possible start.\\n-  So start from nums[i] - 1, and check if isPrime and cur - j > previousNum. If true, subtract the current with j.\\n- \\'j is the prime number\\'.\\n- If current is <= previous, it can not sorted anymore. Thus, return false.\\n\\n# Complexity\\n- Time complexity:\\nO(N*1000)\\n\\n- Space complexity:\\nO(1001)\\n\\n# Code\\n```\\nclass Solution {\\n  bool primeSubOperation(List<int> nums) {\\n    int n = nums.length;\\n    List<bool> isPrimes = List.filled(1001, false);\\n    for (var i = 2; i < 1001; i++) {\\n      isPrimes[i] = isPrime(i);\\n    }\\n\\n    for (var pre = 0, i = 0; i < n; i++) {\\n      int cur = nums[i];\\n      for (var j = nums[i] - 1; j >= 2; j--) {\\n        if (isPrimes[j] && cur - j > pre) {\\n          cur -= j;\\n          break;\\n        }\\n      }\\n      if (cur <= pre) return false;\\n      pre = cur;\\n    }\\n\\n    return true;\\n  }\\n}\\n\\nbool isPrime(int n) {\\n  if (n <= 1) {\\n    return false;\\n  }\\n  if (n == 2 || n == 3) {\\n    return true;\\n  }\\n  if (n % 2 == 0 || n % 3 == 0) {\\n    return false;\\n  }\\n  int i = 5;\\n  int w = 2;\\n  while (i * i <= n) {\\n    if (n % i == 0) {\\n      return false;\\n    }\\n    i += w;\\n    w = 6 - w; // alternate adding 2 and 4\\n  }\\n  return true;\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool primeSubOperation(List<int> nums) {\\n    int n = nums.length;\\n    List<bool> isPrimes = List.filled(1001, false);\\n    for (var i = 2; i < 1001; i++) {\\n      isPrimes[i] = isPrime(i);\\n    }\\n\\n    for (var pre = 0, i = 0; i < n; i++) {\\n      int cur = nums[i];\\n      for (var j = nums[i] - 1; j >= 2; j--) {\\n        if (isPrimes[j] && cur - j > pre) {\\n          cur -= j;\\n          break;\\n        }\\n      }\\n      if (cur <= pre) return false;\\n      pre = cur;\\n    }\\n\\n    return true;\\n  }\\n}\\n\\nbool isPrime(int n) {\\n  if (n <= 1) {\\n    return false;\\n  }\\n  if (n == 2 || n == 3) {\\n    return true;\\n  }\\n  if (n % 2 == 0 || n % 3 == 0) {\\n    return false;\\n  }\\n  int i = 5;\\n  int w = 2;\\n  while (i * i <= n) {\\n    if (n % i == 0) {\\n      return false;\\n    }\\n    i += w;\\n    w = 6 - w; // alternate adding 2 and 4\\n  }\\n  return true;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361576,
                "title": "simple-java-solution-greedy",
                "content": "# Intuition\\nTry reducing prime numbers lesser than the current index nums[i] until it is just lesser than the nums[i+1] so that it meets the condition nums[i]<nums[i+1]\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean prime(int n)\\n    {\\n        for(int i=2;i<=n/2;i++)  if(n%i==0)  return false;\\n        return true;\\n    }\\n    public int fun(int target,int curr)\\n    {\\n        for(int i=2;i<curr;i++)\\n        {\\n            if(prime(i))\\n            {\\n               if(curr-i<target)  return curr-i; \\n            }\\n        }\\n        return -1;\\n    }\\n    public boolean primeSubOperation(int[] nums) \\n    {\\n        for(int i=nums.length-1;i>0;i--)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                nums[i-1]=fun(nums[i],nums[i-1]);\\n                if(nums[i]==-1)  return false;\\n            }\\n        }\\n        if(nums[0]==-1)  return false;\\n        System.out.println(Arrays.toString(nums));\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean prime(int n)\\n    {\\n        for(int i=2;i<=n/2;i++)  if(n%i==0)  return false;\\n        return true;\\n    }\\n    public int fun(int target,int curr)\\n    {\\n        for(int i=2;i<curr;i++)\\n        {\\n            if(prime(i))\\n            {\\n               if(curr-i<target)  return curr-i; \\n            }\\n        }\\n        return -1;\\n    }\\n    public boolean primeSubOperation(int[] nums) \\n    {\\n        for(int i=nums.length-1;i>0;i--)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                nums[i-1]=fun(nums[i],nums[i-1]);\\n                if(nums[i]==-1)  return false;\\n            }\\n        }\\n        if(nums[0]==-1)  return false;\\n        System.out.println(Arrays.toString(nums));\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361447,
                "title": "easy-java-solution-using-sieve-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)*168+O(nlog(log(n)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        boolean[] notprime=new boolean[1001];\\n        notprime[0]=true;\\n        notprime[1]=true;\\n        //this list store all possible prime number\\n        List<Integer> prinum=new ArrayList<>();\\n        isPrime(notprime,prinum);\\n        int index=0;\\n        /*we will traverse through the nums array and find the largest prime number possible \\nsuch that subtracting it from nums[i] it is still greater than nums[i-1]*/\\n        for(int i=0;i<nums.length;i++){\\n            index=0;\\n                while(index<prinum.size()){\\n                    if(i!=0&&nums[i]-prinum.get(index)>nums[i-1]){\\n                         index++;\\n                    }\\n                    else if(i==0&&nums[i]-prinum.get(index)>0){\\n                        index++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                //here we will subtract the possible biggest prime number from the nums[i]\\n                if(index!=0){\\n                    nums[i]-=prinum.get(index-1);\\n                }\\n           //here we will check\\n            if(i!=0&&nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n        }\\n                \\n        return true;\\n    }\\n    //sieve algorithm is used to mark prime number\\n    public void isPrime(boolean[] notprime,List<Integer> prinum){\\n        for(int i=2;i<=1000;i++){\\n            //if a number is not marked means it is prime number\\n            if(!notprime[i]){\\n                //we will add it to our prime number list\\n                prinum.add(i);\\n                //then we will mark  all multiple of that number as not prime number\\n                for(int j=2*i;j<1001;j+=i){\\n                    notprime[j]=true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        boolean[] notprime=new boolean[1001];\\n        notprime[0]=true;\\n        notprime[1]=true;\\n        //this list store all possible prime number\\n        List<Integer> prinum=new ArrayList<>();\\n        isPrime(notprime,prinum);\\n        int index=0;\\n        /*we will traverse through the nums array and find the largest prime number possible \\nsuch that subtracting it from nums[i] it is still greater than nums[i-1]*/\\n        for(int i=0;i<nums.length;i++){\\n            index=0;\\n                while(index<prinum.size()){\\n                    if(i!=0&&nums[i]-prinum.get(index)>nums[i-1]){\\n                         index++;\\n                    }\\n                    else if(i==0&&nums[i]-prinum.get(index)>0){\\n                        index++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                //here we will subtract the possible biggest prime number from the nums[i]\\n                if(index!=0){\\n                    nums[i]-=prinum.get(index-1);\\n                }\\n           //here we will check\\n            if(i!=0&&nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n        }\\n                \\n        return true;\\n    }\\n    //sieve algorithm is used to mark prime number\\n    public void isPrime(boolean[] notprime,List<Integer> prinum){\\n        for(int i=2;i<=1000;i++){\\n            //if a number is not marked means it is prime number\\n            if(!notprime[i]){\\n                //we will add it to our prime number list\\n                prinum.add(i);\\n                //then we will mark  all multiple of that number as not prime number\\n                for(int j=2*i;j<1001;j+=i){\\n                    notprime[j]=true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361119,
                "title": "generate-prime-numbers-by-any-way-then-do-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>arr={\\n0,\\n  2,\\n  3,\\n  5,\\n  7,\\n  11,\\n  13,\\n  17,\\n  19,\\n  23,\\n  29,\\n  31,\\n  37,\\n  41,\\n  43,\\n  47,\\n  53,\\n  59,\\n  61,\\n  67,\\n  71,\\n  73,\\n  79,\\n  83,\\n  89,\\n  97,\\n  101,\\n  103,\\n  107,\\n  109,\\n  113,\\n  127,\\n  131,\\n  137,\\n  139,\\n  149,\\n  151,\\n  157,\\n  163,\\n  167,\\n  173,\\n  179,\\n  181,\\n  191,\\n  193,\\n  197,\\n  199,\\n  211,\\n  223,\\n  227,\\n  229,\\n  233,\\n  239,\\n  241,\\n  251,\\n  257,\\n  263,\\n  269,\\n  271,\\n  277,\\n  281,\\n  283,\\n  293,\\n  307,\\n  311,\\n  313,\\n  317,\\n  331,\\n  337,\\n  347,\\n  349,\\n  353,\\n  359,\\n  367,\\n  373,\\n  379,\\n  383,\\n  389,\\n  397,\\n  401,\\n  409,\\n  419,\\n  421,\\n  431,\\n  433,\\n  439,\\n  443,\\n  449,\\n  457,\\n  461,\\n  463,\\n  467,\\n  479,\\n  487,\\n  491,\\n  499,\\n  503,\\n  509,\\n  521,\\n  523,\\n  541,\\n  547,\\n  557,\\n  563,\\n  569,\\n  571,\\n  577,\\n  587,\\n  593,\\n  599,\\n  601,\\n  607,\\n  613,\\n  617,\\n  619,\\n  631,\\n  641,\\n  643,\\n  647,\\n  653,\\n  659,\\n  661,\\n  673,\\n  677,\\n  683,\\n  691,\\n  701,\\n  709,\\n  719,\\n  727,\\n  733,\\n  739,\\n  743,\\n  751,\\n  757,\\n  761,\\n  769,\\n  773,\\n  787,\\n  797,\\n  809,\\n  811,\\n  821,\\n  823,\\n  827,\\n  829,\\n  839,\\n  853,\\n  857,\\n  859,\\n  863,\\n  877,\\n  881,\\n  883,\\n  887,\\n  907,\\n  911,\\n  919,\\n  929,\\n  937,\\n  941,\\n  947,\\n  953,\\n  967,\\n  971,\\n  977,983, 991, 997};\\n  bool isvalid(int mid_index,vector<int>&nums ,int i)\\n  {\\n    if( nums[i]-arr[mid_index]>nums[i-1] )\\n    return true;\\n    else\\n    return false;\\n  }\\n    bool primeSubOperation(vector<int>& nums) {\\n      int k=0;\\n     for( k=0;k<arr.size();k++)\\n     {\\n       if(arr[k]>=nums[0])\\n       break;\\n     }\\n     nums[0]=nums[0]-arr[k-1];\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n         \\n   \\n         int low=0;\\n          int high=arr.size()-1;\\n         int ans=-1;\\n          while(low<=high)\\n          {\\n            int mid=(low+high)>>1;\\n            if(arr[mid]>=nums[i])\\n            high=mid-1;\\n\\n           else if(isvalid(mid,nums,i))\\n            {\\n        \\n             ans=mid;\\n             low=mid+1;\\n            }\\n             else\\n             {\\n              high =mid-1;\\n             }\\n          }\\n         \\n          if(ans==-1)\\n          return false;\\n          else\\n           {\\n               nums[i]=nums[i]-arr[ans];\\n           }\\n         \\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int>arr={\\n0,\\n  2,\\n  3,\\n  5,\\n  7,\\n  11,\\n  13,\\n  17,\\n  19,\\n  23,\\n  29,\\n  31,\\n  37,\\n  41,\\n  43,\\n  47,\\n  53,\\n  59,\\n  61,\\n  67,\\n  71,\\n  73,\\n  79,\\n  83,\\n  89,\\n  97,\\n  101,\\n  103,\\n  107,\\n  109,\\n  113,\\n  127,\\n  131,\\n  137,\\n  139,\\n  149,\\n  151,\\n  157,\\n  163,\\n  167,\\n  173,\\n  179,\\n  181,\\n  191,\\n  193,\\n  197,\\n  199,\\n  211,\\n  223,\\n  227,\\n  229,\\n  233,\\n  239,\\n  241,\\n  251,\\n  257,\\n  263,\\n  269,\\n  271,\\n  277,\\n  281,\\n  283,\\n  293,\\n  307,\\n  311,\\n  313,\\n  317,\\n  331,\\n  337,\\n  347,\\n  349,\\n  353,\\n  359,\\n  367,\\n  373,\\n  379,\\n  383,\\n  389,\\n  397,\\n  401,\\n  409,\\n  419,\\n  421,\\n  431,\\n  433,\\n  439,\\n  443,\\n  449,\\n  457,\\n  461,\\n  463,\\n  467,\\n  479,\\n  487,\\n  491,\\n  499,\\n  503,\\n  509,\\n  521,\\n  523,\\n  541,\\n  547,\\n  557,\\n  563,\\n  569,\\n  571,\\n  577,\\n  587,\\n  593,\\n  599,\\n  601,\\n  607,\\n  613,\\n  617,\\n  619,\\n  631,\\n  641,\\n  643,\\n  647,\\n  653,\\n  659,\\n  661,\\n  673,\\n  677,\\n  683,\\n  691,\\n  701,\\n  709,\\n  719,\\n  727,\\n  733,\\n  739,\\n  743,\\n  751,\\n  757,\\n  761,\\n  769,\\n  773,\\n  787,\\n  797,\\n  809,\\n  811,\\n  821,\\n  823,\\n  827,\\n  829,\\n  839,\\n  853,\\n  857,\\n  859,\\n  863,\\n  877,\\n  881,\\n  883,\\n  887,\\n  907,\\n  911,\\n  919,\\n  929,\\n  937,\\n  941,\\n  947,\\n  953,\\n  967,\\n  971,\\n  977,983, 991, 997};\\n  bool isvalid(int mid_index,vector<int>&nums ,int i)\\n  {\\n    if( nums[i]-arr[mid_index]>nums[i-1] )\\n    return true;\\n    else\\n    return false;\\n  }\\n    bool primeSubOperation(vector<int>& nums) {\\n      int k=0;\\n     for( k=0;k<arr.size();k++)\\n     {\\n       if(arr[k]>=nums[0])\\n       break;\\n     }\\n     nums[0]=nums[0]-arr[k-1];\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n         \\n   \\n         int low=0;\\n          int high=arr.size()-1;\\n         int ans=-1;\\n          while(low<=high)\\n          {\\n            int mid=(low+high)>>1;\\n            if(arr[mid]>=nums[i])\\n            high=mid-1;\\n\\n           else if(isvalid(mid,nums,i))\\n            {\\n        \\n             ans=mid;\\n             low=mid+1;\\n            }\\n             else\\n             {\\n              high =mid-1;\\n             }\\n          }\\n         \\n          if(ans==-1)\\n          return false;\\n          else\\n           {\\n               nums[i]=nums[i]-arr[ans];\\n           }\\n         \\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359849,
                "title": "sieve-algorithm-reduce-prime-from-last-faster-than-98-c-o-n-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int flag=0;\\n    bool arr[1001]={false};\\n    void Isprime(bool arr[])  // Sieve Algorithm\\n    {\\n            if(flag!=0) return ;\\n            arr[0]=true,arr[1]=true;\\n            for(int i=2;i<=500;++i)\\n            {\\n                if(i!=2 && (i&1)==0) continue;\\n                for(int j=2*i;j<=1000;j+=i)\\n                {\\n                    arr[j]=true;\\n                }\\n            }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        if(flag==0)\\n        {\\n            Isprime(arr); // create a list of 1000 prime numbers\\n            ++flag;  \\n        }\\n        int n=nums.size();\\n        for(int i=n-1;i>0;--i)\\n        {\\n            if(nums[i-1]<nums[i]) continue; // if already sorted continue.\\n            int idex=nums[i-1]-nums[i]+1; // getting the minimum value for nums[i-1] that can smaller than nums[i].\\n            while(idex<1001 && arr[idex]) idex++; // that value is prime or not .\\n            nums[i-1]-=idex; // substract that prime with nums[i];\\n\\n            if(nums[i-1]<=0 || idex>1000) return false; // in case if nums[i] become negative then return false \\n        }\\n\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flag=0;\\n    bool arr[1001]={false};\\n    void Isprime(bool arr[])  // Sieve Algorithm\\n    {\\n            if(flag!=0) return ;\\n            arr[0]=true,arr[1]=true;\\n            for(int i=2;i<=500;++i)\\n            {\\n                if(i!=2 && (i&1)==0) continue;\\n                for(int j=2*i;j<=1000;j+=i)\\n                {\\n                    arr[j]=true;\\n                }\\n            }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        if(flag==0)\\n        {\\n            Isprime(arr); // create a list of 1000 prime numbers\\n            ++flag;  \\n        }\\n        int n=nums.size();\\n        for(int i=n-1;i>0;--i)\\n        {\\n            if(nums[i-1]<nums[i]) continue; // if already sorted continue.\\n            int idex=nums[i-1]-nums[i]+1; // getting the minimum value for nums[i-1] that can smaller than nums[i].\\n            while(idex<1001 && arr[idex]) idex++; // that value is prime or not .\\n            nums[i-1]-=idex; // substract that prime with nums[i];\\n\\n            if(nums[i-1]<=0 || idex>1000) return false; // in case if nums[i] become negative then return false \\n        }\\n\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359593,
                "title": "simple-sieve-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet all the prime under constraints\\nThen check the not valid point;\\nand then check which  prime number which is less than the element and update the index\\n\\nThen check the array is sorted or not if sorted then return true;\\n \\n# Complexity\\n- Time complexity:O(N*m) here m=no. of prime no. till 1001\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void seive(vector<bool>&arr,int n){\\n         for(int i=2;i<n;i++){\\n             if(arr[i]==false){\\n                 continue;\\n             }\\n             for(int j=i*2;j<n;j+=i){\\n                 arr[j]=false;\\n             }\\n         }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=n;\\n        vector<bool>isPrime(1001,true);\\n        isPrime[0]=false;\\n        isPrime[1]=false;\\n         seive(isPrime,1001);\\n         vector<int>prime;\\n         for(int i=0;i<1001;i++){\\n             if(isPrime[i]){\\n                 prime.push_back(i);\\n             }\\n         }\\n        int prev=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<prev){\\n                prev=nums[i];\\n                continue;\\n            }\\n            bool flag=true;\\n            for(int j=0;j<prime.size();j++){\\n                if(prime[j]>=nums[i]){\\n                    break;\\n                }\\n                if((nums[i]-prime[j])<prev){\\n                    prev=nums[i]-prime[j];\\n                    nums[i]=prev;\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]>=nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void seive(vector<bool>&arr,int n){\\n         for(int i=2;i<n;i++){\\n             if(arr[i]==false){\\n                 continue;\\n             }\\n             for(int j=i*2;j<n;j+=i){\\n                 arr[j]=false;\\n             }\\n         }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=n;\\n        vector<bool>isPrime(1001,true);\\n        isPrime[0]=false;\\n        isPrime[1]=false;\\n         seive(isPrime,1001);\\n         vector<int>prime;\\n         for(int i=0;i<1001;i++){\\n             if(isPrime[i]){\\n                 prime.push_back(i);\\n             }\\n         }\\n        int prev=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<prev){\\n                prev=nums[i];\\n                continue;\\n            }\\n            bool flag=true;\\n            for(int j=0;j<prime.size();j++){\\n                if(prime[j]>=nums[i]){\\n                    break;\\n                }\\n                if((nums[i]-prime[j])<prev){\\n                    prev=nums[i]-prime[j];\\n                    nums[i]=prev;\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]>=nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358259,
                "title": "java-o-n-logk-solution",
                "content": "# Complexity\\n- Time complexity: O(N * logK) - where K is the size of list of primes until 1000. If we take it as a coefficient, then the time complexity is ~ O(N)\\n\\nAnd primes are calculated only once.\\n\\n# Code\\n```\\nclass Solution {\\n    static List<Integer> listPrimes;\\n    public boolean primeSubOperation(int[] nums) {\\n        if (nums.length == 1) return true;\\n        if (listPrimes == null) fillWithPrimes();\\n        int prev = nums[nums.length - 1];\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            int curr = nums[i];\\n            if (curr < prev) {\\n                prev = curr;\\n            } else {\\n                int diff = curr - prev + 1;\\n                int idx = Collections.binarySearch(listPrimes, diff);\\n                if (idx < 0) idx = -idx - 1;\\n                idx = Math.min(idx, listPrimes.size() - 1);\\n                if (listPrimes.get(idx) < diff) idx = Math.min(idx + 1, listPrimes.size() - 1);\\n                int res = curr - listPrimes.get(idx);\\n                if (res <= 0) return false;\\n                if (res >= prev) return false;\\n                else prev = res;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static void fillWithPrimes() {\\n        listPrimes = new ArrayList<>();\\n        for (int i = 2; i < 1000; i++) {\\n            int root = (int) Math.sqrt(i);\\n            boolean isPrime = true;\\n            for (int j = 2; j <= root; j++) {\\n                if (i % j == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n            }\\n            if (isPrime) listPrimes.add(i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static List<Integer> listPrimes;\\n    public boolean primeSubOperation(int[] nums) {\\n        if (nums.length == 1) return true;\\n        if (listPrimes == null) fillWithPrimes();\\n        int prev = nums[nums.length - 1];\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            int curr = nums[i];\\n            if (curr < prev) {\\n                prev = curr;\\n            } else {\\n                int diff = curr - prev + 1;\\n                int idx = Collections.binarySearch(listPrimes, diff);\\n                if (idx < 0) idx = -idx - 1;\\n                idx = Math.min(idx, listPrimes.size() - 1);\\n                if (listPrimes.get(idx) < diff) idx = Math.min(idx + 1, listPrimes.size() - 1);\\n                int res = curr - listPrimes.get(idx);\\n                if (res <= 0) return false;\\n                if (res >= prev) return false;\\n                else prev = res;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static void fillWithPrimes() {\\n        listPrimes = new ArrayList<>();\\n        for (int i = 2; i < 1000; i++) {\\n            int root = (int) Math.sqrt(i);\\n            boolean isPrime = true;\\n            for (int j = 2; j <= root; j++) {\\n                if (i % j == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n            }\\n            if (isPrime) listPrimes.add(i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357482,
                "title": "javascript-sieve-of-eratosthenes",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar primeSubOperation = function (nums) {\\n  const primes = generatePrimes(1000);\\n  const n = nums.length;\\n\\n  for (let i = n - 2; i >= 0; i--) {\\n    if (nums[i] < nums[i + 1]) continue;\\n\\n    let isOk = false;\\n    for (const prime of primes) {\\n      if (prime >= nums[i]) break;\\n\\n      const diff = nums[i] - prime;\\n      if (diff < nums[i + 1]) {\\n        nums[i] = diff;\\n        isOk = true;\\n        break;\\n      }\\n    }\\n\\n    if (!isOk) return false;\\n  }\\n\\n  return true;\\n};\\n\\nfunction generatePrimes(num) {\\n  const isPrimes = new Array(num + 1).fill();\\n  isPrimes[0] = false;\\n  isPrimes[1] = false;\\n\\n  for (let i = 2; i <= num; i++) {\\n    if (isPrimes[i] !== undefined) continue;\\n\\n    isPrimes[i] = true;\\n    for (let j = 2; i * j <= num; j++) {\\n      isPrimes[i * j] = false;\\n    }\\n  }\\n\\n  const primes = [];\\n  for (let i = 0; i <= num; i++) {\\n    if (!isPrimes[i]) continue;\\n    primes.push(i);\\n  }\\n  return primes;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar primeSubOperation = function (nums) {\\n  const primes = generatePrimes(1000);\\n  const n = nums.length;\\n\\n  for (let i = n - 2; i >= 0; i--) {\\n    if (nums[i] < nums[i + 1]) continue;\\n\\n    let isOk = false;\\n    for (const prime of primes) {\\n      if (prime >= nums[i]) break;\\n\\n      const diff = nums[i] - prime;\\n      if (diff < nums[i + 1]) {\\n        nums[i] = diff;\\n        isOk = true;\\n        break;\\n      }\\n    }\\n\\n    if (!isOk) return false;\\n  }\\n\\n  return true;\\n};\\n\\nfunction generatePrimes(num) {\\n  const isPrimes = new Array(num + 1).fill();\\n  isPrimes[0] = false;\\n  isPrimes[1] = false;\\n\\n  for (let i = 2; i <= num; i++) {\\n    if (isPrimes[i] !== undefined) continue;\\n\\n    isPrimes[i] = true;\\n    for (let j = 2; i * j <= num; j++) {\\n      isPrimes[i * j] = false;\\n    }\\n  }\\n\\n  const primes = [];\\n  for (let i = 0; i <= num; i++) {\\n    if (!isPrimes[i]) continue;\\n    primes.push(i);\\n  }\\n  return primes;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356440,
                "title": "java-greedy-solution-subtracting-largest-possible-prime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can choose any prime number, choose the largest one so that the strictly increasing condition is satisfied\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, find all primes under 1000 (task limit). Use sieve method. Then, for each number, subtract the largest prime that we can subtract so that the array is still strictly increasing.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * p), where n is a length of the nums array, and p is a number of primes under the limit.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(p)\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        // generate primes under 1000 (limit for the task)\\n        List<Integer> primes = primes();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 2 + (i == 0 ? 0 : nums[i - 1])) {\\n                int primeIndex = 0;\\n                // find largest prime that we can subtract: one where the remaining result will be alrger than previous.\\n                while(primeIndex < primes.size() - 1 && (nums[i] - primes.get(primeIndex + 1)) > (i == 0 ? 0 : nums[i - 1])) {\\n                    primeIndex++;\\n                }\\n                nums[i] -= primes.get(primeIndex);\\n            }\\n            if (i > 0 && nums[i] <= nums[i - 1]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private List<Integer> primes() {\\n        List<Integer> result = new ArrayList<>();\\n        Set<Integer> notPrimes = new HashSet<>();\\n        for (int n = 2; n < 1000; n++) {\\n            if (!notPrimes.contains(n)) {\\n                result.add(n);\\n                int notPrime = n + n;\\n                while (notPrime < 1000) {\\n                    notPrimes.add(notPrime);\\n                    notPrime += n;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        // generate primes under 1000 (limit for the task)\\n        List<Integer> primes = primes();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 2 + (i == 0 ? 0 : nums[i - 1])) {\\n                int primeIndex = 0;\\n                // find largest prime that we can subtract: one where the remaining result will be alrger than previous.\\n                while(primeIndex < primes.size() - 1 && (nums[i] - primes.get(primeIndex + 1)) > (i == 0 ? 0 : nums[i - 1])) {\\n                    primeIndex++;\\n                }\\n                nums[i] -= primes.get(primeIndex);\\n            }\\n            if (i > 0 && nums[i] <= nums[i - 1]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private List<Integer> primes() {\\n        List<Integer> result = new ArrayList<>();\\n        Set<Integer> notPrimes = new HashSet<>();\\n        for (int n = 2; n < 1000; n++) {\\n            if (!notPrimes.contains(n)) {\\n                result.add(n);\\n                int notPrime = n + n;\\n                while (notPrime < 1000) {\\n                    notPrimes.add(notPrime);\\n                    notPrime += n;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356386,
                "title": "naive-solution-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNaive\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n\\n public static boolean primeSubOperation(int[] nums) {\\n        int n = nums.length;\\n\\n        int[]prime = new int[1001]; \\n        // if prime[i] = 1 means that ith number is prime\\n        for(int i = 2;i<1001;i++){\\n            BigInteger bn = new BigInteger(String.valueOf(i));\\n            if( bn.isProbablePrime(10)) prime[i]=1;\\n        }\\n\\n        for(int i = 0;i<n;i++){\\n\\n            for(int j = (nums[i]-1);j>=2;j--){\\n \\n                if(prime[j]==1){\\n                    if(i==0 && nums[i]>1){\\n                        nums[i] = nums[i] - j;\\n                        break;\\n                    }\\n                    else if(i!=0 && nums[i]>1){\\n                        if(nums[i]-j > nums[i-1]) {\\n                            nums[i]  = nums[i] - j;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 1; i <n; i++) {\\n           if(nums[i-1]>nums[i] || nums[i-1]==nums[i]) return false;\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n\\n public static boolean primeSubOperation(int[] nums) {\\n        int n = nums.length;\\n\\n        int[]prime = new int[1001]; \\n        // if prime[i] = 1 means that ith number is prime\\n        for(int i = 2;i<1001;i++){\\n            BigInteger bn = new BigInteger(String.valueOf(i));\\n            if( bn.isProbablePrime(10)) prime[i]=1;\\n        }\\n\\n        for(int i = 0;i<n;i++){\\n\\n            for(int j = (nums[i]-1);j>=2;j--){\\n \\n                if(prime[j]==1){\\n                    if(i==0 && nums[i]>1){\\n                        nums[i] = nums[i] - j;\\n                        break;\\n                    }\\n                    else if(i!=0 && nums[i]>1){\\n                        if(nums[i]-j > nums[i-1]) {\\n                            nums[i]  = nums[i] - j;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for (int i = 1; i <n; i++) {\\n           if(nums[i-1]>nums[i] || nums[i-1]==nums[i]) return false;\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355855,
                "title": "easy-c-solution-seive-of-eratosthenes",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSTARTING FROM BEHIND FOR EACH ELEMENT CHECK FOR THE MIN PRIME NO WHICH REDUCES THE CURRENT ELEMENT TO LESS THAN THE PREV ELEMENT\\nAND IF NO SUCH ELEMENT EXISTS THEN RETURN FALSE ELSE RETURN TRUE IN THE END.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(1000log(log(1000))) + O(1000) + O(N1000)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(NO OF PRIME NOS UNTILL 1000)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void seive_algo(vector<bool> &v, int n){\\n        v[0] = v[1] = false;\\n        for(int i=2; i*i<n; i++){\\n            for(int j=i*i; j<n; j+=i){\\n                v[j] = false;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> isPrime(1005, true);\\n        seive_algo(isPrime, 1005);\\n\\n        vector<int> prime;\\n        for(int i=0; i<1004; i++)\\n            if(isPrime[i]) prime.push_back(i);\\n        \\n        int flg = false;\\n        int prev = nums[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(nums[i]<prev)\\n            {\\n                prev = nums[i]; \\n                continue;\\n            }\\n            flg = true;\\n            for(int sub=0; sub<prime.size() && prime[sub]<nums[i]; sub++){\\n                if(nums[i]-prime[sub]<prev){\\n                    prev = nums[i]-prime[sub];\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg==true) break;\\n\\n        }\\n        return !flg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void seive_algo(vector<bool> &v, int n){\\n        v[0] = v[1] = false;\\n        for(int i=2; i*i<n; i++){\\n            for(int j=i*i; j<n; j+=i){\\n                v[j] = false;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> isPrime(1005, true);\\n        seive_algo(isPrime, 1005);\\n\\n        vector<int> prime;\\n        for(int i=0; i<1004; i++)\\n            if(isPrime[i]) prime.push_back(i);\\n        \\n        int flg = false;\\n        int prev = nums[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(nums[i]<prev)\\n            {\\n                prev = nums[i]; \\n                continue;\\n            }\\n            flg = true;\\n            for(int sub=0; sub<prime.size() && prime[sub]<nums[i]; sub++){\\n                if(nums[i]-prime[sub]<prev){\\n                    prev = nums[i]-prime[sub];\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg==true) break;\\n\\n        }\\n        return !flg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353755,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn prime_sub_operation(nums: Vec<i32>) -> bool {\\n        use std::cmp::Ordering;\\n        fn lower_bound_by<T, F>(arr: &[T], f: F) -> Result<usize, usize>\\n        where\\n            T: Ord,\\n            F: Fn(&T) -> Ordering,\\n        {\\n            arr.iter().position(|y| f(y) != Ordering::Less).ok_or(arr.len())\\n        }\\n\\n        fn lower_bound<T: Ord>(arr: &[T], x: &T) -> Result<usize, usize> {\\n            lower_bound_by(arr, |y| y.cmp(x))\\n        }\\n\\n        fn get_primes() -> Vec<i32> {\\n            let mut ps = vec![2];\\n            let mut sieve = vec![false; 1001];\\n            for i in 3..32 {\\n                if !sieve[i] {\\n                    for j in (i * i..=1000).step_by(i) {\\n                        sieve[j] = true;\\n                    }\\n                }\\n            }\\n            for i in (3..=1000).step_by(2) {\\n                if !sieve[i as usize] {\\n                    ps.push(i);\\n                }\\n            }\\n            ps\\n        }\\n\\n        let mut nums = nums;\\n        let ps = get_primes();\\n        for i in 0..nums.len() {\\n            let it = lower_bound(&ps, &(nums[i] - if i > 0 { nums[i - 1] } else { 0 }));\\n            let it = it.unwrap_or(ps.len());\\n            if it > 0 {\\n                nums[i] -= ps[it - 1];\\n            }\\n            if i > 0 && nums[i] <= nums[i - 1] {\\n                return false;\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prime_sub_operation(nums: Vec<i32>) -> bool {\\n        use std::cmp::Ordering;\\n        fn lower_bound_by<T, F>(arr: &[T], f: F) -> Result<usize, usize>\\n        where\\n            T: Ord,\\n            F: Fn(&T) -> Ordering,\\n        {\\n            arr.iter().position(|y| f(y) != Ordering::Less).ok_or(arr.len())\\n        }\\n\\n        fn lower_bound<T: Ord>(arr: &[T], x: &T) -> Result<usize, usize> {\\n            lower_bound_by(arr, |y| y.cmp(x))\\n        }\\n\\n        fn get_primes() -> Vec<i32> {\\n            let mut ps = vec![2];\\n            let mut sieve = vec![false; 1001];\\n            for i in 3..32 {\\n                if !sieve[i] {\\n                    for j in (i * i..=1000).step_by(i) {\\n                        sieve[j] = true;\\n                    }\\n                }\\n            }\\n            for i in (3..=1000).step_by(2) {\\n                if !sieve[i as usize] {\\n                    ps.push(i);\\n                }\\n            }\\n            ps\\n        }\\n\\n        let mut nums = nums;\\n        let ps = get_primes();\\n        for i in 0..nums.len() {\\n            let it = lower_bound(&ps, &(nums[i] - if i > 0 { nums[i - 1] } else { 0 }));\\n            let it = it.unwrap_or(ps.len());\\n            if it > 0 {\\n                nums[i] -= ps[it - 1];\\n            }\\n            if i > 0 && nums[i] <= nums[i - 1] {\\n                return false;\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3353376,
                "title": "binary-search-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def primeSubOperation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # Get All Prime Number from 1 to 1000\\n        prime_num = [2, 3]\\n        for i in range(5, 1001):\\n            for j in range(2, int(sqrt(i)) + 1):\\n                if i % j == 0:\\n                    break\\n            else:\\n                prime_num.append(i)\\n        # reduce every element from nums array as small as possible\\n        for i in range(len(nums)):\\n            if i == 0:\\n                idx = bisect.bisect_left(prime_num, nums[i])\\n                if idx > 0:\\n                    nums[i] -= prime_num[idx - 1]\\n            else:\\n                if nums[i] > nums[i - 1]:\\n                    idx = bisect.bisect_left(prime_num, nums[i] - nums[i - 1])\\n                    if idx > 0:\\n                        nums[i] -= prime_num[idx - 1]\\n                # if curr val is equal or less than the previous idx val, return False\\n                else:\\n                    return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def primeSubOperation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # Get All Prime Number from 1 to 1000\\n        prime_num = [2, 3]\\n        for i in range(5, 1001):\\n            for j in range(2, int(sqrt(i)) + 1):\\n                if i % j == 0:\\n                    break\\n            else:\\n                prime_num.append(i)\\n        # reduce every element from nums array as small as possible\\n        for i in range(len(nums)):\\n            if i == 0:\\n                idx = bisect.bisect_left(prime_num, nums[i])\\n                if idx > 0:\\n                    nums[i] -= prime_num[idx - 1]\\n            else:\\n                if nums[i] > nums[i - 1]:\\n                    idx = bisect.bisect_left(prime_num, nums[i] - nums[i - 1])\\n                    if idx > 0:\\n                        nums[i] -= prime_num[idx - 1]\\n                # if curr val is equal or less than the previous idx val, return False\\n                else:\\n                    return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352662,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        primes = self.getPrimes(1000)\\n\\n        n = len(nums)\\n        right = nums[n - 1]\\n        needSub = False\\n        for i in range(n - 2, -1, -1):\\n            if nums[i] < right:\\n                right = nums[i]\\n                continue\\n\\n            needSub = True\\n            for p in primes:\\n                if p >= nums[i]:\\n                    break\\n                \\n                if nums[i] - p < right:\\n                    right = nums[i] - p\\n                    needSub = False\\n                    break\\n            if needSub:\\n                return False\\n        return True\\n        \\n    def getPrimes(self, n: int) -> List[int]:\\n        res = []\\n        prime = [True] * (n + 1)\\n\\n        for i in range(2, floor(sqrt(n))):\\n            if prime[i]:\\n                for j in range(i * i, n, i):\\n                    prime[j] = False\\n        \\n        for i in range(2, n):\\n            if prime[i]:\\n                res.append(i)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        primes = self.getPrimes(1000)\\n\\n        n = len(nums)\\n        right = nums[n - 1]\\n        needSub = False\\n        for i in range(n - 2, -1, -1):\\n            if nums[i] < right:\\n                right = nums[i]\\n                continue\\n\\n            needSub = True\\n            for p in primes:\\n                if p >= nums[i]:\\n                    break\\n                \\n                if nums[i] - p < right:\\n                    right = nums[i] - p\\n                    needSub = False\\n                    break\\n            if needSub:\\n                return False\\n        return True\\n        \\n    def getPrimes(self, n: int) -> List[int]:\\n        res = []\\n        prime = [True] * (n + 1)\\n\\n        for i in range(2, floor(sqrt(n))):\\n            if prime[i]:\\n                for j in range(i * i, n, i):\\n                    prime[j] = False\\n        \\n        for i in range(2, n):\\n            if prime[i]:\\n                res.append(i)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352597,
                "title": "javascript-easy-solution",
                "content": "```\\nvar primeSubOperation = function(nums) {\\n    let primes = getPrimes(1000);\\n    let n = nums.length;\\n    let prev = nums[n - 1];\\n    let needSub = false;\\n\\n    for(let i = n - 2; i >= 0; i--){\\n        if(nums[i] < prev){\\n            prev = nums[i];\\n            continue;\\n        }\\n\\n        needSub = true;  \\n        for(let p of primes){\\n            if(nums[i] <= p) break;\\n\\n            if(nums[i] - p < prev){\\n                prev = nums[i] - p;\\n                needSub = false;\\n                break;\\n            }\\n        }\\n        if(needSub) return false;\\n    }\\n    return true;\\n};\\n\\nlet getPrimes = function(n){\\n    let prime = new Array(n + 1).fill(true);\\n    let res = [];\\n\\n    for(let i = 2; i < Math.sqrt(n); i++){\\n        if(prime[i]){\\n            for(let j = i * i; j <= n; j += i){\\n                prime[j] = false;\\n            }\\n        }\\n    }\\n\\n    for(let i = 2; i <= n; i++){\\n        if(prime[i]) res.push(i);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar primeSubOperation = function(nums) {\\n    let primes = getPrimes(1000);\\n    let n = nums.length;\\n    let prev = nums[n - 1];\\n    let needSub = false;\\n\\n    for(let i = n - 2; i >= 0; i--){\\n        if(nums[i] < prev){\\n            prev = nums[i];\\n            continue;\\n        }\\n\\n        needSub = true;  \\n        for(let p of primes){\\n            if(nums[i] <= p) break;\\n\\n            if(nums[i] - p < prev){\\n                prev = nums[i] - p;\\n                needSub = false;\\n                break;\\n            }\\n        }\\n        if(needSub) return false;\\n    }\\n    return true;\\n};\\n\\nlet getPrimes = function(n){\\n    let prime = new Array(n + 1).fill(true);\\n    let res = [];\\n\\n    for(let i = 2; i < Math.sqrt(n); i++){\\n        if(prime[i]){\\n            for(let j = i * i; j <= n; j += i){\\n                prime[j] = false;\\n            }\\n        }\\n    }\\n\\n    for(let i = 2; i <= n; i++){\\n        if(prime[i]) res.push(i);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3352466,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getPrimes(int n){\\n        vector<int> res;\\n        bool prime[n + 1];\\n\\n        for(int i = 0; i < n; i++) \\n            prime[i] = true;\\n        \\n\\n        for(int i = 2; i < sqrt(n); i++){\\n            if(prime[i]){\\n                for(int j = i * i; j <= n; j += i){\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n\\n        for(int i = 2; i <= n; i++){\\n            if(prime[i]) \\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> primes = getPrimes(1000);\\n\\n        int n = nums.size();\\n        int prev = nums[n - 1];\\n        bool needSub = false;\\n\\n        for(int i = n - 2; i >= 0; i--){\\n            if(nums[i] < prev){\\n                prev = nums[i];\\n                continue;\\n            }\\n\\n            needSub = true;\\n            for(int j = 0; j < primes.size() && primes[j] < nums[i]; j++){\\n                if(nums[i] - primes[j] < prev){\\n                    prev = nums[i] - primes[j];\\n                    needSub = false;\\n                    break;\\n                }\\n            }\\n            if(needSub) \\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getPrimes(int n){\\n        vector<int> res;\\n        bool prime[n + 1];\\n\\n        for(int i = 0; i < n; i++) \\n            prime[i] = true;\\n        \\n\\n        for(int i = 2; i < sqrt(n); i++){\\n            if(prime[i]){\\n                for(int j = i * i; j <= n; j += i){\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n\\n        for(int i = 2; i <= n; i++){\\n            if(prime[i]) \\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> primes = getPrimes(1000);\\n\\n        int n = nums.size();\\n        int prev = nums[n - 1];\\n        bool needSub = false;\\n\\n        for(int i = n - 2; i >= 0; i--){\\n            if(nums[i] < prev){\\n                prev = nums[i];\\n                continue;\\n            }\\n\\n            needSub = true;\\n            for(int j = 0; j < primes.size() && primes[j] < nums[i]; j++){\\n                if(nums[i] - primes[j] < prev){\\n                    prev = nums[i] - primes[j];\\n                    needSub = false;\\n                    break;\\n                }\\n            }\\n            if(needSub) \\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352434,
                "title": "prime-subtraction-java-easy-to-understand-minimize-difference-between-curr-and-next",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        boolean []prime=new boolean[1001];\\n        Arrays.fill(prime,true);\\n        prime[0]=false;\\n        prime[1]=false;\\n        for(int i=2;i<=1000;i++){\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){\\n                    prime[i]=false;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }else{\\n                int diff=nums[i]-nums[i+1];\\n                boolean flag=false;\\n                int p=-1;\\n\\n                for(int j=diff+1;j>=0 && j<=1000 && j<nums[i];j++){\\n                    if(prime[j]){\\n                        flag=true;\\n                        p=j;\\n                        break;\\n                    }\\n                }\\n\\n                if(!flag){\\n                    return false;\\n                }\\n\\n                nums[i]-=p;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        boolean []prime=new boolean[1001];\\n        Arrays.fill(prime,true);\\n        prime[0]=false;\\n        prime[1]=false;\\n        for(int i=2;i<=1000;i++){\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){\\n                    prime[i]=false;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }else{\\n                int diff=nums[i]-nums[i+1];\\n                boolean flag=false;\\n                int p=-1;\\n\\n                for(int j=diff+1;j>=0 && j<=1000 && j<nums[i];j++){\\n                    if(prime[j]){\\n                        flag=true;\\n                        p=j;\\n                        break;\\n                    }\\n                }\\n\\n                if(!flag){\\n                    return false;\\n                }\\n\\n                nums[i]-=p;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351487,
                "title": "easy-c-solution-using-seive-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nACCORDING TO GIVEN CONSTRAINTS WE STORE ALL THE PRIME NOS UPTO 1000 IN AN ARRAY USING SEIVE OF ERATOSTHENES\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSTARTING FROM BEHIND FOR EACH ELEMENT CHECK FOR THE MIN PRIME NO WHICH REDUCES THE CURRENT ELEMENT TO LESS THAN THE PREV ELEMENT\\nAND IF NO SUCH ELEMENT EXISTS THEN RETURN FALSE ELSE RETURN TRUE IN THE END.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1000*log(log(1000))) + O(1000) + O(N*1000)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(NO OF PRIME NOS UNTILL 1000)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void seive_algo(vector<bool> &v, int n){\\n        v[0] = v[1] = false;\\n        for(int i=2; i*i<n; i++){\\n            for(int j=i*i; j<n; j+=i){\\n                v[j] = false;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> isPrime(1005, true);\\n        seive_algo(isPrime, 1005);\\n\\n        vector<int> prime;\\n        for(int i=0; i<1004; i++)\\n            if(isPrime[i]) prime.push_back(i);\\n        \\n        int flg = false;\\n        int prev = nums[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(nums[i]<prev)\\n            {\\n                prev = nums[i]; \\n                continue;\\n            }\\n            flg = true;\\n            for(int sub=0; sub<prime.size() && prime[sub]<nums[i]; sub++){\\n                if(nums[i]-prime[sub]<prev){\\n                    prev = nums[i]-prime[sub];\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg==true) break;\\n\\n        }\\n        return !flg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void seive_algo(vector<bool> &v, int n){\\n        v[0] = v[1] = false;\\n        for(int i=2; i*i<n; i++){\\n            for(int j=i*i; j<n; j+=i){\\n                v[j] = false;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> isPrime(1005, true);\\n        seive_algo(isPrime, 1005);\\n\\n        vector<int> prime;\\n        for(int i=0; i<1004; i++)\\n            if(isPrime[i]) prime.push_back(i);\\n        \\n        int flg = false;\\n        int prev = nums[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(nums[i]<prev)\\n            {\\n                prev = nums[i]; \\n                continue;\\n            }\\n            flg = true;\\n            for(int sub=0; sub<prime.size() && prime[sub]<nums[i]; sub++){\\n                if(nums[i]-prime[sub]<prev){\\n                    prev = nums[i]-prime[sub];\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg==true) break;\\n\\n        }\\n        return !flg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351306,
                "title": "seive-algo-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void make_seive(vector <bool>&seive)\\n    {\\n        seive[0]=false;\\n        seive[1]=false;\\n        for(int i=2;i<1001;i++)\\n        {\\n            if(seive[i]==true)\\n            {\\n                for(int j=2*i;j<1001;j+=i)\\n                    seive[j]=false;\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector <bool> seive(1001,true);\\n        make_seive(seive);\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n\\n            for( int j=(nums[i]-1);j>=0;j--)\\n            {\\n                if(seive[j]==true && (i==0 ||nums[i]-j> nums[i-1])){\\n                    nums[i]-=j;\\n                    break;\\n                }\\n                    \\n            }\\n            if(i>0 && nums[i]<=nums[i-1])\\n            {\\n                return false;\\n            \\n            }\\n                \\n        }\\n       \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void make_seive(vector <bool>&seive)\\n    {\\n        seive[0]=false;\\n        seive[1]=false;\\n        for(int i=2;i<1001;i++)\\n        {\\n            if(seive[i]==true)\\n            {\\n                for(int j=2*i;j<1001;j+=i)\\n                    seive[j]=false;\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector <bool> seive(1001,true);\\n        make_seive(seive);\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n\\n            for( int j=(nums[i]-1);j>=0;j--)\\n            {\\n                if(seive[j]==true && (i==0 ||nums[i]-j> nums[i-1])){\\n                    nums[i]-=j;\\n                    break;\\n                }\\n                    \\n            }\\n            if(i>0 && nums[i]<=nums[i-1])\\n            {\\n                return false;\\n            \\n            }\\n                \\n        }\\n       \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351244,
                "title": "doubt",
                "content": "here in question no. 2601 Prime Substraction Operation \\ntestcase no.578 where nums=[15,20,17,7,16]\\nit\\'s output according to my code should be false but system ans is true\\nCan anybody help me in justifying this output \\nMY CODE :\\n\\nclass Solution {\\nprivate:\\n    bool issort(vector<int> check){\\n        int flag=-1;\\n        if (check.size()==1){\\n            return true;\\n        }\\n        for (int i=0 ; i<check.size()-1 ; i++){\\n            if (check[i+1]>check[i]){\\n                flag=1;\\n            }\\n            else{\\n                flag=0;\\n                break;\\n            }\\n        }\\n        if (flag==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int prime(int n){\\n        vector<bool> p(n,true);\\n        p[0]=false;\\n        p[1]=false;\\n        for (int i=2 ; i<n ; i++){\\n            if (p[i]){\\n                for (int j=i*2 ; j<n ; j=j+i){\\n                    p[j]=false;\\n                }\\n            }\\n        }\\n        int ans=-1;\\n        for (int a=2 ; a<n ; a++){\\n            if (p[a]){\\n                ans=a;\\n            }\\n        }\\n        //cout<<ans<<endl;\\n        return ans;\\n    }\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n       \\n        for (int i=0 ; i<nums.size() ; i++){\\n            int v=prime(nums[i]);\\n            nums[i]=nums[i]-v;\\n            //cout<<nums[i]<<\\' \\';\\n            \\n            if (issort(nums)){\\n                return true;\\n            }\\n            \\n            //cout<<\"final :\"<<v<<endl;\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    bool issort(vector<int> check){\\n        int flag=-1;\\n        if (check.size()==1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3351204,
                "title": "javascript-math",
                "content": "```\\nconst primeSubOperation = (a) => {\\n    let se = sieveEratosthenes(1005), pre = 0;\\n    for (const x of a) {\\n        let cur = x;\\n        for (const p of se) {\\n            if (p <= x && x - p > pre) cur = Math.min(cur, x - p);\\n        }\\n        if (cur <= pre) return false;\\n        pre = cur;\\n    }\\n    return true;\\n};\\n\\nconst sieveEratosthenes = (n) => {\\n    let prime = Array(n + 1).fill(true), res = new Set();\\n    for (let p = 2; p * p <= n; p++) {\\n        if (prime[p] == true) {\\n            for (let i = p * p; i <= n; i += p) prime[i] = false;\\n        }\\n    }\\n    for (let p = 2; p <= n; p++) {\\n        if (prime[p]) res.add(p);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst primeSubOperation = (a) => {\\n    let se = sieveEratosthenes(1005), pre = 0;\\n    for (const x of a) {\\n        let cur = x;\\n        for (const p of se) {\\n            if (p <= x && x - p > pre) cur = Math.min(cur, x - p);\\n        }\\n        if (cur <= pre) return false;\\n        pre = cur;\\n    }\\n    return true;\\n};\\n\\nconst sieveEratosthenes = (n) => {\\n    let prime = Array(n + 1).fill(true), res = new Set();\\n    for (let p = 2; p * p <= n; p++) {\\n        if (prime[p] == true) {\\n            for (let i = p * p; i <= n; i += p) prime[i] = false;\\n        }\\n    }\\n    for (let p = 2; p <= n; p++) {\\n        if (prime[p]) res.add(p);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3350876,
                "title": "c-using-sieve-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void SieveOfEratosthenes(int n,vector <int> &pr){\\n    bool prime[n + 1];\\n    memset(prime, true, sizeof(prime));\\n    for (int p = 2; p * p <= n; p++) {\\n        if (prime[p] == true) {\\n            for (int i = p * p; i <= n; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n    for (int p = 2; p <= n; p++)\\n        if (prime[p])\\n            pr.push_back(p);\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> prime;\\n        SieveOfEratosthenes(*max_element(nums.begin(),nums.end()),prime);\\n        int p=prime.size();\\n        for(int i=p-1;i>=0;i--){\\n            if(nums[0] > prime[i]){\\n               nums[0]-=prime[i];\\n               break;\\n            }\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=p-1;j >= 0;j--){\\n                if(nums[i] > prime[j] &&  nums[i]-prime[j] > nums[i-1]){\\n                    nums[i]-=prime[j];\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            if(nums[i-1] >= nums[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void SieveOfEratosthenes(int n,vector <int> &pr){\\n    bool prime[n + 1];\\n    memset(prime, true, sizeof(prime));\\n    for (int p = 2; p * p <= n; p++) {\\n        if (prime[p] == true) {\\n            for (int i = p * p; i <= n; i += p)\\n                prime[i] = false;\\n        }\\n    }\\n    for (int p = 2; p <= n; p++)\\n        if (prime[p])\\n            pr.push_back(p);\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> prime;\\n        SieveOfEratosthenes(*max_element(nums.begin(),nums.end()),prime);\\n        int p=prime.size();\\n        for(int i=p-1;i>=0;i--){\\n            if(nums[0] > prime[i]){\\n               nums[0]-=prime[i];\\n               break;\\n            }\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=p-1;j >= 0;j--){\\n                if(nums[i] > prime[j] &&  nums[i]-prime[j] > nums[i-1]){\\n                    nums[i]-=prime[j];\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            if(nums[i-1] >= nums[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350377,
                "title": "easy-beginner-friendly-solution-c-with-binary-search",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst store all the prime numbers from 1 to 1000 in a vector primes\\n(including 0 since we can also subtract 0 from the element basically leaving it as it is). Then for each numer in the array find the maximum prime number that can be subtracted from it by running a binary search on the primes array. If there is a possiblle prime number substration for each index then return true, else return false.\\nSieve of Eratosthenes can be used to improve the TC for finding the primes.\\n\\n**Please UpVote If you find this Solution Helpful  !!!**\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int BS(int mn,int mx,vector<int>primes){\\n        int l=0,r=primes.size()-1;\\n        int ans = -1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(primes[mid]<mn) l=mid+1;\\n            else if(primes[mid]>mx)r=mid-1;\\n            else{\\n                ans = primes[mid];\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int>primes;\\n        primes.push_back(0);\\n        for(int i=2;i<=1000;i++){\\n            int flag = 0;\\n            for(int j = 2;j<i;j++){\\n                if(i%j==0){\\n                    flag = 1;\\n                    goto end;\\n                }\\n            }\\n            end:\\n            if(!flag)primes.push_back(i);\\n        }\\n        int prev = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int prm = BS(0,(nums[i]-prev-1),primes);\\n            if(prm == -1) return false;\\n            prev = nums[i] - prm;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int BS(int mn,int mx,vector<int>primes){\\n        int l=0,r=primes.size()-1;\\n        int ans = -1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(primes[mid]<mn) l=mid+1;\\n            else if(primes[mid]>mx)r=mid-1;\\n            else{\\n                ans = primes[mid];\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int>primes;\\n        primes.push_back(0);\\n        for(int i=2;i<=1000;i++){\\n            int flag = 0;\\n            for(int j = 2;j<i;j++){\\n                if(i%j==0){\\n                    flag = 1;\\n                    goto end;\\n                }\\n            }\\n            end:\\n            if(!flag)primes.push_back(i);\\n        }\\n        int prev = 0;\\n        for(int i=0;i<nums.size();i++){\\n            int prm = BS(0,(nums[i]-prev-1),primes);\\n            if(prm == -1) return false;\\n            prev = nums[i] - prm;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350274,
                "title": "python-sieve-algo",
                "content": "```python\\nclass Solution:\\n\\n    def generatePrimes(self, n):\\n        \\n        primes = [True]*n\\n        primes[0] = False\\n        primes[1] = False\\n        for i in range(2, int(math.sqrt(n))+1):\\n            if primes[i]:\\n                j = i+i\\n                while j < len(primes):\\n                    primes[j] = False\\n                    j += i\\n        \\n        \\n        return [i for i, p in enumerate(primes) if p]\\n    \\n\\n    def getMaxPrime(self, n, primes):\\n        i = bisect.bisect_left(primes, n)\\n        return primes[i-1]\\n            \\n    def primeSubOperation(self, A: List[int]) -> bool:\\n        primes = self.generatePrimes(1001)\\n        prev = 0\\n        for a in A:\\n            # Not increasing\\n            if a - prev <= 0:\\n                return False\\n            # 2 is the smallest prime\\n            # nothing can help us.\\n            if a - prev <= 2:\\n                prev = a\\n            else:\\n                maxPrime = self.getMaxPrime(a-prev, primes)\\n                prev = a - maxPrime\\n        return True\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n\\n    def generatePrimes(self, n):\\n        \\n        primes = [True]*n\\n        primes[0] = False\\n        primes[1] = False\\n        for i in range(2, int(math.sqrt(n))+1):\\n            if primes[i]:\\n                j = i+i\\n                while j < len(primes):\\n                    primes[j] = False\\n                    j += i\\n        \\n        \\n        return [i for i, p in enumerate(primes) if p]\\n    \\n\\n    def getMaxPrime(self, n, primes):\\n        i = bisect.bisect_left(primes, n)\\n        return primes[i-1]\\n            \\n    def primeSubOperation(self, A: List[int]) -> bool:\\n        primes = self.generatePrimes(1001)\\n        prev = 0\\n        for a in A:\\n            # Not increasing\\n            if a - prev <= 0:\\n                return False\\n            # 2 is the smallest prime\\n            # nothing can help us.\\n            if a - prev <= 2:\\n                prev = a\\n            else:\\n                maxPrime = self.getMaxPrime(a-prev, primes)\\n                prev = a - maxPrime\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350265,
                "title": "ts-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSubtract each `cur` by the largest prime `< cur - pre` and check if they are strictly increasing.\\n\\n# Complexity\\n- Time complexity: $O(n)$ + time to generate `arr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$ + space to store `arr`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction primeSubOperation(nums: number[]): boolean {\\n    // arr[i] gives the greatest prime < i\\n    const arr = [NaN,0,0,2,3,3,5,5,7,7,7,7,11,11,13,13,13,13,17,17,19,19,19,19,23,23,23,23,23,23,29,29,31,31,31,31,31,31,37,37,37,37,41,41,43,43,43,43,47,47,47,47,47,47,53,53,53,53,53,53,59,59,61,61,61,61,61,61,67,67,67,67,71,71,73,73,73,73,73,73,79,79,79,79,83,83,83,83,83,83,89,89,89,89,89,89,89,89,97,97,97,97,101,101,103,103,103,103,107,107,109,109,109,109,113,113,113,113,113,113,113,113,113,113,113,113,113,113,127,127,127,127,131,131,131,131,131,131,137,137,139,139,139,139,139,139,139,139,139,139,149,149,151,151,151,151,151,151,157,157,157,157,157,157,163,163,163,163,167,167,167,167,167,167,173,173,173,173,173,173,179,179,181,181,181,181,181,181,181,181,181,181,191,191,193,193,193,193,197,197,199,199,199,199,199,199,199,199,199,199,199,199,211,211,211,211,211,211,211,211,211,211,211,211,223,223,223,223,227,227,229,229,229,229,233,233,233,233,233,233,239,239,241,241,241,241,241,241,241,241,241,241,251,251,251,251,251,251,257,257,257,257,257,257,263,263,263,263,263,263,269,269,271,271,271,271,271,271,277,277,277,277,281,281,283,283,283,283,283,283,283,283,283,283,293,293,293,293,293,293,293,293,293,293,293,293,293,293,307,307,307,307,311,311,313,313,313,313,317,317,317,317,317,317,317,317,317,317,317,317,317,317,331,331,331,331,331,331,337,337,337,337,337,337,337,337,337,337,347,347,349,349,349,349,353,353,353,353,353,353,359,359,359,359,359,359,359,359,367,367,367,367,367,367,373,373,373,373,373,373,379,379,379,379,383,383,383,383,383,383,389,389,389,389,389,389,389,389,397,397,397,397,401,401,401,401,401,401,401,401,409,409,409,409,409,409,409,409,409,409,419,419,421,421,421,421,421,421,421,421,421,421,431,431,433,433,433,433,433,433,439,439,439,439,443,443,443,443,443,443,449,449,449,449,449,449,449,449,457,457,457,457,461,461,463,463,463,463,467,467,467,467,467,467,467,467,467,467,467,467,479,479,479,479,479,479,479,479,487,487,487,487,491,491,491,491,491,491,491,491,499,499,499,499,503,503,503,503,503,503,509,509,509,509,509,509,509,509,509,509,509,509,521,521,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,541,541,541,541,541,541,547,547,547,547,547,547,547,547,547,547,557,557,557,557,557,557,563,563,563,563,563,563,569,569,571,571,571,571,571,571,577,577,577,577,577,577,577,577,577,577,587,587,587,587,587,587,593,593,593,593,593,593,599,599,601,601,601,601,601,601,607,607,607,607,607,607,613,613,613,613,617,617,619,619,619,619,619,619,619,619,619,619,619,619,631,631,631,631,631,631,631,631,631,631,641,641,643,643,643,643,647,647,647,647,647,647,653,653,653,653,653,653,659,659,661,661,661,661,661,661,661,661,661,661,661,661,673,673,673,673,677,677,677,677,677,677,683,683,683,683,683,683,683,683,691,691,691,691,691,691,691,691,691,691,701,701,701,701,701,701,701,701,709,709,709,709,709,709,709,709,709,709,719,719,719,719,719,719,719,719,727,727,727,727,727,727,733,733,733,733,733,733,739,739,739,739,743,743,743,743,743,743,743,743,751,751,751,751,751,751,757,757,757,757,761,761,761,761,761,761,761,761,769,769,769,769,773,773,773,773,773,773,773,773,773,773,773,773,773,773,787,787,787,787,787,787,787,787,787,787,797,797,797,797,797,797,797,797,797,797,797,797,809,809,811,811,811,811,811,811,811,811,811,811,821,821,823,823,823,823,827,827,829,829,829,829,829,829,829,829,829,829,839,839,839,839,839,839,839,839,839,839,839,839,839,839,853,853,853,853,857,857,859,859,859,859,863,863,863,863,863,863,863,863,863,863,863,863,863,863,877,877,877,877,881,881,883,883,883,883,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,907,907,907,907,911,911,911,911,911,911,911,911,919,919,919,919,919,919,919,919,919,919,929,929,929,929,929,929,929,929,937,937,937,937,941,941,941,941,941,941,947,947,947,947,947,947,953,953,953,953,953,953,953,953,953,953,953,953,953,953,967,967,967,967,971,971,971,971,971,971,977,977,977,977,977,977,983,983,983,983,983,983,983,983,991,991,991,991,991,991,997,997,997]\\n    // copy-paste arr below gives 1-line code\\n    return nums.reduce((pre, cur) => cur - arr[cur - pre], 0) > 0\\n    // if not strictly increasing, cur - pre <= 0 and result will be NaN\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Greedy"
                ],
                "code": "```\\nfunction primeSubOperation(nums: number[]): boolean {\\n    // arr[i] gives the greatest prime < i\\n    const arr = [NaN,0,0,2,3,3,5,5,7,7,7,7,11,11,13,13,13,13,17,17,19,19,19,19,23,23,23,23,23,23,29,29,31,31,31,31,31,31,37,37,37,37,41,41,43,43,43,43,47,47,47,47,47,47,53,53,53,53,53,53,59,59,61,61,61,61,61,61,67,67,67,67,71,71,73,73,73,73,73,73,79,79,79,79,83,83,83,83,83,83,89,89,89,89,89,89,89,89,97,97,97,97,101,101,103,103,103,103,107,107,109,109,109,109,113,113,113,113,113,113,113,113,113,113,113,113,113,113,127,127,127,127,131,131,131,131,131,131,137,137,139,139,139,139,139,139,139,139,139,139,149,149,151,151,151,151,151,151,157,157,157,157,157,157,163,163,163,163,167,167,167,167,167,167,173,173,173,173,173,173,179,179,181,181,181,181,181,181,181,181,181,181,191,191,193,193,193,193,197,197,199,199,199,199,199,199,199,199,199,199,199,199,211,211,211,211,211,211,211,211,211,211,211,211,223,223,223,223,227,227,229,229,229,229,233,233,233,233,233,233,239,239,241,241,241,241,241,241,241,241,241,241,251,251,251,251,251,251,257,257,257,257,257,257,263,263,263,263,263,263,269,269,271,271,271,271,271,271,277,277,277,277,281,281,283,283,283,283,283,283,283,283,283,283,293,293,293,293,293,293,293,293,293,293,293,293,293,293,307,307,307,307,311,311,313,313,313,313,317,317,317,317,317,317,317,317,317,317,317,317,317,317,331,331,331,331,331,331,337,337,337,337,337,337,337,337,337,337,347,347,349,349,349,349,353,353,353,353,353,353,359,359,359,359,359,359,359,359,367,367,367,367,367,367,373,373,373,373,373,373,379,379,379,379,383,383,383,383,383,383,389,389,389,389,389,389,389,389,397,397,397,397,401,401,401,401,401,401,401,401,409,409,409,409,409,409,409,409,409,409,419,419,421,421,421,421,421,421,421,421,421,421,431,431,433,433,433,433,433,433,439,439,439,439,443,443,443,443,443,443,449,449,449,449,449,449,449,449,457,457,457,457,461,461,463,463,463,463,467,467,467,467,467,467,467,467,467,467,467,467,479,479,479,479,479,479,479,479,487,487,487,487,491,491,491,491,491,491,491,491,499,499,499,499,503,503,503,503,503,503,509,509,509,509,509,509,509,509,509,509,509,509,521,521,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,523,541,541,541,541,541,541,547,547,547,547,547,547,547,547,547,547,557,557,557,557,557,557,563,563,563,563,563,563,569,569,571,571,571,571,571,571,577,577,577,577,577,577,577,577,577,577,587,587,587,587,587,587,593,593,593,593,593,593,599,599,601,601,601,601,601,601,607,607,607,607,607,607,613,613,613,613,617,617,619,619,619,619,619,619,619,619,619,619,619,619,631,631,631,631,631,631,631,631,631,631,641,641,643,643,643,643,647,647,647,647,647,647,653,653,653,653,653,653,659,659,661,661,661,661,661,661,661,661,661,661,661,661,673,673,673,673,677,677,677,677,677,677,683,683,683,683,683,683,683,683,691,691,691,691,691,691,691,691,691,691,701,701,701,701,701,701,701,701,709,709,709,709,709,709,709,709,709,709,719,719,719,719,719,719,719,719,727,727,727,727,727,727,733,733,733,733,733,733,739,739,739,739,743,743,743,743,743,743,743,743,751,751,751,751,751,751,757,757,757,757,761,761,761,761,761,761,761,761,769,769,769,769,773,773,773,773,773,773,773,773,773,773,773,773,773,773,787,787,787,787,787,787,787,787,787,787,797,797,797,797,797,797,797,797,797,797,797,797,809,809,811,811,811,811,811,811,811,811,811,811,821,821,823,823,823,823,827,827,829,829,829,829,829,829,829,829,829,829,839,839,839,839,839,839,839,839,839,839,839,839,839,839,853,853,853,853,857,857,859,859,859,859,863,863,863,863,863,863,863,863,863,863,863,863,863,863,877,877,877,877,881,881,883,883,883,883,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,887,907,907,907,907,911,911,911,911,911,911,911,911,919,919,919,919,919,919,919,919,919,919,929,929,929,929,929,929,929,929,937,937,937,937,941,941,941,941,941,941,947,947,947,947,947,947,953,953,953,953,953,953,953,953,953,953,953,953,953,953,967,967,967,967,971,971,971,971,971,971,977,977,977,977,977,977,983,983,983,983,983,983,983,983,991,991,991,991,991,991,997,997,997]\\n    // copy-paste arr below gives 1-line code\\n    return nums.reduce((pre, cur) => cur - arr[cur - pre], 0) > 0\\n    // if not strictly increasing, cur - pre <= 0 and result will be NaN\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3350210,
                "title": "c-nearest-prime-less-than-but-greater-than-previous-number-in-nums",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isincreasing(vector<int>&arr){\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]>=arr[i+1]) return false;\\n        }\\n        return true;\\n    }\\n    bool isPrime(int n){\\n        if(n<=1) return false;\\n        \\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int nearest(int n, int get){\\n        int prime=0;\\n        for(int i=n-1;i>=2;i--){\\n            if(isPrime(i)){\\n                if(get==-1){\\n                    prime=i;\\n                    break;\\n                }\\n                else if(get!=-1 && n-i>get){\\n                    prime=i;\\n                    break;\\n                }\\n            }\\n        }\\n        return prime;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            int near = nearest(nums[i],i>0?nums[i-1]:-1);\\n            nums[i]-=near;\\n            if(isincreasing(nums)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isincreasing(vector<int>&arr){\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]>=arr[i+1]) return false;\\n        }\\n        return true;\\n    }\\n    bool isPrime(int n){\\n        if(n<=1) return false;\\n        \\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int nearest(int n, int get){\\n        int prime=0;\\n        for(int i=n-1;i>=2;i--){\\n            if(isPrime(i)){\\n                if(get==-1){\\n                    prime=i;\\n                    break;\\n                }\\n                else if(get!=-1 && n-i>get){\\n                    prime=i;\\n                    break;\\n                }\\n            }\\n        }\\n        return prime;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            int near = nearest(nums[i],i>0?nums[i-1]:-1);\\n            nums[i]-=near;\\n            if(isincreasing(nums)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349610,
                "title": "c-simple-and-commented",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n//     copy for now else generate in o(n^2)\\n    static const ll MAX=1005;\\n    bool prime[MAX];\\n    \\n    void sieve(){\\n        fill(prime, prime+MAX, true);\\n        prime[0] = prime[1] = false;\\n        \\n        for(ll i=2;i*i<MAX;i++){\\n            if(prime[i]){\\n                for(ll j=i*i;j<MAX;j+=i){\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n//         copied code to generate prime numbers and store it in peimes vector\\n        sieve();\\n        vector<int> primes; // 168 primes\\n        for(int i=2;i<=1000;i++){\\n            if(prime[i]) primes.push_back(i);\\n        }\\n        \\n        int n = nums.size();\\n//         generate sorted kind of vector to store values after opeartions\\n        vector<int> new_nums(n, -1);\\n//         last element no operation required\\n        new_nums[n-1] = nums[n-1];\\n//         start from second last\\n        for(int i=n-2;i>=0;i--){\\n//             for 4,9,6,10 6 is already <10 so continue\\n            if(nums[i] < new_nums[i+1]){\\n                new_nums[i] = nums[i];\\n                continue;\\n            }\\n//             else\\n            for(auto p : primes){\\n                if(p >= nums[i]){ \\n                    new_nums[i] = nums[i];\\n                    break;\\n                }                 \\n                if(nums[i]-p < new_nums[i+1]){\\n                    new_nums[i] = nums[i] - p;\\n                    break;\\n                }\\n            }\\n        }\\n//         strictly increasing condition check\\n        for(int i=1;i<n;i++)\\n            if(new_nums[i] <= new_nums[i-1]) return false;\\n        \\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n//     copy for now else generate in o(n^2)\\n    static const ll MAX=1005;\\n    bool prime[MAX];\\n    \\n    void sieve(){\\n        fill(prime, prime+MAX, true);\\n        prime[0] = prime[1] = false;\\n        \\n        for(ll i=2;i*i<MAX;i++){\\n            if(prime[i]){\\n                for(ll j=i*i;j<MAX;j+=i){\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n//         copied code to generate prime numbers and store it in peimes vector\\n        sieve();\\n        vector<int> primes; // 168 primes\\n        for(int i=2;i<=1000;i++){\\n            if(prime[i]) primes.push_back(i);\\n        }\\n        \\n        int n = nums.size();\\n//         generate sorted kind of vector to store values after opeartions\\n        vector<int> new_nums(n, -1);\\n//         last element no operation required\\n        new_nums[n-1] = nums[n-1];\\n//         start from second last\\n        for(int i=n-2;i>=0;i--){\\n//             for 4,9,6,10 6 is already <10 so continue\\n            if(nums[i] < new_nums[i+1]){\\n                new_nums[i] = nums[i];\\n                continue;\\n            }\\n//             else\\n            for(auto p : primes){\\n                if(p >= nums[i]){ \\n                    new_nums[i] = nums[i];\\n                    break;\\n                }                 \\n                if(nums[i]-p < new_nums[i+1]){\\n                    new_nums[i] = nums[i] - p;\\n                    break;\\n                }\\n            }\\n        }\\n//         strictly increasing condition check\\n        for(int i=1;i<n;i++)\\n            if(new_nums[i] <= new_nums[i-1]) return false;\\n        \\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349430,
                "title": "python3-short-solution-sieve-and-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse sieve algorithm for creating a list of prime no. upto 1000.\\nTraverse from back of the array and try to find a greatest number whose value is less or equal of ```nums[i] - nums[i + 1] + 1```. Eliminate the Cases in which the operation is not possible.\\n\\n# Complexity\\n- Time complexity: O(N(LogN))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        # Sieve of eratosthenes\\n        primes = [2]\\n        for i in range(2, 1001):\\n            c = 0\\n            for j in range(2, (int)(math.sqrt(i))+1):\\n                if i%j == 0: c+=1\\n            if c == 0: primes.append(i)\\n\\n        # Traversing from back and using binary search to find a suitable primes no. to subtract\\n        for i in range(len(nums) - 2, -1, -1):\\n            if nums[i] == 2 and nums[i + 1] <= 2: return False\\n            if nums[i] >= nums[i + 1]:\\n                n = nums[i] - nums[i + 1] + 1\\n                indx = bisect.bisect_left(primes, n)\\n                if indx >= len(primes): return False\\n                if primes[indx] >= nums[i]: return False\\n                nums[i]-=primes[indx]\\n                if nums[i] >= nums[i + 1]: return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```nums[i] - nums[i + 1] + 1```\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        # Sieve of eratosthenes\\n        primes = [2]\\n        for i in range(2, 1001):\\n            c = 0\\n            for j in range(2, (int)(math.sqrt(i))+1):\\n                if i%j == 0: c+=1\\n            if c == 0: primes.append(i)\\n\\n        # Traversing from back and using binary search to find a suitable primes no. to subtract\\n        for i in range(len(nums) - 2, -1, -1):\\n            if nums[i] == 2 and nums[i + 1] <= 2: return False\\n            if nums[i] >= nums[i + 1]:\\n                n = nums[i] - nums[i + 1] + 1\\n                indx = bisect.bisect_left(primes, n)\\n                if indx >= len(primes): return False\\n                if primes[indx] >= nums[i]: return False\\n                nums[i]-=primes[indx]\\n                if nums[i] >= nums[i + 1]: return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348524,
                "title": "c-solution-using-sieve-of-eratosthenis-and-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> sieve(int n) {\\n        int*arr = new int[n + 1](); \\n        vector<long long> vect; \\n        for (int i = 2; i <= n; i++) \\n        if(arr[i] == 0) {\\n            vect.push_back(i); \\n            for (int j = 2 * i; j <= n; j += i) arr[j] = 1;\\n        } \\n        return vect;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> primes = sieve(1000);\\n        for(int i=0;i<n;i++){\\n            if(i > 0 && nums[i] <= nums[i-1]) return false;\\n            if(i == 0){\\n                int ind = lower_bound(primes.begin(), primes.end(), nums[i])-primes.begin();\\n                while(primes[ind] >= nums[i] && ind > 0 || ind >= (int) primes.size()) ind--;\\n                if(ind >= 0 && primes[ind] < nums[i]) nums[i] -= primes[ind];\\n            }else{\\n                int ind = lower_bound(primes.begin(), primes.end(), nums[i]-nums[i-1])-primes.begin();\\n                while(primes[ind] >= nums[i]-nums[i-1] && ind > 0 || ind >= (int) primes.size()) ind--;\\n                if(ind >= 0 && primes[ind] < nums[i]-nums[i-1]) nums[i] -= primes[ind];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> sieve(int n) {\\n        int*arr = new int[n + 1](); \\n        vector<long long> vect; \\n        for (int i = 2; i <= n; i++) \\n        if(arr[i] == 0) {\\n            vect.push_back(i); \\n            for (int j = 2 * i; j <= n; j += i) arr[j] = 1;\\n        } \\n        return vect;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> primes = sieve(1000);\\n        for(int i=0;i<n;i++){\\n            if(i > 0 && nums[i] <= nums[i-1]) return false;\\n            if(i == 0){\\n                int ind = lower_bound(primes.begin(), primes.end(), nums[i])-primes.begin();\\n                while(primes[ind] >= nums[i] && ind > 0 || ind >= (int) primes.size()) ind--;\\n                if(ind >= 0 && primes[ind] < nums[i]) nums[i] -= primes[ind];\\n            }else{\\n                int ind = lower_bound(primes.begin(), primes.end(), nums[i]-nums[i-1])-primes.begin();\\n                while(primes[ind] >= nums[i]-nums[i-1] && ind > 0 || ind >= (int) primes.size()) ind--;\\n                if(ind >= 0 && primes[ind] < nums[i]-nums[i-1]) nums[i] -= primes[ind];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348490,
                "title": "easy-code-sieve-of-eratosthenes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sieve(vector<int>& prime,int n)\\n    {\\n        prime[0]=false;\\n        prime[1]=false;\\n\\n        for(int i=2;i*i<n;i++)\\n        {\\n            for(int j=2*i;j<n;j+=i)\\n            {\\n                prime[j]=false;\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> prime(1005,true);\\n        sieve(prime,1005);\\n        int n=nums.size();\\n        int prev=nums[n-1];\\n        bool flag=0,ans=true;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<prev)\\n            {\\n                prev=nums[i];\\n                continue;\\n            }\\n            flag=1;\\n            for(int j=0;j<nums[i];j++)\\n            {\\n                if(prime[j] && nums[i]-j<prev)\\n                {\\n                    prev=nums[i]-j;\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n            {\\n                ans=false;\\n                break;\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sieve(vector<int>& prime,int n)\\n    {\\n        prime[0]=false;\\n        prime[1]=false;\\n\\n        for(int i=2;i*i<n;i++)\\n        {\\n            for(int j=2*i;j<n;j+=i)\\n            {\\n                prime[j]=false;\\n            }\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> prime(1005,true);\\n        sieve(prime,1005);\\n        int n=nums.size();\\n        int prev=nums[n-1];\\n        bool flag=0,ans=true;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<prev)\\n            {\\n                prev=nums[i];\\n                continue;\\n            }\\n            flag=1;\\n            for(int j=0;j<nums[i];j++)\\n            {\\n                if(prime[j] && nums[i]-j<prev)\\n                {\\n                    prev=nums[i]-j;\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n            {\\n                ans=false;\\n                break;\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348473,
                "title": "easy-simple-solution-c-prime-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void pn(vector<int> &prime)\\n    {\\n        bool arr[1001]={false};\\n        for(int i=2;i<1000;i++)\\n        {\\n            if(!arr[i])\\n            {\\n                for(int j=i+1;j<1000;j++)\\n                {\\n                    if(j%i==0)\\n                    {\\n                        arr[j]=true;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=2;i<1000;i++)\\n        {\\n            if(!arr[i])\\n                prime.push_back(i);\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> prime;\\n        pn(prime);\\n        int t=0;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]>=nums[i+1])\\n            {\\n                for(int j=0;j<prime.size();j++)\\n                {\\n                    if(nums[i]-prime[j]<nums[i+1])\\n                    {\\n                        nums[i]=nums[i]-prime[j];\\n                        cout<<nums[i]<<\" \"<<i<<endl;\\n                        if(nums[i]<1 )\\n                        {\\n                            return false;\\n                        }\\n                        break;\\n                    }\\n                    if(j==prime.size()-1)\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void pn(vector<int> &prime)\\n    {\\n        bool arr[1001]={false};\\n        for(int i=2;i<1000;i++)\\n        {\\n            if(!arr[i])\\n            {\\n                for(int j=i+1;j<1000;j++)\\n                {\\n                    if(j%i==0)\\n                    {\\n                        arr[j]=true;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=2;i<1000;i++)\\n        {\\n            if(!arr[i])\\n                prime.push_back(i);\\n        }\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> prime;\\n        pn(prime);\\n        int t=0;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]>=nums[i+1])\\n            {\\n                for(int j=0;j<prime.size();j++)\\n                {\\n                    if(nums[i]-prime[j]<nums[i+1])\\n                    {\\n                        nums[i]=nums[i]-prime[j];\\n                        cout<<nums[i]<<\" \"<<i<<endl;\\n                        if(nums[i]<1 )\\n                        {\\n                            return false;\\n                        }\\n                        break;\\n                    }\\n                    if(j==prime.size()-1)\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3348218,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums):\\n        def gen_primes(n):\\n            ans = [False]*2 + [True]*(n-1)\\n\\n            for i in range(2,n+1):\\n                if ans[i]:\\n                    for j in range(i*2,n+1,i):\\n                        ans[j] = False\\n\\n            return [i for i in range(n) if ans[i]]\\n\\n        primes = gen_primes(1000)\\n\\n        def max_prime_less_than(k):\\n            if k < 3: return 0\\n            j = bisect.bisect_left(primes,k)\\n            return primes[j-1]\\n\\n        prev = nums[0] - max_prime_less_than(nums[0])\\n\\n        for i in range(1,len(nums)):\\n            if nums[i] <= prev: return False\\n            prev = nums[i] - max_prime_less_than(nums[i]-prev)\\n\\n        return True\\n\\n\\n\\n        \\n\\n\\n        \\n\\n            \\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums):\\n        def gen_primes(n):\\n            ans = [False]*2 + [True]*(n-1)\\n\\n            for i in range(2,n+1):\\n                if ans[i]:\\n                    for j in range(i*2,n+1,i):\\n                        ans[j] = False\\n\\n            return [i for i in range(n) if ans[i]]\\n\\n        primes = gen_primes(1000)\\n\\n        def max_prime_less_than(k):\\n            if k < 3: return 0\\n            j = bisect.bisect_left(primes,k)\\n            return primes[j-1]\\n\\n        prev = nums[0] - max_prime_less_than(nums[0])\\n\\n        for i in range(1,len(nums)):\\n            if nums[i] <= prev: return False\\n            prev = nums[i] - max_prime_less_than(nums[i]-prev)\\n\\n        return True\\n\\n\\n\\n        \\n\\n\\n        \\n\\n            \\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348175,
                "title": "c-faster-than-98-simplest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isprime(int n){\\n        if(n==1)\\n            return false;\\n        int i=2;\\n        while(i<=n/2){\\n            if(n%i==0)\\n                return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i+1]<=nums[i]){\\n                bool f=true;\\n                int x=nums[i]-nums[i+1]+1;\\n                while(x<nums[i]){\\n                    f=true;\\n                    if(isprime(x)){\\n                        nums[i]-=x;\\n                        f=false;\\n                        break;\\n                    }\\n                    else\\n                        x++;\\n                }\\n                if(f)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(int n){\\n        if(n==1)\\n            return false;\\n        int i=2;\\n        while(i<=n/2){\\n            if(n%i==0)\\n                return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i+1]<=nums[i]){\\n                bool f=true;\\n                int x=nums[i]-nums[i+1]+1;\\n                while(x<nums[i]){\\n                    f=true;\\n                    if(isprime(x)){\\n                        nums[i]-=x;\\n                        f=false;\\n                        break;\\n                    }\\n                    else\\n                        x++;\\n                }\\n                if(f)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348086,
                "title": "java-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor index in range [1, lastIndex], we try to subtract a prime that could be as large as possible. This way, those elements in the larger indicies can have more space, and more likely to form a smaller valid number.\\n\\nNote that we need to maintain a rule to find the large prime(int my if statement)\\n\\nNote that we can form a hashmap to do a memorization on the prime results\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^3)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```java\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int length = nums.length;\\n        int firstAfter = getAfter(nums[0], -1);\\n        if (firstAfter != -1) {\\n            nums[0] = firstAfter;\\n        }\\n\\n        for (int i = 1; i < length; i ++) {\\n            int after = getAfter(nums[i], nums[i - 1]);\\n            if (after != -1) {\\n                nums[i] = after;\\n            }\\n            if (nums[i - 1] >= nums[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n    \\n    private int getAfter(int cur, int prev) {\\n        // possible primes: [2, cur - 1]\\n        for (int i = cur - 1; i >= 2; i --) {\\n            // after subtraction:\\n            // prev < cur, cur -> as small as possible\\n            if (prev < cur - i && isPrime(i)) {\\n                // if i is prime and cur - i > prev, we return;\\n                return cur - i;    \\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private boolean isPrime(int n) {\\n        for (int i = 2; i < n; i ++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int length = nums.length;\\n        int firstAfter = getAfter(nums[0], -1);\\n        if (firstAfter != -1) {\\n            nums[0] = firstAfter;\\n        }\\n\\n        for (int i = 1; i < length; i ++) {\\n            int after = getAfter(nums[i], nums[i - 1]);\\n            if (after != -1) {\\n                nums[i] = after;\\n            }\\n            if (nums[i - 1] >= nums[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n    \\n    private int getAfter(int cur, int prev) {\\n        // possible primes: [2, cur - 1]\\n        for (int i = cur - 1; i >= 2; i --) {\\n            // after subtraction:\\n            // prev < cur, cur -> as small as possible\\n            if (prev < cur - i && isPrime(i)) {\\n                // if i is prime and cur - i > prev, we return;\\n                return cur - i;    \\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private boolean isPrime(int n) {\\n        for (int i = 2; i < n; i ++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347924,
                "title": "c-have-a-look-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:O(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int>v(10000,0);\\n          for(int i=2;i*i<=1001;++i)\\n          {\\n              if(v[i]==0)\\n              {\\n                  for(int j=i*i;j<=1001;j+=i)\\n                  {\\n                      v[j]=1;\\n                  }\\n              }\\n          }\\n        vector<int>p;\\n        for(int i=2;i<=1001;++i)\\n        {\\n            if(v[i]==0)\\n            {\\n                p.push_back(i);\\n            }\\n        }\\n        \\n        p.push_back(1009);\\n        vector<int>vis(nums.size(),0);\\n        for(int i=nums.size()-2;i>=0;--i)\\n        {\\n            int a=nums[i];\\n            int b=nums[i+1];\\n            if(a<b)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                 int index=upper_bound(p.begin(),p.end(),a-b)-p.begin();\\n                 nums[i]-=p[index];\\n                if(nums[i]<=0)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n     \\n   return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int>v(10000,0);\\n          for(int i=2;i*i<=1001;++i)\\n          {\\n              if(v[i]==0)\\n              {\\n                  for(int j=i*i;j<=1001;j+=i)\\n                  {\\n                      v[j]=1;\\n                  }\\n              }\\n          }\\n        vector<int>p;\\n        for(int i=2;i<=1001;++i)\\n        {\\n            if(v[i]==0)\\n            {\\n                p.push_back(i);\\n            }\\n        }\\n        \\n        p.push_back(1009);\\n        vector<int>vis(nums.size(),0);\\n        for(int i=nums.size()-2;i>=0;--i)\\n        {\\n            int a=nums[i];\\n            int b=nums[i+1];\\n            if(a<b)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                 int index=upper_bound(p.begin(),p.end(),a-b)-p.begin();\\n                 nums[i]-=p[index];\\n                if(nums[i]<=0)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n     \\n   return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347873,
                "title": "c-using-sieve-of-eratosthenes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   static const long long int max=1001;\\n   bool prime[max];\\n    void primes(){\\n\\n        fill(prime,prime+max,true);\\n        prime[0]=prime[1]=false;\\n\\n        for(long long i=2;i*i<max;i++){\\n            if(prime[i]){\\n                for(long long j=i*i;j<max;j=j+i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n\\n        primes();\\n        vector<int> sieves;\\n        for(int i=2;i<=1000;i++){\\n            if(prime[i])\\n            sieves.push_back(i);\\n        }\\n\\n        int n=nums.size();\\n        vector<int> arr(n,-1);\\n        arr[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n\\n            if(nums[i]<arr[i+1]){\\n                arr[i]=nums[i];\\n                continue;\\n            }\\n\\n            for(auto x:sieves){\\n                if(x>=nums[i]){\\n                    arr[i]=nums[i];\\n                    break;\\n                }\\n                if(nums[i]-x<arr[i+1]){\\n                    arr[i]=nums[i]-x;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            if(arr[i]<=arr[i-1]){\\n                return false;\\n            }\\n        }\\n        \\n         return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static const long long int max=1001;\\n   bool prime[max];\\n    void primes(){\\n\\n        fill(prime,prime+max,true);\\n        prime[0]=prime[1]=false;\\n\\n        for(long long i=2;i*i<max;i++){\\n            if(prime[i]){\\n                for(long long j=i*i;j<max;j=j+i){\\n                    prime[j]=false;\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        \\n\\n        primes();\\n        vector<int> sieves;\\n        for(int i=2;i<=1000;i++){\\n            if(prime[i])\\n            sieves.push_back(i);\\n        }\\n\\n        int n=nums.size();\\n        vector<int> arr(n,-1);\\n        arr[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n\\n            if(nums[i]<arr[i+1]){\\n                arr[i]=nums[i];\\n                continue;\\n            }\\n\\n            for(auto x:sieves){\\n                if(x>=nums[i]){\\n                    arr[i]=nums[i];\\n                    break;\\n                }\\n                if(nums[i]-x<arr[i+1]){\\n                    arr[i]=nums[i]-x;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            if(arr[i]<=arr[i-1]){\\n                return false;\\n            }\\n        }\\n        \\n         return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347712,
                "title": "sieve-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxEle = *max_element(begin(nums),end(nums));\\n        vector<int>arr (maxEle+1,1);\\n        for(int i = 2; i*i<=maxEle; i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                for(int j = i*2; j<=maxEle; j+=i)\\n                {\\n                    arr[j]=0;\\n                }\\n            }\\n        }\\n\\n        vector<int>prime;\\n\\n        for(int i = 2; i<=maxEle; i++)\\n        {\\n            if(arr[i]==1)\\n                prime.push_back(i);\\n        }\\n\\n        int prev = INT_MIN;\\n        for(int i = 0; i<n; i++)\\n        {\\n            int temp = nums[i];\\n            for(auto a:prime)\\n            {\\n                if(nums[i]<=a || nums[i]-a<=prev)\\n                    break;\\n                \\n                temp = nums[i]-a;\\n            }\\n            if(prev>=temp)\\n                return false;\\n\\n            prev = temp;\\n            nums[i] = temp;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxEle = *max_element(begin(nums),end(nums));\\n        vector<int>arr (maxEle+1,1);\\n        for(int i = 2; i*i<=maxEle; i++)\\n        {\\n            if(arr[i]==1)\\n            {\\n                for(int j = i*2; j<=maxEle; j+=i)\\n                {\\n                    arr[j]=0;\\n                }\\n            }\\n        }\\n\\n        vector<int>prime;\\n\\n        for(int i = 2; i<=maxEle; i++)\\n        {\\n            if(arr[i]==1)\\n                prime.push_back(i);\\n        }\\n\\n        int prev = INT_MIN;\\n        for(int i = 0; i<n; i++)\\n        {\\n            int temp = nums[i];\\n            for(auto a:prime)\\n            {\\n                if(nums[i]<=a || nums[i]-a<=prev)\\n                    break;\\n                \\n                temp = nums[i]-a;\\n            }\\n            if(prev>=temp)\\n                return false;\\n\\n            prev = temp;\\n            nums[i] = temp;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347660,
                "title": "sieve-of-eratosthenes-image-explanation-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/6c397399-4050-49b1-9e48-5505e83fff1e_1679921648.206922.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private List<Integer> sieve(int num){\\n        boolean[] isNotPrime = new boolean[num+1];\\n        List<Integer> primes = new ArrayList<Integer>();\\n        for(int i = 2;i*i<=num;i++){\\n            if(!isNotPrime[i]){\\n                //it is prime\\n                for(int j = i*2;j<=num;j+=i){\\n                    //starts from next multiple\\n                    //moves by doing +i\\n                    isNotPrime[j] = true;\\n                }\\n            }\\n        }\\n        for(int i = 2;i<isNotPrime.length;i++){\\n            if(!isNotPrime[i]){\\n                primes.add(i);\\n            }\\n        }\\n        return primes;\\n\\n    }\\n    public boolean primeSubOperation(int[] nums) {\\n\\n        int n = nums.length;\\n        for(int i = 0;i<n;i++){\\n            if(nums[i]==1 && i==0){\\n                //first element and element is 1,can not substract\\n                continue;\\n            }\\n            if(nums[i]==1 && i!=0){\\n                //1 appears in between some index\\n                // we wont be able to reduce the prev element less than 1\\n                //as we are always picking prime< arr[i] so at min\\n                //the diff will be 1 only, (ex: prime=13, nums[i]=14)\\n                return false;\\n            }\\n            //reduce by 1 to get values lesser than nums[i]\\n            List<Integer> prime  = sieve(nums[i]-1);\\n            //adding zero so that we dont get nullpointer for\\n            //any empty prime arr (dry run: nums: [2,2])\\n            prime.add(0);\\n            prime.sort((a,b)-> b-a); // decending sort so get the max first\\n            \\n            if(i==0){\\n                //if first element reduce as much as possible\\n                nums[i] -= prime.get(0);\\n                continue;\\n            }\\n            //this part for i==1\\n            for(int j = 0;j<prime.size();j++){\\n                int p = prime.get(j);\\n                int modifiedVal = nums[i] - p;\\n                //if(substracted value is greater than prev arr element)\\n                if(modifiedVal>nums[i-1]){\\n                    //update the arr element\\n                    nums[i] = modifiedVal;\\n                    break;//we dont need to check for smaller values\\n                }else if(modifiedVal<=nums[i-1] && j==prime.size()-1){\\n                    //at the last prime(min possible) and still does not satisfy\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Brainteaser",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    private List<Integer> sieve(int num){\\n        boolean[] isNotPrime = new boolean[num+1];\\n        List<Integer> primes = new ArrayList<Integer>();\\n        for(int i = 2;i*i<=num;i++){\\n            if(!isNotPrime[i]){\\n                //it is prime\\n                for(int j = i*2;j<=num;j+=i){\\n                    //starts from next multiple\\n                    //moves by doing +i\\n                    isNotPrime[j] = true;\\n                }\\n            }\\n        }\\n        for(int i = 2;i<isNotPrime.length;i++){\\n            if(!isNotPrime[i]){\\n                primes.add(i);\\n            }\\n        }\\n        return primes;\\n\\n    }\\n    public boolean primeSubOperation(int[] nums) {\\n\\n        int n = nums.length;\\n        for(int i = 0;i<n;i++){\\n            if(nums[i]==1 && i==0){\\n                //first element and element is 1,can not substract\\n                continue;\\n            }\\n            if(nums[i]==1 && i!=0){\\n                //1 appears in between some index\\n                // we wont be able to reduce the prev element less than 1\\n                //as we are always picking prime< arr[i] so at min\\n                //the diff will be 1 only, (ex: prime=13, nums[i]=14)\\n                return false;\\n            }\\n            //reduce by 1 to get values lesser than nums[i]\\n            List<Integer> prime  = sieve(nums[i]-1);\\n            //adding zero so that we dont get nullpointer for\\n            //any empty prime arr (dry run: nums: [2,2])\\n            prime.add(0);\\n            prime.sort((a,b)-> b-a); // decending sort so get the max first\\n            \\n            if(i==0){\\n                //if first element reduce as much as possible\\n                nums[i] -= prime.get(0);\\n                continue;\\n            }\\n            //this part for i==1\\n            for(int j = 0;j<prime.size();j++){\\n                int p = prime.get(j);\\n                int modifiedVal = nums[i] - p;\\n                //if(substracted value is greater than prev arr element)\\n                if(modifiedVal>nums[i-1]){\\n                    //update the arr element\\n                    nums[i] = modifiedVal;\\n                    break;//we dont need to check for smaller values\\n                }else if(modifiedVal<=nums[i-1] && j==prime.size()-1){\\n                    //at the last prime(min possible) and still does not satisfy\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347652,
                "title": "c-easy-solution-dp-memoization-sieve-of-eratosthenis-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //TC=O(n*n*m) where m=temp.size()\\n    //sc=o(n*n)+O(m)+O(l) m=temp.size() l=size of prime vector \\n    int dp[1001][1002];\\n    //put all prime number int this vector  that less than and equal to 1000\\n    vector<int> temp;\\n    //Created Sieve of size 1000\\n    void seive_algo(vector<bool>& prime,int n){\\n        prime[0]=false;\\n        prime[1]=false;\\n        for (int p = 2; p * p <= n; p++) {           \\n            if (prime[p] == true) {                \\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }  \\n    }\\n    bool find(int i,int lo,vector<int>& nums,int n,vector<bool>& prime){       \\n        if(i==n){            \\n            return true;\\n        }\\n        if(dp[i][lo+1]!=-1){\\n            return dp[i][lo+1];\\n        }\\n        bool flag=false;\\n        //if current index is not picked\\n        if(nums[i]>lo){           \\n            flag|=find(i+1,nums[i],nums,n,prime);\\n        }\\n        //if current index is picked\\n        for(int j=0;j<temp.size();j++){\\n            if(temp[j]<nums[i]){\\n                if((nums[i]-temp[j])>lo){\\n                    flag|=find(i+1,nums[i]-temp[j],nums,n,prime);\\n                }\\n            }else{\\n                break;\\n            }\\n        }      \\n        return dp[i][lo+1]=flag;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        temp.clear();\\n        memset(dp,-1,sizeof(dp));\\n        vector<bool> prime(1005, true);\\n        //created seive of size 1000\\n        seive_algo(prime, 1004);\\n        for(int i=0;i<1001;i++){\\n            if(prime[i]){\\n                temp.push_back(i);\\n            }\\n        }\\n        int n=nums.size();       \\n        return find(0,-1,nums,n,prime);\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //TC=O(n*n*m) where m=temp.size()\\n    //sc=o(n*n)+O(m)+O(l) m=temp.size() l=size of prime vector \\n    int dp[1001][1002];\\n    //put all prime number int this vector  that less than and equal to 1000\\n    vector<int> temp;\\n    //Created Sieve of size 1000\\n    void seive_algo(vector<bool>& prime,int n){\\n        prime[0]=false;\\n        prime[1]=false;\\n        for (int p = 2; p * p <= n; p++) {           \\n            if (prime[p] == true) {                \\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }  \\n    }\\n    bool find(int i,int lo,vector<int>& nums,int n,vector<bool>& prime){       \\n        if(i==n){            \\n            return true;\\n        }\\n        if(dp[i][lo+1]!=-1){\\n            return dp[i][lo+1];\\n        }\\n        bool flag=false;\\n        //if current index is not picked\\n        if(nums[i]>lo){           \\n            flag|=find(i+1,nums[i],nums,n,prime);\\n        }\\n        //if current index is picked\\n        for(int j=0;j<temp.size();j++){\\n            if(temp[j]<nums[i]){\\n                if((nums[i]-temp[j])>lo){\\n                    flag|=find(i+1,nums[i]-temp[j],nums,n,prime);\\n                }\\n            }else{\\n                break;\\n            }\\n        }      \\n        return dp[i][lo+1]=flag;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        temp.clear();\\n        memset(dp,-1,sizeof(dp));\\n        vector<bool> prime(1005, true);\\n        //created seive of size 1000\\n        seive_algo(prime, 1004);\\n        for(int i=0;i<1001;i++){\\n            if(prime[i]){\\n                temp.push_back(i);\\n            }\\n        }\\n        int n=nums.size();       \\n        return find(0,-1,nums,n,prime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347231,
                "title": "sieve-of-eratosthenes-algorithm-with-little-intution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<bool> v(1001,true);\\n        v[0] = false;\\n        v[1] = false;\\n        for(int i=2;i*i<=1000;i++){\\n            if(v[i]){\\n                for(int j=2*i;j<=1000;j+=i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<v.size();i++){\\n        //     if(v[i]){\\n        //         cout<<i<<\" \";\\n        //     }\\n        // }\\n        int i = nums[0]-1;\\n        while(i>=0 && v[i]==false){\\n            i--;\\n        }\\n        if(i!=-1)\\n        nums[0] -= i; \\n        // cout<<nums[0]<<\" \";\\n        for(int i=1;i<nums.size();i++){\\n            int x = nums[i]-nums[i-1]-1;\\n            while(x>=0 && v[x]==false){\\n                x--;\\n            }\\n            if(x>-1){\\n                nums[i] = nums[i] - x;\\n            }\\n            if(nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<bool> v(1001,true);\\n        v[0] = false;\\n        v[1] = false;\\n        for(int i=2;i*i<=1000;i++){\\n            if(v[i]){\\n                for(int j=2*i;j<=1000;j+=i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<v.size();i++){\\n        //     if(v[i]){\\n        //         cout<<i<<\" \";\\n        //     }\\n        // }\\n        int i = nums[0]-1;\\n        while(i>=0 && v[i]==false){\\n            i--;\\n        }\\n        if(i!=-1)\\n        nums[0] -= i; \\n        // cout<<nums[0]<<\" \";\\n        for(int i=1;i<nums.size();i++){\\n            int x = nums[i]-nums[i-1]-1;\\n            while(x>=0 && v[x]==false){\\n                x--;\\n            }\\n            if(x>-1){\\n                nums[i] = nums[i] - x;\\n            }\\n            if(nums[i]<=nums[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3346971,
                "title": "golang-3-ms-4-8-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nvar primes = [...]int16{\\n\\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\\n\\t73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\\n\\t179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\\n\\t283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\\n\\t419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\\n\\t547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\\n\\t661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\\n\\t811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\\n\\t947, 953, 967, 971, 977, 983, 991, 997, 1009,\\n}\\n\\nfunc primeSubOperation(nums []int) bool {\\n\\tprev := int16(nums[len(nums)-1])\\n\\tfor i := len(nums) - 2; i >= 0; i-- {\\n\\t\\tcur := int16(nums[i])\\n\\t\\tif cur >= prev {\\n\\t\\t\\tminPrime := cur - prev + 1\\n\\t\\t\\tidx := sort.Search(len(primes), func(i int) bool {\\n\\t\\t\\t\\treturn primes[i] >= minPrime\\n\\t\\t\\t})\\n\\t\\t\\tif cur <= primes[idx] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t\\tcur -= primes[idx]\\n\\t\\t}\\n\\t\\tprev = cur\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar primes = [...]int16{\\n\\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\\n\\t73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\\n\\t179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\\n\\t283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\\n\\t419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\\n\\t547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\\n\\t661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\\n\\t811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\\n\\t947, 953, 967, 971, 977, 983, 991, 997, 1009,\\n}\\n\\nfunc primeSubOperation(nums []int) bool {\\n\\tprev := int16(nums[len(nums)-1])\\n\\tfor i := len(nums) - 2; i >= 0; i-- {\\n\\t\\tcur := int16(nums[i])\\n\\t\\tif cur >= prev {\\n\\t\\t\\tminPrime := cur - prev + 1\\n\\t\\t\\tidx := sort.Search(len(primes), func(i int) bool {\\n\\t\\t\\t\\treturn primes[i] >= minPrime\\n\\t\\t\\t})\\n\\t\\t\\tif cur <= primes[idx] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t\\tcur -= primes[idx]\\n\\t\\t}\\n\\t\\tprev = cur\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3346787,
                "title": "simple-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1000)+O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fpn(int n,vector<int>&pn){\\n        for(int i=0;i<pn.size();i++){\\n            if(pn[i]>n)return i-1;\\n        }\\n        return pn.size()-1;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int>pn;\\n        for(int i=2;i<=1000;i++){\\n            bool flag=0;\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){flag=1;break;}\\n            }\\n            if(!flag)pn.push_back(i);\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int k=fpn(nums[i],pn);\\n            if(k==-1)continue;\\n            else{\\n                if(i==0)\\n                {\\n                    while(k>=0){ \\n                            if(nums[0]-pn[k]>0){\\n                                nums[0]=nums[0]-pn[k];break;\\n                            }\\n                            k--;\\n                        }\\n                }\\n                else{\\n                    if(nums[i]-pn[k]>nums[i-1])nums[i]=nums[i]-pn[k];\\n                    else{\\n                        while(k>=0){\\n                            if(nums[i]-pn[k]>nums[i-1]){nums[i]=nums[i]-pn[k];break;}\\n                            k--;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<=nums[i-1])return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fpn(int n,vector<int>&pn){\\n        for(int i=0;i<pn.size();i++){\\n            if(pn[i]>n)return i-1;\\n        }\\n        return pn.size()-1;\\n    }\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int>pn;\\n        for(int i=2;i<=1000;i++){\\n            bool flag=0;\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){flag=1;break;}\\n            }\\n            if(!flag)pn.push_back(i);\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int k=fpn(nums[i],pn);\\n            if(k==-1)continue;\\n            else{\\n                if(i==0)\\n                {\\n                    while(k>=0){ \\n                            if(nums[0]-pn[k]>0){\\n                                nums[0]=nums[0]-pn[k];break;\\n                            }\\n                            k--;\\n                        }\\n                }\\n                else{\\n                    if(nums[i]-pn[k]>nums[i-1])nums[i]=nums[i]-pn[k];\\n                    else{\\n                        while(k>=0){\\n                            if(nums[i]-pn[k]>nums[i-1]){nums[i]=nums[i]-pn[k];break;}\\n                            k--;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<=nums[i-1])return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346766,
                "title": "using-binary-search-sieve-of-eratosthenes-o-n-log-n",
                "content": "# Intuition\\n[Approach is Kind of Greedy + BinarySearch + Sieve Of Eratosthenes Algo for Primes]\\n\\n        + Pick any ith indexed element and subtract the largest prime number P such that it\\'s\\n           P < nums[i] and (nums[i] - P) > nums[i - 1].\\n           \\n           This way it\\'s maximize the chances of options for next indices (i + 1, i + 2, .... )\\n\\n# Complexity\\n- Time complexity:\\n- O(N * log(log(N))) + O(N * log(N))\\n-       Pre-precessing + Making the array strictly increasing.\\n- Space complexity:\\n- O(size_of_prime_list)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    private static final int MAX_NUM = 1000;\\n    private static final boolean[] isPrime;\\n    private static final List<Integer> primeList;\\n\\n    static {\\n        primeList = new ArrayList<>();\\n        isPrime = new boolean[MAX_NUM + 1];\\n        Arrays.fill(isPrime, true);\\n        isPrime[0] = false; isPrime[1] = false;\\n        for(int i = 2; i * i <= MAX_NUM; i += 1) {\\n            if(isPrime[i]) {\\n                for(int j = i * i; j <= MAX_NUM; j += i) {\\n                    isPrime[j] = false;\\n                } \\n            }\\n        }\\n        \\n        for(int i = 0; i <= MAX_NUM; i += 1) {\\n            if(isPrime[i])\\n                primeList.add(i);\\n        }\\n        \\n    }    \\n    \\n    // Binary Search to find out valid \"P\"\\'s index in \"primeList\" as we\\'ve discussed on \"Intuition\" part.\\n    private int primeIndex(int eleAtIdx, int previousPlacedItem) {\\n        int left = 0, right = primeList.size() - 1;\\n        int primeIndex = -1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int primeAtMid = primeList.get(mid);\\n            if(primeAtMid < eleAtIdx && (eleAtIdx - primeAtMid) > previousPlacedItem) {\\n                primeIndex = mid; // one valid candidate\\n                left = mid + 1; // look for more optimcal in the right part of \"mid\"\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return primeIndex;\\n    }\\n    \\n    private boolean isStrictlyIncreasing(int[] nums) {\\n        for(int i = 1; i < nums.length; i += 1) {\\n            if(nums[i] <= nums[i - 1]) return false;\\n        }\\n        return true;\\n    }\\n   \\n    public boolean primeSubOperation(int[] nums) {\\n        if(isStrictlyIncreasing(nums)) return true;\\n        \\n        int previousPlacedItem = 0; // assume 0 is placed at the beginning\\n        \\n        for(int i = 0; i < nums.length; i += 1) {\\n            int eleAtIdx = nums[i];\\n            int primeIdx = primeIndex(eleAtIdx, previousPlacedItem);\\n            if(primeIdx == -1) {\\n                if(eleAtIdx > previousPlacedItem) {\\n                    previousPlacedItem = eleAtIdx;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                nums[i] -= primeList.get(primeIdx);\\n                previousPlacedItem = nums[i];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private static final int MAX_NUM = 1000;\\n    private static final boolean[] isPrime;\\n    private static final List<Integer> primeList;\\n\\n    static {\\n        primeList = new ArrayList<>();\\n        isPrime = new boolean[MAX_NUM + 1];\\n        Arrays.fill(isPrime, true);\\n        isPrime[0] = false; isPrime[1] = false;\\n        for(int i = 2; i * i <= MAX_NUM; i += 1) {\\n            if(isPrime[i]) {\\n                for(int j = i * i; j <= MAX_NUM; j += i) {\\n                    isPrime[j] = false;\\n                } \\n            }\\n        }\\n        \\n        for(int i = 0; i <= MAX_NUM; i += 1) {\\n            if(isPrime[i])\\n                primeList.add(i);\\n        }\\n        \\n    }    \\n    \\n    // Binary Search to find out valid \"P\"\\'s index in \"primeList\" as we\\'ve discussed on \"Intuition\" part.\\n    private int primeIndex(int eleAtIdx, int previousPlacedItem) {\\n        int left = 0, right = primeList.size() - 1;\\n        int primeIndex = -1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int primeAtMid = primeList.get(mid);\\n            if(primeAtMid < eleAtIdx && (eleAtIdx - primeAtMid) > previousPlacedItem) {\\n                primeIndex = mid; // one valid candidate\\n                left = mid + 1; // look for more optimcal in the right part of \"mid\"\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return primeIndex;\\n    }\\n    \\n    private boolean isStrictlyIncreasing(int[] nums) {\\n        for(int i = 1; i < nums.length; i += 1) {\\n            if(nums[i] <= nums[i - 1]) return false;\\n        }\\n        return true;\\n    }\\n   \\n    public boolean primeSubOperation(int[] nums) {\\n        if(isStrictlyIncreasing(nums)) return true;\\n        \\n        int previousPlacedItem = 0; // assume 0 is placed at the beginning\\n        \\n        for(int i = 0; i < nums.length; i += 1) {\\n            int eleAtIdx = nums[i];\\n            int primeIdx = primeIndex(eleAtIdx, previousPlacedItem);\\n            if(primeIdx == -1) {\\n                if(eleAtIdx > previousPlacedItem) {\\n                    previousPlacedItem = eleAtIdx;\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                nums[i] -= primeList.get(primeIdx);\\n                previousPlacedItem = nums[i];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346626,
                "title": "c-sieve-of-eratosthenes-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Find All Primes that are less than the given **constraint 1000** using **Sieve of eratosthenes**\\n2. now take all the prime numbers into a separate array called **primes**\\n3. maintain a prev variable to keep check of the previous element\\n4. iterate the nums array in reverse fashing from the (n-2)th element.\\n5. if( current_ele > prev)\\n      then **substract it with a suitable prime number** lesser than it     by iterating the primes array.\\n      make **falg = 0** and break from the for loop.\\n6. if flag == 0  then **return true**\\n7. else **return false;**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void sieve(vector<int>&isPrime, int n){\\n        isPrime[0] = isPrime[1] = 0;\\n\\n        for(int i=2; i*i<n;i++){\\n            for(int j = i*2; j<n;j+=i){\\n                isPrime[j] = 0;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>isPrime(1005,1);\\n\\n        sieve(isPrime,1005);\\n\\n        vector<int>primes;\\n        for(int i=0;i<1005;i++){\\n            if(isPrime[i]){\\n                primes.push_back(i);\\n            }\\n        }\\n\\n        int prev = nums[n-1];\\n        int flag = 0;\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < prev){\\n                prev = nums[i];\\n                continue;\\n            }\\n            flag = 1;\\n            for(int ind=0;ind<primes.size() && primes[ind]<nums[i];ind++){\\n                if(nums[i]-primes[ind] < prev){\\n                    prev = nums[i]-primes[ind];\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                break;\\n            }\\n        }\\n\\n        return !flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void sieve(vector<int>&isPrime, int n){\\n        isPrime[0] = isPrime[1] = 0;\\n\\n        for(int i=2; i*i<n;i++){\\n            for(int j = i*2; j<n;j+=i){\\n                isPrime[j] = 0;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>isPrime(1005,1);\\n\\n        sieve(isPrime,1005);\\n\\n        vector<int>primes;\\n        for(int i=0;i<1005;i++){\\n            if(isPrime[i]){\\n                primes.push_back(i);\\n            }\\n        }\\n\\n        int prev = nums[n-1];\\n        int flag = 0;\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < prev){\\n                prev = nums[i];\\n                continue;\\n            }\\n            flag = 1;\\n            for(int ind=0;ind<primes.size() && primes[ind]<nums[i];ind++){\\n                if(nums[i]-primes[ind] < prev){\\n                    prev = nums[i]-primes[ind];\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                break;\\n            }\\n        }\\n\\n        return !flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346153,
                "title": "java-prime-seive-method-greedy",
                "content": "# Intuition\\nGenerate sequence of lowest possible elements greater than the previous element\\n\\n# Code\\n```\\nclass Solution {\\n\\n    TreeMap<Integer, Boolean> primeNumbers = new TreeMap<>();\\n\\n    public void primeSieve(int n) {\\n        BitSet bitset = new BitSet(n + 1);\\n        for (long i = 0; i < n; i++) {\\n            if (i == 0 || i == 1) {\\n                bitset.set((int) i);\\n                continue;\\n            }\\n            if (bitset.get((int) i)) continue;\\n            primeNumbers.put((int) i, true);\\n            for (long j = i; j <= n; j += i)\\n                bitset.set((int) j);\\n        }\\n    }\\n\\n    public boolean primeSubOperation(int[] nums) {\\n        primeSieve(1000);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (primeNumbers.firstKey() >= nums[i]) continue;\\n            int prime = primeNumbers.lowerKey(nums[i]);\\n            if (i == 0) {\\n                nums[i] -= prime;\\n                continue;\\n            }\\n\\n            while (nums[i - 1] >= (nums[i] - prime)) {\\n                if (primeNumbers.firstKey() >= prime) break;\\n                prime = primeNumbers.lowerKey(prime);\\n            }\\n\\n            if (nums[i - 1] < (nums[i] - prime)) nums[i] -= prime;\\n        }\\n\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == 0) continue;\\n            if (nums[i - 1] >= nums[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    TreeMap<Integer, Boolean> primeNumbers = new TreeMap<>();\\n\\n    public void primeSieve(int n) {\\n        BitSet bitset = new BitSet(n + 1);\\n        for (long i = 0; i < n; i++) {\\n            if (i == 0 || i == 1) {\\n                bitset.set((int) i);\\n                continue;\\n            }\\n            if (bitset.get((int) i)) continue;\\n            primeNumbers.put((int) i, true);\\n            for (long j = i; j <= n; j += i)\\n                bitset.set((int) j);\\n        }\\n    }\\n\\n    public boolean primeSubOperation(int[] nums) {\\n        primeSieve(1000);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (primeNumbers.firstKey() >= nums[i]) continue;\\n            int prime = primeNumbers.lowerKey(nums[i]);\\n            if (i == 0) {\\n                nums[i] -= prime;\\n                continue;\\n            }\\n\\n            while (nums[i - 1] >= (nums[i] - prime)) {\\n                if (primeNumbers.firstKey() >= prime) break;\\n                prime = primeNumbers.lowerKey(prime);\\n            }\\n\\n            if (nums[i - 1] < (nums[i] - prime)) nums[i] -= prime;\\n        }\\n\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == 0) continue;\\n            if (nums[i - 1] >= nums[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346003,
                "title": "c-binary-search-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCollect all primes numbers upto 1000. Start binary search over them to minimize each value of nums array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n\\n# Complexity\\n- Time complexity: O(nlog(m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   int primes[1001];\\n    \\n    void checkPrimes(){\\n        for(int i=2;i<=1000;i++){\\n            if(primes[i]==0) continue;\\n            for(int j=2*i;j<=1000;j+=i){\\n                primes[j]=0;\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=2;i<=1000;i++) primes[i]=1;\\n        checkPrimes();\\n        vector<int> ar;\\n        for(int i=2;i<=1000;i++){\\n            if(primes[i]==1) ar.push_back(i);\\n        }\\n        for(int k=0;k<nums.size();k++){\\n            int i=0,j=ar.size()-1;\\n            int a=nums[k];\\n            while(i<=j){\\n                int mid=(i+j)/2;\\n                if(ar[mid]>=nums[k]) j=mid-1;\\n                else{\\n                    int d=nums[k]-ar[mid];\\n                    if((k-1)<0){\\n                        a=min(a,d);\\n                        i=mid+1;\\n                    }\\n                    else{\\n                        if(d<=nums[k-1]) j=mid-1;\\n                        else{\\n                            a=min(a,d);\\n                            i=mid+1;\\n                        }\\n                    }\\n                }\\n            }\\n            nums[k]=a;\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<=nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   int primes[1001];\\n    \\n    void checkPrimes(){\\n        for(int i=2;i<=1000;i++){\\n            if(primes[i]==0) continue;\\n            for(int j=2*i;j<=1000;j+=i){\\n                primes[j]=0;\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        for(int i=2;i<=1000;i++) primes[i]=1;\\n        checkPrimes();\\n        vector<int> ar;\\n        for(int i=2;i<=1000;i++){\\n            if(primes[i]==1) ar.push_back(i);\\n        }\\n        for(int k=0;k<nums.size();k++){\\n            int i=0,j=ar.size()-1;\\n            int a=nums[k];\\n            while(i<=j){\\n                int mid=(i+j)/2;\\n                if(ar[mid]>=nums[k]) j=mid-1;\\n                else{\\n                    int d=nums[k]-ar[mid];\\n                    if((k-1)<0){\\n                        a=min(a,d);\\n                        i=mid+1;\\n                    }\\n                    else{\\n                        if(d<=nums[k-1]) j=mid-1;\\n                        else{\\n                            a=min(a,d);\\n                            i=mid+1;\\n                        }\\n                    }\\n                }\\n            }\\n            nums[k]=a;\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<=nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345944,
                "title": "python-greedy-method-to-build-an-increasing-array",
                "content": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        # step 1, find all the prime numbers less than 1000\\n        self.prime = [True] * 1001\\n        self.prime[0] = self.prime[1] = False\\n\\n        i = 2\\n        while i * i < 1001:\\n            if self.prime:\\n                for j in range(i * i, 1001, i):\\n                    self.prime[j] = False\\n            i += 1\\n\\n        self.prime_list = []\\n        for i in range(1001):\\n            if self.prime[i]:\\n                self.prime_list.append(i)\\n\\n        # Step 2: find the ranges that we need to apply operations\\n        last_idx, i = 0, 0\\n        while i < len(nums) - 1:\\n            if nums[i] >= nums[i + 1]:\\n                # we process all the numbers from last_idx to i, and make the list increasing\\n                for j in range(last_idx, i + 1):\\n                    if last_idx == 0:\\n                        diff = nums[0]\\n                    else:\\n                        diff = nums[last_idx] - nums[last_idx - 1]\\n                    t_pidx = self.find_prime(diff)\\n                    prime = 0\\n                    if t_pidx >= 0:\\n                        prime = self.prime_list[t_pidx]\\n                    if prime >= diff:\\n                        return False\\n                    nums[last_idx] -= prime\\n                    last_idx += 1\\n                if nums[last_idx - 1] >= nums[i + 1]:\\n                    return False\\n            i += 1\\n        return True\\n\\n    def find_prime(self, l):\\n        s, e = 0, len(self.prime_list) - 1\\n        while s < e:\\n            m = (s + e) // 2\\n            if self.prime_list[m] >= l:\\n                e = m - 1\\n            else:\\n                s = m + 1\\n\\n        while s >= 0 and self.prime_list[s] >= l:\\n            s -= 1\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        # step 1, find all the prime numbers less than 1000\\n        self.prime = [True] * 1001\\n        self.prime[0] = self.prime[1] = False\\n\\n        i = 2\\n        while i * i < 1001:\\n            if self.prime:\\n                for j in range(i * i, 1001, i):\\n                    self.prime[j] = False\\n            i += 1\\n\\n        self.prime_list = []\\n        for i in range(1001):\\n            if self.prime[i]:\\n                self.prime_list.append(i)\\n\\n        # Step 2: find the ranges that we need to apply operations\\n        last_idx, i = 0, 0\\n        while i < len(nums) - 1:\\n            if nums[i] >= nums[i + 1]:\\n                # we process all the numbers from last_idx to i, and make the list increasing\\n                for j in range(last_idx, i + 1):\\n                    if last_idx == 0:\\n                        diff = nums[0]\\n                    else:\\n                        diff = nums[last_idx] - nums[last_idx - 1]\\n                    t_pidx = self.find_prime(diff)\\n                    prime = 0\\n                    if t_pidx >= 0:\\n                        prime = self.prime_list[t_pidx]\\n                    if prime >= diff:\\n                        return False\\n                    nums[last_idx] -= prime\\n                    last_idx += 1\\n                if nums[last_idx - 1] >= nums[i + 1]:\\n                    return False\\n            i += 1\\n        return True\\n\\n    def find_prime(self, l):\\n        s, e = 0, len(self.prime_list) - 1\\n        while s < e:\\n            m = (s + e) // 2\\n            if self.prime_list[m] >= l:\\n                e = m - 1\\n            else:\\n                s = m + 1\\n\\n        while s >= 0 and self.prime_list[s] >= l:\\n            s -= 1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345920,
                "title": "python-greedly",
                "content": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        ps=[True for i in range(1,10001)]\\n        ps[0]=False\\n        ps[1]=False\\n        i=2\\n        while i**2<1000:\\n            if not ps[i]:\\n                i+=1\\n                continue\\n            for j in range(i*i,1000,i):ps[j]=False\\n            i+=1\\n        for i in range(len(nums)):\\n            wi=[]\\n            for j in range(len(ps)):\\n                if j>=nums[i]:break\\n                if ps[j]:wi.append(j)\\n            if wi:\\n                tx=-1\\n                if i>0:\\n                    for x in wi:\\n                        if (nums[i]-x)>nums[i-1]:tx=x\\n                elif i==0 and wi:tx=wi[-1]\\n                if tx>-1:nums[i]-=tx\\n        for i in range(1,len(nums)):\\n            if nums[i]<=nums[i-1]:return False\\n                \\n        return True\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        ps=[True for i in range(1,10001)]\\n        ps[0]=False\\n        ps[1]=False\\n        i=2\\n        while i**2<1000:\\n            if not ps[i]:\\n                i+=1\\n                continue\\n            for j in range(i*i,1000,i):ps[j]=False\\n            i+=1\\n        for i in range(len(nums)):\\n            wi=[]\\n            for j in range(len(ps)):\\n                if j>=nums[i]:break\\n                if ps[j]:wi.append(j)\\n            if wi:\\n                tx=-1\\n                if i>0:\\n                    for x in wi:\\n                        if (nums[i]-x)>nums[i-1]:tx=x\\n                elif i==0 and wi:tx=wi[-1]\\n                if tx>-1:nums[i]-=tx\\n        for i in range(1,len(nums)):\\n            if nums[i]<=nums[i-1]:return False\\n                \\n        return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345726,
                "title": "java-solution-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    /*\\n        if we start to iterate from the left and encounter a situation where nums[i]<=nums[i-1]\\n        then we can only decrease the previous number\\n        there is no guarantee than on decreasing the previous number , the nums[n-2] would be less than nums[i-1] .\\n        \\n        But if we start to iterate from the right and encounter a situation where nums[i]<=nums[i-1]\\n        Then in this case we can decrease nums[i-1]\\n        This wont disturb the ascending order of elements after nums[i] .\\n        \\n        so if nums[i-1]>=nums[i] \\n        we need to find a prime such that :\\n        \\n        nums[i-1]-prime < nums[i]\\n        \\n        and we need the smallest prime in this case (greedy)\\n        so we use binary search for this .\\n        \\n        prime > nums[i] - nums[i-1]\\n        If we don\\'t get a valid prime in any case , then we return false immediately\\n        \\n    */\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = gen(1002) ;\\n        int n = nums.length ;\\n        for(int i=n-1 ; i>0 ; i--){\\n            if(nums[i-1]>=nums[i]){\\n                int pri = find(primes,nums[i-1]-nums[i]) ;\\n                if(pri==-1 || pri>=nums[i-1])return false ;\\n                nums[i-1]-=pri ;\\n            }\\n        }\\n        return true ;\\n    }\\n    public int find(List<Integer> primes , int val){\\n        System.out.println(val);\\n        //returns first prime greater than val :\\n        int lptr=0 , rptr=primes.size()-1 ;\\n        int ans=-1 ;\\n        while(lptr<=rptr){\\n            int mid = lptr+(rptr-lptr)/2 ;\\n            int ele = primes.get(mid) ;\\n            if(ele>val){\\n                ans = ele ;\\n                rptr=mid-1 ;\\n            }\\n            else{\\n                lptr=mid+1;\\n            }\\n        }\\n        return ans ;\\n    }\\n    public List<Integer> gen(int n){\\n        boolean isprime[] = new boolean[n] ;\\n        Arrays.fill(isprime,true) ;\\n        List<Integer> primes = new ArrayList<>() ;\\n        for(int i=2 ; i*i<n ; i++){\\n            if(isprime[i]){\\n                for(int j=i*i ; j<n ; j+=i){\\n                    isprime[j]=false ;\\n                }\\n            }\\n        }\\n        for(int i=2 ; i<n ; i++){\\n            if(isprime[i])\\n                primes.add(i) ;\\n        }\\n        return primes ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n        if we start to iterate from the left and encounter a situation where nums[i]<=nums[i-1]\\n        then we can only decrease the previous number\\n        there is no guarantee than on decreasing the previous number , the nums[n-2] would be less than nums[i-1] .\\n        \\n        But if we start to iterate from the right and encounter a situation where nums[i]<=nums[i-1]\\n        Then in this case we can decrease nums[i-1]\\n        This wont disturb the ascending order of elements after nums[i] .\\n        \\n        so if nums[i-1]>=nums[i] \\n        we need to find a prime such that :\\n        \\n        nums[i-1]-prime < nums[i]\\n        \\n        and we need the smallest prime in this case (greedy)\\n        so we use binary search for this .\\n        \\n        prime > nums[i] - nums[i-1]\\n        If we don\\'t get a valid prime in any case , then we return false immediately\\n        \\n    */\\n    public boolean primeSubOperation(int[] nums) {\\n        List<Integer> primes = gen(1002) ;\\n        int n = nums.length ;\\n        for(int i=n-1 ; i>0 ; i--){\\n            if(nums[i-1]>=nums[i]){\\n                int pri = find(primes,nums[i-1]-nums[i]) ;\\n                if(pri==-1 || pri>=nums[i-1])return false ;\\n                nums[i-1]-=pri ;\\n            }\\n        }\\n        return true ;\\n    }\\n    public int find(List<Integer> primes , int val){\\n        System.out.println(val);\\n        //returns first prime greater than val :\\n        int lptr=0 , rptr=primes.size()-1 ;\\n        int ans=-1 ;\\n        while(lptr<=rptr){\\n            int mid = lptr+(rptr-lptr)/2 ;\\n            int ele = primes.get(mid) ;\\n            if(ele>val){\\n                ans = ele ;\\n                rptr=mid-1 ;\\n            }\\n            else{\\n                lptr=mid+1;\\n            }\\n        }\\n        return ans ;\\n    }\\n    public List<Integer> gen(int n){\\n        boolean isprime[] = new boolean[n] ;\\n        Arrays.fill(isprime,true) ;\\n        List<Integer> primes = new ArrayList<>() ;\\n        for(int i=2 ; i*i<n ; i++){\\n            if(isprime[i]){\\n                for(int j=i*i ; j<n ; j+=i){\\n                    isprime[j]=false ;\\n                }\\n            }\\n        }\\n        for(int i=2 ; i<n ; i++){\\n            if(isprime[i])\\n                primes.add(i) ;\\n        }\\n        return primes ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345570,
                "title": "100-time-100-memory-simple-solution",
                "content": "# Intuition\\nWe start traversing the array from back and check if the element on the left of it is greater than present element or not. If not then we simply pass on. Otherwise we try to make the value of index on the left to be lower the present index by subrtacting the smallest prime number. If that is not possible we return False \\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def primeSubOperation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n=1000\\n        prime = [True for i in range(n+1)]\\n        p = 2\\n        while(p * p <=n):\\n            if (prime[p] == True):\\n                for i in range(p * p, n + 1, p):\\n                    prime[i] = False\\n            p += 1\\n        l=[]\\n        for p in range(2, n):\\n            if prime[p]:\\n                l.append(p)\\n\\n        for i in range(len(nums)-1,0,-1):\\n\\n            if nums[i]<=nums[i-1]:\\n                v=-1\\n                for j in l:\\n                    if j<nums[i-1] and nums[i-1]-j<nums[i]:\\n                        v=j\\n                        break\\n                if v==-1:\\n                    return False\\n                nums[i-1]-=v\\n        return True\\n\\n    \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def primeSubOperation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n=1000\\n        prime = [True for i in range(n+1)]\\n        p = 2\\n        while(p * p <=n):\\n            if (prime[p] == True):\\n                for i in range(p * p, n + 1, p):\\n                    prime[i] = False\\n            p += 1\\n        l=[]\\n        for p in range(2, n):\\n            if prime[p]:\\n                l.append(p)\\n\\n        for i in range(len(nums)-1,0,-1):\\n\\n            if nums[i]<=nums[i-1]:\\n                v=-1\\n                for j in l:\\n                    if j<nums[i-1] and nums[i-1]-j<nums[i]:\\n                        v=j\\n                        break\\n                if v==-1:\\n                    return False\\n                nums[i-1]-=v\\n        return True\\n\\n    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345562,
                "title": "c-eratosphen-sieve-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static constexpr int N = 1010;\\n    vector<bool> prime;\\n    vector<int> primes_;\\n    \\n    Solution() {\\n        prime.resize(N, true);\\n        prime[0] = false;\\n        prime[1] = false;\\n        for (int i = 2; i < N; ++i) {\\n            if (prime[i]) {\\n                primes_.emplace_back(i);\\n                int j = i + i;\\n                while (j < N) {\\n                    prime[j] = false;\\n                    j += i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        const int n = nums.size();\\n        int prev = nums.back();\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (nums[i] >= prev) {\\n                int j = 0;\\n                while ( (j < primes_.size() && primes_[j] < nums[i]) && nums[i] - primes_[j] >= prev) {\\n                    ++j;\\n                }\\n                if (j == primes_.size() || primes_[j] >= nums[i]) {\\n                    return false;\\n                }\\n                nums[i] -= primes_[j];\\n            }\\n            prev = nums[i];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static constexpr int N = 1010;\\n    vector<bool> prime;\\n    vector<int> primes_;\\n    \\n    Solution() {\\n        prime.resize(N, true);\\n        prime[0] = false;\\n        prime[1] = false;\\n        for (int i = 2; i < N; ++i) {\\n            if (prime[i]) {\\n                primes_.emplace_back(i);\\n                int j = i + i;\\n                while (j < N) {\\n                    prime[j] = false;\\n                    j += i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool primeSubOperation(vector<int>& nums) {\\n        const int n = nums.size();\\n        int prev = nums.back();\\n        for (int i = n - 2; i >= 0; --i) {\\n            if (nums[i] >= prev) {\\n                int j = 0;\\n                while ( (j < primes_.size() && primes_[j] < nums[i]) && nums[i] - primes_[j] >= prev) {\\n                    ++j;\\n                }\\n                if (j == primes_.size() || primes_[j] >= nums[i]) {\\n                    return false;\\n                }\\n                nums[i] -= primes_[j];\\n            }\\n            prev = nums[i];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345542,
                "title": "java-efficient-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }\\n            if(nums[i+1]==1) return false;\\n            if((nums[i]==2 || nums[i]==1)) return false;\\n            int p = pickPrime(nums[i]-1);\\n            int temp = p;\\n            while(nums[i]-p<nums[i+1]){\\n                temp=p;\\n                p = pickPrime(p-1);\\n            }\\n            nums[i]-=temp;\\n        }\\n\\n        //check whether the array is sorted or not\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n\\n    //picking the smallest prime.\\n    public int pickPrime(int n){\\n        while(n>1){\\n            if(isPrime(n)) return n;\\n            n--;\\n        }\\n        return 0;\\n    }\\n\\n    //verifying whether it is a prime or not.\\n    public boolean isPrime(int n){\\n        if(n<=1) return false;\\n\\t\\tfor (int i = 2; i <= Math.sqrt(n); i++) {\\n\\t\\t\\tif (n % i == 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }\\n            if(nums[i+1]==1) return false;\\n            if((nums[i]==2 || nums[i]==1)) return false;\\n            int p = pickPrime(nums[i]-1);\\n            int temp = p;\\n            while(nums[i]-p<nums[i+1]){\\n                temp=p;\\n                p = pickPrime(p-1);\\n            }\\n            nums[i]-=temp;\\n        }\\n\\n        //check whether the array is sorted or not\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n\\n    //picking the smallest prime.\\n    public int pickPrime(int n){\\n        while(n>1){\\n            if(isPrime(n)) return n;\\n            n--;\\n        }\\n        return 0;\\n    }\\n\\n    //verifying whether it is a prime or not.\\n    public boolean isPrime(int n){\\n        if(n<=1) return false;\\n\\t\\tfor (int i = 2; i <= Math.sqrt(n); i++) {\\n\\t\\t\\tif (n % i == 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345443,
                "title": "search-prime-number-in-ranges",
                "content": "**More efficient way to construct the prime number array in a range**\\n# Code\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        # More efficient to construct the prime number array in a range\\n        is_prime = [True] * 1000\\n        prime = [0]\\n        for i in range(2, 1000):\\n            if is_prime[i]:\\n                prime.append(i)\\n                for j in range(i * i, 1000, i):\\n                    is_prime[j] = False\\n        prevItem = 0\\n        for i in range(len(nums)):\\n            if nums[i] <= prevItem: return False\\n            index = bisect_left(prime, nums[i] - prevItem) - 1\\n            prevItem = nums[i] - prime[index]\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        # More efficient to construct the prime number array in a range\\n        is_prime = [True] * 1000\\n        prime = [0]\\n        for i in range(2, 1000):\\n            if is_prime[i]:\\n                prime.append(i)\\n                for j in range(i * i, 1000, i):\\n                    is_prime[j] = False\\n        prevItem = 0\\n        for i in range(len(nums)):\\n            if nums[i] <= prevItem: return False\\n            index = bisect_left(prime, nums[i] - prevItem) - 1\\n            prevItem = nums[i] - prime[index]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345407,
                "title": "sieveoferatoshenes-and-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGenerate all Prime Numbers from `2 to 1000` using Sieve of Erathonese.\\n- We create a list of all numbers from 2 to 1000.\\n- from i -> 2 to n, for all number from j -> i**2 to n, we mark all numbers = False which are divisible by i.\\n- The Remaining are Prime numbers\\n- `TC: O(n*log((log(n))))`\\n\\nNow we have all the primes, what we will do, is we will check which prime is valid for subtraction to make current value smallest. We do this for all numbers.\\n\\n# Complexity\\n- Time complexity: `O(n*log((log(n)))) + O(n * O(1000))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        def sieveOfEratoshenes(n):\\n            mark = [True] * (n+1)\\n            mark[0] = mark[1] = False # means these two are not Prime\\n\\n            for i in range(2, int(n**0.5)+1): # log(n)\\n                for j in range(i**2, n+1): \\n                    if j % i == 0: mark[j] = False\\n\\n            prime = []\\n            for i in range(2, n+1):\\n                if mark[i] == True:\\n                    prime.append(i)\\n            return prime\\n\\n        prime = sieveOfEratoshenes(1000)\\n        \\n\\n        n = len(nums)\\n        if n == 1: return True\\n\\n        # reducing\\n        poss = nums[0]\\n        for j in range(len(prime)):\\n            if prime[j] < nums[0]:\\n                poss = nums[0] - prime[j]\\n            else: break\\n        \\n        nums[0] = poss\\n\\n        for i in range(1, n):\\n\\n            # reduce it to the minimium value that is valid\\n            poss = nums[i]\\n            for j in range(len(prime)):\\n                if prime[j] < nums[i] and nums[i] - prime[j] > nums[i-1]: # valid reduction\\n                    poss = nums[i] - prime[j] \\n                else: break\\n            \\n            if poss <= nums[i-1]: return False # condition satisfy nahi hua\\n            else: nums[i] = poss\\n        \\n        return True\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primeSubOperation(self, nums: List[int]) -> bool:\\n        \\n        def sieveOfEratoshenes(n):\\n            mark = [True] * (n+1)\\n            mark[0] = mark[1] = False # means these two are not Prime\\n\\n            for i in range(2, int(n**0.5)+1): # log(n)\\n                for j in range(i**2, n+1): \\n                    if j % i == 0: mark[j] = False\\n\\n            prime = []\\n            for i in range(2, n+1):\\n                if mark[i] == True:\\n                    prime.append(i)\\n            return prime\\n\\n        prime = sieveOfEratoshenes(1000)\\n        \\n\\n        n = len(nums)\\n        if n == 1: return True\\n\\n        # reducing\\n        poss = nums[0]\\n        for j in range(len(prime)):\\n            if prime[j] < nums[0]:\\n                poss = nums[0] - prime[j]\\n            else: break\\n        \\n        nums[0] = poss\\n\\n        for i in range(1, n):\\n\\n            # reduce it to the minimium value that is valid\\n            poss = nums[i]\\n            for j in range(len(prime)):\\n                if prime[j] < nums[i] and nums[i] - prime[j] > nums[i-1]: # valid reduction\\n                    poss = nums[i] - prime[j] \\n                else: break\\n            \\n            if poss <= nums[i-1]: return False # condition satisfy nahi hua\\n            else: nums[i] = poss\\n        \\n        return True\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345309,
                "title": "c-solution-100-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconsider nums[i] and nums[i - 1], we want the the smallest nums[i](calculated by using the rule in the question) such that it still satisfies nums[i] > nums[i - 1].\\nnumbers we can deduct: nums[i] - nums[i - 1], since we need to satisfy nums[i] > nums[i - 1] after the deduction, need to minus 1\\nso it\\'s nums[i] - nums[i - 1] - 1.\\nAnd then we find the greatest prime number, deduct it, this is the \\'best\\' strictly increasing array we could find by using the rule, and if we\\'re still able to encounter nums[i - 1] >= nums[i], there\\'s no way to make this array strictly increase.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is_prime(int x) {\\n        if (x < 2) return false;\\n        for (int i = 2; i * i <= x; ++i) {\\n            if (x % i == 0) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        for (int i = 0, last = 0; i < n; ++i) {\\n            int a = nums[i];\\n            if (last >= a) return false;\\n\\n            int range = a - last - 1;\\n            for (int j = range; j >= 2; --j) {\\n                if (is_prime(j)) {\\n                    nums[i] -= j;\\n                    break;\\n                }\\n            }\\n\\n            last = nums[i];\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_prime(int x) {\\n        if (x < 2) return false;\\n        for (int i = 2; i * i <= x; ++i) {\\n            if (x % i == 0) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        for (int i = 0, last = 0; i < n; ++i) {\\n            int a = nums[i];\\n            if (last >= a) return false;\\n\\n            int range = a - last - 1;\\n            for (int j = range; j >= 2; --j) {\\n                if (is_prime(j)) {\\n                    nums[i] -= j;\\n                    break;\\n                }\\n            }\\n\\n            last = nums[i];\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345068,
                "title": "c-very-easy-to-understand-sieve-algo-traversal-from-back",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void seive(vector<bool> &v, int n){\\n        v[0] = v[1] = false;\\n        for(int i=2; i*i<n; i++){\\n            for(int j=2*i; j<n; j+=i){\\n                v[j] = false;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> isPrime(1005, true);\\n        seive(isPrime, 1005);\\n\\n        vector<int> v;\\n        for(int i=0; i<1004; i++)\\n            if(isPrime[i]) v.push_back(i);\\n        \\n        for(int i = nums.size()-2;i>=0;i--)\\n        {  \\n            if(nums[i] < nums[i+1])continue;\\n            else\\n            {\\n                int temp = 0;\\n                int j =0 ;\\n                while(v[j] < nums[i] && j< v.size())\\n                {\\n                    int k = nums[i]-v[j];\\n                    if(k < nums[i+1])\\n                    {\\n                        temp = k;\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                if(temp == 0)\\n                    return false;\\n                else\\n                    nums[i] = temp;\\n            }\\n        }\\n        return true;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void seive(vector<bool> &v, int n){\\n        v[0] = v[1] = false;\\n        for(int i=2; i*i<n; i++){\\n            for(int j=2*i; j<n; j+=i){\\n                v[j] = false;\\n            }\\n        }\\n    }\\n\\n    bool primeSubOperation(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> isPrime(1005, true);\\n        seive(isPrime, 1005);\\n\\n        vector<int> v;\\n        for(int i=0; i<1004; i++)\\n            if(isPrime[i]) v.push_back(i);\\n        \\n        for(int i = nums.size()-2;i>=0;i--)\\n        {  \\n            if(nums[i] < nums[i+1])continue;\\n            else\\n            {\\n                int temp = 0;\\n                int j =0 ;\\n                while(v[j] < nums[i] && j< v.size())\\n                {\\n                    int k = nums[i]-v[j];\\n                    if(k < nums[i+1])\\n                    {\\n                        temp = k;\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                if(temp == 0)\\n                    return false;\\n                else\\n                    nums[i] = temp;\\n            }\\n        }\\n        return true;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344928,
                "title": "c-greedy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> prime;\\n        prime.push_back(0);\\n        for(int i = 2; i <= 1000; i++) {\\n            int count = 0;\\n            for(int j = sqrt(i); j > 1; j--) {\\n                if(i % j == 0) count++;\\n            }\\n            if(!count) prime.push_back(i);\\n        }\\n        int val = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            auto iter = lower_bound(prime.begin(), prime.end(), nums[i] - val);\\n            if(iter == prime.begin()) return false;\\n            val = nums[i] - prime[iter - prime.begin() - 1];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool primeSubOperation(vector<int>& nums) {\\n        vector<int> prime;\\n        prime.push_back(0);\\n        for(int i = 2; i <= 1000; i++) {\\n            int count = 0;\\n            for(int j = sqrt(i); j > 1; j--) {\\n                if(i % j == 0) count++;\\n            }\\n            if(!count) prime.push_back(i);\\n        }\\n        int val = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            auto iter = lower_bound(prime.begin(), prime.end(), nums[i] - val);\\n            if(iter == prime.begin()) return false;\\n            val = nums[i] - prime[iter - prime.begin() - 1];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344875,
                "title": "90-01-faster-java-code-easy-implementation",
                "content": "# Please Upvote if it helps you!!\\uD83D\\uDD25\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int prime[]=new int[1001];\\n        for(int i=2;i<Math.sqrt(1001);i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<1001;j+=i){\\n                    prime[j]=1;\\n                }\\n            } \\n        }\\n        //  5 8 3\\n        for(int i=nums.length-2;i>=0;i--){\\n            \\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }\\n            else{\\n                int num=nums[i];\\n                int temp=2;\\n                while(num>=nums[i+1]){\\n                    if(temp==1001){\\n                return false;\\n            }\\n                    if(num<1){\\n                        return false;\\n                    }\\n                    num=nums[i];\\n                    if(prime[temp]==0){\\n                        num=num-temp;\\n                    }\\n                    //System.out.print(num+\" \");\\n                    if(num<1){\\n                        return false;\\n                    }\\n                    temp++;\\n                    \\n                }\\n                nums[i]=num;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        int prime[]=new int[1001];\\n        for(int i=2;i<Math.sqrt(1001);i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<1001;j+=i){\\n                    prime[j]=1;\\n                }\\n            } \\n        }\\n        //  5 8 3\\n        for(int i=nums.length-2;i>=0;i--){\\n            \\n            if(nums[i]<nums[i+1]){\\n                continue;\\n            }\\n            else{\\n                int num=nums[i];\\n                int temp=2;\\n                while(num>=nums[i+1]){\\n                    if(temp==1001){\\n                return false;\\n            }\\n                    if(num<1){\\n                        return false;\\n                    }\\n                    num=nums[i];\\n                    if(prime[temp]==0){\\n                        num=num-temp;\\n                    }\\n                    //System.out.print(num+\" \");\\n                    if(num<1){\\n                        return false;\\n                    }\\n                    temp++;\\n                    \\n                }\\n                nums[i]=num;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344713,
                "title": "java-sieve-beats-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        boolean[] prime = new boolean[1000+1];\\n        sieve(prime, 1000);\\n        \\n        int len = nums.length;\\n        for(int i=len-2;i>=0;i--){\\n            if(nums[i] < nums[i+1])\\n                continue;\\n            else{\\n                boolean flag = false;\\n                for(int j = 2 ;j<=nums[i]-1;j++){\\n                    if(prime[j] == true){\\n                        int val = nums[i] - j;\\n                        if(val < nums[i+1] && val > 0){\\n                            flag = true;\\n                            nums[i] = val;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag == false)\\n                    return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    \\n    public void sieve(boolean[] prime, int num){\\n        for(int i=0;i<=num;i++)\\n            prime[i] = true;\\n        \\n        for(int i=2;i*i<=num;i++){\\n            if(prime[i]){\\n                for(int j=i*i;j<=num;j+=i){\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean primeSubOperation(int[] nums) {\\n        boolean[] prime = new boolean[1000+1];\\n        sieve(prime, 1000);\\n        \\n        int len = nums.length;\\n        for(int i=len-2;i>=0;i--){\\n            if(nums[i] < nums[i+1])\\n                continue;\\n            else{\\n                boolean flag = false;\\n                for(int j = 2 ;j<=nums[i]-1;j++){\\n                    if(prime[j] == true){\\n                        int val = nums[i] - j;\\n                        if(val < nums[i+1] && val > 0){\\n                            flag = true;\\n                            nums[i] = val;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag == false)\\n                    return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    \\n    public void sieve(boolean[] prime, int num){\\n        for(int i=0;i<=num;i++)\\n            prime[i] = true;\\n        \\n        for(int i=2;i*i<=num;i++){\\n            if(prime[i]){\\n                for(int j=i*i;j<=num;j+=i){\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1843841,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just get/create a list of prime numbers till 1000 \n\nFor each number in numbers subtract the prime number just smaller than that number(use binary search for this), but make sure that after subtraction, it remains greater than the previous element, if not, subtract instead the next smaller prime number.\n\nThen just make sure at the end after going through this are you able to maintain the strictly increasing order or not. "
                    },
                    {
                        "username": "vetor",
                        "content": "15, 20, 17, 7, 16\\n\\nFor this numbers my changes nums array becomes \\n2,1,4,7,16\\nand returning false .\\ncan someone help plzz why this answers is expected as true?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "@iamavikb  correct answer will be \n[2,3,4,5,9]\nWe have to reduce the number to the smallest value but keeping the number greater than previous numbers .\n"
                    },
                    {
                        "username": "iamavikb",
                        "content": "Could be wrong expected test output. These are the arrays I get after traversing through all the indices...\\n[2, 1, 17, 7, 16]\\n[2, 1, 4, 7, 16]\\n[2, 1, 4, 2, 16]\\n[2, 1, 4, 2, 3]"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "We are expected to find if there is a possibility that array can remain sorted after prime subtractions.\nSo as we reduce nums[i] to lowest value possible,\n then we will reduce nums[i+1] to smallest value possible that it still remains greater than nums[i] , so we are keeping the possibility the next number has higher chances of remaining greater than previous element"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "why its false for the TC  {17,2} ?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@Jonathan](/jotho_) also suggested good point .\\nalso there is 1 more point mentioned in the q -> we can only subtract a prime numbeer that is less than the current value in case of 17  , we can choose 13 and that will yield False "
                    },
                    {
                        "username": "jotho_",
                        "content": "You\\'d have to subtract 17 from first element to make it 0.  They don\\'t really say this in the problem statement, but the resulting values of the array need to be >= 1"
                    },
                    {
                        "username": "sabbirkhanoni",
                        "content": "Please can anyone describe and simulated testcase 3, which array is [5,8,3]. how it is possible to become true? In my observation, It should be false. I was visit from last index to 0th index. so last index element  3 will be 3, then middle index element  have to be 8-7=1 then first index element have to be 5-5=0. then array becomes [0,1,3]... because of strictly increasing array but in constraints is 1<=nums[i]>=1000. So for \\'0\\' value of first index element it have to be false for constraints limitations."
                    },
                    {
                        "username": "nithin_395",
                        "content": "15,20,17,7,16\n15,20,5,7,16 where  17-4(3)\n15,3,5,7,16 where 20-1(17)\n2,3,5,7,16 where 15-1(13)\n\n\n2,3,5,7,16\n\n\nCorrect me if I am wrong in this "
                    }
                ]
            },
            {
                "id": 1848945,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just get/create a list of prime numbers till 1000 \n\nFor each number in numbers subtract the prime number just smaller than that number(use binary search for this), but make sure that after subtraction, it remains greater than the previous element, if not, subtract instead the next smaller prime number.\n\nThen just make sure at the end after going through this are you able to maintain the strictly increasing order or not. "
                    },
                    {
                        "username": "vetor",
                        "content": "15, 20, 17, 7, 16\\n\\nFor this numbers my changes nums array becomes \\n2,1,4,7,16\\nand returning false .\\ncan someone help plzz why this answers is expected as true?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "@iamavikb  correct answer will be \n[2,3,4,5,9]\nWe have to reduce the number to the smallest value but keeping the number greater than previous numbers .\n"
                    },
                    {
                        "username": "iamavikb",
                        "content": "Could be wrong expected test output. These are the arrays I get after traversing through all the indices...\\n[2, 1, 17, 7, 16]\\n[2, 1, 4, 7, 16]\\n[2, 1, 4, 2, 16]\\n[2, 1, 4, 2, 3]"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "We are expected to find if there is a possibility that array can remain sorted after prime subtractions.\nSo as we reduce nums[i] to lowest value possible,\n then we will reduce nums[i+1] to smallest value possible that it still remains greater than nums[i] , so we are keeping the possibility the next number has higher chances of remaining greater than previous element"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "why its false for the TC  {17,2} ?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@Jonathan](/jotho_) also suggested good point .\\nalso there is 1 more point mentioned in the q -> we can only subtract a prime numbeer that is less than the current value in case of 17  , we can choose 13 and that will yield False "
                    },
                    {
                        "username": "jotho_",
                        "content": "You\\'d have to subtract 17 from first element to make it 0.  They don\\'t really say this in the problem statement, but the resulting values of the array need to be >= 1"
                    },
                    {
                        "username": "sabbirkhanoni",
                        "content": "Please can anyone describe and simulated testcase 3, which array is [5,8,3]. how it is possible to become true? In my observation, It should be false. I was visit from last index to 0th index. so last index element  3 will be 3, then middle index element  have to be 8-7=1 then first index element have to be 5-5=0. then array becomes [0,1,3]... because of strictly increasing array but in constraints is 1<=nums[i]>=1000. So for \\'0\\' value of first index element it have to be false for constraints limitations."
                    },
                    {
                        "username": "nithin_395",
                        "content": "15,20,17,7,16\n15,20,5,7,16 where  17-4(3)\n15,3,5,7,16 where 20-1(17)\n2,3,5,7,16 where 15-1(13)\n\n\n2,3,5,7,16\n\n\nCorrect me if I am wrong in this "
                    }
                ]
            },
            {
                "id": 1845516,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just get/create a list of prime numbers till 1000 \n\nFor each number in numbers subtract the prime number just smaller than that number(use binary search for this), but make sure that after subtraction, it remains greater than the previous element, if not, subtract instead the next smaller prime number.\n\nThen just make sure at the end after going through this are you able to maintain the strictly increasing order or not. "
                    },
                    {
                        "username": "vetor",
                        "content": "15, 20, 17, 7, 16\\n\\nFor this numbers my changes nums array becomes \\n2,1,4,7,16\\nand returning false .\\ncan someone help plzz why this answers is expected as true?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "@iamavikb  correct answer will be \n[2,3,4,5,9]\nWe have to reduce the number to the smallest value but keeping the number greater than previous numbers .\n"
                    },
                    {
                        "username": "iamavikb",
                        "content": "Could be wrong expected test output. These are the arrays I get after traversing through all the indices...\\n[2, 1, 17, 7, 16]\\n[2, 1, 4, 7, 16]\\n[2, 1, 4, 2, 16]\\n[2, 1, 4, 2, 3]"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "We are expected to find if there is a possibility that array can remain sorted after prime subtractions.\nSo as we reduce nums[i] to lowest value possible,\n then we will reduce nums[i+1] to smallest value possible that it still remains greater than nums[i] , so we are keeping the possibility the next number has higher chances of remaining greater than previous element"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "why its false for the TC  {17,2} ?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@Jonathan](/jotho_) also suggested good point .\\nalso there is 1 more point mentioned in the q -> we can only subtract a prime numbeer that is less than the current value in case of 17  , we can choose 13 and that will yield False "
                    },
                    {
                        "username": "jotho_",
                        "content": "You\\'d have to subtract 17 from first element to make it 0.  They don\\'t really say this in the problem statement, but the resulting values of the array need to be >= 1"
                    },
                    {
                        "username": "sabbirkhanoni",
                        "content": "Please can anyone describe and simulated testcase 3, which array is [5,8,3]. how it is possible to become true? In my observation, It should be false. I was visit from last index to 0th index. so last index element  3 will be 3, then middle index element  have to be 8-7=1 then first index element have to be 5-5=0. then array becomes [0,1,3]... because of strictly increasing array but in constraints is 1<=nums[i]>=1000. So for \\'0\\' value of first index element it have to be false for constraints limitations."
                    },
                    {
                        "username": "nithin_395",
                        "content": "15,20,17,7,16\n15,20,5,7,16 where  17-4(3)\n15,3,5,7,16 where 20-1(17)\n2,3,5,7,16 where 15-1(13)\n\n\n2,3,5,7,16\n\n\nCorrect me if I am wrong in this "
                    }
                ]
            },
            {
                "id": 2042481,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just get/create a list of prime numbers till 1000 \n\nFor each number in numbers subtract the prime number just smaller than that number(use binary search for this), but make sure that after subtraction, it remains greater than the previous element, if not, subtract instead the next smaller prime number.\n\nThen just make sure at the end after going through this are you able to maintain the strictly increasing order or not. "
                    },
                    {
                        "username": "vetor",
                        "content": "15, 20, 17, 7, 16\\n\\nFor this numbers my changes nums array becomes \\n2,1,4,7,16\\nand returning false .\\ncan someone help plzz why this answers is expected as true?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "@iamavikb  correct answer will be \n[2,3,4,5,9]\nWe have to reduce the number to the smallest value but keeping the number greater than previous numbers .\n"
                    },
                    {
                        "username": "iamavikb",
                        "content": "Could be wrong expected test output. These are the arrays I get after traversing through all the indices...\\n[2, 1, 17, 7, 16]\\n[2, 1, 4, 7, 16]\\n[2, 1, 4, 2, 16]\\n[2, 1, 4, 2, 3]"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "We are expected to find if there is a possibility that array can remain sorted after prime subtractions.\nSo as we reduce nums[i] to lowest value possible,\n then we will reduce nums[i+1] to smallest value possible that it still remains greater than nums[i] , so we are keeping the possibility the next number has higher chances of remaining greater than previous element"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "why its false for the TC  {17,2} ?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@Jonathan](/jotho_) also suggested good point .\\nalso there is 1 more point mentioned in the q -> we can only subtract a prime numbeer that is less than the current value in case of 17  , we can choose 13 and that will yield False "
                    },
                    {
                        "username": "jotho_",
                        "content": "You\\'d have to subtract 17 from first element to make it 0.  They don\\'t really say this in the problem statement, but the resulting values of the array need to be >= 1"
                    },
                    {
                        "username": "sabbirkhanoni",
                        "content": "Please can anyone describe and simulated testcase 3, which array is [5,8,3]. how it is possible to become true? In my observation, It should be false. I was visit from last index to 0th index. so last index element  3 will be 3, then middle index element  have to be 8-7=1 then first index element have to be 5-5=0. then array becomes [0,1,3]... because of strictly increasing array but in constraints is 1<=nums[i]>=1000. So for \\'0\\' value of first index element it have to be false for constraints limitations."
                    },
                    {
                        "username": "nithin_395",
                        "content": "15,20,17,7,16\n15,20,5,7,16 where  17-4(3)\n15,3,5,7,16 where 20-1(17)\n2,3,5,7,16 where 15-1(13)\n\n\n2,3,5,7,16\n\n\nCorrect me if I am wrong in this "
                    }
                ]
            },
            {
                "id": 1992225,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just get/create a list of prime numbers till 1000 \n\nFor each number in numbers subtract the prime number just smaller than that number(use binary search for this), but make sure that after subtraction, it remains greater than the previous element, if not, subtract instead the next smaller prime number.\n\nThen just make sure at the end after going through this are you able to maintain the strictly increasing order or not. "
                    },
                    {
                        "username": "vetor",
                        "content": "15, 20, 17, 7, 16\\n\\nFor this numbers my changes nums array becomes \\n2,1,4,7,16\\nand returning false .\\ncan someone help plzz why this answers is expected as true?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "@iamavikb  correct answer will be \n[2,3,4,5,9]\nWe have to reduce the number to the smallest value but keeping the number greater than previous numbers .\n"
                    },
                    {
                        "username": "iamavikb",
                        "content": "Could be wrong expected test output. These are the arrays I get after traversing through all the indices...\\n[2, 1, 17, 7, 16]\\n[2, 1, 4, 7, 16]\\n[2, 1, 4, 2, 16]\\n[2, 1, 4, 2, 3]"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "We are expected to find if there is a possibility that array can remain sorted after prime subtractions.\nSo as we reduce nums[i] to lowest value possible,\n then we will reduce nums[i+1] to smallest value possible that it still remains greater than nums[i] , so we are keeping the possibility the next number has higher chances of remaining greater than previous element"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "why its false for the TC  {17,2} ?"
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "[@Jonathan](/jotho_) also suggested good point .\\nalso there is 1 more point mentioned in the q -> we can only subtract a prime numbeer that is less than the current value in case of 17  , we can choose 13 and that will yield False "
                    },
                    {
                        "username": "jotho_",
                        "content": "You\\'d have to subtract 17 from first element to make it 0.  They don\\'t really say this in the problem statement, but the resulting values of the array need to be >= 1"
                    },
                    {
                        "username": "sabbirkhanoni",
                        "content": "Please can anyone describe and simulated testcase 3, which array is [5,8,3]. how it is possible to become true? In my observation, It should be false. I was visit from last index to 0th index. so last index element  3 will be 3, then middle index element  have to be 8-7=1 then first index element have to be 5-5=0. then array becomes [0,1,3]... because of strictly increasing array but in constraints is 1<=nums[i]>=1000. So for \\'0\\' value of first index element it have to be false for constraints limitations."
                    },
                    {
                        "username": "nithin_395",
                        "content": "15,20,17,7,16\n15,20,5,7,16 where  17-4(3)\n15,3,5,7,16 where 20-1(17)\n2,3,5,7,16 where 15-1(13)\n\n\n2,3,5,7,16\n\n\nCorrect me if I am wrong in this "
                    }
                ]
            }
        ]
    }
]