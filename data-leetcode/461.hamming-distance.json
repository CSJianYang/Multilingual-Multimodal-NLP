[
    {
        "title": "Hamming Distance",
        "question_content": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.\n&nbsp;\nExample 1:\n\nInput: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       &uarr;   &uarr;\nThe above arrows point to positions where the corresponding bits are different.\n\nExample 2:\n\nInput: x = 3, y = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t0 <=&nbsp;x, y <= 231 - 1",
        "solutions": [
            {
                "id": 94698,
                "title": "java-1-line-solution-d",
                "content": "What does come to your mind first when you see this sentence ```\"corresponding bits are different\"```? Yes, ```XOR```! Also, do not forget there is a decent function Java provided: ```Integer.bitCount()``` ~~~\\n```\\npublic class Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x ^ y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\"corresponding bits are different\"```\n```XOR```\n```Integer.bitCount()```\n```\\npublic class Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x ^ y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94705,
                "title": "my-c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int dist = 0, n = x ^ y;\\n        while (n) {\\n            ++dist;\\n            n &= n - 1;\\n        }\\n        return dist;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int dist = 0, n = x ^ y;\\n        while (n) {\\n            ++dist;\\n            n &= n - 1;\\n        }\\n        return dist;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94697,
                "title": "python-1-line-49ms",
                "content": "```class Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(x^y).count('1')\\n```",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(x^y).count('1')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94693,
                "title": "java-3-line-solution",
                "content": "```\\npublic int hammingDistance(int x, int y) {\\n    int xor = x ^ y, count = 0;\\n    for (int i=0;i<32;i++) count += (xor >> i) & 1;\\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hammingDistance(int x, int y) {\\n    int xor = x ^ y, count = 0;\\n    for (int i=0;i<32;i++) count += (xor >> i) & 1;\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585474,
                "title": "c-python-4-simple-solutions-w-explanations-xor-and-brian-kernighan-method",
                "content": "We are given two numbers `x` and `y` and we need to return the hamming distance between them.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Converting Binary Form to String/Array & Iterating)***\\n\\nThe most basic way one could solve this question is by simply taking the number, converting them to binary form\\'s string / array and iterating over it to find the number of positions at which bits are different.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        bitset<32> xb(x), yb(y);\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++)\\n            ans += xb[i] != yb[i];\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        xb, yb, ans = f\\'{x:032b}\\', f\\'{y:032b}\\', 0\\n        return sum(i != j for i, j in zip(xb, yb))\\n```\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of bits in the given input numbers\\n***Space Complexity :*** **`O(N)`**, required to store the input number\\'s binary form\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Iterating & Comparing each Bit)***\\n\\nWe can also iterate over each bit of the given numbers manually and then compare the bits at each position. To check if the `i`th bit of a number  `x` is set, we can perform-  `(x >> i) & 1`. If the bit differ at a given position, we increment the count of hamming distance.\\n\\nBut, we can do better by checking the LSB each iteration and right-shifting it by 1 each time. This allows us to only iterate till both number become 0 instead of iterating all 32 times. The C++ code is written using this approach and python code uses the 1st one.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int ans = 0;\\n        while(x or y) {\\n            ans += (x & 1) != (y & 1);\\n            x >>= 1, y >>= 1;\\n        }            \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        return sum(x >> i & 1 != y >> i & 1 for i in range(32))   # using 1st approach...requires n iteration\\n```\\n\\n***Time Complexity :*** **`O(N)`**, to iterate over each bit of the number.\\n***Space Complexity :*** **`O(1)`** no additional extra space is used in this case.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (XOR & count bits)***\\n\\nWe need to count number of positions at which the bits differ for given numbers `x` and `y`. For this, we can use bit-wise XOR. The **xor of two bits is set only if they differ**. So, we need to xor and count the number of set bits in it.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int Xor = x ^ y, ans = 0;\\n        while(Xor)\\n            ans += Xor & 1,\\n            Xor >>= 1;        \\n        // other ways -\\n        // ans = bitset<32>(Xor).count()\\n        // ans = __builtin_popcount(Xor);\\n\\t\\t// ans = popcount(Xor)            // only since C++20\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        Xor, ans = x ^ y, 0\\n        while Xor:\\n            ans += Xor & 1\\n            Xor >>= 1\\n        return ans\\n        # other ways -\\n        # return bin(Xor).count(\\'1\\')\\n\\t\\t# return Xor.bit_count()          # only since python 3.10\\n```\\n\\n***Time Complexity :*** **`O(N)`**, to iterate over each bit of the number.\\n***Space Complexity :*** **`O(1)`** no additional extra space is used in this case.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Brian-Kernighan)***\\n\\nThe Brian-Kernighan approach is used to count the number of set bits in a given number using only set bits number of loops. We can use it to count the number of set bits in XOR result of given numbers. This appoach works as -\\n* Loop till a number is not 0.\\n* In each iteration, unset the rightmost bit and increment count of set bits.\\n\\t* This can be done using the operation `n & (n-1)`. Subtracting 1 from a number toggles each bit starting from the rightmost set bit. Then ANDing it with `n`, gives us the result after unsetting rightmost bit\\n\\t\\t```\\n\\t\\tFor example - \\n\\t\\tlet n = 13 (1101).\\n\\t\\t1.\\n\\t\\tn-1 = 1100            => Each bit from rightmost set bit is flipped\\n\\t\\tn = n&(n-1) = 1100    => rightmost bit got unset\\n\\t\\t\\n\\t\\t2. Now, n = 1100\\n\\t\\tn-1 = 1011            => Each bit from rightmost set bit is flipped\\n\\t\\tn = n&(n-1) = 1000    => rightmost bit unset\\n\\t\\t\\n\\t\\t3. Now, n = 1000\\n\\t\\tn-1 = 0111            => Each bit from rightmost set bit is flipped\\n\\t\\tn = n&(n-1) = 0000    => rightmost bit unset\\n\\t\\t\\n\\t\\tn becomes 0 and we get the count of set bits which is 3.\\n\\t\\t```\\n\\t\\tThe same can also be done by `n - (n & -n)` or `n ^ (n & (~n + 1))` or probably dozen other ways but `n & n-1` is the simplest.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int Xor = x ^ y, ans = 0;\\n        while(Xor) \\n            ans++,\\n            Xor &= Xor-1;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        Xor, ans = x ^ y, 0\\n        while Xor:\\n            ans += 1\\n            Xor &= Xor-1\\n        return ans\\n```\\n\\n***Time Complexity :*** **`O(K)`**, where `K` is the hamming distance between given numbers. This assume XOR operation as `O(1)`\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n**\\uD83D\\uDCA1Note:**\\n1. The number of bits `N` for this problem is fixed to `32`. So, strictly speaking, the time complexity of 1st three solutions is `O(N) = O(32) = O(1)`. But to differentiate between time complexities of 1st three and last approach, I have denoted them as `O(N)`.\\n2. It\\'s likely that if you got such a question during an interview, you will probably be expected to come up with an approach similar to this one. This approach performs the least number of loops to find the number of set bits in a number which is equal to the number of set bits in the number itself.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        bitset<32> xb(x), yb(y);\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++)\\n            ans += xb[i] != yb[i];\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        xb, yb, ans = f\\'{x:032b}\\', f\\'{y:032b}\\', 0\\n        return sum(i != j for i, j in zip(xb, yb))\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int ans = 0;\\n        while(x or y) {\\n            ans += (x & 1) != (y & 1);\\n            x >>= 1, y >>= 1;\\n        }            \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        return sum(x >> i & 1 != y >> i & 1 for i in range(32))   # using 1st approach...requires n iteration\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int Xor = x ^ y, ans = 0;\\n        while(Xor)\\n            ans += Xor & 1,\\n            Xor >>= 1;        \\n        // other ways -\\n        // ans = bitset<32>(Xor).count()\\n        // ans = __builtin_popcount(Xor);\\n\\t\\t// ans = popcount(Xor)            // only since C++20\\n        return ans;\\n    }\\n};\\n\\n```\n```python\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        Xor, ans = x ^ y, 0\\n        while Xor:\\n            ans += Xor & 1\\n            Xor >>= 1\\n        return ans\\n        # other ways -\\n        # return bin(Xor).count(\\'1\\')\\n\\t\\t# return Xor.bit_count()          # only since python 3.10\\n```\n```\\n\\t\\tFor example - \\n\\t\\tlet n = 13 (1101).\\n\\t\\t1.\\n\\t\\tn-1 = 1100            => Each bit from rightmost set bit is flipped\\n\\t\\tn = n&(n-1) = 1100    => rightmost bit got unset\\n\\t\\t\\n\\t\\t2. Now, n = 1100\\n\\t\\tn-1 = 1011            => Each bit from rightmost set bit is flipped\\n\\t\\tn = n&(n-1) = 1000    => rightmost bit unset\\n\\t\\t\\n\\t\\t3. Now, n = 1000\\n\\t\\tn-1 = 0111            => Each bit from rightmost set bit is flipped\\n\\t\\tn = n&(n-1) = 0000    => rightmost bit unset\\n\\t\\t\\n\\t\\tn becomes 0 and we get the count of set bits which is 3.\\n\\t\\t```\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int Xor = x ^ y, ans = 0;\\n        while(Xor) \\n            ans++,\\n            Xor &= Xor-1;\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        Xor, ans = x ^ y, 0\\n        while Xor:\\n            ans += 1\\n            Xor &= Xor-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94789,
                "title": "beats-100-python",
                "content": "```\\nclass Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        x = x ^ y\\n        y = 0\\n        while x:\\n            y += 1\\n            x = x & (x - 1)\\n        return y\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        x = x ^ y\\n        y = 0\\n        while x:\\n            y += 1\\n            x = x & (x - 1)\\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585400,
                "title": "c-two-simple-and-clean-solutions-explained-0ms-faster-than-100",
                "content": "**Solution I:**\\nWe use XOR bitwise operatoin to get all the bits that are set either in `x` or in `y`, not both.\\nThen we count the number of such bits and we\\'re done!\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int res = 0;\\n        int num = x^y;\\n        while (num) {\\n            res += num % 2;\\n            num >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n****\\n**Solution II - Without XOR:**\\nWe iterate `x` and `y` in parallel.\\nIf `(x % 2 != y % 2)` - only one of the rightmost bits are set - we add one to `res`.\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int res = 0;\\n        while (x || y) {\\n            res += (x % 2 != y % 2);\\n            x >>= 1, y >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int res = 0;\\n        int num = x^y;\\n        while (num) {\\n            res += num % 2;\\n            num >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int res = 0;\\n        while (x || y) {\\n            res += (x % 2 != y % 2);\\n            x >>= 1, y >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94704,
                "title": "javascript-one-line-solution",
                "content": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    return (x ^ y).toString(2).replace(/0/g, '').length;\\n};",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    return (x ^ y).toString(2).replace(/0/g, '').length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 720541,
                "title": "python-bit-manipulation-t-t-1-trick-explained",
                "content": "We are asked to find the number of positions, where `x` and `y` have equal bits. It is the same as finding number of `1` bits in number `t = x^y`. There is efficient way to find number of `1` bits in any number, using `t = t&(t-1)` trick: this operation in fact removes the last `1` bit from `t`. So, we just apply this rule in loop and increment our counter `Out`.\\n\\n**Complexity** is `O(k)`, where `k` is Hamming distance between numbers `x` and `y`, memory is `O(1)`. Note, that it works (twice?) faster than usual bit counts, which have always `32` iterations.\\n\\n```\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        Out, t = 0, x^y \\n        while t:\\n            t, Out = t & (t-1), Out + 1\\n        return Out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        Out, t = 0, x^y \\n        while t:\\n            t, Out = t & (t-1), Out + 1\\n        return Out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94879,
                "title": "c-simple-solution-0ms",
                "content": "```\\nint hammingDistance(int x, int y) {\\n    \\n    int tmpInt=x^y;\\n    int dis=0;\\n    \\n    while(tmpInt)\\n    {\\n        if((tmpInt>>1)<<1 != tmpInt)\\n        {\\n            ++dis;\\n        }\\n        \\n        tmpInt>>=1;\\n    }\\n    \\n    return dis;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint hammingDistance(int x, int y) {\\n    \\n    int tmpInt=x^y;\\n    int dis=0;\\n    \\n    while(tmpInt)\\n    {\\n        if((tmpInt>>1)<<1 != tmpInt)\\n        {\\n            ++dis;\\n        }\\n        \\n        tmpInt>>=1;\\n    }\\n    \\n    return dis;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94713,
                "title": "java-solution",
                "content": "The problem is basically the same as counting the 1 bits in an integer, and the useful trick to do that is : xor & (xor - 1) will eliminate the last 1 bit in a integer.\\n\\n```\\n    public int hammingDistance(int x, int y) {\\n        int xor = x ^ y, count = 0;\\n        \\n        while (xor != 0) {\\n            xor &= (xor - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int hammingDistance(int x, int y) {\\n        int xor = x ^ y, count = 0;\\n        \\n        while (xor != 0) {\\n            xor &= (xor - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585496,
                "title": "6-line-easy-java-solution-0ms-100-faster",
                "content": "**Upvote if you LIKE** \\uD83D\\uDE42\\n\\nclass Solution {\\n\\n    public int hammingDistance(int x, int y) {\\n        int res = 0;\\n        int m = x^y;                  // take the xor of two numbers\\n        while(m != 0){                // count the no of \"1\"s \\n            if((m&1) == 1)\\n                res++;\\n            m = m>>1;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int hammingDistance(int x, int y) {\\n        int res = 0;\\n        int m = x^y;                  // take the xor of two numbers\\n        while(m != 0){                // count the no of \"1\"s \\n            if((m&1) == 1)\\n                res++;\\n            m = m>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 720965,
                "title": "c-using-bit-manipulation-important-concept-for-beginners",
                "content": "***Pls upvote if you find this helpful  :)***\\nThe basic idea here is to discuss the usage of xor operator (^) ,and operator(&) and right shift operator(>>).When we take xor of two numbers the bits with same numbers become zero and with different numbers become 1. Then we can right shift all the 1\\'s and use & to find the number of ones .  \\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int z=x^y;int count=0;\\n        while(z){\\n            if(z&1)count++;\\n            z=z>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int z=x^y;int count=0;\\n        while(z){\\n            if(z&1)count++;\\n            z=z>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94701,
                "title": "python-explanation",
                "content": "We can find the i-th bit (from the right) of a number by dividing by 2 i times, then taking the number mod 2.\\n\\nUsing this, lets compare each of the i-th bits, adding 1 to our answer when they are different.\\n\\nCode:\\n```\\nans = 0\\nwhile x or y:\\n  ans += (x % 2) ^ (y % 2)\\n  x /= 2\\n  y /= 2\\nreturn ans\\n```",
                "solutionTags": [],
                "code": "```\\nans = 0\\nwhile x or y:\\n  ans += (x % 2) ^ (y % 2)\\n  x /= 2\\n  y /= 2\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585418,
                "title": "c-easy-intuitive-sol-3-bit-manipulation-approaches-tc-o-32-sc-o-1-beats-100",
                "content": "Hello everyone, I hope you all are doing great.\\n\\n***Note: If you found this post helpful then please do upvote!***\\n\\n**My Approach 1: (Count Different)**\\n1. Since, from the problem constraints says that `x` and `y` cannot be greater than 2<sup>31</sup> - 1. Hence we only need to check at most `32 bits` from `0 to 31`.\\n\\n2.  We traverse from MSB(Most significant bit) i.e. `31` to the LSB(Least significant bit) i.e. `0` and check whether the bits at `ith` position in `x` and `y` are same or different.\\n\\n3.  If the bits are different then we increment the counter.\\n\\n**Below is the code for tha approach I mentioned above:**\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int counter{};\\n        \\n\\t\\t// traverse from MSB to LSB\\n        for(int i{31}; i>=0; --i){\\n            \\n            int mask = (1<<i);\\n\\t\\t\\t\\n            // Check whther ith bit is different or not\\n            if((mask & x) != (mask & y))\\n                counter++;\\n        }\\n        \\n        return counter;\\n    }\\n};\\n```\\n\\n**Time Complexity:** Since we will at max traverse at max 32 bits, time complexity is ***O(32)*** .\\n**Space Complexity:** ***O(1)***\\n\\n**Approach 2: (XOR method)**\\n1. Since, we need to find the number of bits that are different at an index, that means at i<sup>th</sup> position there must be `1` in `x` and `0` in `y` OR `0` in `x` and `1` in `y`.\\n\\n2.  With this, XOR must be the operation that must pop into our mind as XOR converts the i<sup>th</sup> of our result to `1` if and only if there is exactly one single set bit (whether `1` in `x` and `0` in `y` OR `0` in `x` and `1` in `y` ). So we will just XOR our `x` and `y` with each other.\\n\\n3.  Then we will count the set bits from the result we obtained after xoring, because only those bits would be set where there was exactly single set bit (whther in x or y).\\n\\n**Below is the code for the approach I mentioned above:**\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int cnt{};\\n        int xr = x^y; // taking xor\\n        \\n\\t\\t// counting the set bit in the result obtained by xoring\\n        for(int i{31}; i>=0; --i){\\n            \\n            int mask = (1<<i);\\n            \\n            if(mask & xr)\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n**Time Complexity:** Since we will at max traverse at max 32 bits, time complexity is ***O(32)*** .\\n**Space Complexity:** ***O(1)***\\n\\n**Approach 3: (Builtin Method)**\\n1. After XORing like in previous approach, we used `for` loop to count the set bits. But `C++` provide us a bultin method called `__builtin_popcount(int)` to calculate the number of set bits in an integer.\\n\\n***Below is the code for the approach I mentioned above:***\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int cnt{};\\n        int xr = x^y;\\n        \\n        return __builtin_popcount(xr);\\n    }\\n};\\n```\\n\\n**Time Complexity:**  ***O(K)*** where `K` is the number of bits of the integer that has been passed into __builtin__popcount(int) method.\\n\\n**Space Complexity:** ***O(1)***\\n\\n***Please Upvote \\u2705 if you found this post useful for you!***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int counter{};\\n        \\n\\t\\t// traverse from MSB to LSB\\n        for(int i{31}; i>=0; --i){\\n            \\n            int mask = (1<<i);\\n\\t\\t\\t\\n            // Check whther ith bit is different or not\\n            if((mask & x) != (mask & y))\\n                counter++;\\n        }\\n        \\n        return counter;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int cnt{};\\n        int xr = x^y; // taking xor\\n        \\n\\t\\t// counting the set bit in the result obtained by xoring\\n        for(int i{31}; i>=0; --i){\\n            \\n            int mask = (1<<i);\\n            \\n            if(mask & xr)\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int cnt{};\\n        int xr = x^y;\\n        \\n        return __builtin_popcount(xr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94832,
                "title": "c-one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcount(x^y);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcount(x^y);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1585689,
                "title": "python3-easy-solution-using-bit-manipulation",
                "content": "\\t\\tvalue = str(bin(x^y))\\n        return(value.count(\\'1\\'))",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "\\t\\tvalue = str(bin(x^y))\\n        return(value.count(\\'1\\'))",
                "codeTag": "Unknown"
            },
            {
                "id": 94737,
                "title": "my-c-easy-understand-solution",
                "content": "````   \\n int hammingDistance(int x, int y) {\\n        int xorr = x ^ y;\\n        int dig = 0;\\n        while(xorr > 0){\\n            dig += xorr & 1;\\n            xorr >>= 1;\\n        }\\n        return dig;\\n}\\n````",
                "solutionTags": [],
                "code": "````   \\n int hammingDistance(int x, int y) {\\n        int xorr = x ^ y;\\n        int dig = 0;\\n        while(xorr > 0){\\n            dig += xorr & 1;\\n            xorr >>= 1;\\n        }\\n        return dig;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 505413,
                "title": "javascript-one-line-with-explanation",
                "content": "```js\\nlet hammingDistance = (x, y) => (x^y).toString(2).replace(/0/g,\"\").length\\n```\\n**Explanation**\\n```js\\nlet hammingDistance = (x, y) =>\\n```\\nCreates a function with parameters x and y (the two numbers)\\n```js\\n(x^y)\\n```\\nDoes XOR between the two numbers to turn all the differing bits into 1\\'s and the same bits into 0\\'s\\n```js\\n.toString(2)\\n```\\nConvert to binary so we can count the number of 1\\'s\\n```js\\n.replace(/0/g,\"\").length\\n```\\nReplace all the 0\\'s with nothing using a regex with the global flag, then take the length, which is just the number of 1\\'s remaining and therefore the number of differing bits, which is implicitly returned.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nlet hammingDistance = (x, y) => (x^y).toString(2).replace(/0/g,\"\").length\\n```\n```js\\nlet hammingDistance = (x, y) =>\\n```\n```js\\n(x^y)\\n```\n```js\\n.toString(2)\\n```\n```js\\n.replace(/0/g,\"\").length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94731,
                "title": "c-simple-solution",
                "content": "- Do XOR between the numbers which then gives the difference bits as '1'  \\n- Calculate those difference no.of bits by bit-END operation on preceding numbers until it is zero  \\n...............\\npublic int HammingDistance(int x, int y) {\\n        int z = x ^ y;\\n        int n = 0;\\n        while(z > 0)\\n        {\\n            z = z & (z-1);\\n            ++n;\\n        }\\n        return n;\\n    }\\n...............",
                "solutionTags": [],
                "code": "- Do XOR between the numbers which then gives the difference bits as '1'  \\n- Calculate those difference no.of bits by bit-END operation on preceding numbers until it is zero  \\n...............\\npublic int HammingDistance(int x, int y) {\\n        int z = x ^ y;\\n        int n = 0;\\n        while(z > 0)\\n        {\\n            z = z & (z-1);\\n            ++n;\\n        }\\n        return n;\\n    }\\n...............",
                "codeTag": "Unknown"
            },
            {
                "id": 1632003,
                "title": "java-solution-with-explanation-and-code",
                "content": "As we know that\\n0^0=0\\n0^1=1\\n1^0=1\\n1^1=0\\nWhen we take the XOR of two Numbers the place at which they are different gives 1 in Binary\\nExample\\n57^12\\nBinary of 57 is 111001\\nBinary of 12 is 001100\\nwhen we take their XOR\\n\\t\\t\\t\\t\\t\\t\\t\\t111001\\n\\t\\t\\t\\t\\t\\t\\t\\t001100\\n\\t\\t\\t\\t\\t\\t\\t\\t-----------\\n\\t\\t\\t\\t\\t\\t\\t\\t110101\\n\\t\\t\\t\\t\\t\\t\\t\\t------------\\nNow we can count the number of places at which 1 occurs using Kernighan\\'s Algorithm\\nwhich will give us the Hamming Distance\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int res=x^y;\\n        int count=0;\\n        while(res!=0)\\n        {\\n            int rsb=res&-res;\\n            res-=rsb;\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int res=x^y;\\n        int count=0;\\n        while(res!=0)\\n        {\\n            int rsb=res&-res;\\n            res-=rsb;\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013098,
                "title": "python-1-liner-32ms",
                "content": "```\\ndef hammingDistance(self, x, y):\\n        return bin(x^y).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef hammingDistance(self, x, y):\\n        return bin(x^y).count(\\'1\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 989180,
                "title": "easy-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int diff=0;\\n        while( x!=0 || y!=0){\\n            if(x%2!=y%2)diff++;\\n            x/=2;\\n            y/=2;\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int diff=0;\\n        while( x!=0 || y!=0){\\n            if(x%2!=y%2)diff++;\\n            x/=2;\\n            y/=2;\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608255,
                "title": "c-faster-than-100-bit-manipulation-3-line-solution",
                "content": "```\\n    int hammingDistance(int x, int y) {\\n        int c = 0;\\n        for(int i=31;i>=0;i--) if((x& 1<<i)^(y& 1<<i)) c++;\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n    int hammingDistance(int x, int y) {\\n        int c = 0;\\n        for(int i=31;i>=0;i--) if((x& 1<<i)^(y& 1<<i)) c++;\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1586508,
                "title": "simple-100-faster-understandable-solution-with-small-explanation-java-c-c",
                "content": "**Upvote if you liked.!**\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count=0;\\n\\t\\t\\n\\t\\t//do xor between x and y\\n        int num=x^y;\\n        \\n        while(num!=0){\\n\\t\\t\\t\\n\\t\\t\\t//AND operation is done to check the presence of \\'1\\' bit in num. if no \\'1\\' bit\\'s are there then it will be zero and if condition will become false.  \\n            if((1 & num)!=0)\\n                count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t//Right shift operation to remove the last bit\\n            num=num>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count=0;\\n\\t\\t\\n\\t\\t//do xor between x and y\\n        int num=x^y;\\n        \\n        while(num!=0){\\n\\t\\t\\t\\n\\t\\t\\t//AND operation is done to check the presence of \\'1\\' bit in num. if no \\'1\\' bit\\'s are there then it will be zero and if condition will become false.  \\n            if((1 & num)!=0)\\n                count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t//Right shift operation to remove the last bit\\n            num=num>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840470,
                "title": "3-similar-solutions-in-python",
                "content": "Here are my solutions:\\n```\\n# Approach 1: Just check every bit in both numbers and increment when they are different\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        hamming_distance = 0\\n        while x != 0 or y != 0:\\n            if x % 2 != y % 2:\\n                hamming_distance += 1\\n            x = x >> 1\\n            y = y >> 1\\n        return hamming_distance\\n```\\n```\\n# Approach 2: Just make XOR of x and y and after that count the number of \\'1\\' bits.\\n# because XOR of two different bits is always 1\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        hamming_distance = 0\\n        new = x ^ y\\n        while new > 0:\\n            if new % 2 == 1:\\n                hamming_distance += 1\\n            new = new >> 1\\n        return hamming_distance\\n\\n```\\n```\\n# Approach 3: Again make XOR of x and y but when we count the number of \\'1\\' bits\\n# we make the trick n&(n-1) which removes last \\'1\\' bit\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        hamming_distance = 0\\n        new = x ^ y\\n        while new > 0:\\n            new = new & (new-1)\\n            hamming_distance += 1\\n        return hamming_distance\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n# Approach 1: Just check every bit in both numbers and increment when they are different\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        hamming_distance = 0\\n        while x != 0 or y != 0:\\n            if x % 2 != y % 2:\\n                hamming_distance += 1\\n            x = x >> 1\\n            y = y >> 1\\n        return hamming_distance\\n```\n```\\n# Approach 2: Just make XOR of x and y and after that count the number of \\'1\\' bits.\\n# because XOR of two different bits is always 1\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        hamming_distance = 0\\n        new = x ^ y\\n        while new > 0:\\n            if new % 2 == 1:\\n                hamming_distance += 1\\n            new = new >> 1\\n        return hamming_distance\\n\\n```\n```\\n# Approach 3: Again make XOR of x and y but when we count the number of \\'1\\' bits\\n# we make the trick n&(n-1) which removes last \\'1\\' bit\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        hamming_distance = 0\\n        new = x ^ y\\n        while new > 0:\\n            new = new & (new-1)\\n            hamming_distance += 1\\n        return hamming_distance\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720565,
                "title": "java-bit-manipulation-100-runtime",
                "content": "```class Solution {\\n    public int hammingDistance(int x, int y) {\\n        int temp = x ^ y, z, count = 0;\\n        while(temp > 0){\\n            if( (z = temp & 1) == 1)\\n                count++;\\n            temp = temp >>> 1;\\n        }       \\n        return count;\\n    }\\n}\\nThis solution contains 2 steps\\n1) xor the 2 numbers\\n2) calculate the number of 1\\'s in the resulting number.\\n\\nbasically we xor the two numbers because the result of the xor will be a number with set bits in places where the bits of the 2 numbers are different.\\nthan we simply mask all bits except the least dignificant bit to check if it is 1, increase the count if it is and right shift the number by 1 until the number is greater than 0.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\n    public int hammingDistance(int x, int y) {\\n        int temp = x ^ y, z, count = 0;\\n        while(temp > 0){\\n            if( (z = temp & 1) == 1)\\n                count++;\\n            temp = temp >>> 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 217309,
                "title": "elegant-rust-solution",
                "content": "```\\n(x ^ y).count_ones() as i32\\n```",
                "solutionTags": [],
                "code": "```\\n(x ^ y).count_ones() as i32\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1586305,
                "title": "c-0ms-worst-solution-ever-brute-force-af-without-using-bits",
                "content": "**Idea : First convert decimal no.s into binary and then count diffrent bits**\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        // First convert decimal to binary \\n        vector<int> num1, num2;\\n        int max = x>y ? x : y;\\n        \\n        while(max){\\n            int rem1 = x%2;\\n            int rem2 = y%2;\\n            num1.push_back(rem1);\\n            num2.push_back(rem2);\\n            x /= 2;\\n            y /= 2;\\n            max /= 2;\\n        }\\n        \\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        // Now, here the conversion ends \\n        // Now, count the bits that are diffrent\\n        \\n        int count = 0;\\n        for(int i = 0; i < num1.size(); i++)\\n            if(num1[i] != num2[i])\\n                count++;\\n        \\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        // First convert decimal to binary \\n        vector<int> num1, num2;\\n        int max = x>y ? x : y;\\n        \\n        while(max){\\n            int rem1 = x%2;\\n            int rem2 = y%2;\\n            num1.push_back(rem1);\\n            num2.push_back(rem2);\\n            x /= 2;\\n            y /= 2;\\n            max /= 2;\\n        }\\n        \\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        // Now, here the conversion ends \\n        // Now, count the bits that are diffrent\\n        \\n        int count = 0;\\n        for(int i = 0; i < num1.size(); i++)\\n            if(num1[i] != num2[i])\\n                count++;\\n        \\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585869,
                "title": "java-easy-intuitive-sol-bit-manipulation-full-explanation-100-faster",
                "content": "Hello everyone, I hope you all are doing great.\\n <b>Note: If you found this post helpful then please do upvote!\\n \\n#### The Idea is to perform XOR with the given two number and the number of 1\\'s in result will be the ans to this problem.\\n\\nLet\\'s Understant this with an example, suppose input varibles are 12 and 11.\\nit\\'s binary representation will be\\n\\n#### 12 => 1100\\n#### 11 => 1011 \\nAnd when you do XOR with these two no. result will be <b>0111</b> and we can also see that the ans will be three which is equal to no. of ones available in result. Now we can perform <b>\"& 1\"</b> operation with the result to check if it\\'s LSB (Least signifiant bit) is <b>1 or 0</b>. we will increament the counter if the it\\'s 1.\\n![image](https://assets.leetcode.com/users/images/d3f69396-4761-4679-94e8-60fc642e2766_1637300395.1133528.png)\\n**Below is the code for tha approach I mentioned above:**\\n``` \\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int ans =0; \\n        int res = x^y;   // get the XOR for x and y in res\\n        while(res>0){  \\n            if((res&1)==1) ans++;   //checking if LSB is 1 if so increament ans by 1;\\n            res = res>>1;      // do right shift to get next bit\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Time Complexity**: Since we will at max traverse at max 32 bits, time complexity is **O(32)**.\\n**Space Complexity** : **O(1)**\\n\\n**Please Upvote \\u2705 if you found this post useful for you!**",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "``` \\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int ans =0; \\n        int res = x^y;   // get the XOR for x and y in res\\n        while(res>0){  \\n            if((res&1)==1) ans++;   //checking if LSB is 1 if so increament ans by 1;\\n            res = res>>1;      // do right shift to get next bit\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585758,
                "title": "python-easy-solution-with-explanation",
                "content": "Here we allways suppose smaller value is stored in x and larger in y.\\nAfter that we convert x and y to their binary values and add \"0\" before binary values of x to match its length with y\\'s binary value , then we simply compare them and count . \\nFor better understanding remove the \"#\" commented signs .\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        if(x>y):\\n            x,y=y,x\\n        a=str(bin(x))\\n        a=a[2:]\\n        b=str(bin(y))\\n        b=b[2:]\\n        #print(a,b)\\n        a=\"0\"*(len(b)-len(a))+a\\n        #print(a,b)\\n        count=0\\n        for i in range(len(a)):\\n            if(a[i]!=b[i]):\\n                count+=1\\n        return(count)\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        if(x>y):\\n            x,y=y,x\\n        a=str(bin(x))\\n        a=a[2:]\\n        b=str(bin(y))\\n        b=b[2:]\\n        #print(a,b)\\n        a=\"0\"*(len(b)-len(a))+a\\n        #print(a,b)\\n        count=0\\n        for i in range(len(a)):\\n            if(a[i]!=b[i]):\\n                count+=1\\n        return(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721102,
                "title": "0705-hamming-distance-bitwise-c-solution",
                "content": "## Approach \\n![image](https://assets.leetcode.com/users/images/8f11a57e-aeb0-4c6d-af26-6a0c86db5f43_1593958024.4079094.png)\\n* Use the simple bit XOR technique, we can easily determine the hamming distance the binary representation of two numbers.\\n* The `(x & 1)` and `(y & 1)` is used for getting the value of least significant bit.\\n## Complexity Analysis\\nTime: O(log_2(max(x, y)))\\nSpace: O(1)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int res = 0;\\n        while(x || y){\\n            res += (x & 1) ^ (y & 1);\\n            x >>= 1;\\n            y >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int res = 0;\\n        while(x || y){\\n            res += (x & 1) ^ (y & 1);\\n            x >>= 1;\\n            y >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455140,
                "title": "python-simple",
                "content": "<b>24 ms & 100%</b>\\n\\n```\\ndef hammingDistance(self, x, y):\\n\\tbin_x = \\'{0:032b}\\'.format(x)\\n\\tbin_y = \\'{0:032b}\\'.format(y)\\n\\td = 0  # Distance\\n\\tfor i in range(len(bin_x)):\\n\\t\\tif bin_x[i] != bin_y[i]:\\n\\t\\t\\td += 1\\n\\treturn d\\n```\\n\\n<b>28 ms & 100%</b> - Same approach, 1 line\\n\\n```\\nreturn sum(1 for i, j in zip(\\'{0:032b}\\'.format(x), \\'{0:032b}\\'.format(y)) if i != j)\\n```\\nIf you like my solution and/or find it useful, please upvote :) Thank you.",
                "solutionTags": [],
                "code": "```\\ndef hammingDistance(self, x, y):\\n\\tbin_x = \\'{0:032b}\\'.format(x)\\n\\tbin_y = \\'{0:032b}\\'.format(y)\\n\\td = 0  # Distance\\n\\tfor i in range(len(bin_x)):\\n\\t\\tif bin_x[i] != bin_y[i]:\\n\\t\\t\\td += 1\\n\\treturn d\\n```\n```\\nreturn sum(1 for i, j in zip(\\'{0:032b}\\'.format(x), \\'{0:032b}\\'.format(y)) if i != j)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 365768,
                "title": "easy-python-36-ms-solution-using-xor",
                "content": "The idea in my solution is to take XOR of x,y. Then convert to binary and count the 1s:\\n```\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        res = 0\\n        for i in bin(x^y)[2:]:\\n            if i == \\'1\\':\\n                res += 1\\n        return res\\n```\\n\\nI use ```bin(x^y)[2:]``` because ```bin()``` returns a number of the form ``` 0b...```\\nAlso remember that ```bin()``` returns a ```string```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        res = 0\\n        for i in bin(x^y)[2:]:\\n            if i == \\'1\\':\\n                res += 1\\n        return res\\n```\n```bin(x^y)[2:]```\n```bin()```\n``` 0b...```\n```bin()```\n```string```",
                "codeTag": "Python3"
            },
            {
                "id": 297893,
                "title": "javascript-faster-than-98-91-with-bitwise-operators",
                "content": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    let value = x ^ y;\\n    let counter = 0;\\n    \\n    while (value != 0) {\\n        if (value & 1)\\n           ++counter\\n           \\n        value = value >> 1\\n    }\\n    \\n    return counter\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    let value = x ^ y;\\n    let counter = 0;\\n    \\n    while (value != 0) {\\n        if (value & 1)\\n           ++counter\\n           \\n        value = value >> 1\\n    }\\n    \\n    return counter\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179109,
                "title": "python-one-liner-beats-100-20ms",
                "content": "```\\nclass Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(x^y).count(\"1\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(x^y).count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94882,
                "title": "c-intuitive-solution-0ms",
                "content": "```\\nint hammingDistance(int x, int y) {\\n    int dist=0,count=0,temp=0,arr1[1024]={0},arr2[1024]={0};\\n    while(x>0){\\n        temp=x%2;\\n        arr1[count]=temp;\\n        x=x/2;\\n        count++;\\n    }\\n    count=0;\\n    while(y>0){\\n        temp=y%2;\\n        arr2[count]=temp;\\n        y=y/2;\\n        count++;\\n    }\\n    for(x=32;x>=0;x--){\\n        if(arr1[x] != arr2[x])\\n            dist++;\\n    }\\n    return dist;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint hammingDistance(int x, int y) {\\n    int dist=0,count=0,temp=0,arr1[1024]={0},arr2[1024]={0};\\n    while(x>0){\\n        temp=x%2;\\n        arr1[count]=temp;\\n        x=x/2;\\n        count++;\\n    }\\n    count=0;\\n    while(y>0){\\n        temp=y%2;\\n        arr2[count]=temp;\\n        y=y/2;\\n        count++;\\n    }\\n    for(x=32;x>=0;x--){\\n        if(arr1[x] != arr2[x])\\n            dist++;\\n    }\\n    return dist;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94738,
                "title": "java-solution-without-system-function-integer-bitcount",
                "content": "```\\n    public int hammingDistance(int x, int y) {\\n        int n = x ^ y;\\n        \\n        int count = 0;\\n        while (n != 0) {\\n            count++;\\n            n = n & (n - 1);\\n        }\\n        return count;\\n    }\\n```\\n```x^y``` leaves all the bits that are different.\\nEach time, ```n & (n - 1)``` remove the last ```1``` bit of n.",
                "solutionTags": [],
                "code": "```\\n    public int hammingDistance(int x, int y) {\\n        int n = x ^ y;\\n        \\n        int count = 0;\\n        while (n != 0) {\\n            count++;\\n            n = n & (n - 1);\\n        }\\n        return count;\\n    }\\n```\n```x^y```\n```n & (n - 1)```\n```1```",
                "codeTag": "Unknown"
            },
            {
                "id": 3278752,
                "title": "461-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable \"xor\" with the XOR of the given integers \"x\" and \"y\".\\n2. Initialize a variable \"distance\" with 0.\\n3. While \"xor\" is not equal to 0, do the following:\\na. Bitwise AND \"xor\" with \"xor-1\" to unset the rightmost set bit of \"xor\". This operation flips the rightmost set bit to 0 and all the bits to the right of it to 1. For example, if \"xor\" is 010110, \"xor-1\" is 010101, and \"xor & (xor-1)\" is 010100.\\nb. Increment \"distance\" by 1.\\n4. Return \"distance\" as the Hamming distance between \"x\" and \"y\".\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        # Calculate the XOR of the two numbers\\n        xor = x ^ y\\n        \\n        # Calculate the number of set bits in the XOR\\n        distance = 0\\n        while xor:\\n            xor &= xor - 1\\n            distance += 1\\n        \\n        return distance\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        # Calculate the XOR of the two numbers\\n        xor = x ^ y\\n        \\n        # Calculate the number of set bits in the XOR\\n        distance = 0\\n        while xor:\\n            xor &= xor - 1\\n            distance += 1\\n        \\n        return distance\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586490,
                "title": "short-and-simple-c-4-line-solution",
                "content": "```\\nint hammingDistance(int x, int y) {\\n        int c = x ^ y;\\n        int count = 0;\\n        while(c != 0) { c = c & (c - 1); count++; }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint hammingDistance(int x, int y) {\\n        int c = x ^ y;\\n        int count = 0;\\n        while(c != 0) { c = c & (c - 1); count++; }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585583,
                "title": "c-one-liner-faster-than-100",
                "content": "```\\n// ^(xor) operation sets bit to 1 only if the bit is set in one number and not set in another number\\n//  __builtin_popcount(n) returns the number of set bits in n\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcount(x^y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// ^(xor) operation sets bit to 1 only if the bit is set in one number and not set in another number\\n//  __builtin_popcount(n) returns the number of set bits in n\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcount(x^y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721023,
                "title": "javascript-clean-code-no-bit-manipulation",
                "content": "```javascript\\nvar hammingDistance = function(x, y) {\\n    let xBits = x.toString(2);\\n    let yBits = y.toString(2);\\n    let diff = 0;\\n    \\n    if(xBits.length > yBits.length) yBits = yBits.padStart(xBits.length, \\'0\\');\\n    else xBits = xBits.padStart(yBits.length, \\'0\\');\\n    \\n    for(let i = 0; i < xBits.length; i++) {\\n        if(xBits[i] !== yBits[i]) diff++;\\n    }\\n    return diff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar hammingDistance = function(x, y) {\\n    let xBits = x.toString(2);\\n    let yBits = y.toString(2);\\n    let diff = 0;\\n    \\n    if(xBits.length > yBits.length) yBits = yBits.padStart(xBits.length, \\'0\\');\\n    else xBits = xBits.padStart(yBits.length, \\'0\\');\\n    \\n    for(let i = 0; i < xBits.length; i++) {\\n        if(xBits[i] !== yBits[i]) diff++;\\n    }\\n    return diff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371719,
                "title": "python-1-line-beats-99-66",
                "content": "```Python\\nclass Solution:\\n  def hammingDistance(self, x: int, y: int) -> int:\\n    return bin(x ^ y).count(\"1\")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n  def hammingDistance(self, x: int, y: int) -> int:\\n    return bin(x ^ y).count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452238,
                "title": "c-easy-solution-with-explanation-faster-than-100-beats-bit-manipulation",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n# Explanation\\n***The hammingDistance function is a member function of the Solution class. It takes two integers, x and y, as arguments and returns the Hamming distance between them. The Hamming distance is the number of positions at which the corresponding bits are different in the binary representation of the two numbers.***\\n***The function initializes a counter variable c to 0. It then enters a loop that iterates 32 times, once for each bit position in a 32-bit integer. In each iteration of the loop, the function extracts the ith bit of x and y using bitwise right shift and bitwise AND operations. If the ith bit of x and y are different, the function increments the counter c. Finally, the function returns the value of c, which represents the Hamming distance between x and y.***\\n\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int c=0;\\n        for(int i=0;i<=31;i++){\\n            int a=(x>>i)&1;\\n            int b=(y>>i)&1;\\n            if(a!=b)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int c=0;\\n        for(int i=0;i<=31;i++){\\n            int a=(x>>i)&1;\\n            int b=(y>>i)&1;\\n            if(a!=b)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266997,
                "title": "java-one-line-most-simple-solution-knowledge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInbuilt java function\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n      return Integer.bitCount(x^y);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n      return Integer.bitCount(x^y);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749206,
                "title": "java-faster-2-solution-easy-and-elegant-solution",
                "content": "# 1st Solution\\n**Below code will simply run untill both x and y not equal to 0\\nwe make AND operation of x and y with 1 to find rightmost bit and compare\\nif rightmost bit of x == rightmost bit y, if yes then count++\\nalso each time the x and y shift to right side untill x and y becomes 0 to end the loop**\\n```\\nint count = 0;\\nwhile (x != 0 || y != 0) {\\n\\tif ((x & 1) != (y & 1))\\n\\t\\tcount++;\\n\\ty >>= 1;\\n\\tx >>= 1;\\n}\\nreturn count;\\n```\\n# 2nd Solution\\n**Below code will first make xor of -->(x and y) \\ni.e. diffrent bits=1, same bits=0\\nand the method will count number of 1 bit.**\\n\\n    return Integer.bitCount(x ^ y);\\n\\t\\n___________________________________\\n\\n\\n# **Please UPVOTE if you like the solution or the explanation, If you have any question, feel free to ask**",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nint count = 0;\\nwhile (x != 0 || y != 0) {\\n\\tif ((x & 1) != (y & 1))\\n\\t\\tcount++;\\n\\ty >>= 1;\\n\\tx >>= 1;\\n}\\nreturn count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1301068,
                "title": "java-easy-solution-5-lines",
                "content": "class Solution {\\n    public int hammingDistance(int x, int y) {\\n        String first = String.format(\"%32s\", Integer.toBinaryString(x)).replace(\\' \\', \\'0\\');\\n        String second = String.format(\"%32s\", Integer.toBinaryString(y)).replace(\\' \\', \\'0\\');\\n        int count = 0;\\n        for(int i =0;i<32;i++){\\n            if(first.charAt(i)!=second.charAt(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hammingDistance(int x, int y) {\\n        String first = String.format(\"%32s\", Integer.toBinaryString(x)).replace(\\' \\', \\'0\\');\\n        String second = String.format(\"%32s\", Integer.toBinaryString(y)).replace(\\' \\', \\'0\\');\\n        int count = 0;\\n        for(int i =0;i<32;i++){\\n            if(first.charAt(i)!=second.charAt(i)){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 728615,
                "title": "c-solution-using-right-shift-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int z=x^y; //xor both number\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(z&1)\\n            {\\n                ans++;//count set bits\\n            }\\n            z=z>>1;  \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int z=x^y; //xor both number\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(z&1)\\n            {\\n                ans++;//count set bits\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 721188,
                "title": "javascript-56-ms-bit-manipulation",
                "content": "After submitting my solution i started reading the discussion and saw some codes from submission page.\\nBut I  failed to find the algo or the code similar to mine. So I thought about sharing it.\\n\\nAlgo is simple :\\n1) XOR the two numbers;\\n2) Do a bitewise add(&) with 1; (1 is 000001 in base 2 so with add it would return 1 only if the last bit of XORed is 1)\\n3) If (XORed & 1 == 1 )then counter++; \\n4) right shift 1 position ;\\n5)  repeat above three until the XORed number becomes zero;\\n```\\nfor(let i = x^y; i > 0; i = i >> 1){\\nif(i & 1) counter++;}\\nreturn counter;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor(let i = x^y; i > 0; i = i >> 1){\\nif(i & 1) counter++;}\\nreturn counter;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 721086,
                "title": "3-solution-c-bit-manipulation-using-xor",
                "content": "**Solution 1:**  Without ```XOR```\\n\\n1. Count the number of similar bits while number is greater than 0.\\n2. Using basic **Bit Manipulation** we can check the last bit of numbers\\n3. Compare, if equal increase the count.\\n4. Return it.\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while(x>0 or y>0){\\n            if((x&1) != (y&1)) count++;          \\n            x = x>>1;\\n            y = y>>1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\n**Solution 2:**  With ```XOR```\\n\\n1. It is more straight forward and easy to understand;\\n2. Do XOR first and store the result in an variable;\\n3. Doing **XOR** only leave different bits.\\n4. So just count those set bits and you are done with the solution.\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int res = x^y,count = 0;\\n        //while(res>0){count += ((res&1) == 1);res = res>>1;}\\n\\t\\twhile(res>0){count += res&1; res = res>>1;}\\n        return count;\\n    }\\n};\\n```\\n\\n\\n**Solution 3:**  Now comes ```XOR with __builtin_ Method```\\n\\n1. If you are too lazy to write any code \\n2. then why not just use a **builtin** method\\n\\nNow even a second wasted to write the code!\\nPretty Amazing right! I know XD\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcount(x^y);\\n    }\\n};\\n```\\n\\n**If you have any question ask in comment. And If it helps upvote!**",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```XOR```\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while(x>0 or y>0){\\n            if((x&1) != (y&1)) count++;          \\n            x = x>>1;\\n            y = y>>1;\\n        }\\n        return count;\\n    }\\n};\\n```\n```XOR```\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int res = x^y,count = 0;\\n        //while(res>0){count += ((res&1) == 1);res = res>>1;}\\n\\t\\twhile(res>0){count += res&1; res = res>>1;}\\n        return count;\\n    }\\n};\\n```\n```XOR with __builtin_ Method```\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcount(x^y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702053,
                "title": "easy-java-solution-one-line",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x^y);\\n    }\\n        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x^y);\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686796,
                "title": "0ms-simple-and-concise-java-solution-with-full-explanation",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int lastBit = 1;\\n        int hammingDistance = 0;\\n        while(x!=0 || y !=0){\\n            \\n            // we check if the last bit of both the numbers are different or not\\n            // if we find different last bits for the numbers, we just increase \\n            // the hamming distance by 1\\n            \\n            // Example: \\n\\t\\t\\t// ---------\\n\\t\\t\\t// If  x=8 and y=5 i.e. x:1000 and y:0101 respectively\\n            // we do AND operation with 1 i.e. 0001 with the above two numbers\\n            // so after AND operation, 1000 & 0001 = 0000 and 0101 & 0001 = 0001\\n            // we get 0 and 1 respectively, which is not equal, so we increase hammingDistance\\n            if((x&lastBit) != (y&lastBit))\\n                hammingDistance++;\\n            \\n            // now we right shift the numbers\\n            // if numbers are x : 8 and y : 5 i.e. 1000 and 0101 respectively\\n            x = x >> 1;\\n            y = y >> 1;\\n            // after right shift 1 position they become\\n            // 0100 && 0010\\n        }// now we repeat the above process until x or y is zero\\n        \\n        return hammingDistance;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int lastBit = 1;\\n        int hammingDistance = 0;\\n        while(x!=0 || y !=0){\\n            \\n            // we check if the last bit of both the numbers are different or not\\n            // if we find different last bits for the numbers, we just increase \\n            // the hamming distance by 1\\n            \\n            // Example: \\n\\t\\t\\t// ---------\\n\\t\\t\\t// If  x=8 and y=5 i.e. x:1000 and y:0101 respectively\\n            // we do AND operation with 1 i.e. 0001 with the above two numbers\\n            // so after AND operation, 1000 & 0001 = 0000 and 0101 & 0001 = 0001\\n            // we get 0 and 1 respectively, which is not equal, so we increase hammingDistance\\n            if((x&lastBit) != (y&lastBit))\\n                hammingDistance++;\\n            \\n            // now we right shift the numbers\\n            // if numbers are x : 8 and y : 5 i.e. 1000 and 0101 respectively\\n            x = x >> 1;\\n            y = y >> 1;\\n            // after right shift 1 position they become\\n            // 0100 && 0010\\n        }// now we repeat the above process until x or y is zero\\n        \\n        return hammingDistance;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506628,
                "title": "python-easy-one-liner",
                "content": "The main idea is in following ```^``` [bitwise operator](https://wiki.python.org/moin/BitwiseOperators)\\n```python\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return f\\'{x^y:b}\\'.count(\\'1\\')\\n```",
                "solutionTags": [],
                "code": "```^```\n```python\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return f\\'{x^y:b}\\'.count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292523,
                "title": "js-56-ms-33-9-mb-super-compact-one-line-js-solution",
                "content": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    return Number(x^y).toString(2).split(\\'\\').reduce((a, b) => +a + +b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    return Number(x^y).toString(2).split(\\'\\').reduce((a, b) => +a + +b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193591,
                "title": "java-100-fastest-possible-with-explanation",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        // XORing results in 1\\'s where there are differences, \\n        // and 0\\'s on matched bits\\n        int c = x ^ y;\\n        \\n        // This will contain the number of bits which matched\\n        int count = 0;\\n        \\n        // Stop when all bits in c are 0, indicating no matches remaining to count\\n        // Shifting always pulls in a 0 on the most significant bit, \\n        // so we are always getting closer to c = 0\\n        while(c != 0) {\\n            // By bit masking with 1, we are able to check the least\\n            // significant bit is a 1. If it is, c & 1 = 1.\\n            // Otherwise, c&1 = 0.\\n            count += c & 1;\\n            \\n            // Shift the bits to the right\\n            // Brings in a 0 on the far left\\n            c = c >> 1;\\n        }\\n        \\n        // Return the number of matched bits\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        // XORing results in 1\\'s where there are differences, \\n        // and 0\\'s on matched bits\\n        int c = x ^ y;\\n        \\n        // This will contain the number of bits which matched\\n        int count = 0;\\n        \\n        // Stop when all bits in c are 0, indicating no matches remaining to count\\n        // Shifting always pulls in a 0 on the most significant bit, \\n        // so we are always getting closer to c = 0\\n        while(c != 0) {\\n            // By bit masking with 1, we are able to check the least\\n            // significant bit is a 1. If it is, c & 1 = 1.\\n            // Otherwise, c&1 = 0.\\n            count += c & 1;\\n            \\n            // Shift the bits to the right\\n            // Brings in a 0 on the far left\\n            c = c >> 1;\\n        }\\n        \\n        // Return the number of matched bits\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151200,
                "title": "easy-to-understand-javascript-solution-52ms",
                "content": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    let xBin = x.toString(2);\\n    let yBin = y.toString(2);\\n    let hDiff = 0;\\n\\n    while (xBin.length < 8 || xBin.length < yBin.length) {\\n        xBin = \"0\" + xBin;\\n    }\\n    \\n    while (yBin.length < 8 || yBin.length < xBin.length) {\\n        yBin = \"0\" + yBin;\\n    }\\n    \\n    for (let a = 0; a < xBin.length; a++) {\\n        if (xBin[a] !== yBin[a]) {\\n            hDiff++;\\n        }\\n    }\\n    \\n    return hDiff;\\n};\\n\\n```\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/tetreault1/image_1531923500.png)\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    let xBin = x.toString(2);\\n    let yBin = y.toString(2);\\n    let hDiff = 0;\\n\\n    while (xBin.length < 8 || xBin.length < yBin.length) {\\n        xBin = \"0\" + xBin;\\n    }\\n    \\n    while (yBin.length < 8 || yBin.length < xBin.length) {\\n        yBin = \"0\" + yBin;\\n    }\\n    \\n    for (let a = 0; a < xBin.length; a++) {\\n        if (xBin[a] !== yBin[a]) {\\n            hDiff++;\\n        }\\n    }\\n    \\n    return hDiff;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806213,
                "title": "c-easy-approach",
                "content": "# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int ans = 0;\\n        while(x != 0 || y != 0) {\\n            if(x%2 != y%2) {\\n                ans++;\\n            }\\n            x /= 2;\\n            y /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n- Similar : https://leetcode.com/problems/minimum-bit-flips-to-convert-number/\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int ans = 0;\\n        while(x != 0 || y != 0) {\\n            if(x%2 != y%2) {\\n                ans++;\\n            }\\n            x /= 2;\\n            y /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342622,
                "title": "just-cool-one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return bin(x^y).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return bin(x^y).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115238,
                "title": "java-3-solutions-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n- `x & 1` will give us the last bit of `x`.\\n- `y & 1` will give us the last bit of `y`.\\n---\\n\\n### Approach 1:\\nIf the last bits are unequal, increment count.\\n``` java []\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while (x > 0 || y > 0) {\\n            if ((x & 1) != (y & 1)) {\\n                count++;\\n            }\\n            y >>= 1;\\n            x >>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(32) => O(1)\\n// SC: O(1)\\n```\\n---\\n### Approach 2:\\n**XOR** of the last bits will give `1`, if they are unequal.\\nElse it\\'ll give `0`, if they are equal.\\n``` java []\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while (x > 0 || y > 0) {\\n            count += (x & 1) ^ (y & 1);\\n            y >>= 1;\\n            x >>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(32) => O(1)\\n// SC: O(1)\\n```\\n---\\n\\n### Approach 3:\\nWe will do `x xor y`.\\nThe result will have `1` present wherever bits were different, and `0` wherever bits where same.\\n\\nWe will use inbuilt `Integer.bitCount()` method to count the number of set-bits.\\n\\nAgain, the number of set-bits signifies the number of positions where bits were different in `x` and `y`.\\n\\n![image.png](https://assets.leetcode.com/users/images/3a8df501-7ae1-4cf0-9dee-fa4a70c047de_1675025501.335259.png)\\n\\n``` java []\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x ^ y);\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while (x > 0 || y > 0) {\\n            if ((x & 1) != (y & 1)) {\\n                count++;\\n            }\\n            y >>= 1;\\n            x >>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(32) => O(1)\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while (x > 0 || y > 0) {\\n            count += (x & 1) ^ (y & 1);\\n            y >>= 1;\\n            x >>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(32) => O(1)\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x ^ y);\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112305,
                "title": "compact-fast-and-using-just-1-variable",
                "content": "# Intuition\\nXOR and leftshift of bits\\n\\n# Approach\\nGetting xor of two numbers and counting 1 in it.\\n\\n# Complexity\\n- Time complexity:\\nO(32)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count=0;\\n        for(int i=0;i<32;i++)\\n            if(((x^y)&(1<<i))>0)\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count=0;\\n        for(int i=0;i<32;i++)\\n            if(((x^y)&(1<<i))>0)\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821757,
                "title": "easy-approach-with-bit-manipulation-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\nThe main idea is to use a XOR operator for these 2 numbers. If 2 bits are the same - we get \\'0\\' at this position and \\'1\\' otherwise. So our mission here is to calculate the number of \\'1\\'s. We can do so by comparing the last bit with number 1 via AND operator. After comparison we remove that checked bit and repeat the whole process till we have bits left.\\n\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        diff = x^y\\n        res = 0\\n        while diff:\\n            res+= diff&1\\n            diff>>=1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        diff = x^y\\n        res = 0\\n        while diff:\\n            res+= diff&1\\n            diff>>=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731726,
                "title": "c-2-ways-faster-than-100-bit-manipulation-easy-to-understand",
                "content": "**First Method**\\n Compare the last bits and keep right shifting the numbers until the maximum of the two numbers becomes zero.\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int maxNum=max(y,x);\\n        int minNum=min(y,x);\\n        int result=0;\\n        while(maxNum>0){\\n            int a=maxNum&1;\\n            int b=minNum&1;\\n            if(a!=b){\\n                result++;\\n            }\\n            maxNum=maxNum>>1;\\n            minNum=minNum>>1;\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Second Method**\\nTake xor of the two numbers and calculate the no of set bits in the xor.\\n```\\nclass Solution {\\npublic:\\n    int countSetBits(int x){\\n        int result=0;\\n        while(x>0){\\n            x&=x-1;\\n            result++;\\n        }\\n        return result;\\n    }\\n    int hammingDistance(int x, int y) {\\n        int z=x^y;\\n        return countSetBits(z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int maxNum=max(y,x);\\n        int minNum=min(y,x);\\n        int result=0;\\n        while(maxNum>0){\\n            int a=maxNum&1;\\n            int b=minNum&1;\\n            if(a!=b){\\n                result++;\\n            }\\n            maxNum=maxNum>>1;\\n            minNum=minNum>>1;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countSetBits(int x){\\n        int result=0;\\n        while(x>0){\\n            x&=x-1;\\n            result++;\\n        }\\n        return result;\\n    }\\n    int hammingDistance(int x, int y) {\\n        int z=x^y;\\n        return countSetBits(z);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436433,
                "title": "simple-xor-and-right-shift-to-count-1-s-with-comments-for-swift",
                "content": "```\\nclass Solution {\\n    func hammingDistance(_ x: Int, _ y: Int) -> Int {\\n        // XOR the two numbers  \\n        // The result will have a 1 bit, where there is a difference.\\n        var delta = x ^ y\\n        \\n        // Next, count the 1\\'s in the delta       \\n        var count = 0\\n        while delta != 0 {\\n            if delta & 1 == 1 {count += 1} // check least sig bit for a 1\\n            delta >>= 1 // Right shift 1\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func hammingDistance(_ x: Int, _ y: Int) -> Int {\\n        // XOR the two numbers  \\n        // The result will have a 1 bit, where there is a difference.\\n        var delta = x ^ y\\n        \\n        // Next, count the 1\\'s in the delta       \\n        var count = 0\\n        while delta != 0 {\\n            if delta & 1 == 1 {count += 1} // check least sig bit for a 1\\n            delta >>= 1 // Right shift 1\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264914,
                "title": "hamming-distance-easy-solution-java-and-c-both-same-code",
                "content": "First read definition of hamming distance then it is very easy.\\nStep 1: Xor two integers.\\nStep 2: Count set bits.\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int ans=x^y;\\n        int count=0;\\n        while(ans>0){\\n            count+=ans&1;\\n            ans>>=1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\nIf it helps you please upvote me.\\uD83D\\uDE25\\uD83E\\uDD70Thank you.\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int ans=x^y;\\n        int count=0;\\n        while(ans>0){\\n            count+=ans&1;\\n            ans>>=1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253639,
                "title": "hamming-distance-java-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        \\n        int count=0;\\n        while(x!=0 || y!=0){\\n            if((x&1)!=(y&1)){\\n                count++;\\n            }\\n            x=x>>>1;\\n            y=y>>>1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        \\n        int count=0;\\n        while(x!=0 || y!=0){\\n            if((x&1)!=(y&1)){\\n                count++;\\n            }\\n            x=x>>>1;\\n            y=y>>>1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837127,
                "title": "python-easy-sol-95-faster",
                "content": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        x_b = bin(x)[2:]\\n        y_b = bin(y)[2:]\\n        \\n        size = max(len(x_b),len(y_b)) # ensure both binary strings are of same length\\n        x_b = x_b.zfill(size)\\n        y_b = y_b.zfill(size)\\n        \\n        count = 0\\n        for i in range(size):\\n            if x_b[i] != y_b[i]: #count every instance where bits are different\\n                count +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        x_b = bin(x)[2:]\\n        y_b = bin(y)[2:]\\n        \\n        size = max(len(x_b),len(y_b)) # ensure both binary strings are of same length\\n        x_b = x_b.zfill(size)\\n        y_b = y_b.zfill(size)\\n        \\n        count = 0\\n        for i in range(size):\\n            if x_b[i] != y_b[i]: #count every instance where bits are different\\n                count +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586690,
                "title": "simple-python-solution",
                "content": "Runtime: 1260 ms, faster than 49.63%\\nMemory Usage: 25.6 MB, less than 26.88%\\n\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        \\n        x_bin = format(x, \\'0b\\')\\n        y_bin = format(y, \\'0b\\')\\n        \\n        longest_bin = max(len(x_bin), len(y_bin))\\n        \\n        x_bin = x_bin.zfill(longest_bin)\\n        y_bin = y_bin.zfill(longest_bin)\\n        \\n        output = 0\\n        \\n        for a, b in zip(x_bin, y_bin):\\n            if a is not b:\\n                output += 1\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        \\n        x_bin = format(x, \\'0b\\')\\n        y_bin = format(y, \\'0b\\')\\n        \\n        longest_bin = max(len(x_bin), len(y_bin))\\n        \\n        x_bin = x_bin.zfill(longest_bin)\\n        y_bin = y_bin.zfill(longest_bin)\\n        \\n        output = 0\\n        \\n        for a, b in zip(x_bin, y_bin):\\n            if a is not b:\\n                output += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585601,
                "title": "handmade-binary-function-time-o-l",
                "content": "If x = 1, y = 4.\\n(1)First, switch x and y so that x is greater than or equal to y.\\nx = 4, y = 1\\n(2)Make them binary number. \\nx = 100, y = 1\\n(3)Make them have the same digit. \\nx = 100, y = 001\\n(4)Then compare each digit and count the positions where they differ.\\n\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        def get_bin(num):\\n            res = []\\n            while num > 0:\\n                res.append(num % 2)\\n                num //= 2\\n            return \\'\\'.join(str(num) for num in res[::-1])\\n        \\n        if x < y:\\n            x, y = y, x\\n        \\n        bin_x, bin_y = get_bin(x), get_bin(y)\\n        res = 0\\n        s1, s2 = len(bin_x), len(bin_y)\\n        bin_y = \\'0\\' * (s1 - s2) + bin_y\\n        \\n        return sum(bin_x[i] != bin_y[i] for i in range(s1))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        def get_bin(num):\\n            res = []\\n            while num > 0:\\n                res.append(num % 2)\\n                num //= 2\\n            return \\'\\'.join(str(num) for num in res[::-1])\\n        \\n        if x < y:\\n            x, y = y, x\\n        \\n        bin_x, bin_y = get_bin(x), get_bin(y)\\n        res = 0\\n        s1, s2 = len(bin_x), len(bin_y)\\n        bin_y = \\'0\\' * (s1 - s2) + bin_y\\n        \\n        return sum(bin_x[i] != bin_y[i] for i in range(s1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304382,
                "title": "easy-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y)\\n    {\\n        int ans = x^y;\\n        return Integer.bitCount(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y)\\n    {\\n        int ans = x^y;\\n        return Integer.bitCount(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241735,
                "title": "java-bit-manipulation-0ms-beats-100-one-liner-t-c-o-1-s-c-o-1",
                "content": "\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x ^ y);\\n    }",
                "solutionTags": [],
                "code": "\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x ^ y);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1158651,
                "title": "99-72-of-js-solutions-clean-solution-detailed-explanation",
                "content": "The Hamming distance between two integers is the \\n**number of positions at which the corresponding bits are different.**\\n\\n**XOR operation (^) of two binary digits is 1 when digits are different and is 0 when digits are the same.\\nwe should calculate number of different digits in corresponding positions for two numbers.\\nFor this we can find XOR of 2 number and then count 1 digits in result.**\\n\\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    let xorResult = x ^ y;\\n    let binaryFormat = xorResult.toString(2);\\n    let hammingDistance = 0;\\n    \\n    for(let digit of binaryFormat.split(\\'\\')) {\\n        if(digit === \\'1\\')    \\n            hammingDistance++;\\n    }\\n    \\n    return hammingDistance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    let xorResult = x ^ y;\\n    let binaryFormat = xorResult.toString(2);\\n    let hammingDistance = 0;\\n    \\n    for(let digit of binaryFormat.split(\\'\\')) {\\n        if(digit === \\'1\\')    \\n            hammingDistance++;\\n    }\\n    \\n    return hammingDistance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1046827,
                "title": "0ms-100-java-simple-solution",
                "content": "```\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while(x!=0||y!=0)\\n        {   \\n            int x1 =x&1;\\n            int y1 = y&1;\\n            if(x1!=y1)\\n            count++;\\n\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return count;   \\n    }\\n```\\n\\n**A better solution would be -**\\n\\n```\\npublic int hammingDistance(int x, int y) {\\n        int a = x^y , count = 0;\\n        while(a>0)\\n        {   \\n            count += a&1;\\n            a>>=1;\\n        }\\n        return count;   \\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while(x!=0||y!=0)\\n        {   \\n            int x1 =x&1;\\n            int y1 = y&1;\\n            if(x1!=y1)\\n            count++;\\n\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return count;   \\n    }\\n```\n```\\npublic int hammingDistance(int x, int y) {\\n        int a = x^y , count = 0;\\n        while(a>0)\\n        {   \\n            count += a&1;\\n            a>>=1;\\n        }\\n        return count;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008757,
                "title": "python-one-liner",
                "content": "```\\nreturn bin(x^y)[2:].count(\\'1\\')\\n```\\nI think its self explanatory, however if any dounts, please ask!!\\nIf you like, please **UPVOTE**\\nHappy Coding :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nreturn bin(x^y)[2:].count(\\'1\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764670,
                "title": "rust-one-liner-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn hamming_distance(x: i32, y: i32) -> i32 {\\n        (x ^ y).count_ones() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn hamming_distance(x: i32, y: i32) -> i32 {\\n        (x ^ y).count_ones() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640748,
                "title": "python-1-liner",
                "content": "```\\ndef hammingDistance(self, x: int, y: int) -> int:\\n\\treturn bin(x ^ y).count(\\'1\\')\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef hammingDistance(self, x: int, y: int) -> int:\\n\\treturn bin(x ^ y).count(\\'1\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 476410,
                "title": "c",
                "content": "```\\npublic int HammingDistance(int x, int y) {\\n\\tvar z = x ^ y;\\n\\tvar count = 0;\\n\\twhile (z > 0) {\\n\\t\\tcount += z & 1;\\n\\t\\tz >>= 1;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int HammingDistance(int x, int y) {\\n\\tvar z = x ^ y;\\n\\tvar count = 0;\\n\\twhile (z > 0) {\\n\\t\\tcount += z & 1;\\n\\t\\tz >>= 1;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429133,
                "title": "c-neat-one-liner-with-bitwise-magic",
                "content": "There you have it, using both the XOR operator (`^`) and a handy built in function :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcount(x ^ y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcount(x ^ y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382096,
                "title": "python3-1-line-solution-using-xor",
                "content": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return bin(x^y)[2:].count(\"1\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return bin(x^y)[2:].count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299079,
                "title": "0ms-java-using-xor-w-explanation",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        // xor both to get a number with the amount of bits different = the # of 1s\\n        int xored = x ^ y;\\n        int numBits = 0;\\n        \\n        // Increment the bit counter\\n        while(xored != 0) {\\n            numBits++;\\n            \\n            // Subtract 1 and bitwise AND to remove the lowest 1\\n\\t\\t\\t// EXAMPLE\\n\\t\\t\\t//     10100 - 1 \\n\\t\\t\\t//  =  10011\\n\\t\\t\\t// & = 10000\\n            xored &= (xored - 1);\\n        }\\n        \\n        return numBits;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hammingDistance(int x, int y) {\\n        // xor both to get a number with the amount of bits different = the # of 1s\\n        int xored = x ^ y;\\n        int numBits = 0;\\n        \\n        // Increment the bit counter\\n        while(xored != 0) {\\n            numBits++;\\n            \\n            // Subtract 1 and bitwise AND to remove the lowest 1\\n\\t\\t\\t// EXAMPLE\\n\\t\\t\\t//     10100 - 1 \\n\\t\\t\\t//  =  10011\\n\\t\\t\\t// & = 10000\\n            xored &= (xored - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 281810,
                "title": "just-one-line-faster-than-88-78-of-python3",
                "content": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return(bin(x ^ y).count(\\'1\\'))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return(bin(x ^ y).count(\\'1\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212850,
                "title": "python-soln-with-clear-explanation",
                "content": "```class Solution:\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        # Time  : O(1)\\n        # Space : O(1)\\n        # Method : XOR gate and list comprehension\\n\\n        bin_x = list(\\'{0:032b}\\'.format(x))\\n        bin_y = list(\\'{0:032b}\\'.format(y))\\n\\n        res = [(a!=b) for (a,b) in zip(bin_x, bin_y)]\\n\\n        return sum(res)\\n\\nSolution().hammingDistance(1,4)```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        # Time  : O(1)\\n        # Space : O(1)\\n        # Method : XOR gate and list comprehension\\n\\n        bin_x = list(\\'{0:032b}\\'.format(x))\\n        bin_y = list(\\'{0:032b}\\'.format(y))\\n\\n        res = [(a!=b) for (a,b) in zip(bin_x, bin_y)]\\n\\n        return sum(res)\\n\\nSolution().hammingDistance(1,4)```",
                "codeTag": "Java"
            },
            {
                "id": 187454,
                "title": "java-bit-shifting",
                "content": "```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n\n        int xorValue   = x ^ y;\n        int bitCounter = (xorValue & 1) == 1 ? 1 : 0;\n\n        for (int i = 1; i < 32; i++) {\n            xorValue = xorValue >> 1;\n\n            if ((xorValue & 1) == 1) {\n                bitCounter++;\n            }\n        }\n\n        return bitCounter;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n\n        int xorValue   = x ^ y;\n        int bitCounter = (xorValue & 1) == 1 ? 1 : 0;\n\n        for (int i = 1; i < 32; i++) {\n            xorValue = xorValue >> 1;\n\n            if ((xorValue & 1) == 1) {\n                bitCounter++;\n            }\n        }\n\n        return bitCounter;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 182272,
                "title": "javascript-beats-100",
                "content": "```\nvar hammingDistance = function(x, y) {\n    var result = 0;\n    while (x > 0 || y > 0) {\n        result += (x % 2)^(y % 2);\n        x >>= 1;\n        y >>= 1;\n    }    \n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar hammingDistance = function(x, y) {\n    var result = 0;\n    while (x > 0 || y > 0) {\n        result += (x % 2)^(y % 2);\n        x >>= 1;\n        y >>= 1;\n    }    \n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159833,
                "title": "python-3-single-line-easy-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(x ^ y)[2:].count(\\'1\\')\\n```\\nbin returns the binary reperesentation in string format. Just count the number of 1s in the XOR result.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(x ^ y)[2:].count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146687,
                "title": "python3-beats-100",
                "content": "```class Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return self.count_set_bits(x ^ y)\\n    \\n    def count_set_bits(self, n):\\n        count = 0\\n        while n:\\n            if n % 2:\\n                count += 1\\n            n >>= 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return self.count_set_bits(x ^ y)\\n    \\n    def count_set_bits(self, n):\\n        count = 0\\n        while n:\\n            if n % 2:\\n                count += 1\\n            n >>= 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145246,
                "title": "javascript-solution-52ms-99-78",
                "content": "```javascript\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n  let ones = 0;\\n  let z = x ^ y;\\n    \\n  while (z) {\\n    if (z & 1) {\\n      ones += 1;  \\n    }\\n    \\n    z = z >> 1;\\n  }\\n  \\n  return ones;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n  let ones = 0;\\n  let z = x ^ y;\\n    \\n  while (z) {\\n    if (z & 1) {\\n      ones += 1;  \\n    }\\n    \\n    z = z >> 1;\\n  }\\n  \\n  return ones;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114114,
                "title": "swift-1-line-solution",
                "content": "    func hammingDistance(_ x: Int, _ y: Int) -> Int {\\n        return (x ^ y).nonzeroBitCount\\n    }",
                "solutionTags": [],
                "code": "    func hammingDistance(_ x: Int, _ y: Int) -> Int {\\n        return (x ^ y).nonzeroBitCount\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 94692,
                "title": "javascript-xor-1-line",
                "content": "```\\nvar hammingDistance = function(x, y) {\\n    return (x ^ y).toString(2).split(\"0\").join(\"\").length;\\n};",
                "solutionTags": [],
                "code": "```\\nvar hammingDistance = function(x, y) {\\n    return (x ^ y).toString(2).split(\"0\").join(\"\").length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 94714,
                "title": "python-1-line-solution-o-1",
                "content": "<code>\\n<pre>\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        return bin(x^y).count('1')",
                "solutionTags": [
                    "Python3"
                ],
                "code": "<code>\\n<pre>\\nclass Solution:\\n    def hammingDistance(self, x, y):\\n        return bin(x^y).count('1')",
                "codeTag": "Java"
            },
            {
                "id": 94768,
                "title": "scala",
                "content": "```  \\ndef hammingDistance(x: Int, y: Int): Int = {\\n    Integer.bitCount(x ^ y)\\n  }\\n```",
                "solutionTags": [],
                "code": "```  \\ndef hammingDistance(x: Int, y: Int): Int = {\\n    Integer.bitCount(x ^ y)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 94772,
                "title": "dividing-number-by-2-to-get-reminder",
                "content": "O(log(n)) solution.\\n```\\npublic int hammingDistance(int x, int y) {\\n        int hammingDistance = 0;\\n        while(x > 0 || y > 0 ){\\n            if(x%2 != y%2) {\\n                hammingDistance++;\\n            }\\n            x=x/2;\\n            y=y/2;\\n        } \\n        return hammingDistance;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hammingDistance(int x, int y) {\\n        int hammingDistance = 0;\\n        while(x > 0 || y > 0 ){\\n            if(x%2 != y%2) {\\n                hammingDistance++;\\n            }\\n            x=x/2;\\n            y=y/2;\\n        } \\n        return hammingDistance;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94779,
                "title": "ruby-one-line-solution",
                "content": "XOR gets produces 1 when the two bits are different i.e (1,0) and (0,1),\\nAnd XOR in Ruby is '^',\\nTo get the result as string, use the formatter '%b',\\nAnd then count the ones in the resulted string,\\nThat's your hamming distance!\\n```\\n(\"%b\" % (x^y)).count('1')\\n```",
                "solutionTags": [],
                "code": "```\\n(\"%b\" % (x^y)).count('1')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94873,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    let diff = x ^ y;\\n    let result = 0;\\n    \\n    // find number of ones in the XOR result\\n    while (diff > 0) {\\n        if (diff & 1 === 1) result += 1;\\n        diff >>= 1;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @return {number}\\n */\\nvar hammingDistance = function(x, y) {\\n    let diff = x ^ y;\\n    let result = 0;\\n    \\n    // find number of ones in the XOR result\\n    while (diff > 0) {\\n        if (diff & 1 === 1) result += 1;\\n        diff >>= 1;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94727,
                "title": "0ms-c-two-line-solution",
                "content": "```\\nint hammingDistance(int x, int y) {\\n\\tif((x^y)==0) return 0;\\n\\treturn (x^y)%2 + hammingDistance(x/2,y/2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint hammingDistance(int x, int y) {\\n\\tif((x^y)==0) return 0;\\n\\treturn (x^y)%2 + hammingDistance(x/2,y/2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917577,
                "title": "beats-100-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just have to check the number of bits that are different.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this approach we follow these steps.\\n1.Run a loop until both the numbers are zero.\\n2.Get the last bit of the two numbers and compare them.\\n3.If the two bits didn\\'t match increase the count.\\n4.After each iteration right shift both the numbers by 1.\\n5.At last return the count.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int ans=0;\\n        while(x || y){\\n            int mask=x&1;\\n            int mask2=y&1;\\n            if(mask!=mask2){\\n                ans++;\\n            }\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int ans=0;\\n        while(x || y){\\n            int mask=x&1;\\n            int mask2=y&1;\\n            if(mask!=mask2){\\n                ans++;\\n            }\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908766,
                "title": "bit-manipulation-beats-100-o-max-logx-logy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int cnt = 0;\\n        while (x || y) {\\n            cnt += ((x & 1) != (y & 1));\\n            x = x >> 1, y = y >> 1;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int cnt = 0;\\n        while (x || y) {\\n            cnt += ((x & 1) != (y & 1));\\n            x = x >> 1, y = y >> 1;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782319,
                "title": "see-if-you-want",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n           int c=0;\\n    while(x!=0 || y!=0)\\n    {\\n        if((x&1)!=(y&1) || (x&0)!=(y&0))\\n        {\\n            c++;\\n        }\\n        x=x>>1;\\n        y=y>>1;\\n    }\\n    return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n           int c=0;\\n    while(x!=0 || y!=0)\\n    {\\n        if((x&1)!=(y&1) || (x&0)!=(y&0))\\n        {\\n            c++;\\n        }\\n        x=x>>1;\\n        y=y>>1;\\n    }\\n    return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666663,
                "title": "100-beat-easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binary(int x){\\n        int count = 0;\\n        while(x > 0){\\n            if(x%2 == 1){\\n                count++;\\n            }\\n            x /= 2;\\n        }\\n        return count;\\n    }\\n    int hammingDistance(int x, int y) {\\n        int n = x^y;\\n        return binary(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binary(int x){\\n        int count = 0;\\n        while(x > 0){\\n            if(x%2 == 1){\\n                count++;\\n            }\\n            x /= 2;\\n        }\\n        return count;\\n    }\\n    int hammingDistance(int x, int y) {\\n        int n = x^y;\\n        return binary(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555599,
                "title": "easy-1-line-python-code-using-bitwise-xor-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return bin(x^y)[2:].count(\"1\")\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return bin(x^y)[2:].count(\"1\")\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509902,
                "title": "100-beats-cpp-few-lines",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find the xor of the numbers\\n2. Count no. of 1s in the result\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log2n), where n is x ^ y, this can be interpreted as O(1), since an int can hold a maximum of 32 bits\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int n = x ^ y;\\n        int hamdis = 0;\\n        while(n>0){\\n            hamdis += n & 1;\\n            n >>= 1;\\n        }\\n        return hamdis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int n = x ^ y;\\n        int hamdis = 0;\\n        while(n>0){\\n            hamdis += n & 1;\\n            n >>= 1;\\n        }\\n        return hamdis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463181,
                "title": "0ms-easiest-java-solution",
                "content": "\\n\\n# Approach\\nComparing the last bits of the first and second integer and increasing the count in case they are different.\\n\\n# Complexity\\n- Space complexity:\\nO(0)\\n\\n# Code\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n       \\n       int count=0;\\n        while(x!=0 || y!=0){\\n            int one=x&1; //finding the last bit of first integer by comparing it with 1\\n            int two=y&1; //finding the last bit of second integer by comparing it with 1\\n            if(one!=two) count++;  //checking if the bits are same\\n            x=x>>>1; //shifting the binary representaion of x by 1\\n            y=y>>>1;  //shifting the binary representaion of y by 1\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n       \\n       int count=0;\\n        while(x!=0 || y!=0){\\n            int one=x&1; //finding the last bit of first integer by comparing it with 1\\n            int two=y&1; //finding the last bit of second integer by comparing it with 1\\n            if(one!=two) count++;  //checking if the bits are same\\n            x=x>>>1; //shifting the binary representaion of x by 1\\n            y=y>>>1;  //shifting the binary representaion of y by 1\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463035,
                "title": "beating-95-single-line-easy-python-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/b2c748f7-3366-4f4a-bfea-dbe952a1886c_1682672609.175557.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return str(bin(x^y)).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def hammingDistance(self, x, y):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \"\"\"\\n        return str(bin(x^y)).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440426,
                "title": "java-one-liner-code-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x^y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        return Integer.bitCount(x^y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413443,
                "title": "kotlin-literally-one-line-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple, Isn\\'t it?\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    fun hammingDistance(x: Int, y: Int) = Integer.bitCount(x xor y)\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun hammingDistance(x: Int, y: Int) = Integer.bitCount(x xor y)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363973,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcountll(x^y);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        binx,biny=bin(x).replace(\\'0b\\',\\'0\\'),bin(y).replace(\\'0b\\',\\'0\\')\\n        lx,ly=len(binx),len(biny)\\n        ans=0\\n        i,j=lx-1,ly-1\\n        while i>=0 and j>=0:\\n            ans+=binx[i]!=biny[j]\\n            i-=1\\n            j-=1\\n        while i>=0:\\n            ans+=binx[i]==\"1\"\\n            i-=1\\n        while j>=0:\\n            ans+=biny[j]==\"1\"\\n            j-=1\\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int z = x ^ y;\\n        int res = 0;\\n        while (z > 0) {\\n            res++;\\n            z = z & (z-1);\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        return __builtin_popcountll(x^y);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        binx,biny=bin(x).replace(\\'0b\\',\\'0\\'),bin(y).replace(\\'0b\\',\\'0\\')\\n        lx,ly=len(binx),len(biny)\\n        ans=0\\n        i,j=lx-1,ly-1\\n        while i>=0 and j>=0:\\n            ans+=binx[i]!=biny[j]\\n            i-=1\\n            j-=1\\n        while i>=0:\\n            ans+=binx[i]==\"1\"\\n            i-=1\\n        while j>=0:\\n            ans+=biny[j]==\"1\"\\n            j-=1\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int z = x ^ y;\\n        int res = 0;\\n        while (z > 0) {\\n            res++;\\n            z = z & (z-1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350793,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) \\n    {\\n        int num = 0;\\n\\n        while (x > 0 || y > 0)\\n        {\\n            if (x % 2 != y % 2) num++;\\n            x /= 2;\\n            y /= 2;\\n        }    \\n\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) \\n    {\\n        int num = 0;\\n\\n        while (x > 0 || y > 0)\\n        {\\n            if (x % 2 != y % 2) num++;\\n            x /= 2;\\n            y /= 2;\\n        }    \\n\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338043,
                "title": "easy-c-solution-o-logn",
                "content": "\\n\\n# Approach\\nBrian Kernighan\\'s algorithm.\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n# Code\\n```\\nint hammingDistance(int x, int y){\\n    int d=0,n=x^y;\\n    while(n){\\n        n&=n-1;\\n        d++;\\n    }\\n    return d;\\n}\\n```\\nPlease Upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hammingDistance(int x, int y){\\n    int d=0,n=x^y;\\n    while(n){\\n        n&=n-1;\\n        d++;\\n    }\\n    return d;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2941901,
                "title": "c-1-liner-using-xor-beats-99",
                "content": "# Approach\\nBy taking XOR of x and y we will get the no. of different bits b/w these numbers\\nNow we simply need to count the set bits\\nSo we can use __builtin_popcount() to count the set bits and return it\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  log(max(x,y))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n      return __builtin_popcount(x^y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n      return __builtin_popcount(x^y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915071,
                "title": "c-solution-100-time-32-28-space-used-bitset-and-xor",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y);\\n};\\n/***************************************************************/\\nint Solution::hammingDistance(int x, int y) {\\n    bitset<32> xB(x), yB(y);\\n    xB^=yB;\\n    return xB.count(); \\n}\\n/***************************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y);\\n};\\n/***************************************************************/\\nint Solution::hammingDistance(int x, int y) {\\n    bitset<32> xB(x), yB(y);\\n    xB^=yB;\\n    return xB.count(); \\n}\\n/***************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894626,
                "title": "java-3-line-bit-manipulation-with-comments",
                "content": "(x&1) will give last digit of binary of x\\n  (y&1) will give last digit of binary of y\\n\\nXOR of same digits give = 0.\\nXOR of different digits give = 1.\\n\\nThen right shifting x and y.\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count=0;\\n       while(x>0 || y>0){       \\n           count+=(x&1)^(y&1); \\n           x>>=1;\\n           y>>=1;\\n       } \\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count=0;\\n       while(x>0 || y>0){       \\n           count+=(x&1)^(y&1); \\n           x>>=1;\\n           y>>=1;\\n       } \\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792750,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n        public int hammingDistance(int x, int y) {\\n            int xor = x ^ y;\\n            int distance = 0;\\n\\n            while (xor != 0) {\\n                if (xor % 2 ==1) {\\n                    distance++;\\n                }\\n                xor = xor >> 1;\\n            }\\n\\n            return distance;\\n        }\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n        public int hammingDistance(int x, int y) {\\n            int xor = x ^ y;\\n            int distance = 0;\\n\\n            while (xor != 0) {\\n                if (xor % 2 ==1) {\\n                    distance++;\\n                }\\n                xor = xor >> 1;\\n            }\\n\\n            return distance;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2770836,
                "title": "simple-and-easy-java-solution-using-bit-manipulation-100-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int n=(x^y);\\n        int c=0;\\n        while(n>0)\\n        {\\n            c++;\\n            n=(n &(n-1));\\n        }\\n\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int n=(x^y);\\n        int c=0;\\n        while(n>0)\\n        {\\n            c++;\\n            n=(n &(n-1));\\n        }\\n\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755766,
                "title": "one-liner-solution-using-bit-count-method-in-python",
                "content": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return (x^y).bit_count()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return (x^y).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705864,
                "title": "easy-c-solution-beats-100-in-runtime-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly find the XOR of these numbers (opposite bits gives 1 and same bist gives zero) and then count the number of number of 1 bits in the XORED number.\\n\\n# Complexity\\n- Time complexity: O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int cnt = 0;\\n        x ^= y;\\n        while(x)\\n        {\\n            if (x & 1)\\n            cnt++;\\n            x>>=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int cnt = 0;\\n        x ^= y;\\n        while(x)\\n        {\\n            if (x & 1)\\n            cnt++;\\n            x>>=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688279,
                "title": "python3-two-ways-string-and-bit-manipulation-commented",
                "content": "Any questions feel free to ask, if the comments helped, leave me a like :)\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n\\n        # String solution\\n\\t\\t# TC O(n) SC O(1)\\n        longer = len(bin(y))-2 \\n        if x > y: longer = len(bin(x))-2\\n\\t\\t # 2 lines above for padding 0\\'s\\n            \\n        # turn both x and y to binary, keep count of mismatches with count variable\\n        x, y, count = format(x, \\'0b\\').zfill(longer), format(y, \\'0b\\').zfill(longer), 0 \\n        for i in range(len(x)):\\n            if x[i] != y[i]: count += 1\\n        return count\\n\\n        # bit manipulation solution\\n\\t\\t# TC O(n) SC O(1)\\n        xor = x ^ y # XOR your two integers\\n        ham = 0 # store number of 1\\'s from the XOR operation\\n        while xor != 0: # while you have bits to check\\n            ham += xor % 2 # increase ham when a 1 is seen\\n            xor >>= 1 # right shift\\n        return ham\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n\\n        # String solution\\n\\t\\t# TC O(n) SC O(1)\\n        longer = len(bin(y))-2 \\n        if x > y: longer = len(bin(x))-2\\n\\t\\t # 2 lines above for padding 0\\'s\\n            \\n        # turn both x and y to binary, keep count of mismatches with count variable\\n        x, y, count = format(x, \\'0b\\').zfill(longer), format(y, \\'0b\\').zfill(longer), 0 \\n        for i in range(len(x)):\\n            if x[i] != y[i]: count += 1\\n        return count\\n\\n        # bit manipulation solution\\n\\t\\t# TC O(n) SC O(1)\\n        xor = x ^ y # XOR your two integers\\n        ham = 0 # store number of 1\\'s from the XOR operation\\n        while xor != 0: # while you have bits to check\\n            ham += xor % 2 # increase ham when a 1 is seen\\n            xor >>= 1 # right shift\\n        return ham\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624043,
                "title": "best-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count=0;\\n        while(x!=0 || y!=0){\\n            int p1=0,p2=0;\\n            if((x&1)==1)  p1++;\\n            if((y&1)==1)  p2++;\\n            if(p1!=p2)  count++;\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return count;\\n    }\\n}\\n```\\nPlease Upvote If it helps\\u2764\\nNice to meet you",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count=0;\\n        while(x!=0 || y!=0){\\n            int p1=0,p2=0;\\n            if((x&1)==1)  p1++;\\n            if((y&1)==1)  p2++;\\n            if(p1!=p2)  count++;\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407841,
                "title": "simple-answer",
                "content": "\\npublic class HammingDistance {\\n\\n    public static void main(String[] args) {\\n        System.out.println( hammingDistance(3,1));\\n    }\\n    public static int hammingDistance(int x, int y) {\\n\\n        int totalDiff=0;\\n        String result1 = Integer.toBinaryString(x);\\n        String result2 = Integer.toBinaryString(y);\\n\\n        result1= String.format(\"%32s\",result1).replaceAll(\" \",\"0\");\\n        result2= String.format(\"%32s\",result2).replaceAll(\" \",\"0\");\\n\\n\\n\\n        for (int i = 0; i < result1.length(); i++) {\\n            if(result1.charAt(i)!=result2.charAt(i))\\n                totalDiff++;\\n        }\\n\\n        return totalDiff;\\n\\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\npublic class HammingDistance {\\n\\n    public static void main(String[] args) {\\n        System.out.println( hammingDistance(3,1));\\n    }\\n    public static int hammingDistance(int x, int y) {\\n\\n        int totalDiff=0;\\n        String result1 = Integer.toBinaryString(x);\\n        String result2 = Integer.toBinaryString(y);\\n\\n        result1= String.format(\"%32s\",result1).replaceAll(\" \",\"0\");\\n        result2= String.format(\"%32s\",result2).replaceAll(\" \",\"0\");\\n\\n\\n\\n        for (int i = 0; i < result1.length(); i++) {\\n            if(result1.charAt(i)!=result2.charAt(i))\\n                totalDiff++;\\n        }\\n\\n        return totalDiff;\\n\\n    }\\n}\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2215272,
                "title": "simple-c-solution-100-faster-with-explanation",
                "content": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n\\t\\n        // Through XOR we will get \\'1\\' in result at those position at which corresponding\\n        // bits of x and y are different\\n        int result=x ^ y; \\n        int count=0;\\n        \\n        // Code inside the loop is removing the right most \\n        // bits of result one by one until result becomes 0\\n        // and number of bits we removed from result is our answer.\\n        \\n        while(result!=0)\\n        {\\n            count++;\\n            result=result & (result-1);\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n\\t\\n        // Through XOR we will get \\'1\\' in result at those position at which corresponding\\n        // bits of x and y are different\\n        int result=x ^ y; \\n        int count=0;\\n        \\n        // Code inside the loop is removing the right most \\n        // bits of result one by one until result becomes 0\\n        // and number of bits we removed from result is our answer.\\n        \\n        while(result!=0)\\n        {\\n            count++;\\n            result=result & (result-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2174329,
                "title": "intuition-of-xor",
                "content": "we have to find number of position where corresponding bits are different.so we will see the binary and count where there represtentations are different.first thing should come to mind that we have to use xor,as xor is 1 when we are taking xor of two different bits.so we will use a while loop till one of the x or y is greater than 0 and we will check the x mod 2 and y mod 2 and their xor as we know all odd numbers has last digit as 1 in their binary while even numbers have 0 in their binary, and we will keep adding in res and dividing x and y by 2 and continuing the process.\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int result =0;\\n        while(x>0 || y>0)\\n        {\\n            result = result + ((x%2)^(y%2));\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return result;\\n        \\n    }\\n};\\n```\\nkindly upvote if it help you",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int result =0;\\n        while(x>0 || y>0)\\n        {\\n            result = result + ((x%2)^(y%2));\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126489,
                "title": "faster-than-51-58-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/51d2bf53-6ed0-4dc7-9b93-67375c28a9b7_1654689187.9496613.png)\\n```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n    \\n        return str(bin(x^y)).count(\\'1\\')\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n    \\n        return str(bin(x^y)).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967047,
                "title": "100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int n=x^y,c=0;\\n        while(n!=0)\\n        {\\n            c+=n&1;\\n            n>>=1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int n=x^y,c=0;\\n        while(n!=0)\\n        {\\n            c+=n&1;\\n            n>>=1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875613,
                "title": "hamming-distance-solution-java",
                "content": "class Solution {\\n  public int hammingDistance(int x, int y) {\\n    int ans = 0;\\n\\n    while (x > 0 || y > 0) {\\n      ans += (x & 1) ^ (y & 1);\\n      x >>= 1;\\n      y >>= 1;\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public int hammingDistance(int x, int y) {\\n    int ans = 0;\\n\\n    while (x > 0 || y > 0) {\\n      ans += (x & 1) ^ (y & 1);\\n      x >>= 1;\\n      y >>= 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1836647,
                "title": "bit-operaton-c-faster-than-100-00",
                "content": "```\\n    \\nint hammingDistance(int x, int y) {\\n        \\n        x ^= y;                                      // use XOR to make the bit of X represented as the difference between X and Y as 1,and the same as 0.\\n        int res = 0;\\n        \\n        while(x){                                   // counting bits which is represented \"1\"\\n            res++;\\n            x &= x-1;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n    \\nint hammingDistance(int x, int y) {\\n        \\n        x ^= y;                                      // use XOR to make the bit of X represented as the difference between X and Y as 1,and the same as 0.\\n        int res = 0;\\n        \\n        while(x){                                   // counting bits which is represented \"1\"\\n            res++;\\n            x &= x-1;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1819749,
                "title": "go-100-faster",
                "content": "**Naive Solution**\\nFirst get the binary representation of both the numbers and find the count of different corresponding bits.\\nBoth numbers are different create 2 arrays of length 64 to store the binary representation and iterate over them to find the count of different corresponding bits.\\nThis solution will solve the problem for all test cases but iterating over the array will still take time and this solution still can be improved.\\n\\n**Optimized Solution**\\n\\nThe Bitwise-XOR of both number will give the number which has set bits for the different corresponding bits. Then count the number of set bits to get the hamming distance.\\n\\n\\n```\\nfunc hammingDistance(x int, y int) int {\\n\\t// Bitwise-XOR will give the number which have all the set bits for different corresponding btis\\n\\txor := x ^ y \\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\tr := 0\\n\\t// Calculate the number of set bits\\n\\tfor xor != 0 {\\n\\t\\txor -= xor & (-xor)\\n\\t\\tr++\\n\\t}\\n\\treturn r\\n}\\n\\n```\\n\\nTime Complexity:- **O(log(n))**\\nSpace Complexity:- **O(1)**",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc hammingDistance(x int, y int) int {\\n\\t// Bitwise-XOR will give the number which have all the set bits for different corresponding btis\\n\\txor := x ^ y \\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\tr := 0\\n\\t// Calculate the number of set bits\\n\\tfor xor != 0 {\\n\\t\\txor -= xor & (-xor)\\n\\t\\tr++\\n\\t}\\n\\treturn r\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796051,
                "title": "hamming-distance",
                "content": "Solution 1: (Using Bit Manipulation)\\n\\n\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n\\n        int ans=0;\\n        \\n        while(x || y){ \\n            int bit1 = x&1; \\n            int bit2 = y&1;\\n            \\n            if(bit1!=bit2) ans++;\\n            x>>=1; //x/=2; //x=x/2\\n            y>>=1; //y/=2;\\n        }        \\n        return ans;\\n    }\\n};\\n\\nSolution 2: (Using XOR)\\n\\n\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n\\n        int ans = 0;\\n        \\n         int n=x^y;\\n         while(n){\\n             int r_bit = n & 1;\\n            \\n             if(r_bit == 1) ans++;\\n             n >>=1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n\\n        int ans=0;\\n        \\n        while(x || y){ \\n            int bit1 = x&1; \\n            int bit2 = y&1;\\n            \\n            if(bit1!=bit2) ans++;\\n            x>>=1; //x/=2; //x=x/2\\n            y>>=1; //y/=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1734079,
                "title": "3-line-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n     int ans=x^y;\\n        return __builtin_popcount(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n     int ans=x^y;\\n        return __builtin_popcount(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682894,
                "title": "a-simple-and-easy-to-understand-solution-in-c-using-bit-manipulation",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while(x>0 or y>0){\\n            int d1 = x&1;\\n            int d2 = y&1;\\n            if(d1 != d2)\\n                count++;\\n            x = x>>1;\\n            y = y>>1;\\n                        \\n        }\\n        return count;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while(x>0 or y>0){\\n            int d1 = x&1;\\n            int d2 = y&1;\\n            if(d1 != d2)\\n                count++;\\n            x = x>>1;\\n            y = y>>1;\\n                        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1625372,
                "title": "runs-faster-than-100-of-submissions-c",
                "content": "\\n```\\nint countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n > 0)\\n        {\\n            n = n & (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int hammingDistance(int x, int y) {\\n        return countSetBits(x^y);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n > 0)\\n        {\\n            n = n & (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int hammingDistance(int x, int y) {\\n        return countSetBits(x^y);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591635,
                "title": "java-one-liner-100-faster",
                "content": "class Solution {\\n    public int hammingDistance(int x, int y) {\\n     \\n        return Integer.bitCount(x^y);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "class Solution {\\n    public int hammingDistance(int x, int y) {\\n     \\n        return Integer.bitCount(x^y);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1586573,
                "title": "c-easy-faster-than-100",
                "content": "What we do here is that we first convert x and y to binary string, then for each character we compare the bits, if they aren\\'t equal then we increment the return value.\\n```\\nint hammingDistance(int x, int y) {\\n        int ret = 0;\\n        std::string xS = std::bitset<32>(x).to_string(); //Convert the number to a binary string\\n        std::string yS = std::bitset<32>(y).to_string(); //Convert the number to a binary string.\\n        \\n        for (int i = 0; i < 32; i++) { //Since the string will be 32 characters long.\\n            if (xS[i] != yS[i]) ret++; //If the characters of the strings at that index aren\\'t equal then increment the result\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hammingDistance(int x, int y) {\\n        int ret = 0;\\n        std::string xS = std::bitset<32>(x).to_string(); //Convert the number to a binary string\\n        std::string yS = std::bitset<32>(y).to_string(); //Convert the number to a binary string.\\n        \\n        for (int i = 0; i < 32; i++) { //Since the string will be 32 characters long.\\n            if (xS[i] != yS[i]) ret++; //If the characters of the strings at that index aren\\'t equal then increment the result\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585929,
                "title": "using-xor-operation",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int result = x ^ y;\\n        int count = 0;\\n        \\n        while(result > 0){\\n            count += result & 1;\\n            result >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int result = x ^ y;\\n        int count = 0;\\n        \\n        while(result > 0){\\n            count += result & 1;\\n            result >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585568,
                "title": "c-2-liner-faster-than-100",
                "content": "Firstly, thanks for refering to my solution :)\\n\\n**APPROACH :** Using __builtin_popcount()\\n*    Time Complexity : O(m) where \\'m\\' is the no. of bits in the \\'xOR\\'.\\n*    Space Complexity : O(1)\\n\\n  **Code :**\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int xOR = x^y;  //XOR of 2 numbers only sets those bits which are different in both the input numbers. So, count the number of set bits in XOR will give us the hamming distance.\\n        return __builtin_popcount(xOR);\\n    }\\n};\\n```\\n\\nThis could also be done by using the following function instead of using the builtin function\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int xOR = x^y;\\n        return countSetBits(xOR)\\n    }\\n\\t\\n\\tint countSetBits(int num){\\n\\t\\tint count=0;\\n\\t\\twhile(num>0){\\n\\t\\t\\tcount+=num&1\\n\\t\\t\\tnum=num>>1;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```\\n\\n**Please upvote if you like my solution :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int xOR = x^y;  //XOR of 2 numbers only sets those bits which are different in both the input numbers. So, count the number of set bits in XOR will give us the hamming distance.\\n        return __builtin_popcount(xOR);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int xOR = x^y;\\n        return countSetBits(xOR)\\n    }\\n\\t\\n\\tint countSetBits(int num){\\n\\t\\tint count=0;\\n\\t\\twhile(num>0){\\n\\t\\t\\tcount+=num&1\\n\\t\\t\\tnum=num>>1;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585493,
                "title": "c-solution-100-faster-approach-using-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        bitset<32>n1(x),n2(y);\\n        int count=0;\\n        for(int i=0;i<32;i++) if(n1[i]!=n2[i]) count++;\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        bitset<32>n1(x),n2(y);\\n        int count=0;\\n        for(int i=0;i<32;i++) if(n1[i]!=n2[i]) count++;\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1585453,
                "title": "explanation-c-solution-beat-100-bit-manipulation",
                "content": "***This explanation is for those who is very beginner in bit manipulation.***\\n* We use XOR of x and y here b/c in XOR, the truth table is\\n \\t0 ^ 0 = 0\\n \\t0 ^ 1 = 1\\n \\t1 ^ 0 = 1\\n \\t1 ^ 1 = 0\\n\\t\\n\\tThis represents that if the values are same, then it return 0 and if they are different, it return 1. When we do XOR of x and y, then it will return a number that contain 1 at all the places where the value of bits are different in x and y.\\n\\t\\n* \\tNow the task is calculate number of 1s. For this we can perform AND operation of resultant number with (1<<i) for i -> 1 to 31, but another way of counting 1s, which is very easy is using [Brian Kernighan\\u2019s algorithm](https://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/).\\n\\n\\n* \\tWhile the value of n is greater than 0, we apply AND operation of this number with number 1 smaller than it and store it in the same number. Everytime, we perform this operation, one of the bit, having value 1, becomes 0.\\n\\t\\n```\\nint hammingDistance(int x, int y) {\\n        x = (x^y);\\n        int cnt = 0;\\n        while(x) {\\n            x = (x&(x-1));\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint hammingDistance(int x, int y) {\\n        x = (x^y);\\n        int cnt = 0;\\n        while(x) {\\n            x = (x&(x-1));\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581466,
                "title": "easy-c-solution-100-faster",
                "content": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        string s=\"\",t=\"\";\\n        \\n        for(int i=31;i>=0;i--){\\n            if(x&(1<<i))s+=\\'1\\';\\n            else\\n                s+=\\'0\\';\\n            if(y&(1<<i)) t+=\\'1\\';\\n            else\\n                t+=\\'0\\';\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<=31;i++)\\n        {\\n            if(s[i]!=t[i])\\n                ans++;\\n        }\\n       return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        string s=\"\",t=\"\";\\n        \\n        for(int i=31;i>=0;i--){\\n            if(x&(1<<i))s+=\\'1\\';\\n            else\\n                s+=\\'0\\';\\n            if(y&(1<<i)) t+=\\'1\\';\\n            else\\n                t+=\\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1560946,
                "title": "cpp-solution-bit-manipulation-100-fast-ans-easy",
                "content": "```\\n\\t\\tint n = x^y;\\n        int count = 0;\\n        while(n) {\\n            count += (n&1);\\n            n >>= 1;\\n        }\\n        \\n        return count;\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tint n = x^y;\\n        int count = 0;\\n        while(n) {\\n            count += (n&1);\\n            n >>= 1;\\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1503245,
                "title": "100-fast-sol-c-bit-manipulation-xor",
                "content": "//Approach : 1 ) XOR Between the Numbers would give 1 at that places where bits are different.\\n//                   2 ) Counting the Set bits in the number from step (1) would give hamming distance.\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n       int res=x^y,count=0;\\n        while(res)\\n        {\\n            if(res&1)\\n                count++;\\n            res=res>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n       int res=x^y,count=0;\\n        while(res)\\n        {\\n            if(res&1)\\n                count++;\\n            res=res>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425230,
                "title": "java-100-using-shift-operators",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while(x!=0 || y!=0){\\n            boolean a = 1==(1&x);\\n            boolean b = 1==(1&y);\\n            if(a!=b)\\n                count++;\\n            x = x>>1;\\n            y = y>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int count = 0;\\n        while(x!=0 || y!=0){\\n            boolean a = 1==(1&x);\\n            boolean b = 1==(1&y);\\n            if(a!=b)\\n                count++;\\n            x = x>>1;\\n            y = y>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378600,
                "title": "fastest-c-solution-with-x86-assembly",
                "content": "```c\\n__asm__(\".globl hammingDistance\\\\nhammingDistance:\\\\nxor %esi, %edi\\\\npopcnt %edi, %eax\\\\nret\");\\n```\\nTechnically the best solution in C only 3 assembly instructions. The Code first finds the difference between the two inputs with an xor, and then counts the different bits with popcnt. Only works on Linux.",
                "solutionTags": [],
                "code": "```c\\n__asm__(\".globl hammingDistance\\\\nhammingDistance:\\\\nxor %esi, %edi\\\\npopcnt %edi, %eax\\\\nret\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347647,
                "title": "python-solution-using-bit-manipulation-runtime-100-00-faster",
                "content": "XOR operation will find out the uncommon set bits. \\n```\\n\\t\\tresult = x ^ y #this operation will help in getting the uncommon set bits\\n        count = 0\\n        while result > 0: # counting the number of set bits\\n            if result & 1 == 1: #AND operation with 1\\n                count = count + 1\\n            result = result >> 1 # right shift the number as AND operation is performed for a single last bit\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\t\\tresult = x ^ y #this operation will help in getting the uncommon set bits\\n        count = 0\\n        while result > 0: # counting the number of set bits\\n            if result & 1 == 1: #AND operation with 1\\n                count = count + 1\\n            result = result >> 1 # right shift the number as AND operation is performed for a single last bit\\n        return count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300440,
                "title": "java-0ms-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/1b6e3767-cc6e-4b27-8f4a-2c3a3e39a02b_1624793244.6105337.png)\\n\\n```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n     int res=x^y;\\n     int cnt=0;\\n        while(res>0){\\n            cnt+=(res&1);\\n            res>>=1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n     int res=x^y;\\n     int cnt=0;\\n        while(res>0){\\n            cnt+=(res&1);\\n            res>>=1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282301,
                "title": "simple-java-solution-100-faster-without-using-integer-bitcount",
                "content": "\\tpublic int CountNumberofSetBit(int n){\\n\\t//      -n ==2\\'s Complement\\n\\t\\t\\tint counter=0;\\n\\t\\t\\twhile (n!=0){\\n\\t\\t\\t\\tint temp = n & -n;\\n\\t\\t\\t\\tn-=temp;\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t\\treturn(counter);\\n\\t\\t}\\n\\t\\tpublic int hammingDistance(int x, int y) {\\n\\t\\t\\treturn CountNumberofSetBit(x^y); \\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int CountNumberofSetBit(int n){\\n\\t//      -n ==2\\'s Complement\\n\\t\\t\\tint counter=0;\\n\\t\\t\\twhile (n!=0){\\n\\t\\t\\t\\tint temp = n & -n;\\n\\t\\t\\t\\tn-=temp;\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t\\treturn(counter);\\n\\t\\t}\\n\\t\\tpublic int hammingDistance(int x, int y) {\\n\\t\\t\\treturn CountNumberofSetBit(x^y); \\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1247645,
                "title": "c-simple-xor-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint hammingDistance(int x, int y) {\\n\\t\\t\\tint n = x ^ y;\\n\\t\\t\\tint res = 0; \\n\\t\\t\\twhile(n){ \\n\\t\\t\\t\\tres += n & 1; \\n\\t\\t\\t\\tn >>= 1; \\n\\t\\t\\t}\\n\\t\\t\\treturn res;         \\n\\t\\t}\\n\\t};\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint hammingDistance(int x, int y) {\\n\\t\\t\\tint n = x ^ y;\\n\\t\\t\\tint res = 0; \\n\\t\\t\\twhile(n){ \\n\\t\\t\\t\\tres += n & 1; \\n\\t\\t\\t\\tn >>= 1; \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1212363,
                "title": "c-best-solution",
                "content": "```\\nint hammingDistance(int x, int y) {\\n        int xxory=x^y;\\n        int res=0;\\n        while(xxory!=0){\\n            xxory-=(xxory&(-xxory));    //gives the least significant set bit\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint hammingDistance(int x, int y) {\\n        int xxory=x^y;\\n        int res=0;\\n        while(xxory!=0){\\n            xxory-=(xxory&(-xxory));    //gives the least significant set bit\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1159995,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int[] binaryX = decToB(x);\\n        int[] binaryY = decToB(y);\\n        int count = 0;\\n        for(int i = 0; i<31; i++){\\n            count += binaryX[i] == binaryY[i] ? 0 : 1;\\n        }\\n        return count;\\n        \\n    }\\n    \\n    private int[] decToB(int x){\\n        int i = 0; \\n        var bruh = new int[31];\\n        while(x>0){\\n            bruh[i] = x%2;\\n            x /= 2;\\n            i++;\\n        }\\n        return bruh;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        int[] binaryX = decToB(x);\\n        int[] binaryY = decToB(y);\\n        int count = 0;\\n        for(int i = 0; i<31; i++){\\n            count += binaryX[i] == binaryY[i] ? 0 : 1;\\n        }\\n        return count;\\n        \\n    }\\n    \\n    private int[] decToB(int x){\\n        int i = 0; \\n        var bruh = new int[31];\\n        while(x>0){\\n            bruh[i] = x%2;\\n            x /= 2;\\n            i++;\\n        }\\n        return bruh;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150266,
                "title": "python-1-line",
                "content": "```python\\nreturn bin(x ^ y).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nreturn bin(x ^ y).count(\\'1\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099438,
                "title": "python-one-liner-easy-solution-and-self-explanatory",
                "content": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return bin(x^y).replace(\"0b\",\"\").count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        return bin(x^y).replace(\"0b\",\"\").count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065640,
                "title": "c-very-easy-and-important-bit-concept",
                "content": "Let\\'s take an example\\nx=1\\ny=4\\n\\nx= 0001\\ny= 0100\\n\\nxorVal=x^y\\nx =     0 0 0 1\\ny =     0 1 0 0\\nx^y = 0 1 0 1\\n\\nAnswer should be 2 in this case.\\nSo we find the number of set bits in xorVal(x^y) using the Hamming Weight Concept\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int xorVal=x^y;\\n        int count=0;\\n        while(xorVal)\\n        {\\n            if(xorVal&1)\\n                count++;\\n            xorVal>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int xorVal=x^y;\\n        int count=0;\\n        while(xorVal)\\n        {\\n            if(xorVal&1)\\n                count++;\\n            xorVal>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053868,
                "title": "c-1-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n       return bitset<32>(x^y).count();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n       return bitset<32>(x^y).count();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943245,
                "title": "python-3-28ms",
                "content": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        #corner case\\n        #\\n        return sum(1 for i in bin(x^y) if i == \"1\")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingDistance(self, x: int, y: int) -> int:\\n        #corner case\\n        #\\n        return sum(1 for i in bin(x^y) if i == \"1\")\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565110,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1573362,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1567269,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1567270,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1569560,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1575982,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1574778,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1574012,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1573644,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1571735,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1565110,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1573362,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1567269,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1567270,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1569560,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1575982,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1574778,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1574012,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1573644,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            },
            {
                "id": 1571735,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/hamming-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in BitCounting Functions\n\n  \n**Approach 2:** Bit Shift\n\n  \n**Approach 3:** Brian Kernighan's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "salfire",
                        "content": "discussion room is to discuss the algorithm, not to post solution, please try giving suggestions, link to algorithms or ideas to solve.\\nThis is such a easy problem, took long time to understand.\\nwhen we do XOR of numbers it will say if the return bits as 1 if they are different, basically you need to count how many bits are different."
                    },
                    {
                        "username": "spronck",
                        "content": "I added a variety of solutions all of which passed, but the solution that ran quickest on an independent benchmarker was rated as less than average (only above 43%).\\n\\nWhen I benchmarked the best answer as given by leetCode it was ~40 times slower on the independent benchmark. \\n\\nI followed through and re-submitted my best answer and got results from 93% to 43%\\n\\nI submitted the leetCode best and got results of 82% to 53%\\n\\nWhy is the execution time so inaccurate?\\nWhy is a clearly slow answer rated as the best?\\nWhy does the same code have such a varied execution time?"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "same in 2023\\n"
                    },
                    {
                        "username": "sl314",
                        "content": "Can someone look into the compiler for Scala? It seems to be significantly slower than other languages. For example, the exact same one line solution for this problem:\\n\\nInteger.bitCount(x ^ y);\\n\\ncomputes in **11ms in Java**, but **478 ms in Scala!** \\n\\nI ran this simple problem as a test because my solutions in Scala for more complex problems always end with \"Time Limit Exceeded\". I hope the Scala time limit can be increased in general so people can actually use the language. \\n\\nThanks."
                    },
                    {
                        "username": "workofart",
                        "content": "`sum([int(i) for i in list(f\\'{x^y:08b}\\')])`\\n\\n`x^y` takes the XOR of the two numbers, in other words, where digits are different, XOR will return 1.\\n\\n`f\\'{x^y:08b}\\'` formats the string into zero-padded string (E.g. \\'00000110\\')\\n\\n`list()` converts the string into a list, where each element is each digit (E.g. [\\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\', \\'1\\', \\'0\\'])\\n\\n`int(i) for i in list` converts each element from string to integer\\n\\n`sum(list)` takes the sum of the digits, in this case, this will be the number of digits that are different between `x` and `y`\\n\\n"
                    },
                    {
                        "username": "CH_Wu",
                        "content": "\\tint hammingDistance(int x, int y) {\\n\\t\\treturn __builtin_popcount(x ^ y);\\n\\t}"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn bin(x ^ y).count(\\'1\\')"
                    },
                    {
                        "username": "jotrades",
                        "content": "The idea for bitwise comes from the fact that the question says we have to count number of bits which are different between two numbers.\\n\\nSince we have to count, we first do a XOR of x and y, after taking XOR we make sure that where ever we see a 1, those are the corresponding postions in the orignal x and y where the bits are different.\\n\\nNow the problem reduces to merely counting the the number of set bits after taking XOR.\\nThere are many ways to do it. But lets do it in a bitwise manner,\\n\\nIf we are somehow able to count the rightmost set bits one by one we have solved the problem\\nSo idea is to ,make the right most bit to zero and have a counter \\nfor example lets say the number is 7(0111)\\n0111->0110->0100->0000 **making right most bit 0 everytime we loop**\\n  0    ->   1  ->    2  -> 3   **counter**\\nto do this we subtract 1 from the number everytime and take a bitwise AND , cause when we subtact we make sure we unset the rightmost bit and set all the bit to the right of the rightmost bit  and bitwise AND to unset all the set bits after the righmost 1(after we subtract)\\nFor example\\n0110(6)\\nthe aim is to make it to 0100\\nwhen we subtract 1 we get 0101(5)\\nand when we do a bitwise AND it we get 0100(6 ^ 5)\\nRepeat till the number becomes zero and have a counter\\n"
                    },
                    {
                        "username": "meirlo",
                        "content": "return Integer.bitCount(x^y);"
                    },
                    {
                        "username": "wlf92",
                        "content": "func hammingDistance(x int, y int) int {\\n\\tnCount := 0\\n\\tfor r := x ^ y; r != 0; r >>= 1 {\\n\\t\\tif r&1 == 1 {\\n\\t\\t\\tnCount++\\n\\t\\t}\\n\\t}\\n\\treturn nCount\\n}"
                    }
                ]
            }
        ]
    }
]