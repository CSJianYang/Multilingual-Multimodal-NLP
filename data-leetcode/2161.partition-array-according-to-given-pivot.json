[
    {
        "title": "Partition Array According to Given Pivot",
        "question_content": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\n\tEvery element less than pivot appears before every element greater than pivot.\n\tEvery element equal to pivot appears in between the elements less than and greater than pivot.\n\tThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\n\t\tMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\t\n\t\n\nReturn nums after the rearrangement.\n&nbsp;\nExample 1:\n\nInput: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.\n\nExample 2:\n\nInput: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-106 <= nums[i] <= 106\n\tpivot equals to an element of nums.",
        "solutions": [
            {
                "id": 1747115,
                "title": "solution-for-c-three-pointers-o-n",
                "content": "```cpp\\nclass Solution\\n{\\npublic:\\n    vector<int> pivotArray(vector<int> &nums, int pivot)\\n    {\\n        int low = 0;\\n        int same = 0;\\n        int high;\\n        for (auto n : nums)\\n        {\\n            if (n < pivot)\\n            {\\n                ++low;\\n            }\\n            else if (n == pivot)\\n            {\\n                ++same;\\n            }\\n        }\\n        vector<int> res(nums.size());\\n        high = same + low;\\n        same = low;\\n        low = 0;\\n        for (auto n : nums)\\n        {\\n            if (n < pivot)\\n            {\\n                res[low++] = n;\\n            }\\n            else if (n == pivot)\\n            {\\n                res[same++] = n;\\n            }\\n            else\\n            {\\n                res[high++] = n;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n    vector<int> pivotArray(vector<int> &nums, int pivot)\\n    {\\n        int low = 0;\\n        int same = 0;\\n        int high;\\n        for (auto n : nums)\\n        {\\n            if (n < pivot)\\n            {\\n                ++low;\\n            }\\n            else if (n == pivot)\\n            {\\n                ++same;\\n            }\\n        }\\n        vector<int> res(nums.size());\\n        high = same + low;\\n        same = low;\\n        low = 0;\\n        for (auto n : nums)\\n        {\\n            if (n < pivot)\\n            {\\n                res[low++] = n;\\n            }\\n            else if (n == pivot)\\n            {\\n                res[same++] = n;\\n            }\\n            else\\n            {\\n                res[high++] = n;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747184,
                "title": "java-python-3-2-methods-w-brief-explanation-and-analysis",
                "content": "**Method 1:**\\n\\n1. Copy elements < pivot and count the occurrent of `pivot`\\'s;\\n2. Copy all `pivot`\\'s;\\n3. Copy elements > pivot.\\n\\n```java\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n        int n = nums.length, pivotFreq = 0, i = 0;\\n        int[] ans = new int[n];\\n        \\n        for (int num : nums) {\\n            if (num < pivot) {\\n                ans[i++] = num;\\n            }else if (num == pivot) {\\n                ++pivotFreq;\\n            } \\n        }\\n        \\n        while (pivotFreq-- > 0) {\\n            ans[i++] = pivot;\\n        }\\n        \\n        for (int num : nums) {\\n            if (num > pivot) {\\n                ans[i++] = num;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n```python\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        pivotFreq, ans = 0, []\\n        \\n        for num in nums:\\n            if num < pivot:\\n                ans.append(num)\\n            elif num == pivot:\\n                pivotFreq += 1\\n                \\n        ans.extend([pivot] * pivotFreq)\\n        \\n        for num in nums:\\n            if num > pivot:\\n                ans.append(num)        \\n                \\n        return ans\\n```\\n\\n----\\n \\n **Method 2: 4 pointers**\\n \\n1. Traverse from left and right ends, copy to the ends of the output array the items that smaller and bigger than `pivot`, respectively.\\n2. The remainings are all `pivot`.\\n```java\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int left = 0, right = n - 1;\\n        for (int i = 0, j = n - 1; i < n; ++i, --j) {\\n            if (nums[i] < pivot) {\\n                ans[left++] = nums[i];\\n            }\\n            if (nums[j] > pivot) {\\n                ans[right--] = nums[j];\\n            }\\n        }\\n        while (left <= right) {\\n            ans[left++] = pivot;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Q & A**\\nQ: What does `nums[~i]` in the following Python 3 code mean?\\n\\nA:  `~i = -i - 1`.\\nWhen `i` traverses from `0` to `n - 1`, `~i` traverses form `-1` to `-n`, correspondingly. \\nIn short, `i` traverses from left to right, and `~i` traverses from right to left.\\n\\n**End of Q & A**\\n\\n\\n```python\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        n = len(nums)\\n        ans = [pivot] * n\\n        left, right = 0, -1\\n        for i, num in enumerate(nums):\\n            if num < pivot:\\n                ans[left], left = num, left + 1\\n            if nums[~i] > pivot:\\n                ans[right], right = nums[~i], right - 1\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`.",
                "solutionTags": [],
                "code": "```java\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n        int n = nums.length, pivotFreq = 0, i = 0;\\n        int[] ans = new int[n];\\n        \\n        for (int num : nums) {\\n            if (num < pivot) {\\n                ans[i++] = num;\\n            }else if (num == pivot) {\\n                ++pivotFreq;\\n            } \\n        }\\n        \\n        while (pivotFreq-- > 0) {\\n            ans[i++] = pivot;\\n        }\\n        \\n        for (int num : nums) {\\n            if (num > pivot) {\\n                ans[i++] = num;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```python\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        pivotFreq, ans = 0, []\\n        \\n        for num in nums:\\n            if num < pivot:\\n                ans.append(num)\\n            elif num == pivot:\\n                pivotFreq += 1\\n                \\n        ans.extend([pivot] * pivotFreq)\\n        \\n        for num in nums:\\n            if num > pivot:\\n                ans.append(num)        \\n                \\n        return ans\\n```\n```java\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int left = 0, right = n - 1;\\n        for (int i = 0, j = n - 1; i < n; ++i, --j) {\\n            if (nums[i] < pivot) {\\n                ans[left++] = nums[i];\\n            }\\n            if (nums[j] > pivot) {\\n                ans[right--] = nums[j];\\n            }\\n        }\\n        while (left <= right) {\\n            ans[left++] = pivot;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        n = len(nums)\\n        ans = [pivot] * n\\n        left, right = 0, -1\\n        for i, num in enumerate(nums):\\n            if num < pivot:\\n                ans[left], left = num, left + 1\\n            if nums[~i] > pivot:\\n                ans[right], right = nums[~i], right - 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1752535,
                "title": "inplace-nlogn",
                "content": "**divide and conquer**\\n**time: `O(NlogN)`; space: `O(1)`**\\n```\\nvector<int> pivotArray(vector<int>& n, int p) \\n{\\n\\tfor(int d{2}; d<2*size(n); d<<=1)\\n\\t\\tfor(auto b{begin(n)}, m{b}, e{b}; b<end(n); b=e)\\n\\t\\t{\\n\\t\\t\\tm = min(b+d/2, end(n)),\\n\\t\\t\\te = min(b+d,   end(n));\\n\\t\\t\\tauto l = lower_bound(b, m, p),\\n\\t\\t\\t\\t h = upper_bound(m, e, p);\\n\\t\\t\\trotate(l, m, h);\\n\\t\\t}\\n\\treturn n;\\n}\\n```\\n**Notation:**\\n`d` - current chunk size (power of two) `= 2,4,8...`;\\n`b` - **b**eginning of the merge chunk;\\n`m` - **m**iddle of the merge chunk;\\n`e` - **e**nd of the merge chunk;\\n`l` and `h` come from \"**l**ow\" and \"**h**igh\".\\n\\n\\n\\n\\n<br>\\nDivide and conquer technique example:\\n\\n![image](https://assets.leetcode.com/users/images/979172d3-7ce1-48a5-8791-5a3f83e74c53_1644324325.273362.png)\\n\\n<br>\\n<br>\\n\\nSingle \"merge\" operation example:\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/bab7e9ae-9f12-4096-a7ff-5c2584071652_1644281995.6568372.png)\\n\\n<br>\\n\\nAnother problem that uses partition as a subproblem [2149.  Rearrange Array Elements by Sign](https://leetcode.com/problems/rearrange-array-elements-by-sign/discuss/1729673/4-solutions)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> pivotArray(vector<int>& n, int p) \\n{\\n\\tfor(int d{2}; d<2*size(n); d<<=1)\\n\\t\\tfor(auto b{begin(n)}, m{b}, e{b}; b<end(n); b=e)\\n\\t\\t{\\n\\t\\t\\tm = min(b+d/2, end(n)),\\n\\t\\t\\te = min(b+d,   end(n));\\n\\t\\t\\tauto l = lower_bound(b, m, p),\\n\\t\\t\\t\\t h = upper_bound(m, e, p);\\n\\t\\t\\trotate(l, m, h);\\n\\t\\t}\\n\\treturn n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747113,
                "title": "easy-solution-you-will-understand-this-soln-in-just-5sec-guaranteed",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int ans[] = new int[nums.length];\\n        \\n        \\n        int i = 0;\\n        \\n        // first fill smaller element\\n        for(int n : nums){\\n            if(n < pivot) ans[i++] = n;  \\n        }\\n        \\n        \\n        // now fill pivot\\n        for(int n : nums){\\n            if(n == pivot) ans[i++] = n;  \\n        }\\n        \\n        \\n        // Now fill Greater element\\n        for(int n : nums){\\n            if(n > pivot){\\n                ans[i++] = n;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```\\n\\n### Solution in Cpp with only single traversal.****\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> less;\\n        vector<int> greater;\\n        vector<int> equal;\\n        \\n            for(int i=0;i<nums.size();i++)\\n            {\\n            \\n                    if(nums[i]<pivot){\\n                        less.push_back(nums[i]);\\n                    }\\n\\n                    else if(nums[i]>pivot){\\n                        greater.push_back(nums[i]);\\n                    }\\n\\n                    else if(nums[i]==pivot){\\n                        equal.push_back(nums[i]);\\n                    }\\n            \\n        }\\n        \\n        less.insert(less.end(),equal.begin(),equal.end());\\n        less.insert(less.end(),greater.begin(),greater.end());\\n        \\n        return less;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int ans[] = new int[nums.length];\\n        \\n        \\n        int i = 0;\\n        \\n        // first fill smaller element\\n        for(int n : nums){\\n            if(n < pivot) ans[i++] = n;  \\n        }\\n        \\n        \\n        // now fill pivot\\n        for(int n : nums){\\n            if(n == pivot) ans[i++] = n;  \\n        }\\n        \\n        \\n        // Now fill Greater element\\n        for(int n : nums){\\n            if(n > pivot){\\n                ans[i++] = n;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> less;\\n        vector<int> greater;\\n        vector<int> equal;\\n        \\n            for(int i=0;i<nums.size();i++)\\n            {\\n            \\n                    if(nums[i]<pivot){\\n                        less.push_back(nums[i]);\\n                    }\\n\\n                    else if(nums[i]>pivot){\\n                        greater.push_back(nums[i]);\\n                    }\\n\\n                    else if(nums[i]==pivot){\\n                        equal.push_back(nums[i]);\\n                    }\\n            \\n        }\\n        \\n        less.insert(less.end(),equal.begin(),equal.end());\\n        less.insert(less.end(),greater.begin(),greater.end());\\n        \\n        return less;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747590,
                "title": "4-solutions",
                "content": "### 1. Stable Partition\\n**C++**\\n```c++\\nvector<int> pivotArray(vector<int>& n, int p) {\\n    stable_partition(stable_partition(begin(n), end(n), [&](int n){ return n < p; }), end(n), [&](int n){ return n == p; });\\n    return n;\\n}\\n```\\n### 2. 3 passes, 1 array\\n**Python 3**\\n```python\\nclass Solution:\\n    def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```\\n\\n**C++**\\n```cpp\\nvector<int> pivotArray(vector<int>& n, int p) {\\n    vector<int> res;\\n    copy_if(begin(n), end(n), back_inserter(res), [&](int n){ return n < p; });\\n    copy_if(begin(n), end(n), back_inserter(res), [&](int n){ return n == p; });\\n    copy_if(begin(n), end(n), back_inserter(res), [&](int n){ return n > p; });\\n    return res;\\n}\\n```\\n\\n### 3. 1.5 pass, 3 arrays\\nFirst pass is to populate 3 arrays. We also need another pass (0.5 elements in average) to merge those arrays.\\n**C++**\\n```cpp\\nvector<int> pivotArray(vector<int>& n, int p) {\\n    vector<int> res[3] = {};\\n    for (int n : n)\\n        res[n < p ? 0 : n == p ? 1 : 2].push_back(n);\\n    res[0].insert(end(res[0]), begin(res[1]), end(res[1]));\\n    res[0].insert(end(res[0]), begin(res[2]), end(res[2]));\\n    return res[0];\\n}\\n```\\n### 4. 2 passes, 1 array\\nCount numbers less than, and equal to the pivot. \\n\\nThose counts define positions where we insert numbers equal to the pivot (`eq`) and greater than the pivot (`hi`). The numbers smaller than the pivot (`lo`) are filled starting from `0`, obviously :)\\n**C++**\\n```cpp\\nvector<int> pivotArray(vector<int> &n, int p) {\\n\\tvector<int> res(n.size());\\n\\t  int lo = 0, eq = count_if(begin(n), end(n), [&](int n) { return n < p; }),\\n\\t\\t  hi = eq + count(begin(n), end(n), p);\\n\\t  for (int n : n)\\n\\t\\tres[n < p ? lo++ : n == p ? eq++ : hi++] = n;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```c++\\nvector<int> pivotArray(vector<int>& n, int p) {\\n    stable_partition(stable_partition(begin(n), end(n), [&](int n){ return n < p; }), end(n), [&](int n){ return n == p; });\\n    return n;\\n}\\n```\n```python\\nclass Solution:\\n    def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return [n for n in nums if n < p] + [n for n in nums if n == p] + [n for n in nums if n > p]\\n```\n```cpp\\nvector<int> pivotArray(vector<int>& n, int p) {\\n    vector<int> res;\\n    copy_if(begin(n), end(n), back_inserter(res), [&](int n){ return n < p; });\\n    copy_if(begin(n), end(n), back_inserter(res), [&](int n){ return n == p; });\\n    copy_if(begin(n), end(n), back_inserter(res), [&](int n){ return n > p; });\\n    return res;\\n}\\n```\n```cpp\\nvector<int> pivotArray(vector<int>& n, int p) {\\n    vector<int> res[3] = {};\\n    for (int n : n)\\n        res[n < p ? 0 : n == p ? 1 : 2].push_back(n);\\n    res[0].insert(end(res[0]), begin(res[1]), end(res[1]));\\n    res[0].insert(end(res[0]), begin(res[2]), end(res[2]));\\n    return res[0];\\n}\\n```\n```cpp\\nvector<int> pivotArray(vector<int> &n, int p) {\\n\\tvector<int> res(n.size());\\n\\t  int lo = 0, eq = count_if(begin(n), end(n), [&](int n) { return n < p; }),\\n\\t\\t  hi = eq + count(begin(n), end(n), p);\\n\\t  for (int n : n)\\n\\t\\tres[n < p ? lo++ : n == p ? eq++ : hi++] = n;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123066,
                "title": "java-two-pointers-faster-than-98-easy-and-simple-solution",
                "content": "```\\n// Time complexity = 2n = O(n)\\n// Space complexity = O(1), or O(n) if the result array is including in the complexity analysis.\\n\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] result = new int[nums.length];\\n        int left = 0, right = nums.length - 1;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] < pivot) {\\n                result[left++] = nums[i];\\n            }\\n            if(nums[nums.length - 1 - i] > pivot) {\\n                result[right--] = nums[nums.length - 1 - i];\\n            }\\n        }\\n        \\n        while(left <= right) {\\n            result[left++] = pivot;\\n            result[right--] = pivot;\\n        }\\n        \\n        return result;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity = 2n = O(n)\\n// Space complexity = O(1), or O(n) if the result array is including in the complexity analysis.\\n\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] result = new int[nums.length];\\n        int left = 0, right = nums.length - 1;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] < pivot) {\\n                result[left++] = nums[i];\\n            }\\n            if(nums[nums.length - 1 - i] > pivot) {\\n                result[right--] = nums[nums.length - 1 - i];\\n            }\\n        }\\n        \\n        while(left <= right) {\\n            result[left++] = pivot;\\n            result[right--] = pivot;\\n        }\\n        \\n        return result;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019049,
                "title": "java-stream",
                "content": "```\\npublic int[] pivotArray(int[] nums, int pivot) {\\n        return Stream.of(Arrays.stream(nums).filter(e -> e < pivot),\\n                Arrays.stream(nums).filter(e -> e == pivot),\\n                Arrays.stream(nums).filter(e -> e > pivot))\\n                .flatMapToInt(x -> x).toArray();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] pivotArray(int[] nums, int pivot) {\\n        return Stream.of(Arrays.stream(nums).filter(e -> e < pivot),\\n                Arrays.stream(nums).filter(e -> e == pivot),\\n                Arrays.stream(nums).filter(e -> e > pivot))\\n                .flatMapToInt(x -> x).toArray();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1746999,
                "title": "c-two-pointers-o-n-time",
                "content": "\\n## Solution 1. Two Pointers\\n\\nThis problem looks like the partitioning process in Quick Sort, but since the efficient partition algorithms (Lomuto\\'s and Hoare\\'s) are not stable, you can\\'t use it here.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-71/problems/partition-array-according-to-given-pivot/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& A, int pivot) {\\n        vector<int> gt; // numbers greater than pivot\\n        int j = 0, cnt = 0; // `j` is the write pointer. `cnt` is the count of numbers equal to pivot\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (A[i] < pivot) A[j++] = A[i];\\n            else if (A[i] == pivot) ++cnt;\\n            else gt.push_back(A[i]);\\n        }\\n        while (cnt--) A[j++] = pivot;\\n        for (int i = 0; i < gt.size(); ++i) A[j++] = gt[i];\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-71/problems/partition-array-according-to-given-pivot/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& A, int pivot) {\\n        vector<int> gt; // numbers greater than pivot\\n        int j = 0, cnt = 0; // `j` is the write pointer. `cnt` is the count of numbers equal to pivot\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (A[i] < pivot) A[j++] = A[i];\\n            else if (A[i] == pivot) ++cnt;\\n            else gt.push_back(A[i]);\\n        }\\n        while (cnt--) A[j++] = pivot;\\n        for (int i = 0; i < gt.size(); ++i) A[j++] = gt[i];\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632906,
                "title": "java-two-pointers",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] pivotArray(int[] nums, int pivot) {\\n\\t\\t\\tint [] res = new int[nums.length];\\n\\t\\t\\tint left=0, right=nums.length-1;\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i]<pivot)\\n\\t\\t\\t\\t\\tres[left++]=nums[i];\\n\\t\\t\\t\\tif(nums[nums.length-i-1]>pivot){\\n\\t\\t\\t\\t\\tres[right--]=nums[nums.length-i-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(left <= right){\\n\\t\\t\\t\\tres[left++]=pivot;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\n    // credit https://leetcode.com/problems/partition-array-according-to-given-pivot/discuss/2123066/Java-two-pointers.-Faster-than-98.-Easy-and-simple-solution.\\n\\t// Java: Two Pointer\\n\\t// Time O(n)\\n\\t// Space O(n)\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[] pivotArray(int[] nums, int pivot) {\\n\\t\\t\\tint [] res = new int[nums.length];\\n\\t\\t\\tint left=0, right=nums.length-1;\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i]<pivot)\\n\\t\\t\\t\\t\\tres[left++]=nums[i];\\n\\t\\t\\t\\tif(nums[nums.length-i-1]>pivot){\\n\\t\\t\\t\\t\\tres[right--]=nums[nums.length-i-1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2480491,
                "title": "simple-js-solution-w-comments-two-pointers",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 434 ms, faster than 67.61% of JavaScript online submissions for Partition Array According to Given Pivot.\\n// Memory Usage: 77.7 MB, less than 85.92% of JavaScript online submissions for Partition Array According to Given Pivot.\\nconst pivotArray = (nums, pivot) => {\\n\\tlet N = nums.length;\\n\\tlet output = [];\\n\\n  // pointers to iterate array from start/end\\n\\tlet i = 0;\\n\\tlet j = N - 1;\\n\\n  // pointers to save elements in correct spot\\n\\tlet L = 0;\\n\\tlet R = N - 1;\\n\\t\\n\\t// select elements starting from start and end of array\\n\\t// add elements to correct spot if conditions are met.\\n\\twhile (i < nums.length) {\\n\\t\\tif (nums[i] < pivot) output[L++] = nums[i];\\n\\t\\tif (nums[j] > pivot) output[R--] = nums[j];\\n\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\n\\t// fill middle with pivot\\n\\twhile (L <= R) {\\n\\t\\toutput[L++] = pivot;\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 434 ms, faster than 67.61% of JavaScript online submissions for Partition Array According to Given Pivot.\\n// Memory Usage: 77.7 MB, less than 85.92% of JavaScript online submissions for Partition Array According to Given Pivot.\\nconst pivotArray = (nums, pivot) => {\\n\\tlet N = nums.length;\\n\\tlet output = [];\\n\\n  // pointers to iterate array from start/end\\n\\tlet i = 0;\\n\\tlet j = N - 1;\\n\\n  // pointers to save elements in correct spot\\n\\tlet L = 0;\\n\\tlet R = N - 1;\\n\\t\\n\\t// select elements starting from start and end of array\\n\\t// add elements to correct spot if conditions are met.\\n\\twhile (i < nums.length) {\\n\\t\\tif (nums[i] < pivot) output[L++] = nums[i];\\n\\t\\tif (nums[j] > pivot) output[R--] = nums[j];\\n\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\n\\t// fill middle with pivot\\n\\twhile (L <= R) {\\n\\t\\toutput[L++] = pivot;\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891401,
                "title": "easy-solution-using-3-pointers-faster-than-others-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    //simple 3pointers approach\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int low=0,same=0,high=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<pivot){\\n                ++low;\\n            }else if(nums[i]==pivot)\\n                ++same;\\n        }\\n        high=low+same;\\n        same=low;\\n        low=0;\\n        vector<int>res(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<pivot){\\n                res[low++]=nums[i];\\n            }else if(nums[i]==pivot){\\n                res[same++]=nums[i];\\n            }else{\\n                res[high++]=nums[i];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    //simple 3pointers approach\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int low=0,same=0,high=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<pivot){\\n                ++low;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1748566,
                "title": "python-simple-and-clean-python-solution-by-removing-and-appending",
                "content": "# If It is Useful To Understand Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n\\n\\t\\t\\tans=[]\\n\\n\\t\\t\\tnums.remove(pivot)\\n\\n\\t\\t\\ti=0\\n\\t\\t\\tans.append(pivot)\\n\\n\\t\\t\\tfor j in nums:\\n\\t\\t\\t\\tif j<pivot:\\n\\t\\t\\t\\t\\tans.insert(i,j)\\n\\t\\t\\t\\t\\ti=i+1\\n\\t\\t\\t\\telif j==pivot:\\n\\t\\t\\t\\t\\tans.insert(i+1,j)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans.append(j)\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If It is Useful To Understand Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n\\n\\t\\t\\tans=[]\\n\\n\\t\\t\\tnums.remove(pivot)\\n\\n\\t\\t\\ti=0\\n\\t\\t\\tans.append(pivot)\\n\\n\\t\\t\\tfor j in nums:\\n\\t\\t\\t\\tif j<pivot:\\n\\t\\t\\t\\t\\tans.insert(i,j)\\n\\t\\t\\t\\t\\ti=i+1\\n\\t\\t\\t\\telif j==pivot:\\n\\t\\t\\t\\t\\tans.insert(i+1,j)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans.append(j)\\n\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 1747363,
                "title": "is-my-post-hidden",
                "content": "I found that this post is only visible to myself now. Link: https://leetcode.com/problems/partition-array-according-to-given-pivot/discuss/1746999\\n\\nI only added a link to Lomuto\\'s and Hoare\\'s for reference. May the admin bring it back? I can delete it if you have concerns to the link to G4G.\\n\\n![image](https://assets.leetcode.com/users/images/32d7fffa-7474-4b68-84ef-aeeedc1684fb_1644079709.5011833.png)\\n\\nThis problem looks similar to the partitioning process in Quick Sort, but since the efficient partition algorithms (Lomuto\\'s and Hoare\\'s) are not stable, you can\\'t use it here.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/partition-array-according-to-given-pivot/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& A, int pivot) {\\n        vector<int> gt; // numbers greater than pivot\\n        int j = 0, cnt = 0; // `j` is the write pointer. `cnt` is the count of numbers equal to pivot\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (A[i] < pivot) A[j++] = A[i];\\n            else if (A[i] == pivot) ++cnt;\\n            else gt.push_back(A[i]);\\n        }\\n        while (cnt--) A[j++] = pivot;\\n        for (int i = 0; i < gt.size(); ++i) A[j++] = gt[i];\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/partition-array-according-to-given-pivot/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& A, int pivot) {\\n        vector<int> gt; // numbers greater than pivot\\n        int j = 0, cnt = 0; // `j` is the write pointer. `cnt` is the count of numbers equal to pivot\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (A[i] < pivot) A[j++] = A[i];\\n            else if (A[i] == pivot) ++cnt;\\n            else gt.push_back(A[i]);\\n        }\\n        while (cnt--) A[j++] = pivot;\\n        for (int i = 0; i < gt.size(); ++i) A[j++] = gt[i];\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315729,
                "title": "java-simple-solution-naive-approach",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int j=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<pivot)\\n                ans[j++] = nums[i];\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==pivot)\\n                ans[j++] = nums[i];\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]>pivot)\\n                ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int j=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<pivot)\\n                ans[j++] = nums[i];\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==pivot)\\n                ans[j++] = nums[i];\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]>pivot)\\n                ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747103,
                "title": "simple-solution-in-java",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n=nums.length,j=0;\\n        int[] res=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]<pivot)\\n                res[j++]=nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==pivot)\\n                res[j++]=nums[i];\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]>pivot)\\n                res[j++]=nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n=nums.length,j=0;\\n        int[] res=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]<pivot)\\n                res[j++]=nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==pivot)\\n                res[j++]=nums[i];\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]>pivot)\\n                res[j++]=nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156389,
                "title": "easy-python3-solution-got-99-12-run-time",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883811,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding out how to handle values greater than pivot and less than pivot is main problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI declared three pointer one for greater than pivot , one for lesser than pivot and one for equal to pivot.\\nBefore actually putting values in res array we have to find out when to put value greater value while iterating in array for this no of all values less and equal to pivot are calculated this is going to our grater pointer same pointer will help to locate equal pointer.\\n\\nWhile iterating the values if we got value less than pivot place it one less Pointer place and increase it. Same approuch for greater pointer\\nBut while handling same value we have to reduce the equal pointer as we located pointer at one less position than greater pointer\\n\\nPlease UPVOTE if liked\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(N)$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] res = new int[nums.length];\\n        int gPoint = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] <= pivot){\\n                gPoint++;\\n            }\\n        }\\n        int lessPoint = 0;\\n        int equPoint = gPoint-1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] < pivot){\\n                res[lessPoint] = nums[i];\\n                lessPoint++;\\n            }else if(nums[i] > pivot){\\n                res[gPoint] = nums[i];\\n                gPoint++;\\n            }else{\\n                res[equPoint] = nums[i];\\n                equPoint--;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] res = new int[nums.length];\\n        int gPoint = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] <= pivot){\\n                gPoint++;\\n            }\\n        }\\n        int lessPoint = 0;\\n        int equPoint = gPoint-1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] < pivot){\\n                res[lessPoint] = nums[i];\\n                lessPoint++;\\n            }else if(nums[i] > pivot){\\n                res[gPoint] = nums[i];\\n                gPoint++;\\n            }else{\\n                res[equPoint] = nums[i];\\n                equPoint--;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358691,
                "title": "java-1-pass-solution-optimized-clean-code",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] result = new int [nums.length] ;\\n        int i = 0, j = nums.length-1, p = i, q = j ;\\n        \\n        while (i < nums.length && j >= 0) {\\n            if (nums[i] < pivot) result[p++] = nums[i] ;\\n            if (nums[j] > pivot) result[q--] = nums[j] ;\\n            i++ ;\\n            j-- ;\\n        }\\n        \\n        while (p <= q) result[p++] = pivot ;\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] result = new int [nums.length] ;\\n        int i = 0, j = nums.length-1, p = i, q = j ;\\n        \\n        while (i < nums.length && j >= 0) {\\n            if (nums[i] < pivot) result[p++] = nums[i] ;\\n            if (nums[j] > pivot) result[q--] = nums[j] ;\\n            i++ ;\\n            j-- ;\\n        }\\n        \\n        while (p <= q) result[p++] = pivot ;\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334256,
                "title": "4-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums, pivot):\\n        n = len(nums)\\n        left = 0\\n        right = n - 1\\n        result = [pivot] * n\\n\\n        for i in range(n):\\n            j = n - 1 - i\\n            if nums[i] < pivot: # i set the value from left to right to maintain origin order\\n                result[left] = nums[i]\\n                left += 1\\n            if nums[j] > pivot: # j set the value from right to left to maintain origin order\\n                result[right] = nums[j]\\n                right -=1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums, pivot):\\n        n = len(nums)\\n        left = 0\\n        right = n - 1\\n        result = [pivot] * n\\n\\n        for i in range(n):\\n            j = n - 1 - i\\n            if nums[i] < pivot: # i set the value from left to right to maintain origin order\\n                result[left] = nums[i]\\n                left += 1\\n            if nums[j] > pivot: # j set the value from right to left to maintain origin order\\n                result[right] = nums[j]\\n                right -=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717890,
                "title": "simple-javascript-solution-98-95",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} pivot\\n * @return {number[]}\\n */\\nvar pivotArray = function(nums, pivot) {\\n    let smaller = [];\\n    let greater = [];\\n    let equal = [];\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] < pivot) smaller.push(nums[i])\\n        else if(nums[i] > pivot) greater.push(nums[i])\\n        else equal.push(nums[i])\\n    }\\n    return smaller.concat(equal, greater)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} pivot\\n * @return {number[]}\\n */\\nvar pivotArray = function(nums, pivot) {\\n    let smaller = [];\\n    let greater = [];\\n    let equal = [];\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] < pivot) smaller.push(nums[i])\\n        else if(nums[i] > pivot) greater.push(nums[i])\\n        else equal.push(nums[i])\\n    }\\n    return smaller.concat(equal, greater)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2618273,
                "title": "c-easy-with-explanation",
                "content": "**Please upvote if you find it helpful.** \\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\t\\t// stored size of nums array in n.\\n        int n=nums.size();\\n\\t\\t// Created another array of size n to store modified array.\\n        vector <int> ans(n); \\n\\t\\t// Initialized pointers to store and access elements in array.\\n        int start=0,end=n-1;\\n        int i=0,j=n-1;\\n        while(i<n){\\n\\t\\t\\t//checking from start of nums array, if any element is less than pivot then storing it in ans array from starting index and then incrementing start pointer.\\n            if(nums[i]<pivot) ans[start++]=nums[i];\\n\\t\\t\\t// checking from end of nums array, if any element is more than pivot then storing it in ans array from ending index and then decrementing end pointer.\\n            if(nums[j]>pivot) ans[end--]=nums[j];\\n\\t\\t\\t// incrementing i and decrementing j to check other elements in nums array.\\n            i++; j--;\\n        }\\n\\t\\t//in above loop we have stored elements that are less than and more than pivot element. Now we are storing pivot element in remaining left space.\\n        while(start<=end) ans[start++]=pivot;\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you find something wrong then please let me know in comments.**\\n[Link to Submission](https://leetcode.com/submissions/detail/807508141/)",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\t\\t// stored size of nums array in n.\\n        int n=nums.size();\\n\\t\\t// Created another array of size n to store modified array.\\n        vector <int> ans(n); \\n\\t\\t// Initialized pointers to store and access elements in array.\\n        int start=0,end=n-1;\\n        int i=0,j=n-1;\\n        while(i<n){\\n\\t\\t\\t//checking from start of nums array, if any element is less than pivot then storing it in ans array from starting index and then incrementing start pointer.\\n            if(nums[i]<pivot) ans[start++]=nums[i];\\n\\t\\t\\t// checking from end of nums array, if any element is more than pivot then storing it in ans array from ending index and then decrementing end pointer.\\n            if(nums[j]>pivot) ans[end--]=nums[j];\\n\\t\\t\\t// incrementing i and decrementing j to check other elements in nums array.\\n            i++; j--;\\n        }\\n\\t\\t//in above loop we have stored elements that are less than and more than pivot element. Now we are storing pivot element in remaining left space.\\n        while(start<=end) ans[start++]=pivot;\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284149,
                "title": "java-easy-pointers-simulation",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int small=0,greater=0,equal=0;\\n        for(int i:nums){\\n            if(i < pivot)small++;\\n            else if(i > pivot) greater++;\\n            else equal++;\\n        }\\n        int result[]=new int[nums.length];\\n        int i=0;\\n        int l=0,e=small,r=small+equal;\\n        while(i < nums.length){\\n            if(nums[i] < pivot) result[l++]=nums[i];\\n            else if(nums[i] > pivot)result[r++]=nums[i];\\n            else result[e++]=nums[i];\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int small=0,greater=0,equal=0;\\n        for(int i:nums){\\n            if(i < pivot)small++;\\n            else if(i > pivot) greater++;\\n            else equal++;\\n        }\\n        int result[]=new int[nums.length];\\n        int i=0;\\n        int l=0,e=small,r=small+equal;\\n        while(i < nums.length){\\n            if(nums[i] < pivot) result[l++]=nums[i];\\n            else if(nums[i] > pivot)result[r++]=nums[i];\\n            else result[e++]=nums[i];\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022267,
                "title": "c-o-n-2-beginner-friendly-solutions-1-tricky-3-pointers-solution",
                "content": "Hey all..\\nI have solved this in 3 methods using 2 vectors in cpp using basic traversing and counting.\\nI have commented in the code so that it can be useful..\\nIf you have any doubts be free to ask..\\nand please upvote if you understood or found it useful :)\\n\\nThank you..\\n\\n```\\nMethod 1:-\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n\\t\\t\\n\\t\\t// making two vectors to store all the elements less than pivot in left and greater in right.\\n        vector<int> left;\\n        vector<int> right;\\n\\t\\t\\n\\t\\t// Variable to count number of times the pivot occurs in given vector.\\n        int count=0;\\n\\t\\t\\n\\t\\t// Traversing the given vector\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t// If the current elemnt is less than the pivot then store in left vector.\\n            if(nums[i]<pivot){\\n                left.push_back(nums[i]);\\n            }\\n\\t\\t\\t// if the current elemnt is  greater than the pivot then store in right vector.\\n            else if(nums[i]>pivot){\\n                right.push_back(nums[i]);\\n            }\\n\\t\\t\\t// If its equal to pivot, increment the count value\\n            else{\\n                count++;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// First pushing all values equal to pivot the number of times they occur.\\n        for(int i=0;i<count;i++){\\n            left.push_back(pivot);\\n        }\\n\\t\\t\\n\\t\\t// Then all the greater values added in order to the end of left vector.\\n        for(int i=0;i<right.size();i++){\\n            left.push_back(right[i]);\\n        }\\n\\t\\t\\n\\t\\t//returning the left vector as it have all values(n).\\n        return left;\\n    }\\n};\\n\\nMethod 2:-\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n\\t\\tint j=0;\\n\\t\\tvector<int> ans(n);\\n\\t\\t// Traversing the given vector\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t// If its less then add.\\n            if(nums[i]<pivot){\\n                ans[j++]=nums[i];\\n            }\\n\\t\\t}\\n\\t\\t// Traversing the given vector\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t// Then If its equal then add.\\n            if(nums[i]==pivot){\\n                ans[j++]=nums[i];\\n            }\\n\\t\\t}\\n\\t\\t// Then Traversing the given vector\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t// Then If its greater then add.\\n            if(nums[i]>pivot){\\n                ans[j++]=nums[i];\\n            }\\n\\t\\t}\\n        return ans;\\n    }\\n};\\n\\nMethod 3:-\\n\\nclass Solution {\\npublic:\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n    //Initially assuming all elements are higher than pivot.\\n    int low = 0, same = 0, high = nums.size();\\n\\t\\n\\t//Traversing to get all values of low,same,high\\n    for(auto n : nums) {\\n        if(n < pivot) \\n            ++same; \\n        else if(n > pivot)\\n            --high;\\n    }\\n\\n\\t// Again traversing to add in result vector\\n    vector<int> res(nums.size());\\n    for(auto n : nums) {\\n        if(n < pivot)\\n            res[low++] = n; \\n        else if(n == pivot) \\n            res[same++] = n;\\n        else \\n            res[high++] = n;\\n    }\\n    return res;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nMethod 1:-\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n\\t\\t\\n\\t\\t// making two vectors to store all the elements less than pivot in left and greater in right.\\n        vector<int> left;\\n        vector<int> right;\\n\\t\\t\\n\\t\\t// Variable to count number of times the pivot occurs in given vector.\\n        int count=0;\\n\\t\\t\\n\\t\\t// Traversing the given vector\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t// If the current elemnt is less than the pivot then store in left vector.\\n            if(nums[i]<pivot){\\n                left.push_back(nums[i]);\\n            }\\n\\t\\t\\t// if the current elemnt is  greater than the pivot then store in right vector.\\n            else if(nums[i]>pivot){\\n                right.push_back(nums[i]);\\n            }\\n\\t\\t\\t// If its equal to pivot, increment the count value\\n            else{\\n                count++;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// First pushing all values equal to pivot the number of times they occur.\\n        for(int i=0;i<count;i++){\\n            left.push_back(pivot);\\n        }\\n\\t\\t\\n\\t\\t// Then all the greater values added in order to the end of left vector.\\n        for(int i=0;i<right.size();i++){\\n            left.push_back(right[i]);\\n        }\\n\\t\\t\\n\\t\\t//returning the left vector as it have all values(n).\\n        return left;\\n    }\\n};\\n\\nMethod 2:-\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n\\t\\tint j=0;\\n\\t\\tvector<int> ans(n);\\n\\t\\t// Traversing the given vector\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t// If its less then add.\\n            if(nums[i]<pivot){\\n                ans[j++]=nums[i];\\n            }\\n\\t\\t}\\n\\t\\t// Traversing the given vector\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t// Then If its equal then add.\\n            if(nums[i]==pivot){\\n                ans[j++]=nums[i];\\n            }\\n\\t\\t}\\n\\t\\t// Then Traversing the given vector\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t// Then If its greater then add.\\n            if(nums[i]>pivot){\\n                ans[j++]=nums[i];\\n            }\\n\\t\\t}\\n        return ans;\\n    }\\n};\\n\\nMethod 3:-\\n\\nclass Solution {\\npublic:\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n    //Initially assuming all elements are higher than pivot.\\n    int low = 0, same = 0, high = nums.size();\\n\\t\\n\\t//Traversing to get all values of low,same,high\\n    for(auto n : nums) {\\n        if(n < pivot) \\n            ++same; \\n        else if(n > pivot)\\n            --high;\\n    }\\n\\n\\t// Again traversing to add in result vector\\n    vector<int> res(nums.size());\\n    for(auto n : nums) {\\n        if(n < pivot)\\n            res[low++] = n; \\n        else if(n == pivot) \\n            res[same++] = n;\\n        else \\n            res[high++] = n;\\n    }\\n    return res;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747277,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> ans;\\n        for(auto &i : nums)\\n            if(i < pivot)\\n                ans.push_back(i);\\n        \\n        for(auto &i : nums)\\n            if(i == pivot)\\n                ans.push_back(i);\\n        \\n        for(auto &i : nums)\\n            if(i > pivot)\\n                ans.push_back(i);\\n            \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> ans;\\n        for(auto &i : nums)\\n            if(i < pivot)\\n                ans.push_back(i);\\n        \\n        for(auto &i : nums)\\n            if(i == pivot)\\n                ans.push_back(i);\\n        \\n        for(auto &i : nums)\\n            if(i > pivot)\\n                ans.push_back(i);\\n            \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3845943,
                "title": "java-beginner-solution-easy-to-understand-100-beats-with-explanation",
                "content": "# Approach\\n\\n1. Initialize an array called `ans` of the same size as the input `nums` array. This array will store the rearranged elements.\\n2. Create an integer variable `j` and set it to 0. This variable will keep track of the current position in the `ans` array.\\n3. Begin the first loop to iterate through the `nums` array. For each element `num` in the `nums` array, do the following:\\n   a. Check if the element `num` is less than `pivot`.\\n   b. If the condition is true (i.e., `num < pivot`), then assign the value of `num` to the `ans` array at the index `j`.\\n   c. Increment `j` to move the pointer ahead in the `ans` array.\\n   d. Repeat the above steps for each element in the `nums` array that is less than `pivot`. This will place all elements less than `pivot` in their correct positions on the left side of the `ans` array.\\n4. Begin the second loop to iterate through the `nums` array again. For each element `num` in the `nums` array, do the following:\\n   a. Check if the element `num` is equal to `pivot`.\\n   b. If the condition is true (i.e., `num == pivot`), then assign the value of `num` to the `ans` array at the index `j`.\\n   c. Increment `j` to move the pointer ahead in the `ans` array.\\n   d. Repeat the above steps for each element in the `nums` array that is equal to `pivot`. This will place all elements equal to `pivot` in their correct positions in the middle of the `ans` array.\\n5. Begin the third loop to iterate through the `nums` array once again. For each element `num` in the `nums` array, do the following:\\n   a. Check if the element `num` is greater than `pivot`.\\n   b. If the condition is true (i.e., `num > pivot`), then assign the value of `num` to the `ans` array at the index `j`.\\n   c. Increment `j` to move the pointer ahead in the `ans` array.\\n   d. Repeat the above steps for each element in the `nums` array that is greater than `pivot`. This will place all elements greater than `pivot` in their correct positions on the right side of the `ans` array.\\n6. After completing all the loops, the `ans` array will contain the rearranged elements as per the problem requirements.\\n7. Finally, return the `ans` array as the output of the function.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int j = 0;\\n\\n        for(int num : nums)\\n            if(num < pivot)\\n                ans[j++] = num;\\n\\n        for(int num : nums)\\n            if(num == pivot)\\n                ans[j++] = num;\\n\\n        for(int num : nums)\\n            if(num > pivot)\\n                ans[j++] = num;\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int j = 0;\\n\\n        for(int num : nums)\\n            if(num < pivot)\\n                ans[j++] = num;\\n\\n        for(int num : nums)\\n            if(num == pivot)\\n                ans[j++] = num;\\n\\n        for(int num : nums)\\n            if(num > pivot)\\n                ans[j++] = num;\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685922,
                "title": "easiest-c-solution-beginner-friendly-approach-beats-95",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> pivotArray(vector<int> &nums, int pivot)\\n    {\\n        vector<int> ans(nums.size());\\n        int i = 0;\\n        for(int n : nums){\\n            if(n < pivot) \\n                ans[i++] = n;  \\n        }\\n        for(int n : nums){\\n            if(n == pivot) \\n                ans[i++] = n;  \\n        }\\n        for(int n : nums){\\n            if(n > pivot)\\n                ans[i++] = n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> pivotArray(vector<int> &nums, int pivot)\\n    {\\n        vector<int> ans(nums.size());\\n        int i = 0;\\n        for(int n : nums){\\n            if(n < pivot) \\n                ans[i++] = n;  \\n        }\\n        for(int n : nums){\\n            if(n == pivot) \\n                ans[i++] = n;  \\n        }\\n        for(int n : nums){\\n            if(n > pivot)\\n                ans[i++] = n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269046,
                "title": "intuitive-c-o-n-solution-beats-90-time-98-memory",
                "content": "# Intuition\\nThe intuition behind this solution is maintaining 3 seperate pointers in answer array instead of creating 3 seperate arrays for answer which will **drastically reduce the space and time complexity of solution to O(n).** Although the **hints** section asks to create 3 seperate arrays for **each of less than pivot, greater than pivot ans equal to pivot**, this problem still can be solved without creating them.\\n\\n# Approach\\nIn this approach, we will be discussing solution regarding ***maintaining 3 pointers*** approach. \\n\\nVery first, from nums array, **we have to find out how many elemets are less than pivot and how many elements are equal to pivot.**  This data will be helpful for us to maintain 3 seperate pointer in answer array.\\n\\n**less = total number of elements in nums that are less than pivot\\nequal = total number of elements in nums that are equal to pivot\\ngreater = total number of elements in nums that are greter than pivot**\\n\\n---\\n\\n\\nOnce we get this data, we\\'ll create answer array (whose size is obviously equal to original nums size :-) ).\\n\\n---\\n\\n\\nWe will partition the **ans array** in such a way that there are three sections for each ans[i]<pivot , ans[i]==pivot , ans[i] >pivot.\\n\\n---\\n\\n\\n\\nIn order to fill this ans array, we will maintain 3 pointers that I was talking about.\\n\\n***lptr( for filling section which contains all elements < pivot) -->less pointer\\neptr( for filling section which contains all elements == pivot) -->equal pointer\\ngptr( for filling section which contains all elements > pivot) --> greater pointer***\\n\\nI hope names are pretty intuituve as their purpose.\\n\\n---\\n\\n\\n\\n**As lptr has to start filling ans array** from left, naturally it will be 0.\\n\\n**As eptr has to start filling ans array** when elemnts less than pivot are over , hence it has to be less.\\n\\n**As gptr has to start filling ans array** when elemnts less than pivot and elements equal to pivot are over, hence it has to be less+equal.\\n\\nRest is just filling and returning of ans array.\\n\\n# Complexity\\n- Time complexity: O(n+n) //Almost beats 90%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) //Almost beats 98%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\n        int less=0;\\n        int equal=0;\\n        \\n        if(nums.size()==1)\\n        {\\n            return nums;\\n        }\\n        for(auto x:nums)\\n        {\\n            if(x<pivot)\\n            {\\n                less++;;\\n            }\\n            else if(x==pivot)\\n            {\\n                equal++;\\n            }\\n        }\\n        vector<int>ans(nums.size());\\n        int lptr=0;\\n        int eptr=less;\\n        int gptr = less+equal;\\n        for(auto x: nums)\\n        {\\n            if(x<pivot)\\n            {   \\n                ans[lptr]=x;\\n                lptr++;\\n            }\\n            else if(x>pivot)\\n            {\\n                ans[gptr]=x;\\n                gptr++;\\n            }\\n            else if(x==pivot)\\n            {\\n                ans[eptr]=x;\\n                eptr++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\n        int less=0;\\n        int equal=0;\\n        \\n        if(nums.size()==1)\\n        {\\n            return nums;\\n        }\\n        for(auto x:nums)\\n        {\\n            if(x<pivot)\\n            {\\n                less++;;\\n            }\\n            else if(x==pivot)\\n            {\\n                equal++;\\n            }\\n        }\\n        vector<int>ans(nums.size());\\n        int lptr=0;\\n        int eptr=less;\\n        int gptr = less+equal;\\n        for(auto x: nums)\\n        {\\n            if(x<pivot)\\n            {   \\n                ans[lptr]=x;\\n                lptr++;\\n            }\\n            else if(x>pivot)\\n            {\\n                ans[gptr]=x;\\n                gptr++;\\n            }\\n            else if(x==pivot)\\n            {\\n                ans[eptr]=x;\\n                eptr++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233421,
                "title": "easy-java-solution-beats-81",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n = nums.length, start = 0, mid = 0, end = 0, eqcount = 0, smcount = 0;\\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] < pivot)\\n                smcount++;\\n            else if(nums[i] == pivot)\\n                eqcount++;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] < pivot){\\n                arr[start] = nums[i];\\n                start++;\\n            }\\n            else if(nums[i] == pivot){\\n                arr[smcount + mid] = nums[i];\\n                mid++;\\n            }\\n            else{\\n                arr[smcount + eqcount + end] = nums[i];\\n                end++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n = nums.length, start = 0, mid = 0, end = 0, eqcount = 0, smcount = 0;\\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] < pivot)\\n                smcount++;\\n            else if(nums[i] == pivot)\\n                eqcount++;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] < pivot){\\n                arr[start] = nums[i];\\n                start++;\\n            }\\n            else if(nums[i] == pivot){\\n                arr[smcount + mid] = nums[i];\\n                mid++;\\n            }\\n            else{\\n                arr[smcount + eqcount + end] = nums[i];\\n                end++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711596,
                "title": "python-easy-solution-using-two-pointers",
                "content": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        n=len(nums)\\n        a=[0]*n\\n        l,r=0,n-1\\n        for i in range(n):\\n            if nums[i]<pivot:\\n                a[l]=nums[i]\\n                l+=1\\n            if nums[n-i-1]>pivot:\\n                a[r]=nums[n-i-1]\\n                r-=1\\n        while l<=r:\\n            a[l]=pivot\\n            l+=1\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        n=len(nums)\\n        a=[0]*n\\n        l,r=0,n-1\\n        for i in range(n):\\n            if nums[i]<pivot:\\n                a[l]=nums[i]\\n                l+=1\\n            if nums[n-i-1]>pivot:\\n                a[r]=nums[n-i-1]\\n                r-=1\\n        while l<=r:\\n            a[l]=pivot\\n            l+=1\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316203,
                "title": "c-o-n-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int countPivot=0;\\n        vector<int> greater;\\n        vector<int> res;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<pivot) res.push_back(nums[i]);\\n            else if(nums[i]>pivot) greater.push_back(nums[i]);\\n            else countPivot++;\\n        }\\n        for(int i=0; i<countPivot; i++) res.push_back(pivot);\\n        for(int i=0; i<greater.size(); i++) res.push_back(greater[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int countPivot=0;\\n        vector<int> greater;\\n        vector<int> res;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<pivot) res.push_back(nums[i]);\\n            else if(nums[i]>pivot) greater.push_back(nums[i]);\\n            else countPivot++;\\n        }\\n        for(int i=0; i<countPivot; i++) res.push_back(pivot);\\n        for(int i=0; i<greater.size(); i++) res.push_back(greater[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166871,
                "title": "2-solutions-c",
                "content": "**Brute Force Approach**\\n*this is very simple just search the with two loops and get the element and store in result and return i guess it is very simple to do*\\n\\n**First Solution** \\n\\n```\\nint count =0;    //here count is counting the pivot equal values\\n        int i=0,n = nums.size();\\n        vector<int>smaller,greater;  // here i will store smaller and greater values comparing with pivot\\n        while(i<n){\\n            if(nums[i] < pivot)\\n                smaller.push_back(nums[i]);\\n            else if(nums[i] == pivot)\\n                count++;\\n            else\\n                greater.push_back(nums[i]);\\n            i++;\\n        }\\n        for(int i=0;i<count;i++){\\n            smaller.push_back(pivot);\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        return smaller;\\n```\\n\\n**TC:O(N)**\\n\\n*-------------------------------------------------------------------------------------------------*\\n\\n**OPTIMAL SOLUTION THREE POINTER**\\n```\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int low=0,same=0;\\n        int i=0,n = nums.size();\\n        while(i<n){\\n            if(nums[i] < pivot)\\n                low++;\\n            else if(nums[i] == pivot)\\n                same++;\\n            i++;\\n        }\\n        int high = low+same;\\n        same = low;\\n        low = 0;\\n        vector<int>res(n,0);\\n        for(int i=0;i<n;i++){\\n            if(nums[i] < pivot)\\n                res[low++] = nums[i];\\n            else if(nums[i] == pivot)\\n                res[same++] = nums[i];\\n            else\\n                res[high++]=nums[i];\\n        }\\n        return res;\\n```\\n\\n**TC : O(N)**\\n\\n**If U Likes this post please upvote \\uD83C\\uDF88**\\n**:) happy coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint count =0;    //here count is counting the pivot equal values\\n        int i=0,n = nums.size();\\n        vector<int>smaller,greater;  // here i will store smaller and greater values comparing with pivot\\n        while(i<n){\\n            if(nums[i] < pivot)\\n                smaller.push_back(nums[i]);\\n            else if(nums[i] == pivot)\\n                count++;\\n            else\\n                greater.push_back(nums[i]);\\n            i++;\\n        }\\n        for(int i=0;i<count;i++){\\n            smaller.push_back(pivot);\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        return smaller;\\n```\n```\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int low=0,same=0;\\n        int i=0,n = nums.size();\\n        while(i<n){\\n            if(nums[i] < pivot)\\n                low++;\\n            else if(nums[i] == pivot)\\n                same++;\\n            i++;\\n        }\\n        int high = low+same;\\n        same = low;\\n        low = 0;\\n        vector<int>res(n,0);\\n        for(int i=0;i<n;i++){\\n            if(nums[i] < pivot)\\n                res[low++] = nums[i];\\n            else if(nums[i] == pivot)\\n                res[same++] = nums[i];\\n            else\\n                res[high++]=nums[i];\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152359,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        \\n        int small=0, equal=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<pivot) small++;\\n            else if(nums[i]==pivot) equal++;\\n            else continue;\\n        }\\n        int s1=0;\\n        int e1=small;\\n        int b1=small+equal;\\n            \\n        for(int i=0; i<n; i++){\\n            if(nums[i]<pivot) ans[s1]=nums[i], s1++;\\n            else if(nums[i]>pivot) ans[b1]=nums[i], b1++;\\n            else ans[e1]=pivot, e1++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        \\n        int small=0, equal=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<pivot) small++;\\n            else if(nums[i]==pivot) equal++;\\n            else continue;\\n        }\\n        int s1=0;\\n        int e1=small;\\n        int b1=small+equal;\\n            \\n        for(int i=0; i<n; i++){\\n            if(nums[i]<pivot) ans[s1]=nums[i], s1++;\\n            else if(nums[i]>pivot) ans[b1]=nums[i], b1++;\\n            else ans[e1]=pivot, e1++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809546,
                "title": "c-solution-using-2-arrays-beats-91",
                "content": "Here\\'s the code: \\n```\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int count=0;\\n        vector<int> low;\\n        vector<int> high;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==pivot) count++;\\n            else if(nums[i]<pivot) low.push_back(nums[i]);\\n            else high.push_back(nums[i]);\\n        }\\n        for(int i=0;i<count;i++) low.push_back(pivot);\\n        for(int i=0;i<high.size();i++){\\n            low.push_back(high[i]);\\n        }\\n        return low;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "Here\\'s the code: \\n```\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int count=0;\\n        vector<int> low;\\n        vector<int> high;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==pivot) count++;\\n            else if(nums[i]<pivot) low.push_back(nums[i]);\\n            else high.push_back(nums[i]);\\n        }\\n        for(int i=0;i<count;i++) low.push_back(pivot);\\n        for(int i=0;i<high.size();i++){\\n            low.push_back(high[i]);\\n        }\\n        return low;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1765575,
                "title": "one-liner-brief-python3",
                "content": "```python\\n    def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return sorted(nums, key=lambda x: x>p or -(x<p))\\n```\\n\\n| cond. | key |\\n| ----- | --- |\\n| `x>p` | 1   |\\n| `x<p` | -1  |\\n| `x=p` | 0   |\\n",
                "solutionTags": [],
                "code": "```python\\n    def pivotArray(self, nums: List[int], p: int) -> List[int]:\\n        return sorted(nums, key=lambda x: x>p or -(x<p))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1753752,
                "title": "c-using-fill-constructor-o-n",
                "content": "### **O(n) Solution, utilizing fill constructor to make it single loop.**  \\n\\n\\n##### **Explaination**\\n\\n\\t\\t// In order to do this in one pass, the simplest way is to use the fill constructor,\\n        // <!--- std::vector<int>(size, val) --->\\n        // So that while creating result array, all elements are initialised to \\'pivot\\'.\\n        // What this does is, now we can reduce the problem into a simple two pointer,\\n        // where low pointer is initially at 0 and moves forward, storing nums[lo] < pivot.\\n        // Similarly, high pointer is initially at last index and moves backward, storing nums[hi] > pivot.\\n        // And finally, the elements remaining in the middle are already equal to pivot, \\n\\t\\t// so we just return the result! \\n        \\n\\n##### **Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n = nums.size(), lo = 0, hi = n - 1, i = 0, j = n - 1;\\n        vector<int> ans(n, pivot);\\n        while (i < n) {\\n            if (nums[i] < pivot) ans[lo++] = nums[i];            \\n            if (nums[j] > pivot) ans[hi--] = nums[j];            \\n            i++;            \\n            j--;\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n##### **Complexity**\\n\\nTime complexity : `O(n)`\\nSpace complexity : `O(n)`\\n\\n**Thank you** for reading. If you have any questions, feel free to post in the comments section. And in case you found this explaination to be of some use, do **upvote**. \\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n = nums.size(), lo = 0, hi = n - 1, i = 0, j = n - 1;\\n        vector<int> ans(n, pivot);\\n        while (i < n) {\\n            if (nums[i] < pivot) ans[lo++] = nums[i];            \\n            if (nums[j] > pivot) ans[hi--] = nums[j];            \\n            i++;            \\n            j--;\\n        };\\n        return ans;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747650,
                "title": "java-solution-o-n-explanation",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int start = 0;\\n        int i = 0, c = 0;\\n\\t\\t//filling values less than pivot from start\\n        while(start < nums.length) {\\n            if(nums[start] < pivot) {\\n                ans[i++] = nums[start];\\n            } else if(nums[start] ==  pivot) c++;\\n            start++;\\n        }\\n        start = 0;\\n\\t\\t//putting pivot values in centre (c -> count of number of pivot in array)\\n\\t\\tfor(int j = 0; j < c;  j++) {\\n\\t\\t\\tans[i++] = pivot;\\n\\t\\t}\\n\\t\\t\\n\\t\\t//filling values greater than pivot from start\\n        while(start < nums.length) {\\n            if(nums[start] > pivot) {\\n                ans[i++]= nums[start];\\n            }\\n            start++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int start = 0;\\n        int i = 0, c = 0;\\n\\t\\t//filling values less than pivot from start\\n        while(start < nums.length) {\\n            if(nums[start] < pivot) {\\n                ans[i++] = nums[start];\\n            } else if(nums[start] ==  pivot) c++;\\n            start++;\\n        }\\n        start = 0;\\n\\t\\t//putting pivot values in centre (c -> count of number of pivot in array)\\n\\t\\tfor(int j = 0; j < c;  j++) {\\n\\t\\t\\tans[i++] = pivot;\\n\\t\\t}\\n\\t\\t\\n\\t\\t//filling values greater than pivot from start\\n        while(start < nums.length) {\\n            if(nums[start] > pivot) {\\n                ans[i++]= nums[start];\\n            }\\n            start++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747593,
                "title": "java-brute",
                "content": "```\\npublic int[] pivotArray(int[] nums, int pivot) {\\n\\tint i=0, n= nums.length, ans[]= new int[n];\\n\\tfor(int num:nums)\\n\\t\\tif(num<pivot) ans[i++]= num;\\n\\tfor(int num:nums)\\n\\t\\tif(num==pivot) ans[i++]= num;\\n\\tfor(int num:nums)\\n\\t\\tif(num>pivot) ans[i++]= num;\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "```\\npublic int[] pivotArray(int[] nums, int pivot) {\\n\\tint i=0, n= nums.length, ans[]= new int[n];\\n\\tfor(int num:nums)\\n\\t\\tif(num<pivot) ans[i++]= num;\\n\\tfor(int num:nums)\\n\\t\\tif(num==pivot) ans[i++]= num;\\n\\tfor(int num:nums)\\n\\t\\tif(num>pivot) ans[i++]= num;\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1747186,
                "title": "python-3-array-solution",
                "content": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        left, right, piv = [], [], []\\n        for n in nums:\\n            if n < pivot:\\n                left.append(n)\\n            elif n > pivot:\\n                right.append(n)\\n            else:\\n                piv.append(n)\\n\\n        i = 0\\n        while i < len(nums):\\n            while left:\\n                nums[i] = left.pop(0)\\n                i += 1\\n            while piv:\\n                nums[i] = piv.pop(0)\\n                i += 1\\n            while right:\\n                nums[i] = right.pop(0)\\n                i += 1\\n        return nums\\n```\\n\\nupdated:\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        left, right, piv = [], [], []\\n        for n in nums:\\n            if n < pivot:\\n                left.append(n)\\n            elif n > pivot:\\n                right.append(n)\\n            else:\\n                piv.append(n)\\n        return left+piv+right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        left, right, piv = [], [], []\\n        for n in nums:\\n            if n < pivot:\\n                left.append(n)\\n            elif n > pivot:\\n                right.append(n)\\n            else:\\n                piv.append(n)\\n\\n        i = 0\\n        while i < len(nums):\\n            while left:\\n                nums[i] = left.pop(0)\\n                i += 1\\n            while piv:\\n                nums[i] = piv.pop(0)\\n                i += 1\\n            while right:\\n                nums[i] = right.pop(0)\\n                i += 1\\n        return nums\\n```\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        left, right, piv = [], [], []\\n        for n in nums:\\n            if n < pivot:\\n                left.append(n)\\n            elif n > pivot:\\n                right.append(n)\\n            else:\\n                piv.append(n)\\n        return left+piv+right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870791,
                "title": "beats-100-java-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int index = 0;\\n        for (int num : nums) {\\n            if (num < pivot) {\\n                ans[index++] = num;\\n            }\\n        }\\n        for (int num : nums) {\\n            if (num == pivot) {\\n                ans[index++] = num;\\n            }\\n        }\\n        for (int num : nums) {\\n            if (num > pivot) {\\n                ans[index++] = num;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ans = new int[nums.length];\\n        int index = 0;\\n        for (int num : nums) {\\n            if (num < pivot) {\\n                ans[index++] = num;\\n            }\\n        }\\n        for (int num : nums) {\\n            if (num == pivot) {\\n                ans[index++] = num;\\n            }\\n        }\\n        for (int num : nums) {\\n            if (num > pivot) {\\n                ans[index++] = num;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707402,
                "title": "java-easy-to-understand-2-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//approach 1---->  Naive approach\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[]result=new int[nums.length];\\n        int k=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<pivot)\\n            result[k++]=nums[i];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==pivot)\\n            result[k++]=nums[i];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>pivot)\\n            result[k++]=nums[i];\\n        }\\n    return result;\\n    }\\n}\\n\\n//approach 2------>  Two pointer approach\\n\\n// class Solution {\\n//     public int[] pivotArray(int[] nums, int pivot) {\\n//         int left=0;\\n//         int right=nums.length-1;\\n//         int[]result=new int[nums.length];\\n//        for(int i=0;i<nums.length;i++)\\n//        {\\n//            if(nums[i]<pivot)\\n//            result[left++]=nums[i];\\n\\n//            if(nums[nums.length-1-i]>pivot)\\n//            result[right--]=nums[nums.length-1-i];\\n\\n//        }\\n//        while(left<=right)\\n//        {\\n//             result[left++] = pivot;\\n//        }\\n//        return result;\\n//     }\\n// }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//approach 1---->  Naive approach\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[]result=new int[nums.length];\\n        int k=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<pivot)\\n            result[k++]=nums[i];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==pivot)\\n            result[k++]=nums[i];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>pivot)\\n            result[k++]=nums[i];\\n        }\\n    return result;\\n    }\\n}\\n\\n//approach 2------>  Two pointer approach\\n\\n// class Solution {\\n//     public int[] pivotArray(int[] nums, int pivot) {\\n//         int left=0;\\n//         int right=nums.length-1;\\n//         int[]result=new int[nums.length];\\n//        for(int i=0;i<nums.length;i++)\\n//        {\\n//            if(nums[i]<pivot)\\n//            result[left++]=nums[i];\\n\\n//            if(nums[nums.length-1-i]>pivot)\\n//            result[right--]=nums[nums.length-1-i];\\n\\n//        }\\n//        while(left<=right)\\n//        {\\n//             result[left++] = pivot;\\n//        }\\n//        return result;\\n//     }\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515498,
                "title": "using-vector-s-insert-function-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe very first thought that came to my mind while solving this problem was just to break the array into three parts each fulfilling the desired conditions. And then finally Concatenating each of them for the final answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can use the vector\\'s insert function to apply the intuition. \\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> temp,lesser,great;\\n        for( int i = 0;i<nums.size();i++){\\n            if(nums[i]==pivot) temp.push_back(nums[i]);\\n            else if(nums[i]<pivot) lesser.push_back(nums[i]);\\n            else if(nums[i]>pivot) great.push_back(nums[i]);\\n          }\\n        nums.clear();\\n        nums.insert(nums.begin(),lesser.begin(),lesser.end());\\n        nums.insert(nums.end(),temp.begin(),temp.end());\\n        nums.insert(nums.end(),great.begin(),great.end());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> temp,lesser,great;\\n        for( int i = 0;i<nums.size();i++){\\n            if(nums[i]==pivot) temp.push_back(nums[i]);\\n            else if(nums[i]<pivot) lesser.push_back(nums[i]);\\n            else if(nums[i]>pivot) great.push_back(nums[i]);\\n          }\\n        nums.clear();\\n        nums.insert(nums.begin(),lesser.begin(),lesser.end());\\n        nums.insert(nums.end(),temp.begin(),temp.end());\\n        nums.insert(nums.end(),great.begin(),great.end());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479423,
                "title": "java-o-nlogn-time-o-1-space-those-solutions-with-o-n-o-1-are-actually-not-o-1",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n = nums.length;\\n        int chunkSize = 1;\\n        while (chunkSize < n) {\\n            //merge 2 chunks at a time\\n            //need to check if there are two chunks left or not, if not, don\\'t need merge\\n            int curIndex = 0;\\n            while (curIndex < n) {\\n                int nextIndex = curIndex + chunkSize;\\n                if (nextIndex < n) {\\n                    //exist 2 chunks, then merge\\n                    merge(nums, curIndex, nextIndex, chunkSize, pivot);//2nd chunk may be shorter than chunkSize\\n                }\\n                curIndex += chunkSize * 2;\\n            }\\n            chunkSize *= 2;\\n        }\\n        return nums;     \\n    }\\n\\n    private void merge(int[] nums, int c1, int c2, int size, int pivot) {\\n        //each chunk now is ordered as \\'ssssmmmmllll\\' format\\n        //ssssmmmmllll  ssssmmmmllll\\n        //   first         second\\n        //do section reverse on first.mmmmllll and second.ssssmmmm\\n        //=> ssss ssssmmmm mmmmllll llll\\n        //need to find start index of first.m, and end index of second.m\\n        int startMediumInFirst = c1;\\n        int endMediumInSecond = c2;\\n        while (startMediumInFirst < c2 && nums[startMediumInFirst] < pivot) {\\n            startMediumInFirst++;\\n        }\\n        while (endMediumInSecond < Math.min(nums.length, c2 + size) && nums[endMediumInSecond] <= pivot) {\\n            endMediumInSecond++;\\n        }\\n        endMediumInSecond--;\\n        reverse(nums, startMediumInFirst, c2 - 1);\\n        reverse(nums, c2, endMediumInSecond);\\n        reverse(nums, startMediumInFirst, endMediumInSecond);\\n    }\\n\\n    private void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n = nums.length;\\n        int chunkSize = 1;\\n        while (chunkSize < n) {\\n            //merge 2 chunks at a time\\n            //need to check if there are two chunks left or not, if not, don\\'t need merge\\n            int curIndex = 0;\\n            while (curIndex < n) {\\n                int nextIndex = curIndex + chunkSize;\\n                if (nextIndex < n) {\\n                    //exist 2 chunks, then merge\\n                    merge(nums, curIndex, nextIndex, chunkSize, pivot);//2nd chunk may be shorter than chunkSize\\n                }\\n                curIndex += chunkSize * 2;\\n            }\\n            chunkSize *= 2;\\n        }\\n        return nums;     \\n    }\\n\\n    private void merge(int[] nums, int c1, int c2, int size, int pivot) {\\n        //each chunk now is ordered as \\'ssssmmmmllll\\' format\\n        //ssssmmmmllll  ssssmmmmllll\\n        //   first         second\\n        //do section reverse on first.mmmmllll and second.ssssmmmm\\n        //=> ssss ssssmmmm mmmmllll llll\\n        //need to find start index of first.m, and end index of second.m\\n        int startMediumInFirst = c1;\\n        int endMediumInSecond = c2;\\n        while (startMediumInFirst < c2 && nums[startMediumInFirst] < pivot) {\\n            startMediumInFirst++;\\n        }\\n        while (endMediumInSecond < Math.min(nums.length, c2 + size) && nums[endMediumInSecond] <= pivot) {\\n            endMediumInSecond++;\\n        }\\n        endMediumInSecond--;\\n        reverse(nums, startMediumInFirst, c2 - 1);\\n        reverse(nums, c2, endMediumInSecond);\\n        reverse(nums, startMediumInFirst, endMediumInSecond);\\n    }\\n\\n    private void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468989,
                "title": "simple-c-solution-with-time-and-space-complexity-of-o-n",
                "content": "# Approach\\nJUST A SIMPLE APPROACH :- INSERTING THE ELEMENTS SMALLER THAN THE PIVOT ELEMENT IN THE FIRST LOOP THEN INSERTING THE N NUMBER OF TIMES THE PIVOT ELEMENT THEN IN THE LAST FOR LOOP INSERTING ELEMENTS THAT ARE GREATER THAN PIVOT  \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<pivot)\\n            ans1.push_back(nums[i]);\\n        }\\n        int n=count(nums.begin(),nums.end(),pivot);\\n        for(int i=0;i<n;i++){\\n            ans1.push_back(pivot);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>pivot)\\n            ans1.push_back(nums[i]);\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<pivot)\\n            ans1.push_back(nums[i]);\\n        }\\n        int n=count(nums.begin(),nums.end(),pivot);\\n        for(int i=0;i<n;i++){\\n            ans1.push_back(pivot);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>pivot)\\n            ans1.push_back(nums[i]);\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418223,
                "title": "partition-array-according-to-given-pivot-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int i=0, pivot_count=0;\\n        vector<int> temp;\\n        vector<int> ans;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==pivot)\\n            {\\n                pivot_count++;\\n            }\\n            else if(nums[i]>pivot)\\n            {\\n                temp.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        ans.insert(ans.begin()+ans.size(), pivot_count, pivot);\\n        ans.insert(ans.end(), temp.begin(), temp.end());\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int i=0, pivot_count=0;\\n        vector<int> temp;\\n        vector<int> ans;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==pivot)\\n            {\\n                pivot_count++;\\n            }\\n            else if(nums[i]>pivot)\\n            {\\n                temp.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        ans.insert(ans.begin()+ans.size(), pivot_count, pivot);\\n        ans.insert(ans.end(), temp.begin(), temp.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310032,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n     vector<int>ans;\\n     for(auto it:nums){\\n         if(it<pivot){\\n             ans.push_back(it);\\n         }\\n     } \\n     for(auto it:nums){\\n         if(it==pivot){\\n             ans.push_back(it);\\n         }\\n     }\\n     for(auto it:nums){\\n         if(it>pivot){\\n             ans.push_back(it);\\n         }\\n     }    \\n   return ans; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n     vector<int>ans;\\n     for(auto it:nums){\\n         if(it<pivot){\\n             ans.push_back(it);\\n         }\\n     } \\n     for(auto it:nums){\\n         if(it==pivot){\\n             ans.push_back(it);\\n         }\\n     }\\n     for(auto it:nums){\\n         if(it>pivot){\\n             ans.push_back(it);\\n         }\\n     }    \\n   return ans; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231657,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] m = new int[nums.length];\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < pivot){\\n                m[j++] = nums[i];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == pivot){\\n                m[j++] = nums[i];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > pivot){\\n                m[j++] = nums[i];\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] m = new int[nums.length];\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < pivot){\\n                m[j++] = nums[i];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == pivot){\\n                m[j++] = nums[i];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > pivot){\\n                m[j++] = nums[i];\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196125,
                "title": "c-easy-o-n-o-n-68-7-speed-94-space",
                "content": "# Intuition\\nwe have to compare each element\\n\\n# Approach\\n*Have a separate vector,\\n*Scan through the given vector for below pivot values and add them to separate vector\\n*Scan one more time for equivalent\\n*Scan one more time for avove pivot values. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> res(nums.size(),0);\\n        int j = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] < pivot)                res[j++] = nums[i];\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] == pivot)               res[j++] = nums[i];\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] > pivot)                res[j++] = nums[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> res(nums.size(),0);\\n        int j = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] < pivot)                res[j++] = nums[i];\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] == pivot)               res[j++] = nums[i];\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] > pivot)                res[j++] = nums[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191392,
                "title": "unsure-why-it-is-a-medium-level-category",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> pivotArray(vector<int>& a, int p) {\\n        int n = a.size();\\n        vector<int> res;\\n        \\n        for(auto i: a)\\n        {\\n            if(i<p)\\n                res.push_back(i);\\n        }\\n        \\n         for(auto i: a)\\n        {\\n            if(i==p)\\n                res.push_back(i);\\n        }\\n        \\n         for(auto i: a)\\n        {\\n            if(i>p)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> pivotArray(vector<int>& a, int p) {\\n        int n = a.size();\\n        vector<int> res;\\n        \\n        for(auto i: a)\\n        {\\n            if(i<p)\\n                res.push_back(i);\\n        }\\n        \\n         for(auto i: a)\\n        {\\n            if(i==p)\\n                res.push_back(i);\\n        }\\n        \\n         for(auto i: a)\\n        {\\n            if(i>p)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021195,
                "title": "c-solution-easy-to-undersatnd-using-simulation",
                "content": "Runtime: 236 ms, faster than 77.98% of C++ online submissions for Partition Array According to Given Pivot.\\nMemory Usage: 129.3 MB, less than 49.07% of C++ online submissions for Partition Array According to \\nGiven Pivot.\\n\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\t\\t\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\t\\tvector<int>ans;\\n\\t\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t\\twhile(i<n){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(nums[i]<pivot){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tans.push_back(nums[i]);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t else\\n\\t\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t\\t  }\\n        i=0;\\n            while(i<n){\\n                if(nums[i]==pivot){\\n                    ans.push_back(nums[i]);\\n                    i++;\\n                    }\\n                        else\\n                            i++;\\n            }\\n        \\n        i=0;\\n             while(i<n){\\n                     if(nums[i]>pivot){\\n                            ans.push_back(nums[i]);\\n                            i++;\\n                            }   \\n                        else\\n                            i++;\\n                }\\n      return ans;  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\t\\t\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\t\\tvector<int>ans;\\n\\t\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t\\twhile(i<n){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(nums[i]<pivot){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tans.push_back(nums[i]);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2920397,
                "title": "very-easy-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans;\\n\\n        for(auto i: nums){\\n            if(i<pivot){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        for(auto i: nums){\\n          if(i==pivot){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        for(auto i: nums){\\n           if(i>pivot){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans;\\n\\n        for(auto i: nums){\\n            if(i<pivot){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        for(auto i: nums){\\n          if(i==pivot){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        for(auto i: nums){\\n           if(i>pivot){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780348,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<pivot){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==pivot){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>pivot){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<pivot){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==pivot){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>pivot){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712797,
                "title": "python-solution",
                "content": "\\nclass Solution:\\n\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        s=[] #for elements smaller than pivot \\n        l=[] #for elements greater than pivot\\n        p=[] #for elements equal than pivot\\n\\t\\t#returning s+p+l\\n        for i in nums:\\n            if i>pivot:\\n                l.append(i)\\n            elif i==pivot:\\n                p.append(i)\\n            elif i<pivot:\\n                s.append(i)\\n        for i in p:\\n            s.append(i)\\n        for i in l:\\n            s.append(i)\\n        return s\\n\\t\\n",
                "solutionTags": [],
                "code": "\\nclass Solution:\\n\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        s=[] #for elements smaller than pivot \\n        l=[] #for elements greater than pivot\\n        p=[] #for elements equal than pivot\\n\\t\\t#returning s+p+l\\n        for i in nums:\\n            if i>pivot:\\n                l.append(i)\\n            elif i==pivot:\\n                p.append(i)\\n            elif i<pivot:\\n                s.append(i)\\n        for i in p:\\n            s.append(i)\\n        for i in l:\\n            s.append(i)\\n        return s\\n\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 2711593,
                "title": "python-easy-solution-faster-than-99-21-in-o-n-complexity",
                "content": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        a=[]\\n        c=0\\n        for i in nums:\\n            if i<pivot:\\n                a.append(i)\\n            elif i==pivot:\\n                c+=1\\n        for i in range(c):\\n            a.append(pivot)\\n        for i in nums:\\n            if i>pivot:\\n                a.append(i)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        a=[]\\n        c=0\\n        for i in nums:\\n            if i<pivot:\\n                a.append(i)\\n            elif i==pivot:\\n                c+=1\\n        for i in range(c):\\n            a.append(pivot)\\n        for i in nums:\\n            if i>pivot:\\n                a.append(i)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604751,
                "title": "with-explanation-comments-time-229-ms-94-17-space-132-9-mb-30-10",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n**Solution 1: 3 Passes**\\n\\nTC: O(n)   //iterate 3 times over the array\\nSC: O(n)   //initialize new array\\nTime: 481 ms (10.70%), Space: 129.2 MB (49.17%) \\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        //initialize a new array\\n        vector<int> res;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums)\\n            //check if the current value is smaller than the pivot\\n            if(num<pivot)\\n                //append it in the new array\\n                res.push_back(num);\\n        \\n        //loop over the whole array elements, again\\n        for(int num:nums)\\n            //check if the current value equals to the pivot\\n            if(num==pivot)\\n                //append it in the new array\\n                res.push_back(num);\\n        \\n        //loop over the whole array elements, again\\n        for(int num:nums)\\n            //check if the current value is greater than the pivot\\n            if(num>pivot)\\n                //append it in the new array\\n                res.push_back(num);\\n        \\n        //return the new array elements\\n        return res;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Solution 2: **\\n\\nTC: O(n)   //iterate 3 times over the array\\nSC: O(n)   //initialize 2 new arrays\\nTime: 229 ms (94.17%), Space: 132.9 MB (30.10%) \\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        //initialize two new arrays\\n        vector<int> small, large;\\n        int counter=0;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            \\n            //case 1: the current value is smaller than the pivot\\n            if(num<pivot)\\n                //add it to the small numbers vector\\n                small.push_back(num);\\n            //case 2: the current value is greater than the pivot\\n            else if(num>pivot)\\n                //add it to the large numbers vector\\n                large.push_back(num);\\n            //case 3: the current value equals to the pivot\\n            else\\n                //add the counter by 1, to know how many pivots\\n                counter++;\\n        }\\n      \\n        //iterate with the number of the counter value\\n        while((counter--)!=0)\\n            //add the pivot value in the array\\n            small.push_back(pivot);\\n        \\n        //then, iterate the large array to move its elements to only one array, small\\n        for(int num:large)\\n            small.push_back(num);\\n        \\n        //return the rearranged array numbers\\n        return small;\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        //initialize a new array\\n        vector<int> res;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums)\\n            //check if the current value is smaller than the pivot\\n            if(num<pivot)\\n                //append it in the new array\\n                res.push_back(num);\\n        \\n        //loop over the whole array elements, again\\n        for(int num:nums)\\n            //check if the current value equals to the pivot\\n            if(num==pivot)\\n                //append it in the new array\\n                res.push_back(num);\\n        \\n        //loop over the whole array elements, again\\n        for(int num:nums)\\n            //check if the current value is greater than the pivot\\n            if(num>pivot)\\n                //append it in the new array\\n                res.push_back(num);\\n        \\n        //return the new array elements\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2525567,
                "title": "easy-to-understand-simple-java-code",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n   \\n  int[] ans=new int[nums.length];\\n        \\n        int ix=0;\\n        for(int num:nums){ //less\\n            if(num<pivot){\\n                ans[ix++]=num;\\n            }\\n        }\\n        for(int num:nums){\\n            if(num==pivot){ //equal\\n                ans[ix++]=num;\\n            }\\n        }\\n        for(int num:nums){\\n            if(num>pivot){ //greater\\n                ans[ix++]=num;\\n            }\\n        }\\n            \\nreturn ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n   \\n  int[] ans=new int[nums.length];\\n        \\n        int ix=0;\\n        for(int num:nums){ //less\\n            if(num<pivot){\\n                ans[ix++]=num;\\n            }\\n        }\\n        for(int num:nums){\\n            if(num==pivot){ //equal\\n                ans[ix++]=num;\\n            }\\n        }\\n        for(int num:nums){\\n            if(num>pivot){ //greater\\n                ans[ix++]=num;\\n            }\\n        }\\n            \\nreturn ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372781,
                "title": "solution-for-c-using-three-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int low = 0;\\n        int high = 0;\\n        int same = 0;\\n        vector<int> ans(nums.size());\\n        for(auto el: nums){\\n            if(el < pivot) low++;\\n            else if(el == pivot) same++;\\n        }\\n        high = low + same;\\n        same = low;\\n        low = 0;\\n        for(auto el : nums){\\n            if(el < pivot){\\n                ans[low++] = el;\\n            }\\n            else if(el > pivot){\\n                ans[high++] =  el;\\n            }\\n            else{\\n                ans[same++] = el;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int low = 0;\\n        int high = 0;\\n        int same = 0;\\n        vector<int> ans(nums.size());\\n        for(auto el: nums){\\n            if(el < pivot) low++;\\n            else if(el == pivot) same++;\\n        }\\n        high = low + same;\\n        same = low;\\n        low = 0;\\n        for(auto el : nums){\\n            if(el < pivot){\\n                ans[low++] = el;\\n            }\\n            else if(el > pivot){\\n                ans[high++] =  el;\\n            }\\n            else{\\n                ans[same++] = el;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318755,
                "title": "c-solution-approach-explained-commented-easy-to-understand",
                "content": "class Solution {\\npublic:\\n*     vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        // ******* APPROACH ******* //\\n        // We\\'ll store all elements smaller than pivot in a vector (small). We\\'ll store all elements greater than pivot in a vector(great) and then at the end of small vector we\\'ll push pivot number of times it occured and then we\\'ll push all the elements greater than pivot\\n        \\n        int count = 0;  // Count to store number of times pivot occurs\\n        int numsize = nums.size();\\n        int i = 0;\\n        for(;i < numsize; i++){\\n            if(nums[i] == pivot)\\n            {\\n                count++;\\n            }\\n        }\\n        vector<int>small;  // Vector to store all elements smaller than pivot\\n        vector<int>great;  // Vector to store all elements greater than pivot\\n        for(i = 0;i < numsize; i++){\\n            if(nums[i] < pivot)\\n            {\\n                small.push_back(nums[i]);\\n            }\\n        }\\n        for(i = 0;i < numsize; i++){\\n            if(nums[i] > pivot)\\n            {\\n                great.push_back(nums[i]);\\n            }\\n        }\\n        for(i = 0;i < count; i++)\\n        {\\n            small.push_back(pivot);\\n        }\\n        int greatsize = great.size();\\n        for(i = 0;i < greatsize; i++)\\n        {\\n            small.push_back(great[i]);\\n        }\\n        return small;\\n    }\\n};\\n**Do Upvote if you understood it**",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n*     vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        // ******* APPROACH ******* //\\n        // We\\'ll store all elements smaller than pivot in a vector (small). We\\'ll store all elements greater than pivot in a vector(great) and then at the end of small vector we\\'ll push pivot number of times it occured and then we\\'ll push all the elements greater than pivot\\n        \\n        int count = 0;  // Count to store number of times pivot occurs\\n        int numsize = nums.size();\\n        int i = 0;\\n        for(;i < numsize; i++){\\n            if(nums[i] == pivot)\\n            {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2243867,
                "title": "java-solution-slight-optimization-by-scanning-the-list-twice-instead-of-three-times",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int len = nums.length;\\n        int smallerCount = 0, biggerCount = 0, equalCount = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] < pivot) {\\n                smallerCount++;\\n            } else if (nums[i] == pivot) {\\n                equalCount++;\\n            } else {\\n                biggerCount++;\\n            }\\n        }\\n        \\n        int[] result = new int[len];\\n        int smallerIdx = 0;\\n        int equalIdx = smallerCount;\\n        int biggerIdx = smallerCount + equalCount;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] < pivot) {\\n                result[smallerIdx++] = nums[i];\\n            } else if (nums[i] == pivot) {\\n                result[equalIdx++] = nums[i];\\n            } else {\\n                result[biggerIdx++] = nums[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int len = nums.length;\\n        int smallerCount = 0, biggerCount = 0, equalCount = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] < pivot) {\\n                smallerCount++;\\n            } else if (nums[i] == pivot) {\\n                equalCount++;\\n            } else {\\n                biggerCount++;\\n            }\\n        }\\n        \\n        int[] result = new int[len];\\n        int smallerIdx = 0;\\n        int equalIdx = smallerCount;\\n        int biggerIdx = smallerCount + equalCount;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] < pivot) {\\n                result[smallerIdx++] = nums[i];\\n            } else if (nums[i] == pivot) {\\n                result[equalIdx++] = nums[i];\\n            } else {\\n                result[biggerIdx++] = nums[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101603,
                "title": "rust-two-liner",
                "content": "```\\nimpl Solution {\\n    pub fn pivot_array(mut nums: Vec<i32>, pivot: i32) -> Vec<i32> {\\n        nums.sort_by_key(|num| num.cmp(&pivot));\\n        nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn pivot_array(mut nums: Vec<i32>, pivot: i32) -> Vec<i32> {\\n        nums.sort_by_key(|num| num.cmp(&pivot));\\n        nums\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082649,
                "title": "java-python3-easy-to-understand",
                "content": "Runtime: 7 ms, faster than 71.64% of Java online submissions for Partition Array According to Given Pivot.\\nMemory Usage: 168.8 MB, less than 29.95% of Java online submissions for Partition Array According to Given Pivot.\\n```\\nclass Solution {\\n  public int[] pivotArray(int[] nums, int pivot) {\\n    int less = 0;\\n    int equal = 0;\\n    \\n    for(int n : nums)\\n      if      (n <  pivot) less++;\\n      else if (n == pivot) equal++;\\n    \\n    int greater = less + equal;\\n    equal       = less;\\n    less        = 0;\\n    \\n    int[] ans = new int[nums.length];\\n    \\n    for(int n : nums)\\n      if(n <  pivot){\\n        ans[less] = n;\\n        less++;\\n      }\\n      else if(n == pivot){ \\n        ans[equal] = n;\\n        equal++;\\n      }\\n      else{\\n        ans[greater] = n;\\n        greater++;\\n      }\\n    \\n    return ans;      \\n  }\\n}\\n```\\nRuntime: 1879 ms, faster than 51.96% of Python3 online submissions for Partition Array According to Given Pivot.\\nMemory Usage: 31.6 MB, less than 45.02% of Python3 online submissions for Partition Array According to Given Pivot.\\n```\\nclass Solution:\\n  def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n    less = 0\\n    equal = 0\\n    \\n    for n in nums :\\n      if   n <  pivot : less  += 1\\n      elif n == pivot : equal += 1\\n    \\n    greater = less + equal\\n    equal   = less\\n    less    = 0\\n    \\n    ans = [0]*len(nums)\\n    \\n    for n in nums :\\n      if   n <  pivot :\\n        ans[less] = n\\n        less += 1\\n      elif n == pivot : \\n        ans[equal] = n\\n        equal += 1\\n      else :\\n        ans[greater] = n\\n        greater += 1\\n        \\n    return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n  public int[] pivotArray(int[] nums, int pivot) {\\n    int less = 0;\\n    int equal = 0;\\n    \\n    for(int n : nums)\\n      if      (n <  pivot) less++;\\n      else if (n == pivot) equal++;\\n    \\n    int greater = less + equal;\\n    equal       = less;\\n    less        = 0;\\n    \\n    int[] ans = new int[nums.length];\\n    \\n    for(int n : nums)\\n      if(n <  pivot){\\n        ans[less] = n;\\n        less++;\\n      }\\n      else if(n == pivot){ \\n        ans[equal] = n;\\n        equal++;\\n      }\\n      else{\\n        ans[greater] = n;\\n        greater++;\\n      }\\n    \\n    return ans;      \\n  }\\n}\\n```\n```\\nclass Solution:\\n  def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n    less = 0\\n    equal = 0\\n    \\n    for n in nums :\\n      if   n <  pivot : less  += 1\\n      elif n == pivot : equal += 1\\n    \\n    greater = less + equal\\n    equal   = less\\n    less    = 0\\n    \\n    ans = [0]*len(nums)\\n    \\n    for n in nums :\\n      if   n <  pivot :\\n        ans[less] = n\\n        less += 1\\n      elif n == pivot : \\n        ans[equal] = n\\n        equal += 1\\n      else :\\n        ans[greater] = n\\n        greater += 1\\n        \\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963438,
                "title": "simplest-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n = nums.size();\\n        \\n        vector<int>ans(n);\\n\\t\\t\\n        int j = 0;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(nums[i] < pivot)\\n            {\\n                ans[j++] = nums[i];\\n            }\\n        }\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(nums[i] == pivot)\\n            {\\n                ans[j++] = nums[i];\\n            }\\n        }\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(nums[i] > pivot)\\n            {\\n                ans[j++] = nums[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n = nums.size();\\n        \\n        vector<int>ans(n);\\n\\t\\t\\n        int j = 0;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(nums[i] < pivot)\\n            {\\n                ans[j++] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1866266,
                "title": "two-solution-in-c",
                "content": "**First Approach**\\n```\\n vector<int>x;\\n int n=nums.size();\\n    for(int i=0;i<n;i++){\\n        if(nums[i]<pivot)\\n        x.push_back(nums[i]);\\n      }\\n      for(int i=0;i<n;i++){\\n        if(nums[i]==pivot)\\n\\t\\t\\tx.push_back(nums[i]);\\n      }\\n       for(int i=0;i<n;i++){\\n        if(nums[i]>pivot)\\n\\t\\t\\tx.push_back(nums[i]);\\n      }\\n   return x;  \\n ```\\n \\n****   Second Approach using STL****\\n   ```\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n       stable_partition(nums.begin() , nums.end(), [&](int x){\\n         return x < pivot;   \\n        });\\n        stable_partition(nums.begin() , nums.end(), [&](int x){\\n         return x<=pivot;   \\n        });\\n        return nums;\\n   ```\\n  If you found my solution useful, Kindly upvote\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int>x;\\n int n=nums.size();\\n    for(int i=0;i<n;i++){\\n        if(nums[i]<pivot)\\n        x.push_back(nums[i]);\\n      }\\n      for(int i=0;i<n;i++){\\n        if(nums[i]==pivot)\\n\\t\\t\\tx.push_back(nums[i]);\\n      }\\n       for(int i=0;i<n;i++){\\n        if(nums[i]>pivot)\\n\\t\\t\\tx.push_back(nums[i]);\\n      }\\n   return x;  \\n ```\n```\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n       stable_partition(nums.begin() , nums.end(), [&](int x){\\n         return x < pivot;   \\n        });\\n        stable_partition(nums.begin() , nums.end(), [&](int x){\\n         return x<=pivot;   \\n        });\\n        return nums;\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1810388,
                "title": "c-simple-to-understand-explanation-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    //Time Complexity:O(N)\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        //less array to store elements less than pivot\\n        //more array to store elements more than pivot\\n        vector<int>less,more;\\n        \\n        //cnt: freq. of pivot in array\\n        int cnt=0;\\n        for(auto x:nums){\\n            if(x==pivot){\\n                cnt++;\\n            }\\n            else if(x<pivot){\\n                less.push_back(x);\\n            }\\n            else {\\n                more.push_back(x);\\n            }\\n        }\\n        \\n        //The Vector we need to form\\n        // [less,pivot(cnt times),more]\\n        \\n        //Push the less elements in the res\\n        vector<int>res;\\n        for(auto x:less){\\n            res.push_back(x);\\n        }\\n        \\n        //Push the pivot elements in the res cnt times\\n        for(int i=0; i<cnt; ++i){\\n            res.push_back(pivot);\\n        }\\n        //res.push_back(pivot);\\n        \\n        //Push the more elements in the res\\n        for(auto x:more){\\n            res.push_back(x);\\n        }\\n        \\n        //Return the vector\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time Complexity:O(N)\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        //less array to store elements less than pivot\\n        //more array to store elements more than pivot\\n        vector<int>less,more;\\n        \\n        //cnt: freq. of pivot in array\\n        int cnt=0;\\n        for(auto x:nums){\\n            if(x==pivot){\\n                cnt++;\\n            }\\n            else if(x<pivot){\\n                less.push_back(x);\\n            }\\n            else {\\n                more.push_back(x);\\n            }\\n        }\\n        \\n        //The Vector we need to form\\n        // [less,pivot(cnt times),more]\\n        \\n        //Push the less elements in the res\\n        vector<int>res;\\n        for(auto x:less){\\n            res.push_back(x);\\n        }\\n        \\n        //Push the pivot elements in the res cnt times\\n        for(int i=0; i<cnt; ++i){\\n            res.push_back(pivot);\\n        }\\n        //res.push_back(pivot);\\n        \\n        //Push the more elements in the res\\n        for(auto x:more){\\n            res.push_back(x);\\n        }\\n        \\n        //Return the vector\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747701,
                "title": "c-brute-optimal-easy-to-understand",
                "content": "BRUTE FORCE SOLUTION USING 2 VECTORS :\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> less;\\n        vector<int> great;\\n        int same=0;\\n        for(auto it:nums){\\n            if(it>pivot) great.push_back(it);\\n            else if(it<pivot) less.push_back(it);\\n            else same++;\\n        }\\n        if(same>0){\\n            while(same>0){\\n                less.push_back(pivot);\\n                same--;\\n            }\\n        }\\n        if(great.size()>0){\\n            \\n            for(auto it: great){\\n                less.push_back(it);\\n            }\\n        }\\n        return less;\\n        \\n    }\\n};\\n\\n```\\n\\nSLIGHTLY BETTER SOLUTION :\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> ans(nums.size());\\n        int pos=0;\\n        \\n        for(auto it: nums){\\n            if(it<pivot) ans[pos++]=it;\\n        }\\n        for(auto it: nums){\\n            if(it==pivot) ans[pos++]=it;\\n        }\\n        for(auto it: nums){\\n            if(it>pivot) ans[pos++]=it;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> less;\\n        vector<int> great;\\n        int same=0;\\n        for(auto it:nums){\\n            if(it>pivot) great.push_back(it);\\n            else if(it<pivot) less.push_back(it);\\n            else same++;\\n        }\\n        if(same>0){\\n            while(same>0){\\n                less.push_back(pivot);\\n                same--;\\n            }\\n        }\\n        if(great.size()>0){\\n            \\n            for(auto it: great){\\n                less.push_back(it);\\n            }\\n        }\\n        return less;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> ans(nums.size());\\n        int pos=0;\\n        \\n        for(auto it: nums){\\n            if(it<pivot) ans[pos++]=it;\\n        }\\n        for(auto it: nums){\\n            if(it==pivot) ans[pos++]=it;\\n        }\\n        for(auto it: nums){\\n            if(it>pivot) ans[pos++]=it;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747682,
                "title": "kotlin-o-n-solution-with-3-pointers",
                "content": "The idea to the solution is the following. Let\\'s count elements that are less than `pivot` and elements that are equal to `pivot`. After that we can create new array and create three insertion pointers: `less`, `equal` and `greater`. Each pointer points to the index where elements less than `pivot`, equal to `pivot` and greater to `pivot` should be inserted. Obviously, `less` will always be equal to `0`, `equal` will be equal to the count of elements that are less than `pivot` (we are kind of preserving the space for those elements), and `greater` will be equal to the sum of counts of elements that are less than `pivot` and `equal` to pivot (same approach of preserving the space for those elements). After we set initial state of pointers we traverse the array again and put each element to its dedicated space, increasing pointers accordingly. For example, when we meet the element that is less than `pivot`, we place this element at `less` index and increase `less` by one. We do the same for `equal` and `greater`.\\n\\n```\\nclass Solution {\\n    fun pivotArray(nums: IntArray, pivot: Int): IntArray {\\n        var lessCount = 0\\n        var equalCount = 0\\n        for (num in nums) {\\n            if (num < pivot) lessCount++\\n            if (num == pivot) equalCount++\\n        }\\n        \\n        var lessInsert = 0\\n        var equalInsert = lessCount\\n        var greaterInsert = equalCount + lessCount\\n        val result = IntArray(nums.size)\\n        for (num in nums) {\\n            when {\\n                num < pivot -> result[lessInsert++] = num\\n                num == pivot -> result[equalInsert++] = num\\n                num > pivot -> result[greaterInsert++] = num\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun pivotArray(nums: IntArray, pivot: Int): IntArray {\\n        var lessCount = 0\\n        var equalCount = 0\\n        for (num in nums) {\\n            if (num < pivot) lessCount++\\n            if (num == pivot) equalCount++\\n        }\\n        \\n        var lessInsert = 0\\n        var equalInsert = lessCount\\n        var greaterInsert = equalCount + lessCount\\n        val result = IntArray(nums.size)\\n        for (num in nums) {\\n            when {\\n                num < pivot -> result[lessInsert++] = num\\n                num == pivot -> result[equalInsert++] = num\\n                num > pivot -> result[greaterInsert++] = num\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747491,
                "title": "python-solution-with-a-single-list",
                "content": "Solution:\\n1. Consider three individual variables that will store the number of elements smaller than the pivot, the pivot number and the number of elements greater than the pivot\\n2. Using these indices store the values into resulting array\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        left = 0 \\n        right = 0 \\n        same_ele = 0 \\n        for num in nums:\\n            if num > pivot:\\n                right += 1\\n            elif num < pivot:\\n                left += 1\\n            else:\\n                same_ele += 1\\n        same_ele += left \\n        ans = [0]*len(nums)\\n        l = 1 \\n        for num in nums:\\n            if num < pivot and l <= left:\\n                ans[l-1] = num\\n                l += 1\\n            elif num > pivot:\\n                ans[-right] = num\\n                right -=1 \\n            else:\\n                ans[same_ele-1] = num\\n                same_ele -=1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        left = 0 \\n        right = 0 \\n        same_ele = 0 \\n        for num in nums:\\n            if num > pivot:\\n                right += 1\\n            elif num < pivot:\\n                left += 1\\n            else:\\n                same_ele += 1\\n        same_ele += left \\n        ans = [0]*len(nums)\\n        l = 1 \\n        for num in nums:\\n            if num < pivot and l <= left:\\n                ans[l-1] = num\\n                l += 1\\n            elif num > pivot:\\n                ans[-right] = num\\n                right -=1 \\n            else:\\n                ans[same_ele-1] = num\\n                same_ele -=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747359,
                "title": "easiest-c-solution-o-n-time-complexity-o-1-space-simple-to-understand-100-faster",
                "content": "Easiest Solution, \\n\\n**Approach**\\n****\\n1.  Create one result array of same size.\\n1.  Run a loop to store all elements less that pivot\\n1.  Again Run a loop and store all elements equal to pivot from next index.\\n1.  Again Run a loop and store all elements greater to pivot from next index.\\n1.  NO MORE STEPS, JUST RETURN RESULT ARRAY\\n```\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        int n=nums.size();\\n        vector<int> ans(n);\\n        \\n        int l=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<pivot){\\n                ans[l++]=nums[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==pivot){\\n                 ans[l++]=nums[i];\\n            }\\n        }\\n          for(int i=0;i<n;i++){\\n            if(nums[i]>pivot){\\n                 ans[l++]=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    \\n    }\\n```\\n\\nAbove solution is O(N) Space,\\nbut we can do in O(1) by sorting\\n\\nWhy Stable Sort,\\nStable sort use to maintain order of elements as per original array after sorting as per given comparator\\n\\nComparator:\\nif first element < pivot and second element >= pivot return true, it means no swap required\\nif first==pivot and second element > pivot return true\\n\\n```\\nint key;\\nbool custom(int a, int b) {\\n    return ((a<key && b>=key) || (a==key && b>key));\\n}\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        key=pivot;\\n        stable_sort(nums.begin(), nums.end(), custom);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        int n=nums.size();\\n        vector<int> ans(n);\\n        \\n        int l=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<pivot){\\n                ans[l++]=nums[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==pivot){\\n                 ans[l++]=nums[i];\\n            }\\n        }\\n          for(int i=0;i<n;i++){\\n            if(nums[i]>pivot){\\n                 ans[l++]=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    \\n    }\\n```\n```\\nint key;\\nbool custom(int a, int b) {\\n    return ((a<key && b>=key) || (a==key && b>key));\\n}\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        key=pivot;\\n        stable_sort(nums.begin(), nums.end(), custom);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747135,
                "title": "simple-logic-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int>left,right,equal;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<pivot)\\n            {\\n                left.push_back(nums[i]);\\n            }\\n            if(nums[i]==pivot)\\n            {\\n                equal.push_back(nums[i]);\\n            }\\n            if(nums[i]>pivot)\\n            {\\n                right.push_back(nums[i]);\\n            }\\n        }\\n        \\n        int j=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            nums[j]=left[i];\\n            j++;\\n        }\\n        for(int i=0;i<equal.size();i++)\\n        {\\n            nums[j]=equal[i];\\n            j++;\\n        }\\n        for(int i=0;i<right.size();i++)\\n        {\\n            nums[j]=right[i];\\n            j++;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int>left,right,equal;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<pivot)\\n            {\\n                left.push_back(nums[i]);\\n            }\\n            if(nums[i]==pivot)\\n            {\\n                equal.push_back(nums[i]);\\n            }\\n            if(nums[i]>pivot)\\n            {\\n                right.push_back(nums[i]);\\n            }\\n        }\\n        \\n        int j=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            nums[j]=left[i];\\n            j++;\\n        }\\n        for(int i=0;i<equal.size();i++)\\n        {\\n            nums[j]=equal[i];\\n            j++;\\n        }\\n        for(int i=0;i<right.size();i++)\\n        {\\n            nums[j]=right[i];\\n            j++;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939505,
                "title": "java-easy-o-1-space-approach",
                "content": "# Intuition\\nApply the idea similar to insertion sort.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < pivot){\\n                for(int j = i; j > 0 && nums[j - 1] >= pivot; j--){\\n                    int tmp = nums[j];\\n                    nums[j] = nums[j - 1];\\n                    nums[j - 1] = tmp;\\n                }\\n            }\\n            if(nums[i] == pivot){\\n                for(int j = i; j > 0 && nums[j - 1] > pivot; j--){\\n                    int tmp = nums[j];\\n                    nums[j] = nums[j - 1];\\n                    nums[j - 1] = tmp;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < pivot){\\n                for(int j = i; j > 0 && nums[j - 1] >= pivot; j--){\\n                    int tmp = nums[j];\\n                    nums[j] = nums[j - 1];\\n                    nums[j - 1] = tmp;\\n                }\\n            }\\n            if(nums[i] == pivot){\\n                for(int j = i; j > 0 && nums[j - 1] > pivot; j--){\\n                    int tmp = nums[j];\\n                    nums[j] = nums[j - 1];\\n                    nums[j - 1] = tmp;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858935,
                "title": "very-very-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>v;\\n        for(auto it:nums)\\n        {\\n            if(it<pivot)\\n            {\\n                v.push_back(it);\\n            }\\n        }\\n        for(auto it:nums)\\n        {\\n            if(it==pivot)\\n            {\\n                v.push_back(it);\\n            }\\n        }\\n        for(auto it:nums)\\n        {\\n            if(it>pivot)\\n            {\\n                v.push_back(it);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>v;\\n        for(auto it:nums)\\n        {\\n            if(it<pivot)\\n            {\\n                v.push_back(it);\\n            }\\n        }\\n        for(auto it:nums)\\n        {\\n            if(it==pivot)\\n            {\\n                v.push_back(it);\\n            }\\n        }\\n        for(auto it:nums)\\n        {\\n            if(it>pivot)\\n            {\\n                v.push_back(it);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794685,
                "title": "javascript-1-liner-sorting-using-custom-comparator-crazy-idea",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter thinking a bit, you might notice, that it\\'s a kind of a sorting problem - we just place all the elements that < pivot first.\\n\\nObviously you have to use a stable sorting to maintain the relative order of elements.\\n\\nPS: I know, that this wouldn\\'t be an acceptable solution at interview\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} pivot\\n * @return {number[]}\\n */\\nvar pivotArray = function(nums, pivot) {\\n    return nums.sort((a, b) => Math.sign(a-pivot) - Math.sign(b-pivot));\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} pivot\\n * @return {number[]}\\n */\\nvar pivotArray = function(nums, pivot) {\\n    return nums.sort((a, b) => Math.sign(a-pivot) - Math.sign(b-pivot));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546380,
                "title": "o-n-elegant-swifty-solution",
                "content": "# Approach\\nThe fundamental concept revolves around sequentially traversing each element, contrasting it with a predetermined pivot value, and subsequently categorizing it into one of three designated compartments. These compartments facilitate the subsequent reorganization of elements that fall into the categories of being smaller than, equal to, or larger than the pivot value.\\n\\n# Time complexity\\n**O(n)**\\nThe time complexity of the function is linear. This is because the function only contains a single loop that iterates over the input array once. Inside the loop, all operations (comparing the current element to the pivot, remapping it to a Kind value, and appending it to an array in the dictionary) are constant time operations. Therefore, the total time complexity is `O(n)`, where n is the size of the input array.\\n\\n# Space complexity\\n**O(n)**\\nThe space complexity of the function is also linear. This is because the function creates a new dictionary that can potentially store all elements of the input array. In the worst-case scenario, where all elements of the input array are unique, the dictionary will contain n elements. Therefore, the space complexity is `O(n)`, where n is the size of the input array.\\n\\n# Solution\\n```swift\\nclass Solution {\\n    func pivotArray(_ nums: [Int], _ pivot: Int) -> [Int] {\\n        // This enumeration will be used to categorize the integers \\n        // in the input array relative to the pivot value.    \\n        enum Kind: Hashable {\\n            case smaller\\n            case greater\\n            case equal\\n        }\\n        // This function takes an integer as input and returns a \\n        // Kind value indicating how the input compares to the pivot value.\\n        func remap(_ num: Int) -> Kind {\\n            num == pivot ? .equal : num > pivot ? .greater : .smaller\\n        }\\n        // This dictionary will be used to store the integers in the input \\n        // array according to their categories defined by the Kind enum.\\n        var map = [Kind: [Int]]()\\n        \\n        // Classify the integers and store them in the dictionary\\n        for num in nums {\\n            map[remap(num), default: []] += [num]\\n        }\\n        // Helper function to extract a certain kind safely\\n        func values(for kind: Kind) -> [Int] {\\n            map[kind] ?? []\\n        }\\n        // Concatinate the results\\n        return values(for: .smaller) + values(for: .equal) + values(for: .greater)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Enumeration"
                ],
                "code": "```swift\\nclass Solution {\\n    func pivotArray(_ nums: [Int], _ pivot: Int) -> [Int] {\\n        // This enumeration will be used to categorize the integers \\n        // in the input array relative to the pivot value.    \\n        enum Kind: Hashable {\\n            case smaller\\n            case greater\\n            case equal\\n        }\\n        // This function takes an integer as input and returns a \\n        // Kind value indicating how the input compares to the pivot value.\\n        func remap(_ num: Int) -> Kind {\\n            num == pivot ? .equal : num > pivot ? .greater : .smaller\\n        }\\n        // This dictionary will be used to store the integers in the input \\n        // array according to their categories defined by the Kind enum.\\n        var map = [Kind: [Int]]()\\n        \\n        // Classify the integers and store them in the dictionary\\n        for num in nums {\\n            map[remap(num), default: []] += [num]\\n        }\\n        // Helper function to extract a certain kind safely\\n        func values(for kind: Kind) -> [Int] {\\n            map[kind] ?? []\\n        }\\n        // Concatinate the results\\n        return values(for: .smaller) + values(for: .equal) + values(for: .greater)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542983,
                "title": "100-memory-o-log-n-space-adaptation-of-mergesort",
                "content": "# Intuition\\nA constant space complexity is possible through an adapted version of bubblesort, but this algorithm exceeds the time limit imposed. On the other hand, we can achieve $log(n)$ extra space by using an adapted version of mergesort.\\n\\n# Approach\\nA slight change was made to the `merge` procedure of mergesort, such that any element less than the pivot comes before any element equal to the pivot, which in turn comes before any element greater than the pivot. This procedure is preformed in a stable manner for elements different than the pivot, i.e., the relative order of these elements is preserved.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n- Space complexity: $$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums, int pivot, int low, int middle, int high) { // O(n)\\n        for (; low < middle && nums[low] < pivot; ++low);\\n        for (; high > middle && nums[high - 1] > pivot; --high);\\n        for (int i = low, j = middle - 1; i < j; ++i, --j) {\\n            swap(nums[i], nums[j]);\\n        }\\n        for (int i = middle, j = high - 1; i < j; ++i, --j) {\\n            swap(nums[i], nums[j]);\\n        }\\n        for (int i = low, j = high - 1; i < j; ++i, --j) {\\n            swap(nums[i], nums[j]);\\n        }\\n    }\\n    void partition(vector<int>& nums, int pivot, int low, int high) {\\n        if (low + 1 < high) {\\n            const auto middle = (low + high) / 2;\\n            partition(nums, pivot, low, middle);\\n            partition(nums, pivot, middle, high);\\n            merge(nums, pivot, low, middle, high); // O(n)\\n        }\\n    }\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        partition(nums, pivot, 0, nums.size());\\n        return move(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int>& nums, int pivot, int low, int middle, int high) { // O(n)\\n        for (; low < middle && nums[low] < pivot; ++low);\\n        for (; high > middle && nums[high - 1] > pivot; --high);\\n        for (int i = low, j = middle - 1; i < j; ++i, --j) {\\n            swap(nums[i], nums[j]);\\n        }\\n        for (int i = middle, j = high - 1; i < j; ++i, --j) {\\n            swap(nums[i], nums[j]);\\n        }\\n        for (int i = low, j = high - 1; i < j; ++i, --j) {\\n            swap(nums[i], nums[j]);\\n        }\\n    }\\n    void partition(vector<int>& nums, int pivot, int low, int high) {\\n        if (low + 1 < high) {\\n            const auto middle = (low + high) / 2;\\n            partition(nums, pivot, low, middle);\\n            partition(nums, pivot, middle, high);\\n            merge(nums, pivot, low, middle, high); // O(n)\\n        }\\n    }\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        partition(nums, pivot, 0, nums.size());\\n        return move(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440032,
                "title": "simple-and-easy-cpp-solution-beginner-friendly-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int l = 0, h = nums.size()-1;\\n        \\n        vector<int> ans;\\n\\n        for(int i=l; i<=h; i++){\\n\\n        \\n            if(nums[i]<pivot){\\n                ans.push_back(nums[i]);\\n        \\n            }\\n        }\\n        for(int i=l; i<=h; i++){\\n            if(nums[i]==pivot){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=l; i<=h; i++){\\n            if(nums[i]>pivot){\\n                ans.push_back(nums[i]);\\n                \\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int l = 0, h = nums.size()-1;\\n        \\n        vector<int> ans;\\n\\n        for(int i=l; i<=h; i++){\\n\\n        \\n            if(nums[i]<pivot){\\n                ans.push_back(nums[i]);\\n        \\n            }\\n        }\\n        for(int i=l; i<=h; i++){\\n            if(nums[i]==pivot){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=l; i<=h; i++){\\n            if(nums[i]>pivot){\\n                ans.push_back(nums[i]);\\n                \\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376240,
                "title": "easy-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int l=0,g=0,e=0;\\n        for(auto it:nums){\\n            if(it<pivot)l++;\\n            else if(it==pivot)e++;\\n        }\\n        vector<int>res(nums.size());\\n        g=l+e;\\n        e=l;\\n        l=0;\\n        for(auto it:nums){\\n            if(it<pivot){\\n                res[l]=it,l++;\\n            }else if(it==pivot)res[e]=it,e++;\\n            else res[g]=it,g++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int l=0,g=0,e=0;\\n        for(auto it:nums){\\n            if(it<pivot)l++;\\n            else if(it==pivot)e++;\\n        }\\n        vector<int>res(nums.size());\\n        g=l+e;\\n        e=l;\\n        l=0;\\n        for(auto it:nums){\\n            if(it<pivot){\\n                res[l]=it,l++;\\n            }else if(it==pivot)res[e]=it,e++;\\n            else res[g]=it,g++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360379,
                "title": "95-beat-veray-easy-understand-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->ITERATIVE APPROACH\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> pivotArray(vector<int> &nums, int pivot)\\n\\t{\\n\\t\\tvector<int> store1;\\n\\t\\tvector<int> store2;\\n\\n\\t\\tint n = nums.size();\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (nums[i] < pivot)\\n\\t\\t\\t\\tstore1.push_back(nums[i]);\\n\\t\\t\\telse if (nums[i] == pivot)\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstore2.push_back(nums[i]);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < count; i++)\\n\\t\\t\\tstore1.push_back(pivot);\\n\\n\\t    store1.push_back(store2);\\n\\n\\t\\treturn store1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> pivotArray(vector<int> &nums, int pivot)\\n\\t{\\n\\t\\tvector<int> store1;\\n\\t\\tvector<int> store2;\\n\\n\\t\\tint n = nums.size();\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (nums[i] < pivot)\\n\\t\\t\\t\\tstore1.push_back(nums[i]);\\n\\t\\t\\telse if (nums[i] == pivot)\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstore2.push_back(nums[i]);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < count; i++)\\n\\t\\t\\tstore1.push_back(pivot);\\n\\n\\t    store1.push_back(store2);\\n\\n\\t\\treturn store1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204063,
                "title": "python3-beats-73-42-beginner-s-solution",
                "content": "# Please upvote if you find the solution helpful.\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l_lst = []\\n        for i in range(len(nums)):\\n            if nums[i] < pivot:\\n                l_lst.append(nums[i])\\n        for i in range(len(nums)):\\n            if nums[i]==pivot:\\n                l_lst.append(nums[i])\\n        for i in range(len(nums)):\\n            if nums[i]>pivot:\\n                l_lst.append(nums[i])\\n        return l_lst\\n\\n```\\n                                    or\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l_lst = []\\n        m_lst=[]\\n        h_lst=[]\\n        for i in range(len(nums)):\\n            if nums[i] < pivot:\\n                l_lst.append(nums[i])\\n            elif nums[i]==pivot:\\n                m_lst.append(nums[i])\\n            else:\\n                h_lst.append(nums[i])\\n        return l_lst+m_lst+h_lst\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l_lst = []\\n        for i in range(len(nums)):\\n            if nums[i] < pivot:\\n                l_lst.append(nums[i])\\n        for i in range(len(nums)):\\n            if nums[i]==pivot:\\n                l_lst.append(nums[i])\\n        for i in range(len(nums)):\\n            if nums[i]>pivot:\\n                l_lst.append(nums[i])\\n        return l_lst\\n\\n```\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l_lst = []\\n        m_lst=[]\\n        h_lst=[]\\n        for i in range(len(nums)):\\n            if nums[i] < pivot:\\n                l_lst.append(nums[i])\\n            elif nums[i]==pivot:\\n                m_lst.append(nums[i])\\n            else:\\n                h_lst.append(nums[i])\\n        return l_lst+m_lst+h_lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203997,
                "title": "java-easy-simple-4-ms",
                "content": "# - - - Java - - -\\n\\n# Complexity\\n- Time complexity:\\n$$4(ms)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n        int l = nums.length;\\n        int[] ans = new int[l];\\n        int ans_l = 0;\\n\\n        for (int i = 0; i < l; i++) {\\n            if (nums[i] < pivot) {\\n                ans[ans_l] = nums[i];\\n                ans_l++;\\n            }\\n        }\\n        for (int i = 0; i < l; i++) {\\n            if (nums[i] == pivot) {\\n                ans[ans_l] = nums[i];\\n                ans_l++;\\n            }\\n        }\\n        for (int i = 0; i < l; i++) {\\n            if (nums[i] > pivot) {\\n                ans[ans_l] = nums[i];\\n                ans_l++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n        int l = nums.length;\\n        int[] ans = new int[l];\\n        int ans_l = 0;\\n\\n        for (int i = 0; i < l; i++) {\\n            if (nums[i] < pivot) {\\n                ans[ans_l] = nums[i];\\n                ans_l++;\\n            }\\n        }\\n        for (int i = 0; i < l; i++) {\\n            if (nums[i] == pivot) {\\n                ans[ans_l] = nums[i];\\n                ans_l++;\\n            }\\n        }\\n        for (int i = 0; i < l; i++) {\\n            if (nums[i] > pivot) {\\n                ans[ans_l] = nums[i];\\n                ans_l++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198338,
                "title": "easy-python3-solution",
                "content": "# Approach\\nbasic approach to create lists to divide the numbers on teh basis of the condition in the question\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, arr: List[int], x: int) -> List[int]:\\n        small=[]\\n        gre=[]\\n        same=[]\\n        for i in range(len(arr)):\\n            if arr[i]<x:\\n                small.append(arr[i])\\n            elif arr[i]==x:\\n                same.append(arr[i])\\n            else:\\n                gre.append(arr[i])\\n        return small+same+gre\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, arr: List[int], x: int) -> List[int]:\\n        small=[]\\n        gre=[]\\n        same=[]\\n        for i in range(len(arr)):\\n            if arr[i]<x:\\n                small.append(arr[i])\\n            elif arr[i]==x:\\n                same.append(arr[i])\\n            else:\\n                gre.append(arr[i])\\n        return small+same+gre\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179315,
                "title": "simple-solution-easy-logic-to-understand",
                "content": "# Intuition\\nUse 3 list to store numbers which are less than pivot, equal to pivot and greater than pivot. Then combine them together.\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] PivotArray(int[] nums, int pivot) {\\n        var less = new List<int>();\\n        var equal = new List<int>();\\n        var greater = new List<int>();\\n        for(int i=0;i<nums.Length;i++){\\n            switch(nums[i]){\\n                case int x when x < pivot : less.Add(x);break;\\n                case int x when x == pivot : equal.Add(x);break;\\n                case int x when x > pivot : greater.Add(x);break;\\n            }            \\n        }\\n        less.AddRange(equal);\\n        less.AddRange(greater);\\n        return less.ToArray();        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] PivotArray(int[] nums, int pivot) {\\n        var less = new List<int>();\\n        var equal = new List<int>();\\n        var greater = new List<int>();\\n        for(int i=0;i<nums.Length;i++){\\n            switch(nums[i]){\\n                case int x when x < pivot : less.Add(x);break;\\n                case int x when x == pivot : equal.Add(x);break;\\n                case int x when x > pivot : greater.Add(x);break;\\n            }            \\n        }\\n        less.AddRange(equal);\\n        less.AddRange(greater);\\n        return less.ToArray();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134131,
                "title": "pythonic-solution-using-filter",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        return (\\n            list(filter(lambda x: x < pivot, nums)) +\\n            list(filter(lambda x: x == pivot, nums)) +\\n            list(filter(lambda x: x > pivot, nums))\\n        )\\n```\\n\\nIt is possible to build the 3 components in a single pass through `nums`, but it is more idiomatic and easy to read using 3 filtes.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        return (\\n            list(filter(lambda x: x < pivot, nums)) +\\n            list(filter(lambda x: x == pivot, nums)) +\\n            list(filter(lambda x: x > pivot, nums))\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019148,
                "title": "python3-solution-with-using-two-pointers",
                "content": "# Code\\n```\\n# class Solution:\\n#     def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n#         g = [] # greater than pivot\\n#         l = [] # less than pivot\\n#         eq = [] # eq\\n\\n#         for num in nums:\\n#             if num > pivot:\\n#                 g.append(num)\\n#             elif num < pivot:\\n#                 l.append(num)\\n#             else:\\n#                 eq.append(num)\\n\\n        \\n#         return l + eq + g\\n\\n\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        g = [] # greater than pivot\\n\\n        last = 0\\n        eq_cnt = 0\\n        for idx in range(len(nums)):\\n            if nums[idx] > pivot:\\n                g.append(nums[idx])\\n            elif nums[idx] < pivot:\\n                nums[last], nums[idx] = nums[idx], nums[last]\\n                last += 1\\n            else:\\n                eq_cnt += 1\\n        \\n        cur_idx = last\\n        g_idx = 0\\n        while cur_idx < len(nums):\\n            if eq_cnt > 0:\\n                nums[cur_idx] = pivot\\n                eq_cnt -= 1\\n            else:\\n                nums[cur_idx] = g[g_idx]\\n                g_idx += 1\\n\\n            cur_idx += 1\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n# class Solution:\\n#     def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n#         g = [] # greater than pivot\\n#         l = [] # less than pivot\\n#         eq = [] # eq\\n\\n#         for num in nums:\\n#             if num > pivot:\\n#                 g.append(num)\\n#             elif num < pivot:\\n#                 l.append(num)\\n#             else:\\n#                 eq.append(num)\\n\\n        \\n#         return l + eq + g\\n\\n\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        g = [] # greater than pivot\\n\\n        last = 0\\n        eq_cnt = 0\\n        for idx in range(len(nums)):\\n            if nums[idx] > pivot:\\n                g.append(nums[idx])\\n            elif nums[idx] < pivot:\\n                nums[last], nums[idx] = nums[idx], nums[last]\\n                last += 1\\n            else:\\n                eq_cnt += 1\\n        \\n        cur_idx = last\\n        g_idx = 0\\n        while cur_idx < len(nums):\\n            if eq_cnt > 0:\\n                nums[cur_idx] = pivot\\n                eq_cnt -= 1\\n            else:\\n                nums[cur_idx] = g[g_idx]\\n                g_idx += 1\\n\\n            cur_idx += 1\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861961,
                "title": "python3-easytounderstand-using-one-loop",
                "content": "faster than 84.98%\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in range(len(nums)):\\n            if(nums[i]<pivot):\\n                a.append(nums[i])\\n            elif(nums[i]>pivot):\\n                b.append(nums[i])\\n            else:\\n                c.append(nums[i])\\n        return a+c+b\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in range(len(nums)):\\n            if(nums[i]<pivot):\\n                a.append(nums[i])\\n            elif(nums[i]>pivot):\\n                b.append(nums[i])\\n            else:\\n                c.append(nums[i])\\n        return a+c+b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792607,
                "title": "simple-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLinear search\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n       vector<int> ans;\\n\\n       for(auto i : nums){\\n           if(i < pivot)\\n            ans.push_back(i);\\n       }\\n\\n       for(auto i : nums){\\n           if(i == pivot)\\n            ans.push_back(i);\\n       }\\n\\n       for(auto i : nums){\\n           if(i > pivot)\\n            ans.push_back(i);\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n       vector<int> ans;\\n\\n       for(auto i : nums){\\n           if(i < pivot)\\n            ans.push_back(i);\\n       }\\n\\n       for(auto i : nums){\\n           if(i == pivot)\\n            ans.push_back(i);\\n       }\\n\\n       for(auto i : nums){\\n           if(i > pivot)\\n            ans.push_back(i);\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621250,
                "title": "javascript-two-pointers",
                "content": "```\\nfunction pivotArray(nums: number[], pivot: number): number[] {\\n    const result = new Array(nums.length);\\n    let beforeI = 0;\\n    let afterI = nums.length - 1;\\n    \\n    for (let i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n        if (nums[i] < pivot) {\\n            result[beforeI] = nums[i];\\n            beforeI++;\\n        }\\n        \\n        if (nums[j] > pivot) {\\n            result[afterI] = nums[j];\\n            afterI--;\\n        }\\n    }\\n    \\n    for (let i = beforeI; i <= afterI; i++) {\\n        result[i] = pivot;\\n    }\\n    \\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\nfunction pivotArray(nums: number[], pivot: number): number[] {\\n    const result = new Array(nums.length);\\n    let beforeI = 0;\\n    let afterI = nums.length - 1;\\n    \\n    for (let i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n        if (nums[i] < pivot) {\\n            result[beforeI] = nums[i];\\n            beforeI++;\\n        }\\n        \\n        if (nums[j] > pivot) {\\n            result[afterI] = nums[j];\\n            afterI--;\\n        }\\n    }\\n    \\n    for (let i = beforeI; i <= afterI; i++) {\\n        result[i] = pivot;\\n    }\\n    \\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2597890,
                "title": "python-stack-two-pointer",
                "content": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        ans = [pivot]*len(nums)\\n        i,j=0,len(nums)-1\\n        stack = []\\n        for n in nums:\\n            if n < pivot:\\n                ans[i]=n\\n                i+=1\\n            elif n > pivot:\\n                stack.append(n)\\n        while stack:\\n            ans[j]=stack.pop()\\n            j-=1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        ans = [pivot]*len(nums)\\n        i,j=0,len(nums)-1\\n        stack = []\\n        for n in nums:\\n            if n < pivot:\\n                ans[i]=n\\n                i+=1\\n            elif n > pivot:\\n                stack.append(n)\\n        while stack:\\n            ans[j]=stack.pop()\\n            j-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584021,
                "title": "java-very-easy-noob-approach-brute-force",
                "content": "# Please Upvote\\n\\n```\\nList<Integer> left = new ArrayList<>(), right = new ArrayList<>(), equal = new ArrayList<>(), ans = new ArrayList<>();\\n        for(int i : nums){\\n            if(i < pivot)\\n                left.add(i);\\n            if(i == pivot)\\n                equal.add(i);\\n            if(i > pivot)\\n                right.add(i);\\n        }\\n        for(int i : left)\\n            ans.add(i);\\n        for(int i : equal)\\n            ans.add(i);\\n        for(int i : right)\\n            ans.add(i);\\n        int res[] = new int[ans.size()];\\n        for(int i = 0; i < ans.size(); i++)\\n            res[i] = ans.get(i);\\n        return res;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nList<Integer> left = new ArrayList<>(), right = new ArrayList<>(), equal = new ArrayList<>(), ans = new ArrayList<>();\\n        for(int i : nums){\\n            if(i < pivot)\\n                left.add(i);\\n            if(i == pivot)\\n                equal.add(i);\\n            if(i > pivot)\\n                right.add(i);\\n        }\\n        for(int i : left)\\n            ans.add(i);\\n        for(int i : equal)\\n            ans.add(i);\\n        for(int i : right)\\n            ans.add(i);\\n        int res[] = new int[ans.size()];\\n        for(int i = 0; i < ans.size(); i++)\\n            res[i] = ans.get(i);\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2516094,
                "title": "c-three-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivote) \\n    {\\n        int low=0,same=0;\\n        for(auto &n:nums)\\n        {\\n            if(n<pivote)\\n                low++;\\n            else if(n==pivote)\\n                same++;\\n        }\\n        int high=same+low;\\n        same=low;\\n        low=0;\\n        vector<int> res(nums.size());\\n        for( auto &n:nums)\\n        {\\n            if(n<pivote)\\n            {\\n                res[low++]=n;\\n            }\\n            else if(n==pivote)\\n            {\\n                res[same++]=n;\\n            }\\n            else\\n            {\\n                res[high++]=n;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivote) \\n    {\\n        int low=0,same=0;\\n        for(auto &n:nums)\\n        {\\n            if(n<pivote)\\n                low++;\\n            else if(n==pivote)\\n                same++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2408307,
                "title": "c-simple-easy-understanding-vectors",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> v1;\\n        vector<int> v2;\\n        vector<int> v3;\\n        vector<int> v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]<pivot)\\n          {\\n              v1.push_back(nums[i]);\\n          }\\n            else if(nums[i]==pivot)\\n            {\\n                v2.push_back(nums[i]);\\n            }\\n            else{\\n                v3.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int i=0;i<v1.size();i++)\\n        {\\n            v.push_back(v1[i]);\\n        }\\n        \\n         for(int i=0;i<v2.size();i++)\\n        {\\n            v.push_back(v2[i]);\\n        }\\n        \\n         for(int i=0;i<v3.size();i++)\\n        {\\n            v.push_back(v3[i]);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> v1;\\n        vector<int> v2;\\n        vector<int> v3;\\n        vector<int> v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]<pivot)\\n          {\\n              v1.push_back(nums[i]);\\n          }\\n            else if(nums[i]==pivot)\\n            {\\n                v2.push_back(nums[i]);\\n            }\\n            else{\\n                v3.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int i=0;i<v1.size();i++)\\n        {\\n            v.push_back(v1[i]);\\n        }\\n        \\n         for(int i=0;i<v2.size();i++)\\n        {\\n            v.push_back(v2[i]);\\n        }\\n        \\n         for(int i=0;i<v3.size();i++)\\n        {\\n            v.push_back(v3[i]);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386719,
                "title": "c-step-by-step-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>v;\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(pivot==nums[i]){\\n                cnt++;\\n            }\\n            if(nums[i]<pivot){\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>pivot){\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        int i;\\n        for(i=0;i<v.size();i++){\\n            if(v[i]>pivot){\\n                break;\\n            }\\n        }\\n        v.insert(v.begin()+i, cnt,pivot);\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>v;\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(pivot==nums[i]){\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2374212,
                "title": "c-simple-and-clean-solution-for-beginners",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nvector<int> pivotArray(vector<int>& nums, int pivot) \\n    {\\n        vector<int> front;\\n        vector<int> end;\\n        int same=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<pivot)\\n                front.push_back(nums[i]);\\n            else if(nums[i]==pivot)\\n                same++;\\n            else if(nums[i]>pivot)\\n                end.push_back(nums[i]);\\n        }\\n        while(same)\\n        {\\n            front.push_back(pivot);\\n            same--;\\n        }\\n        for(int i=0;i<end.size();i++)\\n        {\\n            front.push_back(end[i]);\\n        }\\n        return front;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> pivotArray(vector<int>& nums, int pivot) \\n    {\\n        vector<int> front;\\n        vector<int> end;\\n        int same=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<pivot)\\n                front.push_back(nums[i]);\\n            else if(nums[i]==pivot)\\n                same++;\\n            else if(nums[i]>pivot)\\n                end.push_back(nums[i]);\\n        }\\n        while(same)\\n        {\\n            front.push_back(pivot);\\n            same--;\\n        }\\n        for(int i=0;i<end.size();i++)\\n        {\\n            front.push_back(end[i]);\\n        }\\n        return front;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2370416,
                "title": "simple-and-easy-o-n",
                "content": "vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> v;\\n        vector<int> vend;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<pivot)\\n            {\\n                v.push_back(nums[i]);\\n            }\\n            else if(nums[i]==pivot)\\n                count++;\\n            else\\n                vend.push_back(nums[i]);\\n                \\n        }\\n        while(count--)\\n            v.push_back(pivot);\\n        v.insert(v.end(),vend.begin(),vend.end());\\n        return v;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> v;\\n        vector<int> vend;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<pivot)\\n            {\\n                v.push_back(nums[i]);\\n            }\\n            else if(nums[i]==pivot)\\n                count++;\\n            else\\n                vend.push_back(nums[i]);\\n                \\n        }\\n        while(count--)\\n            v.push_back(pivot);\\n        v.insert(v.end(),vend.begin(),vend.end());\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2369113,
                "title": "99-94-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int arr[]=new int[nums.length];int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<pivot){\\n                arr[count]=nums[i];\\n                count++;\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==pivot){\\n                arr[count]=nums[i];\\n                count++;\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>pivot){\\n                arr[count]=nums[i];\\n                count++;\\n            }\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int arr[]=new int[nums.length];int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<pivot){\\n                arr[count]=nums[i];\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2317012,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>v1,v2,v3;\\n        for(int i=0;i<nums.size();i++)\\n          if(nums[i]<pivot)\\n              v1.push_back(nums[i]);\\n          else if(nums[i]==pivot)\\n              v3.push_back(nums[i]);\\n          else\\n              v2.push_back(nums[i]);\\n        for(int i=0;i<v3.size();i++)\\n            v1.push_back(v3[i]);\\n        for(int i=0;i<v2.size();i++)\\n            v1.push_back(v2[i]);\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>v1,v2,v3;\\n        for(int i=0;i<nums.size();i++)\\n          if(nums[i]<pivot)\\n              v1.push_back(nums[i]);\\n          else if(nums[i]==pivot)\\n              v3.push_back(nums[i]);\\n          else\\n              v2.push_back(nums[i]);\\n        for(int i=0;i<v3.size();i++)\\n            v1.push_back(v3[i]);\\n        for(int i=0;i<v2.size();i++)\\n            v1.push_back(v2[i]);\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278289,
                "title": "easy-js-solution",
                "content": "```\\nvar pivotArray = function(nums, pivot) {\\n    let minArr = []  //less than pivot\\n    let maxArr = []  //greater than pivot\\n    let equalArr = [] //equal to pivot\\n    nums.filter((e)=>{(e<pivot) ? minArr.push(e) \\n    : (e>pivot) ? maxArr.push(e): equalArr.push(e)})\\n    minArr.push(...equalArr,...maxArr)  // pushed values in first array to maintain respective sequence\\n    return minArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pivotArray = function(nums, pivot) {\\n    let minArr = []  //less than pivot\\n    let maxArr = []  //greater than pivot\\n    let equalArr = [] //equal to pivot\\n    nums.filter((e)=>{(e<pivot) ? minArr.push(e) \\n    : (e>pivot) ? maxArr.push(e): equalArr.push(e)})\\n    minArr.push(...equalArr,...maxArr)  // pushed values in first array to maintain respective sequence\\n    return minArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2268050,
                "title": "c-code-brute-force-using-vectors",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> res;\\n        vector<int> ans;\\n        vector<int> piv;\\n        for(auto i:nums){\\n            if(i<pivot) res.push_back(i);\\n            else if(i>pivot) ans.push_back(i);\\n            else piv.push_back(i);\\n        }\\n        vector<int> v;\\n        for(auto i:res) v.push_back(i);\\n        for(auto j:piv) v.push_back(j);\\n        for(auto k:ans) v.push_back(k);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> res;\\n        vector<int> ans;\\n        vector<int> piv;\\n        for(auto i:nums){\\n            if(i<pivot) res.push_back(i);\\n            else if(i>pivot) ans.push_back(i);\\n            else piv.push_back(i);\\n        }\\n        vector<int> v;\\n        for(auto i:res) v.push_back(i);\\n        for(auto j:piv) v.push_back(j);\\n        for(auto k:ans) v.push_back(k);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251409,
                "title": "python3-straight-forward-and-easy-to-understand",
                "content": "**Solution:**\\n1. store numbers smaller than pivot in \"l\" (left), numbers larger than pivor in \"r\" (right)\\n2. extend \"l\" to include number of pivots according to difference in original list length and total of l + r\\n3. extend \"l\" to include \"r\"\\n\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l = []\\n        r = []\\n        for num in nums:\\n            if num < pivot:\\n                l.append(num)\\n            elif num > pivot:\\n                r.append(num)\\n\\t\\t# add pivot\\n        l.extend([pivot] * (len(nums) - len(l) - len(r)))\\n        l.extend(r)\\n        return l\\n```\\n\\n**Space and time complexity:**\\nTime: O(N)\\nSpace: O(N)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l = []\\n        r = []\\n        for num in nums:\\n            if num < pivot:\\n                l.append(num)\\n            elif num > pivot:\\n                r.append(num)\\n\\t\\t# add pivot\\n        l.extend([pivot] * (len(nums) - len(l) - len(r)))\\n        l.extend(r)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243997,
                "title": "python-3-solution-thinking-with-double-ended-collections",
                "content": "Thought process: \\n1. Initialize two lists for items on each side of the pivot\\n2. For each number check if the number belongs to the right or left side of the pivot \\n3. If the number is on the left then add it to the left list \\n4. If the number is on the right side and num is the pivot then make it the head of the right list\\n5. Otherwise append it to the right list.\\n6. Merge the left list with the right list and return a new list partitioned by the pivot.  \\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l,r = deque(),deque()   \\n        for num in nums:\\n            if num >= pivot:\\n                if num == pivot:\\n                    r.appendleft(num)\\n                else:\\n                    r.append(num)\\n            else:\\n                l.append(num)\\n        return l + r\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l,r = deque(),deque()   \\n        for num in nums:\\n            if num >= pivot:\\n                if num == pivot:\\n                    r.appendleft(num)\\n                else:\\n                    r.append(num)\\n            else:\\n                l.append(num)\\n        return l + r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240313,
                "title": "c-easyy-solution",
                "content": "```\\nvector<int> res;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<pivot)\\n                res.push_back(nums[i]);\\n        }\\n           for(int i=0;i<nums.size();i++){\\n            if(nums[i]==pivot)\\n                res.push_back(nums[i]);\\n        }\\n           for(int i=0;i<nums.size();i++){\\n            if(nums[i]>pivot)\\n                res.push_back(nums[i]);\\n        }\\n        return res;",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> res;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<pivot)\\n                res.push_back(nums[i]);\\n        }\\n           for(int i=0;i<nums.size();i++){\\n            if(nums[i]==pivot)\\n                res.push_back(nums[i]);\\n        }\\n           for(int i=0;i<nums.size();i++){\\n            if(nums[i]>pivot)\\n                res.push_back(nums[i]);\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 2230255,
                "title": "using-vector-stl-easy-solution-beats-98",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> r;\\n        vector<int> l;\\n        int n = 0;\\n        for(auto x:nums){\\n            if(x < pivot) l.push_back(x);\\n            else if(x == pivot) n++;\\n            else r.push_back(x);\\n        }\\n        while(n>0){\\n            l.push_back(pivot);\\n            n--;\\n        }\\n        l.insert(l.end(),r.begin(),r.end());\\n        return l;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/c5523341-43cd-4ce1-8c7a-feb0a7a815d5_1656822478.889503.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> r;\\n        vector<int> l;\\n        int n = 0;\\n        for(auto x:nums){\\n            if(x < pivot) l.push_back(x);\\n            else if(x == pivot) n++;\\n            else r.push_back(x);\\n        }\\n        while(n>0){\\n            l.push_back(pivot);\\n            n--;\\n        }\\n        l.insert(l.end(),r.begin(),r.end());\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224013,
                "title": "simple-java-solution-tc-o-n-sc-o-n",
                "content": "class Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n        int n = nums.length;\\n        \\n        int[] res = new int[n];\\n        \\n        int loc=0;\\n        \\n        for(int i: nums){\\n            if(i<pivot)\\n                res[loc++]=i;\\n        }\\n        \\n        for(int i: nums){\\n            if(i==pivot)\\n                res[loc++]=i;\\n        }\\n        \\n        for(int i: nums){\\n            if(i>pivot)\\n                res[loc++]=i;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n        int n = nums.length;\\n        \\n        int[] res = new int[n];\\n        \\n        int loc=0;\\n        \\n        for(int i: nums){\\n            if(i<pivot)\\n                res[loc++]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2158937,
                "title": "javascript-easy-solution",
                "content": "```\\n    let smaller = [], middle = [],  bigger = [] \\n    nums.forEach((a) => { pivot > a ? smaller.push(a) : pivot == a ? middle.push(a) : bigger.push(a)})\\n    return smaller.concat(middle.concat(bigger))\\n```",
                "solutionTags": [],
                "code": "```\\n    let smaller = [], middle = [],  bigger = [] \\n    nums.forEach((a) => { pivot > a ? smaller.push(a) : pivot == a ? middle.push(a) : bigger.push(a)})\\n    return smaller.concat(middle.concat(bigger))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2143848,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        \\n        less = []\\n        equal = []\\n        more = []\\n        \\n        for i in nums:\\n            if i<pivot:\\n                less.append(i)\\n            elif i ==pivot:\\n                equal.append(i)\\n            else:\\n                more.append(i)\\n                \\n        return less + equal + more\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        \\n        less = []\\n        equal = []\\n        more = []\\n        \\n        for i in nums:\\n            if i<pivot:\\n                less.append(i)\\n            elif i ==pivot:\\n                equal.append(i)\\n            else:\\n                more.append(i)\\n                \\n        return less + equal + more\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097232,
                "title": "c-soln-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans;\\n        \\n        for(int num  :nums){\\n            if(num<pivot){\\n                ans.push_back(num);\\n            }\\n        }\\n         for(int num :nums){\\n            if(num==pivot){\\n                ans.push_back(num);\\n            }\\n        }\\n        for(int num :nums){\\n            if(num>pivot){\\n                ans.push_back(num);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans;\\n        \\n        for(int num  :nums){\\n            if(num<pivot){\\n                ans.push_back(num);\\n            }\\n        }\\n         for(int num :nums){\\n            if(num==pivot){\\n                ans.push_back(num);\\n            }\\n        }\\n        for(int num :nums){\\n            if(num>pivot){\\n                ans.push_back(num);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069960,
                "title": "easy-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ar = new int[nums.length];\\n        int eql =0,right =nums.length;\\n        for(int i =0 ; i<nums.length;i++){\\n            if(nums[i]>pivot){right--;}\\n            else if(nums[i]<pivot){eql++;}\\n        }\\n        int left =0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<pivot){\\n                ar[left]=nums[i];\\n                left++;\\n            }\\n            else if(nums[i]==pivot){\\n                ar[eql++]=nums[i];\\n            }\\n            else{\\n                ar[right]=nums[i];\\n                right++;\\n            }\\n        }\\n        return ar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int[] ar = new int[nums.length];\\n        int eql =0,right =nums.length;\\n        for(int i =0 ; i<nums.length;i++){\\n            if(nums[i]>pivot){right--;}\\n            else if(nums[i]<pivot){eql++;}\\n        }\\n        int left =0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<pivot){\\n                ar[left]=nums[i];\\n                left++;\\n            }\\n            else if(nums[i]==pivot){\\n                ar[eql++]=nums[i];\\n            }\\n            else{\\n                ar[right]=nums[i];\\n                right++;\\n            }\\n        }\\n        return ar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063260,
                "title": "typescript-runtime-373-ms-faster-than-83-33-memory-usage-83-3-mb-less-than-54-17",
                "content": "```\\nfunction pivotArray(nums: number[], pivot: number): number[] {\\n  const less: number[] = [];\\n  const equal: number[] = [];\\n  const greater: number[] = [];\\n\\n  nums.forEach((num) => {\\n    if (num < pivot) {\\n      less.push(num);\\n    } else if (num === pivot) {\\n      equal.push(num);\\n    } else {\\n      greater.push(num);\\n    }\\n  });\\n\\n  return [...less, ...equal, ...greater];\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunction pivotArray(nums: number[], pivot: number): number[] {\\n  const less: number[] = [];\\n  const equal: number[] = [];\\n  const greater: number[] = [];\\n\\n  nums.forEach((num) => {\\n    if (num < pivot) {\\n      less.push(num);\\n    } else if (num === pivot) {\\n      equal.push(num);\\n    } else {\\n      greater.push(num);\\n    }\\n  });\\n\\n  return [...less, ...equal, ...greater];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012684,
                "title": "javascript-easy-understanding-two-solutions",
                "content": "1.\\n ```\\n function pivotArray(nums: number[], pivot: number): number[] {\\n    let left = [];\\n    let right = [];\\n    let midle = 0\\n\\n    for(let num of nums){\\n        if(num < pivot){\\n            left.push(num)\\n        } else if (num == pivot){\\n            midle++;\\n        }else{\\n            right.push(num);\\n        }\\n    }\\n    return [...left, ...Array(midle).fill(pivot), ...right];\\n};\\n```\\n2.\\n```\\nfunction pivotArray(nums: number[], pivot: number): number[] {\\nreturn [...nums.filter(el => el < pivot), ...nums.filter(el => el === pivot), ...nums.filter(el => el > pivot)]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n function pivotArray(nums: number[], pivot: number): number[] {\\n    let left = [];\\n    let right = [];\\n    let midle = 0\\n\\n    for(let num of nums){\\n        if(num < pivot){\\n            left.push(num)\\n        } else if (num == pivot){\\n            midle++;\\n        }else{\\n            right.push(num);\\n        }\\n    }\\n    return [...left, ...Array(midle).fill(pivot), ...right];\\n};\\n```\n```\\nfunction pivotArray(nums: number[], pivot: number): number[] {\\nreturn [...nums.filter(el => el < pivot), ...nums.filter(el => el === pivot), ...nums.filter(el => el > pivot)]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008939,
                "title": "python-easy-to-understand-1-pass-0-n-tc-and-o-n-sc",
                "content": "```\\ndef pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        \\n        left = []\\n        right = []\\n        pivots = []\\n        for e in nums:\\n             if e < pivot:\\n                 left.append(e)\\n             elif e > pivot:\\n                 right.append(e)\\n             else:\\n                 pivots.append(e)\\n        return left+pivots+right\\n```",
                "solutionTags": [],
                "code": "```\\ndef pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        \\n        left = []\\n        right = []\\n        pivots = []\\n        for e in nums:\\n             if e < pivot:\\n                 left.append(e)\\n             elif e > pivot:\\n                 right.append(e)\\n             else:\\n                 pivots.append(e)\\n        return left+pivots+right\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994536,
                "title": "c-two-pointers-o-n-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<int> pivotArray(vector<int>& nums, int pivot)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint higher = 0;\\n\\t\\tfor (int i = 0; i < n;++i)\\n\\t\\t\\thigher += nums[i] > pivot;\\n\\n\\t\\tvector<int> ans(n, pivot);\\n\\t\\tint l = 0, r = n - higher;\\n\\t\\tfor (int i = 0; i < n;++i)\\n\\t\\t{\\n\\t\\t\\tif(nums[i] < pivot)\\n\\t\\t\\t\\tans[l++] = nums[i];\\n\\t\\t\\telse if(nums[i] > pivot)\\n\\t\\t\\t\\tans[r++] = nums[i];\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> pivotArray(vector<int>& nums, int pivot)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint higher = 0;\\n\\t\\tfor (int i = 0; i < n;++i)\\n\\t\\t\\thigher += nums[i] > pivot;\\n\\n\\t\\tvector<int> ans(n, pivot);\\n\\t\\tint l = 0, r = n - higher;\\n\\t\\tfor (int i = 0; i < n;++i)\\n\\t\\t{\\n\\t\\t\\tif(nums[i] < pivot)\\n\\t\\t\\t\\tans[l++] = nums[i];\\n\\t\\t\\telse if(nums[i] > pivot)\\n\\t\\t\\t\\tans[r++] = nums[i];\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970409,
                "title": "java-best-explained-solution",
                "content": "## Naive instead of lomuto\\nAs we need to maintain the order or in other words **stability** we can\\'t use lomuto or hoare hence we are using the **naive partition** method \\n\\nHere we are traversing the array 3 times basically :\\n1. **First** for elements smaller than the pivot element\\n2. **Second** for elements equal to the pivot (To maintain the satability)\\n3. **Third** for elements greater than Pivot \\n\\nAnd in each iteration we add the values to the temporary array and at last copy all the elements from temp to nums\\n\\nI know you learnt so don\\'t be shy and **UPVOTE **\\uD83D\\uDE1C\\u2764\\u2764\\n\\n```\\n public int[] pivotArray(int[] nums, int pivot) {\\n        int index=0;\\n        int[] temp=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]<pivot)temp[index++]=nums[i];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]==pivot)temp[index++]=nums[i];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]>pivot)temp[index++]=nums[i];\\n        \\n        System.arraycopy(temp,0,nums,0,temp.length);\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int[] pivotArray(int[] nums, int pivot) {\\n        int index=0;\\n        int[] temp=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]<pivot)temp[index++]=nums[i];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]==pivot)temp[index++]=nums[i];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]>pivot)temp[index++]=nums[i];\\n        \\n        System.arraycopy(temp,0,nums,0,temp.length);\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1963166,
                "title": "easy-c-solution-queue",
                "content": "```\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n    queue<int> less,equal,great;\\n    for(auto a:nums){\\n        if(a<pivot) less.push(a);\\n        else if(a>pivot) great.push(a);\\n        else equal.push(a);\\n    }\\n    int i=0;\\n    while(!less.empty()){\\n        nums[i++] = less.front();\\n        less.pop();\\n    }\\n    while(!equal.empty()){\\n        nums[i++] = equal.front();\\n        equal.pop();\\n    }\\n    while(!great.empty()){\\n        nums[i++] = great.front();\\n        great.pop();\\n    }\\n    \\n    return nums;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n    queue<int> less,equal,great;\\n    for(auto a:nums){\\n        if(a<pivot) less.push(a);\\n        else if(a>pivot) great.push(a);\\n        else equal.push(a);\\n    }\\n    int i=0;\\n    while(!less.empty()){\\n        nums[i++] = less.front();\\n        less.pop();\\n    }\\n    while(!equal.empty()){\\n        nums[i++] = equal.front();\\n        equal.pop();\\n    }\\n    while(!great.empty()){\\n        nums[i++] = great.front();\\n        great.pop();\\n    }\\n    \\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947482,
                "title": "c-easy-brute-force-approach-o-n",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>v1;\\n        vector<int>v2;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>pivot){\\n                v2.push_back(nums[i]);\\n            }\\n            else if(nums[i]<pivot){\\n                v1.push_back(nums[i]);\\n            }\\n        }\\n        int ct=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==pivot){\\n                ct++;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<v1.size();i++){\\n            ans.push_back(v1[i]);\\n        }\\n        for(int i=0;i<ct;i++){\\n            ans.push_back(pivot);\\n        }\\n        for(int i=0;i<v2.size();i++){\\n            ans.push_back(v2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n//  please **upvote** if you like the solution\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>v1;\\n        vector<int>v2;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>pivot){\\n                v2.push_back(nums[i]);\\n            }\\n            else if(nums[i]<pivot){\\n                v1.push_back(nums[i]);\\n            }\\n        }\\n        int ct=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==pivot){\\n                ct++;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<v1.size();i++){\\n            ans.push_back(v1[i]);\\n        }\\n        for(int i=0;i<ct;i++){\\n            ans.push_back(pivot);\\n        }\\n        for(int i=0;i<v2.size();i++){\\n            ans.push_back(v2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n//  please **upvote** if you like the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926649,
                "title": "faster-than-96-43-of-typescript-online-submissions",
                "content": "```\\nfunction pivotArray(nums: number[], pivot: number): number[] {\\n    let lesser: number[] = nums.filter(x => x < pivot);\\n    let greater: number[] = nums.filter(x => x > pivot );\\n    let pivotted: number[] = nums.filter(x => x == pivot );\\n\\n    return [...lesser, ...pivotted,  ...greater];\\n};",
                "solutionTags": [],
                "code": "```\\nfunction pivotArray(nums: number[], pivot: number): number[] {\\n    let lesser: number[] = nums.filter(x => x < pivot);\\n    let greater: number[] = nums.filter(x => x > pivot );\\n    let pivotted: number[] = nums.filter(x => x == pivot );\\n\\n    return [...lesser, ...pivotted,  ...greater];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1902789,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int[] pivotArray(int[] n, int p) {\\n        int k=n.length,j=0;\\n        int b[]=new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]<p)\\n            {\\n                b[j++]=n[i];\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]==p)\\n            {\\n                b[j++]=n[i];\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]>p)\\n            {\\n                b[j++]=n[i];\\n            }\\n        }\\n        return b;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] pivotArray(int[] n, int p) {\\n        int k=n.length,j=0;\\n        int b[]=new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]<p)\\n            {\\n                b[j++]=n[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1885292,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in range(len(nums)):\\n            if pivot > nums[i]:\\n                a.append(nums[i])\\n            if pivot == nums[i]:\\n                b.append(nums[i])\\n            if pivot<nums[i]:\\n                c.append(nums[i])\\n        return a+b+c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in range(len(nums)):\\n            if pivot > nums[i]:\\n                a.append(nums[i])\\n            if pivot == nums[i]:\\n                b.append(nums[i])\\n            if pivot<nums[i]:\\n                c.append(nums[i])\\n        return a+b+c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884348,
                "title": "python",
                "content": "\\n    def pivotArray(self, nums, pivot):\\n        res1, res2, res3 = [], [], []\\n        \\n        for i in range(len(nums)):\\n            if nums[i] < pivot:\\n                res1.append(nums[i])\\n                \\n                \\n        for i in range(len(nums)):\\n            if nums[i] == pivot:\\n                res2.append(nums[i])\\n                \\n                \\n        for i in range(len(nums)):\\n            if nums[i] > pivot:\\n                res3.append(nums[i])\\n                \\n                \\n        return res1 + res2 + res3\\n",
                "solutionTags": [],
                "code": "\\n    def pivotArray(self, nums, pivot):\\n        res1, res2, res3 = [], [], []\\n        \\n        for i in range(len(nums)):\\n            if nums[i] < pivot:\\n                res1.append(nums[i])\\n                \\n                \\n        for i in range(len(nums)):\\n            if nums[i] == pivot:\\n                res2.append(nums[i])\\n                \\n                \\n        for i in range(len(nums)):\\n            if nums[i] > pivot:\\n                res3.append(nums[i])\\n                \\n                \\n        return res1 + res2 + res3\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1882835,
                "title": "o-n-t-s-2-pointer-approach-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int left = 0, right = nums.length - 1;\\n        int ans[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] < pivot) ans[left++] = nums[i];\\n            if(nums[nums.length -1 - i] > pivot) ans[right--] = nums[nums.length - 1 - i];\\n        }\\n        while(left <= right) {\\n            ans[right--] = pivot;\\n            ans[left++] = pivot;\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int left = 0, right = nums.length - 1;\\n        int ans[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] < pivot) ans[left++] = nums[i];\\n            if(nums[nums.length -1 - i] > pivot) ans[right--] = nums[nums.length - 1 - i];\\n        }\\n        while(left <= right) {\\n            ans[right--] = pivot;\\n            ans[left++] = pivot;\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864526,
                "title": "c-solution-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n\\t\\t//inititalize vector of same size as input\\n        vector<int> ans(n);\\n        \\n\\t\\t//count no. of elements less than pivot(s),equal to pivot(m), and greater than pivot(e)\\n        int s=0, m=0, e=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<pivot)   s++;\\n            else if(nums[i]==pivot)  m++;\\n            else    e++;\\n        }\\n        \\n\\t\\t//initialize three pointer/variables \\n\\t\\t// i starts at 0 (for values less than pivot)\\n\\t\\t// j starts at s (after lesser values)(for values equal to pivot)\\n\\t\\t// k starts from s+m (after lesser values and equal values)(for values greater than pivot)\\n        int i=0, j=s, k=(s+m);\\n        for(int a=0; a<n; a++){\\n\\t\\t//increament the pointer after everytime the value is filled\\n            if(nums[a]<pivot){\\n                ans[i]=nums[a];\\n                i++;\\n            }\\n            else if(nums[a]==pivot){\\n                ans[j]=nums[a];\\n                j++;\\n            }\\n            else if(nums[a]>pivot){\\n                ans[k]=nums[a];\\n                k++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nAsk if there is any doubt... :)))",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n\\t\\t//inititalize vector of same size as input\\n        vector<int> ans(n);\\n        \\n\\t\\t//count no. of elements less than pivot(s),equal to pivot(m), and greater than pivot(e)\\n        int s=0, m=0, e=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<pivot)   s++;\\n            else if(nums[i]==pivot)  m++;\\n            else    e++;\\n        }\\n        \\n\\t\\t//initialize three pointer/variables \\n\\t\\t// i starts at 0 (for values less than pivot)\\n\\t\\t// j starts at s (after lesser values)(for values equal to pivot)\\n\\t\\t// k starts from s+m (after lesser values and equal values)(for values greater than pivot)\\n        int i=0, j=s, k=(s+m);\\n        for(int a=0; a<n; a++){\\n\\t\\t//increament the pointer after everytime the value is filled\\n            if(nums[a]<pivot){\\n                ans[i]=nums[a];\\n                i++;\\n            }\\n            else if(nums[a]==pivot){\\n                ans[j]=nums[a];\\n                j++;\\n            }\\n            else if(nums[a]>pivot){\\n                ans[k]=nums[a];\\n                k++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824589,
                "title": "python-beginner-friendly-solution-using-too-lists",
                "content": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        first = []\\n        second = []\\n        for i in range(len(nums)):\\n            if nums[i] > pivot:\\n                second.append(nums[i])\\n            elif nums[i] < pivot:\\n                first.append(nums[i])\\n        count = nums.count(pivot)\\n        for i in range(count):\\n            first.append(pivot)\\n        return first + second",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        first = []\\n        second = []\\n        for i in range(len(nums)):\\n            if nums[i] > pivot:\\n                second.append(nums[i])\\n            elif nums[i] < pivot:\\n                first.append(nums[i])\\n        count = nums.count(pivot)\\n        for i in range(count):\\n            first.append(pivot)\\n        return first + second",
                "codeTag": "Java"
            },
            {
                "id": 1818341,
                "title": "c-easy-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<pivot)\\n            {\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==pivot)\\n            {\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>pivot)\\n            {\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        int n=nums.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<pivot)\\n            {\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==pivot)\\n            {\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>pivot)\\n            {\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812326,
                "title": "c-easy-understandable-brute-force-comments",
                "content": "\\n\\n    class Solution {\\n    public:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>vect;\\n        for(int i=0;i<nums.size();i++) // FOR TAKING ELEMENTS SMALLER THAN PIVOT ELEMENTS\\n        {\\n            if(nums[i]<pivot)\\n            {\\n                vect.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++) // FOR TAKING ELEMENTS EQUAL TO PIVOT ELEMENTS\\n        {\\n            if(nums[i]==pivot)\\n            {\\n                vect.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++) // FOR TAKING ELEMENTS GREATER THAN PIVOT ELEMENTS\\n        {\\n            if(nums[i]>pivot)\\n            {\\n                vect.push_back(nums[i]);\\n            }\\n        }\\n        return vect;\\n    }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int>vect;\\n        for(int i=0;i<nums.size();i++) // FOR TAKING ELEMENTS SMALLER THAN PIVOT ELEMENTS\\n        {\\n            if(nums[i]<pivot)\\n            {\\n                vect.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1776013,
                "title": "clean-js-solution-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} pivot\\n * @return {number[]}\\n */\\nvar pivotArray = function (nums, pivot) {\\n  var res = [];\\n\\n  collect(nums, res, (value) => value < pivot);\\n  collect(nums, res, (value) => value == pivot);\\n  collect(nums, res, (value) => value > pivot);\\n\\n  return res;\\n};\\n\\nvar collect = function (nums, res, condition) {\\n  for (var i = 0; i < nums.length; i++) {\\n    if (condition(nums[i])) {\\n      res.push(nums[i]);\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} pivot\\n * @return {number[]}\\n */\\nvar pivotArray = function (nums, pivot) {\\n  var res = [];\\n\\n  collect(nums, res, (value) => value < pivot);\\n  collect(nums, res, (value) => value == pivot);\\n  collect(nums, res, (value) => value > pivot);\\n\\n  return res;\\n};\\n\\nvar collect = function (nums, res, condition) {\\n  for (var i = 0; i < nums.length; i++) {\\n    if (condition(nums[i])) {\\n      res.push(nums[i]);\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1759119,
                "title": "c-3-lines",
                "content": "**Stable partition does the job:**\\n```cpp\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\tauto it = stable_partition(nums.begin(), nums.end(), [&](const int&a){return a < pivot;});\\n\\tstable_partition(it, nums.end(), [&](const int&a){return a <= pivot;});\\n\\treturn nums;\\n}\\n```\\n**Using extra space, the naive way**\\n    \\n```cpp\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\tvector<int> result;\\n\\tresult.reserve(nums.size());\\n\\tfor(const auto n:nums)\\n\\t\\tif(n<pivot)\\n\\t\\t\\tresult.push_back(n);\\n\\tfor(const auto n:nums)\\n\\t\\tif(n==pivot)\\n\\t\\t\\tresult.push_back(n);\\n\\tfor(const auto n:nums)\\n\\t\\tif(n>pivot)\\n\\t\\t\\tresult.push_back(n);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\tauto it = stable_partition(nums.begin(), nums.end(), [&](const int&a){return a < pivot;});\\n\\tstable_partition(it, nums.end(), [&](const int&a){return a <= pivot;});\\n\\treturn nums;\\n}\\n```\n```cpp\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n\\tvector<int> result;\\n\\tresult.reserve(nums.size());\\n\\tfor(const auto n:nums)\\n\\t\\tif(n<pivot)\\n\\t\\t\\tresult.push_back(n);\\n\\tfor(const auto n:nums)\\n\\t\\tif(n==pivot)\\n\\t\\t\\tresult.push_back(n);\\n\\tfor(const auto n:nums)\\n\\t\\tif(n>pivot)\\n\\t\\t\\tresult.push_back(n);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753437,
                "title": "simple-js-solution-o-n-space-and-time",
                "content": "```\\nvar pivotArray = function(nums, pivot) {\\n    let lessThan = []\\n    let greaterThan = []\\n    let pivotElement = []\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] < pivot) lessThan.push(nums[i])\\n        else if (nums[i] > pivot) greaterThan.push(nums[i])\\n        else pivotElement.push(nums[i])\\n    }\\n    return [...lessThan,...pivotElement,...greaterThan]\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pivotArray = function(nums, pivot) {\\n    let lessThan = []\\n    let greaterThan = []\\n    let pivotElement = []\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] < pivot) lessThan.push(nums[i])\\n        else if (nums[i] > pivot) greaterThan.push(nums[i])\\n        else pivotElement.push(nums[i])\\n    }\\n    return [...lessThan,...pivotElement,...greaterThan]\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1753397,
                "title": "2-approaches-three-pointer-simple-easy-to-understand-c",
                "content": "Implementation\\n\\n**1st Approach\\nUsing 3 extra array\\nTime Complexity = O(N)\\nSpace Complexity = O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        // taking small array to put the value which are less the pivot\\n        // big array to put the value which are greater than pivot\\n        // equal array to put the value which are equal to pivot\\n        vector<int> small, equal, big;\\n        \\n        for(auto a : nums){\\n            if(a < pivot) small.push_back(a);\\n            else if(a > pivot) big.push_back(a);\\n            else equal.push_back(a);\\n        }\\n        \\n        // clearning the nums, and later using it as a result purpose\\n        nums.clear();\\n        for(auto a : small) nums.push_back(a);\\n        \\n        for(auto a : equal) nums.push_back(a);\\n        \\n        for(auto a : big) nums.push_back(a);\\n        \\n        return nums;\\n    }\\n};\\n```\\n\\n\\n\\n**2nd Approach\\nThree Pointer Approach\\nUsing 1 extra array\\nTime Complexity = O(N)\\nSpace Complexity = O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    // always starting low from 0, bcz we need to enter small element from 0th index\\n    // incrementing same when a is less than pivot, bcz the total number of element which are smaller than pivot, from there we need to start inserting same number\\n    // decrementing high when a is greater than pivot, bcz the total number of element which are greater than pivot, from the last, we need to start inserting high number\\n    \\n    vector<int> pivotArray(vector<int>& nums, int pivot) {        \\n        \\n        int low = 0, same = 0, high = nums.size();\\n        \\n        for(auto a : nums){\\n            if(a < pivot) same++;\\n            else if(a > pivot) high--;\\n        }\\n        \\n        vector<int> res(nums.size());\\n        for(auto a : nums){\\n            if(a < pivot) res[low++] = a;\\n            else if(a > pivot) res[high++] = a;\\n            else res[same++] = a;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        // taking small array to put the value which are less the pivot\\n        // big array to put the value which are greater than pivot\\n        // equal array to put the value which are equal to pivot\\n        vector<int> small, equal, big;\\n        \\n        for(auto a : nums){\\n            if(a < pivot) small.push_back(a);\\n            else if(a > pivot) big.push_back(a);\\n            else equal.push_back(a);\\n        }\\n        \\n        // clearning the nums, and later using it as a result purpose\\n        nums.clear();\\n        for(auto a : small) nums.push_back(a);\\n        \\n        for(auto a : equal) nums.push_back(a);\\n        \\n        for(auto a : big) nums.push_back(a);\\n        \\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // always starting low from 0, bcz we need to enter small element from 0th index\\n    // incrementing same when a is less than pivot, bcz the total number of element which are smaller than pivot, from there we need to start inserting same number\\n    // decrementing high when a is greater than pivot, bcz the total number of element which are greater than pivot, from the last, we need to start inserting high number\\n    \\n    vector<int> pivotArray(vector<int>& nums, int pivot) {        \\n        \\n        int low = 0, same = 0, high = nums.size();\\n        \\n        for(auto a : nums){\\n            if(a < pivot) same++;\\n            else if(a > pivot) high--;\\n        }\\n        \\n        vector<int> res(nums.size());\\n        for(auto a : nums){\\n            if(a < pivot) res[low++] = a;\\n            else if(a > pivot) res[high++] = a;\\n            else res[same++] = a;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748059,
                "title": "javascript-one-liner",
                "content": "```\\nvar pivotArray = function (nums, pivot) {\\n  return [...nums.filter(x => x < pivot), ...nums.filter(x => x == pivot), ...nums.filter(x => x > pivot)]\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pivotArray = function (nums, pivot) {\\n  return [...nums.filter(x => x < pivot), ...nums.filter(x => x == pivot), ...nums.filter(x => x > pivot)]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748055,
                "title": "python3-3-parts",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/57fa31fc309c7347ae7fae475880a8bfdefcea66) for solutions of biweekly 71. \\n\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        small, equal, large = [], [], []\\n        for x in nums: \\n            if x < pivot: small.append(x)\\n            elif x == pivot: equal.append(x)\\n            else: large.append(x)\\n        return small + equal + large\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        small, equal, large = [], [], []\\n        for x in nums: \\n            if x < pivot: small.append(x)\\n            elif x == pivot: equal.append(x)\\n            else: large.append(x)\\n        return small + equal + large\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747928,
                "title": "simple-c-code",
                "content": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> v1,v2,v3;\\n        for(int i=0;i<nums.size();i++){\\n\\n            if(nums[i]<pivot) v1.push_back(nums[i]);\\n            if(nums[i]==pivot) v2.push_back(nums[i]);\\n            if(nums[i]>pivot) v3.push_back(nums[i]);\\n        }\\n        vector<int> ans;\\n        for(auto x: v1) ans.push_back(x); \\n        for(auto x: v2) ans.push_back(x); \\n        for(auto x: v3) ans.push_back(x);  \\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) {\\n        \\n        vector<int> v1,v2,v3;\\n        for(int i=0;i<nums.size();i++){\\n\\n            if(nums[i]<pivot) v1.push_back(nums[i]);\\n            if(nums[i]==pivot) v2.push_back(nums[i]);\\n            if(nums[i]>pivot) v3.push_back(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1747858,
                "title": "clean-and-simple-linear-time-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot)\\n    {\\n        int [] output = new int [nums.length];\\n        int left = 0;\\n        int right = output.length - 1;\\n        int tmp;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] < pivot)\\n            {\\n                output[left] = nums[i];\\n                left++;\\n            }\\n            tmp = nums.length - 1 - i;\\n            if (nums[tmp] > pivot)\\n            {\\n                output[right] = nums[tmp];\\n                right--;\\n            }\\n        }\\n        while (left <= right)\\n        {\\n            output[left] = pivot;\\n            left++;\\n        }\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] pivotArray(int[] nums, int pivot)\\n    {\\n        int [] output = new int [nums.length];\\n        int left = 0;\\n        int right = output.length - 1;\\n        int tmp;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] < pivot)\\n            {\\n                output[left] = nums[i];\\n                left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1747739,
                "title": "easy-approach-java-100-faster-6ms",
                "content": "You keep a pointer idx that would guide you to last filled idx of an array.\\nIn first iteration, you count the number of pivot elements and fill up all the elements in the array while incrementing the idx pointer.\\nThen, you fill up the part of array if any occurances of pivot part happen.\\nThen last traversal of the array to fill up the ans array where elements are greater than pivot.\\n\\nFurthur improvment - you can maintain three seperate pointers low, equal, high.\\n\\nin first iteration, keep the track of occurances of low and equal and increment acc to their condition,\\n\\nset high = low + equal\\n\\nthen in the next iteration, for respective condition, place the element at pointer at respective position and increment the pointer.\\n\\n\\n\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n        int len = nums.length;\\n        int[] ans = new int[len];\\n        int idx = 0, pivotCount = 0;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] < pivot)\\n                ans[idx++] = nums[i];\\n            else if (nums[i] == pivot) \\n                pivotCount++;\\n        }\\n\\t\\t\\n        \\n        for (int i = 0; i < pivotCount; i++) {\\n            ans[idx++] = pivot;\\n        }\\n        \\n        for (int val : nums)\\n            if (val > pivot)\\n                ans[idx++] = val;\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        \\n        int len = nums.length;\\n        int[] ans = new int[len];\\n        int idx = 0, pivotCount = 0;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] < pivot)\\n                ans[idx++] = nums[i];\\n            else if (nums[i] == pivot) \\n                pivotCount++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1747376,
                "title": "c-linq-one-liner",
                "content": "```\\npublic int[] PivotArray(int[] nums, int pivot) {\\n\\treturn nums.Where(x => x < pivot).Select(x => x).Concat(nums.Where(x => x == pivot).Select(x => x)).Concat(nums.Where(x => x > pivot).Select(x => x)).ToArray();\\n}\\n```\\nor 3 lines if you want to save one N loop walk, only when you have a few pivot elements in array (because Repeat is another loop anyway)\\n```\\npublic int[] PivotArray(int[] nums, int pivot) {\\n\\tvar less = nums.Where(x => x < pivot).Select(x => x).ToArray();\\n\\tvar greater = nums.Where(x => x > pivot).Select(x => x).ToArray();\\n\\treturn less.Concat(Enumerable.Repeat(pivot, nums.Length - less.Length - greater.Length)).Concat(greater).ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] PivotArray(int[] nums, int pivot) {\\n\\treturn nums.Where(x => x < pivot).Select(x => x).Concat(nums.Where(x => x == pivot).Select(x => x)).Concat(nums.Where(x => x > pivot).Select(x => x)).ToArray();\\n}\\n```\n```\\npublic int[] PivotArray(int[] nums, int pivot) {\\n\\tvar less = nums.Where(x => x < pivot).Select(x => x).ToArray();\\n\\tvar greater = nums.Where(x => x > pivot).Select(x => x).ToArray();\\n\\treturn less.Concat(Enumerable.Repeat(pivot, nums.Length - less.Length - greater.Length)).Concat(greater).ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747309,
                "title": "simple-python-solution-in-o-n-time",
                "content": "The approach is pretty straight forward, \\n* \\tdefine three empty lists, which show whether the element is smaller, greater or equal to pivot element\\n* \\tin a single pass compare the elements\\n* \\tFinally return the concatenated lists in required order\\n\\nNote - This is my first post. Please upvote if you found this solution helpful. Also, let me know if there are any corrections!\\n\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        less = []\\n        greater = []\\n        equal = []\\n        \\n        for n in nums:\\n            if n < pivot:\\n                less.append(n)\\n            elif n > pivot:\\n                greater.append(n)\\n            else:\\n                equal.append(n)\\n        return less+equal+greater\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        less = []\\n        greater = []\\n        equal = []\\n        \\n        for n in nums:\\n            if n < pivot:\\n                less.append(n)\\n            elif n > pivot:\\n                greater.append(n)\\n            else:\\n                equal.append(n)\\n        return less+equal+greater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747182,
                "title": "java-simple-implementation",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n=nums.length;\\n        int res[]=new int[n];\\n        int more=0;\\n        int p=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>pivot) more++;\\n            else if(nums[i]==pivot) p++;\\n        }\\n        int i=0;\\n        int j=n-more;\\n        for(int k=0;k<n;k++){\\n            if(nums[k]>pivot){\\n                res[j++]=nums[k];\\n            }else if(nums[k]==pivot){\\n                //\\n            }else{\\n                res[i++]=nums[k];\\n            }\\n        }\\n        while(p-->0){\\n            res[i++]=pivot;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n=nums.length;\\n        int res[]=new int[n];\\n        int more=0;\\n        int p=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>pivot) more++;\\n            else if(nums[i]==pivot) p++;\\n        }\\n        int i=0;\\n        int j=n-more;\\n        for(int k=0;k<n;k++){\\n            if(nums[k]>pivot){\\n                res[j++]=nums[k];\\n            }else if(nums[k]==pivot){\\n                //\\n            }else{\\n                res[i++]=nums[k];\\n            }\\n        }\\n        while(p-->0){\\n            res[i++]=pivot;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747094,
                "title": "o-n-both-time-and-space",
                "content": "```\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans;\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]<pivot){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]==pivot){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]>pivot){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> pivotArray(vector<int>& nums, int pivot) {\\n        vector<int> ans;\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]<pivot){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]==pivot){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]>pivot){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1747066,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& n, int p) {\\n         vector<int> v1,v2,v3,v4;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]<p)\\n                v1.push_back(n[i]);\\n            else if(n[i]==p)\\n                v2.push_back(n[i]);\\n            else\\n                v3.push_back(n[i]);\\n            \\n        }\\n        for(auto x:v1)\\n            v4.push_back(x);\\n            for(auto x:v2)\\n                 v4.push_back(x);\\n                for(auto x:v3)\\n                     v4.push_back(x);\\n        return v4;\\n            \\n                        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& n, int p) {\\n         vector<int> v1,v2,v3,v4;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]<p)\\n                v1.push_back(n[i]);\\n            else if(n[i]==p)\\n                v2.push_back(n[i]);\\n            else\\n                v3.push_back(n[i]);\\n            \\n        }\\n        for(auto x:v1)\\n            v4.push_back(x);\\n            for(auto x:v2)\\n                 v4.push_back(x);\\n                for(auto x:v3)\\n                     v4.push_back(x);\\n        return v4;\\n            \\n                        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747048,
                "title": "java-simple-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int counter = 0;\\n        List<Integer> less = new ArrayList<>(), equal = new ArrayList<>(), greater = new ArrayList<>();\\n        for(int num : nums) {\\n            if(num < pivot) {\\n                less.add(num);\\n            } else if(num > pivot) {\\n                greater.add(num);\\n            } else {\\n                equal.add(num);\\n            }\\n        }\\n        for(Integer val : less) {\\n            nums[counter] = val;\\n            counter++;\\n        }\\n        for(Integer val : equal) {\\n            nums[counter] = val;\\n            counter++;\\n        }\\n        for(Integer val : greater) {\\n            nums[counter] = val;\\n            counter++;\\n        }\\n        return nums;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int counter = 0;\\n        List<Integer> less = new ArrayList<>(), equal = new ArrayList<>(), greater = new ArrayList<>();\\n        for(int num : nums) {\\n            if(num < pivot) {\\n                less.add(num);\\n            } else if(num > pivot) {\\n                greater.add(num);\\n            } else {\\n                equal.add(num);\\n            }\\n        }\\n        for(Integer val : less) {\\n            nums[counter] = val;\\n            counter++;\\n        }\\n        for(Integer val : equal) {\\n            nums[counter] = val;\\n            counter++;\\n        }\\n        for(Integer val : greater) {\\n            nums[counter] = val;\\n            counter++;\\n        }\\n        return nums;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747021,
                "title": "python-3-extra-space-solution",
                "content": "\\n# [Python 3] Extra Space Solution\\n## Note: I belive this is not optimal since I used extra space\\n\\n## MAIN IDEA\\nuse left, pivot and right to store correct order and loop through nums place number in correct list, finnaly return\\n\\n## Complexity Analysis\\n* Time : O(N)\\n* Space: O(N)\\n\\n\\n## Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        left = []\\n\\t\\tpivots = []\\n        right = []\\n        for num in nums:\\n            if num < pivot:\\n                left.append(num)\\n            elif num == pivot:\\n                pivots.append(num)\\n            else:\\n                right.append(num)\\n        return left + pivots + right           \\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        left = []\\n\\t\\tpivots = []\\n        right = []\\n        for num in nums:\\n            if num < pivot:\\n                left.append(num)\\n            elif num == pivot:\\n                pivots.append(num)\\n            else:\\n                right.append(num)\\n        return left + pivots + right           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746990,
                "title": "simple-java-sol-using-queue-o-n",
                "content": "```\\n  public static int[] pivotArray(int[] nums, int pivot) {\\n        Queue<Integer> left = new LinkedList<>();\\n        Queue<Integer> piv = new LinkedList<>();\\n        Queue<Integer> right = new LinkedList<>();\\n        for(int n : nums){\\n            if(n < pivot){\\n                left.add(n);\\n            }else if( n > pivot){\\n                right.add(n);\\n            }else{\\n                piv.add(pivot) ;\\n            }\\n        }\\n        for (int i = 0; i < nums.length ; i++) {\\n            Queue<Integer> current = !left.isEmpty() ? left :!piv.isEmpty() ? piv : right;\\n            nums[i] = current.poll();\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public static int[] pivotArray(int[] nums, int pivot) {\\n        Queue<Integer> left = new LinkedList<>();\\n        Queue<Integer> piv = new LinkedList<>();\\n        Queue<Integer> right = new LinkedList<>();\\n        for(int n : nums){\\n            if(n < pivot){\\n                left.add(n);\\n            }else if( n > pivot){\\n                right.add(n);\\n            }else{\\n                piv.add(pivot) ;\\n            }\\n        }\\n        for (int i = 0; i < nums.length ; i++) {\\n            Queue<Integer> current = !left.isEmpty() ? left :!piv.isEmpty() ? piv : right;\\n            nums[i] = current.poll();\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080126,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def pivotArray(self, nums, pivot):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type pivot: int\\n        :rtype: List[int]\\n        \"\"\"\\n        curr = []\\n        left = []\\n        right = []\\n        for i in nums:\\n            if i<pivot:\\n                left.append(i)\\n            elif i>pivot:\\n                right.append(i)\\n            else:\\n                curr.append(i)\\n        return left+curr+right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pivotArray(self, nums, pivot):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type pivot: int\\n        :rtype: List[int]\\n        \"\"\"\\n        curr = []\\n        left = []\\n        right = []\\n        for i in nums:\\n            if i<pivot:\\n                left.append(i)\\n            elif i>pivot:\\n                right.append(i)\\n            else:\\n                curr.append(i)\\n        return left+curr+right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078600,
                "title": "fast-and-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int left = 0, right = n - 1;\\n        for (int i = 0; i < n; ++i) {\\n            int lv = nums[i], rv = nums[n - 1 - i];\\n            if (lv < pivot) ans[left++] = lv;\\n            if (rv > pivot) ans[right--] = rv;\\n        }\\n        while (left <= right) ans[left++] = pivot;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int left = 0, right = n - 1;\\n        for (int i = 0; i < n; ++i) {\\n            int lv = nums[i], rv = nums[n - 1 - i];\\n            if (lv < pivot) ans[left++] = lv;\\n            if (rv > pivot) ans[right--] = rv;\\n        }\\n        while (left <= right) ans[left++] = pivot;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077004,
                "title": "java-array-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nElements lower than pivot through in left side without changing it\\'s relative position whereas elements greater than pivot through it in right side without disturbing the relative position and the equal to pivot put it in mid. of the list;\\n\\nHere relative position means, if 2 is after 3 and pivot is 5 than in your new array 1st 2 should come and then 3.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] a, int pivot) {\\n        ArrayList<Integer> l=new ArrayList<>();\\n        int c=0;\\n        for(int i : a){\\n            if(i<pivot){\\n                l.add(c,i);\\n                c++;\\n            }else if(i>pivot){\\n                l.add(l.size(),i);\\n            }\\n        }\\n        for(int j:a){\\n            if(j==pivot){\\n                l.add(c,j);\\n                c++;    \\n            }\\n           \\n        }\\n        int res[]=new int[l.size()];\\n        for(int i=0;i<l.size();i++){\\n            res[i]=l.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] a, int pivot) {\\n        ArrayList<Integer> l=new ArrayList<>();\\n        int c=0;\\n        for(int i : a){\\n            if(i<pivot){\\n                l.add(c,i);\\n                c++;\\n            }else if(i>pivot){\\n                l.add(l.size(),i);\\n            }\\n        }\\n        for(int j:a){\\n            if(j==pivot){\\n                l.add(c,j);\\n                c++;    \\n            }\\n           \\n        }\\n        int res[]=new int[l.size()];\\n        for(int i=0;i<l.size();i++){\\n            res[i]=l.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071360,
                "title": "php-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $pivot\\n     * @return Integer[]\\n     */\\n    function pivotArray($nums, $pivot) {\\n         $res_arr = [];\\n        for($i=0;$i<count($nums);$i++)\\n        {\\n            if($nums[$i] < $pivot)\\n            {\\n                $res_arr[] = $nums[$i];\\n            }\\n        }\\n        \\n        for($i=0;$i<count($nums);$i++)\\n        {\\n            if($nums[$i] == $pivot)\\n            {\\n                $res_arr[] = $nums[$i];\\n            }\\n        }\\n        \\n        for($i=0;$i<count($nums);$i++){\\n            if($nums[$i] > $pivot)\\n            {\\n                $res_arr[] = $nums[$i];\\n            }\\n        }\\n        $nums = $res_arr;\\n        return $nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $pivot\\n     * @return Integer[]\\n     */\\n    function pivotArray($nums, $pivot) {\\n         $res_arr = [];\\n        for($i=0;$i<count($nums);$i++)\\n        {\\n            if($nums[$i] < $pivot)\\n            {\\n                $res_arr[] = $nums[$i];\\n            }\\n        }\\n        \\n        for($i=0;$i<count($nums);$i++)\\n        {\\n            if($nums[$i] == $pivot)\\n            {\\n                $res_arr[] = $nums[$i];\\n            }\\n        }\\n        \\n        for($i=0;$i<count($nums);$i++){\\n            if($nums[$i] > $pivot)\\n            {\\n                $res_arr[] = $nums[$i];\\n            }\\n        }\\n        $nums = $res_arr;\\n        return $nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071193,
                "title": "python-easy-solution-with-extend",
                "content": "# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        res = [n for n in nums if n < pivot]\\n        res.extend([pivot] * nums.count(pivot))\\n        res.extend([n for n in nums if n > pivot])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        res = [n for n in nums if n < pivot]\\n        res.extend([pivot] * nums.count(pivot))\\n        res.extend([n for n in nums if n > pivot])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069071,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        mins = []\\n        maxs = []\\n        pivots=[]\\n\\n        for i in nums:\\n            if i < pivot:\\n                mins.append(i)\\n            elif i > pivot:\\n                maxs.append(i)\\n            else:\\n                pivots.append(i)\\n        \\n        return mins + pivots + maxs\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        mins = []\\n        maxs = []\\n        pivots=[]\\n\\n        for i in nums:\\n            if i < pivot:\\n                mins.append(i)\\n            elif i > pivot:\\n                maxs.append(i)\\n            else:\\n                pivots.append(i)\\n        \\n        return mins + pivots + maxs\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065096,
                "title": "simple-python3-solution",
                "content": "# Intuition\\nA number can only be less than, equal to, or greater than the pivot. So run the list 3 times.\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        n = len(nums)\\n        newnums = []\\n\\n        for number in nums:\\n            if number < pivot:\\n                newnums.append(number)\\n        for number in nums:\\n            if number == pivot:\\n                newnums.append(number)\\n        for number in nums:\\n            if number > pivot:\\n                newnums.append(number)\\n        return newnums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        n = len(nums)\\n        newnums = []\\n\\n        for number in nums:\\n            if number < pivot:\\n                newnums.append(number)\\n        for number in nums:\\n            if number == pivot:\\n                newnums.append(number)\\n        for number in nums:\\n            if number > pivot:\\n                newnums.append(number)\\n        return newnums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064225,
                "title": "simple-and-easy-consise-code-ek-baar-dekh-lo-accha-laga-to-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int p) {\\n        vector<int> res;\\n        for(auto i:nums){\\n            if(i<p)\\n            res.push_back(i);\\n        }\\n        for(auto i:nums){\\n            if(i==p)\\n            res.push_back(i);\\n        }\\n        for(auto i:nums){\\n            if(i>p)\\n            res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int p) {\\n        vector<int> res;\\n        for(auto i:nums){\\n            if(i<p)\\n            res.push_back(i);\\n        }\\n        for(auto i:nums){\\n            if(i==p)\\n            res.push_back(i);\\n        }\\n        for(auto i:nums){\\n            if(i>p)\\n            res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054953,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe use two ArrayLists (s1 and s2) to separate elements less than and greater than the pivot, and we count occurrences of the pivot in the original array.\\nWe create a new ArrayList called result to store the final result.\\nWe add elements from s1 to result.\\nWe add the pivot elements to result based on the count value, ensuring that the pivot appears the correct number of times.\\nWe add elements from s2 to result.\\nFinally, we convert the result ArrayList to an array (arr) before returning it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        ArrayList<Integer> s1 = new ArrayList<Integer>();\\n        ArrayList<Integer> s2 = new ArrayList<Integer>();\\n\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < pivot) {\\n                s1.add(nums[i]);\\n            } else if (nums[i] == pivot) {\\n                count++;\\n            } else if (nums[i] > pivot) {\\n                s2.add(nums[i]);\\n            }\\n        }\\n\\n        // Create a new ArrayList to hold the result\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n\\n        // Add elements from s1 to result\\n        result.addAll(s1);\\n\\n        // Add pivot elements to result based on count\\n        for (int i = 0; i < count; i++) {\\n            result.add(pivot);\\n        }\\n\\n        // Add elements from s2 to result\\n        result.addAll(s2);\\n\\n        // Convert the ArrayList to an array\\n        int[] arr = new int[result.size()];\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = result.get(i);\\n        }\\n\\n        return arr;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n        ArrayList<Integer> s1 = new ArrayList<Integer>();\\n        ArrayList<Integer> s2 = new ArrayList<Integer>();\\n\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < pivot) {\\n                s1.add(nums[i]);\\n            } else if (nums[i] == pivot) {\\n                count++;\\n            } else if (nums[i] > pivot) {\\n                s2.add(nums[i]);\\n            }\\n        }\\n\\n        // Create a new ArrayList to hold the result\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n\\n        // Add elements from s1 to result\\n        result.addAll(s1);\\n\\n        // Add pivot elements to result based on count\\n        for (int i = 0; i < count; i++) {\\n            result.add(pivot);\\n        }\\n\\n        // Add elements from s2 to result\\n        result.addAll(s2);\\n\\n        // Convert the ArrayList to an array\\n        int[] arr = new int[result.size()];\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = result.get(i);\\n        }\\n\\n        return arr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053212,
                "title": "tc-o-n-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) \\n    {\\n        vector<int> x1;\\n        vector<int> x2;\\n        int npe=0;\\n        int i=0;\\n        while(i<nums.size())\\n       {\\n           if(nums[i]==pivot)npe++;\\n           else\\n           {\\n               if(nums[i]<pivot)x1.push_back(nums[i]);\\n               else\\n               x2.push_back(nums[i]);\\n           }\\n           i++;\\n       }\\n       i=1;\\n       while(i<=npe)\\n       {\\n           x1.push_back(pivot);\\n           i++;\\n       }\\n       i=0;\\n       while(i<x2.size())\\n       {\\n           x1.push_back(x2[i]);\\n           i++;\\n       }\\n       return x1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) \\n    {\\n        vector<int> x1;\\n        vector<int> x2;\\n        int npe=0;\\n        int i=0;\\n        while(i<nums.size())\\n       {\\n           if(nums[i]==pivot)npe++;\\n           else\\n           {\\n               if(nums[i]<pivot)x1.push_back(nums[i]);\\n               else\\n               x2.push_back(nums[i]);\\n           }\\n           i++;\\n       }\\n       i=1;\\n       while(i<=npe)\\n       {\\n           x1.push_back(pivot);\\n           i++;\\n       }\\n       i=0;\\n       while(i<x2.size())\\n       {\\n           x1.push_back(x2[i]);\\n           i++;\\n       }\\n       return x1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047737,
                "title": "easiest-java-solution-to-understand",
                "content": "# Intuition\\nSequentially segregate the elements based on their relationship to the pivot by scanning the input array three times: first for elements less than the pivot, then for elements equal to the pivot, and finally for elements greater than the pivot.\\n\\n# Approach\\n1-We create an array for the result \"ans\" that has the same length as our input array. And we declare an Index=0 as an index for this result array;\\n\\n2-We scan our input array 3 times.\\n-In our 1st scan if elements are smaller than pivot we add them to our result array. And increment is index;\\n-In our 2nd scan if elements are equal to pivot we add them to our result array at index (which we already incremented in our first scan)\\nand then we increment index also.\\n-3rd scan we also scan again our input array for elements bigger than pivot we add them to our result array at index(which is already incremented more in our 2nd scan). \\nSo all the elements now are at the right place in our result array.\\nWe then return our result array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n       \\n        int[] ans = new int[nums.length];\\n             \\n        int index = 0;\\n        for(int i=0; i<nums.length; i++){   \\n             if(nums[i] < pivot)      \\n            ans[index++] = nums[i];\\n  \\n        }\\n\\n\\n        for(int i= 0; i<nums.length; i++){\\n            \\n            if(nums[i] == pivot)\\n                ans[index++] = nums[i];\\n   \\n        }\\n\\n        for(int i= 0; i<nums.length; i++){\\n            if(nums[i] > pivot)\\n                ans[index++] = nums[i];\\n    \\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pivotArray(int[] nums, int pivot) {\\n       \\n        int[] ans = new int[nums.length];\\n             \\n        int index = 0;\\n        for(int i=0; i<nums.length; i++){   \\n             if(nums[i] < pivot)      \\n            ans[index++] = nums[i];\\n  \\n        }\\n\\n\\n        for(int i= 0; i<nums.length; i++){\\n            \\n            if(nums[i] == pivot)\\n                ans[index++] = nums[i];\\n   \\n        }\\n\\n        for(int i= 0; i<nums.length; i++){\\n            if(nums[i] > pivot)\\n                ans[index++] = nums[i];\\n    \\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047486,
                "title": "basics-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsimple approach\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) \\n    { int n=nums.size();\\n    vector<int>abhi;\\n     for(int i=0;i<n;i++)\\n     {\\n         if(nums[i]<pivot){abhi.push_back(nums[i]);}\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n     {\\n         if(nums[i]==pivot){abhi.push_back(nums[i]);}\\n        }\\n        for(int i=0;i<n;i++)\\n     {\\n         if(nums[i]>pivot){abhi.push_back(nums[i]);}\\n        }\\n        return abhi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pivotArray(vector<int>& nums, int pivot) \\n    { int n=nums.size();\\n    vector<int>abhi;\\n     for(int i=0;i<n;i++)\\n     {\\n         if(nums[i]<pivot){abhi.push_back(nums[i]);}\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n     {\\n         if(nums[i]==pivot){abhi.push_back(nums[i]);}\\n        }\\n        for(int i=0;i<n;i++)\\n     {\\n         if(nums[i]>pivot){abhi.push_back(nums[i]);}\\n        }\\n        return abhi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576981,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2014558,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1568726,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1716235,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2011477,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1794037,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1883117,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1828600,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2064140,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2058664,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1576981,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2014558,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1568726,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1716235,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2011477,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1794037,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1883117,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 1828600,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2064140,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2058664,
                "content": [
                    {
                        "username": "iitjsagar",
                        "content": "Hello guys,\\n\\nIs it possible to solve this question with O(1) space complexity?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "[@AlphaProximaCentauri](/AlphaProximaCentauri) yes, it can solve using Lomuto partition and Hoars\\' Partition"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@SolskGaer](/SolskGaer) did you submit your code what is submission percent and time complexity"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Was thinking of making use of unused bits inside the 32-bit integer. But there weren't enough bits when the range of `-10^6 <= nums[i] <= 10^6` takes 21 bits but I need 17 more bits to store the resulting indices.\nSo Time O(n) Space O(1) solution doesn't seem possible.\n\nYou can easily do it time O(n logn) Space O(1) with in-place sorting by key."
                    },
                    {
                        "username": "Drupad_Dev18",
                        "content": "yes"
                    },
                    {
                        "username": "AlphaProximaCentauri",
                        "content": "[@SolskGaer](/SolskGaer) Can it be solved in less then O(n^2) time complexity and O(1) memory?"
                    },
                    {
                        "username": "SolskGaer",
                        "content": "yes, we can solve it using the idea of insertion sort\\n```\\nfunc pivotArray(nums []int, pivotal int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] <= pivotal {\\n\\t\\t\\ttemp := nums[i]\\n\\t\\t\\tvar j int\\n\\t\\t\\tfor j = i; j > 0 && ((temp == pivotal && nums[j-1] > pivotal) || (temp < pivotal && nums[j-1] >= pivotal)); j-- {\\n\\t\\t\\t\\tnums[j] = nums[j-1]\\n\\t\\t\\t}\\n\\t\\t\\tnums[j] = temp\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```"
                    },
                    {
                        "username": "john142",
                        "content": "Got this problem in a recent interview. The requirement is that you need to do it in-place, which means Space should be O(1)."
                    },
                    {
                        "username": "john142",
                        "content": "[@contactvaibhavi](/contactvaibhavi) The expected time complexity is O(n). Quicksort\\'s time complexity is O(nlogn) on average. This problem doesn\\'t require you to sort all elements in order, so you only need to use the pivot and loop through the list one time."
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "[@Tushar_Tushar](/Tushar_Tushar) Yes, exactly. \\n\\nFor O(nlogn), any stable sort algorithm would do with binary comparisons to preserve the order of elements."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@contactvaibhavi](/contactvaibhavi) I think, It should be O(NlogN)"
                    },
                    {
                        "username": "contactvaibhavi",
                        "content": "And what\\'s the expected time complexity?"
                    },
                    {
                        "username": "uuTracy",
                        "content": "Wonder if it is possible to solve this question by O(1) space."
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag I Think. Should be an easy problem."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Definitely should be an easy level question unless nums has to be processed in place..."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "the question is easy till you can use extra memory but it is difficult who does not know the insertion sorting and space extra should be o(1)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[9,5,3,10,10,14,12]\\nExpected\\n[9,5,3,10,10,12,14]\\n\\nReally dude ?  I can\\'t use Dutch Flag Algorithm because my last numbers are reversed ?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "[@spookie886](/spookie886) no..."
                    },
                    {
                        "username": "spookie886",
                        "content": "Same problem here!! Have you figured out how to do it using this algo?"
                    },
                    {
                        "username": "trqkkr",
                        "content": "how is this medium? it\\'s easier than fizzbuzz lol"
                    },
                    {
                        "username": "deep_71",
                        "content": "why quick sort is not working??"
                    },
                    {
                        "username": "Androw77",
                        "content": "O(n) is easy but solving it in O(1) I tried for 2 hours and couldn\\'t do it, anyone was able to do it in O(1) that can tell me how?"
                    }
                ]
            },
            {
                "id": 2024362,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 2022582,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 2015927,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 2005338,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 1960001,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 1958907,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 1903408,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 1899565,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 1869865,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            },
            {
                "id": 1803943,
                "content": [
                    {
                        "username": "sanchit1417",
                        "content": "is there a variation of the dutch flag that we can apply?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "can you apply a partition on this question with relative order? If yes how?"
                    },
                    {
                        "username": "layyy",
                        "content": "maintain three pointers after finding the count of elements"
                    },
                    {
                        "username": "adipta28",
                        "content": "can  this be done with recursion?"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "we can do it by many methods,  I realized many did with taking three for loops using conditions O(n), we can also do it with three pointer approach. \\nOne pointer for less than pivot,\\nsecond pointer for equal to pivot,\\nthird pointer for greater than pivot this also take O(n)."
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "but  their real relative ordering will change"
                    },
                    {
                        "username": "Harsh404_",
                        "content": "This is a easy level question. "
                    },
                    {
                        "username": "rahulrauki",
                        "content": "I\\'m trying to implement using Lomuto\\'s partition, but it\\'s annoying!"
                    },
                    {
                        "username": "iyer_rajesh",
                        "content": "Lomuto\\'s partitioning won\\'t preserve order afaik. "
                    },
                    {
                        "username": "saifrhman03",
                        "content": "test case 14: \\ninput = [4,0,4,5,-11]\\nmy output = [4,4,0,-11,5]\\nexpected = [4,0,4,-11,5] \\n\\ncan anyone explain me why the expected output is this way? I dont understand."
                    },
                    {
                        "username": "dopingcode",
                        "content": "As per naive solution, it should be in easy category but because it uses special algorith like lomuto and hoars\\' partition it should be medium category. It you guys think"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Yeah, they should reduce the memory limit, and throw more \"Memory Limit Exceeded\" to make it a medium, but their own hints suggests to use the naive approach,"
                    },
                    {
                        "username": "fabianrobin2001",
                        "content": "class Solution {\\n    public int[] pivotArray(int[] arr, int pivot) {\\n         List<Integer> a=new ArrayList<Integer>();\\n        List<Integer> b=new ArrayList<Integer>();\\n        List<Integer> c=new ArrayList<Integer>();\\n        int n=arr.length;\\n        int arr1[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<pivot)\\n            {\\n               a.add(arr[i]);\\n               \\n            }\\n            else if(arr[i]==pivot)\\n            {\\n                continue;\\n            }\\n            \\n            else if(arr[i]>pivot)\\n            b.add(arr[i]);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==pivot)\\n            count++;\\n        }\\n        for(int i=1;i<=count;i++)\\n        {\\n            a.add(pivot);\\n        }\\n        c.addAll(a);\\n        c.addAll(b);\\n        \\n       for(int i=0;i<c.size();i++)\\n       {\\n           arr1[i]=c.get(i);\\n       }\\n      return arr1;\\n       \\n        \\n        \\n    }\\n}\\n   "
                    }
                ]
            }
        ]
    }
]