[
    {
        "title": "Check Whether Two Strings are Almost Equivalent",
        "question_content": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.\n&nbsp;\nExample 1:\n\nInput: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.\n\nExample 2:\n\nInput: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.\n\nExample 3:\n\nInput: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.\n\n&nbsp;\nConstraints:\n\n\tn == word1.length == word2.length\n\t1 <= n <= 100\n\tword1 and word2 consist only of lowercase English letters.",
        "solutions": [
            {
                "id": 1575960,
                "title": "c-straightforward",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string s, string t) {\\n        int cnt[26] = {};\\n        for (char c : s) cnt[c - \\'a\\']++;\\n        for (char c : t) cnt[c - \\'a\\']--;\\n        for (int i = 0; i < 26; ++i) {\\n            if (abs(cnt[i]) > 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string s, string t) {\\n        int cnt[26] = {};\\n        for (char c : s) cnt[c - \\'a\\']++;\\n        for (char c : t) cnt[c - \\'a\\']--;\\n        for (int i = 0; i < 26; ++i) {\\n            if (abs(cnt[i]) > 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586119,
                "title": "java-easy-solution-using-hashmap",
                "content": "```\\nclass Solution { \\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character,Integer> map = new HashMap();\\n        for (int i = 0; i < word1.length(); i++) {\\n            map.put(word1.charAt(i), map.getOrDefault(word1.charAt(i), 0) + 1);\\n            map.put(word2.charAt(i), map.getOrDefault(word2.charAt(i), 0) - 1);\\n        }\\n        for (int i : map.values()) { //get value set\\n            if (i > 3 || i < -3) { \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution { \\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character,Integer> map = new HashMap();\\n        for (int i = 0; i < word1.length(); i++) {\\n            map.put(word1.charAt(i), map.getOrDefault(word1.charAt(i), 0) + 1);\\n            map.put(word2.charAt(i), map.getOrDefault(word2.charAt(i), 0) - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1576575,
                "title": "counter-arithmetic",
                "content": "**Python 3**\\nUsing counter arithmetic in Python. The subtraction does not go negative, so we need to do it both ways.\\n\\n```python\\nclass Solution:\\n    def checkAlmostEquivalent(self, w1: str, w2: str) -> bool:\\n\\t\\treturn all(v < 4 for v in ((Counter(w1) - Counter(w2)) + (Counter(w2) - Counter(w1))).values())\\n```\\n\\n**C++**\\n```cpp\\nbool checkAlmostEquivalent(string w1, string w2) {\\n    int cnt[26] = {};\\n    for (int i = 0; i < w1.size(); ++i) {\\n        ++cnt[w1[i] - \\'a\\'];\\n        --cnt[w2[i] - \\'a\\'];\\n    }\\n    return all_of(begin(cnt), end(cnt), [](int cnt){ return abs(cnt) < 4; });\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def checkAlmostEquivalent(self, w1: str, w2: str) -> bool:\\n\\t\\treturn all(v < 4 for v in ((Counter(w1) - Counter(w2)) + (Counter(w2) - Counter(w1))).values())\\n```\n```cpp\\nbool checkAlmostEquivalent(string w1, string w2) {\\n    int cnt[26] = {};\\n    for (int i = 0; i < w1.size(); ++i) {\\n        ++cnt[w1[i] - \\'a\\'];\\n        --cnt[w2[i] - \\'a\\'];\\n    }\\n    return all_of(begin(cnt), end(cnt), [](int cnt){ return abs(cnt) < 4; });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581308,
                "title": "python-easy-solution",
                "content": "In this code first we check for all the values of word1 and compare them with the values present in word2 and repeat the same for word2 and compare it with the values of word1.\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        for i in range(len(word1)):\\n            a=word1.count(word1[i])\\n            b=word2.count(word1[i])\\n            if(abs(a-b)>3):\\n                return(False)\\n            \\n        for i in range(len(word2)):\\n            a=word2.count(word2[i])\\n            b=word1.count(word2[i])\\n            if(abs(a-b)>3):\\n                return(False)\\n        \\n        return(True)\\n```\\nIf u understood the code then plz....UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        for i in range(len(word1)):\\n            a=word1.count(word1[i])\\n            b=word2.count(word1[i])\\n            if(abs(a-b)>3):\\n                return(False)\\n            \\n        for i in range(len(word2)):\\n            a=word2.count(word2[i])\\n            b=word1.count(word2[i])\\n            if(abs(a-b)>3):\\n                return(False)\\n        \\n        return(True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575936,
                "title": "concise-c-java-python-explanation-for-beginners-ideas-discussed",
                "content": "\\n\\n**Idea**\\nThis is a fairly simple problem which can be approached in multiple ways. The brute force method would be to count frequencies of every possible character by traversing the strings for each character. Following is a C++ implementation of this idea.\\n\\n**C++ [Brute Force]**\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n            int f1 = 0, f2 = 0;\\n            for(char c : word1) {\\n                if(c == ch)\\n                    f1++;\\n            }\\n            for(char c : word2) {\\n                if(c == ch)\\n                    f2++;\\n            }\\n            if(abs(f1 - f2) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n*Space Complexity (Auxiliary): O(1)*\\n*Time Complexity: O(26 * n) = O(n)*\\n\\n**Optimized**\\nInstead of traversing the strings over and over again for each character, we can simply count the frequencies of each character and store them in a hashmap. In this case, since only lowercase english characters are allowed, we can also use a frequency array instead of a hashmap. After storing all character frequencies for both the strings, we can traverse the frequency array to check if there\\'s any character whose difference in frequencies exceeds 3.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int f1[26] = {0}, f2[26] = {0};\\n        \\n        for(char c : word1) {\\n            f1[c - \\'a\\']++;\\n        }\\n        for(char c : word2) {\\n            f2[c - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            if(abs(f1[i] - f2[i]) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] f1 = new int[26];\\n        int[] f2 = new int[26];\\n        \\n        for(char c : word1.toCharArray()) {\\n            f1[c - \\'a\\']++;\\n        }\\n        for(char c : word2.toCharArray()) {\\n            f2[c - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            if(Math.abs(f1[i] - f2[i]) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        f1, f2 = [0] * 26, [0] * 26\\n        \\n        for ch in word1:\\n            f1[ord(ch) - ord(\\'a\\')] += 1\\n            \\n        for ch in word2:\\n            f2[ord(ch) - ord(\\'a\\')] += 1\\n        \\n        for i in range(26):\\n            if abs(f1[i] - f2[i]) > 3:\\n                return False\\n            \\n        return True\\n```\\n\\n*Space Complexity (Auxiliary): O(26) = O(1)*\\n*Time Complexity: O(n)*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n            int f1 = 0, f2 = 0;\\n            for(char c : word1) {\\n                if(c == ch)\\n                    f1++;\\n            }\\n            for(char c : word2) {\\n                if(c == ch)\\n                    f2++;\\n            }\\n            if(abs(f1 - f2) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int f1[26] = {0}, f2[26] = {0};\\n        \\n        for(char c : word1) {\\n            f1[c - \\'a\\']++;\\n        }\\n        for(char c : word2) {\\n            f2[c - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            if(abs(f1[i] - f2[i]) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] f1 = new int[26];\\n        int[] f2 = new int[26];\\n        \\n        for(char c : word1.toCharArray()) {\\n            f1[c - \\'a\\']++;\\n        }\\n        for(char c : word2.toCharArray()) {\\n            f2[c - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            if(Math.abs(f1[i] - f2[i]) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        f1, f2 = [0] * 26, [0] * 26\\n        \\n        for ch in word1:\\n            f1[ord(ch) - ord(\\'a\\')] += 1\\n            \\n        for ch in word2:\\n            f2[ord(ch) - ord(\\'a\\')] += 1\\n        \\n        for i in range(26):\\n            if abs(f1[i] - f2[i]) > 3:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585278,
                "title": "python-one-line-counter-solution",
                "content": "**Python :**\\n\\n```\\ndef checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n\\treturn all(v <= 3 for v in ((Counter(list(word1)) - Counter(list(word2))) + (Counter(list(word2)) - Counter(list(word1)))).values())\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n\\treturn all(v <= 3 for v in ((Counter(list(word1)) - Counter(list(word2))) + (Counter(list(word2)) - Counter(list(word1)))).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1575958,
                "title": "python3-dictionary-a-few-versions-and-one-liners",
                "content": "We are counting letters in both words and store it in the dictionary.\\n```word1``` is adding one point\\n```word2``` is substructing one point\\nWhen ```word1```  is same as ```word2``` we have all values in the dictionary ```zero```\\n\\nFor this problem we are looking for the situation when all values in the dictionary are between ```-3``` and ```3``` .\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        d={}\\n        for ch in word1:\\n            d[ch]=d.get(ch,0)+1\\n        for ch in word2:\\n            d[ch]=d.get(ch,0)-1\\n        difFreq=max(abs(val) for val in d.values())\\n        return difFreq<=3\\n```\\n\\nOr shorter code:\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        d=Counter(word1)\\n        for ch in word2:\\n            d[ch]-=1\\n        return max(abs(val) for val in d.values())<=3\\n```\\nOr two lines version.\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        d=Counter(word1)\\n        return all(abs(d[ch]-val)<4 for ch,val in Counter(word2).items()) and max((Counter(word1+\\'*\\')-Counter(word2)).values())<4\\n```\\n\\nOne liner is too ugly, but it works:\\n\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        return all(abs(Counter(word1)[ch]-val)<4 for ch,val in Counter(word2).items()) and max((Counter(word1+\\'*\\')-Counter(word2)).values())<4\\n```\\n\\nThank you @votrubac, the one liner looks much better:\\n\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, w1: str, w2: str) -> bool:\\n        return all(v < 4 for v in ((Counter(w1)-Counter(w2))+(Counter(w2)-Counter(w1))).values())\\n```",
                "solutionTags": [],
                "code": "```word1```\n```word2```\n```word1```\n```word2```\n```zero```\n```-3```\n```3```\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        d={}\\n        for ch in word1:\\n            d[ch]=d.get(ch,0)+1\\n        for ch in word2:\\n            d[ch]=d.get(ch,0)-1\\n        difFreq=max(abs(val) for val in d.values())\\n        return difFreq<=3\\n```\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        d=Counter(word1)\\n        for ch in word2:\\n            d[ch]-=1\\n        return max(abs(val) for val in d.values())<=3\\n```\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        d=Counter(word1)\\n        return all(abs(d[ch]-val)<4 for ch,val in Counter(word2).items()) and max((Counter(word1+\\'*\\')-Counter(word2)).values())<4\\n```\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        return all(abs(Counter(word1)[ch]-val)<4 for ch,val in Counter(word2).items()) and max((Counter(word1+\\'*\\')-Counter(word2)).values())<4\\n```\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, w1: str, w2: str) -> bool:\\n        return all(v < 4 for v in ((Counter(w1)-Counter(w2))+(Counter(w2)-Counter(w1))).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745625,
                "title": "javascript-hash-map-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nCreate a hashmap where keys are characters and values are frequencies. Iterate over `word1` and add +1 to the frequency in the hashmap. Same for `word2` but this time subtract -1. In the end, check whether any resulting frequency is greater than 3.\\n\\nTime: **O(n)** - for scan\\nSpace: **O(1)** - for hashmap\\n\\n```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    const hm = new Map()\\n    const addToHm = (ch, add) => {\\n        if (hm.has(ch)) \\n            hm.set(ch, hm.get(ch) + (add ? +1 : -1))\\n        else \\n            hm.set(ch, (add ? +1 : -1))  \\n    }\\n    \\n    for (let i = 0; i < word1.length; i++) {\\n        addToHm(word1[i], true) \\n        addToHm(word2[i], false) \\n    }\\n    \\n    for (const val of hm.values())\\n        if (Math.abs(val) > 3)\\n\\t\\t\\treturn false\\n    \\n    return true\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    const hm = new Map()\\n    const addToHm = (ch, add) => {\\n        if (hm.has(ch)) \\n            hm.set(ch, hm.get(ch) + (add ? +1 : -1))\\n        else \\n            hm.set(ch, (add ? +1 : -1))  \\n    }\\n    \\n    for (let i = 0; i < word1.length; i++) {\\n        addToHm(word1[i], true) \\n        addToHm(word2[i], false) \\n    }\\n    \\n    for (const val of hm.values())\\n        if (Math.abs(val) > 3)\\n\\t\\t\\treturn false\\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576262,
                "title": "c-hashmap-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkAlmostEquivalent(string word1, string word2) {\\n\\t\\t\\tunordered_map<char, int> m;\\n\\t\\t\\tfor(int i = 0; i < word1.size(); i++){\\n\\t\\t\\t\\tm[word1[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < word2.size(); i++){\\n\\t\\t\\t\\tm[word2[i]]--;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto i : m){\\n\\t\\t\\t\\tif(abs(i.second) > 3){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkAlmostEquivalent(string word1, string word2) {\\n\\t\\t\\tunordered_map<char, int> m;\\n\\t\\t\\tfor(int i = 0; i < word1.size(); i++){\\n\\t\\t\\t\\tm[word1[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2513742,
                "title": "python-concise-array-solution-no-counter-hash-map-beats-98",
                "content": "Most solution are using a hash map/Counter to count the occurences for every word itself and then compare these counters.\\n\\nBut since the alphabet is limited to 26 characters, we can just do the same using an array and do it in one pass through both words at the same time. This allows us to make one pass instead of two (for two counters) and we don\\'t need to subtract the values of the same hashes.\\n\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        \\n        # make an array to track occurences for every letter of the\\n        # alphabet\\n        alphabet = [0]*26\\n        \\n        # go through both words and count occurences\\n        # word 1 add and word 2 subtract\\n        # after this we have the differences for every letter\\n        for index in range(len(word1)):\\n            alphabet[ord(word1[index]) - 97] += 1\\n            alphabet[ord(word2[index]) - 97] -= 1\\n        \\n        # find min and max and check that it is less than three\\n        return min(alphabet) >= -3 and max(alphabet) <= 3\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        \\n        # make an array to track occurences for every letter of the\\n        # alphabet\\n        alphabet = [0]*26\\n        \\n        # go through both words and count occurences\\n        # word 1 add and word 2 subtract\\n        # after this we have the differences for every letter\\n        for index in range(len(word1)):\\n            alphabet[ord(word1[index]) - 97] += 1\\n            alphabet[ord(word2[index]) - 97] -= 1\\n        \\n        # find min and max and check that it is less than three\\n        return min(alphabet) >= -3 and max(alphabet) <= 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012460,
                "title": "easy-java-one-pass-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] charFrequency = new int[26];\\n        for(int i = 0; i<word1.length(); i++){\\n            charFrequency[word1.charAt(i)-\\'a\\']++;\\n            charFrequency[word2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int freq : charFrequency){\\n            if(Math.abs(freq) > 3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] charFrequency = new int[26];\\n        for(int i = 0; i<word1.length(); i++){\\n            charFrequency[word1.charAt(i)-\\'a\\']++;\\n            charFrequency[word2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int freq : charFrequency){\\n            if(Math.abs(freq) > 3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580614,
                "title": "100-runtime-90-memory",
                "content": "- Keep an integer array of size 26 since there are 26 lower letter alphabets. \\n- Loop through the first string and increment the frequency of letters\\n- Loop through the second string and decrement the frequency of letters\\n- Finally, loop through the resulting frequency array and return false if absolute value is greater than 3.\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(const string& word1, const string& word2) {\\n        int f[26]={0};\\n        for(auto c: word1) { ++f[c-\\'a\\']; }\\n        for(auto c: word2) { --f[c-\\'a\\']; }\\n        \\n        for(int i=0; i<26; ++i) {\\n            if(abs(f[i])>3) { return false; }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(const string& word1, const string& word2) {\\n        int f[26]={0};\\n        for(auto c: word1) { ++f[c-\\'a\\']; }\\n        for(auto c: word2) { --f[c-\\'a\\']; }\\n        \\n        for(int i=0; i<26; ++i) {\\n            if(abs(f[i])>3) { return false; }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549886,
                "title": "simple-o-n-time-o-1-space-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) \\n    {\\n       int[] alphabets = new int[26];\\n        int len = word1.length();\\n        \\n        for(int i=0; i<len;i++)\\n        {\\n            alphabets[word1.charAt(i) - \\'a\\']++;\\n            alphabets[word2.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for(int i=0; i<26;i++)\\n        {\\n            if(Math.abs(alphabets[i]) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) \\n    {\\n       int[] alphabets = new int[26];\\n        int len = word1.length();\\n        \\n        for(int i=0; i<len;i++)\\n        {\\n            alphabets[word1.charAt(i) - \\'a\\']++;\\n            alphabets[word2.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for(int i=0; i<26;i++)\\n        {\\n            if(Math.abs(alphabets[i]) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065965,
                "title": "fast-easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) \\n    {\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        for(char c:word1.toCharArray())\\n            hmap.put(c,hmap.getOrDefault(c,0)+1);\\n        for(char c:word2.toCharArray())\\n            hmap.put(c,hmap.getOrDefault(c,0)-1);\\n        for(char c:hmap.keySet())\\n        {\\n            if(hmap.get(c)>3 || hmap.get(c)<-3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) \\n    {\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        for(char c:word1.toCharArray())\\n            hmap.put(c,hmap.getOrDefault(c,0)+1);\\n        for(char c:word2.toCharArray())\\n            hmap.put(c,hmap.getOrDefault(c,0)-1);\\n        for(char c:hmap.keySet())\\n        {\\n            if(hmap.get(c)>3 || hmap.get(c)<-3)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1576889,
                "title": "c-solution-100-better-short-and-sweet-with-explanation",
                "content": "Intialize a map and count frequeny of each letter occur in both string (Size of both string is same) \\nnow if same letter occur in both string then there count get calculate like:\\nword1 = \"abcdeef\", word2 = \"abaaacc\"\\nmp[a] get increment 1 time for word1 and decrement 4 time for word2,so mp[a]=-3;\\nWe use abs because for handling cases like:\\nword1=\"zzzyyy\"\\nword2=\"iiiiii\"\\nin this situation mp[i]=-6 \\n\\n```\\n bool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            mp[word1[i]]++;\\n            mp[word2[i]]--;\\n        }\\n        for(auto i:mp)\\n            if(abs(i.second)>3 )\\n                return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            mp[word1[i]]++;\\n            mp[word2[i]]--;\\n        }\\n        for(auto i:mp)\\n            if(abs(i.second)>3 )\\n                return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576384,
                "title": "js-easy-solution-100-time-space-with-explanation",
                "content": "Here I am using an array of size 26 to store the frequency of the characters. We have to find the difference of the each characters of word1 and word2 string. \\nso in word1, I\\'ve increased the frequency of any Character\\n& in word2, I\\'ve decreased the frequency of any Character.\\n\\nand finally got the difference for the each of 26 alphabets. if diff>3 then returns false.\\n\\none more thing, for the \"index\", ascii value of \\'a\\' =97\\n\\'a\\'-97=0, \\'b\\'-97=1, \\'c\\'-97=2, ... , \\'z\\'-97= 25 \\n\\nIf you still have any doubt, please comment below and Upvote if you like!\\n```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    var mp= new Array(26).fill(0);\\n    for(let i=0; i < word1.length;i++){\\n        let index=word1.charCodeAt(i)-97; //as ascii value of \\'a\\'=97\\n        mp[index]++;\\n    }\\n    for(let i=0; i < word2.length;i++){\\n        let index=word2.charCodeAt(i)-97;\\n        mp[index]--;\\n    }\\n    for(let i=0;i<26;i++){\\n        if(Math.abs(mp[i])>3)\\n            return false;\\n    }\\n    return true;\\n};\\n```\\n\\nTime Complexity: O(N), Space Complexity: O(N)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    var mp= new Array(26).fill(0);\\n    for(let i=0; i < word1.length;i++){\\n        let index=word1.charCodeAt(i)-97; //as ascii value of \\'a\\'=97\\n        mp[index]++;\\n    }\\n    for(let i=0; i < word2.length;i++){\\n        let index=word2.charCodeAt(i)-97;\\n        mp[index]--;\\n    }\\n    for(let i=0;i<26;i++){\\n        if(Math.abs(mp[i])>3)\\n            return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605280,
                "title": "easy-python-solution",
                "content": "```\\ndef checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        for i in word1:\\n            if abs(word1.count(i)-word2.count(i))>3:\\n                return False\\n        for j in word2:\\n            if abs(word1.count(j)-word2.count(j))>3:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        for i in word1:\\n            if abs(word1.count(i)-word2.count(i))>3:\\n                return False\\n        for j in word2:\\n            if abs(word1.count(j)-word2.count(j))>3:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1576066,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        \\n        for(int i = 0; i < word1.length(); i++)\\n            freq1[word1[i]-\\'a\\']++;\\n        \\n        for(int i = 0; i < word2.length(); i++)\\n            freq2[word2[i]-\\'a\\']++;\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(abs(freq1[i] - freq2[i]) > 3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        \\n        for(int i = 0; i < word1.length(); i++)\\n            freq1[word1[i]-\\'a\\']++;\\n        \\n        for(int i = 0; i < word2.length(); i++)\\n            freq2[word2[i]-\\'a\\']++;\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(abs(freq1[i] - freq2[i]) > 3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343506,
                "title": "python-learn-the-use-of-any-and-character-count-using-array-concise-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173472,
                "title": "python-sets-union-95-better",
                "content": "Let masterset be the combination set of word1 and word2.\\nCount the absolute difference of character in word1 and word2.\\nReturn false if more than 3, else True\\n\\nPlease upvote if it helps you! Thank you :)\\n\\n```\\nmasterset = set(word1).union(set(word2))\\n\\nfor i in masterset:\\n\\tif abs(word1.count(i) - word2.count(i)) > 3:\\n\\t\\treturn False\\nreturn True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nmasterset = set(word1).union(set(word2))\\n\\nfor i in masterset:\\n\\tif abs(word1.count(i) - word2.count(i)) > 3:\\n\\t\\treturn False\\nreturn True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1622816,
                "title": "c-constant-space-0ms-100-fast",
                "content": "Linear time, constant space solution: \\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        int arr1[26] = {0}; // store frequency of word1\\n        int arr2[26] = {0}; // store frequency of word2\\n        for(int i=0; i<word1.length(); i++)\\n        {\\n            arr1[word1[i]-\\'a\\']++;\\n            arr2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++)\\n        {\\n            if(abs(arr1[i]-arr2[i])>3) return false; // check frequency difference\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        int arr1[26] = {0}; // store frequency of word1\\n        int arr2[26] = {0}; // store frequency of word2\\n        for(int i=0; i<word1.length(); i++)\\n        {\\n            arr1[word1[i]-\\'a\\']++;\\n            arr2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++)\\n        {\\n            if(abs(arr1[i]-arr2[i])>3) return false; // check frequency difference\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576339,
                "title": "python3-freq-table",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/e61879b77928a08bb15cc182a69259d6e2bce59a) for solutions of biweekly 65. \\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        freq = [0]*26\\n        for x in word1: freq[ord(x)-97] += 1\\n        for x in word2: freq[ord(x)-97] -= 1\\n        return all(abs(x) <= 3 for x in freq)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        freq = [0]*26\\n        for x in word1: freq[ord(x)-97] += 1\\n        for x in word2: freq[ord(x)-97] -= 1\\n        return all(abs(x) <= 3 for x in freq)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808202,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> v1(26), v2(26);\\n        for(auto x: word1) v1[x-\\'a\\']++;\\n        for(auto x: word2) v2[x-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            if (abs(v1[i] - v2[i]) > 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> v1(26), v2(26);\\n        for(auto x: word1) v1[x-\\'a\\']++;\\n        for(auto x: word2) v2[x-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            if (abs(v1[i] - v2[i]) > 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589488,
                "title": "python3-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        words = set(word1 + word2)\\n        for w in words:\\n            if abs(word1.count(w) - word2.count(w)) >3:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        words = set(word1 + word2)\\n        for w in words:\\n            if abs(word1.count(w) - word2.count(w)) >3:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396320,
                "title": "easy-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        check = set(word1 + word2)\\n\\n        for i in check:\\n            res = abs(word1.count(i) - word2.count(i)) >= 4\\n            if res:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        check = set(word1 + word2)\\n\\n        for i in check:\\n            res = abs(word1.count(i) - word2.count(i)) >= 4\\n            if res:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218336,
                "title": "javascript-hash",
                "content": "very simple:\\n1. count all letters from the first array with \"+\" increment\\n2. count all letters from the second array with \"-\" increment\\n3. find at least one letter which has absolute value more than 3\\n\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction checkAlmostEquivalent(word1: string, word2: string): boolean {\\n    const hash = {};\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        const letter = word1[i];\\n        const letter2 = word2[i];\\n\\n        if (!hash[letter]) {\\n            hash[letter] = 0;\\n        }\\n\\n        if (!hash[letter2]) {\\n            hash[letter2] = 0;\\n        }\\n\\n        hash[letter]++;\\n        hash[letter2]--;\\n    }\\n\\n    return !Object.keys(hash).find((letter) => Math.abs(hash[letter]) > 3)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction checkAlmostEquivalent(word1: string, word2: string): boolean {\\n    const hash = {};\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        const letter = word1[i];\\n        const letter2 = word2[i];\\n\\n        if (!hash[letter]) {\\n            hash[letter] = 0;\\n        }\\n\\n        if (!hash[letter2]) {\\n            hash[letter2] = 0;\\n        }\\n\\n        hash[letter]++;\\n        hash[letter2]--;\\n    }\\n\\n    return !Object.keys(hash).find((letter) => Math.abs(hash[letter]) > 3)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083643,
                "title": "check-whether-two-strings-are-almost-equivalent",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        check = set(word1 + word2)\\n        for i in check:\\n            limit = abs(word1.count(i) - word2.count(i)) >= 4\\n            if limit:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        check = set(word1 + word2)\\n        for i in check:\\n            limit = abs(word1.count(i) - word2.count(i)) >= 4\\n            if limit:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755130,
                "title": "java-in-just-3-ms-2-solutions",
                "content": "# Solution 1 | in 7 ms\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : word1.toCharArray()) {\\n            if (map.containsKey(c)) {\\n                map.put(c, map.get(c) + 1);\\n            } else {\\n                map.put(c, 1);\\n            }\\n        }\\n        for (char c : word2.toCharArray()) {\\n            if (map.containsKey(c)) {\\n                map.put(c, map.get(c) - 1);\\n            } else {\\n                map.put(c, -1);\\n            }\\n        }\\n\\n        for (char key : map.keySet()) {\\n            if (Math.abs(map.get(key)) > 3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Solution 2 | in 3 ms\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        byte[] alph = new byte[26];\\n        for (char c : word1.toCharArray()) {\\n            alph[c - \\'a\\']++;\\n        }\\n\\n        for (char c : word2.toCharArray()) {\\n            alph[c - \\'a\\']--;\\n        }\\n\\n        for (byte n : alph) {\\n            if (Math.abs(n) > 3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : word1.toCharArray()) {\\n            if (map.containsKey(c)) {\\n                map.put(c, map.get(c) + 1);\\n            } else {\\n                map.put(c, 1);\\n            }\\n        }\\n        for (char c : word2.toCharArray()) {\\n            if (map.containsKey(c)) {\\n                map.put(c, map.get(c) - 1);\\n            } else {\\n                map.put(c, -1);\\n            }\\n        }\\n\\n        for (char key : map.keySet()) {\\n            if (Math.abs(map.get(key)) > 3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        byte[] alph = new byte[26];\\n        for (char c : word1.toCharArray()) {\\n            alph[c - \\'a\\']++;\\n        }\\n\\n        for (char c : word2.toCharArray()) {\\n            alph[c - \\'a\\']--;\\n        }\\n\\n        for (byte n : alph) {\\n            if (Math.abs(n) > 3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691890,
                "title": "runtime-faster-than-88-46-memory-usage-less-than-73-08-of-javascript-online-submissions",
                "content": "```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    const hash = {};\\n    \\n    for (let c of word1) {\\n        hash[c] = (hash[c] || 0) + 1;\\n    }\\n    \\n    for (let c of word2) {\\n        hash[c] = (hash[c] || 0) - 1;\\n    }\\n    \\n    for (let c in hash) {\\n        if (Math.abs(hash[c]) > 3) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    const hash = {};\\n    \\n    for (let c of word1) {\\n        hash[c] = (hash[c] || 0) + 1;\\n    }\\n    \\n    for (let c of word2) {\\n        hash[c] = (hash[c] || 0) - 1;\\n    }\\n    \\n    for (let c in hash) {\\n        if (Math.abs(hash[c]) > 3) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2328826,
                "title": "c-0ms-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<int, int> w;\\n        \\n        for(int i=0; i<word1.size(); i++) {\\n            w[word1[i]]++;\\n            w[word2[i]]--;\\n        }\\n        \\n        for(auto& it : w)\\n            if(it.second > 3 || it.second < -3)\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<int, int> w;\\n        \\n        for(int i=0; i<word1.size(); i++) {\\n            w[word1[i]]++;\\n            w[word2[i]]--;\\n        }\\n        \\n        for(auto& it : w)\\n            if(it.second > 3 || it.second < -3)\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867082,
                "title": "100-faster-c-solution-using-hashmap",
                "content": "```\\n bool checkAlmostEquivalent(string w1, string w2) {\\n        map<char,int> m;\\n        for(int i=0;i<w1.size();i++)\\n        {\\n            m[w1[i]]++;\\n            m[w2[i]]--;\\n        }\\n        for(auto i:m)\\n            if(abs(i.second)>3)\\n                return false;\\n        return true;\\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool checkAlmostEquivalent(string w1, string w2) {\\n        map<char,int> m;\\n        for(int i=0;i<w1.size();i++)\\n        {\\n            m[w1[i]]++;\\n            m[w2[i]]--;\\n        }\\n        for(auto i:m)\\n            if(abs(i.second)>3)\\n                return false;\\n        return true;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1839933,
                "title": "java-easy-count-sort-o-n-time",
                "content": "Appraoch:\\n* Since we only have to deal with lowercase english alphabets, we keep track of frequencies in side an array of size 26. \\n* Since the size of both the strings are equal, iterate over them together and for every character in ```word1``` increment and counter in map and decrement the same for every character in ```word2```.\\n* Once, we are done doing the above, now we can again iterate over the array and see if any character\\'s frequency is more than 3 or less than -3. If this is correct return false else true.\\n\\n\\nTime: O(N) | Space: O(26)\\n\\n```\\npublic boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] map = new int[26];\\n        for(int i = 0; i < word1.length(); i++){\\n            map[word1.charAt(i) - \\'a\\']++;\\n            map[word2.charAt(i) - \\'a\\']--;\\n        }\\n        for(int i = 0; i < map.length; i++){\\n            if(Math.abs(map[i]) > 3) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```word1```\n```word2```\n```\\npublic boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] map = new int[26];\\n        for(int i = 0; i < word1.length(); i++){\\n            map[word1.charAt(i) - \\'a\\']++;\\n            map[word2.charAt(i) - \\'a\\']--;\\n        }\\n        for(int i = 0; i < map.length; i++){\\n            if(Math.abs(map[i]) > 3) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715049,
                "title": "c-easy-beginner-friendly-code",
                "content": "**Please upvote if you like it**\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int c1,c2;\\n        for(int i=\\'a\\';i<=\\'z\\';i++)\\n        {\\n            c1=0;\\n            c2=0;\\n            for(int j=0;j<word1.length();j++)\\n                if(word1[j]==i)\\n                    c1++;\\n            \\n            for(int j=0;j<word2.length();j++)\\n                if(word2[j]==i)\\n                    c2++;\\n            \\n            if(abs(c1-c2)>3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int c1,c2;\\n        for(int i=\\'a\\';i<=\\'z\\';i++)\\n        {\\n            c1=0;\\n            c2=0;\\n            for(int j=0;j<word1.length();j++)\\n                if(word1[j]==i)\\n                    c1++;\\n            \\n            for(int j=0;j<word2.length();j++)\\n                if(word2[j]==i)\\n                    c2++;\\n            \\n            if(abs(c1-c2)>3)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1593156,
                "title": "python3-solution-easy-to-follow",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        hash1, hash2 = Counter(word1), Counter(word2)\\n        uniqueLetters = set(word1 + word2)\\n        \\n        for letter in uniqueLetters:\\n            if abs(hash1[letter] - hash2[letter]) > 3:\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        hash1, hash2 = Counter(word1), Counter(word2)\\n        uniqueLetters = set(word1 + word2)\\n        \\n        for letter in uniqueLetters:\\n            if abs(hash1[letter] - hash2[letter]) > 3:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589613,
                "title": "c-simple-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        std::vector<int> mp(26);\\n        for(auto && i : word1){\\n            mp[i-\\'a\\']++;\\n        }\\n        for(auto && i : word2){\\n            mp[i-\\'a\\']--;\\n        }\\n        for(auto && i : mp){\\n            if(abs(i) > 3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        std::vector<int> mp(26);\\n        for(auto && i : word1){\\n            mp[i-\\'a\\']++;\\n        }\\n        for(auto && i : word2){\\n            mp[i-\\'a\\']--;\\n        }\\n        for(auto && i : mp){\\n            if(abs(i) > 3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579700,
                "title": "two-golang-solutions",
                "content": "The time complexity of the first solution is `O(2n + 26)`\\n\\n* The `2n` is for looping through both `word1` and `word2`. They both are the same length, so we get `2n` instead of `n * m`\\n* The `26` is for looping through `len(letters)`, because there are `26` letters in the alphabet. \\n\\n``` go\\nfunc checkAlmostEquivalent(word1 string, word2 string) bool {\\n    letters := make([]int, 26)\\n    \\n    for i := 0; i < len(word1); i++ {\\n        letters[int(word1[i] - \\'a\\')]++\\n        letters[int(word2[i] - \\'a\\')]--\\n    }\\n    \\n    for _, a := range letters {\\n        if a < -3 || a > 3 { return false }\\n    }\\n    \\n    return true\\n}\\n```\\n\\nThe worst time complexity of the following solution is `O(2n + 26)`, but since we are using a map instead of an array the time complexity can range from `O(2n + 1)` to `O(2n + 26)`.\\n\\n``` go\\nfunc checkAlmostEquivalent(word1 string, word2 string) bool {\\n    m := make(map[int] int)\\n    \\n    for i := 0; i < len(word1); i++ {\\n        m[int(word1[i] - \\'a\\')]++\\n        m[int(word2[i] - \\'a\\')]--\\n    }\\n    \\n    for _, val := range m {\\n        if val < -3 || val > 3 { return false }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc checkAlmostEquivalent(word1 string, word2 string) bool {\\n    letters := make([]int, 26)\\n    \\n    for i := 0; i < len(word1); i++ {\\n        letters[int(word1[i] - \\'a\\')]++\\n        letters[int(word2[i] - \\'a\\')]--\\n    }\\n    \\n    for _, a := range letters {\\n        if a < -3 || a > 3 { return false }\\n    }\\n    \\n    return true\\n}\\n```\n``` go\\nfunc checkAlmostEquivalent(word1 string, word2 string) bool {\\n    m := make(map[int] int)\\n    \\n    for i := 0; i < len(word1); i++ {\\n        m[int(word1[i] - \\'a\\')]++\\n        m[int(word2[i] - \\'a\\')]--\\n    }\\n    \\n    for _, val := range m {\\n        if val < -3 || val > 3 { return false }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577647,
                "title": "c-solution-using-maps",
                "content": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char,int>mp1,mp2;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            mp1[word1[i]]++;\\n            mp2[word2[i]]++;\\n        }\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            if(abs(mp1[i]-mp2[i])>3){\\n                return false;\\n            }\\n        }\\n        return true;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char,int>mp1,mp2;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            mp1[word1[i]]++;\\n            mp2[word2[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1576219,
                "title": "simple-o-n-solution-java-easy-to-understand-with-comments",
                "content": "```\\npublic boolean checkAlmostEquivalent(String word1, String word2) {\\n        int []char_freq = new int[26]; \\n        int n =word1.length(); \\n        for( int i=0; i < n ; i++)\\n        {\\n            char_freq[word1.charAt(i)-\\'a\\']++; // increase char frequency for word1\\n            char_freq[word2.charAt(i)-\\'a\\']--;  // decrement char frequency for word 2 \\n        }\\n        for( int i=0; i < 26 ; i++)\\n        {\\n            // if char_freq  difference for particular char is > 3 , return false\\n            if( Math.abs(char_freq[i]) > 3) \\n                return false;\\n        }\\n        return true;\\n    }\\n\\t\\n\\tjava  simple easy\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkAlmostEquivalent(String word1, String word2) {\\n        int []char_freq = new int[26]; \\n        int n =word1.length(); \\n        for( int i=0; i < n ; i++)\\n        {\\n            char_freq[word1.charAt(i)-\\'a\\']++; // increase char frequency for word1\\n            char_freq[word2.charAt(i)-\\'a\\']--;  // decrement char frequency for word 2 \\n        }\\n        for( int i=0; i < 26 ; i++)\\n        {\\n            // if char_freq  difference for particular char is > 3 , return false\\n            if( Math.abs(char_freq[i]) > 3) \\n                return false;\\n        }\\n        return true;\\n    }\\n\\t\\n\\tjava  simple easy\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576049,
                "title": "python3-one-pass-simple-o-1-space",
                "content": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        arr=[0]*26\\n        for c1,c2 in zip(word1,word2):\\n            arr[ord(c1)-ord(\\'a\\')]+=1\\n            arr[ord(c2)-ord(\\'a\\')]-=1\\n        return all(abs(el)<=3 for el in arr)\\n```\\n* Another solution:\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        dct1=collections.Counter(word1)-collections.Counter(word2)\\n        dct2=collections.Counter(word2)-collections.Counter(word1)\\n        return all(dct1[el]<=3 for el in dct1) and all(dct2[el]<=3 for el in dct2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        arr=[0]*26\\n        for c1,c2 in zip(word1,word2):\\n            arr[ord(c1)-ord(\\'a\\')]+=1\\n            arr[ord(c2)-ord(\\'a\\')]-=1\\n        return all(abs(el)<=3 for el in arr)\\n```\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        dct1=collections.Counter(word1)-collections.Counter(word2)\\n        dct2=collections.Counter(word2)-collections.Counter(word1)\\n        return all(dct1[el]<=3 for el in dct1) and all(dct2[el]<=3 for el in dct2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575923,
                "title": "python-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        f1 = Counter(word1)\\n        f2 = Counter(word2)\\n        for ch in string.ascii_lowercase:\\n            if abs(f1[ch]-f2[ch]) > 3:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        f1 = Counter(word1)\\n        f2 = Counter(word2)\\n        for ch in string.ascii_lowercase:\\n            if abs(f1[ch]-f2[ch]) > 3:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832780,
                "title": "c-take-the-diff-of-two-arrays",
                "content": "#Code\\n```\\npublic class Solution {\\n    public bool CheckAlmostEquivalent(string word1, string word2) {\\n        int[] a1 = new int[26], a2 = new int[26];\\n        foreach(char n in word1.ToCharArray())\\n            a1[n - 97]++;\\n        foreach(char n in word2.ToCharArray())\\n            a2[n - 97]++;\\n        for(int i = 0; i < a1.Length; i++)\\n        {\\n            a1[i] = Math.Abs(a1[i] - a2[i]);\\n            if(a1[i] > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckAlmostEquivalent(string word1, string word2) {\\n        int[] a1 = new int[26], a2 = new int[26];\\n        foreach(char n in word1.ToCharArray())\\n            a1[n - 97]++;\\n        foreach(char n in word2.ToCharArray())\\n            a2[n - 97]++;\\n        for(int i = 0; i < a1.Length; i++)\\n        {\\n            a1[i] = Math.Abs(a1[i] - a2[i]);\\n            if(a1[i] > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767204,
                "title": "93-5-time-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        # create combined string with all ch from word1 and word2\\n        combined = set(word1+word2)\\n        # for unique ch in combined create dictionary that counts freq of each ch in each word \\n        d1 = {x:word1.count(x) for x in combined}\\n        d2 = {x:word2.count(x) for x in combined}\\n        # create flag to determine if freq diff >3\\n        flag = True\\n        for key, val in d1.items():\\n            #compare freq for word1 and word2 if flag turns false break and return flag val\\n            if abs(d1[key] - d2[key]) > 3:\\n                flag = False\\n                break\\n        return flag\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        # create combined string with all ch from word1 and word2\\n        combined = set(word1+word2)\\n        # for unique ch in combined create dictionary that counts freq of each ch in each word \\n        d1 = {x:word1.count(x) for x in combined}\\n        d2 = {x:word2.count(x) for x in combined}\\n        # create flag to determine if freq diff >3\\n        flag = True\\n        for key, val in d1.items():\\n            #compare freq for word1 and word2 if flag turns false break and return flag val\\n            if abs(d1[key] - d2[key]) > 3:\\n                flag = False\\n                break\\n        return flag\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587821,
                "title": "check-whether-two-strings-are-almost-equivalent-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int i, j, flag=0;\\n        map<char, int> m1;\\n        map<char, int> m2;\\n        for(i=0 ; i<word1.length() ; i++)\\n        {\\n            m1[word1[i]]++;\\n        }\\n        for(i=0 ; i<word2.length() ; i++)\\n        {\\n            m2[word2[i]]++;\\n        }\\n        for(auto it:m1)\\n        {\\n            flag=0;\\n            for(auto k:m2)\\n            {\\n                if((it.first==k.first && abs(it.second-k.second)<=3))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0 && it.second>3)\\n            {\\n                return false;\\n            }\\n        }\\n        for(auto it:m2)\\n        {\\n            flag=0;\\n            for(auto k:m1)\\n            {\\n                if((it.first==k.first && abs(it.second-k.second)<=3))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0 && it.second>3)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/247ea278-9d46-4d59-9455-a717daffd45c_1685675988.5657146.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int i, j, flag=0;\\n        map<char, int> m1;\\n        map<char, int> m2;\\n        for(i=0 ; i<word1.length() ; i++)\\n        {\\n            m1[word1[i]]++;\\n        }\\n        for(i=0 ; i<word2.length() ; i++)\\n        {\\n            m2[word2[i]]++;\\n        }\\n        for(auto it:m1)\\n        {\\n            flag=0;\\n            for(auto k:m2)\\n            {\\n                if((it.first==k.first && abs(it.second-k.second)<=3))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0 && it.second>3)\\n            {\\n                return false;\\n            }\\n        }\\n        for(auto it:m2)\\n        {\\n            flag=0;\\n            for(auto k:m1)\\n            {\\n                if((it.first==k.first && abs(it.second-k.second)<=3))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0 && it.second>3)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582362,
                "title": "beginners-friendly-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    add word1 and word2 under frequency map\\n\\n    now check given condition using key of word1\\n    and then for map2 keys\\n\\n    read the code once you will get it!\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        HashMap<Character, Integer> map1= new HashMap<>();\\n        HashMap<Character, Integer> map2 =new HashMap<>();\\n        int n= word1.length();\\n        \\n        for(int i=0;i<n;i++){\\n            char c=word1.charAt(i);\\n            char d=word2.charAt(i);\\n            map1.put(c,map1.getOrDefault(c,0)+1);\\n            map2.put(d, map2.getOrDefault(d,0)+1);   \\n        }     \\n\\n        for(char k: map1.keySet()){\\n            if(!map2.containsKey(k)) map2.put(k,0);\\n            if(map1.get(k)-map2.get(k)>3) return false;\\n        }\\n\\n        for(char d: map2.keySet()){\\n            if(!map1.containsKey(d)) map1.put(d,0);\\n            if(map2.get(d)-map1.get(d)>3) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        HashMap<Character, Integer> map1= new HashMap<>();\\n        HashMap<Character, Integer> map2 =new HashMap<>();\\n        int n= word1.length();\\n        \\n        for(int i=0;i<n;i++){\\n            char c=word1.charAt(i);\\n            char d=word2.charAt(i);\\n            map1.put(c,map1.getOrDefault(c,0)+1);\\n            map2.put(d, map2.getOrDefault(d,0)+1);   \\n        }     \\n\\n        for(char k: map1.keySet()){\\n            if(!map2.containsKey(k)) map2.put(k,0);\\n            if(map1.get(k)-map2.get(k)>3) return false;\\n        }\\n\\n        for(char d: map2.keySet()){\\n            if(!map1.containsKey(d)) map1.put(d,0);\\n            if(map2.get(d)-map1.get(d)>3) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189515,
                "title": "c-easy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int a1[26]={0};\\n        int a2[26]={0};\\n        for(char x : word1){\\n            a1[x -\\'a\\']++;\\n        }\\n        for(char x: word2){\\n            a2[x - \\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(abs(a1[i]-a2[i])>3)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int a1[26]={0};\\n        int a2[26]={0};\\n        for(char x : word1){\\n            a1[x -\\'a\\']++;\\n        }\\n        for(char x: word2){\\n            a2[x - \\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(abs(a1[i]-a2[i])>3)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773792,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n        HashMap<Character,Integer> wordMap = new HashMap();\\n        \\n        for(char ch:word1.toCharArray()) {\\n            wordMap.put(ch,wordMap.getOrDefault(ch,0)+1);\\n        }\\n        \\n        for(char ch:word2.toCharArray()) {\\n            wordMap.put(ch,wordMap.getOrDefault(ch,0)-1);\\n        }\\n        \\n        for(Character ch:wordMap.keySet()) {\\n            if((Math.abs(wordMap.get(ch))>3)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n        HashMap<Character,Integer> wordMap = new HashMap();\\n        \\n        for(char ch:word1.toCharArray()) {\\n            wordMap.put(ch,wordMap.getOrDefault(ch,0)+1);\\n        }\\n        \\n        for(char ch:word2.toCharArray()) {\\n            wordMap.put(ch,wordMap.getOrDefault(ch,0)-1);\\n        }\\n        \\n        for(Character ch:wordMap.keySet()) {\\n            if((Math.abs(wordMap.get(ch))>3)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742130,
                "title": "java-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        //Use map to store the character and its frequency of word1 and word2\\n        Map<Character,Integer> map1 = new HashMap<>();\\n        Map<Character,Integer> map2 = new HashMap<>();\\n        \\n        for(char c:word1.toCharArray()){\\n            map1.put(c,map1.getOrDefault(c,0)+1);\\n        }\\n         for(char c:word2.toCharArray()){\\n            map2.put(c,map2.getOrDefault(c,0)+1);\\n        }\\n        \\n        int a = 0;\\n        int b = 0;\\n        //we have to check every character of word1 and word2\\n       //So concatinate the both strings\\n        //Now word1 contists of characters of word2 and itself\\n        word1 = word1+word2;\\n        \\n        for(int i = 0;i<word1.length();i++){\\n            char c = word1.charAt(i);\\n            //Get the freqency of character if there, else mark as 0\\n            if(map1.containsKey(c)){\\n                a = map1.get(c);\\n            }\\n            else{\\n                a = 0;\\n            }\\n            //Get the freqency of character if there, else mark as 0\\n            if(map2.containsKey(c)){\\n                b = map2.get(c);\\n            }\\n            else{\\n                b = 0;\\n            }\\n            //If the difference is greater than 3 return false\\n         if(Math.abs(a-b)>3) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n//Time Complexity O(n)\\n//Space Complexity O(n)\\n//Please Upvote If You Liked It!\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        //Use map to store the character and its frequency of word1 and word2\\n        Map<Character,Integer> map1 = new HashMap<>();\\n        Map<Character,Integer> map2 = new HashMap<>();\\n        \\n        for(char c:word1.toCharArray()){\\n            map1.put(c,map1.getOrDefault(c,0)+1);\\n        }\\n         for(char c:word2.toCharArray()){\\n            map2.put(c,map2.getOrDefault(c,0)+1);\\n        }\\n        \\n        int a = 0;\\n        int b = 0;\\n        //we have to check every character of word1 and word2\\n       //So concatinate the both strings\\n        //Now word1 contists of characters of word2 and itself\\n        word1 = word1+word2;\\n        \\n        for(int i = 0;i<word1.length();i++){\\n            char c = word1.charAt(i);\\n            //Get the freqency of character if there, else mark as 0\\n            if(map1.containsKey(c)){\\n                a = map1.get(c);\\n            }\\n            else{\\n                a = 0;\\n            }\\n            //Get the freqency of character if there, else mark as 0\\n            if(map2.containsKey(c)){\\n                b = map2.get(c);\\n            }\\n            else{\\n                b = 0;\\n            }\\n            //If the difference is greater than 3 return false\\n         if(Math.abs(a-b)>3) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n//Time Complexity O(n)\\n//Space Complexity O(n)\\n//Please Upvote If You Liked It!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678458,
                "title": "swift-solution-hashmap-set-90-faster",
                "content": "```\\nclass Solution {\\n    func checkAlmostEquivalent(_ word1: String, _ word2: String) -> Bool {\\n        var hash = [Character: Int]()\\n        word1.forEach { hash[$0, default: 0] += 1 }\\n        word2.forEach { hash[$0, default: 0] -= 1 }\\n        \\n        var values = Set(hash.values)\\n        var didPass = true\\n        \\n        for value in values {\\n            if value > 3 || value < -3 {\\n                didPass = false\\n                break\\n            }\\n        }\\n        \\n        return didPass\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func checkAlmostEquivalent(_ word1: String, _ word2: String) -> Bool {\\n        var hash = [Character: Int]()\\n        word1.forEach { hash[$0, default: 0] += 1 }\\n        word2.forEach { hash[$0, default: 0] -= 1 }\\n        \\n        var values = Set(hash.values)\\n        var didPass = true\\n        \\n        for value in values {\\n            if value > 3 || value < -3 {\\n                didPass = false\\n                break\\n            }\\n        }\\n        \\n        return didPass\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640688,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        counter1, counter2 = Counter(word1), Counter(word2)        \\n        counter1.subtract(counter2)\\n        for cnt in counter1.values():\\n            if abs(cnt) > 3: return False\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        counter1, counter2 = Counter(word1), Counter(word2)        \\n        counter1.subtract(counter2)\\n        for cnt in counter1.values():\\n            if abs(cnt) > 3: return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2477766,
                "title": "c-3-line-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char,int>sk;\\n        for(auto i:word1){sk[i]++;}\\n        for(auto i:word2){sk[i]--;}\\n        for(auto i:sk){if(i.second>3 || i.second<-3){return false;}}\\n        return true;\\n    }   \\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char,int>sk;\\n        for(auto i:word1){sk[i]++;}\\n        for(auto i:word2){sk[i]--;}\\n        for(auto i:sk){if(i.second>3 || i.second<-3){return false;}}\\n        return true;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388728,
                "title": "c-simple-and-clean-solution-only-for-beginners",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nbool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        map<char,int> p;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            p[word1[i]]++;\\n            p[word2[i]]--;\\n        }\\n        for(auto i:p)\\n        {\\n            if(i.second>3 || i.second<-3)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        map<char,int> p;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            p[word1[i]]++;\\n            p[word2[i]]--;\\n        }\\n        for(auto i:p)\\n        {\\n            if(i.second>3 || i.second<-3)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2327429,
                "title": "easy-javascript-solution",
                "content": "```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    let keys= [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\'];\\n   \\n    word1.toLowerCase();\\n    word2.toLowerCase();\\n    \\n    let arr1=new Array(26).fill(0);\\n    let arr2=new Array(26).fill(0);\\n\\n    \\n    for(let i=0; i< word1.length; i++){\\n        arr1[keys.indexOf(word1[i])]++;\\n    }\\n    \\n    for(let i=0; i< word2.length; i++){\\n        arr2[keys.indexOf(word2[i])]++;\\n    }\\n    \\n    for(let i=0; i< arr1.length; i++){\\n       if(Math.abs(arr1[i] - arr2[i]) > 3)  return false;\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    let keys= [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\'];\\n   \\n    word1.toLowerCase();\\n    word2.toLowerCase();\\n    \\n    let arr1=new Array(26).fill(0);\\n    let arr2=new Array(26).fill(0);\\n\\n    \\n    for(let i=0; i< word1.length; i++){\\n        arr1[keys.indexOf(word1[i])]++;\\n    }\\n    \\n    for(let i=0; i< word2.length; i++){\\n        arr2[keys.indexOf(word2[i])]++;\\n    }\\n    \\n    for(let i=0; i< arr1.length; i++){\\n       if(Math.abs(arr1[i] - arr2[i]) > 3)  return false;\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2309222,
                "title": "python-simple-hashmap",
                "content": "\\n    def checkAlmostEquivalent(self, word1, word2):\\n        dict1, dict2, ans = Counter(word1), Counter(word2), [0]*26\\n        \\n        for i in range(97,123):\\n            ans[i-97] = abs(dict1[chr(i)] - dict2[chr(i)])\\n            \\n        return all([i <= 3 for i in ans])\\n",
                "solutionTags": [],
                "code": "\\n    def checkAlmostEquivalent(self, word1, word2):\\n        dict1, dict2, ans = Counter(word1), Counter(word2), [0]*26\\n        \\n        for i in range(97,123):\\n            ans[i-97] = abs(dict1[chr(i)] - dict2[chr(i)])\\n            \\n        return all([i <= 3 for i in ans])\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2299454,
                "title": "simple-c-faster-solution-0ms-100-faster",
                "content": "```\\n        vector<int> v(26,0);\\n        for(int i=0;i<word1.length();i++) //as both strings of same length so run only one for loop\\n        {\\n            v[word1[i]-\\'a\\']++;\\n            v[word2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(abs(v[i])>3)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        vector<int> v(26,0);\\n        for(int i=0;i<word1.length();i++) //as both strings of same length so run only one for loop\\n        {\\n            v[word1[i]-\\'a\\']++;\\n            v[word2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(abs(v[i])>3)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236616,
                "title": "c-easy-using-set-and-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_set<int> st;\\n        unordered_map<char,int> mp1, mp2;\\n        for(auto i:word1){\\n            mp1[i]++;\\n            st.insert(i);\\n        }\\n        for(auto i:word2){\\n            mp2[i]++;\\n            st.insert(i);\\n        }\\n        bool flag=true;\\n        for(auto i:st){\\n            int diff = abs(mp1[i]-mp2[i]);\\n            if(diff>3){\\n                flag=false;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_set<int> st;\\n        unordered_map<char,int> mp1, mp2;\\n        for(auto i:word1){\\n            mp1[i]++;\\n            st.insert(i);\\n        }\\n        for(auto i:word2){\\n            mp2[i]++;\\n            st.insert(i);\\n        }\\n        bool flag=true;\\n        for(auto i:st){\\n            int diff = abs(mp1[i]-mp2[i]);\\n            if(diff>3){\\n                flag=false;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143959,
                "title": "java-solution-frequency-count",
                "content": "class Solution {\\n\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int w1[]=new int[26];\\n        int w2[]=new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            int x=word1.charAt(i)-\\'a\\';\\n            w1[x]++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            int x=word2.charAt(i)-\\'a\\';\\n            w2[x]++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(Math.abs(w1[i]-w2[i])>3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int w1[]=new int[26];\\n        int w2[]=new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            int x=word1.charAt(i)-\\'a\\';\\n            w1[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2136616,
                "title": "100-fastest-c-solution",
                "content": "Here we count the difference between the frequencies of each letter in both the strings,\\n-  if the difference in frequency of any one letter is more than 3 we return \\'false\\'\\n-  else we return \\'true\\'.  \\n---\\n            Runtime: \\'0 ms\\', faster than 100.00%\\n       Memory Usage: \\'6.3 MB\\',  less than 81.93%\\nCODE:\\n\\n                \\'Upvote if you like the Solution / Exlanation\\n\\n```\\nbool checkAlmostEquivalent(string w1, string w2) \\n{\\n    vector<int> v(26,0);\\n    for(auto i:w1){v[i-\\'a\\']++;}\\n    for(auto i:w2){v[i-\\'a\\']--;}\\n    for(int i=0;i<26;i++){if(abs(v[i])>3){return false;}}\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkAlmostEquivalent(string w1, string w2) \\n{\\n    vector<int> v(26,0);\\n    for(auto i:w1){v[i-\\'a\\']++;}\\n    for(auto i:w2){v[i-\\'a\\']--;}\\n    for(int i=0;i<26;i++){if(abs(v[i])>3){return false;}}\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126459,
                "title": "easy-java-solution-beginner-friendly-o-n-time-w-o-map",
                "content": "***Please Upvote if You Liked The Solution***\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int []arr=new int [26];\\n        for (int i=0;i<word1.length();i++)\\n        {\\n            arr[word1.charAt(i)-\\'a\\']++;\\n            arr[word2.charAt(i)-\\'a\\']--;\\n        }\\n        for (int i:arr){if (Math.abs(i)>3){return false;}}\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int []arr=new int [26];\\n        for (int i=0;i<word1.length();i++)\\n        {\\n            arr[word1.charAt(i)-\\'a\\']++;\\n            arr[word2.charAt(i)-\\'a\\']--;\\n        }\\n        for (int i:arr){if (Math.abs(i)>3){return false;}}\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089372,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n       unordered_map<char,int> w1,w2;\\n        for(char c: word1)\\n            w1[c]++;\\n        for(char c: word2)\\n            w2[c]++;\\n        int f=0;\\n        for(auto t: w1)\\n        {\\n            if(w2.find(t.first)!=w2.end())\\n            {\\n                if(abs(w2[t.first]-w1[t.first])>3)\\n                {\\n                    f=1;break;\\n                }\\n            }\\n                else\\n                {\\n                    if(w1[t.first]>3)\\n                    {\\n                        f=1;break;\\n                    }\\n                }\\n            \\n        }\\n        if(f==1)\\n            return false;\\n        for(auto t: w2)\\n        {\\n            if(w1.find(t.first)!=w1.end())\\n            {\\n                if(abs(w2[t.first]-w1[t.first])>3)\\n                {\\n                    f=1;break;\\n                }\\n            }\\n                else\\n                {\\n                    if(w2[t.first]>3)\\n                    {\\n                        f=1;break;\\n                    }\\n                }\\n            \\n        }\\n        if(f==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n       unordered_map<char,int> w1,w2;\\n        for(char c: word1)\\n            w1[c]++;\\n        for(char c: word2)\\n            w2[c]++;\\n        int f=0;\\n        for(auto t: w1)\\n        {\\n            if(w2.find(t.first)!=w2.end())\\n            {\\n                if(abs(w2[t.first]-w1[t.first])>3)\\n                {\\n                    f=1;break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2085243,
                "title": "simple-python-code",
                "content": "class Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        string = set(word1+word2)\\n        diff = []\\n        for c in string :\\n            diff.append(abs(word1.count(c) - word2.count(c)))    \\n        if max(diff) > 3:\\n            return False\\n        else:\\n            return True",
                "solutionTags": [],
                "code": "class Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        string = set(word1+word2)\\n        diff = []\\n        for c in string :\\n            diff.append(abs(word1.count(c) - word2.count(c)))    \\n        if max(diff) > 3:\\n            return False\\n        else:\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 2052080,
                "title": "java-1ms-solution-easy-understanding-100",
                "content": "count1 and count2 are array storing the no of alphabets \\nexample if  the string \"aabeesd\" have 2 a\\'s,1 b ,1 d,2 e\\'s ans 1 s.\\n\\n\\'\\'\\'class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] count1=new int[26];\\n       int[] count2=new int[26];\\n        int count=0;\\n        for(int i=0;i<word1.length();i++){\\n                count1[word1.charAt(i)-\\'a\\']++;\\n            count2[word2.charAt(i)-\\'a\\']++;\\n               } \\n\\t\\t\\t   for(int i = 0; i < count1.length; i++){\\n          count=count1[i]-count2[i];\\n           if(Math.abs(count) > 3) \\n                return false;\\n        }\\n        return true;\\n    }\\n}\\'\\'\\'\\n\\nplease upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] count1=new int[26];\\n       int[] count2=new int[26];\\n        int count=0;\\n        for(int i=0;i<word1.length();i++){\\n                count1[word1.charAt(i)-\\'a\\']++;\\n            count2[word2.charAt(i)-\\'a\\']++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2034922,
                "title": "1ms-95-faster-simple-java-solution",
                "content": "java code is:\\n\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n      int dp[]=new int[26];\\n        for(char c : word1.toCharArray())dp[c-\\'a\\']++;\\n        for(char c : word2.toCharArray())dp[c-\\'a\\']--;\\n        for(int a : dp)if(a<-3||a>3)return false;\\n        return true;\\n        \\n    }\\n}\\n```\\n# \\n# **Time : O(n) linear\\n# Space: O(1) constant space\\n# \\n# Please upvote if this is helpful**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n      int dp[]=new int[26];\\n        for(char c : word1.toCharArray())dp[c-\\'a\\']++;\\n        for(char c : word2.toCharArray())dp[c-\\'a\\']--;\\n        for(int a : dp)if(a<-3||a>3)return false;\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937041,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def checkAlmostEquivalent(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: bool\\n        \"\"\"\\n        a=[0]*26\\n        for i in range(len(word1)):\\n            a[ord(word1[i])-ord(\\'a\\')]+=1\\n            a[ord(word2[i])-ord(\\'a\\')]-=1\\n        for i in range(26):\\n            if(abs(a[i])>3):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkAlmostEquivalent(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: bool\\n        \"\"\"\\n        a=[0]*26\\n        for i in range(len(word1)):\\n            a[ord(word1[i])-ord(\\'a\\')]+=1\\n            a[ord(word2[i])-ord(\\'a\\')]-=1\\n        for i in range(26):\\n            if(abs(a[i])>3):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931758,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character, Integer> freqMap1 = new HashMap<>();\\n        Map<Character, Integer> freqMap2 = new HashMap<>();\\n        for(char letter: word1.toCharArray()) {\\n            freqMap1.put(letter, freqMap1.getOrDefault(letter, 0) + 1);\\n        }\\n        for(char letter: word2.toCharArray()) {\\n            freqMap2.put(letter, freqMap2.getOrDefault(letter, 0) + 1);\\n        }\\n        for(Map.Entry<Character, Integer> entry: freqMap1.entrySet()) {\\n            if(Math.abs(freqMap2.getOrDefault(entry.getKey(), 0)-entry.getValue()) > 3) {\\n                return false;\\n            }\\n        }\\n        for(Map.Entry<Character, Integer> entry: freqMap2.entrySet()) {\\n            if(Math.abs(freqMap1.getOrDefault(entry.getKey(), 0)-entry.getValue()) > 3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character, Integer> freqMap1 = new HashMap<>();\\n        Map<Character, Integer> freqMap2 = new HashMap<>();\\n        for(char letter: word1.toCharArray()) {\\n            freqMap1.put(letter, freqMap1.getOrDefault(letter, 0) + 1);\\n        }\\n        for(char letter: word2.toCharArray()) {\\n            freqMap2.put(letter, freqMap2.getOrDefault(letter, 0) + 1);\\n        }\\n        for(Map.Entry<Character, Integer> entry: freqMap1.entrySet()) {\\n            if(Math.abs(freqMap2.getOrDefault(entry.getKey(), 0)-entry.getValue()) > 3) {\\n                return false;\\n            }\\n        }\\n        for(Map.Entry<Character, Integer> entry: freqMap2.entrySet()) {\\n            if(Math.abs(freqMap1.getOrDefault(entry.getKey(), 0)-entry.getValue()) > 3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931528,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            a[word1.charAt(i)-97]++;\\n        }\\n        for(int i=0;i<word2.length();i++)\\n        {\\n            b[word2.charAt(i)-97]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(Math.abs(a[i]-b[i])>3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            a[word1.charAt(i)-97]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1903804,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> v(26,0);\\n        for(auto it:word1){\\n            v[it-\\'a\\']++;\\n        }\\n        for(auto it:word2){\\n            v[it-\\'a\\']--;\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            if(v[i]>3 || v[i]<-3)\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> v(26,0);\\n        for(auto it:word1){\\n            v[it-\\'a\\']++;\\n        }\\n        for(auto it:word2){\\n            v[it-\\'a\\']--;\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            if(v[i]>3 || v[i]<-3)\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855118,
                "title": "c-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<char,int> m;\\n        for(auto& i : word1){\\n            m[i]++;\\n        }\\n        for(auto& i : word2){\\n            m[i]--;\\n        }\\n        for(auto& i :m){\\n            if(abs(i.second) >3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<char,int> m;\\n        for(auto& i : word1){\\n            m[i]++;\\n        }\\n        for(auto& i : word2){\\n            m[i]--;\\n        }\\n        for(auto& i :m){\\n            if(abs(i.second) >3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847634,
                "title": "java-beat-100",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(final String word1, final String word2) {\\n        final int[] count = new int[\\'z\\' - \\'a\\' + 1];\\n        for (int i=0; i<word1.length(); i++) {\\n            count[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int i=0; i<word2.length(); i++) {\\n            count[word2.charAt(i) - \\'a\\']--;\\n        }\\n        int max = 0;\\n        for (final int element: count) {\\n            max = Math.max(max, Math.abs(element));\\n        }\\n        return max <= 3;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(final String word1, final String word2) {\\n        final int[] count = new int[\\'z\\' - \\'a\\' + 1];\\n        for (int i=0; i<word1.length(); i++) {\\n            count[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int i=0; i<word2.length(); i++) {\\n            count[word2.charAt(i) - \\'a\\']--;\\n        }\\n        int max = 0;\\n        for (final int element: count) {\\n            max = Math.max(max, Math.abs(element));\\n        }\\n        return max <= 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825614,
                "title": "c-0ms-using-hashing-easy-to-understand",
                "content": "**Please do upvote if you liked my code :)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        int hash1[26] = {0}, hash2[26] = {0};\\n        \\n        for(char ch: word1)\\n            ++hash1[ch-\\'a\\'];\\n        for(char ch: word2)\\n            ++hash2[ch-\\'a\\'];\\n        \\n        for(int i=0; i<26; i++)\\n            if(abs(hash1[i]-hash2[i]) > 3)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        int hash1[26] = {0}, hash2[26] = {0};\\n        \\n        for(char ch: word1)\\n            ++hash1[ch-\\'a\\'];\\n        for(char ch: word2)\\n            ++hash2[ch-\\'a\\'];\\n        \\n        for(int i=0; i<26; i++)\\n            if(abs(hash1[i]-hash2[i]) > 3)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792190,
                "title": "java-solution-1-ms-faster-than-80-90",
                "content": "\\tpublic boolean checkAlmostEquivalent(String word1, String word2) {\\n\\t\\tint [] count = new int[26];\\n\\t\\tint n = word1.length();\\n\\n\\t\\tfor(int i =0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tchar a = word1.charAt(i);\\n\\t\\t\\tchar b = word2.charAt(i);\\n\\t\\t\\tcount[a-\\'a\\']++;\\n\\t\\t\\tcount[b-\\'a\\']--;\\n\\t\\t}\\n\\t\\tfor(int i =0; i<26; i++)\\n\\t\\t\\tif(Math.abs(count[i])>3)\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic boolean checkAlmostEquivalent(String word1, String word2) {\\n\\t\\tint [] count = new int[26];\\n\\t\\tint n = word1.length();\\n\\n\\t\\tfor(int i =0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tchar a = word1.charAt(i);\\n\\t\\t\\tchar b = word2.charAt(i);\\n\\t\\t\\tcount[a-\\'a\\']++;\\n\\t\\t\\tcount[b-\\'a\\']--;\\n\\t\\t}\\n\\t\\tfor(int i =0; i<26; i++)\\n\\t\\t\\tif(Math.abs(count[i])>3)\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1784029,
                "title": "java-hashmap-explained-each-section",
                "content": "```\\npublic boolean checkAlmostEquivalent(String word1, String word2) {\\n        //creating two maps//\\n        Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        \\n        //putting the keys and values to both maps//\\n        for(int i=0;i<word1.length();i++){\\n            char ch=word1.charAt(i);\\n            int count=map1.containsKey(ch)?map1.get(ch):0;\\n            map1.put(ch,count+1);\\n        }\\n         for(int i=0;i<word2.length();i++){\\n            char ch=word2.charAt(i);\\n            int count=map2.containsKey(ch)?map2.get(ch):0;\\n            map2.put(ch,count+1);\\n        }\\n        //putting the freq of common key and also the key which are not common into list//\\n        List<Integer> list=new ArrayList<>();\\n        for(Character c:map1.keySet()){\\n            if(map2.containsKey(c)){\\n                int freq=Math.abs(map1.get(c)-map2.get(c));\\n                list.add(freq);\\n            }else{\\n                list.add(map1.get(c));\\n            }\\n        }\\n        //putting the remaining values of key of map2 into list// \\n        for(Character c:map2.keySet()){\\n            if(!map1.containsKey(c)){\\n                list.add(map2.get(c));\\n            }\\n        }\\n        Collections.sort(list);\\n        if(list.get(list.size()-1)<=3){\\n            return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkAlmostEquivalent(String word1, String word2) {\\n        //creating two maps//\\n        Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        \\n        //putting the keys and values to both maps//\\n        for(int i=0;i<word1.length();i++){\\n            char ch=word1.charAt(i);\\n            int count=map1.containsKey(ch)?map1.get(ch):0;\\n            map1.put(ch,count+1);\\n        }\\n         for(int i=0;i<word2.length();i++){\\n            char ch=word2.charAt(i);\\n            int count=map2.containsKey(ch)?map2.get(ch):0;\\n            map2.put(ch,count+1);\\n        }\\n        //putting the freq of common key and also the key which are not common into list//\\n        List<Integer> list=new ArrayList<>();\\n        for(Character c:map1.keySet()){\\n            if(map2.containsKey(c)){\\n                int freq=Math.abs(map1.get(c)-map2.get(c));\\n                list.add(freq);\\n            }else{\\n                list.add(map1.get(c));\\n            }\\n        }\\n        //putting the remaining values of key of map2 into list// \\n        for(Character c:map2.keySet()){\\n            if(!map1.containsKey(c)){\\n                list.add(map2.get(c));\\n            }\\n        }\\n        Collections.sort(list);\\n        if(list.get(list.size()-1)<=3){\\n            return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1740611,
                "title": "c-vector-int-a-26-based-solution",
                "content": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int>v1(26,0);\\n        vector<int>v2(26,0);\\n        int n=word1.length();\\n        int m=word2.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            v1[word1[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            v2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            int d=abs(v1[i]-v2[i]);\\n            if(d>3)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int>v1(26,0);\\n        vector<int>v2(26,0);\\n        int n=word1.length();\\n        int m=word2.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            v1[word1[i]-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1728999,
                "title": "all-approach-code",
                "content": "**1st Apporach** **C++ Code**\\n\\n**Brute Force**\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        // Brute Force\\n        // T.C O(26* (n + m))\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n            int freq1 = 0;\\n            int freq2 = 0;\\n            for(auto &i: word1){\\n                if(i == ch) freq1++;\\n            }\\n            for(auto &i: word2){\\n                if(i == ch) freq2++;\\n            }\\n            \\n            if(abs(freq1 - freq2) > 3) return false;       \\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**2nd Approach Java Code**\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        // Time Complexity =>  O(26 + N + M)\\n        int freq1[] = new int[26];\\n        int freq2[] = new int[26];\\n        // a - > 0\\n        // b - > 1\\n        // c - > 2\\n        // z - > 25\\n        \\n      \\n        for(int i = 0; i < word1.length(); i++){\\n            // to find the ascii value \\n            freq1[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < word2.length(); i++){\\n            freq2[word2.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(Math.abs(freq1[i] - freq2[i]) > 3)    return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**3rd Approach  Java Code**\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        // Time Complexity =>  O(26 + N + M)\\n        int freq1[] = new int[26];\\n        // a - > 0\\n        // b - > 1\\n        // c - > 2\\n        // z - > 25\\n        \\n      \\n        for(int i = 0; i < word1.length(); i++){\\n            // to find the ascii value \\n            freq1[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < word2.length(); i++){\\n            freq1[word2.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(Math.abs(freq1[i]) > 3)    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        // Brute Force\\n        // T.C O(26* (n + m))\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n            int freq1 = 0;\\n            int freq2 = 0;\\n            for(auto &i: word1){\\n                if(i == ch) freq1++;\\n            }\\n            for(auto &i: word2){\\n                if(i == ch) freq2++;\\n            }\\n            \\n            if(abs(freq1 - freq2) > 3) return false;       \\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        // Time Complexity =>  O(26 + N + M)\\n        int freq1[] = new int[26];\\n        int freq2[] = new int[26];\\n        // a - > 0\\n        // b - > 1\\n        // c - > 2\\n        // z - > 25\\n        \\n      \\n        for(int i = 0; i < word1.length(); i++){\\n            // to find the ascii value \\n            freq1[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < word2.length(); i++){\\n            freq2[word2.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(Math.abs(freq1[i] - freq2[i]) > 3)    return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        // Time Complexity =>  O(26 + N + M)\\n        int freq1[] = new int[26];\\n        // a - > 0\\n        // b - > 1\\n        // c - > 2\\n        // z - > 25\\n        \\n      \\n        for(int i = 0; i < word1.length(); i++){\\n            // to find the ascii value \\n            freq1[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < word2.length(); i++){\\n            freq1[word2.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(Math.abs(freq1[i]) > 3)    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701916,
                "title": "simple-and-fast-solution-in-cpp-with-comments-0-ms",
                "content": "1. Intialize both vectors with zeroes, these 2 vectors are meant to store the frequencies of the character in both the strings.\\n2. Traverse both the strings and update both of the frequency vectors.\\n3.  Traverse the vector again and check if for any two corresponding index the absolute difference is more than 3 i.e, if so then false otherwise true.\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string w1, string w2) {\\n        vector<int> m(26, 0);\\n        vector<int> n (26, 0);\\n        for(int i = 0;i<w1.length();i++) {\\n            m[int(w1[i]) - 97]++;\\n            n[int(w2[i]) - 97]++;\\n        }\\n        for(int i = 0;i<26;i++) {\\n            if(abs(m[i] - n[i]) > 3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string w1, string w2) {\\n        vector<int> m(26, 0);\\n        vector<int> n (26, 0);\\n        for(int i = 0;i<w1.length();i++) {\\n            m[int(w1[i]) - 97]++;\\n            n[int(w2[i]) - 97]++;\\n        }\\n        for(int i = 0;i<26;i++) {\\n            if(abs(m[i] - n[i]) > 3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696234,
                "title": "c-cpp-100-faster-99-32-space-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int a[26] = {0};\\n        for(char c:word1){\\n            a[c - \\'a\\']++;\\n        }\\n        for(char c:word2){\\n            a[c - \\'a\\']--;\\n        }\\n        for(int x:a){\\n            if(abs(x) > 3) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/a1ec3372-1d9c-420f-a5a1-33b04c503e7f_1642398008.0000596.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int a[26] = {0};\\n        for(char c:word1){\\n            a[c - \\'a\\']++;\\n        }\\n        for(char c:word2){\\n            a[c - \\'a\\']--;\\n        }\\n        for(int x:a){\\n            if(abs(x) > 3) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626791,
                "title": "kotlin-map-solution",
                "content": "```\\nclass Solution {\\n    fun checkAlmostEquivalent(word1: String, word2: String): Boolean {\\n        val frequencyMap = mutableMapOf<Char,Int>()\\n        \\n        word1.forEachIndexed { index, char1 ->\\n            val char2 = word2[index]\\n            \\n            frequencyMap[char1] = frequencyMap.getOrDefault(char1, 0) + 1\\n            frequencyMap[char2] = frequencyMap.getOrDefault(char2, 0) - 1\\n        }\\n        \\n        return frequencyMap.values.all { Math.abs(it) <= 3 }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun checkAlmostEquivalent(word1: String, word2: String): Boolean {\\n        val frequencyMap = mutableMapOf<Char,Int>()\\n        \\n        word1.forEachIndexed { index, char1 ->\\n            val char2 = word2[index]\\n            \\n            frequencyMap[char1] = frequencyMap.getOrDefault(char1, 0) + 1\\n            frequencyMap[char2] = frequencyMap.getOrDefault(char2, 0) - 1\\n        }\\n        \\n        return frequencyMap.values.all { Math.abs(it) <= 3 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611168,
                "title": "c-easy-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string s, string t) {\\n        unordered_map<int,int>mp;\\n        for (char ch : s) \\n            mp[ch - \\'a\\']++;\\n        for (char ch : t) \\n            mp[ch - \\'a\\']--;\\n        for (int i = 0; i < 26; ++i) {\\n            if (abs(mp[i]) > 3) \\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string s, string t) {\\n        unordered_map<int,int>mp;\\n        for (char ch : s) \\n            mp[ch - \\'a\\']++;\\n        for (char ch : t) \\n            mp[ch - \\'a\\']--;\\n        for (int i = 0; i < 26; ++i) {\\n            if (abs(mp[i]) > 3) \\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1607581,
                "title": "faster-than-100-c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int count[26]={0};\\n        for(int i=0;i<word1.length();i++) {\\n            count[word1[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++) {\\n            count[word2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(abs(count[i])>3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int count[26]={0};\\n        for(int i=0;i<word1.length();i++) {\\n            count[word1[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++) {\\n            count[word2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(abs(count[i])>3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596329,
                "title": "simple-and-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n       int[] freqArray = new int[26];\\n       char[] letters1 = word1.toCharArray(); \\n       char[] letters2 = word2.toCharArray();\\n        \\n        for(int i=0;i<letters1.length;i++){\\n            freqArray[letters1[i]-97] ++;\\n        }\\n        \\n        for(int i=0;i<letters2.length;i++){\\n            freqArray[letters2[i]-97] --;\\n        }\\n        \\n        for(int i=0 ;i<26 ;i++){\\n            if(Math.abs(freqArray[i])>3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n       int[] freqArray = new int[26];\\n       char[] letters1 = word1.toCharArray(); \\n       char[] letters2 = word2.toCharArray();\\n        \\n        for(int i=0;i<letters1.length;i++){\\n            freqArray[letters1[i]-97] ++;\\n        }\\n        \\n        for(int i=0;i<letters2.length;i++){\\n            freqArray[letters2[i]-97] --;\\n        }\\n        \\n        for(int i=0 ;i<26 ;i++){\\n            if(Math.abs(freqArray[i])>3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589382,
                "title": "python-solution",
                "content": "\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        \\n        words = set(word1+word2) \\n        for ch in words:\\n            if abs(word1.count(ch) - word2.count(ch)) > 3:\\n                return False      \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        \\n        words = set(word1+word2) \\n        for ch in words:\\n            if abs(word1.count(ch) - word2.count(ch)) > 3:\\n                return False      \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586981,
                "title": "c-frequency-map-solutions-compared-and-explained-100-time-90-space",
                "content": "Pretty basic problems, so we will start with the easier approach first:\\n* we will create `f1` and `f2` as arrays of `26` (all our domain range) elements, initially with all the cells set to `0`;\\n* running through `w1` and `w2`, we will populate each matching array, with `\\'a\\'` increasing the counter for the first slot (index `0`), `\\'b\\'` for the second (index `1`) and so on;\\n* compare each cell and `return` `false` if the difference between them is above `3`, in absolute value;\\n* `return` `true` if we exit the last loop.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string w1, string w2) {\\n        // support variables\\n        int f1[26] = {}, f2[26] = {};\\n        // collecting frequencies\\n        for (char c: w1) f1[c - \\'a\\']++;\\n        for (char c: w2) f2[c - \\'a\\']++;\\n        // comparing frequencies\\n        for (int i = 0; i < 26; i++) if (abs(f1[i] - f2[i]) > 3) return false;\\n        return true;\\n    }\\n};\\n```\\n\\nBut, wait a moment! We do not need two arrays, we can just have one (`f`) and:\\n* set all the cells to be `4`;\\n* add the frequency for each cell of the matching a character from `w1`;\\n* reduce the frequency of the matching character from `w2` and, in case we reach a `0`, just `return` `false` (the mismatch would be above `3`;\\n* parse again `f` and `return` `false` for any value above `7` (specular to the previous condition);\\n* `return` `true` if we exit the last loop.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string w1, string w2) {\\n        // support variables\\n        int f[26];\\n        // preparing f\\n        fill(f, f + 26, 4);\\n        // collecting frequencies\\n        for (char c: w1) f[c - \\'a\\']++;\\n        for (char c: w2) {\\n            if (!--f[c - \\'a\\']) return false;\\n        }\\n        // comparing frequencies\\n        for (int i = 0; i < 26; i++) if (f[i] > 7) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string w1, string w2) {\\n        // support variables\\n        int f1[26] = {}, f2[26] = {};\\n        // collecting frequencies\\n        for (char c: w1) f1[c - \\'a\\']++;\\n        for (char c: w2) f2[c - \\'a\\']++;\\n        // comparing frequencies\\n        for (int i = 0; i < 26; i++) if (abs(f1[i] - f2[i]) > 3) return false;\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string w1, string w2) {\\n        // support variables\\n        int f[26];\\n        // preparing f\\n        fill(f, f + 26, 4);\\n        // collecting frequencies\\n        for (char c: w1) f[c - \\'a\\']++;\\n        for (char c: w2) {\\n            if (!--f[c - \\'a\\']) return false;\\n        }\\n        // comparing frequencies\\n        for (int i = 0; i < 26; i++) if (f[i] > 7) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584206,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        if(word1.isEmpty() && word2.isEmpty())\\n            return true;\\n        \\n         if(word1.isEmpty() || word2.isEmpty())\\n            return false;\\n        \\n        int [] vals = new int[26];\\n        for(char ch : word1.toCharArray()) {\\n            vals[ch - \\'a\\']++;\\n        }\\n        for(char ch : word2.toCharArray()) {\\n            vals[ch - \\'a\\']--;\\n        }\\n        \\n        System.out.println(Arrays.toString(vals));\\n        for(int num: vals) {\\n            if(Math.abs(num) > 3)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        if(word1.isEmpty() && word2.isEmpty())\\n            return true;\\n        \\n         if(word1.isEmpty() || word2.isEmpty())\\n            return false;\\n        \\n        int [] vals = new int[26];\\n        for(char ch : word1.toCharArray()) {\\n            vals[ch - \\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1579315,
                "title": "java-0ms-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] letters = new int[26];\\n        \\n        int length = word1.length();\\n        for (int i = 0 ; i < length ; i++) {\\n            letters[word1.charAt(i) - \\'a\\']++;\\n            letters[word2.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for (int letter : letters) {\\n            if (letter > 3 || letter < -3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] letters = new int[26];\\n        \\n        int length = word1.length();\\n        for (int i = 0 ; i < length ; i++) {\\n            letters[word1.charAt(i) - \\'a\\']++;\\n            letters[word2.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for (int letter : letters) {\\n            if (letter > 3 || letter < -3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578969,
                "title": "c-simple-solution-using-hashmap-time-comlexity-0-max-string1-string2",
                "content": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<char, int> m1;//word1\\n        unordered_map<char, int> m2;//word2\\n        \\n        for(int i=0;i<word1.size();i++) m1[word1[i]]++;\\n        for(int i=0;i<word2.size();i++) m2[word2[i]]++;\\n        \\n        string s =\"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        for(int i=0;i<26;i++){\\n            if(abs(m1[s[i]]-m2[s[i]])>3) return false;\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<char, int> m1;//word1\\n        unordered_map<char, int> m2;//word2\\n        \\n        for(int i=0;i<word1.size();i++) m1[word1[i]]++;\\n        for(int i=0;i<word2.size();i++) m2[word2[i]]++;\\n        \\n        string s =\"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        for(int i=0;i<26;i++){\\n            if(abs(m1[s[i]]-m2[s[i]])>3) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1578147,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn check_almost_equivalent(word1: String, word2: String) -> bool {\\n        let get_count = |s: &str| -> [i32; 26] {\\n            let mut count = [0; 26];\\n            s.as_bytes()\\n                .iter()\\n                .for_each(|&b| count[(b - b\\'a\\') as usize] += 1);\\n            count\\n        };\\n        let count_1 = get_count(&word1);\\n        let count_2 = get_count(&word2);\\n\\n        count_1\\n            .iter()\\n            .zip(count_2.iter())\\n            .all(|(n1, n2)| (n1 - n2).abs() <= 3)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_almost_equivalent(word1: String, word2: String) -> bool {\\n        let get_count = |s: &str| -> [i32; 26] {\\n            let mut count = [0; 26];\\n            s.as_bytes()\\n                .iter()\\n                .for_each(|&b| count[(b - b\\'a\\') as usize] += 1);\\n            count\\n        };\\n        let count_1 = get_count(&word1);\\n        let count_2 = get_count(&word2);\\n\\n        count_1\\n            .iter()\\n            .zip(count_2.iter())\\n            .all(|(n1, n2)| (n1 - n2).abs() <= 3)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576216,
                "title": "python-java-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n\\t\\t\\tcnt1 = {}\\n\\t\\t\\tcnt2 = {}\\n\\t\\t\\tfor i in range(len(word1)):\\n\\t\\t\\t\\tc1 = word1[i]\\n\\t\\t\\t\\tc2 = word2[i]\\n\\t\\t\\t\\tif c1 not in cnt1:\\n\\t\\t\\t\\t\\tcnt1[c1] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcnt1[c1] += 1\\n\\t\\t\\t\\tif c2 not in cnt2:\\n\\t\\t\\t\\t\\tcnt2[c2] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcnt2[c2] += 1\\n\\t\\t\\t\\tif c1 not in cnt2:\\n\\t\\t\\t\\t\\tcnt2[c1] = 0\\n\\t\\t\\t\\tif c2 not in cnt1:\\n\\t\\t\\t\\t\\tcnt1[c2] = 0\\n\\t\\t\\tfor c in cnt1:\\n\\t\\t\\t\\tif abs(cnt1[c] - cnt2[c]) > 3:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean checkAlmostEquivalent(String word1, String word2) {\\n\\t\\t\\tMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\t\\tMap<Character, Integer> map2 = new HashMap<>();\\n\\t\\t\\tfor (int i = 0; i < word1.length(); i ++) {\\n\\t\\t\\t\\tchar c1 = word1.charAt(i);\\n\\t\\t\\t\\tchar c2 = word2.charAt(i);\\n\\t\\t\\t\\tmap1.put(c1, map1.getOrDefault(c1, 0) + 1);\\n\\t\\t\\t\\tmap2.put(c2, map2.getOrDefault(c2, 0) + 1);\\n\\t\\t\\t\\tif (!map2.containsKey(c1)) {\\n\\t\\t\\t\\t\\tmap2.put(c1, 0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!map1.containsKey(c2)) {\\n\\t\\t\\t\\t\\tmap1.put(c2, 0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: map1.keySet()) {\\n\\t\\t\\t\\tif (Math.abs(map1.get(c) - map2.get(c)) > 3) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n\\t\\t\\tcnt1 = {}",
                "codeTag": "Java"
            },
            {
                "id": 1576138,
                "title": "c-count-frequency",
                "content": "In first traversal of string a, add frequency of letters.\\nThen, traverse string b, and reduce the frequency of each letter from the vector, if any element in resultant vector is greater than 3, then return false, else true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string a, string b) {\\n        vector<int> res(26,0);\\n        for (auto& c : a){\\n            int x = c - 97;\\n            res[x]++;\\n        }\\n        for (auto& d : b){\\n            int y = d - 97;\\n            res[y]--;\\n        }\\n        for (auto &e:res) {\\n            if (abs(e) > 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string a, string b) {\\n        vector<int> res(26,0);\\n        for (auto& c : a){\\n            int x = c - 97;\\n            res[x]++;\\n        }\\n        for (auto& d : b){\\n            int y = d - 97;\\n            res[y]--;\\n        }\\n        for (auto &e:res) {\\n            if (abs(e) > 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576008,
                "title": "vey-easy-hashing-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map <char,int> mp1;\\n        unordered_map <char,int> mp2;\\n        \\n        for(char i:word1){\\n            mp1[i]++;\\n        }\\n        \\n        for(char i:word2){\\n            mp2[i]++;\\n        }\\n        \\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if(abs(mp1[ch]-mp2[ch])>3) return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map <char,int> mp1;\\n        unordered_map <char,int> mp2;\\n        \\n        for(char i:word1){\\n            mp1[i]++;\\n        }\\n        \\n        for(char i:word2){\\n            mp2[i]++;\\n        }\\n        \\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if(abs(mp1[ch]-mp2[ch])>3) return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575968,
                "title": "c-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        int freq1[26] = {}, freq2[26] = {};\\n        for(int i=0; i<word2.length(); i++)\\n        {\\n            freq1[word1[i]-\\'a\\']++;\\n            freq2[word2[i]-\\'a\\']++;\\n        }        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(abs(freq2[i]-freq1[i])>3) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) \\n    {\\n        int freq1[26] = {}, freq2[26] = {};\\n        for(int i=0; i<word2.length(); i++)\\n        {\\n            freq1[word1[i]-\\'a\\']++;\\n            freq2[word2[i]-\\'a\\']++;\\n        }        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(abs(freq2[i]-freq1[i])>3) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575952,
                "title": "java-1ms-two-ways-easy-to-understand",
                "content": "Edit: A better non hash map approach. Storing the frequency in a single array. For the first string, we increase frequency by 1 and for the second we decrease it by 1. If the absolute frequency (i.e. > 3 or  < -3) is  greater than 3, then false is returned.\\n```\\nclass Solution\\n{\\n    public boolean checkAlmostEquivalent(String word1, String word2)\\n    {\\n        int[] f1 = new int[26];\\n        for(char ch : word1.toCharArray())\\n            f1[ch - \\'a\\']++;\\n        for(char ch : word2.toCharArray())\\n            f1[ch - \\'a\\']--;\\n        \\n        for(int i = 0; i < 26; i++)\\n            if(Math.abs(f1[i]) > 3)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```\\nTwo maps contain frequency of the two strings. Iterated over both the maps\\' keyset as some characters may be present in one and absent in another.\\n\\n```\\nclass Solution\\n{\\n    public boolean checkAlmostEquivalent(String word1, String word2)\\n    {\\n        Map<Character, Integer> map1 = new TreeMap<>();\\n        Map<Character, Integer> map2 = new TreeMap<>();\\n        \\n        for(char ch : word1.toCharArray())\\n            map1.put(ch,map1.getOrDefault(ch,0)+1);\\n        for(char ch : word2.toCharArray())\\n            map2.put(ch,map2.getOrDefault(ch,0)+1);\\n        \\n        for(char ch : map1.keySet())\\n            if(Math.abs(map1.getOrDefault(ch,0)-map2.getOrDefault(ch,0)) > 3)\\n                return false;\\n        for(char ch : map2.keySet())\\n            if(Math.abs(map1.getOrDefault(ch,0)-map2.getOrDefault(ch,0)) > 3)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean checkAlmostEquivalent(String word1, String word2)\\n    {\\n        int[] f1 = new int[26];\\n        for(char ch : word1.toCharArray())\\n            f1[ch - \\'a\\']++;\\n        for(char ch : word2.toCharArray())\\n            f1[ch - \\'a\\']--;\\n        \\n        for(int i = 0; i < 26; i++)\\n            if(Math.abs(f1[i]) > 3)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public boolean checkAlmostEquivalent(String word1, String word2)\\n    {\\n        Map<Character, Integer> map1 = new TreeMap<>();\\n        Map<Character, Integer> map2 = new TreeMap<>();\\n        \\n        for(char ch : word1.toCharArray())\\n            map1.put(ch,map1.getOrDefault(ch,0)+1);\\n        for(char ch : word2.toCharArray())\\n            map2.put(ch,map2.getOrDefault(ch,0)+1);\\n        \\n        for(char ch : map1.keySet())\\n            if(Math.abs(map1.getOrDefault(ch,0)-map2.getOrDefault(ch,0)) > 3)\\n                return false;\\n        for(char ch : map2.keySet())\\n            if(Math.abs(map1.getOrDefault(ch,0)-map2.getOrDefault(ch,0)) > 3)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575913,
                "title": "easy-to-understand-concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> ans(26);\\n        int n = word1.size();\\n        for(int i = 0;i<n;i++){\\n            ans[word1[i]-\\'a\\']++;\\n        }\\n        for(int i = 0;i<word2.size();i++){\\n            ans[word2[i]-\\'a\\']--;\\n        }\\n        for(int i = 0;i<26;i++){\\n            if(abs(ans[i])>3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Please upvote if you find it useful.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> ans(26);\\n        int n = word1.size();\\n        for(int i = 0;i<n;i++){\\n            ans[word1[i]-\\'a\\']++;\\n        }\\n        for(int i = 0;i<word2.size();i++){\\n            ans[word2[i]-\\'a\\']--;\\n        }\\n        for(int i = 0;i<26;i++){\\n            if(abs(ans[i])>3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575912,
                "title": "c-100-fast-soln-explained",
                "content": "Use two frequency arrays to save count of alphabets of both strings and find out the maximum difference for a particular alphabet.\\nIf that maximum difference is less than or equal to 3 then Eureka....\\n```\\nbool checkAlmostEquivalent(string s1, string s2) {\\n        vector<char> v1(26,0), v2(26,0);\\n        for(auto i: s1) v1[i - \\'a\\']++;\\n        for(auto i: s2) v2[i - \\'a\\']++;\\n        int maxm = INT_MIN;\\n        for(int i=0; i<26; ++i) {\\n            maxm = max(maxm, abs(v1[i] - v2[i]));\\n        }\\n        return (maxm <= 3 ? true : false);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkAlmostEquivalent(string s1, string s2) {\\n        vector<char> v1(26,0), v2(26,0);\\n        for(auto i: s1) v1[i - \\'a\\']++;\\n        for(auto i: s2) v2[i - \\'a\\']++;\\n        int maxm = INT_MIN;\\n        for(int i=0; i<26; ++i) {\\n            maxm = max(maxm, abs(v1[i] - v2[i]));\\n        }\\n        return (maxm <= 3 ? true : false);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575897,
                "title": "single-pass-solution",
                "content": "\\n\\npublic boolean checkAlmostEquivalent(String word1, String word2) {\\n\\n        int arr1[]=new int[26];\\n        int arr2[]=new int[26];\\n        for(char ch:word1.toCharArray()){\\n            arr1[ch-\\'a\\']++;\\n        }\\n        for(char ch:word2.toCharArray()){\\n            arr2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(Math.abs(arr1[i]-arr2[i])>3) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\npublic boolean checkAlmostEquivalent(String word1, String word2) {\\n\\n        int arr1[]=new int[26];\\n        int arr2[]=new int[26];\\n        for(char ch:word1.toCharArray()){\\n            arr1[ch-\\'a\\']++;\\n        }\\n        for(char ch:word2.toCharArray()){\\n            arr2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(Math.abs(arr1[i]-arr2[i])>3) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1575888,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string w1, string w2) {\\n        \\n        unordered_map <char, int> mp1, mp2;\\n        \\n        for(int i=0; w1[i]; i++)\\n            mp1[w1[i]]++;\\n        \\n        for(int i=0; w2[i]; i++)\\n            mp2[w2[i]]++;\\n        \\n        for(auto it1 = mp1.begin(); it1!=mp1.end(); it1++)\\n        {\\n            unordered_map <char,int>::iterator it2 = mp2.find(it1->first);   \\n            if(it2 != mp2.end())\\n            {\\n                if(abs(it1->second - it2->second) > 3)\\n                    return false;\\n            }\\n            else if(it1->second > 3)\\n                return false;\\n        }\\n        \\n        for(auto it1 = mp2.begin(); it1!=mp2.end(); it1++)\\n        {\\n            unordered_map <char,int>::iterator it2 = mp1.find(it1->first);   \\n            if(it2 != mp1.end())\\n            {\\n                if(abs(it1->second - it2->second) > 3)\\n                    return false;\\n            }\\n            else if(it1->second > 3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string w1, string w2) {\\n        \\n        unordered_map <char, int> mp1, mp2;\\n        \\n        for(int i=0; w1[i]; i++)\\n            mp1[w1[i]]++;\\n        \\n        for(int i=0; w2[i]; i++)\\n            mp2[w2[i]]++;\\n        \\n        for(auto it1 = mp1.begin(); it1!=mp1.end(); it1++)\\n        {\\n            unordered_map <char,int>::iterator it2 = mp2.find(it1->first);   \\n            if(it2 != mp2.end())\\n            {\\n                if(abs(it1->second - it2->second) > 3)\\n                    return false;\\n            }\\n            else if(it1->second > 3)\\n                return false;\\n        }\\n        \\n        for(auto it1 = mp2.begin(); it1!=mp2.end(); it1++)\\n        {\\n            unordered_map <char,int>::iterator it2 = mp1.find(it1->first);   \\n            if(it2 != mp1.end())\\n            {\\n                if(abs(it1->second - it2->second) > 3)\\n                    return false;\\n            }\\n            else if(it1->second > 3)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077762,
                "title": "c-easy-code-beats-100-on-time",
                "content": "# Intuition\\nJust taken two freq vectors and traversed loop to see difference between elements.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1) (constant space)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int n = word1.size();\\n        vector<int> m1(26,0),m2(26,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            m1[word1[i] - \\'a\\']++;\\n            m2[word2[i] - \\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(abs(m1[i] - m2[i]) > 3)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int n = word1.size();\\n        vector<int> m1(26,0),m2(26,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            m1[word1[i] - \\'a\\']++;\\n            m2[word2[i] - \\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(abs(m1[i] - m2[i]) > 3)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077667,
                "title": "c-easy-and-readable-solution-less-than-85",
                "content": "![image.png](https://assets.leetcode.com/users/images/6ad31bf6-f40e-418a-8b73-3671829e5bb9_1695403881.4703147.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public bool CheckAlmostEquivalent(string word1, string word2) {\\n        int[] wordsDiff = new int[26];\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            wordsDiff[word1[i] - 97]++;\\n            wordsDiff[word2[i] - 97]--;\\n        }\\n        return wordsDiff.Min() >= -3 && wordsDiff.Max() <= 3;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckAlmostEquivalent(string word1, string word2) {\\n        int[] wordsDiff = new int[26];\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            wordsDiff[word1[i] - 97]++;\\n            wordsDiff[word2[i] - 97]--;\\n        }\\n        return wordsDiff.Min() >= -3 && wordsDiff.Max() <= 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077418,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/8ed00a13-0ad4-471b-83f5-fad1e8d08aaa_1695399877.6115544.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> v1(26,0), v2(26,0);\\n        for(auto i : word1) v1[i-\\'a\\']++;\\n        for(auto i : word2) v2[i-\\'a\\']++;\\n\\n        for(int i=0; i<26; i++){\\n            if(abs(v1[i] - v2[i]) > 3)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> v1(26,0), v2(26,0);\\n        for(auto i : word1) v1[i-\\'a\\']++;\\n        for(auto i : word2) v2[i-\\'a\\']++;\\n\\n        for(int i=0; i<26; i++){\\n            if(abs(v1[i] - v2[i]) > 3)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071804,
                "title": "idk-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        differences = set()\\n        for i in word1:\\n            differences.add(abs(word1.count(i) - word2.count(i)))\\n        for i in word2:\\n            differences.add(abs(word1.count(i) - word2.count(i)))\\n        if max(differences) > 3:\\n            return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        differences = set()\\n        for i in word1:\\n            differences.add(abs(word1.count(i) - word2.count(i)))\\n        for i in word2:\\n            differences.add(abs(word1.count(i) - word2.count(i)))\\n        if max(differences) > 3:\\n            return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067943,
                "title": "very-simple-short-and-productive-solution",
                "content": "```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    const arr = new Array(26).fill(0)\\n    \\n    for (let i = 0; i < word1.length; i++) {\\n        arr[word1.charCodeAt(i) - 97]++\\n        arr[word2.charCodeAt(i) - 97]--\\n    }\\n\\n    return arr.every(val => Math.abs(val) <= 3)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkAlmostEquivalent = function(word1, word2) {\\n    const arr = new Array(26).fill(0)\\n    \\n    for (let i = 0; i < word1.length; i++) {\\n        arr[word1.charCodeAt(i) - 97]++\\n        arr[word2.charCodeAt(i) - 97]--\\n    }\\n\\n    return arr.every(val => Math.abs(val) <= 3)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066311,
                "title": "short-and-simple-python-solution-faster-than-89-69",
                "content": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        letters = set(word1 + word2)\\n        arr = []\\n        for i in letters:\\n            arr.append(abs(word1.count(i) - word2.count(i)))\\n        #print(arr)\\n        \\n        if max(arr) > 3:\\n            return False\\n        else:\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        letters = set(word1 + word2)\\n        arr = []\\n        for i in letters:\\n            arr.append(abs(word1.count(i) - word2.count(i)))\\n        #print(arr)\\n        \\n        if max(arr) > 3:\\n            return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063784,
                "title": "c-solution-by-ajeet20-iit-kanpur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for(int i =0; i < word1.size(); i++) {\\n            v1[int(word1[i] - 97)]++;\\n            v2[int(word2[i] - 97)]++;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            if(abs(v1[i] - v2[i]) >= 4) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for(int i =0; i < word1.size(); i++) {\\n            v1[int(word1[i] - 97)]++;\\n            v2[int(word2[i] - 97)]++;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            if(abs(v1[i] - v2[i]) >= 4) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061749,
                "title": "simplest-solution-runtime-97",
                "content": "![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-09-18 \\u0432 22.56.02.png](https://assets.leetcode.com/users/images/3aeb6d99-73e3-4dd8-8465-16b63a118eaf_1695067028.528865.png)\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        cnt = Counter(word1)\\n        cnt.subtract(word2)\\n        return all(abs(i) < 4 for i in cnt.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        cnt = Counter(word1)\\n        cnt.subtract(word2)\\n        return all(abs(i) < 4 for i in cnt.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051826,
                "title": "99-runtime-71-memory-3-line-simple-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/ebd3d0c9-4b72-4261-bf5b-1f9898b269b4_1694874206.2656295.png)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        for i in set(word1)|set(word2):\\n            if abs(word1.count(i) - word2.count(i)) > 3: return False\\n\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        for i in set(word1)|set(word2):\\n            if abs(word1.count(i) - word2.count(i)) > 3: return False\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043911,
                "title": "easy-to-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char, int> myMap;\\n        for(int i=0;i<word1.length();i++){\\n            myMap[word1[i]]++;\\n            myMap[word2[i]]--;\\n        }\\n        string alpha=\"abcdefghijklmnopqrstuvwxyz\";\\n        for(char c:alpha){\\n            if(abs(myMap[c])>3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char, int> myMap;\\n        for(int i=0;i<word1.length();i++){\\n            myMap[word1[i]]++;\\n            myMap[word2[i]]--;\\n        }\\n        string alpha=\"abcdefghijklmnopqrstuvwxyz\";\\n        for(char c:alpha){\\n            if(abs(myMap[c])>3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043771,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] arr_one  = new int[26];\\n        int[] arr_two = new int[26];\\n        int n = word1.length();\\n        for(int i = 0;i<n;i++){\\n            arr_one[word1.charAt(i)-\\'a\\']++;\\n            arr_two[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<n;i++){\\n    if((Math.abs(arr_one[word1.charAt(i)-\\'a\\']-arr_two[word1.charAt(i)-\\'a\\']))>3||(Math.abs(arr_one[word2.charAt(i)-\\'a\\']-arr_two[word2.charAt(i)-\\'a\\']))>3 ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] arr_one  = new int[26];\\n        int[] arr_two = new int[26];\\n        int n = word1.length();\\n        for(int i = 0;i<n;i++){\\n            arr_one[word1.charAt(i)-\\'a\\']++;\\n            arr_two[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<n;i++){\\n    if((Math.abs(arr_one[word1.charAt(i)-\\'a\\']-arr_two[word1.charAt(i)-\\'a\\']))>3||(Math.abs(arr_one[word2.charAt(i)-\\'a\\']-arr_two[word2.charAt(i)-\\'a\\']))>3 ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038110,
                "title": "beginner-friendly-with-not-much-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(3n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(3n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Set<Character> set = new HashSet<>();\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        for(int i=0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            set.add(word1.charAt(i));\\n        }\\n        Map<Character, Integer> map2 = new HashMap<>();\\n        for(int i=0; i<word2.length(); i++){\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n            set.add(word2.charAt(i));\\n        }\\n\\n        for(char ch : set){\\n            //char ch = set.get(i);\\n            if(map1.containsKey(ch) && map2.containsKey(ch)){\\n                if(Math.abs(map1.get(ch)-map2.get(ch)) > 3) return false;\\n            }\\n            else if(map1.containsKey(ch)){\\n                if(map1.get(ch) >3) return false;\\n            } else{\\n                if(map2.get(ch) >3) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Set<Character> set = new HashSet<>();\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        for(int i=0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            set.add(word1.charAt(i));\\n        }\\n        Map<Character, Integer> map2 = new HashMap<>();\\n        for(int i=0; i<word2.length(); i++){\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n            set.add(word2.charAt(i));\\n        }\\n\\n        for(char ch : set){\\n            //char ch = set.get(i);\\n            if(map1.containsKey(ch) && map2.containsKey(ch)){\\n                if(Math.abs(map1.get(ch)-map2.get(ch)) > 3) return false;\\n            }\\n            else if(map1.containsKey(ch)){\\n                if(map1.get(ch) >3) return false;\\n            } else{\\n                if(map2.get(ch) >3) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031577,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        word1_counter = Counter(word1)\\n        word2_counter = Counter(word2)\\n\\n        common = word1_counter | word2_counter\\n        # Counter({\\'a\\': 4, \\'c\\': 2, \\'e\\': 2, \\'b\\': 1, \\'d\\': 1, \\'f\\': 1})\\n\\n        for key in common:\\n            if key in word1_counter and key in word2_counter:\\n                if abs(word1_counter[key] - word2_counter[key]) > 3:\\n                    return False\\n            elif key in word1_counter and key not in word2_counter:\\n                if word1_counter[key] >3:\\n                    return False\\n            else:\\n                if word2_counter[key] >3:\\n                    return False\\n\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        word1_counter = Counter(word1)\\n        word2_counter = Counter(word2)\\n\\n        common = word1_counter | word2_counter\\n        # Counter({\\'a\\': 4, \\'c\\': 2, \\'e\\': 2, \\'b\\': 1, \\'d\\': 1, \\'f\\': 1})\\n\\n        for key in common:\\n            if key in word1_counter and key in word2_counter:\\n                if abs(word1_counter[key] - word2_counter[key]) > 3:\\n                    return False\\n            elif key in word1_counter and key not in word2_counter:\\n                if word1_counter[key] >3:\\n                    return False\\n            else:\\n                if word2_counter[key] >3:\\n                    return False\\n\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028871,
                "title": "2068-check-whether-two-strings-are-almost-equivalent",
                "content": "# Complexity\\nRuntime Details 42ms Beats 54.12%of users with Python3\\nMemory Details 16.30MB Beats 71.71%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        # Initialization\\n        char_set = set(word1+word2)\\n        dict1 = dict(zip(list(char_set), [0 for i in range(len(char_set))]))\\n        dict2 = dict(zip(list(char_set), [0 for i in range(len(char_set))]))\\n\\n        # Update count\\n        for i in word1:\\n            dict1[i] += 1\\n        for i in word2:\\n            dict2[i] += 1\\n\\n        for i in char_set:\\n            if abs(dict1[i]-dict2[i]) > 3:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        # Initialization\\n        char_set = set(word1+word2)\\n        dict1 = dict(zip(list(char_set), [0 for i in range(len(char_set))]))\\n        dict2 = dict(zip(list(char_set), [0 for i in range(len(char_set))]))\\n\\n        # Update count\\n        for i in word1:\\n            dict1[i] += 1\\n        for i in word2:\\n            dict2[i] += 1\\n\\n        for i in char_set:\\n            if abs(dict1[i]-dict2[i]) > 3:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024153,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore character -> frequency of word1 and word 2 in two different hashmap then compare both frequencies to be atmost 3.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(char c: word1.toCharArray()){\\n            if(map1.containsKey(c)){\\n                map1.put(c, map1.get(c) + 1);\\n            }else{\\n                map1.put(c, 1);\\n            }\\n        }\\n\\n        for(char c: word2.toCharArray()){\\n            if(map2.containsKey(c)){\\n                map2.put(c, map2.get(c) + 1);\\n            }else{\\n                map2.put(c, 1);\\n            }\\n        }\\n\\n        for(char c: map1.keySet()){\\n            if(!map2.containsKey(c)){\\n                map2.put(c,0);\\n            }\\n\\n            if(map1.get(c) - map2.get(c) > 3)\\n                return false;\\n        }\\n\\n\\n        for(char c: map2.keySet()){\\n            if(!map1.containsKey(c)){\\n                map1.put(c,0);\\n            }\\n\\n            if(map2.get(c) - map1.get(c) > 3)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(char c: word1.toCharArray()){\\n            if(map1.containsKey(c)){\\n                map1.put(c, map1.get(c) + 1);\\n            }else{\\n                map1.put(c, 1);\\n            }\\n        }\\n\\n        for(char c: word2.toCharArray()){\\n            if(map2.containsKey(c)){\\n                map2.put(c, map2.get(c) + 1);\\n            }else{\\n                map2.put(c, 1);\\n            }\\n        }\\n\\n        for(char c: map1.keySet()){\\n            if(!map2.containsKey(c)){\\n                map2.put(c,0);\\n            }\\n\\n            if(map1.get(c) - map2.get(c) > 3)\\n                return false;\\n        }\\n\\n\\n        for(char c: map2.keySet()){\\n            if(!map1.containsKey(c)){\\n                map1.put(c,0);\\n            }\\n\\n            if(map2.get(c) - map1.get(c) > 3)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023999,
                "title": "python-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m+n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        dict1 = {}\\n        dict2 = {}\\n        for i in word1:\\n            if i in dict1.keys():\\n                dict1[i] += 1\\n            else:\\n                dict1[i] = 1\\n\\n        for i in word2:\\n            if i in dict2.keys():\\n                dict2[i] += 1\\n            else:\\n                dict2[i] = 1\\n\\n        for key in dict1.keys():\\n            if dict2.get(key):\\n                diff = abs(dict1.get(key) - dict2.get(key))\\n            else:\\n                diff = dict1.get(key)\\n            if diff >3:\\n                return False\\n        \\n        for key in dict2.keys():\\n            if dict1.get(key):\\n                diff = abs(dict1.get(key) - dict2.get(key))\\n            else:\\n                diff = dict2.get(key)\\n            if diff >3:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        dict1 = {}\\n        dict2 = {}\\n        for i in word1:\\n            if i in dict1.keys():\\n                dict1[i] += 1\\n            else:\\n                dict1[i] = 1\\n\\n        for i in word2:\\n            if i in dict2.keys():\\n                dict2[i] += 1\\n            else:\\n                dict2[i] = 1\\n\\n        for key in dict1.keys():\\n            if dict2.get(key):\\n                diff = abs(dict1.get(key) - dict2.get(key))\\n            else:\\n                diff = dict1.get(key)\\n            if diff >3:\\n                return False\\n        \\n        for key in dict2.keys():\\n            if dict1.get(key):\\n                diff = abs(dict1.get(key) - dict2.get(key))\\n            else:\\n                diff = dict2.get(key)\\n            if diff >3:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022048,
                "title": "easy-cpp-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> v1(26), v2(26);\\n        for(auto x: word1) v1[x-\\'a\\']++;\\n        for(auto x: word2) v2[x-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            if (abs(v1[i] - v2[i]) > 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int> v1(26), v2(26);\\n        for(auto x: word1) v1[x-\\'a\\']++;\\n        for(auto x: word2) v2[x-\\'a\\']++;\\n        for (int i = 0; i < 26; i++) {\\n            if (abs(v1[i] - v2[i]) > 3) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021715,
                "title": "rust-beginner-friendly-hashmaps-o-n-time-and-space",
                "content": "# Intuition\\nCount the instances of each character in each string. Then compare the characters in word 1 against word 2, and the characters in word 2 against word 1. If the difference is greater than 3, we know the strings are not equivalent.\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\n\\nimpl Solution {\\n    pub fn check_almost_equivalent(word1: String, word2: String) -> bool {\\n        let mut word_1_count: HashMap<char, i32> = HashMap::new();\\n        let mut word_2_count: HashMap<char, i32> = HashMap::new();\\n\\n        for i in 0..word1.len() {\\n            let char1 = word1.chars().nth(i).unwrap();\\n            let char2 = word2.chars().nth(i).unwrap();\\n\\n            *word_1_count.entry(char1).or_insert(0) += 1;\\n            *word_2_count.entry(char2).or_insert(0) += 1;\\n        }\\n\\n        for (k, v) in &word_1_count {\\n            if (v - word_2_count.get(k).unwrap_or(&0)).abs() > 3 {\\n                return false;\\n            }\\n        }\\n\\n        for (k, v) in &word_2_count {\\n            if (v - word_1_count.get(k).unwrap_or(&0)).abs() > 3 {\\n                return false;\\n            }\\n        }\\n\\n        true\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\n\\nimpl Solution {\\n    pub fn check_almost_equivalent(word1: String, word2: String) -> bool {\\n        let mut word_1_count: HashMap<char, i32> = HashMap::new();\\n        let mut word_2_count: HashMap<char, i32> = HashMap::new();\\n\\n        for i in 0..word1.len() {\\n            let char1 = word1.chars().nth(i).unwrap();\\n            let char2 = word2.chars().nth(i).unwrap();\\n\\n            *word_1_count.entry(char1).or_insert(0) += 1;\\n            *word_2_count.entry(char2).or_insert(0) += 1;\\n        }\\n\\n        for (k, v) in &word_1_count {\\n            if (v - word_2_count.get(k).unwrap_or(&0)).abs() > 3 {\\n                return false;\\n            }\\n        }\\n\\n        for (k, v) in &word_2_count {\\n            if (v - word_1_count.get(k).unwrap_or(&0)).abs() > 3 {\\n                return false;\\n            }\\n        }\\n\\n        true\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009149,
                "title": "easy-peasy-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int map1[26]={0};\\n        int map2[26]={0};\\n        for(char i : word1){\\n            map1[i -\\'a\\']++;\\n        }\\n        for(char i: word2){\\n            map2[i - \\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(abs(map1[i]-map2[i])>3)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int map1[26]={0};\\n        int map2[26]={0};\\n        for(char i : word1){\\n            map1[i -\\'a\\']++;\\n        }\\n        for(char i: word2){\\n            map2[i - \\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(abs(map1[i]-map2[i])>3)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994561,
                "title": "simple-c-style-array-c-solution-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int freqs[26] = {};\\n        int n = word1.size();\\n        for (int i = 0; i < n; ++i) {\\n            freqs[word1[i] - \\'a\\']++;\\n            freqs[word2[i] - \\'a\\']--;\\n        }\\n\\n        for (int i = 0; i < 26; ++i) {\\n            if (abs(freqs[i]) > 3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int freqs[26] = {};\\n        int n = word1.size();\\n        for (int i = 0; i < n; ++i) {\\n            freqs[word1[i] - \\'a\\']++;\\n            freqs[word2[i] - \\'a\\']--;\\n        }\\n\\n        for (int i = 0; i < 26; ++i) {\\n            if (abs(freqs[i]) > 3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994054,
                "title": "readable-solution",
                "content": "# Approach\\nWith small dataset, I prefer to see \\nsomething more readable see below. Performance is not always the goal.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n\\n     Set<Character> charSet = new HashSet<>((word1 + word2).chars().mapToObj(e-> (char)e).toList());\\n            List<Character> word1L = word1.chars().mapToObj(e-> (char)e).toList();\\n            List<Character> word2L = word2.chars().mapToObj(e->(char)e).toList();\\n\\n            for (Object ch :charSet )\\n            {\\n                long count1 = word1L.stream().filter( x-> x == ch).count();\\n                long count2 = word2L.stream().filter( x-> x == ch).count();\\n                if(Math.abs(count1 - count2)>3 ) return false;\\n            }\\n\\n            return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n\\n     Set<Character> charSet = new HashSet<>((word1 + word2).chars().mapToObj(e-> (char)e).toList());\\n            List<Character> word1L = word1.chars().mapToObj(e-> (char)e).toList();\\n            List<Character> word2L = word2.chars().mapToObj(e->(char)e).toList();\\n\\n            for (Object ch :charSet )\\n            {\\n                long count1 = word1L.stream().filter( x-> x == ch).count();\\n                long count2 = word2L.stream().filter( x-> x == ch).count();\\n                if(Math.abs(count1 - count2)>3 ) return false;\\n            }\\n\\n            return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990713,
                "title": "java-o-1-space-o-n-time-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis could be solved like any other counting characters problem with int array of length 26. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Initialize array for 26 lower case characters.\\nStep 2: Take two character variables - ch1 is character from word1, ch2 from word 2. Substracting 97 to match with 0 indexed array (please refer to ASCII table).\\nStep 3: Adding from one String while substracting from other which gives net difference.\\nStep 4: If for any character, difference is more than 3, return false.\\n            \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) [O(26)]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        //initialize array for 26 lower case characters\\n        int[] count = new int[26];\\n\\n        for(int i = 0; i< word2.length(); i++){\\n            // ch1 is character from word1, ch2 from word 2. Substracting 97 to match with 0 indexed array (ASCII)\\n            int ch1 = word1.charAt(i) -97;\\n            int ch2 = word2.charAt(i) -97;\\n           \\n           //Adding from one String while substracting from other which gives net difference\\n           count[ch1] += 1;\\n           count[ch2] -= 1; \\n        }\\n\\n        //if for any character, difference is more than 3, return false.\\n        for(int i: count){\\n            if(i<-3 || i>3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        //initialize array for 26 lower case characters\\n        int[] count = new int[26];\\n\\n        for(int i = 0; i< word2.length(); i++){\\n            // ch1 is character from word1, ch2 from word 2. Substracting 97 to match with 0 indexed array (ASCII)\\n            int ch1 = word1.charAt(i) -97;\\n            int ch2 = word2.charAt(i) -97;\\n           \\n           //Adding from one String while substracting from other which gives net difference\\n           count[ch1] += 1;\\n           count[ch2] -= 1; \\n        }\\n\\n        //if for any character, difference is more than 3, return false.\\n        for(int i: count){\\n            if(i<-3 || i>3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989367,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        a=word1+word2\\n        b=[]\\n        for i in a :\\n            if i not in b :\\n                b.append(i)\\n        c=[]\\n        for i in range(0,len(b)) :\\n            c.append([])\\n        for i in range(0,len(b)) :\\n            c[i].append(word1.count(b[i])) \\n            c[i].append(word2.count(b[i])) \\n        d=[]\\n        for i in range(0,len(c)) :\\n            d.append(abs(c[i][0]-c[i][1]))\\n        print(d)\\n        e=0\\n        for i in range(0,len(d)) :\\n            if d[i]>3 :\\n                e+=1\\n            if e>0 :\\n                break\\n        return True if e==0 else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        a=word1+word2\\n        b=[]\\n        for i in a :\\n            if i not in b :\\n                b.append(i)\\n        c=[]\\n        for i in range(0,len(b)) :\\n            c.append([])\\n        for i in range(0,len(b)) :\\n            c[i].append(word1.count(b[i])) \\n            c[i].append(word2.count(b[i])) \\n        d=[]\\n        for i in range(0,len(c)) :\\n            d.append(abs(c[i][0]-c[i][1]))\\n        print(d)\\n        e=0\\n        for i in range(0,len(d)) :\\n            if d[i]>3 :\\n                e+=1\\n            if e>0 :\\n                break\\n        return True if e==0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988340,
                "title": "simple-cpp-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int>f1(26,0);\\n        vector<int>f2(26,0);\\n        for(int i = 0; i<word1.size(); i++){\\n            f1[word1[i]-\\'a\\']++;\\n        }\\n         for(int i = 0; i<word2.size(); i++){\\n            f2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; i<26; i++){\\n            if(abs(f1[i]-f2[i])>3)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        vector<int>f1(26,0);\\n        vector<int>f2(26,0);\\n        for(int i = 0; i<word1.size(); i++){\\n            f1[word1[i]-\\'a\\']++;\\n        }\\n         for(int i = 0; i<word2.size(); i++){\\n            f2[word2[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; i<26; i++){\\n            if(abs(f1[i]-f2[i])>3)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987885,
                "title": "c-solution-using-array-100-runtime-78-5-memory-beginner-friendly-solution-p",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreating a simple array that stores the occurences of characters.\\nAt first a static array is declared to store the occurences of all the characters of word1 and removing the occurences of the characters of word2.\\nSince both strings are of same length, then using a simple for loop we can traverse the words and update the value of array we declared.\\nThen we have to check whether the occurences of characters in word1 are more than 3 or less than 3 in word2 to make the string equivalent.\\nSo by traversing the array again and checking if the absolute (positive) value of any index is greater than 3, we simply terminate the program returning false.\\nIf complete array is traversed and no such index is found then we can say that the strings are equivalent.\\n\\n> I don\\'t know what an upvote does, but still would appretiate it if you do :)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int a[26] = {0};\\n        for(int i = 0; i<word1.size(); i++){\\n            a[word1[i]-\\'a\\']++;\\n            a[word2[i]-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(abs(a[i]) > 3)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int a[26] = {0};\\n        for(int i = 0; i<word1.size(); i++){\\n            a[word1[i]-\\'a\\']++;\\n            a[word2[i]-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(abs(a[i]) > 3)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985516,
                "title": "0s-fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int w1[]=new int[26];\\n        int w2[]=new int[26];\\n        for(char c:word1.toCharArray()){\\n            w1[c-\\'a\\']++;\\n        }\\n        for(char c:word2.toCharArray()){\\n             w2[c-\\'a\\']++;\\n        }\\n        for(int i=0;i<w1.length;i++){\\n            if(Math.abs(w1[i]-w2[i])>3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int w1[]=new int[26];\\n        int w2[]=new int[26];\\n        for(char c:word1.toCharArray()){\\n            w1[c-\\'a\\']++;\\n        }\\n        for(char c:word2.toCharArray()){\\n             w2[c-\\'a\\']++;\\n        }\\n        for(int i=0;i<w1.length;i++){\\n            if(Math.abs(w1[i]-w2[i])>3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980161,
                "title": "very-simple-solution",
                "content": "\\n\\n# Approach\\nword1.length == word2.length so in 1 pass, increase the freq for each\\nletter from word1 and decrease for each letter in word2. If the final\\nfreq is > 3 for one letter, it means it cant be almost equivalent.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1), we use a constant vector like a map because we are working with\\nsmall letters only.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int map[26] = {};\\n        //n == word1.length == word2.length\\n        for (int i = 0; i < word1.size(); i++)\\n        {\\n            map[word1[i] - \\'a\\']++;\\n            map[word2[i] - \\'a\\']--;\\n        }\\n        for (int c = 0; c < 26; c++)\\n        {\\n            if (abs(map[c]) > 3)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int map[26] = {};\\n        //n == word1.length == word2.length\\n        for (int i = 0; i < word1.size(); i++)\\n        {\\n            map[word1[i] - \\'a\\']++;\\n            map[word2[i] - \\'a\\']--;\\n        }\\n        for (int c = 0; c < 26; c++)\\n        {\\n            if (abs(map[c]) > 3)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977447,
                "title": "java-based-o-n-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] letters = new int[26];\\n        for(int i=0; i<word1.length(); i++) {\\n            letters[word1.charAt(i) - \\'a\\']++;\\n            letters[word2.charAt(i) - \\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++) {\\n            if(Math.abs(letters[i]) > 3) {//for all the cases where there is no match and the difference is >3\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] letters = new int[26];\\n        for(int i=0; i<word1.length(); i++) {\\n            letters[word1.charAt(i) - \\'a\\']++;\\n            letters[word2.charAt(i) - \\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++) {\\n            if(Math.abs(letters[i]) > 3) {//for all the cases where there is no match and the difference is >3\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974388,
                "title": "simpliest-solution-with-defaultdict",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def checkAlmostEquivalent(self, word1, word2):\\n\\n        d = defaultdict(int)\\n        for ch in word1:\\n            d[ch] += 1\\n        for ch in word2:\\n            d[ch] -= 1\\n        \\n        return all(abs(i) < 4 for i in d.values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def checkAlmostEquivalent(self, word1, word2):\\n\\n        d = defaultdict(int)\\n        for ch in word1:\\n            d[ch] += 1\\n        for ch in word2:\\n            d[ch] -= 1\\n        \\n        return all(abs(i) < 4 for i in d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962936,
                "title": "easy-c-solution-track-count-using-single-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int count[26] = {0};\\n\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            count[word1[i]-\\'a\\']++;\\n            count[word2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            if( !(count[i] <= 3 && count[i] >= -3))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int count[26] = {0};\\n\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            count[word1[i]-\\'a\\']++;\\n            count[word2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            if( !(count[i] <= 3 && count[i] >= -3))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961551,
                "title": "check-whether-two-strings-are-almost-equivalent-24ms-beats-99-76-of-users-with-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code checks whether two words, word1 and word2, are almost equivalent. Two words are considered almost equivalent if they have the same characters with a maximum frequency difference of 3 for each character.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code first creates frequency dictionaries, `freq1` and `freq2`, using the `Counter` class. These dictionaries store the frequency of each character in `word1` and `word2`, respectively.\\n1. It then iterates over the characters and their frequencies in `freq1`.\\n1. For each character `k` in `freq1`, it checks if `k` is present in `freq2`.\\n   - If `k` is present in `freq2`, it checks if the absolute difference between the frequencies of `k` in `freq1` and `freq2` is greater than 3. If it is, the code returns `False`, indicating that the words are not almost equivalent.\\n   - If the absolute difference is not greater than 3, it continues to the next character.\\n   - If `k` is not present in `freq2`, it checks if the frequency of `k` in `freq1` is greater than 3. If it is, the code returns `False`.\\n1. The code performs a similar check for characters in `freq2` that are not present in `freq1`.\\n1. If the code completes the iterations without returning `False`, it means the words are almost equivalent, and it returns `True`.\\n\\n# Complexity\\n# ***- Time complexity:***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: The code iterates over the characters and their frequencies in both `word1` and `word2`, which takes O(N) time, where N is the length of the longer word between `word1` and `word2`. Checking the frequency difference and membership in dictionaries takes constant time. Therefore, the overall time complexity is O(N).\\n# ***- Space complexity:***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: The code uses additional space to store the frequency dictionaries `freq1` and `freq2`. The space required is proportional to the number of unique characters in `word1` and `word2`, which is O(M), where M is the number of unique characters. Therefore, the space complexity is O(M).\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        freq1 = Counter(word1)\\n        freq2 = Counter(word2)\\n        for k,v in freq1.items():\\n            if k in freq2:\\n                if abs(freq1[k]-freq2[k])>3:\\n                    return False\\n            else:\\n                if freq1[k]>3:\\n                    return False\\n                \\n        for k,v in freq2.items():\\n            if k in freq1:\\n                if abs(freq1[k]-freq2[k])>3:\\n                    return False\\n            else:\\n                if freq2[k]>3:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        freq1 = Counter(word1)\\n        freq2 = Counter(word2)\\n        for k,v in freq1.items():\\n            if k in freq2:\\n                if abs(freq1[k]-freq2[k])>3:\\n                    return False\\n            else:\\n                if freq1[k]>3:\\n                    return False\\n                \\n        for k,v in freq2.items():\\n            if k in freq1:\\n                if abs(freq1[k]-freq2[k])>3:\\n                    return False\\n            else:\\n                if freq2[k]>3:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960281,
                "title": "2-easy-to-read-python-solutions-with-explanation-in-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        return self.sol2(word1, word2)\\n\\n\\n    def sol1(self, word1, word2):\\n        #this can be solved with a hashmap\\n        # first build a freq map of word1\\n        # then parse thru the second word a character at a time\\n        # and then decrement the characters frequency in the same freq map\\n        \\n        #once we have done this, for each character in the freq map:\\n        # if word1 had more occurences of a char than word2, the freq will be positive\\n        # if word1 and word 2 had same number of occurences as word2, the freq will be 0\\n        # if word2 had more occurneces of a char than word1, the freq will be negative\\n\\n        #we simply need to see if each chat has an absolute frequency less than or equal to 3\\n\\n\\n        charCtr = Counter()\\n\\n        #parse thru word1 and increment the freq of char in counter \\n        for char in word1:\\n            charCtr[char] += 1\\n\\n        \\n        #parse thru word2 and decrement the freq of char in counter\\n        for char in word2:\\n            charCtr[char] -= 1\\n        \\n        #if there are any chars where the absolute diff in frequency is greater than 3, return false\\n        for char in charCtr:\\n            if abs(charCtr[char]) > 3:\\n                return False\\n        \\n        #if we get out of the for loop, return True since none of the chars had a diff in freq greatern than 3\\n        return True\\n\\n\\n    def sol2(self, word1, word2):\\n            # This is the same as sol1 with one slight modification \\n            # we parse thru the two words at the same time (not the len of the two strings are the same)\\n            # and we only update the counter if the chars are different\\n\\n        charCtr = Counter()\\n\\n        for i in range(0,len(word1)):\\n            if word1[i] != word2[i]:\\n                charCtr[word1[i]] += 1\\n                charCtr[word2[i]] -= 1\\n        \\n        #Now we check iof the absolute diff in freq of each char is less than or equal to 3\\n\\n        for char in charCtr:\\n            if abs(charCtr[char]) > 3:\\n                return False\\n        \\n        return True\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        return self.sol2(word1, word2)\\n\\n\\n    def sol1(self, word1, word2):\\n        #this can be solved with a hashmap\\n        # first build a freq map of word1\\n        # then parse thru the second word a character at a time\\n        # and then decrement the characters frequency in the same freq map\\n        \\n        #once we have done this, for each character in the freq map:\\n        # if word1 had more occurences of a char than word2, the freq will be positive\\n        # if word1 and word 2 had same number of occurences as word2, the freq will be 0\\n        # if word2 had more occurneces of a char than word1, the freq will be negative\\n\\n        #we simply need to see if each chat has an absolute frequency less than or equal to 3\\n\\n\\n        charCtr = Counter()\\n\\n        #parse thru word1 and increment the freq of char in counter \\n        for char in word1:\\n            charCtr[char] += 1\\n\\n        \\n        #parse thru word2 and decrement the freq of char in counter\\n        for char in word2:\\n            charCtr[char] -= 1\\n        \\n        #if there are any chars where the absolute diff in frequency is greater than 3, return false\\n        for char in charCtr:\\n            if abs(charCtr[char]) > 3:\\n                return False\\n        \\n        #if we get out of the for loop, return True since none of the chars had a diff in freq greatern than 3\\n        return True\\n\\n\\n    def sol2(self, word1, word2):\\n            # This is the same as sol1 with one slight modification \\n            # we parse thru the two words at the same time (not the len of the two strings are the same)\\n            # and we only update the counter if the chars are different\\n\\n        charCtr = Counter()\\n\\n        for i in range(0,len(word1)):\\n            if word1[i] != word2[i]:\\n                charCtr[word1[i]] += 1\\n                charCtr[word2[i]] -= 1\\n        \\n        #Now we check iof the absolute diff in freq of each char is less than or equal to 3\\n\\n        for char in charCtr:\\n            if abs(charCtr[char]) > 3:\\n                return False\\n        \\n        return True\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960269,
                "title": "easy-to-read-py-solution-with-explanation-in-comments",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        #this can be solved with a hashmap\\n        # first build a freq map of word1\\n        # then parse thru the second word a character at a time\\n        # and then decrement the characters frequency in the same freq map\\n        \\n        #once we have done this, for each character in the freq map:\\n        # if word1 had more occurences of a char than word2, the freq will be positive\\n        # if word1 and word 2 had same number of occurences as word2, the freq will be 0\\n        # if word2 had more occurneces of a char than word1, the freq will be negative\\n\\n        #we simply need to see if each chat has an absolute frequency less than or equal to 3\\n\\n\\n        charCtr = Counter()\\n\\n        #parse thru word1 and increment the freq of char in counter \\n        for char in word1:\\n            charCtr[char] += 1\\n\\n        \\n        #parse thru word2 and decrement the freq of char in counter\\n        for char in word2:\\n            charCtr[char] -= 1\\n        \\n        #if there are any chars where the absolute diff in frequency is greater than 3, return false\\n        for char in charCtr:\\n            if abs(charCtr[char]) > 3:\\n                return False\\n        \\n        #if we get out of the for loop, return True since none of the chars had a diff in freq greatern than 3\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        #this can be solved with a hashmap\\n        # first build a freq map of word1\\n        # then parse thru the second word a character at a time\\n        # and then decrement the characters frequency in the same freq map\\n        \\n        #once we have done this, for each character in the freq map:\\n        # if word1 had more occurences of a char than word2, the freq will be positive\\n        # if word1 and word 2 had same number of occurences as word2, the freq will be 0\\n        # if word2 had more occurneces of a char than word1, the freq will be negative\\n\\n        #we simply need to see if each chat has an absolute frequency less than or equal to 3\\n\\n\\n        charCtr = Counter()\\n\\n        #parse thru word1 and increment the freq of char in counter \\n        for char in word1:\\n            charCtr[char] += 1\\n\\n        \\n        #parse thru word2 and decrement the freq of char in counter\\n        for char in word2:\\n            charCtr[char] -= 1\\n        \\n        #if there are any chars where the absolute diff in frequency is greater than 3, return false\\n        for char in charCtr:\\n            if abs(charCtr[char]) > 3:\\n                return False\\n        \\n        #if we get out of the for loop, return True since none of the chars had a diff in freq greatern than 3\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960146,
                "title": "probably-this-will-be-one-of-the-best-approach-frequency-array-concept",
                "content": "# Intuition\\n  Keep the track of the frequencies of the Strings : For the first string increment each character\\'s frequency and for the second string decrement each character\\'s frequency , traverse the frequency array if at any moment of time we encounters that either of the frequency has greater than 3 or less than -3 then immediately we will return false otherwise once we traversed the whole frequency array it means all the frequencies has the difference less than or equal to 3 so we will simply return true outside the loop.\\n\\n# Approach\\n  Frequency Array Concept.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n        int []freq = new int[26];\\n\\n        for(char ch:word1.toCharArray()){\\n            freq[ch-\\'a\\']++;\\n        }\\n        for(char ch:word2.toCharArray()){\\n            freq[ch-\\'a\\']--;\\n        }\\n\\n        for(int check:freq) if(check>3||check<-3) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        \\n        int []freq = new int[26];\\n\\n        for(char ch:word1.toCharArray()){\\n            freq[ch-\\'a\\']++;\\n        }\\n        for(char ch:word2.toCharArray()){\\n            freq[ch-\\'a\\']--;\\n        }\\n\\n        for(int check:freq) if(check>3||check<-3) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955610,
                "title": "java-eaey-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int sum = 0;\\n        int[] str = new int[26];\\n        for(char c : word1.toCharArray()){\\n            str[c-\\'a\\']++;\\n        }\\n        for(char c: word2.toCharArray()){\\n            str[c-\\'a\\']--;\\n        }\\n        for(int i = 0; i<str.length;i++){\\n            if(str[i] >3 || str[i] < -3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int sum = 0;\\n        int[] str = new int[26];\\n        for(char c : word1.toCharArray()){\\n            str[c-\\'a\\']++;\\n        }\\n        for(char c: word2.toCharArray()){\\n            str[c-\\'a\\']--;\\n        }\\n        for(int i = 0; i<str.length;i++){\\n            if(str[i] >3 || str[i] < -3) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954329,
                "title": "very-easy-to-undarstand-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int count=0;\\n        int arr[26]={0};\\n        int brr[26]={0};\\n        for(int i=0;i<word1.size();i++){\\n            arr[word1[i]-\\'a\\']++;\\n            brr[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(abs( arr[i]-brr[i]) > 3 ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int count=0;\\n        int arr[26]={0};\\n        int brr[26]={0};\\n        for(int i=0;i<word1.size();i++){\\n            arr[word1[i]-\\'a\\']++;\\n            brr[word2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(abs( arr[i]-brr[i]) > 3 ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954251,
                "title": "easiest-and-simple-java-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Simplest approach\\n\\n# Complexity\\n- Time complexity: 1ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 40.52MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] arr1=new int[26];\\n        int[] arr2=new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            arr1[word1.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            arr2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<arr1.length;i++){\\n            if(Math.abs(arr1[i]-arr2[i])>3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] arr1=new int[26];\\n        int[] arr2=new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            arr1[word1.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            arr2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<arr1.length;i++){\\n            if(Math.abs(arr1[i]-arr2[i])>3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953710,
                "title": "very-easy-solution-java",
                "content": "# Intuition\\n\\n\\n# Approach\\nUsed two frequency counter.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String w1, String w2) {\\n        char[] ch = new char[26];\\n        char[] ch1 = new char[26];\\n\\n        for(int i=0;i<w1.length();i++){\\n            ch[w1.charAt(i)-\\'a\\']++;\\n            ch1[w2.charAt(i)-\\'a\\']++;\\n        }\\n\\n        for(int i=0;i<26;i++){\\n             if((ch[i] - ch1[i]) > 3 || (ch[i] - ch1[i]) < -3){\\n                 return false;\\n             }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String w1, String w2) {\\n        char[] ch = new char[26];\\n        char[] ch1 = new char[26];\\n\\n        for(int i=0;i<w1.length();i++){\\n            ch[w1.charAt(i)-\\'a\\']++;\\n            ch1[w2.charAt(i)-\\'a\\']++;\\n        }\\n\\n        for(int i=0;i<26;i++){\\n             if((ch[i] - ch1[i]) > 3 || (ch[i] - ch1[i]) < -3){\\n                 return false;\\n             }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948871,
                "title": "the-beast-and-the-best-explanation-simplest-one",
                "content": "# Intuition\\n- Check the absolute difference between the alphabets for two words. \\n- True Case\\n    - word1 = \\'abcd\\', word2 = \\'aabb\\'\\n    - The character appearing are a, b, c, d\\n    - a appears 1 time in word1 and 2 times in word2: abs(1-2) = 1\\n    - b appears 1 time in word1 and 2 times in word2: abs(1-2) = 1\\n    - c appears 1 time in word1 and 0 times in word2: abs(1-0) = 1\\n    - d appears 1 time in word1 and 0 times in word2: abs(1-0) = 1\\n    - Here, the absolute difference never exceeds 3, so these two strings are almost equivalent and return True.\\n- False Case\\n    - word1 = \\'abcabbba\\', word2 = \\'aacbcccc\\'\\n    - The character appearing are a, b, c, d\\n    - a appears 3 times in word1 and 2 times in word2: abs(3-2) = 1\\n    - b appears 4 times in word1 and 1 time in word2: abs(4-1) = 3\\n    - c appears 1 time in word1 and 5 times in word2: abs(1-5) = 4\\n    - Here, the absolute difference for the alphabet \\'c\\' exceeds 3, so these two strings are not equivalent and return False.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create the dictionary for both the words to get the count of occurrence of the characters in the word.\\n    - Example: word = \\'abca\\'\\n    - `Counter(word)` will have {\\'a\\': 2, \\'b\\': 1, \\'c\\': 1}\\n- `string.asciii_lowercase` is a list of all the alphabets in lowercase.\\n    - It contains a, b, c, d, ......, x, y, z.\\n- We just have to iterate over these alphabets and check,\\n    - if an alphabet exists in a word\\n    - check the count of occurence in both the word \\n        - if there absolute difference is less than 3, then no problem and continue for the next alphabet.\\n        - but if more than 3, then return `False`.\\n- If we were able to iterate over all the alphabets that means no alphabet has absolute difference more than 3, return `True`..   \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n\\n        for char in string.ascii_lowercase:\\n            if abs(c1[char] - c2[char]) > 3:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n\\n        for char in string.ascii_lowercase:\\n            if abs(c1[char] - c2[char]) > 3:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948147,
                "title": "check-whether-two-strings-are-almost-equivalent-easy-approach-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char, int> m1;\\n        map<char, int> m2;\\n        for(int i=0;i<word1.size();i++){\\n            m1[word1[i]]++;\\n        }\\n        for(int i=0;i<word2.size();i++){\\n            m2[word2[i]]++;\\n        }\\n        string word=word1+word2;\\n        set<char> s(word.begin(),word.end());\\n        for(char i:s){\\n            if(abs(m1[i]-m2[i])>3){\\n                return false;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char, int> m1;\\n        map<char, int> m2;\\n        for(int i=0;i<word1.size();i++){\\n            m1[word1[i]]++;\\n        }\\n        for(int i=0;i<word2.size();i++){\\n            m2[word2[i]]++;\\n        }\\n        string word=word1+word2;\\n        set<char> s(word.begin(),word.end());\\n        for(char i:s){\\n            if(abs(m1[i]-m2[i])>3){\\n                return false;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943316,
                "title": "java-it-s-time-to-embrace-streaming-style",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        final int K = 3;\\n        Map<Character, Integer> freq1 = new HashMap();\\n        Map<Character, Integer> freq2 = new HashMap();\\n        for (char c: word1.toCharArray())\\n            freq1.put(c, freq1.getOrDefault(c, 0)+1);\\n\\n        for (char c: word2.toCharArray())\\n            freq2.put(c, freq2.getOrDefault(c, 0)+1);\\n\\n        Map<Character, Integer> newMap = Stream.of(freq1, freq2)\\n                .flatMap(map->map.entrySet().stream())\\n                .collect(Collectors.toMap(\\n                        Map.Entry::getKey,\\n                        Map.Entry::getValue,\\n                        (o1, o2) -> Math.abs(o1 - o2)\\n                        )\\n                );\\n        \\n        for (var entry: newMap.entrySet()) {\\n            if (entry.getValue() > K)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        final int K = 3;\\n        Map<Character, Integer> freq1 = new HashMap();\\n        Map<Character, Integer> freq2 = new HashMap();\\n        for (char c: word1.toCharArray())\\n            freq1.put(c, freq1.getOrDefault(c, 0)+1);\\n\\n        for (char c: word2.toCharArray())\\n            freq2.put(c, freq2.getOrDefault(c, 0)+1);\\n\\n        Map<Character, Integer> newMap = Stream.of(freq1, freq2)\\n                .flatMap(map->map.entrySet().stream())\\n                .collect(Collectors.toMap(\\n                        Map.Entry::getKey,\\n                        Map.Entry::getValue,\\n                        (o1, o2) -> Math.abs(o1 - o2)\\n                        )\\n                );\\n        \\n        for (var entry: newMap.entrySet()) {\\n            if (entry.getValue() > K)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942356,
                "title": "o-n-simple-java-array-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] freq = new int[26];\\n        for(char c: word1.toCharArray()){\\n          freq[c-\\'a\\']++;\\n        }\\n        for(char c: word2.toCharArray()){\\n          freq[c-\\'a\\']--;\\n        }\\n        for(int c : freq){\\n           if (c > 3 || c < -3) { \\n                return false;\\n            }\\n        }\\n        return true;\\n            }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] freq = new int[26];\\n        for(char c: word1.toCharArray()){\\n          freq[c-\\'a\\']++;\\n        }\\n        for(char c: word2.toCharArray()){\\n          freq[c-\\'a\\']--;\\n        }\\n        for(int c : freq){\\n           if (c > 3 || c < -3) { \\n                return false;\\n            }\\n        }\\n        return true;\\n            }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936691,
                "title": "tc-o-m-n-sc-o-26-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n      int m=word1.length();\\n      int n=word2.length();\\n\\n      int freq1[]=new int[26];\\n      int freq2[]=new int[26];\\n\\n      for(int i=0;i<m;i++)\\n      {\\n          char ch=word1.charAt(i);\\n          freq1[ch-\\'a\\']++;\\n      }\\n\\n      for(int i=0;i<n;i++)\\n      {\\n          char ch=word2.charAt(i);\\n          freq2[ch-\\'a\\']++;\\n      }\\n\\n      for(int i=0;i<26;i++){\\n          if(Math.abs(freq1[i]-freq2[i])>3)\\n          {\\n              return false;\\n          }\\n\\n      }\\n\\nreturn true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n      int m=word1.length();\\n      int n=word2.length();\\n\\n      int freq1[]=new int[26];\\n      int freq2[]=new int[26];\\n\\n      for(int i=0;i<m;i++)\\n      {\\n          char ch=word1.charAt(i);\\n          freq1[ch-\\'a\\']++;\\n      }\\n\\n      for(int i=0;i<n;i++)\\n      {\\n          char ch=word2.charAt(i);\\n          freq2[ch-\\'a\\']++;\\n      }\\n\\n      for(int i=0;i<26;i++){\\n          if(Math.abs(freq1[i]-freq2[i])>3)\\n          {\\n              return false;\\n          }\\n\\n      }\\n\\nreturn true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936085,
                "title": "counter-and-set",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        c1, c2 = Counter(word1), Counter(word2)\\n        return all(abs(c1[c]-c2[c]) <= 3 for c in set(c1.keys()) | set(c2.keys()) )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        c1, c2 = Counter(word1), Counter(word2)\\n        return all(abs(c1[c]-c2[c]) <= 3 for c in set(c1.keys()) | set(c2.keys()) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934426,
                "title": "java-simple-without-hashmap",
                "content": "class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] arr = new int[26];\\n        \\n        for(int i=0;i<word1.length();i++) {\\n            arr[word1.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<word2.length();i++) {\\n            arr[word2.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for(int x : arr) {\\n            if(Math.abs(x) > 3) return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] arr = new int[26];\\n        \\n        for(int i=0;i<word1.length();i++) {\\n            arr[word1.charAt(i) - \\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3933401,
                "title": "solution-using-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char , int> mp1;\\n        map<char , int> mp2;\\n        for(auto i:word1){\\n            mp1[i]++;\\n        }\\n        for(auto i:word2){\\n            mp2[i]++;\\n        }\\n\\n        for(auto it:mp1){\\n            char key=it.first;\\n            int va1=it.second;\\n\\n            int va2=mp2[key];\\n\\n            if(abs(va1-va2)>3){\\n                return false;\\n            }\\n        }\\n\\n        for(auto it:mp2){\\n            char key=it.first;\\n            int va1=it.second;\\n\\n            if(mp1.find(key)==mp1.end()){\\n                if(va1>3){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        map<char , int> mp1;\\n        map<char , int> mp2;\\n        for(auto i:word1){\\n            mp1[i]++;\\n        }\\n        for(auto i:word2){\\n            mp2[i]++;\\n        }\\n\\n        for(auto it:mp1){\\n            char key=it.first;\\n            int va1=it.second;\\n\\n            int va2=mp2[key];\\n\\n            if(abs(va1-va2)>3){\\n                return false;\\n            }\\n        }\\n\\n        for(auto it:mp2){\\n            char key=it.first;\\n            int va1=it.second;\\n\\n            if(mp1.find(key)==mp1.end()){\\n                if(va1>3){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929648,
                "title": "beats-100-unordered-map-basic-solutiion",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<char , int >m1;\\n        for(int i=0;i<word1.length();i++){\\n            m1[word1[i]]++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            m1[word2[i]]--;\\n        }\\n         for(auto i:m1){\\n             if(abs(i.second)>3)return false;\\n         }\\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<char , int >m1;\\n        for(int i=0;i<word1.length();i++){\\n            m1[word1[i]]++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            m1[word2[i]]--;\\n        }\\n         for(auto i:m1){\\n             if(abs(i.second)>3)return false;\\n         }\\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925743,
                "title": "java-beginner-friendly-approach-using-hashmap-3ms",
                "content": "\\n# PLEASE UPVOTE\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n        for(int i=0;i<word1.length();i++){\\n            if(map.containsKey(word1.charAt(i))){\\n                map.put(word1.charAt(i),map.get(word1.charAt(i))+1);\\n            }else{\\n                map.put(word1.charAt(i),1);\\n            }\\n        }\\n        for(int j=0;j<word2.length();j++){\\n            if(map.containsKey(word2.charAt(j))){\\n                map.put(word2.charAt(j),map.get(word2.charAt(j))-1);\\n            }else{\\n                map.put(word2.charAt(j),-1);\\n            }\\n        }\\n        String word=word1+word2;\\n        int n=word1.length()+word2.length();\\n        for(int g=0;g<n;g++){\\n            if((map.get(word.charAt(g))>3)||(map.get(word.charAt(g))<-3)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n        for(int i=0;i<word1.length();i++){\\n            if(map.containsKey(word1.charAt(i))){\\n                map.put(word1.charAt(i),map.get(word1.charAt(i))+1);\\n            }else{\\n                map.put(word1.charAt(i),1);\\n            }\\n        }\\n        for(int j=0;j<word2.length();j++){\\n            if(map.containsKey(word2.charAt(j))){\\n                map.put(word2.charAt(j),map.get(word2.charAt(j))-1);\\n            }else{\\n                map.put(word2.charAt(j),-1);\\n            }\\n        }\\n        String word=word1+word2;\\n        int n=word1.length()+word2.length();\\n        for(int g=0;g<n;g++){\\n            if((map.get(word.charAt(g))>3)||(map.get(word.charAt(g))<-3)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911535,
                "title": "2068-easy-solution-using-character-frequency-analysis",
                "content": "# Intuition\\nThe intuition behind this code lies in the concept of comparing the frequency distribution of characters between two strings to determine if they are \"almost equivalent\" as per the given criteria. Here\\'s a breakdown of the intuition:\\n\\n1. **Frequency Counting**: The code starts by counting the frequency of characters in both input strings `word1` and `word2`. This is done using two arrays `arr1` and `arr2` of size 26, where each index corresponds to a lowercase English letter (\\'a\\' to \\'z\\'). The idea is to track how many times each character appears in both words.\\n\\n2. **Finding Maximum Difference**: After counting the frequencies, the code iterates through both frequency arrays and calculates the absolute difference between the frequencies of each character at the same index. This difference represents how many times a character appears more or less in one word compared to the other.\\n\\n3. **Determining Almost Equivalence**: The maximum difference among all characters is stored in the variable `c`. According to the problem\\'s condition, if this maximum difference is less than or equal to 3, then the words are considered \"almost equivalent.\"\\n\\n4. **Return Result**: The code checks if `c` is within the specified limit. If it is, the function returns `true`, indicating that the two words are almost equivalent. Otherwise, it returns `false`.\\n\\nThe intuition here is based on the observation that if the differences in character frequencies between the two words are relatively small (within the limit of 3), then the words are likely to be closely related or almost equivalent. This approach abstracts the character frequency analysis, making it a simple way to determine the similarity between words based on their characters\\' distribution.\\n\\n# Approach\\n\\nThe given code defines a function `checkAlmostEquivalent` that takes two strings, `word1` and `word2`, as input and determines if the strings are almost equivalent based on a certain criterion. Here\\'s the approach of the code:\\n\\n1. Initialize variables:\\n   - `s` to store the size of the input strings.\\n   - `c` to store the maximum difference count between corresponding characters in the two words. Initialize it with 3.\\n   - Two arrays `arr1` and `arr2` of size 26 (representing the 26 lowercase English letters), initialized with all zeros.\\n\\n2. Iterate through each character in the input strings `word1` and `word2`:\\n   - Increment the corresponding element in `arr1` for `word1[i]`.\\n   - Increment the corresponding element in `arr2` for `word2[i]`.\\n\\n3. Iterate through the arrays `arr1` and `arr2` (size 26):\\n   - Calculate the absolute difference between `arr1[i]` and `arr2[i]`.\\n   - Update `c` if this difference is greater than the current value of `c`.\\n\\n4. Check if `c` is less than or equal to 3. If yes, return `true`, indicating that the two words are almost equivalent. Otherwise, return `false`.\\n\\nThe code focuses on counting the occurrences of each character in both words and then comparing the occurrence counts to determine if the words are almost equivalent based on the given criterion.\\n\\nThis approach aims to find the differences between the frequencies of each character in both words and checks if the maximum difference is within the specified limit. If it is, then the function returns `true`, indicating that the words are almost equivalent. Otherwise, it returns `false`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int s = word1.size();\\n        int c=3;\\n        int arr1[26]={0};\\n        int arr2[26]={0};\\n        // cout<<endl;\\n\\n        for(int i=0;i<s;i++){\\n            // int x=word1[i]-\\'a\\';\\n            // int y=word2[i]-\\'a\\';\\n\\n            arr1[word1[i]-\\'a\\']++;\\n            arr2[word2[i]-\\'a\\']++;\\n        }\\n\\n        for(int i=0;i<26;i++){\\n            if(abs(arr1[i]-arr2[i])>c){\\n                c= abs(arr1[i]-arr2[i]);\\n            }\\n        }\\n        // // to check arr number \\n        // for(int d:arr1){\\n        //     cout<<d<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int d:arr2){\\n        //     cout<<d<<\" \";\\n        // }\\n\\n        // We can use flag also if we don\\'t need most value\\n        // cout<<c<<endl;\\n        if(c<=3){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        int s = word1.size();\\n        int c=3;\\n        int arr1[26]={0};\\n        int arr2[26]={0};\\n        // cout<<endl;\\n\\n        for(int i=0;i<s;i++){\\n            // int x=word1[i]-\\'a\\';\\n            // int y=word2[i]-\\'a\\';\\n\\n            arr1[word1[i]-\\'a\\']++;\\n            arr2[word2[i]-\\'a\\']++;\\n        }\\n\\n        for(int i=0;i<26;i++){\\n            if(abs(arr1[i]-arr2[i])>c){\\n                c= abs(arr1[i]-arr2[i]);\\n            }\\n        }\\n        // // to check arr number \\n        // for(int d:arr1){\\n        //     cout<<d<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int d:arr2){\\n        //     cout<<d<<\" \";\\n        // }\\n\\n        // We can use flag also if we don\\'t need most value\\n        // cout<<c<<endl;\\n        if(c<=3){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3909174,
                "title": "easy-solution-using-java",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] charFrequency = new int[26];\\n        for(int i = 0; i<word1.length(); i++){\\n            charFrequency[word1.charAt(i)-\\'a\\']++;\\n            charFrequency[word2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int freq : charFrequency){\\n            if(Math.abs(freq) > 3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] charFrequency = new int[26];\\n        for(int i = 0; i<word1.length(); i++){\\n            charFrequency[word1.charAt(i)-\\'a\\']++;\\n            charFrequency[word2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int freq : charFrequency){\\n            if(Math.abs(freq) > 3){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904865,
                "title": "0ms-beats-100-very-easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] arr = new int[26];\\n        for(char ch: word1.toCharArray()) {\\n            arr[ch-97]++;\\n        }\\n\\n        for(char ch: word2.toCharArray()) {\\n            arr[ch-97]--;\\n        }\\n\\n        for(int i = 0;i<26; i++) {\\n            if(arr[i] >3 || arr[i] <-3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        int[] arr = new int[26];\\n        for(char ch: word1.toCharArray()) {\\n            arr[ch-97]++;\\n        }\\n\\n        for(char ch: word2.toCharArray()) {\\n            arr[ch-97]--;\\n        }\\n\\n        for(int i = 0;i<26; i++) {\\n            if(arr[i] >3 || arr[i] <-3) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884399,
                "title": "easy-java-soltution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character,Integer> map = new HashMap();\\n        for (int i = 0; i < word1.length(); i++) {\\n            map.put(word1.charAt(i), map.getOrDefault(word1.charAt(i), 0) + 1);\\n            map.put(word2.charAt(i), map.getOrDefault(word2.charAt(i), 0) - 1);\\n        }\\n        for (int i : map.values()) { //get value set\\n            if (i > 3 || i < -3) { \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        Map<Character,Integer> map = new HashMap();\\n        for (int i = 0; i < word1.length(); i++) {\\n            map.put(word1.charAt(i), map.getOrDefault(word1.charAt(i), 0) + 1);\\n            map.put(word2.charAt(i), map.getOrDefault(word2.charAt(i), 0) - 1);\\n        }\\n        for (int i : map.values()) { //get value set\\n            if (i > 3 || i < -3) { \\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877715,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(unordered_map<char, int>m1, unordered_map<char, int>m2){\\n        for(auto it = m1.begin(); it != m1.end(); it++){\\n            auto it2 = m2.find(it->first);\\n            if(it2 != m2.end()){\\n                if(abs(it2->second-it->second) > 3){\\n                    return false;\\n                }\\n            }else{\\n                if(it->second > 3){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<char, int>m1;\\n        unordered_map<char, int> m2;\\n        for(int i=0; i<word1.size(); i++){\\n            m1[word1[i]]++;\\n            m2[word2[i]]++;\\n        }\\n        return check(m1, m2) && check(m2, m1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(unordered_map<char, int>m1, unordered_map<char, int>m2){\\n        for(auto it = m1.begin(); it != m1.end(); it++){\\n            auto it2 = m2.find(it->first);\\n            if(it2 != m2.end()){\\n                if(abs(it2->second-it->second) > 3){\\n                    return false;\\n                }\\n            }else{\\n                if(it->second > 3){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool checkAlmostEquivalent(string word1, string word2) {\\n        unordered_map<char, int>m1;\\n        unordered_map<char, int> m2;\\n        for(int i=0; i<word1.size(); i++){\\n            m1[word1[i]]++;\\n            m2[word2[i]]++;\\n        }\\n        return check(m1, m2) && check(m2, m1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873950,
                "title": "python-simple-and-fast-hash-table-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        \\n        # Create dictionaries for both words and a unified one\\n\\n        dict_word1 = dict.fromkeys(word1, 0)\\n        dict_word2 = dict.fromkeys(word2, 0)\\n\\n        for char in word1:\\n            dict_word1[char] += 1\\n\\n        for char in word2:\\n            dict_word2[char] += 1\\n\\n        dict_united = dict_word1 | dict_word2\\n\\n\\n        # Test cases: \\n        #1) no key in one dictionary \\n        #2) both keys are present, values are different by more than 3\\n        \\n        for key in dict_united:\\n            if (key not in dict_word1):\\n                if (dict_united[key] > 3):\\n                    return False\\n            elif (key not in dict_word2):\\n                if (dict_united[key] > 3):\\n                    return False\\n            elif (abs(dict_word1[key] - dict_word2[key]) > 3):\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        \\n        # Create dictionaries for both words and a unified one\\n\\n        dict_word1 = dict.fromkeys(word1, 0)\\n        dict_word2 = dict.fromkeys(word2, 0)\\n\\n        for char in word1:\\n            dict_word1[char] += 1\\n\\n        for char in word2:\\n            dict_word2[char] += 1\\n\\n        dict_united = dict_word1 | dict_word2\\n\\n\\n        # Test cases: \\n        #1) no key in one dictionary \\n        #2) both keys are present, values are different by more than 3\\n        \\n        for key in dict_united:\\n            if (key not in dict_word1):\\n                if (dict_united[key] > 3):\\n                    return False\\n            elif (key not in dict_word2):\\n                if (dict_united[key] > 3):\\n                    return False\\n            elif (abs(dict_word1[key] - dict_word2[key]) > 3):\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854547,
                "title": "java-o-n-functions",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst get frequency map of both the string\\ni)Check for difference of atmost 3 condition from string1 to string2\\niI)Check for difference of atmost 3 condition from string2 to string1\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n\\n        frequecyMap(word1,hm1);\\n        frequecyMap(word2,hm2);\\n            \\n        return check(hm1,hm2) && check(hm2,hm1);\\n    }\\n    private void frequecyMap(String word1 , HashMap<Character,Integer> hm1){\\n        for(int i=0;i<word1.length();i++){\\n            char ch = word1.charAt(i);\\n            if(hm1.containsKey(ch)){\\n                hm1.put(ch , hm1.get(ch)+1);\\n            }else{\\n                hm1.put(ch , 1);\\n            }\\n        }\\n    }\\n    private boolean check(HashMap<Character,Integer> hm2 , HashMap<Character,Integer> hm1){\\n        for(Map.Entry<Character,Integer> e : hm2.entrySet()){\\n            char ch = e.getKey();\\n            int val = hm1.containsKey(ch) ? hm1.get(ch) : 0;\\n            if(Math.abs(e.getValue() - val ) > 3 ){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkAlmostEquivalent(String word1, String word2) {\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n\\n        frequecyMap(word1,hm1);\\n        frequecyMap(word2,hm2);\\n            \\n        return check(hm1,hm2) && check(hm2,hm1);\\n    }\\n    private void frequecyMap(String word1 , HashMap<Character,Integer> hm1){\\n        for(int i=0;i<word1.length();i++){\\n            char ch = word1.charAt(i);\\n            if(hm1.containsKey(ch)){\\n                hm1.put(ch , hm1.get(ch)+1);\\n            }else{\\n                hm1.put(ch , 1);\\n            }\\n        }\\n    }\\n    private boolean check(HashMap<Character,Integer> hm2 , HashMap<Character,Integer> hm1){\\n        for(Map.Entry<Character,Integer> e : hm2.entrySet()){\\n            char ch = e.getKey();\\n            int val = hm1.containsKey(ch) ? hm1.get(ch) : 0;\\n            if(Math.abs(e.getValue() - val ) > 3 ){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852564,
                "title": "python-solution-faster-than-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n\\n        def compare(c1, c2):\\n            for (num, count) in c1.items():\\n                if not c2[num]:\\n                    c2[num] = 0\\n                if abs(c2[num] - count) > 3:\\n                    return False\\n            return True\\n\\n        c1 = collections.Counter(word1)\\n        c2 = collections.Counter(word2)\\n        result = compare(c1, c2) and compare(c2, c1)\\n        return result\\n      \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n\\n        def compare(c1, c2):\\n            for (num, count) in c1.items():\\n                if not c2[num]:\\n                    c2[num] = 0\\n                if abs(c2[num] - count) > 3:\\n                    return False\\n            return True\\n\\n        c1 = collections.Counter(word1)\\n        c2 = collections.Counter(word2)\\n        result = compare(c1, c2) and compare(c2, c1)\\n        return result\\n      \\n        \\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1752766,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "1. One frequency counter is enough. (Increment for word1 and decrement for word2 characters.)\\n2. Array[26] works faster than Map."
                    },
                    {
                        "username": "topswe",
                        "content": "use two frequency counters."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "Here is an example of how to do it more efficiently:\\nhttps://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/solutions/3008309/c-the-simplest-shortest-efficient-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : \\uFF23\\uFF4F\\uFF55\\uFF4E\\uFF54\\uFF45\\uFF52\\uFF08\\uFF09"
                    },
                    {
                        "username": "siaaam",
                        "content": "91 / 196 testcases passed\\nword1 =\"aaaa\"\\nword2 =\"aaaa\"\\nOutput: false\\nExpected: true\\n\\nwhy expected: true ? there are 4 \\'a\\' and the diff between \\'a\\' is 0 but the ques says that if it is 3 then true. It\\'s clearly 0 then it is true, not false ?"
                    },
                    {
                        "username": "SumitRT",
                        "content": "\"at most 3\" not exactly 3"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "I am using below code : \\n`for i in set(word1) :`\\n-----|`if abs(word1.count(i) - word2.count(i)) < 4 :`\\n----------|`return True`\\n-----|`return False` \\n\\nBut still getting error in 1 hidden test case that is :\\n`word1 = \\'aaaab\\'`\\n`word2 = \\'zzzza\\'`\\n`Output = True`\\n`Expected = False`\\n\\nI also tried it with single hashmap but still getting this test case failed!"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "There are 4 \"z\" in word2, and 0 \"z\" in word1, so the difference is 4  -> return false.\\n\\nSPOILER: \\nWhat I did was keeping track of the letters in a array<int,26>, where 0 == a, 1 == b, and so on. Then every time I found a letter in word1 I added to that letters position in the array, and did the opposite (subtracted) for every letter in word2.\\n\\nThen, in the end, you just iterate through the array and return false if abs(array[i]) > 3."
                    },
                    {
                        "username": "IHxRK28",
                        "content": "Try doing in one Map  "
                    },
                    {
                        "username": "esantalone",
                        "content": "use hashmap to count frequencies of each character. increment when in first word, decrement in second word"
                    }
                ]
            },
            {
                "id": 1693383,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "1. One frequency counter is enough. (Increment for word1 and decrement for word2 characters.)\\n2. Array[26] works faster than Map."
                    },
                    {
                        "username": "topswe",
                        "content": "use two frequency counters."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "Here is an example of how to do it more efficiently:\\nhttps://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/solutions/3008309/c-the-simplest-shortest-efficient-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : \\uFF23\\uFF4F\\uFF55\\uFF4E\\uFF54\\uFF45\\uFF52\\uFF08\\uFF09"
                    },
                    {
                        "username": "siaaam",
                        "content": "91 / 196 testcases passed\\nword1 =\"aaaa\"\\nword2 =\"aaaa\"\\nOutput: false\\nExpected: true\\n\\nwhy expected: true ? there are 4 \\'a\\' and the diff between \\'a\\' is 0 but the ques says that if it is 3 then true. It\\'s clearly 0 then it is true, not false ?"
                    },
                    {
                        "username": "SumitRT",
                        "content": "\"at most 3\" not exactly 3"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "I am using below code : \\n`for i in set(word1) :`\\n-----|`if abs(word1.count(i) - word2.count(i)) < 4 :`\\n----------|`return True`\\n-----|`return False` \\n\\nBut still getting error in 1 hidden test case that is :\\n`word1 = \\'aaaab\\'`\\n`word2 = \\'zzzza\\'`\\n`Output = True`\\n`Expected = False`\\n\\nI also tried it with single hashmap but still getting this test case failed!"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "There are 4 \"z\" in word2, and 0 \"z\" in word1, so the difference is 4  -> return false.\\n\\nSPOILER: \\nWhat I did was keeping track of the letters in a array<int,26>, where 0 == a, 1 == b, and so on. Then every time I found a letter in word1 I added to that letters position in the array, and did the opposite (subtracted) for every letter in word2.\\n\\nThen, in the end, you just iterate through the array and return false if abs(array[i]) > 3."
                    },
                    {
                        "username": "IHxRK28",
                        "content": "Try doing in one Map  "
                    },
                    {
                        "username": "esantalone",
                        "content": "use hashmap to count frequencies of each character. increment when in first word, decrement in second word"
                    }
                ]
            },
            {
                "id": 1979661,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "1. One frequency counter is enough. (Increment for word1 and decrement for word2 characters.)\\n2. Array[26] works faster than Map."
                    },
                    {
                        "username": "topswe",
                        "content": "use two frequency counters."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "Here is an example of how to do it more efficiently:\\nhttps://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/solutions/3008309/c-the-simplest-shortest-efficient-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : \\uFF23\\uFF4F\\uFF55\\uFF4E\\uFF54\\uFF45\\uFF52\\uFF08\\uFF09"
                    },
                    {
                        "username": "siaaam",
                        "content": "91 / 196 testcases passed\\nword1 =\"aaaa\"\\nword2 =\"aaaa\"\\nOutput: false\\nExpected: true\\n\\nwhy expected: true ? there are 4 \\'a\\' and the diff between \\'a\\' is 0 but the ques says that if it is 3 then true. It\\'s clearly 0 then it is true, not false ?"
                    },
                    {
                        "username": "SumitRT",
                        "content": "\"at most 3\" not exactly 3"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "I am using below code : \\n`for i in set(word1) :`\\n-----|`if abs(word1.count(i) - word2.count(i)) < 4 :`\\n----------|`return True`\\n-----|`return False` \\n\\nBut still getting error in 1 hidden test case that is :\\n`word1 = \\'aaaab\\'`\\n`word2 = \\'zzzza\\'`\\n`Output = True`\\n`Expected = False`\\n\\nI also tried it with single hashmap but still getting this test case failed!"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "There are 4 \"z\" in word2, and 0 \"z\" in word1, so the difference is 4  -> return false.\\n\\nSPOILER: \\nWhat I did was keeping track of the letters in a array<int,26>, where 0 == a, 1 == b, and so on. Then every time I found a letter in word1 I added to that letters position in the array, and did the opposite (subtracted) for every letter in word2.\\n\\nThen, in the end, you just iterate through the array and return false if abs(array[i]) > 3."
                    },
                    {
                        "username": "IHxRK28",
                        "content": "Try doing in one Map  "
                    },
                    {
                        "username": "esantalone",
                        "content": "use hashmap to count frequencies of each character. increment when in first word, decrement in second word"
                    }
                ]
            },
            {
                "id": 1960963,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "1. One frequency counter is enough. (Increment for word1 and decrement for word2 characters.)\\n2. Array[26] works faster than Map."
                    },
                    {
                        "username": "topswe",
                        "content": "use two frequency counters."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "Here is an example of how to do it more efficiently:\\nhttps://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/solutions/3008309/c-the-simplest-shortest-efficient-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : \\uFF23\\uFF4F\\uFF55\\uFF4E\\uFF54\\uFF45\\uFF52\\uFF08\\uFF09"
                    },
                    {
                        "username": "siaaam",
                        "content": "91 / 196 testcases passed\\nword1 =\"aaaa\"\\nword2 =\"aaaa\"\\nOutput: false\\nExpected: true\\n\\nwhy expected: true ? there are 4 \\'a\\' and the diff between \\'a\\' is 0 but the ques says that if it is 3 then true. It\\'s clearly 0 then it is true, not false ?"
                    },
                    {
                        "username": "SumitRT",
                        "content": "\"at most 3\" not exactly 3"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "I am using below code : \\n`for i in set(word1) :`\\n-----|`if abs(word1.count(i) - word2.count(i)) < 4 :`\\n----------|`return True`\\n-----|`return False` \\n\\nBut still getting error in 1 hidden test case that is :\\n`word1 = \\'aaaab\\'`\\n`word2 = \\'zzzza\\'`\\n`Output = True`\\n`Expected = False`\\n\\nI also tried it with single hashmap but still getting this test case failed!"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "There are 4 \"z\" in word2, and 0 \"z\" in word1, so the difference is 4  -> return false.\\n\\nSPOILER: \\nWhat I did was keeping track of the letters in a array<int,26>, where 0 == a, 1 == b, and so on. Then every time I found a letter in word1 I added to that letters position in the array, and did the opposite (subtracted) for every letter in word2.\\n\\nThen, in the end, you just iterate through the array and return false if abs(array[i]) > 3."
                    },
                    {
                        "username": "IHxRK28",
                        "content": "Try doing in one Map  "
                    },
                    {
                        "username": "esantalone",
                        "content": "use hashmap to count frequencies of each character. increment when in first word, decrement in second word"
                    }
                ]
            },
            {
                "id": 1739068,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "1. One frequency counter is enough. (Increment for word1 and decrement for word2 characters.)\\n2. Array[26] works faster than Map."
                    },
                    {
                        "username": "topswe",
                        "content": "use two frequency counters."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "Here is an example of how to do it more efficiently:\\nhttps://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/solutions/3008309/c-the-simplest-shortest-efficient-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : \\uFF23\\uFF4F\\uFF55\\uFF4E\\uFF54\\uFF45\\uFF52\\uFF08\\uFF09"
                    },
                    {
                        "username": "siaaam",
                        "content": "91 / 196 testcases passed\\nword1 =\"aaaa\"\\nword2 =\"aaaa\"\\nOutput: false\\nExpected: true\\n\\nwhy expected: true ? there are 4 \\'a\\' and the diff between \\'a\\' is 0 but the ques says that if it is 3 then true. It\\'s clearly 0 then it is true, not false ?"
                    },
                    {
                        "username": "SumitRT",
                        "content": "\"at most 3\" not exactly 3"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "I am using below code : \\n`for i in set(word1) :`\\n-----|`if abs(word1.count(i) - word2.count(i)) < 4 :`\\n----------|`return True`\\n-----|`return False` \\n\\nBut still getting error in 1 hidden test case that is :\\n`word1 = \\'aaaab\\'`\\n`word2 = \\'zzzza\\'`\\n`Output = True`\\n`Expected = False`\\n\\nI also tried it with single hashmap but still getting this test case failed!"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "There are 4 \"z\" in word2, and 0 \"z\" in word1, so the difference is 4  -> return false.\\n\\nSPOILER: \\nWhat I did was keeping track of the letters in a array<int,26>, where 0 == a, 1 == b, and so on. Then every time I found a letter in word1 I added to that letters position in the array, and did the opposite (subtracted) for every letter in word2.\\n\\nThen, in the end, you just iterate through the array and return false if abs(array[i]) > 3."
                    },
                    {
                        "username": "IHxRK28",
                        "content": "Try doing in one Map  "
                    },
                    {
                        "username": "esantalone",
                        "content": "use hashmap to count frequencies of each character. increment when in first word, decrement in second word"
                    }
                ]
            },
            {
                "id": 1707078,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "1. One frequency counter is enough. (Increment for word1 and decrement for word2 characters.)\\n2. Array[26] works faster than Map."
                    },
                    {
                        "username": "topswe",
                        "content": "use two frequency counters."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "Here is an example of how to do it more efficiently:\\nhttps://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/solutions/3008309/c-the-simplest-shortest-efficient-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : \\uFF23\\uFF4F\\uFF55\\uFF4E\\uFF54\\uFF45\\uFF52\\uFF08\\uFF09"
                    },
                    {
                        "username": "siaaam",
                        "content": "91 / 196 testcases passed\\nword1 =\"aaaa\"\\nword2 =\"aaaa\"\\nOutput: false\\nExpected: true\\n\\nwhy expected: true ? there are 4 \\'a\\' and the diff between \\'a\\' is 0 but the ques says that if it is 3 then true. It\\'s clearly 0 then it is true, not false ?"
                    },
                    {
                        "username": "SumitRT",
                        "content": "\"at most 3\" not exactly 3"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "I am using below code : \\n`for i in set(word1) :`\\n-----|`if abs(word1.count(i) - word2.count(i)) < 4 :`\\n----------|`return True`\\n-----|`return False` \\n\\nBut still getting error in 1 hidden test case that is :\\n`word1 = \\'aaaab\\'`\\n`word2 = \\'zzzza\\'`\\n`Output = True`\\n`Expected = False`\\n\\nI also tried it with single hashmap but still getting this test case failed!"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "There are 4 \"z\" in word2, and 0 \"z\" in word1, so the difference is 4  -> return false.\\n\\nSPOILER: \\nWhat I did was keeping track of the letters in a array<int,26>, where 0 == a, 1 == b, and so on. Then every time I found a letter in word1 I added to that letters position in the array, and did the opposite (subtracted) for every letter in word2.\\n\\nThen, in the end, you just iterate through the array and return false if abs(array[i]) > 3."
                    },
                    {
                        "username": "IHxRK28",
                        "content": "Try doing in one Map  "
                    },
                    {
                        "username": "esantalone",
                        "content": "use hashmap to count frequencies of each character. increment when in first word, decrement in second word"
                    }
                ]
            },
            {
                "id": 1700279,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "1. One frequency counter is enough. (Increment for word1 and decrement for word2 characters.)\\n2. Array[26] works faster than Map."
                    },
                    {
                        "username": "topswe",
                        "content": "use two frequency counters."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "Here is an example of how to do it more efficiently:\\nhttps://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/solutions/3008309/c-the-simplest-shortest-efficient-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : \\uFF23\\uFF4F\\uFF55\\uFF4E\\uFF54\\uFF45\\uFF52\\uFF08\\uFF09"
                    },
                    {
                        "username": "siaaam",
                        "content": "91 / 196 testcases passed\\nword1 =\"aaaa\"\\nword2 =\"aaaa\"\\nOutput: false\\nExpected: true\\n\\nwhy expected: true ? there are 4 \\'a\\' and the diff between \\'a\\' is 0 but the ques says that if it is 3 then true. It\\'s clearly 0 then it is true, not false ?"
                    },
                    {
                        "username": "SumitRT",
                        "content": "\"at most 3\" not exactly 3"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "I am using below code : \\n`for i in set(word1) :`\\n-----|`if abs(word1.count(i) - word2.count(i)) < 4 :`\\n----------|`return True`\\n-----|`return False` \\n\\nBut still getting error in 1 hidden test case that is :\\n`word1 = \\'aaaab\\'`\\n`word2 = \\'zzzza\\'`\\n`Output = True`\\n`Expected = False`\\n\\nI also tried it with single hashmap but still getting this test case failed!"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "There are 4 \"z\" in word2, and 0 \"z\" in word1, so the difference is 4  -> return false.\\n\\nSPOILER: \\nWhat I did was keeping track of the letters in a array<int,26>, where 0 == a, 1 == b, and so on. Then every time I found a letter in word1 I added to that letters position in the array, and did the opposite (subtracted) for every letter in word2.\\n\\nThen, in the end, you just iterate through the array and return false if abs(array[i]) > 3."
                    },
                    {
                        "username": "IHxRK28",
                        "content": "Try doing in one Map  "
                    },
                    {
                        "username": "esantalone",
                        "content": "use hashmap to count frequencies of each character. increment when in first word, decrement in second word"
                    }
                ]
            }
        ]
    }
]